{"id": "4l3SRr", "name": "Weird Lattice 2", "author": "aiekick", "description": "Weird Lattice", "tags": ["smooth", "cristal", "radclick", "latice"], "likes": 3, "viewed": 463, "published": "Public API", "date": "1477591947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n// count radial section. \n// with this you can have more section. \n// more sections need more id check, but the tech is exactly the same\nconst float sections = 4.; \t\n\n// some varas\nfloat time = 0.;\t\t\t\t// time\nfloat cid = 0., lid = 0.; \t// current id, last id\nmat3 m1;\t\t\t\t\t\t// matrix used by the pattern merging\nmat3 m2;\t\t\t\t\t\t// matrix used by the pattern merging\n\n// Matrix operations\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\n// tunnel and cam path\nvec2 path(float t){return vec2(cos(t*0.08), sin(t*0.08)) * 4.;}\n\n// continuous angle from atan\nfloat cAtan(vec2 uv)\n{\n\tfloat a = 0.;\n\tif (uv.x >= 0.) a = atan(uv.x, uv.y);\n    if (uv.x < 0.) a = 3.14159 - atan(uv.x, -uv.y);\n    return a;\n}\n\n// return id of region \nfloat GetID(vec2 uv) \n{\n    return cAtan(uv) * floor(sections) * .5 / 3.14159;\n}\n\n// one pettern for each ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat pattern(vec3 p, mat3 m, float s, float id)\n{\n\tfloat r = 0.;\n\tp = abs(fract(p*m*s) - 0.5);\n\tif (id > 3.) r= max(min(abs(p.x),abs(p.z)),abs(p.y));\n    else if (id > 2.) r= max(p.x,abs(p.y)+p.z);\n\telse if (id > 1.) r= length(p);\n    else if (id > 0.) r= max(p.x,-p.y);\n\treturn r;\n}\n\n// redirect dispalce func according to ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat displace(vec3 p, float id)\n{\n\tvec3 a = vec3(0), b = a;\n\tif (id > 3.) a = vec3(-0.32,0.5,.5), b = vec3(0);\n    else if (id > 2.) a = vec3(0.46,0.42,-1.5), b = vec3(0);\n    else if (id > 1.) a = vec3(0.36,0.2,-2.28), b = vec3(0.36,0.24,1.62);\n\telse if (id > 0.) a = vec3(0.62,0.62,-1.02), b = vec3(0);\n        \n    return \n        (1.-min(pattern(p, m1, a.x, id), pattern(p, m2, a.y, id))) * a.z + \n    \t(1.-min(pattern(p, m1, b.x, id), pattern(p, m2, b.y, id))) * b.z;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k = 1.;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\t\t\t\t\t\t\t\t\t\t\t\t\t// tunnel path\n\t\n    // mix from displace of last section id with displace of current section id accroding to id range \n    float r = mix(displace(p, lid), displace(p, cid), fract(cid)); \t// id range [0-1]\n\t\n    p *= getRotZMat(p.z*0.05);\n\t\n    p = mod(p, 10.) - 5.;\n    \n    // tunnel + dispalce\n\treturn vec4(smin(length(p.xz), abs(p.y)+2.) - 1. + r, p);\n}\n\nvec3 nor( vec3 pos, float k)\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn map(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// color arangement is what i choose\n// its easy to have another coloration wothout modified the lighting.\n// here is an easy way i choose, but you can do alterate more as you want\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nvec4 params(vec4 f, float id)\n{\n\tvec4 c = f;\n    if (id > 3.) c = f.zwyw; \n    else if (id > 2.) c = f.zyzw; \n    else if (id > 1.) c = f.yzyx; \n    else if (id > 0.) c = f.xyzw; \n    return c;\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.001, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// blackbody color according to the subdensity value\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\t\t\t\t\t// use bumpmap fnc of shane here\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 5.) * 0.5; \t\t\t\t\t// one step sub density of df\n\treturn vec4(\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// some mix of WTF :) i tried many different things and this i choose :) but maybe there is other things to do\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\n// get cam \n// g will be gl_FragCoord.xy or uMouse.xy\n//  si is screensize\nvec3 cam(vec2 g, vec2 si, vec3 ro, vec3 cv)\n{\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 cu = normalize(vec3(0,1,0) * getRotZMat(ro.z*-0.03));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n\t// matrix used by the pattern\n    m1 = mx * my * mz;\n    m2 = m1 * m1;\n\t\n    time = iTime * 8.;\n    \n    vec3 cu = vec3(0,1,0);\t\t\t\t\t\t\t\t\t\t\t// Camera Up\n  \tvec3 cv = vec3(path(time + .1),time + .1); \t\t\t\t\t// Camera View\n    vec3 ro = vec3(path(time),time);\t\t\t\t\t\t\t\t// Camera Origin\n    //ro *= getRotZMat(ro.z*0.05);\n\t//cv *= getRotZMat(ro.z*0.05);\n\t\n\tvec3 lp = vec3(path(ro.z + 7.),ro.z + 7.); \t\t\t\t\t// light point\n    vec3 cp = vec3(path(ro.z + 25.2),ro.z + 25.2); \t\t// center point for Smooth RadClick\n\tvec3 rd = cam(g, si, ro, cv);\t\t\t\t\t\t\t\t\t// Camera Direction\n\n\t// center point for calculate section id accroding to the tunnel path\n\tvec2 rdID = rd.xy - normalize(cp-ro).xy;\n\t\n\trdID = cam(si*0.5, si, ro, cv).xy - normalize(cp-ro).xy;\n\n\t// radial section id\n    float id = 0.;//GetID(rdID); // 0 to 4\n\n    // circular sections id \n    cid = id; \t\t\t\t\t\t\t\t\t// current section id\n\tlid = cid - 1.; \t\t\t\t\t\t\t// last section id\n\tif (lid < 0.) lid = id + sections - 1.;\t// circular \n\t\n\t// Ray Marching\n    float s = 1.;\n    float d = 2.;\n    for(int i=0;i<60;i++)\n    {      \n        if (log(d*d/s/1e5)>0.) break;\n        d += s = map(ro+rd*d).x * .6;\n    }\n\t\n\t// Color\n    f = shade(ro, rd, d, lp);\n\t\n\t// mix Color Arangement according to Radial Section Range \n\t// mix from params of last section id with params of current section id \n\t// according to the range between the two sections with fract(cid) => range 0 to 1\n\tf = mix(params(f, lid), params(f, cid), fract(cid)); // id range [0-1]\n\t\n\t// improve light a little bit\n\tf = f + f.x*0.3;\n\n\t// fog for hide some ray marching artifact cause by the low count iteration (60 here )\n    f = mix( f, vec4(0.8), 1.0-exp( -0.001*d*d ) );\n        \n\t// gamma correction for add some contrast without saturation\n   \tfragColor = sqrt(f*f*f*2.); // gamma correction\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3SRr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[560, 581, 606, 606, 664], [665, 665, 690, 690, 748], [749, 749, 774, 774, 832], [834, 857, 876, 876, 920], [922, 952, 974, 974, 1096], [1098, 1122, 1145, 1145, 1202], [1204, 1315, 1365, 1365, 1599], [1601, 1727, 1761, 1761, 2202], [2204, 2204, 2236, 2236, 2340], [2342, 2342, 2360, 2360, 2750], [2752, 2752, 2782, 2782, 2997], [2999, 3220, 3248, 3248, 3573], [3575, 3657, 3714, 3714, 3938], [3940, 3940, 3976, 3976, 4112], [4114, 4290, 4341, 4341, 4512], [4514, 4723, 4786, 4786, 5254], [5256, 5521, 5552, 5552, 5716], [5718, 5718, 5766, 5766, 6884], [6886, 6961, 7006, 7006, 7226], [7228, 7228, 7285, 7285, 9258]], "test": "error"}
{"id": "4lG3zV", "name": "Twinkling star", "author": "kellyegan", "description": "Experimenting with polar shapes. Sketch from my One Hundred Sketches Project.\n\nkellyegan.net/2016/07/onehundred.html", "tags": ["star", "polar"], "likes": 4, "viewed": 257, "published": "Public", "date": "1475458784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat circle( vec2 coord, vec2 center, float radius, float blur ) {\n    vec2 dist = coord - center;\n\treturn 1.0 - smoothstep(pow(radius - blur, 2.0), pow(radius + blur, 2.0), dot(dist,dist));\n}\n\nfloat star( vec2 coord, vec2 center, float radius, float points, float blur, float rot) {\n    vec2 p = center - coord;\n    \n    //Polar coordinates\n    float d = length(p) * 2.0;\n    float a = atan(p.y, p.x);\n    \n    float f = (cos(a * points + rot) + 1.0) / 4.0  + 0.5;\n    return 1.0 - smoothstep(f * radius - blur / 2.0, f * radius + blur / 2.0, d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t//float a = circle(fragCoord.xy, vec2(200.0, 100.), 80.0, 10.0);\n    //float b = circle(fragCoord.xy, vec2(300.0, 100.), 80.0, 10.0);\n    \n\t//fragColor = vec4(1.0, 0.0, 1.0, 1.0) * a;\n    //fragColor += vec4(0.0, 1.0, 0.0, 1.0) * b;\n    \n    float radius = 200.0;\n    float blur = 100.0;\n    \n    vec4 c1 = vec4( 0.1, 0.6, 1.0, 1.0 );\n    vec4 c2 = vec4( 0.0, 0.8, 1.0, 1.0 );\n    vec4 c3 = vec4( 0.2, 1.0, 0.5, 1.0 );\n    vec4 c4 = vec4( 0.3, 1.0, 1.0, 1.0 );\n    \n    vec2 pos = iResolution.xy / 2.0 - fragCoord.xy;\n    \n    float size = min( iResolution.x, iResolution.y ) * 0.85;\n    \n\tfloat star1 = star( fragCoord.xy, iResolution.xy / 2.0, size * 0.7, 12.0, 300.0, iTime );\n    float star2 = star( fragCoord.xy, iResolution.xy / 2.0, size, 18.0, 300.0, -iTime * 1.2 );\n    float star3 = star( fragCoord.xy, iResolution.xy / 2.0, size, 24.0, 300.0, iTime * 1.1 );\n    float star4 = star( fragCoord.xy, iResolution.xy / 2.0, size * 0.8, 9.0, 200.0, -iTime );\n    fragColor = c1 * star1 + c2 * star2 + c3 * star3 + c4 * star4; \n    \n       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lG3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 69, 69, 195], [197, 197, 286, 286, 552], [556, 556, 613, 848, 1661]], "test": "valid"}
{"id": "4lGGRc", "name": "Brassmorph", "author": "efairbanks", "description": "Weird giant morphing spherical ball of metallic cheese.", "tags": ["raymarching", "weird"], "likes": 3, "viewed": 187, "published": "Public", "date": "1475726231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCH_STEPS 128.0\n#define MARCH_EPSILON 0.001\n#define SHADOW_STEPS 40.0\n#define SHADOW_EPSILON 0.01\n#define GRADIENT_STEP 0.02\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 b, float roundness)\n{\n\treturn length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat cappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat triangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat quad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// --- //\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\n// ----------------------------------------------- //\n// --- NOTES ON DISTANCE FIELD TRANSFORMATIONS --- //\n// ----------------------------------------------- //\n\n// UNION:\t\tmin(d1,d2)\n// SUBTRACT:\tmax(-d1,d2)\n// INTERSECT:\tmax(d1,d2)\n// REPEAT:\t\tmap(mod(p,c)-0.5*c)\n// SCALE:\t\tmap(p/s)*s\n// ROTATE:\t\tmap(invert(m)*p)\t// where m == 4x4 rot matrix\n/*\n\nfloat twist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return primitive(q);\n}\n\nfloat bend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return primitive(q);\n}\n\n*/\n\n// ----------------------------------------------- //\n// ----------------------------------------------- //\n// ----------------------------------------------- //\n\n// field of view of camera\n#define FOV 0.3\nfloat CAMERA_DISTANCE = 100.;//*(1.+sin(iTime*2.*M_PI*0.05));\n// generate combined distance field\nfloat map(vec3 p)\n{\n\t// draw rounded boxes\n    float qs = (cos(iTime/11.)+2.)/3.;\n    vec3 q = p;\n    q.xyz = mod(p.xyz,vec3(10.0*qs))-5.*qs;\n    float boxSize = 4.*qs;\n\tfloat d = box(q,vec3(boxSize), boxSize/2.);\n\n    // sub mini spheres from rounded boxes\n    float qr = (sin(iTime/1.)+4.)/5.;\n    vec3 r = p;\n    r.xyz = mod(r.xyz,vec3(2.*qr))-1.*qr;\n    d = max(-sphere(r,1.2*qr), d);\n    \n    // intersect previous geometry with megasphere\n    d = max(d,sphere(p,30.));\n    \n    // subtract smaller sphere from megasphere\n    d = max(d,-sphere(p,25.));\n\n\treturn d;\n}\n\n// raymarching procedure with lots of output info\nvoid march(vec3 origin, vec3 direction, out vec3 rayHead, out bool hit, out float dist, out float steps)\n{\n    float distanceTraveled = 0.;\n    hit = true;\n    for(float step=0.; step<MARCH_STEPS; step++)\n    {\n        rayHead = origin + (direction*distanceTraveled);\n        dist = map(rayHead);\n        steps = step;\n        if(dist<MARCH_EPSILON||step>=MARCH_STEPS) return;\n        distanceTraveled += dist;\n    }\n    hit = false;\n}\n\n// get origin and direction of ray to be cast for camera/screen xy (pixel) coordinate\nvoid cameraRay(vec2 scanLines, vec3 cameraPosition, vec3 target, float fov, out vec3 pos, out vec3 dir)\n{\n\tvec3 forward = normalize(target-cameraPosition);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*scanLines.x*fov;\n    up = up*scanLines.y*fov;\n    \n    pos = cameraPosition;\n    dir = (right+up+forward);\n}\n\n// get surface normal of point on distance field for shading\nvec3 gradient( vec3 pos )\n{\n\tconst vec3 dx = vec3( GRADIENT_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRADIENT_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRADIENT_STEP );\n\treturn normalize(vec3(\n\t\tmap( pos + dx ) - map( pos - dx ),\n\t\tmap( pos + dy ) - map( pos - dy ),\n\t\tmap( pos + dz ) - map( pos - dz )\n\t));\n}\n\n// calculate diffuse lighting for point on distance field given surface normal\nfloat diffuse(vec3 normal, vec3 lightPosition)\n{\n\treturn max(dot(normal,normalize(lightPosition)),0.);\n}\n\n// calculate diffuse lighting for point on distance field\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<int(SHADOW_STEPS); i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<SHADOW_EPSILON || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// calculate combined lighting for point on distance field\nfloat shadePoint(vec3 position, vec3 normal, vec3 lightPosition)\n{\n    float diffuseLight = diffuse(normal, lightPosition);\n\t// speculative light - it might be specular, but we're not really sure\n    float specularLight = pow(diffuseLight,50.);\n\tfloat shadow = softshadow(position, normalize(lightPosition), 0.02, 2.25);\n    return (diffuseLight*0.7+specularLight*3.0)*shadow;\n}\n\n// generate background color\nvec3 background(vec2 uv)\n{\n\treturn vec3(0.5,0.5,0.5)*uv.y;\n}\n\n// compose image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale coordinates to -1 -> +1, adjusted for screen aspect ratio\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.-1.;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    // get mouse coords\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // get ray representing camera scanline position and direction\n    float cameraRotationSpeed = 0.2;\n    vec3 cameraPosition = normalize(vec3(sin(iTime*cameraRotationSpeed),\n                                         sin(iTime*cameraRotationSpeed),\n                                         cos(iTime*cameraRotationSpeed)));\n    if(iMouse.z>0.)\n        cameraPosition = normalize(vec3(\tsin(mouse.x*2.*M_PI),\n                                        \t(mouse.y*2.-1.),\n                                        \tcos(mouse.x*2.*M_PI)));\n    cameraPosition *= CAMERA_DISTANCE;\n    vec3 cameraOrigin;\n    vec3 cameraDirection;\n    cameraRay(uv, cameraPosition, vec3(0.,0.,0.), FOV, cameraOrigin, cameraDirection);\n    \n    // calculate distance, hit point, etc of distance field via raymarching\n    vec3 rayHead;\n    bool hit;\n    float dist;\n    float steps = 40.;\n    march(cameraOrigin, cameraDirection, rayHead, hit, dist, steps);\n    \n    // calculate normal for point on distance field\n    vec3 normal = gradient(rayHead);\n    \n    // calculate light for point\n\tvec3 rotLightPos = vec3(-1.);\n    vec3 latRotLightPos = vec3(1.);\n    vec3 lightPos = vec3(cos(iTime),sin(iTime),cos(iTime));\n    float light = 0.;\n    light += shadePoint(rayHead, normal, rotLightPos);\n    light += shadePoint(rayHead, normal, latRotLightPos);\n    light += shadePoint(rayHead, normal, lightPos);\n    light /= 2.;\n    \n    // specify color of entire distance field\n    vec3 fieldColor = vec3(1.,0.8,0.5);\n    \n    // final steps and background\n    vec3 color = fieldColor*light;\n    if(!hit) color = background(uv);\n    \n    // set fragment shader color\n    fragColor = vec4(color,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 209, 209, 228], [230, 230, 261, 261, 326], [328, 328, 361, 361, 385], [387, 387, 431, 431, 496], [498, 498, 532, 532, 566], [568, 568, 598, 598, 659], [661, 661, 692, 692, 723], [725, 725, 759, 759, 843], [845, 845, 879, 879, 966], [968, 968, 1018, 1018, 1145], [1147, 1147, 1187, 1187, 1286], [1288, 1288, 1330, 1330, 1623], [1625, 1625, 1666, 1666, 1726], [1728, 1728, 1778, 1778, 2285], [2287, 2287, 2341, 2341, 2981], [2983, 2994, 3035, 3035, 3118], [4053, 4122, 4141, 4164, 4693], [4695, 4745, 4851, 4851, 5180], [5182, 5268, 5373, 5373, 5675], [5677, 5738, 5765, 5765, 6056], [6058, 6137, 6185, 6185, 6241], [6243, 6301, 6375, 6375, 6657], [6659, 6718, 6784, 6784, 7096], [7098, 7127, 7153, 7153, 7187], [7189, 7206, 7262, 7333, 9177]], "test": "valid"}
{"id": "4lKGDG", "name": "Goursat Surface", "author": "Dain", "description": "http://mathworld.wolfram.com/GoursatsSurface.html", "tags": ["shape", "goursat"], "likes": 5, "viewed": 250, "published": "Public", "date": "1476465460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//distance not accurate at all\nfloat sdGoursat(vec3 p, vec3 b, vec3 goursat ){\n     vec3 d = abs(p) - b;\n     return pow(d.x,4.0) + pow(d.y, 4.0) + pow(d.z, 4.0) \n         \t+\tgoursat.x * (length(d)) \n           \t+ \tgoursat.y * dot(d,d) \n         \t+\tgoursat.z;\n}\n\n//original box\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat hash1( in vec2 f ) \n{ \n    return fract(sin(f.x+131.1*f.y)*43758.5453123); \n}\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//float sca = 0.5 + 0.15*sin(iTime-10.0);\nvec4 grow = vec4(1.0);\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += 1.000*sin(  2.0*p.yzx )*grow.x;\n    p.xyz += 0.500*sin(  4.0*p.yzx )*grow.y;\n    p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;\n    p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;\n    return p;\n}\n\nfloat map( vec3 q )\n{\n    float r = 1.01;\n   \n    return sdGoursat(q, vec3(r,r, r)*1.0, vec3(.0,-1.0,.5));\n  \n}\t\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 250.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<1256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h*0.05;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.005,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*1.0 )*32.0, 0.0, 1.0 );\n    }\n\tao /= 64.0;\n\t\n    return clamp( ao*ao, 0.0, 1.0 );\n}\n\nfloat calcAO2( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*0.2 )*100.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 q = fragCoord/iResolution.xy;\n\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n\n    \n    grow = smoothstep( 0.0, 1.0, (iTime-vec4(0.0,1.0,2.0,3.0))/3.0 );\n\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = 1.1 + 0.05*(iTime-10.0) - 7.0*m.x;\n\n\tvec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n\t// raymarch\n    float t = intersect(ro,rd);\n\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        vec3 sor = nor;\n        \n        vec3 q = mapP( pos );\n        float occ = calcAO( pos, nor, fragCoord ); occ = occ*occ;\n\n        // materials\n\t\tcol = vec3(0.04);\n        float ar = clamp(1.0-0.7*length(q-pos),0.0,1.0);\n        col = mix( col, vec3(2.1,2.0,1.2), ar);\n        col  *= 0.3;          \n        col *= mix(vec3(1.0,0.4,0.3), vec3(0.8,1.0,1.3), occ);\n        float occ2 = calcAO2( pos, nor, fragCoord );\n        \n        \n        col *= 1.0*mix( vec3(2.0,0.4,0.2), vec3(1.0), occ2*occ2*occ2 );\n        float ks = texCube( iChannel0, pos*1.5, nor, 4.0 ).x;\n        ks = 0.5 + 1.0*ks;\n        ks *= (1.0-ar);\n        \n        // lighting\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = pow(max( dot(-rd,nor),0.0),8.0);\n\t\t// lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky*occ;\n             lin += 1.0*fre*vec3(1.2,0.70,0.60)*(0.1+0.9*occ);\n        col += 0.3*ks*4.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.05+0.95*pow(fre,5.0))*(0.5+0.5*nor.y)*occ;\n        col += 4.0*ks*1.5*spe*occ*col.x;\n        col += 2.0*ks*1.0*pow(spe,8.0)*occ*col.x;\n        col = col * lin;\n\n        // dust\n        //col = mix( col, 0.2*fre*fre*fre+0.6*vec3(0.6,0.55,0.5)*sky*(0.8+0.4*texCube( iChannel0, pos*8.0, nor, 4.0 ).xyz), 0.6*smoothstep(0.3,0.7,nor.y)*sqrt(occ) );\n        \n       // col *= 2.6*exp(-0.2*t);\n    }\n\n\tcol = pow(col,vec3(0.4545));\n\n    col = pow( col, vec3(1.0,1.0,1.4) ) + vec3(0.0,0.02,0.14);\n    \n    col += (1.0/255.0)*hash1( fragCoord );\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKGDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 32, 79, 79, 262], [264, 279, 310, 310, 397], [400, 400, 424, 424, 466], [468, 468, 495, 495, 551], [660, 660, 696, 696, 872], [874, 940, 961, 961, 1157], [1159, 1159, 1180, 1180, 1270], [1273, 1273, 1316, 1316, 1578], [1580, 1580, 1612, 1612, 1823], [1825, 1825, 1880, 1880, 2157], [2159, 2159, 2215, 2215, 2490], [2492, 2492, 2557, 2557, 2741], [2743, 2743, 2800, 2800, 5507]], "test": "error"}
{"id": "4lKGR3", "name": "Weird Pattern 1", "author": "aiekick", "description": "Weird Pattern 1", "tags": ["pattern", "weird", "1"], "likes": 4, "viewed": 552, "published": "Public API", "date": "1475854247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5 ) / iResolution.y * 5.;\n\t\n\tvec2 f = floor(uv);\n\tvec2 g = fract(uv);\n\tfloat k = 9., t = iTime * 0.1, a,r;\n    \n\tvec2 cp;\n\tvec2 p;\n\tfor(int x=-2;x<=2;x++)\n    for(int y=-2;y<=2;y++)\n\t{\t\n\t\tp = vec2(x,y);\n    \tp += .5 + .5*sin( t * 10. + 9. * fract(sin((f+p)*mat2(2,5,5,2)))) - g;\n\t\ta = atan(abs(p.x),abs(p.y));\n\t\tr = length(p);\n\t\tp = vec2(a/3.14159*0.8,r);\n\t\tk = min(k, mix(max(abs(p.x)-p.y, abs(p.y)-p.x), mix(max(abs(p.x), abs(p.y)), length(p), -4.), -4.8));\n    }\n\t\n\tfragColor.rgb = vec3(0.4, 0.54, 1) * k;\n\tfragColor.rgb += smoothstep(fragColor.rgb * 0.17, fragColor.rgb/0.17, vec3(0.17));\n\tfragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 714]], "test": "valid"}
{"id": "4lKGRc", "name": "Simple Ray Tracer Study", "author": "pdcxs007", "description": "https://www.youtube.com/watch?v=9g8CdctxmeU", "tags": ["raytracer"], "likes": 2, "viewed": 263, "published": "Public", "date": "1475897297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.youtube.com/watch?v=9g8CdctxmeU\n\nfloat iSphere(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sphere)\n{\n    vec3 oc = rayOrigin - sphere.xyz;\n    float b = 2.0 * dot(oc, rayDirection);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float h = b*b - 4.0*c;\n    if (h < 0.0)\n        return -1.0;\n    float t = (-b - sqrt(h)) / 2.0;\n    return t;\n}\n\nvec3 nSphere(in vec3 pos, in vec4 sphere)\n{\n    return (pos - sphere.xyz)/sphere.w;\n} \n\nfloat iPlane(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    return -rayOrigin.y / rayDirection.y;\n}\n\nvec3 nPlane(in vec3 pos)\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvec4 sphere1 = vec4(0.0, 1.0, 0.0, 1.0);\nfloat intersect(in vec3 rayOrigin, in vec3 rayDirection, out float resultT)\n{\n    resultT = 1000.0;\n    float id = -1.0;\n    // intersect with a sphere\n    float tSphere = iSphere(rayOrigin, rayDirection, sphere1);\n    // intersect with a plane\n    float tPlane = iPlane(rayOrigin, rayDirection);\n    \n    if (tSphere > 0.0)\n    {\n        id = 1.0;\n        resultT = tSphere;\n    }\n    \n    if (tPlane > 0.0 && tPlane < resultT)\n    {\n        id = 2.0;\n        resultT = tPlane;\n    }\n    \n    return id;\n}\n\nvec3 light = normalize(vec3(0.57703));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx + vec2(0.0, 0.2);\n    \n    // Generate a ray\n    vec3 rayOrigin = vec3(0.0, 1.0, 4.0);\n    vec3 rayDirection = normalize(vec3(-1.0 + 2.0*uv, -1.0));\n    \n    sphere1.x = 0.5 * cos(iTime);\n    sphere1.z = 0.5 * sin(iTime);\n    \n    float t;\n    // Intersect the ray with 3d scene\n    float id = intersect(rayOrigin, rayDirection, t);\n    \n    vec3 color = vec3(0.7);\n    vec3 pos = rayOrigin + t*rayDirection;\n    if (id > 0.5 && id < 1.5)\n    {\n        // hit the sphere\n        vec3 nor = nSphere(pos, sphere1);\n        float diffuse = clamp(dot(nor, light), 0.0, 1.0);\n        float ao = 0.5 + 0.5*nor.y;\n        color = vec3(0.9, 0.8, 0.6)*diffuse + vec3(0.1, 0.2, 0.4);\n        color *= ao;\n    }\n    else if (id > 1.5 && id < 2.5)\n    {\n        // hit the plane\n        vec3 nor = nPlane(pos);\n        float diffuse = clamp(dot(nor, light), 0.0, 1.0);\n        float amb = smoothstep(0.0, 2.0*sphere1.w, length(pos.xz - sphere1.xz));\n        color = vec3(amb*0.7);\n    }\n    color = sqrt(color);\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 119, 119, 366], [368, 368, 411, 411, 453], [456, 456, 511, 511, 555], [557, 557, 583, 583, 617], [660, 660, 737, 737, 1166], [1207, 1207, 1264, 1264, 2337]], "test": "valid"}
{"id": "4ltSzn", "name": "sasjas hello world", "author": "sasja", "description": "thx to stefaan for introducing me ;)", "tags": ["2d", "helloworld", "sines"], "likes": 1, "viewed": 82, "published": "Public", "date": "1477740939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    \n    float blobthres = 0.5 + 0.5 * sin(iTime*.1);\n    float phase = iTime*.043;\n    vec2 rot = vec2(cos(phase)*fragCoord.x - sin(phase)*fragCoord.y,\n        \t\t\tsin(phase)*fragCoord.x + cos(phase)*fragCoord.y);\n    rot *= 1.01 + sin(iTime*.1);\n\tvec4 tmp = vec4(0.5+0.5*sin(rot.x/10.0+50.0*sin(rot.y/40.0)*sin(iTime*.25)),\n                    0.5+0.5*sin(rot.y/10.0+10.0*sin(rot.x/40.0)*sin(iTime*.37)),\n                    0,1);\n    tmp.b = tmp.r*tmp.g;\n    if (tmp.b > blobthres) {\n        float plus = 10.0 * (tmp.b - blobthres);\n        tmp.r *= 1.0 - plus;\n        tmp.g *= 1.0 - plus;\n        tmp.b = 0.0;\n    }\n    fragColor = tmp;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 697]], "test": "valid"}
{"id": "4lV3DV", "name": "raymarching experiments", "author": "mfandl", "description": "I recently found out about raymarching and I can not resist digging deeper. this is my first piece. thanks to: https://www.youtube.com/watch?v=yxNnRSefK94", "tags": ["raymarching", "bubbles"], "likes": 0, "viewed": 85, "published": "Public", "date": "1476894660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdfBox(vec3 p) {\n\tvec3 size = vec3(0.9 + 0.1 * abs(sin(iTime)));\n    vec3 f = (fract(p) * 2.0 - 1.0);\n    vec3 dist = abs(f) - size / 2.0;\n    \n    return max(dist.x, max(dist.y, dist.z));\n}\n\nfloat sdfSphere(vec3 p) {\n    vec3 f = (fract(p * 2.0) * 2.0 - 1.0);\n\treturn length(f) - 0.7;\n}\n\nfloat sdfSphere2(vec3 p) {\n    vec3 f = (fract(p * 2.0) * 2.0 - 1.0);\n\treturn length(f) - 0.7;\n}\n\nfloat map(vec3 p) {\n    return max(min(sdfSphere(p), sdfBox(p)), -sdfSphere2(p));\n}\n\nfloat trace(vec3 r, vec3 o) {\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 1.0 - uv * 2.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.25));\n    \n    float theta = iTime * 0.1;\n    r.yz *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    vec3 o = vec3(iTime * 0.2, 0.0, -iTime * 0.2);\n    \n    float t = trace(r, o);\n    float fog = 1.0 / (1.0 + t * t * 0.5);\n    vec3 fcc = vec3(1.0 - fog);\n    \n    vec3 floored = floor( o + r * t);\n    if (fog > 0.2) {\n\t\tfragColor = vec4(fcc.x * ((mod(floored.x, 10.0)) / 10.0 + 0.5), 1.0 - fcc.x * ((mod(floored.x, 10.0)) / 10.0 + 0.5), 0.0, 1.0);\n    } else {\n    \tfragColor = vec4(uv.x, 1.0, uv.y, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lV3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 196], [198, 198, 223, 223, 293], [295, 295, 321, 321, 391], [393, 393, 412, 412, 476], [478, 478, 507, 507, 658], [660, 660, 717, 717, 1403]], "test": "valid"}
{"id": "4lV3RK", "name": "Rainbow Circles", "author": "Friendship", "description": "Total GLSL and programming noob here! Series of concentric circles blending though different hues at an offset time from one another.", "tags": ["abstract"], "likes": 3, "viewed": 219, "published": "Public", "date": "1475535783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Converts hsv to rgb - How the heck does this work? O_o\n//Taken from https://gist.github.com/kylemcdonald/f8df3bc2f8d38ca2b7cb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Converts rgb to hsv - also have no idea how this works\n//Not needed currently but might use it if I do more with this :3\n//Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //taken from vug's GLSL tutorials - https://www.shadertoy.com/view/Md23DV\n    vec2 center = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tcenter = 2.0 * center.xy / iResolution.y;\n\t// [-0.5*iResolution.x, 0.5*iResolution.x] -> [-1.0, 1.0]\n    \n    \n    float timemodifier = 1.0; // adjusts the rate the colors change.\n    float time = iTime / timemodifier;\n    vec4 pixel = vec4(0.0,0.0,0.0,1.0); //background color\n    \n    //tehsauce's better circle drawing method\n    float d = length(center);\n    if (d < 2.1 ){\n    \tpixel = vec4(hsv2rgb( vec3(0.5+0.5*sin(time+floor(10.0*d)/7.0) , 1.0, 1.0) ), 1.0);\n    }\n    \n    // -----test --------\n    //Off center circles changing saturation/value\n    float d2 = length(center + 0.5);\n    if (d2 < 0.5 ){\n    \tpixel = vec4(hsv2rgb( vec3(0.5+0.5*sin(time+floor(10.0*d)/7.0) , 0.5+0.5*sin(time+floor(10.0*d)/7.0), 1.0) ), 1.0);\n       // pixel = vec4(hsv2rgb( vec3(0.5+0.5*sin(time+floor(10.0*d)/7.0) , 1.0, 1.0) ), 1.0) * pixel;\n    }\n    float d3 = length(center - 0.5);\n    if (d3 < 0.5 ){\n        pixel = vec4(hsv2rgb( vec3(0.5+0.5*sin(time+floor(10.0*d)/7.0) , 1.0 , 0.5+0.5*sin(time+floor(10.0*d)/7.0)) ), 1.0);\n        //pixel = vec4(hsv2rgb( vec3(0.5+0.5*sin(time+floor(10.0*d)/7.0) , 1.0, 1.0) ), 1.0) * pixel;\n    }\n    //Cannot figure out how to get circles in the other corners!\n    /*float d4 = length(center - 1.0);\n    if (d4 < 0.5 ){\n        //pixel = vec4(hsv2rgb( vec3(0.5+0.5*sin(time+floor(10.0*d)/7.0) , 1.0, 1.0) ), 1.0) * pixel;\n        pixel = vec4(1.0); //so I can see where I'm moving it\n    }   \n    */\n    \n    \n    \n    \n\n\tfragColor = vec4(pixel);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lV3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 128, 150, 150, 319], [321, 514, 536, 536, 867], [869, 869, 926, 1004, 2682]], "test": "valid"}
{"id": "4lV3RV", "name": "The One True Keiser", "author": "MrHenryBemis", "description": "Keiserin'", "tags": ["mandala"], "likes": 4, "viewed": 553, "published": "Public API", "date": "1475576197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iTime sin(iTime*2.2)\n\n#define DTM 78.0\n\n#define D 8.0\n#define T 35.0\n#define M 35.0\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float scale = (sin(iTime)*.5+.5);\n    \n    float d;\n    \n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 33; i++)\n    {\n        vec2 p = vec2(acos(float(i)/33.0*PI*2.0+iTime), asin(float(i)/33.0*PI*2.0+iTime));\n    \n        d = length(uv-p)*0.7;\n        \n        \n    \tif(d <= 3.0)\n        {\n            col += (vec3(\n            sin(-iTime*PI*2.0+D+d*PI),\n            cos(-iTime*PI*2.0+4.0*PI/3.0+M+d*PI),\n            cos(-iTime*PI*2.0+2.0*PI/2.0+T+d*PI))*.5+.5)*sin(d*PI*DTM+iTime*DTM);\n        }\n    }\n    \n    d = length(uv)*2.2;\n    \n    col += vec3(\n    \tsin(-iTime*PI*3.0+D+d*PI),\n        cos(-iTime*PI*2.0+4.0*PI/3.0+M+d*PI),\n        cos(-iTime*PI*3.0+3.0*PI/2.0+T+d*PI));\n    \n\t\tfragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lV3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 176, 176, 1005]], "test": "error"}
{"id": "4lV3zc", "name": "Voronoi lines", "author": "stb", "description": "An extension of the voronoi pattern in which lines connect cell offsets less than 1 unit apart. Mouse x adjusts amount of cell jitter; mouse y adjusts line thickness.", "tags": ["procedural", "2d", "voronoi", "lines", "random", "hash"], "likes": 21, "viewed": 449, "published": "Public", "date": "1475947051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// comment to disable perspective\n#define MODE7\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031, .11369, .13787) // int range\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x+p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// get hash offset (jitter and p are assigned in main)\n#define getH(d) jitter * hash22(floor(p-d)) - d;\n\n// basic line function (ends are clipped not rounded)\nfloat line(in vec2 p, vec2 p0, vec2 p1) {\n    vec2 n = normalize(p1-p0);\n    p -= p0;\n    float l = .5 * length(p1-p0);\n    return abs(dot(p, vec2(n.y, -n.x))) + step(l, abs(dot(p, n)-l));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n\tvec2 uv = (fragCoord.xy-res/2.) / res.y + 1.e-4; // a small value is added to avoid errors where floor meets fract\n\t\n    // init p, with zoom\n\tvec2 p = 16. * uv;\n    \n    // 'mode 7'\n    #ifdef MODE7\n    \tp.y -= 10.;\n    \tp = - 5. * vec2(p.x/p.y, 20./p.y);\n    #endif\n    \n    // scrolling\n    p.x += iTime;\n    \n    // adjust cell jitter with mouse x\n    // usually this would be a fixed number or 1.0 (not considered)\n    float jitter = iMouse.z>0. ? min(1., iMouse.x / res.x) : 1.;\n    \n    // random offsets of neighbors (clockwise starting north)\n    vec3 v = vec3(-1., 0., 1.);\n    vec2 o[10];\n    o[0] = getH(v.yz);\n    o[1] = getH(v.zz);\n    o[2] = getH(v.zy);\n    o[3] = getH(v.zx);\n    o[4] = getH(v.yx);\n    o[5] = getH(v.xx);\n    o[6] = getH(v.xy);\n    o[7] = getH(v.xz);\n    o[8] = o[0];\t // trying to prevent excess code\n\to[9] = o[1];\t// <--'\n    \n    // center offset\n    vec2 c = getH(0.);\n    \n    // center cell dot (we won't know which lines connect, so all line caps contribute)\n    float f = length(fract(p)-c);\n    \n    // check neighbors and combine into f:\n    for(int n=0; n<8; n++) {\n        \n        // dots from neighbors\n        f = min(f, length(fract(p)-o[n]));\n        \n        // lines between center and neighbors\n        if(distance(c, o[n]) < 1.)\n\t\t\tf = min(f, line(fract(p), c, o[n]));\n        \n        // lines between adjacent neighbors\n        if(distance(o[n], o[n+1]) < 1.)\n\t\t\tf = min(f, line(fract(p), o[n], o[n+1]));\n        \n        // lines between every other neighbor\n        if(distance(o[n], o[n+2]) < 1.)\n\t\t\tf = min(f, line(fract(p), o[n], o[n+2]));\n    }\n    \n    // adjust line thickness with mouse y\n    f = iMouse.w>0. ? min(1., f / (1.-iMouse.y/res.y)) : f;\n    \n    #ifdef MODE7\n    \tfragColor = vec4(mix(f*vec3(1.3, 1., .7), vec3(.8, .8, 1.), clamp(p.y/70., 0., 1.)), 1.);\n    #else\n    \tfragColor = vec4(f*vec3(1.3, 1., .7), 1.);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lV3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 165, 186, 186, 319], [426, 480, 521, 521, 670], [672, 672, 729, 729, 2660]], "test": "valid"}
{"id": "4lVGDK", "name": "Vector mountains", "author": "VirtuosoChris", "description": "function visualization", "tags": ["2d", "visualization", "green", "mountains", "vector"], "likes": 4, "viewed": 181, "published": "Public", "date": "1476831597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mfunc (float x)\n{\n  return abs(-1.0 + abs(-12.25 + abs(-8.0 + abs(-12.0 + abs(.95 * x + 4.0))))); \n}\n\nfloat wfunc(float x)\n{\n//\treturn sin(x) + .15*sin(1.5*x);\n    float wave = .25* sin(3.0*x) + .15*sin(1.5*x + 6.0 * iTime) + .14*cos(x + 3.0*iTime);\n    return wave;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float domain = 9.0 * 3.14159;\n    \n    vec2 origin = vec2(-10.0, -8.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= domain;\n    uv += origin;\n     \n     float cameraOff = 2.0*sin(iTime);\n    \n    vec3 col = vec3(0.0);\n    {   \n    \tfloat outVal = mfunc(uv.x*2.0 + cameraOff);\n    \tfloat difference = abs(outVal - uv.y);\n    \n    \tfloat edge = smoothstep(.1, .75, difference);\n    \tedge = pow(edge, .15);\n    \n    \tcol = vec3(10.0, 1.5, 0.0)*(1.0 - edge);\n\t}\n    \n     {   \n    \tfloat outVal = wfunc (uv.x + 1.25* iTime + (.5 * cameraOff));\n    \tfloat difference = abs(outVal - uv.y);\n    \n    \tfloat edge = smoothstep(.1, .75, difference);\n    \tedge = pow(edge, .15);\n    \n    \tcol += vec3(0.0, 1.5, 10.0)*(1.0 - edge);\n\t}\n    \n    \n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 106], [108, 108, 130, 165, 283], [285, 285, 342, 342, 1132]], "test": "valid"}
{"id": "4lVGzt", "name": "Bipolar", "author": "decrooks", "description": "Playing with bipolar coordinates.", "tags": ["2d", "pattern", "bipolar"], "likes": 9, "viewed": 207, "published": "Public", "date": "1476201318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n   \tfloat scale = ( 40.0+20.0*sin(0.3*time));\n    vec2 p = scale*(fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\t\n    //rotate\n    float rotationrate = 0.1;\n    float s = sin(rotationrate*time);\n    float c = cos(rotationrate*time);\n    p = mat2(c,s,-s,c)*p;\n       \n    //bipolar coordinates (sigma, tau)\n    float a = min(10.0,2.0*time);\n    float alpha = a*a - dot(p,p);\n    float beta = a*a + dot(p,p);\n    float sigma = atan( 2.0*a*p.y ,alpha);\n    float tau = 0.5*log((beta + 2.0*a*p.x)/(beta - 2.0*a*p.x));\n\n    //do something funky in bipolar corrdinates\n    float freq = 20.0;\n    float rate = 3.0;\n    vec2 osc = 0.5*(1.0 + cos(freq*vec2(sigma,tau) + rate*time)) ;\n    float bipolarOscillations  = 0.5*(osc.x+osc.y);\n    \n    float spotPattern = pow(bipolarOscillations,2.0 + 1.5*sin(0.2*time));\n    float gray = spotPattern;\n    vec3 color = vec3(gray);\n \tfragColor  = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 980]], "test": "valid"}
{"id": "4lX3zM", "name": "Dancers", "author": "BGC", "description": "Heavily based on raymarch algos around shadertoy\nRaymarch study for personal understanding of the following techniques\nRaymarch - Sphere - Normals - Diffuse - Specular - Ambient - Motion blur - Vignette - Gamma ", "tags": ["distancefield", "motionblur", "dancefloor"], "likes": 21, "viewed": 1755, "published": "Public", "date": "1475494912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////\n//\n// DANCERS\n//\n// Heavily based on raymarch algos around shadertoy\n// Raymarch study for personal understanding of the following techniques\n//\n// Raymarch - Sphere - Normals - Diffuse - Specular - Ambient - Motion blur - Vignette - Gamma \n//\n////////////////////////////////////////////////////\n\n//#define debug_sphere\n\nprecision highp float;\n\n// Test color\nvec3 mag = vec3(1.5454,0.5464,1.161981);\nvec3 test = vec3(1.5454,0.5464,1.161981);\n\n// pixel XY\nvec2 xy;\n\n\n// frustum limits\nconst float ncp = 0.;\nconst float fcp = 2.;\nconst float step = 0.03;\n\n// lights\nstruct light{\n\tvec3 p;\n\tfloat di;\n\tfloat si;\n\tvec4 c;\t\n};\nlight KL;\nlight FL;\n\n// time\nfloat T = 0.;\n\n// sin-cos\nfloat sn = 0.;\nfloat cn = 1.;\n\n// ray data\nstruct ray{\n \tvec3 o;\n\tvec3 d;\n\tbool h;\n\tvec3 hp;\n\tvec3 n;\n    float m;\n};\t\n\t\nvoid sincos(float t)\n{\n\tsn = sin(t);\n\tcn = cos(t);\n}\t\n\n//--------------------------------------------------\n\t\nfloat sphere(vec3 _p, vec3 _c, float _r)\n{\n\treturn length(_p-_c)-_r;\n}\n\nfloat plane(vec3 _p, float _h)\n{\n\treturn _p.y - _h;\n}\n\nvec2 opU(vec2 _d, vec2 _o)\n{\n    return _d.x < _o.x ? _d : _o;\n}\n\nvec2 opI(vec2 _d, vec2 _o)\n{\n    return _d.x > _o.x ? _d : _o;\n}\n\n//--------------------------------------------------\n\n// Materials\n#define MAT_PLANE 0.01\n#define MAT_KEYLIGHT 0.02\n\nvec2 map(vec3 _p)\n{\n\tvec2 d0 = vec2(100000.,0.);\n    vec2 d = d0;\n\t\n    vec2 sphere1 = vec2(sphere(_p,vec3(.0,0.,.0),.6),.5);\n    vec2 sphere2 = vec2(sphere(_p,vec3(sn,-.5,cn),.8),.8);\n    vec2 sphere3 = vec2(sphere(_p,vec3(-sn,-.5,-cn),.8),.8);\n    vec2 plane1 = vec2(plane(_p,-1.),MAT_PLANE);\n    vec2 light1 = vec2(sphere(_p,KL.p/30.,.1),MAT_KEYLIGHT);\n    vec2 light2 = vec2(sphere(_p,FL.p/30.,.1),MAT_KEYLIGHT);\n    \n\td = opU(sphere2,sphere3);\n\td = opI(d,sphere1);\n    d = opU(d,plane1);\n    \n    // lights\n    //d = opU(d,light1);\n    //â‰¥d = opU(d,light2);\n    \n    #ifdef debug_sphere\n    d = opU(d0,sphere1);\n    d = opU(d,plane1);\n    #endif\n    \n\treturn d;\t\n}\n\nray camera(vec3 _pos, vec3 _target, vec2 _xy, float _fov)\n{    \n    // initialize ray\n    ray cr;\n\tcr.o = vec3(_xy,0.);\n\tcr.d = normalize(vec3(_fov * _xy,1.));\n\tcr.h = false;\n    \n    // rotation matrix\n    vec3 la = normalize(_target - _pos);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 ri = normalize(cross(up,la));\n    up = cross(la,ri);\n    \n    mat3 m = mat3(ri,up,la);\n    \n    // translation\n    vec3 t = _pos;\n    \n    // apply transforms\n    cr.d = m * cr.d;\n    cr.o = m * cr.o;\n    cr.o = t + cr.o;\n    \n    return cr;\n}\t\n\nray setupCamera(float t, vec2 xy)\n{\n    vec3 cam = vec3(sn,1.5,cn*.5) * .3;\n    vec3 target = vec3(0.);\n    ray cr = camera(cam, target, xy, .2);\n    \n    return cr;\n}\n\n\n//--------------------------------------------------\n\nvoid rayCast(inout ray _r)\n{\t\n\t// ray start point\n\tvec3 p = _r.o;\n\tvec2 d = vec2(0.);\n\tfloat ld = 0.;\n    \n    sincos(iTime*-4.);\n    \n    // traverse map\n    for(int t = 0; t < 1000; t++)\n    {\n        d = map(p);        \n        p += _r.d * d.x;\n        if(d.x < 0.001)\n        {\n            _r.h = true;\n            _r.hp = p;\n            _r.m = d.y;\n                       \n            break;\n        }\n    }\n}\n\nvoid rayMarch(inout ray _r)\n{\n\t// ray start point\n\tvec3 p = _r.o;\n\tvec2 d = vec2(0.);\n\tfloat ld = 0.;\n\t\t\n\t// traverse frustum\n\tfor(float s=ncp; s<fcp; s+=step)\n\t{\n\t\t// step in front\n\t\tp += _r.d*step;\n\t\t\n\t\t// check hit\n\t\td = map(p);\n\t\tif(!_r.h && d.x<0.)\n\t\t{\n\t\t\t_r.h = true;\n\t\t\t\n\t\t\t// interpolate p\n\t\t\tfloat i = step*ld/(ld-d.x);\n\t\t\t_r.hp = p;//_r.o + _r.d * (s-step+i);            \n            break;\n\t\t}\n\t\t\n\t\t//last d\n\t\tld = d.x;\n\t}\n}\n\nvoid normal(inout ray _r)\n{\n    vec2 eps = vec2(.001,.0);\n    float dx = map(_r.hp + eps.xyy).x - map(_r.hp - eps.xyy).x;\n    float dy = map(_r.hp + eps.yxy).x - map(_r.hp - eps.yxy).x;\n    float dz = map(_r.hp + eps.yyx).x - map(_r.hp - eps.yyx).x; \n    _r.n = normalize(vec3(dx,dy,dz));\n}\n\n//--------------------------------------------------\n\nvec4 material(ray _r)\n{\n    if(_r.m == MAT_PLANE)\n    {\n        float f = mod( floor(5.*_r.hp.z) + floor(5.*_r.hp.x), 2.0);\n        return vec4(f);\n    }\n    else if(_r.m == MAT_KEYLIGHT)\n    {\n        return KL.c;\n    }\n    \n\treturn vec4(.5,.2,.3,1.)/2.;\t\n}\n\t\t\nvec4 diffuse(ray _r, light _l)\n{\t\t\n\t// diffuse\n\tvec3 ld = normalize(_l.p - _r.hp);\n\tfloat LdotN = max(dot(ld,_r.n),0.);\n\t\n\tvec4 diff = LdotN * _l.di * _l.c;\n\t\n\treturn vec4(diff);\n}\n\nvec4 specular(ray _r, light _l)\n{\t\t\n\t// specular\n\tvec3 ld = normalize(_l.p - _r.hp);\n\tvec3 rf = reflect(ld,_r.n);\n\tfloat RdotE = max(dot(normalize(rf),normalize(_r.d)),0.);\n\t\n\tvec4 spec = RdotE * _l.si * _l.c;\n\t\n\tspec = pow(spec,vec4(12.)) * 4.;\n\t\n\treturn vec4(spec);\n}\n\nvec4 ambient(light _l)\n{\n\treturn .05 * _l.c;\t\n}\n\nfloat hardShadow(ray _r, vec3 _light)\n{\n    ray r = _r;\n    r.o = _r.hp;\n    r.d = normalize(_light - _r.hp);\n    \n    float s = 1.;\n    float t = 0.02;    \n    for(int i=0; i<30; i++)\n    {        \n        vec3 p = r.o + r.d * t;\n        \n        float d = map(p).x;\n        \n        if(d < 0.002)\n            return 0.;\n        \n        t += d;\n    }\n    \n    return 1.;\n}\n\nfloat softShadow(ray _r, vec3 _light)\n{\n    float tmin = 0.02;\n    float tmax = 2.5;\n        \n    ray lr = _r;\n    lr.o = _r.hp;\n    lr.d = normalize(_light - _r.hp );\n    \n    float t = tmin;    \n    float ss = 1.;\n    for(int i=0; i<30; i++)\n    {                \n        vec3 p = lr.o + lr.d * t;\n        float d = map(p).x;\n        \n        ss = min(ss, 1. * d / t);\n        \n        if(d < 0.002 || t > tmax)\n            break;        \n        \n        t += clamp(d, .02, .1);\n    }\n    \n    return clamp(ss,0.,1.);\n}\n\n\nvec4 colorize(ray _r)\n{\n\tvec4 c = vec4(0.);\n\t\n\t// normal\n\tnormal(_r);\n\t\n\t// material\n\tc = material(_r);\n\t\n\t// lighting\n\tc *= diffuse(_r,KL) * softShadow(_r,KL.p) + diffuse(_r,FL) * softShadow(_r,FL.p);\n\t//c *= diffuse(_r,KL) * hardShadow(_r,KL.p) + diffuse(_r,FL) * hardShadow(_r,FL.p);\n\tc += specular(_r,KL);\n\tc += specular(_r,FL);\n\t//c += ambient(KL);\n\t//c += ambient(FL);\n    \n ///debug\n //test = vec3(softShadow(_r,KL.p));\n    \t\n\treturn c;\n}\n\n//--------------------------------------------------\n\nvec4 render()\n{\n\tvec4 c = vec4(0.);\n\tT = iTime;\n\tray r;\n\tconst float loops = 5.;\n\t\n\t// motion blur\n\tfor(float i=0.; i<loops; i++)\n\t{\n\t\t// cast ray\n\t\tsincos(T);\n        \n        // camera\n\t\tr = setupCamera(T,xy);\n        \n\t\trayCast(r);\t\t\n\t\n\t\t// hit\n\t\tif( r.h )\n\t\t{\n\t\t\t// Colorize\n\t\t\tc += colorize(r)/loops;\n\t\t}\t\n\t\t// miss\n\t\telse\n\t\t{\n\t\t\tc += vec4(0.,0.,.2,0.)/loops;\n\t\t}\t\t\n\t\t\n\t\t// move time for interframe\n\t\tT -= 1./(loops*20.);\n\t}\n\t\n\treturn c;\n}\n\n//=================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n     T = iTime;\n    \n\t// uv\n\txy = fragCoord.xy / iResolution.xy;\n\txy = 2.*xy - 1.;\n\tvec2 uv = xy;\n\txy.x *= iResolution.x / iResolution.y;\n\t\n\t// output color\n\tvec4 c = vec4(0.);\t\n\t\n\t// key light\n\tsincos(iTime*.2);\n\tKL.p = vec3(-2.*sn,10.1,-4.*cn)/3., \n\tKL.si = float(.8), \n\tKL.di = float(1.), \n\tKL.c = vec4(.9,.4,.6,1.)*1.2;\n\t\n\t// fill light\n\tFL.p = vec3(10.,18.,10.);// vec3(-KL.p.x,KL.p.y,-KL.p.z); //\n\tFL.si = float(.7), \n\tFL.di = float(.7), \n\tFL.c = vec4(.3,.3,1.,1.);\n\t\t\n\t// trace\n\tc = render();\n\t\n\t// gamma\n\tc = pow(c,vec4(1./2.2));\n\t\n\t// vignette\n\tc *= exp(-.5*dot(uv,uv));\t\t\n\t\n\t// Output\n\tfragColor = c;\n\t\n\t// tests\n\tif(test != mag) //notEqual\n\t\tfragColor.rgb = test;\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lX3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[762, 852, 874, 874, 904], [907, 962, 1004, 1004, 1032], [1034, 1034, 1066, 1066, 1087], [1089, 1089, 1117, 1117, 1153], [1155, 1155, 1183, 1183, 1219], [1275, 1338, 1357, 1357, 2013], [2015, 2015, 2074, 2100, 2541], [2544, 2544, 2579, 2579, 2711], [2714, 2768, 2796, 2817, 3182], [3184, 3184, 3213, 3233, 3619], [3621, 3621, 3648, 3648, 3911], [3913, 3967, 3990, 3990, 4225], [4229, 4229, 4261, 4275, 4409], [4411, 4411, 4444, 4459, 4680], [4682, 4682, 4706, 4706, 4729], [4731, 4731, 4770, 4770, 5105], [5107, 5107, 5146, 5146, 5629], [5632, 5632, 5655, 5655, 6077], [6079, 6133, 6148, 6148, 6577], [6579, 6633, 6690, 6690, 7368]], "test": "valid"}
{"id": "4lyGDV", "name": "Voronoi Column Tracing", "author": "tomkh", "description": "Full-scene tracing inspired by glk7's [url=https://www.shadertoy.com/view/Ml3GDX]Reactive Voronoi[/url]. My approach is more robust (no need to find closest cell at every step, just continue) plus I've added ambient occlusion.", "tags": ["voronoi", "raymarch", "shadows", "ao", "tracing"], "likes": 86, "viewed": 2955, "published": "Public API", "date": "1476715228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Clean Voronoi Column Tracing\n// by Tomasz Dobrowolski'2016 CC BY-SA\n\n// Inspired by:\n//   https://www.shadertoy.com/view/Ml3GDX \"Reactive Voronoi\" (by Genise Sole)\n\n// Other references:\n//   https://www.shadertoy.com/view/llG3zy \"Faster Voronoi Borders\"\n//   https://www.shadertoy.com/view/XtK3RG \"Voronoi Floor Tiling\"\n//   https://www.shadertoy.com/view/4djSRW Dave Hoskins hash functions\n\n// Do you like colors? \n//  Put 0 if not ;)\n//      1 for pastel-rainbow\n//      2 for image-based\n//      3 elevation-based coloring (via Shane's suggestion)\n#define USE_COLORS 3\n\n// Waving or city-like?\n#define WAVING 1\n\n#define ROTATE 1\n\n#define SHADOWS 1\n#define AO 1\n\n#define ANIMATE 1\n#define ANIM_SPEED .25\n\n\nfloat hash12(vec2 p)\n{\n#if WAVING == 1\n   float v = sin(p.x*.3)*sin(p.y*.3+iTime)*.5 + .5;\n   return v*v;\n#else\n   // Dave Hoskins hash\n   vec3 p3  = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract((p3.x + p3.y) * p3.z);\n#endif\n}\n\nvec2 hash22(vec2 p)\n{\n#if ANIMATE == 0\n   //vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   //p3 += dot(p3, p3.yzx+19.19);\n   //return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y))*.9+.05;\n    // Texture-based\n   return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n#elif 1\n   // Dave Hoskins hash with animation\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   vec2 v = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n   return sin(iTime*ANIM_SPEED + v*6.283185)*.45 + .5;\n#else\n   // Texture-based\n   vec2 v = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n   return sin(iTime*ANIM_SPEED + 6.283185*v)*.45 + .5;\n#endif\n}\n\n//---------------------------------------------------------------\n// Trace through 2D Voronoi columns\n// by Tomasz Dobrowolski'2016 CC BY-SA\n\n// Requires:\n//   vec2 hash22( in vec2 p ); // to get Voronoi seeds positions\n//   float hash12( in vec2 p ); // to get column heights\n\nconst float eps = .0001;\nconst float max_dist = 9999.;\n\n// Scan through all Voronoi neighbours in direction of ray.\nfloat find_neighbour(vec2 n, vec2 f, vec2 dir, vec4 mc, out vec4 kc, out vec2 kdr)\n{\n   float kd = max_dist;\n   // This is fast. approx of neighbour search,\n   // to make it error free in all possible cases,\n   // we would have to use 7x7 scan.\n   for( int j=-2; j<=2; j++ )\n   for( int i=-2; i<=2; i++ )\n   {\n      vec2 g = mc.zw + vec2(float(i),float(j));\n      vec2 o = hash22( n + g );\n      vec2 r = g + o - f;\n\n      vec2 dr = r - mc.xy;\n      if ( dot(dr,dr) > eps ) { // Check if not equal to cell seed\n         float d = dot(dir,dr);\n         if ( d > eps ) { // Check if in direction of ray\n            d = dot(.5*(mc.xy + r),dr)/d;\n            if (d < kd) {\n               kd = d;\n               kdr = dr;\n               kc = vec4(r, g);\n            }\n         }\n      }\n   }\n   return kd;\n}\n\n// Trace through 2D Voronoi columns\n// Z-axis is height: \n//      0 = ground\n//  max_h = max. column height (positive)\n// Returns:\n//   xy = Voronoi seed at hit pos.\n//   zw = Voronoi grid cell at hit pos.\nvec4 voronoi_column_trace(\n         vec3 ray_pos,\n         vec3 ray_dir,\n         float max_h,\n         out vec4 hit_pos,\n         out vec3 hit_norm,\n         out vec3 hit_dh )\n{\n   const int iter = 32;\n   \n   vec2 p = ray_pos.xy;\n   float s = 1./length(ray_dir.xy);\n   vec2 dir = ray_dir.xy*s;\n   vec2 n = floor(p);\n   vec2 f = fract(p);\n   \n   vec4 mc;\n   float md;\n\n   // Find closest Voronoi cell to ray starting position.\n   md = 8.;\n\n   // This is fast. approx of closest point search,\n   // to make it error free in all possible cases,\n   // we would have to use 4x4 scan.\n   for( int j=-1; j<=1; j++ )\n   for( int i=-1; i<=1; i++ )\n   {\n      vec2 g = vec2(float(i),float(j));\n      vec2 o = hash22( n + g );\n      vec2 r = g + o - f;\n      float d = dot(r,r);\n\n      if( d<md )\n      {\n         md = d;\n         mc = vec4(r, g);\n      }\n   }\n   \n   vec2 mdr = vec2(0,1);\n   float dh = 0.;\n   float prev_h = 0.;\n   float h = 0.;\n   \n   md = eps;\n\n   for( int k=0; k<iter; ++k )\n   {\n      // Get height of the column\n      h = hash12( mc.zw + n )*max_h;\n      if (ray_dir.z >= 0.) {\n         dh = ray_pos.z + ray_dir.z*md;\n         if (dh < h || dh > max_h) break; // ray goes to inifnity or hits\n      }\n      \n      vec4 kc;\n      vec2 kdr;\n      float kd = find_neighbour(n, f, dir, mc, kc, kdr)*s;\n      \n      if (ray_dir.z < 0.) {\n         dh = ray_pos.z + ray_dir.z*kd;\n         if (dh < h) break; // hit!\n      }\n      \n      mc = kc;\n      md = kd;\n      mdr = kdr;\n      prev_h = h;\n   }\n   \n   if (dh >= h) {\n      hit_pos = vec4(ray_pos + ray_dir*max_dist,max_dist);\n      hit_norm = vec3(0,0,1);\n      hit_dh = vec3(1,1,h);\n      return vec4(0);\n   }\n   \n   float d;\n   if (ray_dir.z >= 0.) {\n      d = md;\n      hit_norm = vec3(-normalize(mdr),0);\n      hit_dh = vec3(vec2(ray_pos.z + ray_dir.z*d - prev_h, h-prev_h)/max_h,h);\n   }\n   else {\n      d = (h - ray_pos.z)/ray_dir.z;\n      if (md > d) {\n         d = md;\n         hit_norm = vec3(-normalize(mdr),0);\n         hit_dh = vec3(vec2(ray_pos.z + ray_dir.z*d - prev_h, h-prev_h)/max_h,h);\n      } else {\n         hit_norm = vec3(0,0,1);\n         hit_dh = vec3(1,1,h);\n      }\n   }\n   hit_pos = vec4(ray_pos + ray_dir*d, d);\n   return mc + vec4(p, n);\n} \n\n// Trace through 2D Voronoi columns with some tuning for artifact-free shadows\n// Assumes: ray_dir.z >= 0\nvec4 voronoi_column_trace_shadow(\n         vec4 mc,\n         vec3 ray_pos,\n         vec3 ray_dir,\n         float max_h,\n         out vec4 hit_pos,\n         out vec3 hit_norm )\n{\n   const int iter = 8;\n\n   vec2 p = ray_pos.xy;\n   float s = 1./length(ray_dir.xy);\n   vec2 dir = ray_dir.xy*s;\n   vec2 n = floor(p);\n   vec2 f = fract(p);\n   \n   mc -= vec4(p, n);\n   \n   float md;\n   \n   vec2 mdr = vec2(0,1);\n   float dh = 0.;\n   float h = 0.;\n   \n   md = eps;\n\n   for( int k=0; k<iter; ++k )\n   {\n      // Scan through all Voronoi neighbours in direction of ray.\n      \n      vec4 kc;\n      vec2 kdr;\n      float kd = find_neighbour(n, f, dir, mc, kc, kdr)*s;\n      \n      mc = kc;\n      md = kd;\n      mdr = kdr;\n      \n      // Get height of the column\n      h = hash12( mc.zw + n )*max_h;\n      dh = ray_pos.z + ray_dir.z*md;\n      if (dh > max_h || dh < h) break;\n   }\n   \n   if (dh >= h) {\n      hit_pos = vec4(ray_pos + ray_dir*max_dist,max_dist);\n      hit_norm = vec3(0,0,1);\n      return vec4(0);\n   }\n   \n   float d = md;\n   hit_norm = vec3(-normalize(mdr),0);\n   hit_pos = vec4(ray_pos + ray_dir*d, d);\n   return mc + vec4(p, n);\n}\n\n// Calculate AO on the top face of the column\nfloat voronoi_column_ao( vec2 x, vec4 mc )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mr = mc.xy - x;\n    vec2 mg = mc.zw - n;\n    \n    float mh = hash12( n + mg );\n    \n    // Set center of search based on which half of the cell we are in,\n    // since 4x4 is not centered around \"n\".\n    mg = step(.5,f) - 1.;\n\n    float mao = 0.;\n    for( int j=-1; j<=2; j++ )\n    for( int i=-1; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash22( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>eps ) // skip the same cell\n        {\n            float d = dot( 0.5*(mr+r), normalize(r-mr) );\n            // Get height of the column\n            float h = hash12( n + g );\n            float ao = clamp((h - mh)*2.,0.,.5)*max(0., 1. - d*4.);\n            mao = max(mao, ao);\n        }\n    }\n\n    return mao;\n}\n//---------------------------------------------------------------\n\n// Examplary rendering with simple shading\n\nconst float fog_density = .04;\nconst float fog_start = 16.;\nconst float cam_dist = 13.5;\nconst float ground = -.2;\n#if WAVING == 1\nconst float max_h = 3.;\n#else\nconst float max_h = 2.;\n#endif\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir, in vec3 light_dir,\n   out vec4 norm_h, out vec4 ret_mc, out vec2 shadow_ao )\n{\n   vec3 p = ray_start;\n   p.y += ground;\n   \n   norm_h = vec4(0,1,0,0);\n   ret_mc = vec4(9999.,0,0,0);\n   shadow_ao = vec2(0);\n\n   if (p.y > max_h && ray_dir.y > -.0001)\n      return vec4(0.);\n   \n\n   float dist = p.y - max_h;\n   if (dist > .001) {\n      dist /= -ray_dir.y;\n      p += ray_dir*dist;\n   } else {\n      dist = 0.;\n   }\n\n   vec4 hit;\n   vec3 hit_dh;\n   ret_mc = voronoi_column_trace(p.xzy, ray_dir.xzy, max_h, hit, norm_h.xyz, hit_dh);\n#if AO == 1\n   if (hit_dh.x < 1.) {\n      shadow_ao.y = max(0., 1. - hit_dh.x*8.)*.5*hit_dh.y;\n   } else {\n      shadow_ao.y = voronoi_column_ao(hit.xy, ret_mc);\n   }\n#endif\n\n#if SHADOWS == 1\n   if (hit.w < 48.-dist) {\n      vec3 sh_dir = light_dir.xzy;\n      vec4 sh_hit;\n      vec3 sh_norm;\n      if (dot(sh_dir,norm_h.xyz) < .001) {\n         shadow_ao.x = 1.;\n      } else {\n         vec4 smc = voronoi_column_trace_shadow(ret_mc, hit.xyz, sh_dir, max_h, sh_hit, sh_norm);\n         shadow_ao.x = 1.-step(max_dist-1.,sh_hit.w);\n      }\n   }\n#endif\n\n   hit = hit.xzyw;\n   hit.w += dist;\n   hit.y -= ground + hit_dh.z;\n   norm_h = vec4(norm_h.xzy, hit_dh.z/max_h);\n   return hit;\n}\n\nvec3 shade(in vec3 ray_start, in vec3 ray_dir, vec4 norm_h, vec4 mc,\n   vec2 shadow_ao, in vec3 light_dir, in vec3 fog_color, in vec4 hit)\n{   \n   vec3 norm = norm_h.xyz;\n   float diffuse = pow(max(0.05, dot(norm, light_dir)*(1.-shadow_ao.x*.9)),.3);\n   diffuse *= 1. - shadow_ao.y*.7*(1.-shadow_ao.x*.6);\n   float spec = max(0.0,dot(reflect(light_dir,norm),normalize(ray_dir)));\n   spec = pow(spec, 32.0)*.5*(1.-shadow_ao.x);\n\n#if USE_COLORS == 0\n   vec3 base_color = vec3(.6);\n#else\n  #if USE_COLORS == 3\n   #if WAVING == 1\n     float sh = sqrt(max(0.,norm_h.w))*.8+.2;\n   #else\n     float sh = norm_h.w*.8+.2;\n   #endif\n   vec3 base_color =\n    vec3(exp(pow(sh-.75,2.)*-10.),\n         exp(pow(sh-.50,2.)*-20.),\n         exp(pow(sh-.25,2.)*-10.));\n  #elif USE_COLORS == 1\n   float sh = mc.z; // + mc.w*17.;\n   sh = (abs(mod(sh+6.,12.)-6.)+2.5)*(1./9.);\n   // Ken Silverman's EvalDraw colors ;)\n   vec3 base_color =\n    vec3(exp(pow(sh-.75,2.)*-10.),\n         exp(pow(sh-.50,2.)*-20.),\n         exp(pow(sh-.25,2.)*-10.));\n  #else\n   vec3 base_color = texture(iChannel1, mc.zw*.1, -100.).xyz;\n  #endif\n   vec3 an = abs(norm);\n   base_color = mix(base_color, texture(iChannel1,\n       ((an.y>an.x&&an.y>an.z)?hit.xz:(an.x>an.z)?hit.yz:hit.xy)*.25).xyz, .2);\n#endif\n\n   if (hit.w < max_dist-1.) {\n      base_color *= 1.-dot(mc.xy-hit.xz,mc.xy-hit.xz)*.25;\n   }\n   vec3 color = mix(vec3(0.),vec3(1.),diffuse)*base_color +\n      spec*vec3(1.,1.,.9);\n  \n   \n   float fog_dist = max(0.,hit.w - fog_start);\n   float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   //vec3 light_dir = normalize(vec3(.5, 1.0, .25));\n   vec3 light_dir = normalize(vec3(.25, .7, .25));\n   \n   // Simple model-view matrix:\n   float ms = 2.5/iResolution.y;\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -ms :\n#if ROTATE == 1\n      -iTime*.125 + .7;\n#else\n      .7;\n#endif\n   si = sin(ang); co = cos(ang);\n   mat3 cam_mat = mat3(\n      co, 0., si,\n      0., 1., 0.,\n     -si, 0., co);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y) * -ms - .5 :\n#if ROTATE == 1\n      cos(-iTime*.5)*.2 + .8;\n#else\n      .8;\n#endif\n   //ang = .1;\n   ang = max(0.,ang);\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat3(\n      1., 0., 0.,\n      0., co, si,\n      0.,-si, co);\n\n   vec3 pos = cam_mat*vec3(0., 0., -cam_dist);\n   vec3 dir = normalize(cam_mat*vec3(uv, 1.));\n\n   vec3 color;\n   vec3 fog_color = vec3(min(1.,.4+max(-.1,dir.y*.8)));\n   vec4 norm_h;\n   vec4 mc;\n   vec2 shadow_ao;\n   vec4 hit = trace(pos, dir, light_dir, norm_h, mc, shadow_ao);\n   if (hit.w == 0.) {\n      color = fog_color;\n   } else {\n      color = shade(pos, dir, norm_h, mc, shadow_ao, light_dir, fog_color, hit);\n   }\n   \n   // gamma correction:\n   color = pow(color,vec3(.6));\n   \n   fragColor = vec4(color, 1.);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyGDV.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[576, 711, 733, 733, 990], [992, 992, 1013, 1013, 1684], [2020, 2080, 2164, 2164, 2882], [2884, 3090, 3268, 3268, 5318], [5321, 5427, 5604, 5604, 6566], [6568, 6614, 6658, 6658, 7476], [7544, 7781, 7906, 7906, 9038], [9040, 9040, 9180, 9180, 10650], [10652, 10652, 10709, 10709, 12029]], "test": "error"}
{"id": "4lyGzK", "name": "Galaxies FOREVER", "author": "voz", "description": "Foeva", "tags": ["galaxies", "forever"], "likes": 5, "viewed": 472, "published": "Public API", "date": "1475416428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n//-----------------TREES---------------------------\nfloat distTree = 0.0;\nfloat angleTree = 0.0;\n\n//-----------------BASE IMAGE--------------------------\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time*PI*4.0), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n        \n        \n    }\n        \n    float a = atan(quotient.y, quotient.x);\n    \n    angleTree = a/PI;\n    distTree = length(quotient.xy);\n    \n    //quotient = rotatePoint(vec3(quotient, 0.0), vec3(0.0, 0.0, 1.0), a).xy;\n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    \n    \n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvec3 weights[32];\n\nvec4 stars(vec2 uv)\n{\n    float density = 2.0;\n    uv *= density;\n    float s = floor(uv.x)*1234.1234+floor(uv.y)*123.123;\n    vec2 p = floor(uv)+saw(floor(uv)+iTime+s)*.5+.25;\n    \n    float l = length(p-uv);\n    float f = smoothstep(.1*GR, 1.0, exp(-l*8.0));\n    \n    return vec4(clamp(flux(time+f+s)*f+f*f*f, 0.0, 1.0), f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float center = 1.0E32;\n    float angle = atan(uv.y, uv.x)/PI;\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n        weights[i] = vec3(vec2(0.0), 1.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0)*.5+1.0;\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0)*2.0;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0)*.5+1.0;\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0)*2.0;\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        antispeckle *= stretch;\n\n        float weight = smoothstep(0.0, 1.0, pow(antispeckle, 1.0/float(i+1)));\n        \n        weights[i] = vec3(uv*2.0-1.0, weight);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(floor(uv.x+uv.y)*PI*123.0);\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        center = min(center, distTree);\n        \n        angle = (angle*angleTree);\n        \n        color += (galaxy((p.xy)*2.0-1.0)+stars(p.xy))*draw*weight;//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n    \n    fragColor = vec4((color)*GR);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 877, 897, 897, 1014], [1015, 1015, 1033, 1033, 1072], [1074, 1074, 1092, 1092, 1141], [1142, 1142, 1160, 1160, 1219], [1527, 1584, 1606, 1606, 2474], [2476, 2539, 2568, 2568, 2638], [2640, 2640, 2669, 2669, 2753], [2755, 2755, 2823, 2871, 4140], [4142, 4204, 4309, 4309, 5054], [5079, 5079, 5100, 5100, 5407], [5409, 5409, 5466, 5466, 7414]], "test": "valid"}
{"id": "4tG3RK", "name": "Sphere skeleton 2", "author": "deadmanswitch", "description": "Just experimenting...", "tags": ["raymarch", "sphere", "folding", "tetrahedron"], "likes": 6, "viewed": 176, "published": "Public", "date": "1475391686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FOV 60.0\n\n#define MAX_STEP   16\n#define MAX_STEP_F 16.0\n\nconst float infinity = 1.0/0.000000000000001;\nconst float PI = asin(1.0)*2.0;\n\n\nfloat max4(in vec4 v4) {\n    return max( max(v4.x, v4.y), max(v4.z, v4.w) );\n}\n\n\n// rotations\nvec3 rotateX(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0],\n        vec[1]*cos(rad) - vec[2]*sin(rad),\n        vec[1]*sin(rad) + vec[2]*cos(rad)\n    );\n        \n}\n\nvec3 rotateY(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[2]*sin(rad) + vec[0]*cos(rad),\n        vec[1],\n        vec[2]*cos(rad) - vec[0]*sin(rad)\n    );\n}\n\nvec3 rotateZ(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0]*cos(rad) - vec[1]*sin(rad),\n        vec[0]*sin(rad) + vec[1]*cos(rad),\n        vec[2]\n    );\n}\n\n\n/***************\n\nTetrahedron start\n\n***************/\n\n// normals\nconst vec3 norm1 = vec3(\n\t0.4714045226573944,\n    0.3333333432674408,\n    -0.8164966106414795\n);\nconst vec3 norm2 = vec3(\n\t-0.9428090453147888,\n    0.3333333432674408,\n    0.0\n);\nconst vec3 norm3 = vec3(\n\t0.4714045524597168,\n    0.3333333432674408,\n    0.8164966106414795\n);\n\n// points\nconst vec3 point0 = vec3(0.0,1.0,0.0);\nconst vec3 point1 = vec3(0.9428090453147888,-0.3333333432674408,0);\nconst vec3 point2 = vec3(-0.4714045226573944,-0.3333333432674408,-0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944,-0.3333333432674408,0.8164966106414795);\n\nfloat planedist(in vec3 point, in vec3 norm) {\n\n    return dot(point, norm) - norm.y;\n\n}\n\nconst float size = 3.0;\nfloat tet(in vec3 point) {\n    \n    point = point/size;\n\n    // subtracting the planes from a sphere\n    float dist = max4(vec4(\n        planedist(point, norm1),\n        planedist(point, norm2),\n        planedist(point, norm3),\n        -(1.0/3.0+point.y)\n    ));\n\n    // the sphere has a `size` radius\n    dist = max(length(point)-1.0, dist)*size;\n\n    return dist;\n    \n}\n\n/***************\n\nTetrahedron end\n\n***************/\n\nconst mat2 foldb = mat2(0.7071067690849304, -0.7071067690849304, 0.7071067690849304, 0.7071067690849304);\nconst mat2 foldi = mat2(0.7071067690849304, 0.7071067690849304, -0.7071067690849304, 0.7071067690849304);\n\nvoid fold(inout vec2 vec) {\n    vec = (abs(vec*foldb))*foldi;\n}\n\nfloat DE(in vec3 pos) {\n    \n    float rot = (iTime*0.25)*PI*2.0;\n    \n    pos = rotateX(pos, rot);\n    pos = rotateY(pos, rot);\n    pos = rotateZ(pos, rot*0.5);\n    \n    // folding\n    for(int i=0; i<16; i++) {\n        \n        fold(pos.xy);\n        //if(pos.x+pos.y<0.0){pos.xy=-pos.yx;}\n        //pos.xy = mix(pos.xy, -pos.yx, float(pos.x+pos.y<0.0));\n        \n        pos = rotateY(pos,  0.9+cos(iTime)*0.1);\n        \n        fold(pos.xz);\n        //if(pos.x+pos.z<0.0){pos.xz=-pos.zx;}\n        //pos.xz = mix(pos.xz, -pos.zx, float(pos.x+pos.z<0.0));\n        \n        pos = rotateZ(pos, -0.6-cos(iTime)*0.1);\n        \n        fold(pos.yz);\n        //if(pos.y+pos.z<0.0){pos.yz=-pos.zy;}\n        //pos.yz = mix(pos.yz, -pos.zy, float(pos.y+pos.z<0.0));\n        \n        \n    }\n    \n    return min(max(\n        tet(pos),\n        -(length(pos)-1.7)\n    ), length(pos)-1.6);\n}\n\nconst vec3 shadowColor = vec3(0.0, 0.0, 0.25);\nconst vec3 backColor = vec3(0.5, 0.4, 0.5);\nconst vec3 oColor = vec3(0.25, 0.9, 0.25);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 5.0+sin(iTime)*1.0);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\n        vec3 pos = point;\n\n        float dist = DE(pos);\n\n        if(dist < 0.0025) {\n            fragColor = vec4(mix(\n                oColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            return;\n        }\n\n        closest = min(closest, dist);\n\n        point += dir*dist;\n\n    }\n\n    // background shading\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/2.0, 0.0, 1.0))\n    ), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tG3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 169, 169, 223], [226, 239, 280, 280, 421], [423, 423, 464, 464, 596], [598, 598, 639, 639, 771], [1116, 1407, 1453, 1453, 1495], [1521, 1521, 1547, 1547, 1893], [1895, 2161, 2188, 2188, 2224], [2226, 2226, 2249, 2249, 3103], [3240, 3240, 3297, 3316, 4249]], "test": "error"}
{"id": "4tG3zV", "name": "DCT compressed image", "author": "Wumpf", "description": "Wanted to brush up my math on fourier & co. a bit, so I've wrote a program to extract discrete cosine transformation coefficients. Using first 25x25 coeffs. There are certainly a lot of clever things that can be done, maybe another time.", "tags": ["compression", "image", "dct"], "likes": 7, "viewed": 957, "published": "Public API", "date": "1475791862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n#define NUMCOEFPERDIM 25\n\nfloat coeffs[NUMCOEFPERDIM * NUMCOEFPERDIM];\n\nvoid initCoeffs()\n{\n    coeffs[0] = 494.395;\n    coeffs[1] = -13.5646;\n    coeffs[2] = 41.9669;\n    coeffs[3] = 4.77984;\n    coeffs[4] = -37.8743;\n    coeffs[5] = -5.57596;\n    coeffs[6] = 16.7766;\n    coeffs[7] = 8.43182;\n    coeffs[8] = -1.82959;\n    coeffs[9] = -9.23618;\n    coeffs[10] = -4.04652;\n    coeffs[11] = 7.2116;\n    coeffs[12] = 3.51418;\n    coeffs[13] = -3.06341;\n    coeffs[14] = -1.74854;\n    coeffs[15] = -0.444344;\n    coeffs[16] = 1.50488;\n    coeffs[17] = 1.62088;\n    coeffs[18] = -2.25167;\n    coeffs[19] = -0.730986;\n    coeffs[20] = 2.39072;\n    coeffs[21] = -0.463996;\n    coeffs[22] = -1.2518;\n    coeffs[23] = 0.76738;\n    coeffs[24] = -0.354769;\n    coeffs[25] = 18.7524;\n    coeffs[26] = 9.93594;\n    coeffs[27] = -5.35632;\n    coeffs[28] = -7.28919;\n    coeffs[29] = -1.29845;\n    coeffs[30] = 2.71562;\n    coeffs[31] = 4.89264;\n    coeffs[32] = -2.17536;\n    coeffs[33] = -6.26781;\n    coeffs[34] = 0.39897;\n    coeffs[35] = 3.507;\n    coeffs[36] = 1.54239;\n    coeffs[37] = 0.0461554;\n    coeffs[38] = -3.06431;\n    coeffs[39] = -2.45806;\n    coeffs[40] = 2.98707;\n    coeffs[41] = 2.62967;\n    coeffs[42] = -1.74936;\n    coeffs[43] = -1.69008;\n    coeffs[44] = 0.313373;\n    coeffs[45] = 0.752267;\n    coeffs[46] = 0.145385;\n    coeffs[47] = -0.362298;\n    coeffs[48] = 0.336287;\n    coeffs[49] = 0.220463;\n    coeffs[50] = 4.18967;\n    coeffs[51] = -4.63273;\n    coeffs[52] = -7.77723;\n    coeffs[53] = 6.37916;\n    coeffs[54] = 12.4236;\n    coeffs[55] = 0.0885493;\n    coeffs[56] = -5.60069;\n    coeffs[57] = -2.82083;\n    coeffs[58] = 1.20864;\n    coeffs[59] = 4.69616;\n    coeffs[60] = 1.24416;\n    coeffs[61] = -4.34756;\n    coeffs[62] = -1.36584;\n    coeffs[63] = 2.23751;\n    coeffs[64] = 0.593885;\n    coeffs[65] = 0.609715;\n    coeffs[66] = 0.237362;\n    coeffs[67] = -2.6725;\n    coeffs[68] = -0.531359;\n    coeffs[69] = 3.16936;\n    coeffs[70] = 0.63715;\n    coeffs[71] = -2.26343;\n    coeffs[72] = -0.800843;\n    coeffs[73] = 1.00635;\n    coeffs[74] = 1.14694;\n    coeffs[75] = -2.24162;\n    coeffs[76] = -7.5841;\n    coeffs[77] = -7.0568;\n    coeffs[78] = -1.00054;\n    coeffs[79] = 3.13626;\n    coeffs[80] = -1.94589;\n    coeffs[81] = -4.2288;\n    coeffs[82] = 2.5791;\n    coeffs[83] = 4.20044;\n    coeffs[84] = -0.482875;\n    coeffs[85] = -1.95892;\n    coeffs[86] = -1.94577;\n    coeffs[87] = -0.22502;\n    coeffs[88] = 3.47217;\n    coeffs[89] = 1.37452;\n    coeffs[90] = -2.78348;\n    coeffs[91] = -1.11757;\n    coeffs[92] = 0.518372;\n    coeffs[93] = 0.421167;\n    coeffs[94] = 1.8186;\n    coeffs[95] = 0.142723;\n    coeffs[96] = -2.74054;\n    coeffs[97] = -0.430919;\n    coeffs[98] = 2.05807;\n    coeffs[99] = 0.770575;\n    coeffs[100] = 20.5824;\n    coeffs[101] = 7.80979;\n    coeffs[102] = -4.88104;\n    coeffs[103] = -1.32424;\n    coeffs[104] = 2.12735;\n    coeffs[105] = -0.802179;\n    coeffs[106] = -0.762283;\n    coeffs[107] = -0.860417;\n    coeffs[108] = -1.75929;\n    coeffs[109] = -0.517978;\n    coeffs[110] = 0.952846;\n    coeffs[111] = 1.5104;\n    coeffs[112] = 0.107919;\n    coeffs[113] = -2.08173;\n    coeffs[114] = -0.693179;\n    coeffs[115] = 1.22821;\n    coeffs[116] = 0.148195;\n    coeffs[117] = 0.109813;\n    coeffs[118] = 0.491949;\n    coeffs[119] = -1.02881;\n    coeffs[120] = -0.793089;\n    coeffs[121] = 0.688047;\n    coeffs[122] = 0.517889;\n    coeffs[123] = 0.350453;\n    coeffs[124] = -0.196136;\n    coeffs[125] = -6.91592;\n    coeffs[126] = -6.21761;\n    coeffs[127] = -1.84712;\n    coeffs[128] = 2.67833;\n    coeffs[129] = 6.3377;\n    coeffs[130] = 2.24734;\n    coeffs[131] = -3.07691;\n    coeffs[132] = -0.103575;\n    coeffs[133] = 2.27664;\n    coeffs[134] = -0.588895;\n    coeffs[135] = 0.0601178;\n    coeffs[136] = 1.57542;\n    coeffs[137] = -1.67843;\n    coeffs[138] = -2.08905;\n    coeffs[139] = 2.03704;\n    coeffs[140] = 2.39365;\n    coeffs[141] = -1.05243;\n    coeffs[142] = -1.87116;\n    coeffs[143] = -0.023114;\n    coeffs[144] = 0.76102;\n    coeffs[145] = 0.528136;\n    coeffs[146] = 0.725137;\n    coeffs[147] = -0.174091;\n    coeffs[148] = -1.73191;\n    coeffs[149] = -0.548193;\n    coeffs[150] = 6.4707;\n    coeffs[151] = 1.79065;\n    coeffs[152] = -3.69257;\n    coeffs[153] = -3.63666;\n    coeffs[154] = -1.23624;\n    coeffs[155] = -1.15247;\n    coeffs[156] = -1.05702;\n    coeffs[157] = 0.848297;\n    coeffs[158] = 1.46943;\n    coeffs[159] = -0.697547;\n    coeffs[160] = -1.23902;\n    coeffs[161] = 0.672676;\n    coeffs[162] = 0.5174;\n    coeffs[163] = -0.542504;\n    coeffs[164] = 0.642731;\n    coeffs[165] = 0.385149;\n    coeffs[166] = -1.61349;\n    coeffs[167] = -0.223498;\n    coeffs[168] = 1.87298;\n    coeffs[169] = 0.00415485;\n    coeffs[170] = -1.42451;\n    coeffs[171] = 0.212456;\n    coeffs[172] = 0.651555;\n    coeffs[173] = -0.515139;\n    coeffs[174] = -0.172124;\n    coeffs[175] = -4.66359;\n    coeffs[176] = 0.431829;\n    coeffs[177] = 5.4295;\n    coeffs[178] = 1.65706;\n    coeffs[179] = 0.186429;\n    coeffs[180] = 0.905641;\n    coeffs[181] = -1.35063;\n    coeffs[182] = -0.680284;\n    coeffs[183] = 1.9447;\n    coeffs[184] = -0.663274;\n    coeffs[185] = -2.54696;\n    coeffs[186] = 0.754769;\n    coeffs[187] = 1.77759;\n    coeffs[188] = -0.0765175;\n    coeffs[189] = -0.673776;\n    coeffs[190] = -1.18975;\n    coeffs[191] = -0.442769;\n    coeffs[192] = 2.10452;\n    coeffs[193] = 1.19085;\n    coeffs[194] = -2.09438;\n    coeffs[195] = -1.53746;\n    coeffs[196] = 1.17661;\n    coeffs[197] = 1.45972;\n    coeffs[198] = -0.0229687;\n    coeffs[199] = -1.03986;\n    coeffs[200] = -0.726621;\n    coeffs[201] = -1.11163;\n    coeffs[202] = -1.56653;\n    coeffs[203] = -1.29495;\n    coeffs[204] = -0.152143;\n    coeffs[205] = 0.308943;\n    coeffs[206] = 0.170185;\n    coeffs[207] = 0.348096;\n    coeffs[208] = 0.840095;\n    coeffs[209] = 0.723897;\n    coeffs[210] = -0.515555;\n    coeffs[211] = -0.984474;\n    coeffs[212] = 0.543812;\n    coeffs[213] = 1.32885;\n    coeffs[214] = -0.444732;\n    coeffs[215] = -1.5059;\n    coeffs[216] = 0.302356;\n    coeffs[217] = 1.73601;\n    coeffs[218] = 0.0465957;\n    coeffs[219] = -1.88839;\n    coeffs[220] = -0.442117;\n    coeffs[221] = 1.84908;\n    coeffs[222] = 0.735019;\n    coeffs[223] = -1.27315;\n    coeffs[224] = -0.778266;\n    coeffs[225] = -2.62196;\n    coeffs[226] = 0.365127;\n    coeffs[227] = 3.93316;\n    coeffs[228] = 1.11625;\n    coeffs[229] = -1.96713;\n    coeffs[230] = -0.757537;\n    coeffs[231] = 0.263715;\n    coeffs[232] = -0.699247;\n    coeffs[233] = -0.0643564;\n    coeffs[234] = 0.728661;\n    coeffs[235] = -0.69722;\n    coeffs[236] = -1.33556;\n    coeffs[237] = 0.527019;\n    coeffs[238] = 1.86272;\n    coeffs[239] = 0.12635;\n    coeffs[240] = -2.22478;\n    coeffs[241] = -0.712762;\n    coeffs[242] = 2.24957;\n    coeffs[243] = 0.650081;\n    coeffs[244] = -1.98608;\n    coeffs[245] = -0.098079;\n    coeffs[246] = 1.42176;\n    coeffs[247] = -0.511796;\n    coeffs[248] = -0.849269;\n    coeffs[249] = 0.715431;\n    coeffs[250] = 2.65722;\n    coeffs[251] = 0.120378;\n    coeffs[252] = -2.27558;\n    coeffs[253] = -0.538665;\n    coeffs[254] = 0.753468;\n    coeffs[255] = 0.455773;\n    coeffs[256] = 1.30087;\n    coeffs[257] = 0.506783;\n    coeffs[258] = -1.50096;\n    coeffs[259] = 0.239215;\n    coeffs[260] = 1.8658;\n    coeffs[261] = -0.906188;\n    coeffs[262] = -1.62832;\n    coeffs[263] = 1.27363;\n    coeffs[264] = 0.766879;\n    coeffs[265] = -1.59346;\n    coeffs[266] = -0.071428;\n    coeffs[267] = 1.64908;\n    coeffs[268] = -0.152404;\n    coeffs[269] = -1.44594;\n    coeffs[270] = 0.0704592;\n    coeffs[271] = 1.16815;\n    coeffs[272] = 0.00767683;\n    coeffs[273] = -0.835177;\n    coeffs[274] = 0.139939;\n    coeffs[275] = -1.8201;\n    coeffs[276] = -0.824992;\n    coeffs[277] = 1.2531;\n    coeffs[278] = 1.00603;\n    coeffs[279] = -0.832131;\n    coeffs[280] = -0.626554;\n    coeffs[281] = 0.412398;\n    coeffs[282] = -0.615098;\n    coeffs[283] = -1.16136;\n    coeffs[284] = 0.810021;\n    coeffs[285] = 1.43834;\n    coeffs[286] = -0.475198;\n    coeffs[287] = -1.12162;\n    coeffs[288] = 0.42336;\n    coeffs[289] = 0.995039;\n    coeffs[290] = -0.326104;\n    coeffs[291] = -0.681529;\n    coeffs[292] = 0.369556;\n    coeffs[293] = 0.248059;\n    coeffs[294] = -0.578352;\n    coeffs[295] = 0.122438;\n    coeffs[296] = 0.820722;\n    coeffs[297] = -0.245473;\n    coeffs[298] = -0.939996;\n    coeffs[299] = 0.0854382;\n    coeffs[300] = 3.14612;\n    coeffs[301] = 0.737659;\n    coeffs[302] = -2.12546;\n    coeffs[303] = -1.27495;\n    coeffs[304] = 0.746418;\n    coeffs[305] = 0.843388;\n    coeffs[306] = 0.65177;\n    coeffs[307] = 0.0507128;\n    coeffs[308] = -1.10447;\n    coeffs[309] = -0.310863;\n    coeffs[310] = 1.03453;\n    coeffs[311] = -0.150192;\n    coeffs[312] = -1.22282;\n    coeffs[313] = 0.0404437;\n    coeffs[314] = 0.754832;\n    coeffs[315] = 0.195147;\n    coeffs[316] = -0.100215;\n    coeffs[317] = -0.432418;\n    coeffs[318] = -0.385863;\n    coeffs[319] = 0.507201;\n    coeffs[320] = 0.512339;\n    coeffs[321] = -0.186898;\n    coeffs[322] = -0.330197;\n    coeffs[323] = -0.445876;\n    coeffs[324] = -0.0154375;\n    coeffs[325] = -1.76403;\n    coeffs[326] = -0.0644444;\n    coeffs[327] = 1.79106;\n    coeffs[328] = 0.0674528;\n    coeffs[329] = -0.965629;\n    coeffs[330] = 0.620591;\n    coeffs[331] = 0.366224;\n    coeffs[332] = -1.45743;\n    coeffs[333] = -0.283529;\n    coeffs[334] = 1.48205;\n    coeffs[335] = 0.327698;\n    coeffs[336] = -0.434467;\n    coeffs[337] = 0.315089;\n    coeffs[338] = -0.343943;\n    coeffs[339] = -0.713069;\n    coeffs[340] = 0.737843;\n    coeffs[341] = 0.637499;\n    coeffs[342] = -0.819993;\n    coeffs[343] = -0.384134;\n    coeffs[344] = 0.615394;\n    coeffs[345] = 0.0892268;\n    coeffs[346] = -0.28943;\n    coeffs[347] = 0.0824723;\n    coeffs[348] = 0.0430875;\n    coeffs[349] = -0.10953;\n    coeffs[350] = 0.511837;\n    coeffs[351] = 0.101075;\n    coeffs[352] = -0.97836;\n    coeffs[353] = -1.34072;\n    coeffs[354] = 0.698698;\n    coeffs[355] = 1.71199;\n    coeffs[356] = -0.12512;\n    coeffs[357] = -1.00507;\n    coeffs[358] = 0.290919;\n    coeffs[359] = 0.477283;\n    coeffs[360] = -0.767284;\n    coeffs[361] = -0.534213;\n    coeffs[362] = 0.713328;\n    coeffs[363] = 0.411991;\n    coeffs[364] = -0.551551;\n    coeffs[365] = 0.0214374;\n    coeffs[366] = 0.635476;\n    coeffs[367] = -0.394755;\n    coeffs[368] = -0.673959;\n    coeffs[369] = 0.663754;\n    coeffs[370] = 0.516196;\n    coeffs[371] = -0.713938;\n    coeffs[372] = -0.18595;\n    coeffs[373] = 0.52125;\n    coeffs[374] = -0.171136;\n    coeffs[375] = -1.89497;\n    coeffs[376] = 0.232206;\n    coeffs[377] = 2.33345;\n    coeffs[378] = 0.131642;\n    coeffs[379] = -1.70883;\n    coeffs[380] = -0.491604;\n    coeffs[381] = 0.0772628;\n    coeffs[382] = -0.297884;\n    coeffs[383] = 0.827929;\n    coeffs[384] = 1.01672;\n    coeffs[385] = -1.05273;\n    coeffs[386] = -0.937763;\n    coeffs[387] = 1.25089;\n    coeffs[388] = 0.515714;\n    coeffs[389] = -1.28388;\n    coeffs[390] = -0.16545;\n    coeffs[391] = 0.828492;\n    coeffs[392] = -0.307543;\n    coeffs[393] = -0.230293;\n    coeffs[394] = 0.693498;\n    coeffs[395] = -0.178155;\n    coeffs[396] = -0.887135;\n    coeffs[397] = 0.29387;\n    coeffs[398] = 0.896747;\n    coeffs[399] = -0.123114;\n    coeffs[400] = 0.368227;\n    coeffs[401] = -0.247194;\n    coeffs[402] = -0.747101;\n    coeffs[403] = 0.0499551;\n    coeffs[404] = 1.13227;\n    coeffs[405] = 0.60035;\n    coeffs[406] = -0.531017;\n    coeffs[407] = -0.321621;\n    coeffs[408] = 0.277197;\n    coeffs[409] = -0.283301;\n    coeffs[410] = -0.626655;\n    coeffs[411] = 0.282738;\n    coeffs[412] = 0.772292;\n    coeffs[413] = 0.0258566;\n    coeffs[414] = -0.479425;\n    coeffs[415] = -0.0571917;\n    coeffs[416] = 0.244124;\n    coeffs[417] = -0.0456812;\n    coeffs[418] = -0.0215264;\n    coeffs[419] = 0.320773;\n    coeffs[420] = -0.209414;\n    coeffs[421] = -0.725256;\n    coeffs[422] = 0.375311;\n    coeffs[423] = 1.03508;\n    coeffs[424] = -0.416676;\n    coeffs[425] = -0.987258;\n    coeffs[426] = -0.217801;\n    coeffs[427] = 0.976045;\n    coeffs[428] = 0.509702;\n    coeffs[429] = -1.15605;\n    coeffs[430] = -1.22834;\n    coeffs[431] = 0.468906;\n    coeffs[432] = 1.1336;\n    coeffs[433] = 0.292313;\n    coeffs[434] = -0.352166;\n    coeffs[435] = -0.396019;\n    coeffs[436] = -0.00275919;\n    coeffs[437] = 0.263693;\n    coeffs[438] = -0.248527;\n    coeffs[439] = -0.316508;\n    coeffs[440] = 0.491006;\n    coeffs[441] = 0.159834;\n    coeffs[442] = -0.699313;\n    coeffs[443] = 0.175603;\n    coeffs[444] = 0.805934;\n    coeffs[445] = -0.427806;\n    coeffs[446] = -0.718106;\n    coeffs[447] = 0.528963;\n    coeffs[448] = 0.553759;\n    coeffs[449] = -0.463582;\n    coeffs[450] = 1.09396;\n    coeffs[451] = 0.0625137;\n    coeffs[452] = -0.853369;\n    coeffs[453] = 0.12247;\n    coeffs[454] = 0.921014;\n    coeffs[455] = 0.0446483;\n    coeffs[456] = -0.571989;\n    coeffs[457] = -0.106599;\n    coeffs[458] = -0.0916351;\n    coeffs[459] = -0.51295;\n    coeffs[460] = 0.219228;\n    coeffs[461] = 0.93716;\n    coeffs[462] = -0.0680066;\n    coeffs[463] = -0.80916;\n    coeffs[464] = 0.238682;\n    coeffs[465] = 0.663358;\n    coeffs[466] = -0.41034;\n    coeffs[467] = -0.58502;\n    coeffs[468] = 0.360119;\n    coeffs[469] = 0.493238;\n    coeffs[470] = -0.241045;\n    coeffs[471] = -0.486586;\n    coeffs[472] = 0.11023;\n    coeffs[473] = 0.523096;\n    coeffs[474] = -0.0306005;\n    coeffs[475] = -1.18712;\n    coeffs[476] = -0.211873;\n    coeffs[477] = 1.00137;\n    coeffs[478] = 0.26032;\n    coeffs[479] = -0.939456;\n    coeffs[480] = -0.384105;\n    coeffs[481] = 0.878409;\n    coeffs[482] = 0.643452;\n    coeffs[483] = -0.439419;\n    coeffs[484] = -0.412681;\n    coeffs[485] = 0.238787;\n    coeffs[486] = 0.13411;\n    coeffs[487] = -0.336346;\n    coeffs[488] = -0.299851;\n    coeffs[489] = 0.146031;\n    coeffs[490] = 0.473731;\n    coeffs[491] = 0.134335;\n    coeffs[492] = -0.432362;\n    coeffs[493] = -0.166888;\n    coeffs[494] = 0.375392;\n    coeffs[495] = 0.128898;\n    coeffs[496] = -0.244854;\n    coeffs[497] = -0.102286;\n    coeffs[498] = 0.0809971;\n    coeffs[499] = 0.110838;\n    coeffs[500] = 0.488463;\n    coeffs[501] = 0.137432;\n    coeffs[502] = -0.393352;\n    coeffs[503] = -0.391129;\n    coeffs[504] = 0.12356;\n    coeffs[505] = 0.325006;\n    coeffs[506] = 0.0480846;\n    coeffs[507] = -0.230353;\n    coeffs[508] = -0.444504;\n    coeffs[509] = -0.164784;\n    coeffs[510] = 0.701486;\n    coeffs[511] = 0.672481;\n    coeffs[512] = -0.540006;\n    coeffs[513] = -0.645802;\n    coeffs[514] = 0.392389;\n    coeffs[515] = 0.322307;\n    coeffs[516] = -0.309034;\n    coeffs[517] = -0.0668094;\n    coeffs[518] = -0.0623083;\n    coeffs[519] = -0.211155;\n    coeffs[520] = 0.438783;\n    coeffs[521] = 0.379299;\n    coeffs[522] = -0.645249;\n    coeffs[523] = -0.310434;\n    coeffs[524] = 0.623624;\n    coeffs[525] = -0.773622;\n    coeffs[526] = -0.0816086;\n    coeffs[527] = 0.951796;\n    coeffs[528] = 0.469997;\n    coeffs[529] = -0.909794;\n    coeffs[530] = -0.710066;\n    coeffs[531] = 0.886978;\n    coeffs[532] = 0.823525;\n    coeffs[533] = -0.865341;\n    coeffs[534] = -0.7379;\n    coeffs[535] = 0.727621;\n    coeffs[536] = 0.331575;\n    coeffs[537] = -0.729416;\n    coeffs[538] = -0.0493793;\n    coeffs[539] = 0.576512;\n    coeffs[540] = -0.0355729;\n    coeffs[541] = -0.0918345;\n    coeffs[542] = 0.258267;\n    coeffs[543] = -0.23126;\n    coeffs[544] = -0.387934;\n    coeffs[545] = 0.381871;\n    coeffs[546] = 0.38694;\n    coeffs[547] = -0.453763;\n    coeffs[548] = -0.396116;\n    coeffs[549] = 0.463148;\n    coeffs[550] = 0.588154;\n    coeffs[551] = -0.27632;\n    coeffs[552] = -0.731912;\n    coeffs[553] = 0.421808;\n    coeffs[554] = 0.666137;\n    coeffs[555] = -0.426271;\n    coeffs[556] = -0.266606;\n    coeffs[557] = 0.525384;\n    coeffs[558] = -0.13332;\n    coeffs[559] = -0.58989;\n    coeffs[560] = 0.512141;\n    coeffs[561] = 0.661172;\n    coeffs[562] = -0.62655;\n    coeffs[563] = -0.562794;\n    coeffs[564] = 0.516523;\n    coeffs[565] = 0.124536;\n    coeffs[566] = -0.50497;\n    coeffs[567] = 0.177342;\n    coeffs[568] = 0.318058;\n    coeffs[569] = -0.36976;\n    coeffs[570] = 0.0442934;\n    coeffs[571] = 0.515356;\n    coeffs[572] = -0.32588;\n    coeffs[573] = -0.499825;\n    coeffs[574] = 0.454284;\n    coeffs[575] = 0.361283;\n    coeffs[576] = -0.136069;\n    coeffs[577] = -0.139471;\n    coeffs[578] = 0.519003;\n    coeffs[579] = -0.250117;\n    coeffs[580] = -1.06203;\n    coeffs[581] = 0.33148;\n    coeffs[582] = 1.23543;\n    coeffs[583] = -0.299792;\n    coeffs[584] = -0.972713;\n    coeffs[585] = 0.331596;\n    coeffs[586] = 0.52163;\n    coeffs[587] = -0.348148;\n    coeffs[588] = -0.0212452;\n    coeffs[589] = 0.459603;\n    coeffs[590] = -0.149935;\n    coeffs[591] = -0.293934;\n    coeffs[592] = 0.215079;\n    coeffs[593] = 0.0473996;\n    coeffs[594] = -0.283563;\n    coeffs[595] = 0.0127693;\n    coeffs[596] = 0.208312;\n    coeffs[597] = -0.0189122;\n    coeffs[598] = -0.193202;\n    coeffs[599] = -0.00483542;\n    coeffs[600] = 0.755723;\n    coeffs[601] = -0.132498;\n    coeffs[602] = -0.795457;\n    coeffs[603] = 0.348688;\n    coeffs[604] = 0.997699;\n    coeffs[605] = -0.16053;\n    coeffs[606] = -0.868536;\n    coeffs[607] = -0.087033;\n    coeffs[608] = 0.399656;\n    coeffs[609] = 0.00944414;\n    coeffs[610] = -0.126786;\n    coeffs[611] = 0.0986666;\n    coeffs[612] = -0.0431641;\n    coeffs[613] = -0.227969;\n    coeffs[614] = -0.00853011;\n    coeffs[615] = 0.145872;\n    coeffs[616] = -0.00678391;\n    coeffs[617] = 0.0396794;\n    coeffs[618] = 0.144238;\n    coeffs[619] = -0.0728417;\n    coeffs[620] = -0.0999985;\n    coeffs[621] = 0.16627;\n    coeffs[622] = 0.00743231;\n    coeffs[623] = -0.238452;\n    coeffs[624] = 0.0520685;\n}\n\nvec3 desaturate(in vec3 color, in float saturation)\n{\n\tfloat grey = dot(color, vec3(0.3, 0.59, 0.11));\n    return mix(vec3(grey), color, saturation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    initCoeffs();\n    \n    int numDisplayed = int(iTime*40.0);\n    \n    float minRes = min(iResolution.x, iResolution.y);\n    \n    vec2 squareCoord = vec2(fragCoord.x - (iResolution.x - minRes) * 0.5,\n                            fragCoord.y - (iResolution.y - minRes) * 0.5);\n    if(squareCoord.x < 0.0 || squareCoord.y < 0.0 || \n       squareCoord.x > minRes || squareCoord.y > minRes)\n    {\n        fragColor = vec4(0.0);\n    \treturn;\n    }\n    \n    vec2 freqC = vec2(PI / minRes * (squareCoord.x + 0.5),\n                      PI / minRes * (minRes - squareCoord.y));\n    \n    float image = 0.0;\n    for(int y=0; y<NUMCOEFPERDIM; ++y)\n    {\n        for(int x=0; x<NUMCOEFPERDIM; ++x)\n        {\n            vec2 wave = cos(freqC * vec2(x, y));\n            float contribuation = coeffs[x + y * NUMCOEFPERDIM] * wave.x * wave.y;\n            if(x + y * NUMCOEFPERDIM < numDisplayed)\n            \timage += contribuation;\n        }\n    }\n    \n    // scaling and some \"postpro\"\n    image = pow(max(image, 0.0) * 0.0017, 2.5);\n    fragColor.rgb = vec3(image);\n    // Some grain to hide the terrible ringing a bit.\n    //if(false)\n    {\n        vec3 noise0 = desaturate(texture(iChannel0, squareCoord/iChannelResolution[0].xy).rgb, 0.7);\n        vec3 noise1 = desaturate(texture(iChannel0, squareCoord/iChannelResolution[0].xy * 0.75).rgb, 0.4);\n        vec3 noise2 = desaturate(texture(iChannel0, squareCoord/iChannelResolution[0].xy * 0.5).rgb, 0.2);\n        fragColor.rgb = mix(fragColor.rgb, noise2, 0.1);\n        fragColor.rgb = mix(fragColor.rgb, noise1, 0.15);\n        fragColor.rgb = mix(fragColor.rgb, noise0, 0.2);\n    }\n    \n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tG3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 17639], [17641, 17641, 17694, 17694, 17792], [17794, 17794, 17851, 17851, 19508]], "test": "error"}
{"id": "4tGGRd", "name": "HelloWorldPlaneProjection", "author": "aminere", "description": "My first effect on shadertoy!", "tags": ["planeprojection"], "likes": 2, "viewed": 138, "published": "Public", "date": "1476130767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, res] to [-1, 1]\n\tvec2 coord = -1.0 + (fragCoord.xy / iResolution.xy)*2.0;    \n    vec2 ncoord = coord * vec2(iResolution.x / iResolution.y, 1.0); // take aspect ratio into account\n    \n    // rotation\n    float angle = radians(iTime);\n    angle = sin(angle*35.0) * radians(10.0); // fluctuate angle\n    vec2 tcoord = vec2(ncoord.x * cos(angle) - ncoord.y * sin(angle),\n                       ncoord.y * cos(angle) + ncoord.x * sin(angle));\n    \n    float lookAtOffsetY = sin(radians(iTime * 40.0)) * .5;\n    \n    // simple plane projection\n    vec2 uv = vec2(tcoord.x, 1.0) / (tcoord.y + lookAtOffsetY);\n    uv /= 4.0;\n    \n    // scrolling \n    uv.y = abs(uv.y) + iTime;\n    \n    vec4 col = texture(iChannel0, uv);\n    col.r += .2; // tint\n    \n    // horizon\n    col *= smoothstep(0.0, 0.4, abs(tcoord.y + lookAtOffsetY));\n    \n    // post process\n    float vignette = (1.0 - abs(coord.x * coord.x)) * (1.0 - abs(coord.y * coord.y));    \n    col *= vignette;\n    \n    fragColor = col;\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 84, 1057]], "test": "error"}
{"id": "4tGGRV", "name": "Library", "author": "zackpudil", "description": "AbsBox fractal with volumetric shadows and edge detection. ", "tags": ["raymarching", "volumetric"], "likes": 20, "viewed": 608, "published": "Public", "date": "1475457069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) {\n    return fract(sin(n)*43578.5453);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat de(vec3 p) {\n    vec4 q = vec4(p, 1);\n\tq.y = mod(q.y + 1.0, 2.0) - 1.0;\n    q.xyz -= 1.0;\n    \n    for(int i = 0; i < 3; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q = 1.2*q/clamp(dot(q.xyz, q.xyz), 0.25, 1.0);\n    }\n    \n    float f = box(q.xyz, vec3(1.0))/q.w;\n    f = min(f, p.y + 2.0);\n    f = min(f, min(p.x + 3.0, -p.x + 3.0));\n    f = min(f, min(p.z + 3.0, -p.z + 3.0));\n    \n    return f;\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n    for(int i = 0; i < 80; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.001 || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\n// Approvement thanks to Shane. vstrace= shadow trace in volumentric loop.\n// less detailed, dithering and breaks quicker.\nfloat vstrace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.1*hash(dot(ro, rd));\n    for(int i = 0; i < 50; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.01 || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\nvec3 normal(vec3 p, out float e) {\n    vec2 h = vec2(0.001, 0.0);\n    \n    vec3 n1 = vec3(\n        de(p + h.xyy),\n        de(p + h.yxy),\n        de(p + h.yyx)\n\t);\n    \n    vec3 n2 = vec3(\n        de(p - h.xyy),\n        de(p - h.yxy),\n        de(p - h.yyx)\n\t);\n    \n    // edge detection.\n    float d = de(p);\n    \n    vec3 e3 = abs(d - 0.5*(n1 + n2));\n    e = min(1.0, pow(e3.x + e3.y + e3.z, 0.55)*10.0);\n    return normalize(n1 - n2);\n}\n\nvec4 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = pow(n, vec3(30.0));\n    vec4 x = texture(s, p.zy);\n    vec4 y = texture(s, p.xz);\n    vec4 z = texture(s, p.xy);\n    \n    return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 ro = vec3(-2.9*sin(iTime*0.5), -1, 2.9*cos(iTime*0.5));\n    vec3 ww = normalize(vec3(0, -0.7, 0)-ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n    \n    vec3 col = vec3(0);\n    vec3 key = vec3(0, 0.0*sin(iTime*0.3), 0);\n    \n    float t = trace(ro, rd, 10.0);\n    if(t > 0.0) {\n        float edg;\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos, edg);\n        \n        // ambient occlusion.\n        float occ = 0.0, sca = 1.0, ste = 0.003;\n        for(int i = 0; i < 15; i++) {\n            float d = de(pos + nor*ste);\n            occ += (ste - d)*sca;\n            sca *= 1.0;\n            ste += ste/(float(i) + 1.0);\n        }\n        occ = 1.0 - clamp(occ, 0.0, 1.0);\n        \n        vec3 lig = normalize(key - pos);\n        float dis = length(pos - key);\n        \n        // direct lighting with hard shadows.\n        col += 0.3*clamp(dot(lig, nor), 0.0, 1.0)\n            *step(0.0, -trace(pos + nor*0.001, lig, dis));\n        \n        // indirect lighting with ambient occlusion.\n        col += 0.1*clamp(dot(-lig, nor), 0.0, 1.0)*occ;\n        \n        // material.\n        col *= texcube(iChannel0, 0.5*pos, nor).xyz;\n        \n        // edge emission texture           // avoid pixel dancing by fading the effect while the veiwer is farther away.\n        col += mix(col, vec3(0, 0.1, 2.1), edg/(0.7*length(ro)));\n    }\n    \n    // volumetric shadows\n    float s = hash(dot(uv, vec2(12.23, 39.343)))*0.05;\n    float vol = 0.0;\n    // need less light strength the closer you are to the light.\n    float e = 0.1*smoothstep(0.0, 3.5, length(key - ro));\n    for(int i = 0; i < 70; i++) {\n        if(s > t) break;\n        vec3 pos = ro + rd*s;\n        \n        vec3 lig = normalize(key - pos);\n        float dis = length(key - pos);\n        \n        // shadow trace at each position along the march.\n        float l = step(0.0, -vstrace(pos, lig, dis));\n        // light strength is proportional to distance from light.\n        l *= e/dis;\n        \n        vol += l;\n        s += 0.05;\n    }\n    \n    // blue light rays.\n    col += 0.6*vec3(0.5*vol, 0.5*vol, vol);\n    col = pow(col, vec3(1.0/2.2));\n    \n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 60], [62, 62, 89, 89, 184], [186, 186, 204, 204, 602], [604, 604, 645, 645, 842], [844, 967, 1010, 1010, 1224], [1226, 1226, 1260, 1260, 1664], [1666, 1666, 1709, 1709, 1896], [1898, 1898, 1955, 1955, 4392]], "test": "error"}
{"id": "4tGGW3", "name": "Hello Tinou 2", "author": "lilin", "description": "test", "tags": ["test"], "likes": 1, "viewed": 92, "published": "Public", "date": "1476976726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screen = fragCoord.xy / iResolution.xy;\n    float sound = texture (iChannel0, vec2(screen.x, 0.75)).x;\n    \n    vec3 color = vec3(.0);\n    \n    color += vec3(abs(sin(iTime)) - smoothstep(0.0, 0.2, abs(sound - screen.y)),\n                  abs(sin(iTime * 2.0/3.0 * 3.1415)) - smoothstep(0.0, abs(sin(iTime) * 0.1), abs(sound - screen.y)),\n                  abs(sin(iTime * 4.0/3.0 * 3.1415)) - smoothstep(0.0, abs(sin(iTime) * 0.1), abs(sound - screen.y)));\n                  \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdSGWR", "previewfilepath": "https://soundcloud.com/safakash/mr-unstoppable", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/safakash/mr-unstoppable", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 576]], "test": "error"}
{"id": "4tGGz3", "name": "Fixed repeat, thanks Klems!", "author": "efairbanks", "description": "I was having a problem with repeat not working because I made a stupid mistake. Look near line 28 to see my error and how it was resolved.", "tags": ["raymarcher", "mod", "bug", "repeat", "fixed"], "likes": 0, "viewed": 136, "published": "Public", "date": "1475701171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCH_STEPS 30.0\n#define EPSILON 0.001\n#define GRADIENT_STEP 0.02\n\n//#define DEMONSTRATE_BUG true\n\n#define M_PI 3.1415926535897932384626433832795\n\n// for generating distance map of box with rounded corners\nfloat box(vec3 p, vec3 b, float roundness)\n{\n\treturn length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n}\n\n// combine shapes smoothly\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\n// field of view of camera\n#define FOV 0.06\n// generate combined distance field\nfloat map(vec3 p)\n{\n    /*\n#ifndef DEMONSTRATE_BUG\n    // repeat following shape?\n    if(mod(iTime,6.)>2.0) p.xz=mod(p.xz,vec2(8.)-4.);\n#else\n    if(DEMONSTRATE_BUG) p.xz=mod(p.xz,vec2(8.)-4.);\n#endif\n*/\n\tp.xz=mod(p.xz,vec2(8.))-4.;\n    \n    // draw rounded box\n    float boxSize = 2.;\n\tfloat d = box(p,vec3(boxSize), boxSize/3.);\n\n\treturn d;\n}\n\n// raymarching procedure with lots of output info\nvoid march(vec3 origin, vec3 direction, out vec3 rayHead, out bool hit, out float dist, out float steps)\n{\n    float distanceTraveled = 0.;\n    hit = true;\n    for(float step=0.; step<MARCH_STEPS; step++)\n    {\n        rayHead = origin + (direction*distanceTraveled);\n        dist = map(rayHead);\n        steps = step;\n        if(dist<EPSILON||step>=MARCH_STEPS) return;\n        distanceTraveled += dist;\n    }\n    hit = false;\n}\n\n// get origin and direction of ray to be cast for camera/screen xy (pixel) coordinate\nvoid cameraRay(vec2 scanLines, vec3 cameraPosition, vec3 target, float fov, out vec3 pos, out vec3 dir)\n{\n\tvec3 forward = normalize(target-cameraPosition);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*scanLines.x*fov;\n    up = up*scanLines.y*fov;\n    \n    pos = cameraPosition;\n    dir = (right+up+forward);\n}\n\n// get surface normal of point on distance field for shading\nvec3 gradient( vec3 pos )\n{\n\tconst vec3 dx = vec3( GRADIENT_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRADIENT_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRADIENT_STEP );\n\treturn normalize(vec3(\n\t\tmap( pos + dx ) - map( pos - dx ),\n\t\tmap( pos + dy ) - map( pos - dy ),\n\t\tmap( pos + dz ) - map( pos - dz )\n\t));\n}\n\n// calculate diffuse lighting for point on distance field given surface normal\nfloat diffuse(vec3 normal, vec3 lightPosition)\n{\n\treturn max(dot(normal,normalize(lightPosition)),0.);\n}\n\n// calculate diffuse lighting for point on distance field\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// calculate combined lighting for point on distance field\nfloat shadePoint(vec3 position, vec3 normal, vec3 lightPosition)\n{\n    float diffuseLight = diffuse(normal, lightPosition);\n\t// speculative light - it might be specular, but we're not really sure\n    float specularLight = pow(diffuseLight,30.);\n\tfloat shadow = softshadow(position, normalize(lightPosition), 0.02, 2.25);\n    return (diffuseLight+specularLight)*shadow;\n}\n\n// generate background color\nvec3 background(vec2 uv)\n{\n\treturn vec3(0.5,0.5,0.5)*uv.y;\n}\n\n// compose image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale coordinates to -1 -> +1, adjusted for screen aspect ratio\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.-1.;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    // get ray representing camera scanline position and direction\n    vec3 cameraPosition = normalize(vec3(sin(iTime*1.5),-0.7,cos(iTime*1.5)))*200.;\n    vec3 cameraOrigin;\n    vec3 cameraDirection;\n    cameraRay(uv, cameraPosition, vec3(0.,0.,0.), FOV, cameraOrigin, cameraDirection);\n    \n    // calculate distance, hit point, etc of distance field via raymarching\n    vec3 rayHead;\n    bool hit;\n    float dist;\n    float steps = 40.;\n    march(cameraOrigin, cameraDirection, rayHead, hit, dist, steps);\n    \n    // calculate normal for point on distance field\n    vec3 normal = gradient(rayHead);\n    \n    // calculate light for point\n\tvec3 rotLightPos = vec3(-1.,-1.,0.);\n    vec3 latRotLightPos = vec3(0.,-1.,-1.);\n    vec3 lightPos = vec3(cos(iTime),sin(iTime),cos(iTime));\n    float light = 0.;\n    light += shadePoint(rayHead, normal, rotLightPos);\n    light += shadePoint(rayHead, normal, latRotLightPos);\n    light += shadePoint(rayHead, normal, lightPos);\n    light /= 3.;\n    \n    // specify color of entire distance field\n    vec3 fieldColor = vec3(1.0,0.4,0.4);\n    \n    // final steps and background\n    vec3 color = fieldColor*light;\n    if(!hit) color = background(uv);\n    \n    // set fragment shader color\n    fragColor = vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 214, 258, 258, 323], [325, 352, 393, 393, 476], [522, 558, 577, 761, 902], [904, 954, 1060, 1060, 1383], [1385, 1471, 1576, 1576, 1878], [1880, 1941, 1968, 1968, 2259], [2261, 2340, 2388, 2388, 2444], [2446, 2504, 2578, 2578, 2836], [2838, 2897, 2963, 2963, 3267], [3269, 3298, 3324, 3324, 3358], [3360, 3377, 3433, 3504, 4873]], "test": "valid"}
{"id": "4tKGDK", "name": "Sine visualization test", "author": "VirtuosoChris", "description": "basic function graphing test", "tags": ["visualization", "sine", "graph", "function"], "likes": 2, "viewed": 133, "published": "Public", "date": "1476831684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float func (float x)\n{\n\treturn sin(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float domain = 4.0 * 3.14159;\n    \n    vec2 origin = vec2(0.0, -2.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= domain;\n    uv += origin;\n     \n    \n    float outVal = func(uv.x + iTime);\n    \n    float difference = abs(outVal - uv.y);\n    \n    float edge = smoothstep(.1, .2, difference);\n    \n    fragColor = vec4(edge);\n    \n    const float axisLineSize = .05;\n    const float gridLineSize = .025;\n    \n    //draw graph paper\n    \n    fragColor = abs(uv.x) < axisLineSize ? vec4(0.0,0.0,1.0,1.0) : fragColor;\n    fragColor = abs(uv.y) < axisLineSize ? vec4(0.0,0.0,1.0,1.0) : fragColor;\n    \n    vec2 frac = fract(uv);\n    bool onGrid = any(lessThan(abs(frac), vec2(gridLineSize)));\n    \n    fragColor = onGrid ? vec4(0.0,0.0,1.0,1.0) : fragColor;\n    \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 40], [42, 42, 99, 99, 886]], "test": "valid"}
{"id": "4tKGWc", "name": "Colored tiles", "author": "kellyegan", "description": "Shifting colored checkered tiles. Part of my One Sketches project. http://kellyegan.net/2016/07/onehundred.html", "tags": ["checker", "tiles", "colorchange"], "likes": 0, "viewed": 136, "published": "Public", "date": "1477188885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 2. * acos(-1.)\n\nfloat annulus( vec2 p, float r1, float r2 ) {\n    return max(length(p) - r1, r2 - length(p));\n}\n\nfloat rect( vec2 pos, vec2 dim ) {\n    return length(max(abs(pos)-dim,0.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    \n    \n    if(iResolution.y>iResolution.x){\n        //Vertical\n        st.y*=iResolution.y/iResolution.x;\n        st.y-=(iResolution.y*.5-iResolution.x*.5)/iResolution.x;\n    }else{\n        //Horizontal\n        st.x*=iResolution.x/iResolution.y;\n        st.x-=(iResolution.x*.5-iResolution.y*.5)/iResolution.y;\n    }  \n\n    \n    fragColor  = vec4((floor(st*10.0)/10.),0.5+0.5*sin(iTime),1.0);\n    \n    float cells = 10.0;\n    \n    st = floor(st*cells)/cells;\n    \n    float w = 3. * ( sin(st.y * TAU * 2.) ) + st.y * 30.0;\n    float v = (cos(st.x * TAU * 2. + w) + 1.0) / 2.0;\n    \n\tst = st * cells;\n    \n    float f = 0.;\n    \n    if( mod(st.x,2.0) < 1.0 ) {\n        f = mod(st.y,2.0) < 1.0 ? 0.2 : 1. ;\n    } else {\n        f = mod(st.y,2.0) < 1.0 ? 1. : 0.2 ;       \n    }\n    \n    vec3 c = vec3( step(0.5, v ), f, 1.-f*v );\n    vec3 t = vec3( sin(iTime* 0.11), sin(iTime * 0.07), sin(iTime * 0.17));\n       \n\n    //st = fract(st);\n    \n    if( f == 1.0 ) {\n        c = 1. - c;\n    }\n        \n    \n    fragColor = vec4(c + t, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 73, 73, 123], [125, 125, 159, 159, 203], [206, 206, 263, 263, 1345]], "test": "valid"}
{"id": "4ttXzr", "name": "Abstract Plane Cloudy Beauty", "author": "aiekick", "description": "Abstract Plane Cloudy Beauty", "tags": ["3d", "raymarching", "cloud", "fog", "cloudy"], "likes": 26, "viewed": 1008, "published": "Public API", "date": "1477796950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/* \n\tthis shader is a mix of :\n\n \tShader Cloudy spikeball from duke : https://www.shadertoy.com/view/MljXDw\n\tShader Cloudy MegaWave from me : https://www.shadertoy.com/view/MljSRy\n\tShader Abstract Plane Beauty from me : https://www.shadertoy.com/view/MlcSzn\n*/\n\nconst vec3 lightDir = vec3(0.,1., 0.5);\nconst float mPi = 3.14159;\nconst float m2Pi = 6.28318;\n\nfloat t = 0.;\n\n/////////////////////////\n// FROM Shader Cloudy spikeball from duke : https://www.shadertoy.com/view/MljXDw\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture(iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n\trg = vec2(rg.x + rg.y)/2.;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nfloat fpn(vec3 p) \n{\n\treturn pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n/////////////////////////\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec3 path(vec3 p)\n{\n    p.xy += cos(iTime * 0.2);\n\tp *= RotZ(p.z * 0.1);\n    p += sin(p.zxy * 0.5) * 0.5;\n\tp *= RotZ(p.z * 0.2);\n    p = sin(p.zxy * 0.2) * 2.;\n    return p;\n}\n\nfloat disp(vec3 p)\n{\n    p *= 50.;\n   \treturn fpn(p) * .6;\n}\n\n\nfloat dfBase(vec3 p)\n{\n\tp += path(p);\n\tp *= RotZ(p.z * 0.045);\n    return 1. - cos(p.z*1.5) * 0.1 - abs(p.y);\n}\n\nfloat df(vec3 p)\n{\n\treturn dfBase(p) + disp(p);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    dfBase(pos+eps.xyy) - dfBase(pos-eps.xyy),\n\t    dfBase(pos+eps.yxy) - dfBase(pos-eps.yxy),\n\t    dfBase(pos+eps.yyx) - dfBase(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += dfBase(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn dfBase(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 ro = vec3(0,0, iTime * 6.); ro -= path(ro);\n    vec3 cv = ro + vec3(0,0,4); cv -= path(cv);\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    float fov = .9;\n  \tvec3 rd = normalize(fov * (uv.x * x + uv.y * y) + z);\n\t\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = ro + rd * d;\n\t\n    float dMax = 50.;\n\tfloat sMin = 0.0001;\n\t\n    /////////////////////////\n\t// FROM Shader Cloudy spikeball from duke : https://www.shadertoy.com/view/MljXDw\n\tfloat ld, td= 0.; // ld, td: local, total density \n\tfloat w; // w: weighting factor\n\tvec3 tc = vec3(.25); // total color\n   \n\tfloat h=.05;\n    const float stepf = 1./250.;\n\t/////////////////////////\n    \n\tfor (float i=0.; (i<1.); i+=stepf) \n\t{\n        // FROM Shader Cloudy spikeball from duke : https://www.shadertoy.com/view/MljXDw\n\t\tif(!((i<1.) && (s>sMin) && (d < dMax)&& (td < .95))) break;\n\t\t\n        s = df(p);\n\t\ts *= (s>0.001?0.15:.2) ;\n        \n        /////////////////////////\n\t\t// FROM Shader Cloudy spikeball from duke : https://www.shadertoy.com/view/MljXDw\n\t\tld = (h - s) * step(s, h);\n\t\tw = (1. - td) * ld;   \n\t\ttc += w; \n      \ttd += w + .005;\n      \ts = max(s, 0.02);\n        /////////////////////////\n      \t\n        d += s;\n\t  \tp = ro + rd * d;\n    }\n\t\n    // classic RM from Abstract Plane Beauty : https://www.shadertoy.com/view/MlcSzn\n    s = 1., d = 0.;\n\tfor (int i=0; i<30; i++) // 30 iterations yeah :)\n\t{\n\t\tif (log(d/1e6)>0.) break; // due to this special break condition\n\t\td += dfBase(ro+rd*d);\n\t}\n\t\n\tp = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 lid = normalize(ro-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.001);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, lid ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, lid ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(.8,.5,.2);\n    \n    // here the magix happen\n\tfloat sss = dfBase(p - n*0.001)/0.01;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = blackbody(200. * sb);\t\t\t\t\t\t\t\t\t// blackbody color\n\tfloat sss2 = 0.8 - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\n\tvec3 a = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.25 + spe; // near\n    vec3 b = col * sss * .5;\n    \n    // mix\n    fragColor.rgb = mix( tc, mix(b,a,1.-exp(-0.015*d*d)), 1.-exp(-0.01*d*d) );\n\n\t// vigneting from iq Shader Mike : https://www.shadertoy.com/view/MsXGWr\n    vec2 q = g/si;\n    fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.55 );\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttXzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[511, 619, 642, 642, 887], [889, 889, 909, 909, 970], [971, 998, 1017, 1017, 1075], [1077, 1077, 1096, 1096, 1252], [1254, 1254, 1274, 1274, 1314], [1317, 1317, 1339, 1339, 1428], [1430, 1430, 1448, 1448, 1479], [1481, 1481, 1515, 1515, 1739], [1741, 1962, 1990, 1990, 2315], [2317, 2399, 2456, 2456, 2684], [2686, 2686, 2722, 2722, 2859], [2861, 2861, 2918, 2918, 5749]], "test": "error"}
{"id": "4tV3DV", "name": "noise practice", "author": "seeyouspace", "description": "just practice of noise", "tags": ["2d", "noise"], "likes": 3, "viewed": 117, "published": "Public", "date": "1476892321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626\n#define F 16.0\n#define time iTime\n#define cc(x,a,b,c,d) (a+b*cos(2.*PI*(c*x+d)))\n#define hash21(p) (-1.+2.*fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123))\nvec2 hash22(vec2 p)\n{\n    p = mat2(127.1, 269.3, 311.7, 183.3)*p;\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n\tvec2 p = (2.*fragCoord.xy - r)/r.y*.4;\n    vec2 m = (2.*iMouse.xy - r)/r.y;\n    p *= 0.5 + 0.5*hash21(p);\n    float c = 0.5+0.5*sin(2.0*PI*F*length(p-m) + time);\n\tfragColor = cc(c,.5,.5,1.,vec4(.1,.2,.3,1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 217, 217, 314], [315, 315, 372, 372, 613]], "test": "valid"}
{"id": "4tV3W3", "name": "Function Visual", "author": "VoidChicken", "description": "A line graph showing a function.", "tags": ["2d", "line", "visualizer", "graph", "function", "equation", "visual"], "likes": 0, "viewed": 482, "published": "Public API", "date": "1477154099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(float x) {\n    //REPLACE THIS WITH FUNCTION\n\treturn mix(sqrt(x), x*x, fract(x-iTime));    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(1.-length(uv-.5)/2.62, 0, .2);\n    \n    if (abs(uv.y-(f(uv.x)))<0.002) {\n        col = vec3(1);\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 51, 100], [101, 101, 158, 158, 352]], "test": "valid"}
{"id": "4tV3z3", "name": "Power Diagram", "author": "tomkh", "description": "Closest distance to edges of Power Diagram. This is ShaderToy port. Here is original [url=http://polycu.be/edit/?h=cdpAH4]PolyCube version[/url]. Based on my [url=https://www.shadertoy.com/view/llG3zy]Faster Voronoi Edges[/url].", "tags": ["voronoi", "noise", "worley", "distance", "cellular", "powerdiagram", "voronoiedges"], "likes": 22, "viewed": 916, "published": "Public API", "date": "1475886783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2016-10-08\n\n// +LMB to see distance to circles\n\n// Relatively fast method to find closest distance to edges of Power diagram,\n// a weighted Voronoi diagram with squared weight subtracted from squared distance.\n// The edge between Power diagram of cells A and B can be also interpreted \n// as a segment spanned by intersection points of circles centered at A and B \n// with radii equal to respective weights. If sum of weights is bigger than the distance \n// between A and B, i.e. circles do not intersect, formula still holds.\n\n// PolyCube version: \n//   http://polycu.be/edit/?h=cdpAH4 - Power Diagram\n//   http://polycu.be/edit/?h=Gbhigy - Fast Voronoi Edges\n\n// ShaderToy references:\n//   https://www.shadertoy.com/view/llG3zy - My Fast Voronoi Edges (improved/corrected)\n//   https://www.shadertoy.com/view/ldl3W8 - IQ's Distance to Voronoi Edges\n//   https://www.shadertoy.com/view/4djSRW - Dave Hoskins wonderful hash functions\n\n#define SHOW_MODE 2\n // 0 = Distance to edge + mouse cursor for inspection\n // 1 = Distance to circle + mouse cursor for inspection\n // 2 = Display both and switch while pressing LMB\n\n#define ACCURACY 2\n // 0 = 3x3 both passes\n // 1 = 3x3 + 4x4 (fast + decent accuracy)\n // 2 = 4x4 both passes (improved accuracy)\n\n#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .0001\n\n// Max. distance\n#define MAX_D 9999.\n\nvec3 hash32(vec2 p)\n{\n   // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yxz+19.19);\n   vec3 o = fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n   #ifdef ANIMATE\n   o.z = 0.5 + ANIMATE_D*sin( iTime + o.z*6.283185 );\n   #endif\n   o.z *= 0.7071; // limit weight to 0..sqrt(2)/2 range\n   return o;\n}\n\n// Returns distance to closest circle with radius = weight\nfloat closest_circle( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    #if ACCURACY == 2\n    // shift by half-cell\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    #endif\n\n    float md = MAX_D;\n    vec3 mr;\n    #if ACCURACY == 2\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    #else\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    #endif\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        md = min( md, length(r) - o.z );\n    }\n    \n    return md;\n}\n\n// Power diagram-based continuous noise function (not used here)\nfloat power_noise( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    #if ACCURACY == 2\n    // shift by half-cell\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    #endif\n\n    float md = MAX_D;\n    #if ACCURACY == 2\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    #else\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    #endif\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        md = min( md, dot(r,r) - o.z*o.z );\n    }\n    \n    return md;\n}\n\n// Power Diagram edges,\n// returns closest distance to edge and closest cell with squared weight\nvec4 power_diagram( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    #if ACCURACY == 2\n    // shift by half-cell\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    #endif\n    \n    vec3 mr;\n\n    //--------------------------------------------------\n    // 1st pass: find weighted Voronoi cell for \"x\"\n    float md = MAX_D;\n    #if ACCURACY == 2\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    #else\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    #endif\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        float w = o.z*o.z;\n        float d = dot(r,r) - w;\n\n        if( d<md )\n        {\n            md = d;\n            mr = vec3(r, w);\n        }\n    }\n    //--------------------------------------------------\n    \n    #if ACCURACY == 1\n    // shift by half-cell\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    #endif\n\n    //--------------------------------------------------\n    // 2nd pass: find closest weighted Voronoi edge\n    md = MAX_D;\n    #if ACCURACY >= 1\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    #else\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    #endif\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        vec2 dr = r - mr.xy;\n        float d = dot(dr,dr);\n        if( d>EPSILON ) {\n           float mf = (mr.z - o.z*o.z + d) / (2.*d);\n           md = min( md, dot( mix(mr.xy,r,mf), dr*(1./sqrt(d)) ) );\n        }\n    }\n    //--------------------------------------------------\n\n    return vec4(md, mr);\n}\n\n// Fast voronoi to get closest distance to generator points,\n// implemented/re-implemented by others many, many times already\nfloat fast_voronoi( in vec2 x )\n{\n    x -= .5;\n    vec2 n = floor(x);\n    vec2 f = fract(x) + .5;\n    \n    float md = MAX_D;\n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        md = min(md, dot(r,r));\n    }\n    \n    return md;\n}\n\nvec3 plot( vec2 p, vec2 template_cursor, float ss )\n{\n   // Colors:\n   const vec3 interior = vec3(.2,.8,1.);\n   const vec3 exterior = vec3(1.,.4,.1);\n   const vec3 border = vec3(.1,.7,.3);\n   const vec3 point = vec3(1.,.5,0.);\n\n#if SHOW_MODE == 2\n   if (iMouse.z > 0.)\n   {\n#endif\n#if SHOW_MODE != 0\n   float c = sqrt(fast_voronoi(p));\n   float d = closest_circle(p);\n   float d2 = abs(d);\n   vec3 col =\n       mix(\n           mix(\n               (d2*1.4+.05)*mix(exterior,interior,sign(d)*.5+.5)*min(1.,d2*18.),\n               border,\n               smoothstep(.03,.01,d2)\n           )*min(1.,c*9.),\n           point,\n           smoothstep(.07,.05,c)\n       );\n   #if SHOW_MODE != 2\n   float dc = length(p - template_cursor);\n   if (dc < 2.) {\n       dc = abs(dc - abs(closest_circle(template_cursor)) + .03);\n       col = mix(col,vec3(1),smoothstep(ss,.0,dc));\n   }\n   #endif\n   return pow(col,vec3(.85));\n#endif\n#if SHOW_MODE == 2\n   }\n#endif\n#if SHOW_MODE != 1\n   vec4 cp = power_diagram(p);\n   float c = cp.x;\n    \n   float d = length(cp.yz);\n   //float d1 = sqrt(fast_voronoi(p));\n   float d2 = d - sqrt(cp.w);\n   float d3 = (1.-smoothstep(.06,.02,c));\n   vec3 col =\n   mix(      \n      mix(\n         mix(\n            (c*1.4+.05)*(sin(c*120.)*.1+.9)*interior*d3*min(1.,d*9.),\n            point,\n            smoothstep(.07,.05,d)\n         )*clamp(abs(d2)*18.,.7,1.),\n         point*d3,\n         max(smoothstep(.03,.01,abs(d2))*.5,\n             smoothstep(.03,.01,d2)*.2)\n      ),\n      border*(smoothstep(0.,.015,c)*.5+.5),\n      smoothstep(.04,.02,c)\n   );\n   #if SHOW_MODE != 2\n   float dc = length(p - template_cursor);\n   if (dc < 2.) {\n      dc = abs(dc - abs(power_diagram(template_cursor).x) + .03);\n      col = mix(col,vec3(1),smoothstep(ss,.0,dc));\n   }\n   #endif\n   return pow(col,vec3(.85))*1.2;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) * sc / iResolution.y;\n    vec2 cursor = (abs(iMouse.xy) - iResolution.xy*.5) * sc / iResolution.y;\n\tfragColor = vec4(plot(uv, cursor, sc/iResolution.y), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tV3z3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1539, 1577, 1598, 1667, 1994], [1996, 2055, 2090, 2090, 2628], [2630, 2695, 2727, 2727, 3255], [5008, 5134, 5167, 5167, 5491], [5550, 7315, 7372, 7372, 7663]], "test": "valid"}
{"id": "4tVGz3", "name": "MAT472 p.747", "author": "Museifu", "description": "MAT472 p.747", "tags": ["procedural"], "likes": 1, "viewed": 124, "published": "Public", "date": "1475888875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x - (iResolution.x / 2.);\n    x /= (iResolution.x / 2.) / 10.;\n    float y = fragCoord.y - (iResolution.y / 2.);\n    y /= (iResolution.y / 2.) / 10.;\n        \n    //float z = (1.-pow(x, 2.)) * (1.-pow(y, 2.));\n    float z = sin(x) - sin (y);\n    z = z < -0.05 ? sin(x) - sin (y): z;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    //vec4 color = vec4(0., 0., 0., 0.);\n    vec4 noColor = vec4(1., 1., 1., 1.);\n    if(mod(z, 1. - cos(iTime)/4.) < .4 + sin(iTime)/5. && (z > 0.05 || z < -0.05)){\n        fragColor = color;\n    }else{\n    \tfragColor = noColor;    \n    }\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 754]], "test": "valid"}
{"id": "lldXRn", "name": "Amiga-Style Copper Bars", "author": "GeekyMcGeekface", "description": "This is my first ShaderToy. It's a nod to the old-school Amiga Copper bars.\nFeedback is very welcome, in particular if you think any of my code idioms could be improved.", "tags": ["2d", "retro"], "likes": 3, "viewed": 319, "published": "Public", "date": "1477831009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// COPPER BARS, AMIGA STYLE!\n// 30 Oct 2016\n\n// Follow me on Twitter : @GeekyMcGeekface\n// Feedback welcome, this is my first ShaderToy.\n\n// v1.1 (1/11/2016) : Factored into vectors. Thanks for FabriceNeyret2 for the suggestions.\n// v1.2 (1/11/2016) : ADD_SOME_PLOP. (Thanks https://www.shadertoy.com/view/MlSSDV). Also music.\n\n#define ADD_SOME_PLOP\n\n//#define DO_BRIGHTNESS_SNAP\n#define BRIGHTNESS_SNAP\t(0.2)\n\n#define QUANTIZE_X\t\t\t\t// Comment out to show smooth sine-waves. Enable for Amiga-style copper.\n#define QUANTIZE_SIZE\t\t8.0\n#define BAR_SIZES\t\t\tvec3(3.0, 2.5, 2.0)\t\t// Bigger = Thinner bars\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef ADD_SOME_PLOP\n    // Funky plasma-type effect\n    // Tweaked version of : https://www.shadertoy.com/view/MlSSDV\n\tfloat t = iTime/2.;\n    vec2 U = 8.* fragCoord / iResolution.xy - 4.;\n//    U = 4.* U / iResolution.xy;\n    \n    for (int i=0; i<8; i++)\n    \tU += cos( U.yx *3. + vec2(t,1.6)) / 3.,\n        U += sin( U.yx + t + vec2(1.6,0)) / 2.,\n        U *= 1.3;\n    \n    vec4 o;\n//\to += length(mod(U,2.)-1.);  // black & white\n\to += length(U) / 32.0;\n#endif\n\n    vec2 fragPos = vec2(2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;   \n\n#ifdef QUANTIZE_X\n    fragPos.x = (floor(fragPos.x * QUANTIZE_SIZE) / QUANTIZE_SIZE);\n#endif\n\n    float xQuant = fragPos.x + iTime;\n    float xQuant2 = xQuant + iTime;\n    vec3 c;\n\n    c.x = ((sin(xQuant*2.5)*0.5) * (cos((xQuant2*1.7)+0.55) * 0.5)) + iTime * 0.2;\n    c.y = sin(xQuant2*3.8+0.3)*0.13 * sin(iTime * 0.9);\n    c.z = cos(xQuant*3.1) * 0.07;\n    c = (c + fragPos.y) * BAR_SIZES;\n  \n    // This line injects gaps between the bars, otherwise all components of c\n    // are continuous (non-zero) values, which means that c.x (=red) is\n    // a continuous signal & only red bars are visible.\n    c *= step( vec3(1.0, 2.0, 0.0), mod(c, vec3(2.0, 4.0, 1.0) ));\n\n    // See : http://pietermans.com/blog/triangle-wave-algorithms/\n    // Move to range [-1,+1] (0.5 ensures round bars /\\ vs \\/)\n    // and abs() fn makes signal into sawtooth [0,1]\n    c = abs((fract(c+0.5) * 2.0) - 1.0);\n\n    // Snap values < BRIGHTNESS_SNAP down to 0.\n#ifdef DO_BRIGHTNESS_SNAP\n    c *= step( BRIGHTNESS_SNAP, c );\n#endif\n\n   \tfragColor = c.x > 0.0 ? vec4(c.x, 0.0, 0.0 , 1.0)\n        \t:\tc.y > 0.0 ? vec4(0.0, c.y, 0.0 , 1.0)\n            :\t\t\t\tvec4(0.0, 0.0, c.z, 1.0);\n#ifdef ADD_SOME_PLOP\n    fragColor *= o;\n#endif\n}\n", "image_inputs": [{"id": "lsB3WR", "previewfilepath": "https://soundcloud.com/maniacs-of-noise/jeroen-tel-cybernoid-ii-master", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/maniacs-of-noise/jeroen-tel-cybernoid-ii-master", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 600, 657, 657, 2411]], "test": "valid"}
{"id": "lldXRr", "name": "sphere_test_PZ", "author": "philzook", "description": "raymarched sphere", "tags": ["sphereraymarched"], "likes": 0, "viewed": 293, "published": "Public", "date": "1477883838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere( in vec3 p){\n return length(p) - 0.5;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 st = 2.0*uv -1.0;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    vec3 cam = vec3(0.0, 0.0, -1.0);\n    vec3 ray = vec3(st.x, st.y, 1);\n    ray = normalize(ray);\n    float depth = 0.0;\n    for(int i=0; i<64; i++){\n     vec3 p = cam + depth * ray;\n     depth = depth += sphere(p);\n        \n    }\n    vec3 p = cam + depth * ray;\n    if(abs(sphere(p)) < 0.1){\n     \n     fragColor = vec4(0.3+dot(normalize(p), normalize(vec3(1.0,1.0,0.0)))); \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 57], [59, 59, 116, 116, 620]], "test": "valid"}
{"id": "llG3zK", "name": "Gaudi's column profiles", "author": "spite", "description": "Based on this talk https://www.youtube.com/watch?v=UZq5iOV3-bs\nYou can change values in the first lines of map()\n(using iq's https://www.shadertoy.com/view/Xds3zN and jaburns' https://www.shadertoy.com/view/ldSGWR)", "tags": ["procedural", "architecture", "profile"], "likes": 23, "viewed": 1193, "published": "Public API", "date": "1475495106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define TRENCADIS 1\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdWavyCylinder( vec3 p, vec3 c ) {\n    vec3 p2 = p;\n    float a = atan( p.z, p.x );\n    float r = length( p.xz );\n    p2.xz *= 1. + .1 * sin( a * 8. );\n    return length(p2.xz-c.xy)-c.z;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat expSmoothMin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n \nfloat polynomialSmoothMin (float a, float b, float k) {\n    float h = clamp (0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nfloat powerSmoothMin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat blend( float a, float b, float k ) {\n    return expSmoothMin( a, b, k );\n}\n\nvec3 random3f( vec3 p )\n{\n#if 1\n\treturn texture( iChannel0, (p.xy + vec2(3.0,1.0)*p.z+0.5)/256.0, -100.0 ).xyz;\n#else\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n#endif\t\n}\n\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    float roundness = .15;\n  \tfloat rot = 1.;\n\tfloat k = 32.;\n    float size = .5;\n    \n    float scale = 1. / ( 3. - clamp( pos.y, 1., 2. ) );\n    scale = 1.;\n    \n    float h = 3.5;\n    vec3 p = pos;\n\n    vec3 rotPos1 = p;\n    rotPos1.xz = rotate2d( - rot * rotPos1.y ) * rotPos1.xz;\n    rotPos1.xz *= scale;\n\n   \tfloat d1 = sdRoundBox( rotPos1 , vec3( size, h, size ), roundness );\n    //d1 = sdWavyCylinder( p, vec3( 0., 0., 1. ) );\n    \n   \tvec3 rotPos2 = p;\n    rotPos2.xz = rotate2d( rot * rotPos2.y ) * rotPos2.xz;\n    rotPos2.xz *= scale;\n    \n    float d2 = sdRoundBox( rotPos2 , vec3( size, h, size ), roundness );\n    //d2 = sdWavyCylinder( rotPos2, vec3( 0., 0., 1. ) );\n    \n    float d = blend( d1, d2, k );\n    \n    #if TRENCADIS\n    vec3 v = voronoi(10.0*p);\n\tfloat f = clamp( 5.*(v.y-v.x), 0.0, 1.0 );\n\td -= 0.01*f;\n    #endif\n    d *= 0.8;\n    \n    vec2 res = opU( vec2( sdPlane( p ), 1.0 ),\n\t                vec2( d, 3.0 ) );\n   \n    return res;\n    \n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 5.*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y,5.*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 2., 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\t // render\t\n    vec3 col = render( fragRayOri, fragRayDir );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llG3zK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 399, 424, 424, 439], [441, 441, 476, 476, 502], [504, 504, 535, 535, 622], [624, 624, 669, 669, 765], [767, 767, 807, 807, 961], [963, 963, 988, 988, 1025], [1027, 1027, 1052, 1052, 1110], [1112, 1112, 1137, 1137, 1202], [1205, 1279, 1312, 1312, 1338], [1340, 1340, 1370, 1370, 1403], [1405, 1405, 1435, 1435, 1464], [1466, 1466, 1490, 1490, 1622], [1624, 1624, 1652, 1652, 1738], [1740, 1740, 1789, 1789, 1860], [1863, 1863, 1918, 1918, 2006], [2008, 2008, 2059, 2059, 2137], [2139, 2139, 2181, 2181, 2219], [2221, 2221, 2246, 2246, 2531], [2533, 2533, 2560, 2560, 3144], [3146, 3220, 3245, 3245, 4218], [4220, 4220, 4260, 4260, 4580], [4583, 4583, 4657, 4657, 4918], [4920, 4920, 4952, 4952, 5173], [5175, 5175, 5217, 5217, 5516], [5521, 5521, 5560, 5560, 7131], [7133, 7133, 7185, 7185, 7362], [7364, 7364, 7421, 7421, 7996], [7998, 7998, 8092, 8105, 8223]], "test": "error"}
{"id": "llGGRV", "name": "My Ray Marching", "author": "Tacoa", "description": "GLSL Ray Marching", "tags": ["ray"], "likes": 1, "viewed": 131, "published": "Public", "date": "1475506876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 cPos = vec3(-3.0,  3.0,  3.0);\nconst vec3 cDir = vec3(0.577, -0.577, -0.577);\nconst vec3 cUp  = vec3(0.577, 0.577, -0.577);\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\n// smoothing min\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\n// box distance function\nfloat distFuncBox(vec3 p){\n    return length(max(abs(p) - vec3(1.0+cos(iTime), 0.1, 1.0+sin(iTime)), 0.0)) - 0.1;\n}\n\n// torus distance function\nfloat distFuncTorus(vec3 p){\n    vec2 t = vec2(abs(2.0*cos(iTime)), 0.25);\n    vec2 r = vec2(length(p.xy) - t.x, p.z);\n    return length(r) - t.y;\n}\n\n// distance function\nfloat distFunc(vec3 p){\n    float d1 = distFuncTorus(p);\n    float d2 = distFuncBox(p);\n    return smoothMin(d1, d2, 8.0);\n}\n\nvec3 genNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)) - distFunc(p + vec3( -d, 0.0, 0.0)),\n        distFunc(p + vec3(0.0,   d, 0.0)) - distFunc(p + vec3(0.0,  -d, 0.0)),\n        distFunc(p + vec3(0.0, 0.0,   d)) - distFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera and ray\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    float tmp, dist;\n    tmp = 0.0;\n    vec3 dPos = cPos;\n    for(int i = 0; i < 256; i++){\n        dist = distFunc(dPos);\n        tmp += dist;\n        dPos = cPos + tmp * ray;\n    }\n    \n    // hit check\n    vec3 color;\n    if(abs(dist) < 0.001){\n        vec3 normal = genNormal(dPos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        color = vec3(1.0, 1.0, 1.0) * diff;\n    }else{\n        color = vec3(0.0);\n    }\n   \tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 204, 249, 249, 318], [320, 345, 371, 371, 460], [462, 489, 517, 517, 637], [639, 660, 683, 683, 784], [786, 786, 809, 809, 1104], [1106, 1106, 1160, 1185, 1934]], "test": "valid"}
{"id": "llGGWc", "name": "Rocky Tunnel 2", "author": "aiekick", "description": "Rocky Tunnel 2", "tags": ["tunnel", "2", "rocky"], "likes": 11, "viewed": 588, "published": "Public API", "date": "1477076238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nmat3 m1;\nmat3 m2;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.08), sin(t*0.08)) * 4.;\n}\n\nfloat pattern(vec3 p)\n{\n\tp = abs(fract(p*.3) - 0.5);\n\treturn length(p);\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\n    float d0 = min(pattern(p*m1), pattern(p*m2));\n    float d1 = min(pattern(p*3.*m1), pattern(p*2.*m2));\n    \n   \tfloat dist0 = dot(vec3(1)-clamp(d0,0.,1.),vec3(1));\n\tfloat dist1 = dot(vec3(1)-clamp(d1,0.,1.),vec3(d0));\n    \n\treturn vec4(4.5 - length(p.xy) - dist0*.5 + dist1*0.5, vec3(0));\n}\n\nvec3 nor( vec3 pos, float k )\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn map(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.001, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 5.) * 0.5; \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n    m1 = mx * my * mz;\n    m2 = m1*m1;\n\t\n    float time = iTime * 4.;\n    \n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,time + .1); //Change camere view here\n\tcamView.xy += path(camView.z);\n    \n  \tvec2 uv = (g+g-si)/si.y;\n    \n    vec3 ro = vec3(0,0,time);\n\tro.xy += path(ro.z);\n    \n    vec3 lp = vec3(path(ro.z + 7.),ro.z + 7.);\n    \n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float s = 1.;\n    float d = 0.;\n    for(int i=0;i<60;i++)\n    {      \n        if (log(d*d/s/1e5)>0.) break;\n        d += s = map(ro+rd*d).x * .6;\n    }\n\t\n    vec3 p = ro+rd*d;\n    vec3 n = nor(p, 0.1);\n        \n    f = shade(ro, rd, d, lp);\n\t\n\tf = f.yzww + f.x*0.3;\n\n    f = mix( f, vec4(0.8), 1.0-exp( -0.001*d*d ) );\n        \n   \tfragColor = sqrt(f*f*f*2.);\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGGWc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 139, 164, 164, 222], [223, 223, 248, 248, 306], [307, 307, 332, 332, 390], [411, 411, 431, 431, 478], [480, 480, 503, 503, 553], [555, 555, 573, 573, 887], [889, 889, 920, 920, 1135], [1137, 1358, 1386, 1386, 1711], [1713, 1795, 1852, 1852, 2078], [2080, 2080, 2116, 2116, 2252], [2254, 2430, 2480, 2480, 2665], [2667, 2876, 2938, 2938, 3448], [3450, 3450, 3498, 3498, 4405], [4407, 4407, 4464, 4464, 5537]], "test": "error"}
{"id": "llGGzc", "name": "Radial Screen Door", "author": "marmph", "description": "Weird radial screen door effect.", "tags": ["screen", "aliasing", "interference", "radial", "door"], "likes": 2, "viewed": 503, "published": "Public API", "date": "1475829051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592654;\n\nvec4 radialLines(vec2 fragCoord, vec2 center, float density, vec3 baseColor)\n{\n    const float lineWidth = 0.20;\n    float spacing = 2.0 * PI / density;\n    \n    vec2 ray = fragCoord - center;\n    float angle = atan(ray.y, ray.x);\n    \n    float intensity = step(mod(angle, spacing), lineWidth / length(ray));\n    \n\treturn vec4(baseColor * intensity, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    const float baseDensity = 900.0;\n    const float centerExtraDensity = 500.0;\n    \n    vec2 center = iResolution.xy * 0.5;\n    float radius = distance(iMouse.xy, center) * 0.15;\n    float angle = iTime;\n    vec2 offset = vec2(cos(angle), sin(angle)) * radius;\n        \n    fragColor = radialLines(fragCoord, \n        \t  \t            center + offset, \n    \t                    baseDensity, \n    \t                    vec3(0.5 + 0.5 * sin(iTime), \n                                 0.5, \n                                 0.5))  \n              + radialLines(fragCoord, \n                     \t    center - offset, \n                          \tbaseDensity,\n                   \t        vec3(0.5,\n                                 0.5 + 0.5 * sin(iTime * 0.3 + PI * 0.5), \n                                 0.5))\n              + radialLines(fragCoord, \n                     \t    center, \n                          \tbaseDensity + centerExtraDensity * sin(iTime),\n                   \t        vec3(0.5,\n                                 0.5, \n                                 0.5 + 0.5 * sin(iTime * 0.9 + PI)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 109, 109, 389], [391, 391, 448, 448, 1554]], "test": "valid"}
{"id": "llGGzt", "name": "Playing with 2D Spirals", "author": "Nesvi7", "description": "Learning how to do spirals and playing with them. https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/", "tags": ["2d", "spiral", "learn"], "likes": 3, "viewed": 146, "published": "Public", "date": "1476137114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Math variables\nconst float e = 2.7182818284590452353602874713527;\nconst float PI = 3.14159265359;\nconst float TWOPI = 2.0*PI;\n\n\n//https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\nfloat Spiral(vec2 vector, float a, float b){\n    float angle = atan(vector.y,vector.x);\n    float r = length(vector);\n    float n = (log(r/a)/b - angle)/TWOPI;\n    float r1 = a*pow(e,b*(angle+floor(n)*TWOPI));\n    float r2 = a*pow(e,b*(angle+ceil(n)*TWOPI));\n    return min(abs(r1-r),abs(r2-r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float scale = 30.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    uv.x *= iResolution.x/iResolution.y;\n\tuv *= scale; \n    vec2 center = vec2(iResolution.x/iResolution.y*0.5,0.5)*scale;\n    \n    float s = 9999.0;\n    const float offset = 5.0;\n    for( float i = -6.0; i <= 6.0; i++)\n        for( float j = -3.0; j <= 3.0; j++){\n        \ts = min(s,Spiral(uv-center+vec2(offset*i,offset*j),1.0,sin(iTime*0.1)*3.0*length(vec2(i,j))));\n        }\n    \n    vec3 color = mix(vec3(0.0,0.0,0.0),vec3(0.45,0.25,0.2),s);\n    fragColor = vec4(color,1.0);\n   \n}\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 211, 255, 255, 508], [510, 510, 567, 567, 1127]], "test": "valid"}
{"id": "llGGzV", "name": "My Own Raymarcher", "author": "efairbanks", "description": "Iterative well-commented raymarcher so I can understand.", "tags": ["raymarching"], "likes": 2, "viewed": 129, "published": "Public", "date": "1475525616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct ray{\n \tvec3 position;\n    vec3 direction;\n};\n\n// get the distance from a torus (how does this work?)\nfloat distTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// get the distance from a sphere\nfloat distSphere( vec3 p, float s )\n{\n  p = p - vec3(0.,0.,-0.25);\n  return length(p)-s;\n}\n\nfloat distBox(vec3 p, vec3 b, float roundness)\n{\n\treturn length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n}\n\nray getLookRayFlawed(vec2 uv, vec3 eye, vec3 target, float fov)\n{\n\ttarget = vec3(target.x + (uv.x*fov), target.y + (uv.y*fov), target.z);\n    vec3 fwdDirection = normalize(target-eye);\n    return ray(eye,fwdDirection);\n}\n\nray getLookRay(vec2 uv, vec3 cameraPos, vec3 target, float fov)\n{\n\tvec3 forward = normalize(target-cameraPos);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*uv.x*fov;\n    up = up*uv.y*fov;\n    \n    return ray(cameraPos,right+up+forward);\n}\n/*\nfloat dist(vec3 p) {\n\tfloat d = 0.;\n    \n    d = distBox(p-vec3(0.,0.,-0.15),vec3(0.2,0.2,0.15),0.05);\n    d = max(-distSphere(p+vec3(0.,0.,-0.1), 0.2),d);\n    d += 0.005;\n    \n    float e = 0.;\n    \n    e = distTorus(p-vec3(0.,0.,-0.25), vec2(0.05+(0.02*sin(iTime*4.4)), 0.01));\n    e = max(-distTorus(p-vec3(0.,0.,-0.25), vec2(0.11+(0.02*sin(iTime*4.4)), 0.055)),e);\n    e = min(distSphere(p, 0.03+(0.01*sin((iTime+0.14)*4.4))),e);\n    e -= 0.005;\n    \n    float f = 0.;\n    f = min(d, e);\n    \n\td = f;\n    \n    return d;\n}\n*/\n\nfloat dist(vec3 p)\n{\n\tfloat d = 0.;\n    \n    d = distBox(p, vec3(0.09), 0.05);\n    d = max(-distTorus(p, vec2(0.08,0.045)), d);\n    \n    return d;\n}\n\nconst float maxSteps = 80.;\nfloat marchRay(ray marcher)\n{\n    float hitDistance = 0.00001;\n    float distanceTravelled = 0.;\n\tfor(float i=0.0; i<maxSteps; i++)\n    {\n        float nextDistanceTravelled = dist(marcher.position + (marcher.direction * distanceTravelled));\n        if(nextDistanceTravelled < hitDistance) return 1.-(i/maxSteps);\n        distanceTravelled += nextDistanceTravelled;\n    }\n    return 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale fragCoord xy to 0.0 -> 1.0\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    // transform uv x/y to go from -1.0 -> 1.0\n    uv = uv * vec2(2) - vec2(1);\n    // tranform uv x axis so that it's not skewed by aspect ratio\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    float mask = 1.0-distance(uv, vec2(0.,0.));\n    vec3 rot = vec3(-6.,-6.,-6.);\n    rot = vec3(sin(iTime), cos(iTime*0.5), cos(iTime)) * 30.;\n    ray lookRay = getLookRay(uv, rot, vec3(0.,0.,0.), 0.005);\n\tmask = marchRay(lookRay);\n    fragColor = vec4(mask,mask,mask,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 108, 143, 143, 208], [210, 244, 281, 281, 334], [336, 336, 384, 384, 449], [451, 451, 516, 516, 671], [673, 673, 738, 738, 1009], [1010, 1543, 1563, 1563, 1691], [1721, 1721, 1750, 1750, 2109], [2112, 2112, 2169, 2209, 2725]], "test": "valid"}
{"id": "llK3Ry", "name": "Iterated Analysis", "author": "voz", "description": "Iterated Analysis", "tags": ["analysis", "iterated"], "likes": 1, "viewed": 424, "published": "Public API", "date": "1475367648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define time (sin((float(__LINE__+123)*123.0)*.25+.5)*(iTime))\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define circle(x) (vec2(cos(x),sin(x)))\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x){ return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x){ return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x){ return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\nvec2 cmul(vec2 v1, vec2 v2) { return vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y); }\nvec2 cdiv(vec2 v1, vec2 v2) { return vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2); }\n\n\nfloat s1;\nfloat s2;\n\nvoid mainImage(out vec4 f,vec2 p)\n{\n    const int iters = 4;\n    const int trans = 4;\n    p = p/iResolution.xy-.5;\n    p *= 2.0;\n    p *= iResolution.x/iResolution.y;\n    float f1 = 0.0;\n    float m1 = 1.0;\n    vec2 p0 = p;\n    for(int i = 0; i < iters; i++)\n    {\n        s1 = float(i+1)/float(iters);\n        \n        float f2 = 0.0;\n        float m2 = 1.0;\n        \n    \tvec2 quotient = vec2(0.0);\n        for(int j = 0; j < trans; j++)\n    \t{\n            s2 = float(j+1)/float(trans);\n            vec2 offa = circle(s2*12.0+time)*\n                (1.5+sin(time));\n            vec2 offb = circle(s2*1234.0+time)/4.0*\n                (1.5+sin(time));\n            vec2 numerator = p + offa;\n            vec2 denominator = p + offb;\n            quotient += (cdiv(numerator, denominator));\n            m2 *= dot(denominator, denominator);\n            m2 *= dot(numerator, denominator);\n            m2 = clamp(sqrt(abs(m2)), 0.0, 1.0);\n            \n            f2 += length(quotient)/float(trans);\n    \t}\n    \n        m1 *= m2;\n        p = (cos(quotient*PI*2.0))*m1+p*(1.0-m1);\n       \n        f1 += atan(p.y, p.x)/PI;\n    }\n    \n    m1 = pow(m1, 1.0/float(iters));\n    \n    float s = time;\n    float b = smoothstep(0.0, 1.0/5.0, saw(s+f1));\n    float w = smoothstep(4.0/5.0, 1.0, saw(s+f1));\n    \n    float t = smoothstep(0.4, .6, sin(time)*.5+.5);\n    f = vec4(p.xy, 0.0, 1.0)*m1;\n    f = vec4(flux(f1), 1.0)*saw(m1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llK3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 270, 270, 375], [376, 376, 393, 393, 428], [429, 429, 446, 446, 491], [492, 492, 509, 509, 564], [566, 566, 595, 595, 664], [665, 665, 694, 694, 777], [801, 801, 836, 836, 2220]], "test": "valid"}
{"id": "llK3WK", "name": "Hypno-Wheel", "author": "CaliCoastReplay", "description": "Messing with nimitz' spiral from:  https://www.shadertoy.com/view/MdlXRS .  Just a doodle.", "tags": ["spiral", "psychedelic"], "likes": 5, "viewed": 524, "published": "Public", "date": "1476902051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Just trying to pull apart nimitz' spiral from https://www.shadertoy.com/view/MdlXRS\n//to see how it works!\n\n#define TAU 6.28318530716\n\nfloat spiral(vec2 p,float scl, float phase) \n{\n\tfloat r = length(p);\n\tr = log(r);\n\tfloat a = atan(p.y, p.x);\n\treturn abs(mod(scl*(r-1.0/scl*a) - phase*2.0,TAU)-1.)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    float modifier1 = 1.0 / spiral(uv, 1.0, iTime + 2.3);\n    float modifier2 = 1.0 / spiral(uv, 2.0, iTime);\n    float modifier3 = 1.0 / spiral(uv, 3.0, iTime*2.0 - 1.0);\n    float modifier4 = 1.0 / spiral(uv, 25.0 , iTime*5.0 - 2.0);\n    vec3 color = vec3 (0.19, 0.43, 0.82);\n\tfragColor = vec4(color,1.0)\n        * (modifier1 +\n           modifier2 +\n           modifier3 + \n           modifier4)/4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llK3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 137, 183, 183, 307], [309, 309, 366, 366, 829]], "test": "valid"}
{"id": "llK3zd", "name": "Op art waves", "author": "decrooks", "description": "Playing with bipolar coordinates", "tags": ["2d", "opart", "bipolar"], "likes": 5, "viewed": 149, "published": "Public", "date": "1476318420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 bipolar(vec2 p,float a, float b){\n     \n    float alpha = a*a - dot(p,p);\n    float beta = a*a + dot(p,p);\n    float gamma = sqrt(alpha*alpha - 4.0*p.y*p.y*a*a);\n    float sigma = atan( 2.0*a*p.y ,alpha + b*gamma );\n    float tau = 0.5*log((beta + 2.0*a*p.x)/(beta - 2.0*a*p.x));\n    \n    return vec2(sigma,tau);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\t\n    //rotate\n   float rotationRate = 0.3;\n   float s = sin(rotationRate*time);\n   float c = cos(rotationRate*time);\n   p = mat2(c,s,-s,c)*p;\n    \n    vec2 bp = bipolar(p,0.3, 1.0 + sin(time));\n    float osc = bp.x + bp.y;\n\t\n    vec3 color = vec3(sin(15.0*osc + 10.0*time));\n   \n \tfragColor  = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llK3zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 319], [321, 321, 378, 378, 776]], "test": "valid"}
{"id": "llV3DK", "name": "Glitch w/ Power of", "author": "VoidChicken", "description": "A weird but interesting effect. Power of glitch in GLSL. Mac looks different than Windows.", "tags": ["2d", "pow", "interesting"], "likes": 0, "viewed": 90, "published": "Public", "date": "1476928061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*50.-25.;\n    float a = sin(iTime)/2.+.5;\n    vec3 col = vec3(abs(pow(mix(uv.y-uv.x, uv.y+uv.x, a),mix(uv.x*uv.y, uv.y/uv.x, a))));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llV3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 259]], "test": "valid"}
{"id": "llV3R3", "name": "Some random lines", "author": "stduhpf", "description": "Just playing with noise", "tags": ["colors", "gradiantperlin"], "likes": 7, "viewed": 211, "published": "Public", "date": "1475968196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec3 a)\n{\n    return fract(sin(dot(vec3(30,1.3,320)*a*a,vec3(12.9898,8.233,-19.848))*43758.5453))-.5;\n}\n\n\nvec3 g(vec3 co)//random gradiant\n{\n    return vec3(rand(co.xyz),rand(co.zxy),rand(co.yzx));\n}\n\nvec4 f1(vec3 a, vec3 b) //gradiant/position dot product for square vertex\n{\n    return vec4(dot(g(a),b),dot(g(a+vec3(1,0,0)),b-vec3(1,0,0)),dot(g(a+vec3(0,1,0)),b-vec3(0,1,0)),dot(g(a+vec3(1,1,0)),b-vec3(1,1,0)));\n}\nfloat ip(vec4 a,vec2 b)//interpolation for a square\n{\n    return mix(mix(a.r,a.g,smoothstep(0.,1.,b.x)),mix(a.b,a.a,smoothstep(0.,1.,b.x)),smoothstep(0.,1.,b.y));\n}\n    \nfloat perlin(vec3 p,float time)\n{\n    time+=iTime*.2;\n    p+=time;\n    vec3 r = fract(p);\n    vec3 l = floor(p);\n    vec4 a = f1(l,r);\n    float n1 = ip(a,r.xy);\n    a = f1(l+vec3(0,0,1),r-vec3(0,0,1));\n    return mix(n1,ip(a,r.xy),smoothstep(0.,1.,r.z));//inetrpolation for the cube\n}\nfloat fbm(vec3 p,float time)\n{\n     float b =perlin(p,time);\n    for (int i=0;i<5;i++){\n        p*=1.5;\n    b= mix(b,perlin(p,time),.05);\n    }\n    return b;\n}\nfloat max3(vec3 v)\n{\n    return max(max(v.x,v.y),v.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x-vec2(.5,.5*iResolution.y/iResolution.x);\n    vec2 mse = (iMouse.xy / iResolution.x-vec2(.5,.5*iResolution.y/iResolution.x))*12.3;\n    mat3 r = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y))*mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n    vec3 vd = normalize(vec3(uv,1.))*r;\n    vec3 col =vec3(max3(((90.*sin(500.*cross(vec3(fbm(vd,1.),fbm(vd,0.),fbm(vd,3.)),vd)))))>89.).rgb*sin(100.*cross(vec3(fbm(vd,1.),fbm(vd,0.),fbm(vd,3.)),vd));\n   // col = texture(iChannel0,90.*sin(cross(vec3(fbm(vd,1.),fbm(vd,0.),fbm(vd,3.)),vd))).rgb;\n\tfragColor = vec4(col,0.);\n}", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llV3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 114], [117, 117, 151, 151, 210], [212, 212, 287, 287, 427], [428, 428, 481, 481, 592], [598, 598, 631, 631, 883], [884, 884, 914, 914, 1043], [1044, 1044, 1064, 1064, 1100], [1103, 1103, 1160, 1160, 1790]], "test": "error"}
{"id": "llV3Rt", "name": "2d graph canvas", "author": "ollj", "description": "drag with mouse\n\nmixing linear functions with a fast grid background that scales nicely, using fract()", "tags": ["2d", "graph", "analysis"], "likes": 2, "viewed": 599, "published": "Public API", "date": "1476274247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n#define ss(a,b,c) smoothstep(a-b,a+b,c)\n#define st (cos(iTime)*.5+.6)\n#define res iResolution\n\n#define zoom 5.\n\n//branchless if(a<0)return b;return c;\n//#define ifb(a,b,c) (b+(c-b)*step(a,0.))\n//#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\n\n//scale and center uv coords.\nvec2 frame(vec2 v){v=2.*v.xy/res.xy-1.;\n v.x*=res.x/res.y;return v;}\n\n//a half rotation is divided by this value.\n//#define HalfSections 8.\n\nfloat Segment(vec2 p,vec2 a,vec2 b){p-=a;b-=a;\n float h=clamp(dot(p,b)/dot(b,b),0.,1.);\n return length(p-b*h);}\n //h is how far along p projects on the liné agment\n//https://www.shadertoy.com/view/MdsGRS\n\nvoid mainImage(out vec4 r,in vec2 i){\n i-=iMouse.xy-res.xy*.5;//mouse.drag\n vec2 p=frame(i)*zoom;\n //distance to vec2(0):\n float d=length(p); \n //angle\n float divs=2.*(d-fract(d)+1.);//=HalfSections;\n float a=abs(atan(p.y,p.x))*divs/pi;\n a+=(1.-a-a)*step(p.y,0.);//a=ifb(p.y,a,1.-a);\n //orthogonal grid:\n vec2 t2=ss(.1,.1,fract(abs(p)));\n float t=min(t2.x,t2.y);\n vec3 grid=vec3(1.-fract(d),t,1.-fract(a));\n grid=.7-grid*st;\n r=vec4(grid,1.);\n //linear function.sin(x):\n float s=p.y-sin(p.x);\n s=ss(.1,.03,abs(s));\n r=mix(r,vec4(1),1.-s);\n //linear function.log(abs(x)):   \n float l=p.y-log(abs(p.x));\n l=ss(.1,.03,abs(l));\n r=mix(r,vec4(1),1.-l);\n    \n //line segment;\n vec2 l1=vec2(-2,4);\n vec2 l2=vec2( 1,5);\n float u=Segment(p,l1,l2);\n l=ss(.9,.01,1.-u);\n r=mix(r,vec4(1),l);\n //r.xyz+=max(1.-u,0.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llV3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 286, 305, 305, 354], [356, 427, 463, 463, 538], [540, 633, 670, 670, 1439]], "test": "valid"}
{"id": "llVGz3", "name": "countryside sketch", "author": "wombleman", "description": "sdf sketch. iterating fast so sloppy code :)\nstarted from: https://www.shadertoy.com/view/Xds3zN", "tags": ["terrain"], "likes": 5, "viewed": 168, "published": "Public", "date": "1476044525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MAX_SCALE = 20.0;\nconst float MIN_SCALE = 2.0;\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat hash( vec2 p )\n{    \n\tfloat h = dot(p,vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat hash(float f)\n{    \n\tfloat h = f * 311.7;\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat scale(vec2 sq){\n    return floor(mix(MIN_SCALE,MAX_SCALE,hash(vec2(sq))));\n}\n\nvec2 square(vec3 pos){\n    vec2 sq = vec2(floor(pos.x)+0.5,floor(pos.z)+0.5);\n\tsq = vec2(floor(pos.x)+0.5,floor(pos.z)+0.5);\n        return sq;\n}\n\nfloat dTo(vec3 pos){\n        float s = scale(square(pos));\n        vec2 sq = square(s*pos);\n        vec2 delta = s*pos.xz - sq;\n        return dot(delta,delta);}\n\nbool isPath(vec3 pos){\n    return abs(pos.x) < 0.07 || mod(pos.z,2.0) < 0.14;\n    return abs(pos.x - sin(pos.z)*20.0) <1.0 || abs(pos.x) < 0.07;\n}\n\nbool isFarm(vec3 pos){\n    float h = hash(square(pos));\n    return h > 0.6 && h < 0.7 ;\n}\n\nfloat sdPlane( vec3 p )\n{\n    float t = iTime/2.0;\n    float h=0.0;\n    h -= 0.6*(sin(0.1*(p.x-p.z)+1.6)*cos(0.23*p.z));\n    if (!isPath(p) && !isFarm(p)) h += (1.0-dTo(p))*0.05;\n\treturn p.y-h;\n}\n\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )        \n{\n    return  vec2( sdPlane(     pos), 1.0 );;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 40.0;\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 diffuse(vec3 pos){\n        vec2 sq = square(pos);\n    \tif(isPath(pos)) return vec3(0.3,0.3,0.3);\n        if(isFarm(pos)) return vec3(0.3,0.3,0.1);\n    \tsq = square(pos);\n        float d2 = dTo(pos);\n        float h = 0.2+0.3*hash(sq);\n        h += floor(d2*20.0)*0.05;\n    \n        vec3 rgb1 = hsv2rgb(vec3(h,0.9,0.3));\n        //vec3 rgb2 = hsv2rgb(vec3(0.6,0.6,0.2));\n        //vec3 rgb3 = hsv2rgb(vec3(0.0,1.0,1.0));\n        //rgb1 = mix(rgb1,rgb2,mod(sq.x, 2.0));\n\n    \tif (hash(sq) < 0.2) return vec3(0.6,0.4,0.2);\n    \n        return rgb1;\n}\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 skyTop = hsv2rgb(vec3(0.6,0.6,0.4));\n    vec3 skyBottom = hsv2rgb(vec3(0.55, 0.3, 0.6));\n    vec3 col = mix(skyBottom,skyTop,rd.y*5.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 diff = diffuse(pos);\n        vec3 L = vec3(2.0);\n        col = diff * dot(nor,vec3(0.0,1.0,0.0)) * L;\n    \tcol = mix( col, skyBottom, 1.0-exp( -0.002*t*t ) ); //fog\n\t\t\n    col = mix(vec3(0.5,0.0,0.0),col,m);\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = vec2(8.0,1.0);//iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime*5.0;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(6.0*mo.x), 4.0 + 1.0*mo.y, -5.0 + 3.5*sin(6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    ro.z += 0.2*time;\n    ta.z += 0.2*time;\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sB3zm", "previewfilepath": "https://soundcloud.com/danielasings/gentlemen", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/danielasings/gentlemen", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 207, 207, 385], [387, 387, 409, 409, 492], [494, 494, 515, 515, 583], [585, 585, 606, 606, 667], [669, 669, 691, 691, 814], [816, 816, 836, 836, 977], [979, 979, 1001, 1001, 1125], [1127, 1127, 1149, 1149, 1216], [1218, 1218, 1243, 1243, 1413], [1416, 1490, 1523, 1523, 1570], [1572, 1572, 1612, 1612, 1932], [1936, 1936, 1968, 1968, 2189], [2192, 2192, 2215, 2215, 2744], [2748, 2748, 2787, 2787, 3360], [3362, 3362, 3414, 3414, 3591], [3593, 3593, 3650, 3650, 4290]], "test": "valid"}
{"id": "lly3R3", "name": "Spiral 01", "author": "lokii", "description": "Animated spiral.. Most of the color varying spiral shaders use nested spiral to have multiple spiral starting from the center. This one does it differently by essentially having just one spiral vary colors along its arc length.", "tags": ["spiral"], "likes": 4, "viewed": 505, "published": "Public API", "date": "1475776241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Akshay S. Loke\n// Title: Spiral 01\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define USE_SMOOTH\n#define M_PI 3.14159265358979\n#define M_2PI 6.28318530717958\n#define RADIUS .25\n#define NUMCURLS 6\n\n//http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    vec2 R = iResolution.xy;\n    U = (2.*U-R)/R.y;\n    \n    float \tdist = length(U),\n\t\t\tnormTheta = .5+atan(U.y, U.x)/M_2PI,\n        \tval = 0.;\n    \n    for (int i=-1; i<NUMCURLS-1; i++) {\n        float iFloat = float(i);\n        float \tringPre = (iFloat == -1.)? 0.: (normTheta + iFloat) * RADIUS,\n            \tringPost = (normTheta + iFloat + 1.) * RADIUS;\n        \n#ifdef USE_SMOOTH\n        float ringVal = smoothstep(-.01, 0., dist-ringPre) - smoothstep(-.01, 0., dist-ringPost);\n#else\n        float ringVal = step(ringPre, dist) - step(ringPost, dist);\n#endif\n        val += ringVal * (normTheta + iFloat + 1.);\n    }\n\n    val /= float(NUMCURLS);\n    val += cos(iTime*.3);\n\n    vec3 col = pal(val, \n                   vec3(0.5,0.5,0.5),\n                   vec3(0.5,0.5,0.5),\n                   vec3(1.0,1.0,1.0),\n                   vec3(0.0,0.33,0.67) );\n    \n    O = vec4(col * smoothstep(0.81, .8, dist), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lly3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 271, 339, 339, 382], [384, 384, 422, 422, 1341]], "test": "valid"}
{"id": "lly3zc", "name": "Meta regular n-gons", "author": "twitchingace", "description": "Mucking about, trying to implement regular meta n-gons.", "tags": ["2d", "metaball", "learning", "gooey", "metacube", "metapolygon"], "likes": 3, "viewed": 161, "published": "Public", "date": "1475871661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////////////////////\n// Set COL to 0. to see the shapes colorized.\n// Use ISSOLID in conjunction with ISTHRESHOLDto determine if \n// the shape should be filled in.\n/////////////////////////////////////////////////////////////////////////////\n\n#define COL 1.\n#define ISSOLID 0\n#define ISTHRESHOLD 1\n#define PI 3.14159\n#define MAXSIDES 10\n\nstruct metaball{\n    vec2 pos;\n    vec3 colour;\n    float radius;\n    \n};    \nstruct metangon{\n\tvec2 pos;\n    int numSides;\n    vec3 colour;\n    float radius;\n};\n    \nvec2 rotate(in vec2 vec, in float rot){\n    vec2 newVec;\n\tnewVec.x = vec.x * cos(rot) - vec.y * sin(rot);\n\tnewVec.y = vec.x * sin(rot) + vec.y * cos(rot); \n    return newVec;\n}\n\nvec3 doMetangon(in metangon mngon, in vec2 testPoint, in float rot){\n    // Basically, we want to fake a \"distance\" to use by finding the projection\n    // of the vector from the center of the shape to the testPoint onto the\n    // normal (scaled by \"radius\") of each side, and take the biggest one.\n    \n    vec2 testVec = testPoint - mngon.pos;   \n    vec2 sideNormal = vec2(0., mngon.radius);\n    sideNormal = rotate(sideNormal, rot);    \n    float maxDist = dot(testVec, normalize(sideNormal));    \n    for (int i = 1; i < MAXSIDES; i++){\n        // A silly hack to get around the need for constant loop iterations\n        if (i >= mngon.numSides){\n            break;\n        }            \n        sideNormal = rotate(sideNormal, radians(360./ float(mngon.numSides))); \n        maxDist = max(maxDist, dot(testVec, normalize(sideNormal)));\n    }\n        \n    return mngon.colour * mngon.radius / maxDist;\n}\n\nvec3 doMetaball(in metaball mball, in vec2 testPoint){\n    vec2 pos = mball.pos;\n\treturn mball.colour *  mball.radius/length(pos - testPoint);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    \n    metaball ball1 = metaball(vec2(0.5+ .5*cos(iTime + 0.4), 0.25 + .2*sin(iTime)),\n                              vec3(COL,1.,1.), .1);\n    metangon cube1 = metangon(vec2(0.5 + .5 * sin(iTime), 0.15), 4,\n                              vec3(1.,1., COL), .07);\n    metangon tri1 = metangon(vec2(abs(0.3 + .5 * sin(iTime)), 0.4 + .2 * cos(iTime)), 3,\n                              vec3(1.,COL, 1.), .07);\n    metaball ball2 = metaball(vec2(abs(0.1 + sin(iTime)), 0.2 + 0.2 * cos(iTime)), \n                              vec3(1., COL, COL), 0.05);    \n    metangon pentagon1 = metangon(vec2(0.5, abs(0.3 + .2 * sin(iTime * 0.7 + 5.))), 5,\n                              vec3(COL, 1., COL), .075);    \n    metangon septagon1 = metangon(vec2(abs(0.4 + sin(iTime)), 0.4 - 0.2 * cos(iTime)), 7,\n                              vec3(1., 1., 1.), 0.06);\n    \n    vec3 rgb = vec3(0.);\n    rgb += doMetaball(ball2, uv);\n    rgb += doMetaball(ball1, uv);\n    rgb += doMetangon(cube1, uv, iTime * 1.1 + 0.3);\n\trgb += doMetangon(tri1, uv, iTime);\n    rgb += doMetangon(pentagon1, uv, -iTime);\n    rgb += doMetangon(septagon1, uv, 0.);                            \n    rgb /= 1.75;\n    \n    #if ISTHRESHOLD == 1\n    float threshold = 1.;\n    if (rgb.x <= threshold){\n        rgb.x = 0.;\n    }\n    if (rgb.y <= threshold){\n        rgb.y = 0.;\n    }\n    if (rgb.z <= threshold){\n        rgb.z = 0.;\n    }    \n    #if ISSOLID == 0\n    if (rgb.x > threshold + 0.1 || \n        \trgb.y > threshold + 0.1 ||\n        \trgb.z > threshold + 0.1){\n        rgb = vec3(0.);\n    }\n    #endif\n    #endif\n    \n\tfragColor = vec4(rgb ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lly3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 562, 601, 601, 738], [740, 740, 808, 1039, 1649], [1651, 1651, 1705, 1705, 1795], [1797, 1797, 1854, 1854, 3502]], "test": "valid"}
{"id": "lly3zK", "name": "demosplash2016-cxw-05", "author": "cxw", "description": "Part 05: Overlaying multiple computations to provide an effect\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016", "tags": ["tutorial", "demoparty"], "likes": 2, "viewed": 372, "published": "Public API", "date": "1475776995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp int;precision highp float;\n\n// Parameters for your demo\n\n#define THICKNESS (0.85)\n    // larger means narrower\n#define SPACING (200.0)\n    //ditto\n#define SPEED (0.6)\n    // Higher is faster\n\nfloat           //not a color, but an ingredient\nget_sine_01(    //Named for its output range\n    in float time, in vec2 coords,      // parameters!\n    in vec2 center, in float radius, in float speed)\n{\n    float whereami = radius*distance(center,coords) - speed*time;\n    return 0.5+0.5*sin(whereami);\n} //get_sine_01\n\nfloat squish(in float f)\n{ //-1..1->0..1\n  return (f+1.0)*0.5;\n}\nvec2 lisa(in float time, in float a, in float b, in float delta)\n{ // a Lissajous curve.  Formula from en.wikipedia.org.\n    return vec2(squish(sin(a*time+delta)), squish (sin(b*time)));\n} //lisa\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 pixel_coord = fragCoord.xy / iResolution.xy;\n\n    // Centers of sines a and b.  All numbers empirical.\n    vec2 ca = lisa(t*0.5*SPEED,        5.0,4.0,0.0);\n    vec2 cb = lisa(t*0.835744*SPEED,   3.0,2.0,1.8);\n\n    cb = mix(ca, cb, 0.6);      //Move cb closer to ca.\n        // I did this because the centers were spending too much time apart\n        // and this was an easy way to mitigate that.\n\n    // Sine values\n    float sa = get_sine_01(t, pixel_coord, ca, SPACING, 10.0);\n    float sb = get_sine_01(t, pixel_coord, cb, SPACING, 10.0);\n\n    // Make them sharp rather than blurry\n    sa=step(THICKNESS,sa);\n    sb=step(THICKNESS,sb);\n\n    // Combine the two sines\n    float res=max(sa,sb);\n        // or min(sa,sb)   sa-sb   mix(sa,sb,0.5)\n    fragColor = vec4(res,0.0,0.0,1.0);\n       // or vec4(sa,sb,0.0,1.0);\n\n} //mainImage\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lly3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 208, 411, 411, 513], [514, 529, 555, 569, 593], [594, 594, 660, 714, 782], [783, 791, 848, 848, 1699]], "test": "valid"}
{"id": "llyGR3", "name": "Fractal Vibrations", "author": "gPlatl", "description": "Still a crazy idea - sound vibration of a fractal - which was created by BlooD2oo1.\nFor fractal see https://www.shadertoy.com/view/Xly3R3\nUse mouse to change view...", "tags": ["fractal", "sound", "visualizer"], "likes": 17, "viewed": 593, "published": "Public", "date": "1475780443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//------------------------------------------------------\n//\n// Fractal_Vibrations.glsl\n//\n// original:  https://www.shadertoy.com/view/Xly3R3\n//            2016-10-05  Kaleo by BlooD2oo1\n//\n//   v1.0  2016-10-06  first release\n//   v1.1  2018-03-23  AA added, mainVR untested!!! \n//   v1.2  2018-09-02  supersampling corrected\n//\n// description  a koleidoscopic 3d fractal\n//\n// Hires B/W fractal picture:\n//   https://c2.staticflickr.com/6/5609/15527309729_b2a1d5a491_o.jpg\n//\n//------------------------------------------------------\n\nfloat g_fScale = 1.2904082537;\n\nmat4 g_matIterator1 = mat4(-0.6081312299, -0.7035965919, 0.3675977588, 0.0000000000,\n                            0.5897225142, -0.0904228687, 0.8025279045, 0.0000000000,\n                           -0.5314166546, 0.7048230171, 0.4699158072, 0.0000000000,\n                            0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nmat4 g_matIterator2 = mat4(-0.7798885703, 0.6242666245, -0.0454343557, -0.2313748300,\n                            0.0581589043, 0.0000002980, -0.9983071089, -0.2313748300,\n                           -0.6232098937, -0.7812111378, -0.0363065004, -0.2313748300,\n                            0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nmat4 g_matReflect1 = mat4( 0.9998783469, -0.0103046382, -0.0117080826, 0.0000000000,\n                          -0.0103046382, 0.1270489097, -0.9918430448, 0.0000000000,\n                          -0.0117080826, -0.9918430448, -0.1269274950, 0.0000000000,\n                           0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nmat4 g_matReflect2 = mat4( 0.7935718298, -0.0946179554, 0.6010749936, 0.0000000000,\n                          -0.0946179554, 0.9566311240, 0.2755074203, 0.0000000000,\n                           0.6010749936, 0.2755074203, -0.7502027750, 0.0000000000,\n                           0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nmat4 g_matReflect3 = mat4(-0.7127467394, -0.5999681950, 0.3633601665, 0.0000000000,\n                          -0.5999681950, 0.7898335457, 0.1272835881, 0.0000000000,\n                           0.3633601665, 0.1272835881, 0.9229129553, 0.0000000000,\n                           0.0000000000, 0.0000000000, 0.0000000000, 1.0000000000 );\n\nvec4 g_planeReflect1 = vec4( 0.0077987094, 0.6606628895, 0.7506421208, -0.0000000000 );\n\nvec4 g_planeReflect2 = vec4( 0.3212694824, 0.1472563744, -0.9354685545, -0.0000000000 );\n\nvec4 g_planeReflect3 = vec4( -0.9254043102, -0.3241653740, 0.1963250339, -0.0000000000 );\n\n/////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 HSVtoRGB(float h, float s, float v) \n{\n  return((clamp(abs(fract(h +vec3(0.,2./3.,1./3.))*2.-1.)*3.-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nmat3 rot3xy( vec2 angle )\n{\n  vec2 c = cos( angle );\n  vec2 s = sin( angle );\n  return mat3( c.y,       -s.y,        0.0,\n               s.y * c.x,  c.y * c.x, -s.x,\n               s.y * s.x,  c.y * s.x,  c.x );\n}\n\nvec4 DE1( in vec4 v )\n{\n  float fR = dot( v.xyz, v.xyz );\n  vec4 q;\n  int k = 0;\n  vec3 vO = vec3( 0.0, 0.0, 0.0 );\n\n  for ( int i = 0; i < 32; i++ )\n  {\n    q = v*g_matIterator1;\n    v.xyz = q.xyz;\n\n    if ( dot( v, g_planeReflect1 ) < 0.0 )\n    {\n      q = v*g_matReflect1;\n      v.xyz = q.xyz;\n      vO.x += 1.0;\n    }\n\n    if ( dot( v, g_planeReflect2 ) < 0.0 )\n    {\n      q = v*g_matReflect2;\n      v.xyz = q.xyz;\n      vO.y += 1.0;\n    }\n\n    if ( dot( v, g_planeReflect3 ) < 0.0 )\n    {\n      q = v*g_matReflect3;\n      v.xyz = q.xyz;\n      vO.z += 1.0;\n    }\n\n    q = v*g_matIterator2;\n    v.xyz = q.xyz;\n\n    v.xyz = v.xyz*g_fScale;\n    fR = dot( v.xyz, v.xyz );\n    k = i;\n  }\n  return vec4( vO, ( sqrt( fR ) - 2.0 ) * pow( g_fScale, -float(k+1) ) );\n}\n\n//------------------------------------------------------\n\nfloat time = 0.0;  \nfloat fL = 1.0;\n\n//------------------------------------------------------\nvec4 renderRay (in vec3 rayOrig, in vec3 rayDir)\n{\n  rayDir = normalize( rayDir );\n\n  const float fRadius = 2.0;\n  float b = dot( rayDir, rayOrig ) * 2.0;\n  float c = dot( rayOrig, rayOrig ) - fRadius*fRadius;\n  float ac4 = 4.0 * c;\n  float b2 = b*b;\n\n  vec4 color = vec4(0,0,0,1);\n  color.rgb = -rayDir*0.2+0.8;\n  color.rgb = pow( color.rgb, vec3( 0.9, 0.8, 0.5 ) );\n  color.rgb *= 1.0-fL;\n  if ( b2 - ac4 <= 0.0 )  return color;\n\n  float root = sqrt( b2-ac4 );\n  float at1 = max(0.0, (( -b - root ) / 2.0));\n  float at2 = ( -b + root ) / 2.0;\n\n  float t = at1;\n  vec4 v = vec4( rayOrig + rayDir * t, 1.0 );\n  vec4 vDE = vec4( 0.0, 0.0, 0.0, 0.0 );\n  float fEpsilon = 0.0;\n\n  float fEpsilonHelper = 1.0 / iResolution.x;\n    \n  float count = 0.0;\n  for ( int k = 0; k < 100; k++ )\n  {\n    vDE = DE1( v );\n    t += vDE.w;\n    v.xyz = rayOrig + rayDir * t;\n\n    fEpsilon = fEpsilonHelper * t;\n\t\t\n    if ( vDE.a < fEpsilon ) \n    {\n        count = float(k);\n        break;\n    }\n    if ( t > at2 )     return color;\n  }\n    \n  // colorizing by distance of fractal\n  color.rgb = HSVtoRGB(count/25., 1.0-count/50., 0.8);\n    \n  vec4 vOffset = vec4( fEpsilon*1.8, 0.0, 0.0, 0.0 );\n  vec4 vNormal = vec4(0.0);\n  vNormal.x = DE1( v + vOffset.xyzw ).w - DE1( v - vOffset.xyzw ).w;\n  vNormal.y = DE1( v + vOffset.yxzw ).w - DE1( v - vOffset.yxzw ).w;\n  vNormal.z = DE1( v + vOffset.zyxw ).w - DE1( v - vOffset.zyxw ).w;\n  vNormal.xyz = normalize( vNormal.xyz );\n\n  vec4 vReflect = vec4(0.7);\n  vReflect.xyz = reflect( rayDir, vNormal.xyz );\n\n  vec2 vOccRefl = vec2( 0.0, 0.4 );\n  \n  float fMul = 2.0;\n  float fMulMul = pow( 2.0, 9.0/10.0 ) * pow( fEpsilon, 1.0/10.0 ) * 0.5;\n  float fW = 0.0;\n  for ( int k = 0; k < 8; k++ )\n  {\n    vOccRefl.x += DE1( v + vNormal * fMul ).w / fMul;\n    vOccRefl.y += DE1( v + vReflect * fMul ).w / fMul;\n    fMul *= fMulMul;\n  }\n  vOccRefl /= 6.0;\n  \n  color.rgb *= vec3( vOccRefl.x * vOccRefl.y );\n  color.rgb *= (vNormal.xyz*0.5+0.5)*(1.0-vOccRefl.x) +vec3(1.5)* vOccRefl.y;\n  color.rgb = pow( color.rgb, vec3( 0.4, 0.5, 0.6 ) );\n  color.rgb *= 1.0-fL;\n  return vec4(color.rgb, 1.0);\n}\n\n//------------------------------------------------------\nvoid mainVR (out vec4 fragColor, in vec2 fragCoord\n            ,in vec3 fragRayOri, in vec3 fragRayDir)\n{\n  vec2 uv = (fragCoord - iResolution.xy*0.5) / iResolution.x;\n  fL = length( uv );\n  fragColor = renderRay (fragRayOri, fragRayDir);\n}\n\n//------------------------------------------------------\nvec4 render(in vec2 pos)\n{\n  time = iTime * 0.1;  \n  vec2 mouse = iMouse.xy / iResolution.xy;\n  vec3 rayOrig = vec3( -3.0 - sin( time ), 0.0, 0.0 );\n  vec2 uv = (pos - iResolution.xy*0.5) / iResolution.x;\n  fL = length( uv );\n  uv /= fL;\n  uv *= 1.0-pow( 1.0-fL, 0.7 );\n  vec3 rayDir = vec3(0.45+mouse.y, uv );\n\n  mat3 rot = rot3xy( vec2( 0.0, time + mouse.x * 4.0) );\n  rayDir  = rot * rayDir;\n  rayOrig = rot * rayOrig;\n    \n  return renderRay (rayOrig, rayDir);\n}\n\n//------------------------------------------------------\n\n#define AAX 2   // supersampling level. Make higher for more quality.\n#define AAY 1   \n\nfloat AA = float(AAX * AAY);\n\n//------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float tr = texture(iChannel0,vec2(0.01, 0.01)).r;  // sound value\n  g_fScale -= (tr*2.3 - 2.0) / 18.0;    // fractal scaling\n\n  if (AAX>1 || AAY>1)\n  {\n    vec4 col = vec4(0,0,0,1);\n    for (int xp = 0; xp < AAX; xp++)\n    for (int yp = 0; yp < AAY; yp++)\n    {\n      vec2 pos = fragCoord + vec2(xp,yp) / vec2(AAX,AAY);\n      col += render (pos);\n    }\n    fragColor.rgb = col.rgb / AA;\n  }\n  else fragColor = render (fragCoord);\n}\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2539, 2630, 2673, 2673, 2759], [2761, 2761, 2788, 2788, 2974], [2976, 2976, 2999, 2999, 3739], [3836, 3893, 3943, 3943, 6004], [6006, 6063, 6168, 6168, 6303], [6305, 6362, 6388, 6388, 6828], [7006, 7063, 7120, 7120, 7554]], "test": "error"}
{"id": "llyGWc", "name": "Soft n Mushy", "author": "Xafer", "description": "Some sort of underwater scene or something", "tags": ["perlin", "grass"], "likes": 0, "viewed": 166, "published": "Public", "date": "1477082518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NEAR 0.01\n#define FAR 10.0\n\n#define STEP_SIZE 0.6\n#define MAX_ITER 200\n#define DELTA 0.005\n#define A_SPEED 0.1\n#define CAM_DIST 3.0\n\n#define RECAST_MAX 5\n\n#define GLOW_POWER 6.0\n#define GLOW_COLOR vec3(0.2,0.4,0.4)\n#define GRASS_SIZE vec2(0.005,0.4)\n\n#define SKY_COLOR vec3(0.1,0.3,0.4)\n\n#define ONE 0.00390625\n#define ONEHALF 0.001953125\n\n#define PIXEL_SCALE 1.0\n\nfloat fade(float t) {\n  // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative\n  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n}\n\nfloat noise(vec2 P)\n{\n  vec2 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled and offset for texture lookup\n  vec2 Pf = fract(P);             // Fractional part for interpolation\n\n  // Noise contribution from lower left corner\n  vec2 grad00 = texture(iChannel0, Pi).rg * 4.0 - 1.0;\n  float n00 = dot(grad00, Pf);\n\n  // Noise contribution from lower right corner\n  vec2 grad10 = texture(iChannel0, Pi + vec2(ONE, 0.0)).rg * 4.0 - 1.0;\n  float n10 = dot(grad10, Pf - vec2(1.0, 0.0));\n\n  // Noise contribution from upper left corner\n  vec2 grad01 = texture(iChannel0, Pi + vec2(0.0, ONE)).rg * 4.0 - 1.0;\n  float n01 = dot(grad01, Pf - vec2(0.0, 1.0));\n\n  // Noise contribution from upper right corner\n  vec2 grad11 = texture(iChannel0, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float n11 = dot(grad11, Pf - vec2(1.0, 1.0));\n\n  // Blend contributions along x\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade(Pf.x));\n\n  // Blend contributions along y\n  float n_xy = mix(n_x.x, n_x.y, fade(Pf.y));\n\n  // We're done, return the final noise value.\n  return n_xy;\n}\n\nfloat tnoise(vec3 p)\n{\n    return (noise(p.xz/5.0) + (noise(p.xz/2.0))/12.0)*4.0;\n}\n\nvec3 displaceTerrain(vec3 p)\n{\n    p.y += tnoise(p) ;\n    return p;\n}\n\nvec3 displaceGrass(vec3 p)\n{\n    p = displaceTerrain(p);\n    p.x += sin(p.z + p.y*3.0 + iTime/2.0)/8.0 * (p.y*3.0) + cos(p.x + p.y*6.0 + iTime*3.0)/20.0 * (p.y*6.0);\n    p.y -= abs(sin(p.x*20.01124 + p.z*24.0241)/20.0);\n    \n    p.x += sin(p.z*12.042)*0.04 +  sin(p.z*9.1230)*0.06;\n    p.z += sin(p.x*9.612)*0.03 +  sin(p.x*13.3231)*0.055;\n    \n    return p;\n}\n\nfloat sdGrassField(vec3 p)\n{\n    vec3 q = displaceTerrain(p);\n    \n    vec3 grassDist = vec3(0.05,0,0.05);\n\tvec3 pg = displaceGrass(p) + grassDist * 0.5;\n\tvec3 k = floor (pg / grassDist);\n\tpg -= grassDist * (k + 0.5);\n    \n    vec2 b = GRASS_SIZE;\n    \n    float g = length(max(abs(pg)-vec3(b,0.001),0.0));\n    float f = -q.y;\n    \n    return min(f,g);\n}\n\nfloat sdSphere(vec3 p)\n{\n    p += vec3(0,0,0);\n    return length(p) - 1.0;\n}\n\nfloat map(vec3 p)\n{\n    return sdGrassField(p);//min(sdSphere(p),);\n}\n\nfloat getLightFactor(vec3 p,vec3 normal)\n{\n    vec3 lightPos = vec3(0,-2.0,iTime);\n    vec3 lp = p - lightPos;\n    float power = 3.0;\n    float intensity = max(1.0-length(lp)/power,0.0);\n    float dist = 1.0-dot(normalize(lp),normal);\n    \n    float factor = intensity*dist;\n        \n    return factor;\n}\n\nvec3 castRay(vec3 pos, vec3 dir)\n{\n    //Initialize RayMarching\n    vec3 p = pos;\n    float rl = 0.0;\n    \n    vec3 color = vec3(0);//Output color\n    \n    float near = FAR;\n    float iters = 0.0;\n    \n    //March\n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        near = map(p);//Nearest surface distance\n        \n        rl += near;\n        if(near <= DELTA || rl > FAR)//If the ray hits something\n        {\n            break;\n        }\n        p += STEP_SIZE*near*dir;//March forward\n        iters++;\n    }\n    \n    if(near >= DELTA)//If the point is outside a volume\n    {\n        vec3 a = SKY_COLOR;\n        vec3 b = GLOW_COLOR;\n        float n = pow(iters/float(MAX_ITER), 1.0/GLOW_POWER);\n        color = mix(a,b,n);\n    }\n    else\n    {\n        vec2 delta = vec2 (DELTA, 0.0);\n\t\tvec3 normal = normalize (vec3 (\n\t\t\tmap (p + delta.xyy) - map (p - delta.xyy),\n\t\t\tmap (p + delta.yxy) - map (p - delta.yxy),\n\t\t\tmap (p + delta.yyx) - map (p - delta.yyx)));\n        \n        float lightFactor = getLightFactor(p,normal);\n        \n        vec3 sky = GLOW_COLOR;\n        \n        vec2 ss = p.xz*2.0;\n        \n        color = vec3(texture(iChannel0, mod(ss.xy/30.0,vec2(1))).r/1.7,texture(iChannel0, mod(ss.xy/30.0,vec2(1))).g/1.5,0);\n        color = mix(color,sky/3.0,1.0-lightFactor);\n        float fog = clamp(rl / FAR,0.0,1.0);\n        color = mix(color,GLOW_COLOR,fog);\n    }\n   \t\n    //color += vec3(pow(iters/float(MAX_ITER), 1.0/GLOW_POWER));\n    //fog\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Pixel scaling. Coulda done that somewhere else to prevent rendering the same pixel\n    vec2 fc;\n    fc.x = floor(fragCoord.x/PIXEL_SCALE)*PIXEL_SCALE;\n    fc.y = floor(fragCoord.y/PIXEL_SCALE)*PIXEL_SCALE;\n    \n    //Setting up screen-correct uv\n\tvec2 uv = ( fc.xy / iResolution.xy ) * 2.0 - vec2( 1 );\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //Setting up rotation\n    float sa = sin( iTime * A_SPEED );\n    float ca = cos( iTime * A_SPEED );\n    \n    //Creating ray\n    vec3 or = vec3(sa*CAM_DIST,0,-ca*CAM_DIST + iTime);\n    or.y = -tnoise(or)-1.3;\n    vec3 di = -normalize(vec3(uv.x,uv.y,-1.0));\n    \n    //Rotating orientation\n    mat3 r;\n    r[0] = vec3(ca,0,sa);\n    r[1] = vec3(0,1,0);\n    r[2] = vec3(-sa,0,ca);\n    di = r*di;\n    \n    vec3 color = castRay(or,di);\n    \n\tfragColor = vec4(color,1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 373, 394, 475, 560], [562, 562, 583, 583, 1623], [1625, 1625, 1647, 1647, 1708], [1710, 1710, 1740, 1740, 1779], [1781, 1781, 1809, 1809, 2141], [2143, 2143, 2171, 2171, 2497], [2499, 2499, 2523, 2523, 2575], [2577, 2577, 2596, 2596, 2646], [2648, 2648, 2690, 2690, 2952], [2954, 2954, 2988, 3017, 4433], [4435, 4435, 4492, 4581, 5316]], "test": "error"}
{"id": "llyGWG", "name": "illussion_test_1", "author": "brchan_toy", "description": "illusion", "tags": ["illusion"], "likes": 2, "viewed": 103, "published": "Public", "date": "1476395495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hi_green = vec4(.341,1.,0.,1.);\nvec4 white =  vec4(1.,1.,1.,1.);\n\nfloat LINES_NUMBER = 40.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc = vec2 (iResolution.x / iResolution.y, 1.);\n    //\n    float set = 0.;\n    float shift = iTime * 3.;\n    \n    //if (uv.x<=0.5) shift = -shift+1./LINES_NUMBER;\n\n    //float test = floor((uv.x + shift)*LINES_NUMBER);\n    float test = floor(length ((uv - vec2 (0.5, 0.5)) * sc)*LINES_NUMBER + shift  );\n    if (mod( test, 2.) == 1.)  set = 1.;\n    \n    vec4 color = white * set;\n    \n    if (length ((uv - vec2 (0.5, 0.5)) * sc ) < 0.014) color = vec4(1.,0.,0.,1.);\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 154, 154, 698]], "test": "valid"}
{"id": "lt3XRn", "name": "Generalized Mandelbrot Set", "author": "Patapom", "description": "A variation on modulo multiplications showing similarity with the amount of lobes of the generalized Mandelbrot set.\nYet again inspired by the same Mathologer episode: https://www.youtube.com/watch?v=qhbuKbxJsk8", "tags": ["mandelbrot", "modulo", "generalized"], "likes": 9, "viewed": 170, "published": "Public", "date": "1477665638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This shows the multiplication table modulo 200 represented as lines connecting points\n//\ton the unit circle, as explained in the Mathologer video https://www.youtube.com/watch?v=qhbuKbxJsk8\n//\n// In the background is the generalized Mandelbrot set with an arbitrary power that shows the connection\n//\tof the shapes obtained with the \"modulo multiplication\" and the amount of lobes in the Mandelbrot set.\n//  (this was also suggested by the same Mathologer video)\n//\nconst float\tTWOPI = 6.283185307179586476925286766559;\n\n// You can remove this line for the \"regular\" multiplication but this mirroring\n//  makes the fitting to the Mandelbrot lobes better...\n#define MIRROR\n\n// Comment this to obtain the regular Mandelbrot set, otherwise coordinates outside the unit circle are reciprocated inside (love it!)\n#define RECIPROCAL_MANDELBROT\n\nconst float\tMAX_LOBES = 10.0;\t// Maximum amount of Mandelbrot lobes\nconst float\tMODULO = 200.0;\t\t// Amount of subdivisions of the circle\n\n// Computes the generalized mandelbrot set Zn+1 = Zn^p + C with an arbitrary p\n// We can notice that p is directly driving Z's argument, hence the apparent multiple rotations of the set's main lobes\n//\nvec3 ComputeMandelbrot( vec2 _uv, float _mul ) {\n    float\tstepsCount = 0.0;\n    vec2\tz = vec2( 0.0 );\n    for ( float i=0.0; i < 64.0; i++ ) {\n        z += _uv;\n        \n        float\tf = pow( dot( z, z ), 0.5 * _mul );\n        float\ta = _mul * atan( z.y, z.x );\n        z = f * vec2( cos( a ), sin( a ) );\n        if ( dot( z, z ) > 10.0 )\n            break;\n        stepsCount++;\n    }\n    return vec3( stepsCount / 64.0 );\n}\n\nvec3 ComputeInnerColor( vec2 _uv, float _mul ) {\n\n    float\tisOnLine = 0.0;\n    \n\tvec2\tscStart, scEnd;\n    \n    #ifdef MIRROR\n\t\t_uv.y = abs( _uv.y );\t// Better matching\n    #endif\n    \n\t// Compute start and end anglse based on multiplier\n\tfloat\tdStartAngle = TWOPI / MODULO;\n\tfloat\tdEndAngle = _mul * dStartAngle;\n    float\toffset = -0.5 * TWOPI / (_mul - 1.0);\t// This angular offset is used to make troughs coïncide with the Mandelbrot set\n\tfloat\tstartAngle = dStartAngle + offset;\n\tfloat\tendAngle = dEndAngle + offset;\n\n    for ( float i=1.0; i < MODULO; i++ ) {\n        // Compute start and end position on the unit circle, forming a line\n        scStart.y = sin( startAngle );\n        scStart.x = cos( startAngle );\n        scEnd.y = sin( endAngle );\n        scEnd.x = cos( endAngle );\n        \n        // Compute line normal\n        vec2\tnormal = normalize( vec2( scEnd.y - scStart.y, scStart.x - scEnd.x ) );\n        \n        // Compute distance to line\n        vec2\tdelta = _uv - scStart;\n        float\torthoDistance = abs( dot( delta, normal ) );\n        \n        // Check if the current position is on the line or not\n        isOnLine += smoothstep( 0.005, 0.0, orthoDistance );\n        \n        startAngle += dStartAngle;\n        endAngle += dEndAngle;\n    }\n\n    return vec3( 1.0 - clamp( isOnLine, 0.0, 1.0 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2\tR = iResolution.xy;\n    vec2\tuv = ( 2. * fragCoord - R ) / R.y;\n    \nuv *= 1.5 + 0.5 * sin( iTime );\t// Fun with flags\n    \n\tfloat\tmul = 1.0 + 0.5 * MAX_LOBES * (1.0 - cos( 0.2 * iTime ));\n    \n    float\tradius = length( uv );\n\tfloat\tD = mix( 1.0, 1.0 / (radius*radius), smoothstep( 0.95, 1.05, radius ) );\n    #ifdef RECIPROCAL_MANDELBROT\n\t\tvec3\tC = 0.5 * (ComputeInnerColor( D*uv, mul ) + ComputeMandelbrot( D*uv, mul ));\n    #else\n\t\tvec3\tC = 0.5 * (ComputeInnerColor( D*uv, mul ) + ComputeMandelbrot( uv, mul ));\n    #endif\n\tfragColor = vec4( C, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3XRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[980, 1182, 1230, 1230, 1610], [1612, 1612, 1660, 1660, 2939], [2941, 2941, 2998, 2998, 3562]], "test": "valid"}
{"id": "ltcXzr", "name": "AA Bouncing Balls", "author": "tholzer", "description": "Demonstrate bouncing 2 antialiased balls in 2d.", "tags": ["2d", "simulation", "antialiasing", "balls", "animate", "bouncing"], "likes": 1, "viewed": 183, "published": "Public", "date": "1477733616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---------------------------------------------------------\n// AABouncingBalls.glsl\n//   v1.0  2016-05-18  one ball\n//   v2.0  2016-10-29  two balls\n// based on       https://www.shadertoy.com/view/XsVXzm\n// tiny version   https://www.shadertoy.com/view/lsVXRw       \n//---------------------------------------------------------\nconst vec3 circle1Color = vec3(0.4, 0.3, 0.5);\nconst vec3 circle2Color = vec3(0.6, 0.5, 0.3);\nvec2 uv = vec2(0);\n//---------------------------------------------------------\n// draw circle at pos with given radius\n//---------------------------------------------------------\nfloat circle(in vec2 pos, in float radius, in float halo)\n{\n  return clamp (halo * (radius - length(pos)), 0.0, 1.0);\n}\n//---------------------------------------------------------\n// animate circle depending on given time\n//---------------------------------------------------------\nfloat animateCircle (float radius, float time, float x, vec3 color)\n{\n  float xPos = abs(mod(time, 2.0) -1.0) * 1.6;\n  vec2 center = vec2(0.085, 0.5) + vec2(xPos, -0.4+0.7*abs(sin(time*5.0)));\n  return circle (uv-center, radius, 111.0);\n}\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  uv = fragCoord.xy / iResolution.yy;\n  float t = iTime / 5.50;\n\n  vec3 color = vec3(1.0);   // background\n  color = mix(color, circle1Color, animateCircle(0.1,           t, 111., circle1Color));\n  color = mix(color, circle2Color, animateCircle(0.05, 1.+t*0.876, 222., circle2Color));\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 601, 660, 660, 720], [721, 883, 952, 952, 1121], [1122, 1182, 1239, 1239, 1557]], "test": "valid"}
{"id": "ltG3Dy", "name": "tokyo", "author": "mfandl", "description": "cells", "tags": ["2d"], "likes": 1, "viewed": 122, "published": "Public", "date": "1476443906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tentacleWeight = 25.0;\n    \n\tvec2 uv = floor(fragCoord.xy / tentacleWeight) * tentacleWeight / iResolution.xy;\n    vec2 cthulhu = abs(sin(uv + iTime));\n    float clr = cthulhu.x * cthulhu.y;\n\tfragColor = vec4(1.0, clr, clr, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltG3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 299]], "test": "valid"}
{"id": "ltG3Rc", "name": "Liquid Gold", "author": "efairbanks", "description": "Morphy gold thing.", "tags": ["raymarch", "lighting", "morph", "plaid"], "likes": 1, "viewed": 214, "published": "Public", "date": "1475804261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCH_STEPS 50.0\n#define MARCH_EPSILON 0.04\n#define SHADOW_STEPS 50.0\n#define SHADOW_EPSILON 0.005\n#define GRADIENT_STEP 0.02\n#define AA\n//#define RENDER_DISTANCE\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// --- //\n\n// field of view of camera\n#define FOV 0.15\nfloat CAMERA_DISTANCE = 40.;\n// generate combined distance field\nfloat map(vec3 p)\n{\n\tfloat d;\n    \n    vec3 q = p;\n    q = q - vec3(0.,-1.,0.);\n    q.x = q.x + 0.6*cos((iTime*2.+q.y)*2.*M_PI/3.);\n    q.z = q.z + 0.4*cos((iTime*3.+q.y)*2.*M_PI/3.);\n    d = sphere(q, 2.);\n \t\n    // ground plane\n    float planeWidth = 5.;\n    float e = -p.y+2.+MARCH_EPSILON;\n    e = max(e, -(planeWidth - abs(p.z)));\n    e = max(e, -(planeWidth - abs(p.x)));\n\n    d = min(d, e);\n        \n\treturn d;\n}\n\n// raymarching procedure with lots of output info\nvoid march(vec3 origin, vec3 direction, out vec3 rayHead, out bool hit, out float dist, out float steps)\n{\n    float distanceTraveled = 0.;\n    hit = true;\n    for(float step=0.; step<MARCH_STEPS; step++)\n    {\n        //rayHead = origin + (direction*distanceTraveled);\n        rayHead = origin + (direction*distanceTraveled)*.5;\n        dist = map(rayHead);\n        steps = step;\n        if(dist<MARCH_EPSILON||step>=MARCH_STEPS) return;\n        distanceTraveled += dist;\n    }\n    hit = false;\n}\n\n// get origin and direction of ray to be cast for camera/screen xy (pixel) coordinate\nvoid cameraRay(vec2 scanLines, vec3 cameraPosition, vec3 target, float fov, out vec3 pos, out vec3 dir)\n{\n\tvec3 forward = normalize(target-cameraPosition);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*scanLines.x*fov;\n    up = up*scanLines.y*fov;\n    \n    pos = cameraPosition;\n    dir = (right+up+forward);\n}\n\n// get surface normal of point on distance field for shading\nvec3 gradient( vec3 pos )\n{\n\tconst vec3 dx = vec3( GRADIENT_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRADIENT_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRADIENT_STEP );\n\treturn normalize(vec3(\n\t\tmap( pos + dx ) - map( pos - dx ),\n\t\tmap( pos + dy ) - map( pos - dy ),\n\t\tmap( pos + dz ) - map( pos - dz )\n\t));\n}\n\n// calculate diffuse lighting for point on distance field given surface normal\nfloat diffuse(vec3 normal, vec3 lightPosition)\n{\n\treturn max(dot(normal,normalize(lightPosition)),0.);\n}\n\n// calculate diffuse lighting for point on distance field\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<int(SHADOW_STEPS); i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<SHADOW_EPSILON || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// calculate combined lighting for point on distance field\nfloat shadePoint(vec3 position, vec3 normal, vec3 lightPosition)\n{\n    float diffuseLight = diffuse(normal, lightPosition);\n\t// speculative light - it might be specular, but we're not really sure\n    float specularLight = pow(diffuseLight,50.);\n\tfloat shadow = softshadow(position, lightPosition, 0.02, 2.25);\n    float ambient = 0.1;\n    return (diffuseLight*0.4+specularLight*2.9)*shadow+ambient;\n}\n\n// generate background color\nvec3 background(vec2 uv)\n{\n    return vec3(0.,0.,0.);\n\t//return vec3(0.5,0.5,0.5)*uv.y;\n}\n\nvec4 getPixel(vec2 fragCoord)\n{\n    // scale coordinates to -1 -> +1, adjusted for screen aspect ratio\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.-1.;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    // get mouse coords\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // get ray representing camera scanline position and direction\n    float cameraRotationSpeed = 0.2;\n    vec3 cameraPosition = normalize(vec3(sin(iTime*cameraRotationSpeed),\n                                         -.15,\n                                         cos(iTime*cameraRotationSpeed)));\n    if(iMouse.z>0.)\n        cameraPosition = normalize(vec3(\tsin(mouse.x*2.*M_PI),\n                                        \t-((1.-mouse.y)*2.)-0.001,\n                                        \tcos(mouse.x*2.*M_PI)));\n    cameraPosition *= CAMERA_DISTANCE;\n    vec3 cameraOrigin;\n    vec3 cameraDirection;\n    cameraRay(uv, cameraPosition, vec3(0.,0.,0.), FOV, cameraOrigin, cameraDirection);\n    \n    // calculate distance, hit point, etc of distance field via raymarching\n    vec3 rayHead;\n    bool hit;\n    float dist;\n    float steps;\n    march(cameraOrigin, cameraDirection, rayHead, hit, dist, steps);\n    \n    // calculate normal for point on distance field\n    vec3 normal = gradient(rayHead);\n    \n    // calculate light for point\n    vec3 rotLightPos = vec3(sin(iTime),-1.5,cos(iTime));\n    float light = 0.;\n    light += shadePoint(rayHead, normal, rotLightPos)*2.;\n\n   \tvec3 lightPos;\n    lightPos = vec3(1.,-0.5,1.);\n    light += shadePoint(rayHead, normal, lightPos)*0.6;\n    lightPos = vec3(-1.,-0.5,1.);\n    light += shadePoint(rayHead, normal, lightPos)*0.6;\n    lightPos = vec3(1.,-0.5,-1.);\n    light += shadePoint(rayHead, normal, lightPos)*0.6;\n    lightPos = vec3(-1.,-0.5,-1.);\n    light += shadePoint(rayHead, normal, lightPos)*0.6;\n    \n    \n    light /= 2.;\n    \n    // specify color of entire distance field\n    vec3 fieldColor = vec3(1.,0.8,0.5);\n    if(rayHead.y-2. > -0.001) {\n        float checkerMask = (mod(rayHead.x,1.)>0.5?1.:0.) + (mod(rayHead.z,1.)>0.5?1.:0.)/2.;\n        fieldColor = vec3(0.9,0.9,1.)*(checkerMask*0.7+0.3);\n    }\n    // final steps and background\n    vec3 color = fieldColor*light;\n    if(!hit) color = background(uv);\n    \n    // distance map\n    #ifdef RENDER_DISTANCE\n    color = vec3(steps/MARCH_STEPS);\n    #endif\n    \n    float vignette = 1.;\n    vignette *= pow(1.-abs(uv.x/2.), 0.9);\n    vignette *= pow(1.-abs(uv.y), 1.);\n    color *= vignette;\n    \n    // set fragment shader color\n    return vec4(color,1.);\n}\n\n// compose image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aaX = fragCoord;\n    aaX.x += 0.5;\n    vec2 aaY = fragCoord;\n    aaY.y += 0.5;\n\tvec4 color = getPixel(fragCoord);\n    #ifdef AA\n    color += getPixel(aaX);\n    color += getPixel(aaY);\n    color /= 3.;\n    #endif\n    fragColor = color;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltG3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 220, 253, 253, 277], [363, 399, 418, 418, 818], [820, 870, 976, 976, 1367], [1369, 1455, 1560, 1560, 1862], [1864, 1925, 1952, 1952, 2243], [2245, 2324, 2372, 2372, 2428], [2430, 2488, 2562, 2562, 2844], [2846, 2905, 2971, 2971, 3305], [3307, 3336, 3362, 3362, 3425], [3427, 3427, 3458, 3529, 5981], [5983, 6000, 6056, 6056, 6302]], "test": "valid"}
{"id": "ltGGWt", "name": "Terrainz 650 charz", "author": "VoidChicken", "description": "Low characters in terrain that looks pretty nice( to me at least ).", "tags": ["3d", "distancefield", "terrain", "raymarch", "sky", "fog", "distance", "vignette", "field", "character", "chicken"], "likes": 4, "viewed": 277, "published": "Public", "date": "1477370070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 L(vec3 d) {\n    return mix(vec3(0,.5,1), vec3(1), pow(max(dot(d, vec3(0, 1, 0)), 0.), .2));\n}\nvoid mainImage( out vec4 c, vec2 f )\n{\n\tvec2 R=iResolution.xy,u = f/R;\n    \n    vec3 d = vec3(u*2.-1., 1);\n   \n    vec3 po = vec3(0, 4, iTime);\n    vec3 p = po;\n    d.y*=R.y/R.x;\n     vec3 m = L(d+vec3(0, .6, 0));\n    \n    bool h = false;\n  \n    for (int i = 0; i < 100; ++i) {\n    \tfloat f = p.y+texture(iChannel0, p.xz/10.).r*2.+sin(p.x+p.z/10.)*cos(p.z-p.x/100.)-texture(iChannel0, p.xz/100.).r*2.;\n        if (length(p-po)>20.) break;\n        if (f < .2) {\n            h = true;\n           \n        }\n        p+=d*f/5.;\n    }\n    if (h)\n    \t    m = mix(\n                texture(iChannel1, p.xz).grb+(vec3(.8-length(p-po)/20.))/2.,\n                m, pow(length(p-po)/20., 25.))*(1.-texture(iChannel0, p.xz/10.).r*.7);\n    c = pow(vec4(m, 1)*(1.-length(u-.5)/1.62), vec4(1./1.5));\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 17, 17, 99], [100, 100, 138, 138, 886]], "test": "error"}
{"id": "ltK3zV", "name": "slugs", "author": "efairbanks", "description": "Slugs are red, right? Sure.", "tags": ["raymarching"], "likes": 1, "viewed": 109, "published": "Public", "date": "1475658129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCH_STEPS 150.0\n#define EPSILON 0.00005\n#define GRADIENT_STEP 0.02\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere( vec3 p, float s )\n{\n  p = p - vec3(0.,0.,-0.25);\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 b, float roundness)\n{\n\treturn length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n}\n\nvoid cameraRay(vec2 scanLines, vec3 cameraPosition, vec3 target, float fov, out vec3 pos, out vec3 dir)\n{\n\tvec3 forward = normalize(target-cameraPosition);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*scanLines.x*fov;\n    up = up*scanLines.y*fov;\n    \n    pos = cameraPosition;\n    dir = (right+up+forward);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\n#define FOV 0.8\nfloat map(vec3 p)\n{\n    const float times = 9.;\n\tfloat d = 1000.;\n    for(float i=0.;i<times;i++)\n    {\n    \td = smin(sphere(p,pow(0.83,i)*1.8),d,pow(1.,i)*0.9);\n        p.z-=pow(sin(iTime+(2.*M_PI*i/times)),2.);\n        p.x+=-pow(0.99,i)*1.;\n    }\n   \tfor(float i=0.;i<times;i++)\n    {\n    \td = smin(sphere(p,pow(0.83,7.-i)*1.8),d,pow(1.,i)*0.9);\n        p.z-=pow(sin(iTime+(2.*M_PI*i/times)),2.);\n        p.x-=-pow(0.99,i)*1.;\n    }\n   \tfor(float i=0.;i<times;i++)\n    {\n    \td = smin(sphere(p,pow(0.83,i)*1.8),d,pow(1.,i)*0.9);\n        p.z+=pow(sin(iTime+(2.*M_PI*i/times)),2.);\n        p.x-=-pow(0.99,i)*1.;\n    }\n    for(float i=0.;i<times;i++)\n    {\n    \td = smin(sphere(p,pow(0.83,7.-i)*1.8),d,pow(1.,i)*0.9);\n        p.z+=pow(sin(iTime+(2.*M_PI*i/times)),2.);\n        p.x+=-pow(0.99,i)*1.;\n    }\n    return d;\n}\n\nvoid march(vec3 origin, vec3 direction, out vec3 rayHead, out bool hit, out float dist, out float steps)\n{\n    float distanceTraveled = 0.;\n    hit = true;\n    for(float step=0.; step<MARCH_STEPS; step++)\n    {\n        rayHead = origin + (direction*distanceTraveled);\n        dist = map(rayHead);\n        steps = step;\n        if(dist<EPSILON||step>=MARCH_STEPS) return;\n        distanceTraveled += dist;\n    }\n    hit = false;\n}\n\nvec3 gradient( vec3 pos )\n{\n\tconst vec3 dx = vec3( GRADIENT_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRADIENT_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRADIENT_STEP );\n\treturn normalize(vec3(\n\t\tmap( pos + dx ) - map( pos - dx ),\n\t\tmap( pos + dy ) - map( pos - dy ),\n\t\tmap( pos + dz ) - map( pos - dz )\n\t));\n}\n\nfloat diffuse(vec3 normal, vec3 lightPosition)\n{\n\treturn max(dot(normal,normalize(lightPosition)),0.);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat shadePoint(vec3 position, vec3 normal, vec3 lightPosition)\n{\n    float diffuseLight = diffuse(normal, lightPosition);\n\t// is this specular?\n    // no, this could only be\n    // speculative light\n    float specularLight = pow(diffuseLight,30.);\n\tfloat shadow = 1.;//softshadow(position, normalize(lightPosition), 0.02, 2.25);\n    return (diffuseLight+specularLight)*shadow;\n}\n\nvec3 background(vec2 uv)\n{\n\treturn vec3(0.5,0.5,0.5)*uv.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale coordinates to -1 -> +1, adjusted for screen aspect ratio\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.-1.;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    // get ray representing camera scanline position and direction\n    vec3 cameraPosition = vec3(sin(iTime/4.),-1.,cos(iTime/4.))*5.;\n    vec3 cameraOrigin;\n    vec3 cameraDirection;\n    cameraRay(uv, cameraPosition, vec3(0.,0.,0.), FOV, cameraOrigin, cameraDirection);\n    \n    // calculate distance, hit point, etc of distance field via raymarching\n    vec3 rayHead;\n    bool hit;\n    float dist;\n    float steps = 40.;\n    march(cameraOrigin, cameraDirection, rayHead, hit, dist, steps);\n    \n    // calculate normal for point on distance field\n    vec3 normal = gradient(rayHead);\n    \n    // calculate light for point\n\tvec3 rotLightPos = vec3(-1.,-1.,0.);\n    vec3 latRotLightPos = vec3(0.,-1.,-1.);\n    vec3 lightPos = vec3(cos(iTime),sin(iTime),cos(iTime));\n    float light = 0.;\n    light += shadePoint(rayHead, normal, rotLightPos);\n    light += shadePoint(rayHead, normal, latRotLightPos);\n    light += shadePoint(rayHead, normal, lightPos);\n    light /= 3.;\n    \n    // specify color of entire distance field\n    vec3 fieldColor = vec3(1.0,0.4,0.4);\n    \n    // final steps and background\n    vec3 color = fieldColor*light;\n    if(!hit) color = background(uv);\n    \n    // set fragment shader color\n    fragColor = vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltK3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 157, 157, 222], [224, 224, 257, 257, 310], [312, 312, 356, 356, 421], [423, 423, 528, 528, 830], [832, 832, 873, 873, 956], [974, 974, 993, 993, 1793], [1795, 1795, 1901, 1901, 2224], [2226, 2226, 2253, 2253, 2544], [2546, 2546, 2594, 2594, 2650], [2652, 2652, 2726, 2726, 2984], [2986, 2986, 3052, 3052, 3366], [3368, 3368, 3394, 3394, 3428], [3430, 3430, 3486, 3557, 4910]], "test": "valid"}
{"id": "ltV3Dc", "name": "test noise reaction", "author": "silviopaganini", "description": "testing noise reaction ", "tags": ["voronoi", "noise"], "likes": 21, "viewed": 413, "published": "Public", "date": "1477321782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n    Combustible Voronoi Layers\n\t--------------------------\n\n    The effect itself is nothing new or exciting, just some moving 3D Voronoi layering. \n    However, the fire palette might prove useful to some.\n\n*/\n\n\n// This is my favorite fire palette. It's trimmed down for shader usage, and is based on an \n// article I read at Hugo Elias's site years ago. I'm sure most old people, like me, have \n// visited his site at one time or another:\n//\n// http://freespace.virgin.net/hugo.elias/models/m_ffire.htm\n//\n\n// Hash function. This particular one probably doesn't disperse things quite as nicely as some \n// of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 3D Voronoi: Obviously, this is just a rehash of IQ's original.\n//\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); // \"p -= g;\" works on some GPUs, but not all, for some annoying reason.\n\t\n\t// Maximum value: I think outliers could get as high as \"3,\" the squared diagonal length \n\t// of the unit cube, with the mid point being \"0.75.\" Is that right? Either way, for this \n\t// example, the maximum is set to one, which would cover a good part of the range, whilst \n\t// dispensing with the need to clamp the final result.\n\tfloat d = 1.; \n     \n    // I've unrolled one of the loops. GPU architecture is a mystery to me, but I'm aware \n    // they're not fond of nesting, branching, etc. My laptop GPU seems to hate everything, \n    // including multiple loops. If it were a person, we wouldn't hang out. \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\n\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat noiseLayers(in vec3 p) {\n\n    // Normally, you'd just add a time vector to \"p,\" and be done with \n    // it. However, in this instance, time is added seperately so that \n    // its frequency can be changed at a different rate. \"p.z\" is thrown \n    // in there just to distort things a little more.\n    vec3 t = vec3(0., 0., p.z+iTime*.5);\n\n    const int iter = 5; // Just five layers is enough.\n    float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.\n\n    for (int i = 0; i < iter; i++) {\n        tot += voronoi(p + t) * amp; // Add the layer to the total.\n        p *= 2.0; // Position multiplied by two.\n        t *= 1.5; // Time multiplied by less than two.\n        sum += amp; // Sum of amplitudes.\n        amp *= 0.5; // Decrease successive layer amplitude, as normal.\n    }\n    \n    return tot/sum; // Range: [0, 1].\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n\t\n\t// Shifting the central position around, just a little, to simulate a \n\t// moving camera, albeit a pretty lame one.\n\t//uv += vec2(sin(iTime*0.5)*0.25, cos(iTime*0.5)*0.125);\n\t\n    // Constructing the unit ray. \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/12.));\n\n    // Rotating the ray about the XY plane, to simulate a rolling camera.\n\t//float cs = cos(iTime*0.25), si = sin(iTime*0.25);\n    // Apparently \"r *= rM\" can break in some older browsers.\n\t//rd.xy = rd.xy*mat2(cs, -si, si, cs); \n\t\n\t// Passing a unit ray multiple into the Voronoi layer function, which \n\t// is nothing more than an fBm setup with some time dialation.\n\tfloat c = noiseLayers(rd*2.);\n\t\n\t// Optional: Adding a bit of random noise for a subtle dust effect. \n\t//c = max(c + dot(hash33(rd)*2.-1., vec3(0.015)), 0.);\n\n    // Coloring:\n    \n    // Nebula.\n    //c *= sqrt(c)*1.5; // Contrast.\n    //vec3 col = firePalette(c); // Palettization.\n    //col = mix(col, col.zyx*0.1+c*0.9, (1.+rd.x+rd.y)*0.45 ); // Color dispersion.\n    \n    // The fire palette on its own. Perhaps a little too much fire color.\n     //c = pow(c, 1.33)*1.33;\n    // vec3 col =  firePalette(c);\n   \n    // Black and white, just to keep the art students happy. :)\n\t c *= sqrt(c)*1.25;\n\t vec3 col = vec3(c);\n\t\n\t// Done.\n\tfragColor = vec4(clamp(col, 0., 1.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltV3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 674, 694, 694, 803], [805, 874, 896, 896, 2001], [2003, 2201, 2231, 2504, 3041], [3043, 3043, 3100, 3127, 4516]], "test": "valid"}
{"id": "ltV3RV", "name": "Remarch v1.0", "author": "efairbanks", "description": "A rewrite of my variation on ray-marching, which is honestly not very innovative and is probably pretty inefficient. Cut me some slack, I started learning about fragment shaders six days ago. Couldn't have done it without the awesome ShaderToy community.", "tags": ["raymarcher"], "likes": 1, "viewed": 144, "published": "Public", "date": "1475709600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCH_STEPS 128.0\n#define MARCH_EPSILON 0.001\n#define SHADOW_STEPS 40.0\n#define SHADOW_EPSILON 0.01\n#define GRADIENT_STEP 0.02\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 b, float roundness)\n{\n\treturn length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat cappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat triangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat quad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// --- //\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\n// ----------------------------------------------- //\n// --- NOTES ON DISTANCE FIELD TRANSFORMATIONS --- //\n// ----------------------------------------------- //\n\n// UNION:\t\tmin(d1,d2)\n// SUBTRACT:\tmax(-d1,d2)\n// INTERSECT:\tmax(d1,d2)\n// REPEAT:\t\tmap(mod(p,c)-0.5*c)\n// SCALE:\t\tmap(p/s)*s\n// ROTATE:\t\tmap(invert(m)*p)\t// where m == 4x4 rot matrix\n/*\n\nfloat twist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return primitive(q);\n}\n\nfloat bend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return primitive(q);\n}\n\n*/\n\n// ----------------------------------------------- //\n// ----------------------------------------------- //\n// ----------------------------------------------- //\n\n// field of view of camera\n#define FOV 0.001\n// generate combined distance field\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    q.xyz = mod(p.xyz,vec3(5.0))-2.5;\n    \n    // draw rounded box\n    float boxSize = 2.;\n\tfloat d = box(q,vec3(boxSize), boxSize/3.);\n    d = max(d,sphere(p,boxSize*10.));\n\n\treturn d;\n}\n\n// raymarching procedure with lots of output info\nvoid march(vec3 origin, vec3 direction, out vec3 rayHead, out bool hit, out float dist, out float steps)\n{\n    float distanceTraveled = 0.;\n    hit = true;\n    for(float step=0.; step<MARCH_STEPS; step++)\n    {\n        rayHead = origin + (direction*distanceTraveled);\n        dist = map(rayHead);\n        steps = step;\n        if(dist<MARCH_EPSILON||step>=MARCH_STEPS) return;\n        distanceTraveled += dist;\n    }\n    hit = false;\n}\n\n// get origin and direction of ray to be cast for camera/screen xy (pixel) coordinate\nvoid cameraRay(vec2 scanLines, vec3 cameraPosition, vec3 target, float fov, out vec3 pos, out vec3 dir)\n{\n\tvec3 forward = normalize(target-cameraPosition);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*scanLines.x*fov;\n    up = up*scanLines.y*fov;\n    \n    pos = cameraPosition;\n    dir = (right+up+forward);\n}\n\n// get surface normal of point on distance field for shading\nvec3 gradient( vec3 pos )\n{\n\tconst vec3 dx = vec3( GRADIENT_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRADIENT_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRADIENT_STEP );\n\treturn normalize(vec3(\n\t\tmap( pos + dx ) - map( pos - dx ),\n\t\tmap( pos + dy ) - map( pos - dy ),\n\t\tmap( pos + dz ) - map( pos - dz )\n\t));\n}\n\n// calculate diffuse lighting for point on distance field given surface normal\nfloat diffuse(vec3 normal, vec3 lightPosition)\n{\n\treturn max(dot(normal,normalize(lightPosition)),0.);\n}\n\n// calculate diffuse lighting for point on distance field\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<int(SHADOW_STEPS); i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<SHADOW_EPSILON || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// calculate combined lighting for point on distance field\nfloat shadePoint(vec3 position, vec3 normal, vec3 lightPosition)\n{\n    float diffuseLight = diffuse(normal, lightPosition);\n\t// speculative light - it might be specular, but we're not really sure\n    float specularLight = pow(diffuseLight,30.);\n\tfloat shadow = softshadow(position, normalize(lightPosition), 0.02, 2.25);\n    return (diffuseLight+specularLight)*shadow;\n}\n\n// generate background color\nvec3 background(vec2 uv)\n{\n\treturn vec3(0.5,0.5,0.5)*uv.y;\n}\n\n// compose image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale coordinates to -1 -> +1, adjusted for screen aspect ratio\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.-1.;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    // get mouse coords\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // get ray representing camera scanline position and direction\n    float cameraRotationSpeed = 0.2;\n    vec3 cameraPosition = normalize(vec3(sin(iTime*cameraRotationSpeed),\n                                         sin(iTime*cameraRotationSpeed),\n                                         cos(iTime*cameraRotationSpeed)));\n    if(iMouse.z>0.)\n        cameraPosition = normalize(vec3(\tsin(mouse.x*2.*M_PI),\n                                        \t(mouse.y*2.-1.),\n                                        \tcos(mouse.x*2.*M_PI)));\n    cameraPosition *= 20000.;\n    vec3 cameraOrigin;\n    vec3 cameraDirection;\n    cameraRay(uv, cameraPosition, vec3(0.,0.,0.), FOV, cameraOrigin, cameraDirection);\n    \n    // calculate distance, hit point, etc of distance field via raymarching\n    vec3 rayHead;\n    bool hit;\n    float dist;\n    float steps = 40.;\n    march(cameraOrigin, cameraDirection, rayHead, hit, dist, steps);\n    \n    // calculate normal for point on distance field\n    vec3 normal = gradient(rayHead);\n    \n    // calculate light for point\n\tvec3 rotLightPos = vec3(-0.5,-1.,0.);\n    vec3 latRotLightPos = vec3(0.,-1.,-1.);\n    vec3 lightPos = vec3(cos(iTime),sin(iTime),cos(iTime));\n    float light = 0.;\n    light += shadePoint(rayHead, normal, rotLightPos);\n    light += shadePoint(rayHead, normal, latRotLightPos);\n    light += shadePoint(rayHead, normal, lightPos);\n    light /= 3.;\n    \n    // specify color of entire distance field\n    vec3 fieldColor = vec3(1.0,0.4,0.4);\n    \n    // final steps and background\n    vec3 color = fieldColor*light;\n    if(!hit) color = background(uv);\n    \n    // set fragment shader color\n    fragColor = vec4(color,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltV3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 209, 209, 228], [230, 230, 261, 261, 326], [328, 328, 361, 361, 385], [387, 387, 431, 431, 496], [498, 498, 532, 532, 566], [568, 568, 598, 598, 659], [661, 661, 692, 692, 723], [725, 725, 759, 759, 843], [845, 845, 879, 879, 966], [968, 968, 1018, 1018, 1145], [1147, 1147, 1187, 1187, 1286], [1288, 1288, 1330, 1330, 1623], [1625, 1625, 1666, 1666, 1726], [1728, 1728, 1778, 1778, 2285], [2287, 2287, 2341, 2341, 2981], [2983, 2994, 3035, 3035, 3118], [4026, 4062, 4081, 4081, 4285], [4287, 4337, 4443, 4443, 4772], [4774, 4860, 4965, 4965, 5267], [5269, 5330, 5357, 5357, 5648], [5650, 5729, 5777, 5777, 5833], [5835, 5893, 5967, 5967, 6249], [6251, 6310, 6376, 6376, 6680], [6682, 6711, 6737, 6737, 6771], [6773, 6790, 6846, 6917, 8769]], "test": "valid"}
{"id": "ltVGRK", "name": "A centipede", "author": "erucipe", "description": "mouse x: adjust the camera move\nmouse y: the height of legs' movement \n\nQ1: Is it possible to do smin between bodies of the centipede?\n\nQ2: How can I detect collision between legs and the floor correctly without displace the shape?", "tags": ["ik", "insect"], "likes": 8, "viewed": 754, "published": "Public API", "date": "1475591885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// bunch of remix codes from iq, Shane, nimitz\n\nconst float pi = 3.141592;\n\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\nvec3 tri33(in vec3 x){return abs(x-floor(x)-.5);} \nfloat surfFunc(in vec3 p){\n\treturn dot(tri33(p*0.5 + tri33(p*0.25).yzx), vec3(0.666));\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdFloor(vec3 p) {\n\treturn p.y + 0.4 * surfFunc(p + vec3(0.0, 0.0, iTime));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - mix(ra, rb, h);\n}\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat smin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smaxP(vec2 a, vec2 b, float s){    \n\tfloat h = clamp( 0.5 + 0.5*(a.x-b.x)/s, 0., 1.);\n\treturn mix(b, a, h) + h*(1.0-h)*s;\n}\n\nvec4 solve(vec2 p1, float r1, vec2 p2, float r2) {\n\tvec2 p = p2 - p1;\n\tfloat d = length(p);\n\tfloat k = (d * d + r1 * r1 - r2 * r2) / (2.0 * d);\n\tfloat s = sqrt(r1 * r1 - k * k);\n\tfloat x1 = p1.x + (p.x * k) / d + (p.y / d) * s;\n\tfloat y1 = p1.y + (p.y * k) / d - (p.x / d) * s;\n\tfloat x2 = p1.x + (p.x * k) / d - (p.y / d) * s;\n\tfloat y2 = p1.y + (p.y * k) / d + (p.x / d) * s;\n\t\n\treturn vec4(x1, y1, x2, y2);\n}\n\nvec2 map(vec3 p) {\n\tvec2 d = vec2(100.0, 0.0);\n\td = opU(d, vec2(sdFloor(p), 3.0));\n\tfloat s = d.x - p.y;\n\tp.y += s;\n\tfloat z = p.z;\n\tfloat phase = sin(z) * 3.14;\n\tfloat z0 = mod(p.z, 0.25) - 0.125;\n    float z1 = mod(z - 0.25, 0.5) - 0.25;\n    float z2 = mod(z, 0.5) - 0.25;\n    p.z = smin(pow(z1 * z2, 0.6), z0, 0.1);\n    p.z = pow(z1 * z2, 0.8);\n    p.z = z0;\n\tfloat t = iTime * 10.0;\n\tvec3 center = vec3(0.1 * sin(z + iTime * 4.0), 0.5, 0.0);\n\tvec3 joint_r = vec3(-0.4, 0.4, 0.0); \n\tvec3 joint_l = vec3(0.4, 0.4, 0.0);\n\tfloat h = iMouse.y / iResolution.y;\n    h = iMouse.y == 0.0 ? 0.5 : h;\n\tvec3 foot_r = vec3(-0.5, h * (0.5 + 0.5 * sin(t + phase)), 0.0); \n\tvec3 foot_l = vec3(0.5, h * (0.5 + 0.5 * sin(t + pi + phase)), 0.0);\n\tjoint_r.xy = solve(center.xy, 0.4, foot_r.xy, 0.4).xy;\n\tjoint_l.xy = solve(center.xy, 0.4, foot_l.xy, 0.4).zw;\n\t\n\td = opU(d, vec2(sdCapsule(p, center, joint_l, 0.05, 0.02), 2.0));\n\td = opU(d, vec2(sdCapsule(p, joint_l, foot_l, 0.02, 0.01), 2.0));\n\td = opU(d, vec2(sdCapsule(p, center, joint_r, 0.05, 0.02), 2.0));\n\td = opU(d, vec2(sdCapsule(p, joint_r, foot_r, 0.02, 0.01), 2.0));\n    \n    float d1 = sdSphere(vec3(p.xy, z1) - center, 0.1);\n    float d2 = sdSphere(vec3(p.xy, z2) - center, 0.1);\n    float body = smin(d1, d2, 0.2);\n\td = smin(d, vec2(body, 2.2), 0.1);\n\t\n\treturn d;\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec2 e = vec2(-1.0, 1.0) * 0.001;\n\treturn normalize(\n\t\te.xyy * map(p + e.xyy).x +\n\t\te.yxy * map(p + e.yxy).x + \n\t\te.yyx * map(p + e.yyx).x + \n\t\te.xxx * map(p + e.xxx).x\n\t);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax ) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 32.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\tvec3 ro = vec3((mouse.x - 0.5) * 10.0, 2.0, 6.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x*cu + p.y*cv + 2.7*cw); \n\t\n\tfloat precis = 0.001;\n\tfloat t = 0.0;\n\tfloat h = precis * 2.0;\n\tfloat m = 0.0;\n\tfor(int i = 0; i < 120; i++) {\n\t\tif(abs(h) < precis || t > 20.0) continue;\n\t\tvec2 o = map(ro + rd * t);\n\t\th = o.x;\n\t\tm = o.y;\n\t\tt += h;\n\t}\n\t\n\tvec3 c = vec3(0.0);\n\tvec3 col = vec3(0.0);\n\tif(h < precis) {\n\t\tvec3 pos = ro + rd * t;\n\t\tvec3 ld = vec3((mouse.x - 0.5)*20.0, 10.0, 5.0) - pos;\n\t\tvec3 lig = normalize(ld);\n\t\tvec3 nor = calcNormal(pos);\n\t\tfloat dif = clamp(dot(lig, nor)*length(ld)*0.1, 0.0, 1.0);\n\t\tfloat spe = pow(clamp(dot(reflect(lig, nor), rd), 0.0, 1.0), 64.0);\n\t\tfloat sh = softshadow(pos, lig, 0.01, 10.0);\n\t\tfloat fre = 1.0 - dot(-rd, nor);\n\t\tfloat fog = 1.0 - clamp(exp(-0.2 * (pos.z + 5.0)), 0.0, 1.0);\n\t\tfloat kk = m == 3.0 ? 0.0 : m;\n\t\tcol = vec3(0.5 + 0.5 * sin(m * 0.1), 0.5 + 0.5 * sin(m * 2.0), kk * (0.5 + 0.5 * sin(pos.z * 0.5 + iTime)));\n\t\tc = 1.5 * col * (dif + spe + fre * 0.5) * (0.5 + 0.5 * sh) * fog;\n\t}\n\n\tfragColor = vec4( c, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 99, 99, 127], [129, 129, 151, 151, 178], [180, 180, 206, 206, 268], [270, 270, 303, 303, 328], [330, 330, 353, 353, 412], [414, 414, 475, 475, 614], [616, 616, 646, 646, 679], [681, 681, 722, 722, 809], [811, 811, 849, 849, 940], [942, 942, 978, 978, 1070], [1072, 1072, 1122, 1122, 1483], [1485, 1485, 1503, 1503, 2799], [2801, 2801, 2826, 2826, 3002], [3004, 3004, 3065, 3065, 3293], [3296, 3296, 3353, 3353, 4685]], "test": "valid"}
{"id": "ltVGWG", "name": "Biomorph", "author": "vmednis", "description": "Use mouse to change constant.\nInternet resources say that \"Biomorphs\" like this one were discovered by Dr. Clifford A. Pickover reportedly by accident.\nAs far as I know there was an article published about them on July 1989 issue of Scientific American.", "tags": ["2d", "fractal", "mouse", "mandlebrot", "power", "5", "clifford", "changing", "biomorph", "cliff", "pickover", "july", "1989", "scientificamerican", "5th"], "likes": 24, "viewed": 862, "published": "Public API", "date": "1476527815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nCopyright (c) 2016 Valters Mednis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#define ITERATIONS_MAX 100\n#define EXIT_NUMBER 10.0\n#define ANTIALIAS_AMOUNT 2\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\n    vec2 cRes = c;\n    for(int i = 1; i < 5; i++)\n    {\n        //Multiply the result by the original complex number\n    \tvec2 cResCopy = cRes;\n    \tcRes.x = (c.x * cResCopy.x) - (c.y * cResCopy.y);\n    \tcRes.y = (c.x * cResCopy.y) + (c.y * cResCopy.x);\n    }\n    return cRes;\n}\n\n//Returns the color of a biomorph at position coord\nvec4 colorBiomorph(vec2 coord, vec2 morphConstant)\n{\n    //This part is very similar to crude mandlebrot implementations\n    vec2 z = coord;\n    for(int i = 0; i < ITERATIONS_MAX; i++)\n    {\n        if((z.x * z.x < EXIT_NUMBER * EXIT_NUMBER) && (z.y * z.y < EXIT_NUMBER * EXIT_NUMBER) && ((z.x * z.x) + (z.y * z.y) < EXIT_NUMBER * EXIT_NUMBER))\n        {\n        \t//z = z^5 + c\n        \tz = complexPower5(z) + morphConstant;\n        }\n    }\n    \n    //Unlike mandelbrot and likes this is not colored according to the number of iterations\n    //it took to reach the exit number, but rather the according to the number itself after\n    //these iterations\n    if((z.x * z.x < EXIT_NUMBER * EXIT_NUMBER) || (z.y * z.y < EXIT_NUMBER * EXIT_NUMBER))\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant)\n{\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    vec2 sampleStep = 1.0 / iResolution.xy / float(ANTIALIAS_AMOUNT + 1);\n    for(int i = 1; i < ANTIALIAS_AMOUNT + 1; i++)\n    {\n        for(int j = 1; j < ANTIALIAS_AMOUNT + 1; j++)\n        {\n            vec2 currentPos = uv;\n            currentPos.x += sampleStep.x * float(i);\n            currentPos.y += sampleStep.y * float(j);\n            result += colorBiomorph((currentPos) * 4.0, constant);\n        }\n    }\n    return result / float(ANTIALIAS_AMOUNT * ANTIALIAS_AMOUNT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    //Position the Biomorph\n    if(iResolution.x > iResolution.y)\n    {\n    \tuv.x -= 0.5 * (iResolution.x / iResolution.y) - 0.1777;\n   \t\tuv.y -= 0.5;\n    }\n    else\n    {\n        uv.y -= 0.5 * (iResolution.y / iResolution.x);\n   \t\tuv.x -= 0.3333;\n    }\n    //Render the Biomorph\n    if(iMouse.z < 0.5)\n    {\n\t\tfragColor = antiAliasedBiomorph(uv, vec2(0.01 * sin(iTime / 4.0) + 0.15, 0.8));\n    }\n    else\n    {\n        fragColor = antiAliasedBiomorph(uv, iMouse.xy / iResolution.xy);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVGWG.jpg", "access": "shaders20k", "license": "mit", "functions": [[1147, 1202, 1230, 1230, 1509], [1511, 1563, 1615, 1683, 2423], [2425, 2550, 2600, 2600, 3127], [3129, 3129, 3186, 3186, 3720]], "test": "valid"}
{"id": "ltVGzy", "name": "Regular Tetrahedron", "author": "deadmanswitch", "description": "Regular Tetrahedron", "tags": ["raymarch", "wip", "green", "tetrahedron", "regular"], "likes": 5, "viewed": 217, "published": "Public", "date": "1475344341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653\n#define FOV 60.0\n\n#define MAX_STEP   32\n#define MAX_STEP_F 32.0\n\nconst float infinity = 1.0/0.00000000001;\n\n#define epsilon 0.0025\n\n\nfloat sum(in vec3 v3) {\n \treturn dot(v3, vec3(1.0));   \n}\n\nstruct Hit {\n    float dist;\n    vec3 norm;\n    vec3 col;\n};\n    \nstruct DirLight {\n\tvec3 dir;\n    vec3 col;\n    float intensity;\n};\n    \nvec3 applyLight(in DirLight light, in vec3 pos, in vec3 cam, in Hit hit) {\n\t\n    vec3 surfaceToLight = light.dir;\n\n    float diffuseCoefficient = max(0.0, dot(hit.norm, surfaceToLight));\n    \n    vec3 diffuse = diffuseCoefficient * hit.col*light.col * light.intensity;\n\n    // specular\n    vec3 surfaceToCamera = normalize(cam - pos);\n\n    float specularCoefficient = pow(\n        max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, hit.norm))),\n        1.0/0.0025/*materialShininess*/\n    );\n\n    vec3 specular = specularCoefficient * vec3(1.0, 1.0, 1.0)/*materialSpecularColor*/ * light.intensity;\n\t\n    // ambient\n    vec3 ambient = hit.col*light.col*0.05;\n    \n    // result\n    return diffuse + specular + ambient;\n    \n}\n\n// rotations\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// matrix functions\n\nvec3 applyMat( in vec3 v, in mat4 mat) {\n    return (vec4(v, 1.0) * mat).xyz;\n}\n\n//\nconst vec3 shadowColor = vec3(0.1, 0.0, 0.1);\nconst vec3 backColor = vec3(0.5, 0.5, 0.5);\nconst vec3 tetColor = vec3(0.0, 0.75, 0.0);\n\n/***************\n\nTetrahedron start\n\n***************/\n\n// normals\nconst vec3 norm1 = vec3(\n\t 0.4714045226573944,\n     0.3333333432674408,\n    -0.8164966106414795\n);\nconst vec3 norm2 = vec3(\n\t-0.9428090453147888,\n     0.3333333432674408,\n     0.0\n);\nconst vec3 norm3 = vec3(\n\t 0.4714045524597168,\n     0.3333333432674408,\n     0.8164966106414795\n);\nconst vec3 norm4 = vec3(\n\t 0.0,\n    -1.0,\n     0.0\n);\n\n// points\nconst vec3 point0 = vec3( 0.0,                 1.0,                 0.0);\nconst vec3 point1 = vec3( 0.9428090453147888, -0.3333333432674408,  0.0);\nconst vec3 point2 = vec3(-0.4714045226573944, -0.3333333432674408, -0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944, -0.3333333432674408,  0.8164966106414795);\n\nfloat planedist(in vec3 point, in vec3 norm) {\n\n    return dot(point, norm) - norm.y;\n\n}\n\nconst float size = 3.0;\nHit tet(in vec3 point) {\n    \n    Hit hit;\n    point = point/size;\n\n    // subtracting the planes from a sphere\n    vec4 distances = vec4(\n        planedist(point, norm1),\n        planedist(point, norm2),\n        planedist(point, norm3),\n        -(1.0/3.0+point.y)\n    );\n\n    float dist = max( max(distances.x, distances.y), max(distances.z, distances.w) );\n\n    // the sphere has a `size` radius\n    hit.dist = max(length(point)-1.0, dist)*size;\n    \n    if(hit.dist < epsilon) {\n        \n        // select the appropriate norm\n        vec4 eq = vec4(equal(distances, vec4(dist)));\n        \n        hit.norm = eq.x*norm1 + eq.y*norm2 + eq.z*norm3 + eq.w*norm4;\n        \n        hit.col = tetColor;\n        \n    }\n\n    return hit;\n    \n}\n\n/***************\n\nTetrahedron end\n\n***************/\n\nHit DE(in vec3 pos, in mat4 trans, in mat4 invTrans) {\n    \n    pos = applyMat(pos, invTrans);\n    \n    Hit hit = tet(pos);\n    \n    // convert back normal coordinates to global\n    hit.norm = normalize(applyMat(hit.norm, trans) - applyMat(vec3(0.0, 0.0, 0.0), trans));\n    \n    return hit;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 10.0+sin(iTime)*4.0);\n    vec3 pos = point;\n    \n    // light\n    DirLight light;\n    light.dir = normalize(vec3(0.25, 0.25, 1.0));\n    light.col = vec3(1.0, 1.0, 1.0);\n    light.intensity = 1.0;\n    \n    // trans\n    float rot = (iTime*0.25)*PI*2.0;\n    \n    mat4 trans = rotationMatrix(vec3(1.0, 0.0, 0.0), rot)*rotationMatrix(vec3(0.0, 1.0, 0.0), rot)*rotationMatrix(vec3(0.0, 0.0, 1.0), rot);\n    mat4 invTrans = inverse(trans);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\t\t\n        Hit hit = DE(pos, trans, invTrans);\n        float dist = hit.dist;\n\n        if(dist < epsilon) {\n            /*\n            fragColor = vec4(mix(\n                tetColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            */\n            \n            fragColor = vec4(applyLight(light, pos, point, hit), 1.0);\n            \n            return;\n        }\n\n        closest = min(closest, dist);\n\n        pos += dir*dist;\n\n    }\n\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/2.0, 0.0, 1.0))\n    ), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 179, 179, 213], [353, 353, 427, 427, 1082], [1084, 1097, 1142, 1142, 1770], [1772, 1793, 1833, 1833, 1872], [2415, 2752, 2798, 2798, 2840], [2866, 2866, 2890, 2890, 3604], [3606, 3659, 3713, 3713, 3956], [3958, 3958, 4015, 4034, 5501]], "test": "error"}
{"id": "lty3Rt", "name": "Pegasus Galaxy", "author": "frankenburgh", "description": "Galaxy shader from Pegasus 4k Intro\n4kb executable: http://www.pouet.net/prod.php?which=65859\nhttps://www.youtube.com/watch?v=3pXhImWoNsw", "tags": ["clouds", "space", "galaxy", "stars", "demsoscene", "nebular"], "likes": 183, "viewed": 14467, "published": "Public", "date": "1476125205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Galaxy shader\n//\n// Created by Frank Hugenroth  /frankenburgh/   07/2015\n// Released at nordlicht/bremen 2015\n\n#define SCREEN_EFFECT 0\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 2d noise function\nfloat noise( in vec2 x )\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbmslow( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.2;\n  f += 0.2500*noise( p ); p = m*p*1.3;\n  f += 0.1666*noise( p ); p = m*p*1.4;\n  f += 0.0834*noise( p ); p = m*p*1.84;\n  return f;\n}\n\nfloat fbm( vec3 p )\n{\n  float f = 0., a = 1., s=0.;\n  f += a*noise( p ); p = m*p*1.149; s += a; a *= .75;\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\n  f += a*noise( p ); p = m*p*1.51; s += a; a *= .65;\n  f += a*noise( p ); p = m*p*1.21; s += a; a *= .35;\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\n  f += a*noise( p ); \n  return f/s;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 0.1;\n\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\n\t// fade in (1=10sec), out after 8=80sec;\n\tfloat fade = min(1., time*1.)*min(1.,max(0., 15.-time));\n\t// start glow after 5=50sec\n\tfloat fade2= max(0., time-10.)*0.37;\n\tfloat glow = max(-.25,1.+pow(fade2, 10.) - 0.001*pow(fade2, 25.));\n\t\n\t\n\t// get camera position and view direction\n\tvec3 campos = vec3(500.0, 850., -.0-cos((time-1.4)/2.)*2000.); // moving\n\tvec3 camtar = vec3(0., 0., 0.);\n\t\n\tfloat roll = 0.34;\n\tvec3 cw = normalize(camtar-campos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.6*cw );\n\n\tvec3 light   = normalize( vec3(  0., 0.,  0. )-campos );\n\tfloat sundot = clamp(dot(light,rd),0.0,1.0);\n\n\t// render sky\n\n    // galaxy center glow\n    vec3 col = glow*1.2*min(vec3(1.0, 1.0, 1.0), vec3(2.0,1.0,0.5)*pow( sundot, 100.0 ));\n    // moon haze\n    col += 0.3*vec3(0.8,0.9,1.2)*pow( sundot, 8.0 );\n\n\t// stars\n\tvec3 stars = 85.5*vec3(pow(fbmslow(rd.xyz*312.0), 7.0))*vec3(pow(fbmslow(rd.zxy*440.3), 8.0));\n\t\n\t// moving background fog\n    vec3 cpos = 1500.*rd + vec3(831.0-time*30., 321.0, 1000.0);\n    col += vec3(0.4, 0.5, 1.0) * ((fbmslow( cpos*0.0035 ) - .5));\n\n\tcpos += vec3(831.0-time*33., 321.0, 999.);\n    col += vec3(0.6, 0.3, 0.6) * 10.0*pow((fbmslow( cpos*0.0045 )), 10.0);\n\n\tcpos += vec3(3831.0-time*39., 221.0, 999.0);\n    col += 0.03*vec3(0.6, 0.0, 0.0) * 10.0*pow((fbmslow( cpos*0.0145 )), 2.0);\n\n\t// stars\n\tcpos = 1500.*rd + vec3(831.0, 321.0, 999.);\n\tcol += stars*fbm(cpos*0.0021);\n\t\n\t\n\t// Clouds\n    vec2 shift = vec2( time*100.0, time*180.0 );\n    vec4 sum = vec4(0,0,0,0); \n    float c = campos.y / rd.y; // cloud height\n    vec3 cpos2 = campos - c*rd;\n    float radius = length(cpos2.xz)/1000.0;\n\n    if (radius<1.8)\n    {\n  \t  for (int q=10; q>-10; q--) // layers\n      {\n\t\tif (sum.w>0.999) continue;\n        float c = (float(q)*8.-campos.y) / rd.y; // cloud height\n        vec3 cpos = campos + c*rd;\n\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\n\n\t\t// border\n \t    float radius = length(cpos.xz)/999.;\n\t    if (radius>1.0)\n\t      continue;\n\n\t\tfloat rot = 3.00*(radius)-time;\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n \t\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\n\t\tcpos *= mix(0.0025, 0.0028, radius); // zoom\n      \tfloat alpha = smoothstep(0.50, 1.0, fbm( cpos )); // fractal cloud density\n\t  \talpha *= 1.3*pow(smoothstep(1.0, 0.0, radius), 0.3); // fade out disc at edges\n\t  \tvec3 dustcolor = mix(vec3( 2.0, 1.3, 1.0 ), vec3( 0.1,0.2,0.3 ), pow(radius, .5));\n      \tvec3 localcolor = mix(dustcolor, shine, alpha); // density color white->gray\n\t\t  \n\t\tfloat gstar = 2.*pow(noise( cpos*21.40 ), 22.0);\n\t\tfloat gstar2= 3.*pow(noise( cpos*26.55 ), 34.0);\n\t\tfloat gholes= 1.*pow(noise( cpos*11.55 ), 14.0);\n\t\tlocalcolor += vec3(1.0, 0.6, 0.3)*gstar;\n\t\tlocalcolor += vec3(1.0, 1.0, 0.7)*gstar2;\n\t\tlocalcolor -= gholes;\n\t\t  \n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\n\t  }\n\t\t\n  \t  for (int q=0; q<20; q++) // 120 layers\n      {\n\t\tif (sum.w>0.999) continue;\n        float c = (float(q)*4.-campos.y) / rd.y; // cloud height\n        vec3 cpos = campos + c*rd;\n\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\n\n\t\t// border\n \t    float radius = length(cpos.xz)/200.0;\n\t    if (radius>1.0)\n\t      continue;\n\n\t\tfloat rot = 3.2*(radius)-time*1.1;\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n \t\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\n      \tfloat alpha = 0.1+smoothstep(0.6, 1.0, fbm( cpos )); // fractal cloud density\n\t  \talpha *= 1.2*(pow(smoothstep(1.0, 0.0, radius), 0.72) - pow(smoothstep(1.0, 0.0, radius*1.875), 0.2)); // fade out disc at edges\n      \tvec3 localcolor = vec3(0.0, 0.0, 0.0); // density color white->gray\n  \n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\n\t  }\n    }\n\tfloat alpha = smoothstep(1.-radius*.5, 1.0, sum.w);\n    sum.rgb /= sum.w+0.0001;\n    sum.rgb -= 0.2*vec3(0.8, 0.75, 0.7) * pow(sundot,10.0)*alpha;\n    sum.rgb += min(glow, 10.0)*0.2*vec3(1.2, 1.2, 1.2) * pow(sundot,5.0)*(1.0-alpha);\n\n   \tcol = mix( col, sum.rgb , sum.w);//*pow(sundot,10.0) );\n\n    // haze\n\tcol = fade*mix(col, vec3(0.3,0.5,.9), 29.0*(pow( sundot, 50.0 )-pow( sundot, 60.0 ))/(2.+9.*abs(rd.y)));\n\n#if SCREEN_EFFECT == 1\n    if (time<2.5)\n    {\n    \t// screen effect\n    \tfloat c = (col.r+col.g+col.b)* .3 * (.6+.3*cos(gl_FragCoord.y*1.2543)) + .1*(noise((xy+time*2.)*294.)*noise((xy-time*3.)*321.));\n   \t    c += max(0.,.08*sin(10.*time+xy.y*7.2543));\n        // flicker\n\t\tcol = vec3(c, c, c) * (1.-0.5*pow(noise(vec2(time*99., 0.)), 9.));\n    }\n    else\n    {\n        // bam\n        float c = clamp(1.-(time-2.5)*6., 0., 1. );\n        col = mix(col, vec3(1.,1.,1.),c);\n    }\n#endif\n    \n    // Vignetting\n\tvec2 xy2 = gl_FragCoord.xy / iResolution.xy;\n\tcol *= vec3(.5, .5, .5) + 0.25*pow(100.0*xy2.x*xy2.y*(1.0-xy2.x)*(1.0-xy2.y), .5 );\t\n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "ldB3Rm", "previewfilepath": "https://soundcloud.com/virgill/4k-galaxy-pegasus-soundtrack", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/virgill/4k-galaxy-pegasus-soundtrack", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lty3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 177, 200, 200, 238], [240, 261, 287, 287, 486], [488, 488, 514, 514, 831], [913, 943, 968, 968, 1144], [1146, 1146, 1167, 1167, 1501], [1505, 1505, 1562, 1562, 7322]], "test": "valid"}
{"id": "lty3RV", "name": "simplex drunk dt", "author": "ollj", "description": "fork of \nhttps://www.shadertoy.com/view/Xsd3Rs\nwith mouse input, changed lines 54, 56, 57, 228\n\nto remind self that straight lines are for polygons but noisy curves are fun and cartoony.", "tags": ["noise", "sss", "simplex", "drunk", "ice", "hgsdf", "curved"], "likes": 2, "viewed": 221, "published": "Public", "date": "1475512039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fork of https://www.shadertoy.com/view/Xsd3Rs\n//camera orbit set by mouse.x\n//changed implementation of snoise, over time, lower wavelength, higher amplitude.\n//amplitude is linear to iouse.y\n\n//i assume the line artefacts are from bad derivates over full rotations.\n//they are not (simple) overstepping artefacts.\n\n// Everyday003 - IceCube\n// By David Ronai / @Makio64\n\n// Thanks to XT95 to implement SSS in this shadertoy:\n// https://www.shadertoy.com/view/MsdGz2\n// Base on this papper :\n// http://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 127\n#define RAYMARCHING_JUMP .25\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n#define RENDER_NORMAL\n//#define RENDER_AO\n\nconst float PI = acos(-1.);// 3.14159265359;\n\n//------------------------------------------------------------------  SIGNED PRIMITIVES\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2./repetitions*PI;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat snoise(vec3 v);\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n\tfloat d = pos.y;\n    pos -=snoise(pos*0.035+iTime*.01)*(2.+4.*iMouse.y/iResolution.y);\n    vec3 q = pos-vec3(0.,5.,0.);\n    pModPolar(q.xz, 10.);\n    q.x-=30.;\n\td = fOpUnionRound(d, fBox(q,vec3(5.)),4.4);\n    q = pos;\n    pModPolar(q.xz,8.);\n\td = fOpUnionRound(d, fBox(q,vec3(6.,20.,6.)),6.);\n\treturn d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 100. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale(line117) & inverse the color(line 118)\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// gamma correction\n\t// col = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t// vigneting\n\tcol *= 0.7+0.3*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 6., 1.5);\n\n    vec3 lpos1 = vec3(0.0,15.+sin(iTime)*5.,0.0);\n\tvec3 ldir1 = normalize(lpos1-pos);\n\tfloat latt1 = pow( length(lpos1-pos)*.1, 1.5 );\n    float trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\tvec3 diff1 = vec3(.0,.5,1.) * (max(dot(nor,ldir1),0.) ) / latt1;\n\tcol =  diff1;\n\tcol += vec3(.3,.2,.05) * (trans1/latt1)*thi;\n\n    for(int i = 0; i<6; i++){\n        float angle = float(i)/6.*PI*2.;\n        float radius = 30.;\n        vec3 lpos1 = vec3(cos(angle)*radius,5.,sin(angle)*radius);\n\t\tvec3 ldir1 = normalize(lpos1-pos);\n\t\tfloat latt1 = pow( length(lpos1-pos)*(.3+abs(sin(iTime)*2.)), 1. );\n    \tfloat trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\t\tcol += vec3(.2,.2,.4) * (trans1/latt1)*thi;\n\t}\n    \n\tcol = max(vec3(.05),col);\n\tcol *= ao;\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tfloat time = iTime;\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t//Camera\n\tfloat radius = 50.;\n    time=mouse.x*acos(-1.)*2.;\n\tvec3 ro = orbit(PI/2.-.5,PI/2.+time,radius);\n\tvec3 ta  = vec3(0.0, 0., 0.0);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n\n//------------------------------------------------------------------ NOISE\n//AshimaOptim https://www.shadertoy.com/view/Xd3GRf\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 1./3.) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lty3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[935, 1023, 1043, 1043, 1075], [1076, 1076, 1104, 1104, 1185], [1186, 1186, 1236, 1236, 1474], [1475, 1475, 1523, 1523, 1608], [1633, 1706, 1732, 1732, 2039]], "test": "error"}
{"id": "lty3WV", "name": "666 kyrpä", "author": "zov", "description": "vittu", "tags": ["kyrp"], "likes": 1, "viewed": 77, "published": "Public", "date": "1476794031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float sinModulator = sin(fragCoord.x / sin(iTime)*0.05)*sin(iTime)*3.0;\n    float sinMain = sin(sin(iTime*1.3)*10.0 + iTime + fragCoord.x/(sin(iTime)*20.0+40.0))/(6.0+sinModulator); //sinModulator;\n    float yCoord = 0.5+sinMain;\n    \n    if (uv.y < yCoord-0.02 || uv.y > yCoord+0.02) {\n        fragColor.rgb = vec3(0.0); \n    } else {\n        fragColor.rgb = vec3(0.78, 0.21, 0.7);\n    }\n    \n    if (uv.y < yCoord-0.02) {\n        vec2 seed = vec2(2.0, 8.0);\n        fragColor.rgb = vec3(rand(seed), 0.0, 0.0);\n    }\n    \n    vec2 square = vec2(8.0, 8.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lty3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 93], [95, 95, 152, 152, 760]], "test": "valid"}
{"id": "lty3zc", "name": "An amiga intro", "author": "Himred", "description": "Nostalgia .....\nI hope this version won't crash iq PC. :)\nMusic is Comic Bakery by the great Martin Galway.\n", "tags": ["intro", "amiga", "glenz", "textscroll"], "likes": 39, "viewed": 3923, "published": "Public API", "date": "1475844448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nAn amiga intro with Glenz cube & scrolltext.\n\nThe code is *NOT* optimized at all\nIt was coded as a proof of concept and a personal challenge (don't laugh).\n\nI borrowed some code (thats the concept of shadertoy isnt'it ?) from:\nLighting stuff: https://www.shadertoy.com/view/MdGXWG by Shane\nOriginal tentative of glenz: https://www.shadertoy.com/view/ldlSW2 by rix\nFonts: https://www.shadertoy.com/view/4s3XDn by Andre\n\n*/\n\nvec3 cubevec;\nvec2 coord;\n\n#define scrolltext BOLD H_ e_ l_ l_ o_  _ s_ h_ a_ d_ e_ r_ t_ o_ y_  _ _exclam _exclam  _ T_ h_ i_ s_  _ i_ s_  _ a_ n_  _ a_ t_ t_ e_ m_ p_ t_  _ t_ o_  _ r_ e_ n_ d_ e_ r_  _ a_  _ _1 _9 _9 _3  _ o_ l_ d_  _ s_ c_ h_ o_ o_ l_  _ a_ m_ i_ g_ a_  _ i_ n_ t_ r_ o_  _ w_ i_ t_ h_  _ a_  _ G_ l_ e_ n_ z_  _ c_ u_ b_ e_  _ a_ n_ d_  _ a_  _ t_ e_ x_ t_  _ s_ c_ r_ o_ l_ l_ e_ r_  _ _dot _dot _dot _dot  _ G_ r_ e_ e_ t_ i_ n_ g_ s_  _ t_ o_  _ I_ q_ _comma  _ S_ h_ a_ n_ e_ _comma  _ S_ h_ a_ u_ _comma  _ P_ _und M_ a_ l_ i_ n_ _comma  _ r_ i_ x_ _comma  _ A_ n_ d_ r_ e_  _ a_ n_ d_  _ o_ t_ h_ e_ r_ s_  _ I_  _ f_ o_ r_ g_ o_ t_  _ _dot _dot _dot  _ E_ O_ T_  _ _dot _dot _dot \n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n    return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w+.2;\n}\n\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n#define _ cp+=.5;\n#define BOLD cur.w = 1.5-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.6-cur.g;\n#define BLUE cur.b = 1.0-cur.b;\n#define crlf uv.y += 2.0; cp = 0.;\n\n// the test scroller\nvec3 Scroller(vec2 fragCoord )\n{\n    float ms = float(iMouse.w>0.);\n    float scale = 1.5;\n    vec2 mouseOffs = vec2(0);\n\tvec2 uv = (fragCoord+mouseOffs-.5*iResolution.xy) / iResolution.x * 22.0 * scale;\n    uv.x+=8.*iTime;\n    uv.x-=290.;\n    uv.y-=0.55;\n    uv.x=mod(uv.x,150.)-30.;\n  \n    float px = 22.0/iResolution.x*scale;\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0.,0.,0.,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n    uv.x += 10.1;\n\n    uv.x=uv.x+0.5*sin(uv.y+2.*iTime);\n    uv.y = mod(uv.y,2.0)-1.;\n    scrolltext\n    float weight  = 0.05;\n    return vec3(mix(us.rgb,vec3(0.5),smoothstep(weight-px,weight+px, x)));\n}\n\n\n// Sinus bars function\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\n// Render the bars calling 3 CalcSines() and adding rgb componants\nvec3 Bars(vec2 f)\n{\n    vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.10, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.10, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.10, 1.0);\n    return color;\n}\n\n// Classic iq twist function\nvec3 Twist(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// The distance function which generate a rotating twisted rounded cube \n// and we save its pos into cubevec\nfloat Cube( vec3 p )\n{\n    p=Twist(p);\n    cubevec.x = sin(iTime);\n    cubevec.y = cos(iTime);\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\n// Split the face in 4 triangles zones\n// return color index 0 or 1 if color1 or color2\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\n//Classic iq normal\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x;\n    float pat = iTime*5.0;\n    float Step = 1.0;\n    float Distance = 0.0;\n    float Near = -1.0;\n    float Far = -1.0;\n    vec3 lightPos = vec3(1.5, 0, 0);\n    vec2 kp = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*kp;\n    vec4 m = iMouse / iResolution.xxxx;\n    float hd=-1.;\n    float ay=0.1;\n      \n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n            \t\tif(hd<0.) hd=Distance;\n                    if( Near < 0.0 ) Near = Far;\n            \t\tif(m.z<=0.0) Distance += 0.05; else break;\n                }\n        }\n\n    vec3 Color=Bars(fragCoord);\n    \n    if( Near > 0.0 )\n    \t{\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            \n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n\n    vec3 rainbow = vec3(0.5 + 0.5 * sin(kp.x*8. + 3.14 + pat), 0.5 + 0.5 * cos (kp.x*8. + pat), 0.5 + 0.5 * sin (kp.x*8. + pat));\n    if (kp.y > ay && kp.y < ay+0.006 || kp.y > (1.-ay) && kp.y < 1.-ay+0.006 ) Color = rainbow;\n    if(kp.y>1.-ay+0.006 || kp.y<0.1) Color=vec3(0.20,0.17,0.35);\n    \n    if(kp.y<=ay)\n    \t{\n        vec3 cc = Scroller(fragCoord);\n        if(cc!=vec3(0.5)) Color=rainbow;\n        }\n    \n    \n    // Presenting color to the screen\n    fragColor = vec4( Color, 1.0 );\n}", "image_inputs": [{"id": "XdSGRm", "previewfilepath": "https://soundcloud.com/ziphoid/03-ziphoid-comic-bakery", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/ziphoid/03-ziphoid-comic-bakery", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lty3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1137, 1173, 1173, 1298], [1300, 1350, 1387, 1387, 1546], [1547, 1547, 1566, 1566, 1620], [1621, 1621, 1640, 1640, 1871], [1872, 1872, 1891, 1891, 1961], [1962, 1962, 1981, 1981, 2045], [2047, 2071, 2090, 2090, 2340], [2341, 2341, 2360, 2360, 2427], [2428, 2428, 2447, 2447, 2686], [2687, 2687, 2706, 2706, 2744], [2745, 2745, 2764, 2764, 2947], [2948, 2948, 2967, 2967, 3130], [3131, 3131, 3150, 3150, 3298], [3299, 3299, 3318, 3318, 3427], [3428, 3428, 3447, 3447, 3500], [3501, 3501, 3520, 3520, 3592], [3593, 3593, 3612, 3612, 3766], [3767, 3767, 3786, 3786, 3807], [3808, 3808, 3827, 3846, 4003], [4004, 4004, 4023, 4023, 4113], [4114, 4114, 4133, 4133, 4154], [4155, 4155, 4174, 4174, 4257], [4258, 4258, 4277, 4277, 4316], [4317, 4317, 4336, 4336, 4554], [4555, 4555, 4574, 4574, 4836], [4837, 4837, 4856, 4856, 4994], [4995, 4995, 5014, 5014, 5043], [5044, 5044, 5063, 5063, 5136], [5137, 5137, 5156, 5156, 5287], [5288, 5288, 5307, 5307, 5372], [5373, 5373, 5392, 5392, 5501], [5502, 5502, 5521, 5521, 5680], [5682, 5694, 5713, 5713, 5938], [5940, 5940, 5959, 5959, 6222], [6223, 6223, 6242, 6242, 6543], [6544, 6544, 6563, 6563, 6841], [6842, 6842, 6861, 6861, 7087], [7088, 7088, 7107, 7107, 7311], [7312, 7312, 7331, 7331, 7766], [7767, 7767, 7786, 7786, 7944], [7945, 7945, 7964, 7964, 8121], [8122, 8122, 8141, 8141, 8400], [8401, 8401, 8420, 8420, 8616], [8617, 8617, 8636, 8636, 8773], [8774, 8774, 8793, 8793, 9042], [9043, 9043, 9062, 9062, 9261], [9262, 9262, 9281, 9281, 9348], [9349, 9349, 9368, 9368, 9597], [9598, 9598, 9617, 9617, 9802], [9803, 9803, 9822, 9822, 10106], [10107, 10107, 10126, 10126, 10400], [10401, 10401, 10420, 10420, 10556], [10557, 10557, 10576, 10576, 10751], [10752, 10752, 10771, 10771, 10844], [10845, 10845, 10864, 10864, 10995], [10996, 10996, 11015, 11015, 11096], [11097, 11097, 11116, 11116, 11301], [11302, 11302, 11321, 11321, 11494], [11496, 11496, 11516, 11516, 11720], [11721, 11721, 11741, 11741, 12014], [12015, 12015, 12035, 12035, 12209], [12210, 12210, 12230, 12230, 12420], [12421, 12421, 12441, 12441, 12793], [12794, 12794, 12814, 12814, 13109], [13110, 13110, 13130, 13130, 13251], [13252, 13252, 13272, 13272, 13434], [13435, 13435, 13455, 13455, 13736], [13737, 13737, 13757, 13757, 13835], [13837, 13847, 13868, 13868, 13919], [13920, 13920, 13942, 13942, 14013], [14014, 14014, 14037, 14037, 14117], [14118, 14118, 14143, 14143, 14371], [14372, 14372, 14394, 14394, 14535], [14536, 14536, 14559, 14559, 14601], [14602, 14602, 14625, 14625, 14703], [14704, 14704, 14729, 14729, 14869], [14870, 14870, 14893, 14893, 14990], [14991, 14991, 15012, 15012, 15145], [15146, 15146, 15167, 15167, 15225], [15226, 15226, 15247, 15247, 15398], [15399, 15399, 15420, 15420, 15475], [15476, 15476, 15495, 15495, 15585], [15586, 15586, 15605, 15605, 15642], [15643, 15643, 15664, 15664, 15843], [15844, 15844, 15864, 15864, 16257], [16258, 16258, 16277, 16277, 16347], [16348, 16348, 16368, 16368, 16426], [16427, 16427, 16449, 16449, 16612], [16613, 16613, 16636, 16636, 16676], [16677, 16677, 16699, 16699, 16947], [16948, 16948, 16971, 16971, 17011], [17013, 17013, 17063, 17063, 17109], [17110, 17110, 17162, 17162, 17199], [19599, 19620, 19652, 19652, 20267], [20270, 20293, 20419, 20419, 20615], [20617, 20684, 20703, 20703, 21025], [21027, 21056, 21076, 21076, 21226], [21228, 21337, 21359, 21359, 21632], [21634, 21722, 21745, 21745, 21853], [21855, 21875, 21904, 21904, 22098], [22101, 22101, 22158, 22158, 24464]], "test": "valid"}
{"id": "ltyGz3", "name": "Complex spiral", "author": "ehj1", "description": "Created by modifying https://www.shadertoy.com/view/4ly3zc", "tags": ["spiral"], "likes": 0, "viewed": 105, "published": "Public", "date": "1475785401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y*2.0-iResolution.xy/iResolution.y;\n    \n    float l = 0.0;\n    vec2 rot = vec2(sin(iTime*0.1),cos(iTime*0.1));\n    \n    for(int i = 0; i < 256; i++) {\n        \n        uv = 1.1*(uv.x*vec2(rot.x,rot.y)+uv.y*vec2(-rot.y,rot.x));\n        \n        if(pow(0.05*uv.x, sin(uv.y)) > 12.0) {\n            break;\n        }\n        l++;\n    }\n    \n    fragColor = vec4(mod(l, 2.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 469]], "test": "valid"}
{"id": "ltyGzt", "name": "Mandelbrot  Morph", "author": "decrooks", "description": " Generalized Mandelbrot  Set", "tags": ["2d", "fractal", "mandelbrot"], "likes": 1, "viewed": 159, "published": "Public", "date": "1476135157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 complexExp(vec2 z, vec2 w){\n   float l = length(z);\n   float zsq = l*l;\n   float argz = atan(z.y,z.x);\n   float alpha = pow(zsq,0.5*w.x)* exp(-w.y*argz);\n   float beta = w.x*argz + 0.5*w.y* log( zsq); \n    \n   return alpha*vec2(cos(beta),sin(beta)) ; \n}\n\n\nfloat mandelbrot(vec2 z,vec2 w){\n\n  vec2 c = z;\n                                                             \n  int n=1;\n  const int   maxitn = 50;                              \n  \n    for( int i = 0;i<maxitn;i++){\n      \n        z = complexExp(z,w) + c;\n        \n        if(length(z) >= 2.0) {\n            return float(i)/float(maxitn);\n        }\n    }\n   \n   return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 z = 2.0*uv + vec2(-1.0,-1.3);\n    z.x = z.x*aspectRatio;\n    z = vec2(z.y,z.x);\n    \n    \n    vec2 w = vec2(4.0  + 3.0*cos(iTime),0.0);\n    float t = mandelbrot(z,w);\n\t\n    float a = cos(iTime);\n    float b = sin(iTime);        \n \tfloat c = cos(3.27*iTime);\n    \n\tfragColor = vec4(pow(t,1.0 +0.3*a ),pow(t,1.0+0.3*b),pow(t,0.7+0.3*c),1.0);\n}\n\n                                                                                       ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 33, 33, 259], [262, 262, 294, 294, 636], [639, 639, 696, 696, 1142]], "test": "valid"}
{"id": "MlcSRn", "name": "Dux", "author": "dr2", "description": "Kwak, kwak", "tags": ["waves", "raymarch", "ducks"], "likes": 15, "viewed": 610, "published": "Public API", "date": "1477653661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Dux\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nconst float pi = 3.14159;\n\nvec3 qHit, sunDir;\nvec2 gId, gIdHit;\nfloat dstFar, tCur, dukHt, dukAyz, dukAxy;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  ro.xz += 0.5 * tCur;\n  f = Fbm2 (0.1 * (ro + rd * (50. - ro.y) / rd.y).xz);\n  return mix (vec3 (0.2, 0.3, 0.55) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     0.35 * pow (max (dot (rd, sunDir), 0.), 16.),\n     vec3 (0.85), clamp (0.8 * f * rd.y + 0.1, 0., 1.));\n}\n\nfloat WaveHt (vec2 p)\n{\n  vec2 u;\n  u = 0.1 * (vec2 (p.y * cos (0.2 * pi)) +\n     vec2 (p.x * sin (0.2 * pi)) * vec2 (-1., 1.));\n  u = mod (u + vec2 (-0.1, 0.053) * tCur, 1.) - 0.5;\n  u = exp (-100. * u * u);\n  return 0.5 + (u.x + u.y) / (3. + 0.05 * dot (p, p));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 50; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 8; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  float h;\n  h = WaveHt (p.xz);\n  return normalize (vec3 (h - WaveHt (p.xz + e.xy), e.x, h - WaveHt (p.xz + e.yx)));\n}\n\nfloat DukDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 r, cs;\n  float d, h, s;\n  q = p;\n  r = vec2 (0.04, 0.06 + 0.01 * clamp (q.z, -0.4, 0.4));\n  h = 0.1;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  if (d < dMin) { dMin = d;  idObj = idBdy;  qHit = q;  gIdHit = gId; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.1, 0.06, 0.12);\n  cs = vec2 (cos (0.3), sin (0.3));\n  q.yz = Rot2Cs (q.yz, cs);\n  cs.y = - cs.y;\n  q.xy = Rot2Cs (q.xy, cs);\n  q.xz = Rot2Cs (q.xz, cs);\n  q = q.yxz;\n  r = vec2 (0.06, 0.1 + 0.016 * clamp (q.z, -0.4, 0.4));\n  h = 0.014;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  d = SmoothMin (d, dMin, 0.01);\n  if (d < dMin) { dMin = d;  idObj = idWng;  qHit = q;  gIdHit = gId; }\n  q = p;\n  q.yz -= vec2 (0.15, -0.08);\n  d = PrEllipsDf (q, vec3 (0.08, 0.07, 0.1));\n  d = SmoothMin (d, dMin, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idHead;  qHit = q;  gIdHit = gId; }\n  q = p;\n  q.yz -= vec2 (0.14, -0.19);\n  r = vec2 (0.03, 0.008);\n  h = 0.02;\n  d = max (PrEllCylDf (q, r, h),\n      - PrEllCylDf (q - vec3 (0., 0., h), r - 0.004, 2. * h));\n  if (d < dMin) { dMin = d;  idObj = idBk;  qHit = q;  gIdHit = gId; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float bb = PrBox2Df (p.xz, vec2 (3.6));\n  p.xz -= gId;\n  p.y -= 0.05 + dukHt;\n  p.yz = Rot2D (p.yz, -3. * dukAyz);\n  p.xy = Rot2D (p.xy, 5. * dukAxy);\n  return max (DukDf (p, dstFar), bb);\n}\n\nvoid EvalDukPa ()\n{\n  vec2 e = vec2 (0.1, 0.);\n  dukHt = WaveHt (gId);\n  dukAyz = WaveHt (gId - e.yx) - WaveHt (gId + e.yx);\n  dukAxy = WaveHt (gId - e) - WaveHt (gId + e);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h, gIdP;\n  float dHit, d;\n  srd = - sign (rd.xz);\n  dda = - srd / (rd.xz + 0.0001);\n  gIdP = vec2 (-10.);\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    gId = floor (p.xz + 0.5);\n    if (abs (gId.x) <= 4. && abs (gId.y) <= 4.) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        EvalDukPa ();\n        gIdP = gId;\n      }\n      d = ObjDf (p);\n    } else d = dstFar;\n    dHit += min (d, 0.2 + max (0., min (h.x, h.y)));\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.05, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ObjCol ()\n{\n  vec3 col, cBdy;\n  float s;\n  cBdy = (mod (gIdHit.x, 2.) == mod (gIdHit.y, 2.)) ?\n     vec3 (1., 0., 0.) : vec3 (1., 1., 0.);\n  if (idObj == idBdy) {\n    col = cBdy * (1. - smoothstep (0.02, 0.06, qHit.y) *\n       smoothstep (0., 0.14, qHit.z) * 0.1 * SmoothBump (0.3, 0.5, 0.05,\n       mod (50. * qHit.x, 1.)));\n  } else if (idObj == idWng) {\n    col = cBdy * (1. - step (0.004, qHit.y) *\n       smoothstep (0., 0.04, qHit.z) * 0.2 * SmoothBump (0.3, 0.5, 0.05,\n       mod (100. * qHit.x, 1.)));\n  } else if (idObj == idHead) {\n    s = length (qHit.yz - vec2 (0.02, -0.05));\n    if (s > 0.02) col = cBdy;\n    else col = (abs (s - 0.01) < 0.003) ? vec3 (1., 1., 1.) : vec3 (0.3, 0.3, 1.);\n  } else if (idObj == idBk) col = vec3 (1., 0.5, 0.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colW, vn;\n  float dstObj, dstWat, sh;\n  bool waterRefl;\n  dstWat = WaveRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  waterRefl = (dstWat < min (dstFar, dstObj));\n  if (waterRefl) {\n    ro += rd * dstWat;\n    vn = WaveNf (ro);\n    vn = VaryNf (10. * ro, vn, 0.2);\n    colW = vec3 (0., 0.2, 0.3) * (0.4 + 0.6 * max (dot (vn, sunDir), 0.));\n    rd = reflect (rd, vn);\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    col = ObjCol ();\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    sh = ObjSShadow (ro, sunDir);\n    col = col * (0.4 + 0.6 * sh * max (dot (vn, sunDir), 0.)) +\n       0.1 * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n  } else col = SkyCol (ro, rd);\n  if (waterRefl) col = mix (colW, col, 0.3);\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  az = -0.03 * pi * tCur;\n  el = -0.15 * pi;\n  el = clamp (el, -0.45 * pi, -0.02 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -9.);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  dstFar = 20.;\n  sunDir = normalize (vec3 (1., 0.8, -0.8));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcSRn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 620, 652, 652, 928], [930, 930, 953, 953, 1195], [1197, 1197, 1231, 1231, 1748], [1750, 1750, 1772, 1772, 1919], [1921, 1921, 1955, 1955, 3207], [3209, 3209, 3231, 3231, 3424], [3426, 3426, 3445, 3445, 3600], [3602, 3602, 3635, 3635, 4254], [4256, 4256, 4277, 4277, 4499], [4501, 4501, 4538, 4538, 4778], [4780, 4780, 4796, 4796, 5556], [5558, 5558, 5593, 5593, 6401], [6403, 6403, 6459, 6459, 7104], [7106, 7106, 7139, 7139, 7228], [7230, 7230, 7265, 7265, 7327], [7329, 7329, 7373, 7373, 7448], [7450, 7450, 7495, 7495, 7598], [7600, 7600, 7657, 7657, 7740], [7742, 7742, 7772, 7772, 7830], [7832, 7832, 7863, 7863, 7927], [8050, 8050, 8074, 8074, 8121], [8123, 8123, 8148, 8148, 8347], [8349, 8349, 8370, 8370, 8509], [8511, 8511, 8540, 8540, 8752], [8754, 8754, 8793, 8793, 9016]], "test": "error"}
{"id": "MlcSzn", "name": "Abstract Plane Beauty", "author": "aiekick", "description": "Based on [url=https://www.shadertoy.com/view/Mt3GW2]Tunnel Beauty[/url]", "tags": ["sss", "abstract", "plane", "beauty"], "likes": 16, "viewed": 799, "published": "Public API", "date": "1477671370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec3 path(vec3 p)\n{\n\tp *= RotZ(p.z * 0.1);\n    p += sin(p.zxy * 0.5) * 0.5;\n\tp *= RotZ(p.z * 0.2);\n   \treturn sin(p.zxy * 0.2) * 2.;\n}\nfloat df(vec3 p)\n{\n\tp += path(p);\n\tp *= RotZ(p.z * 0.1);\n    return 1. - cos(p.z*1.5) * 0.1 - abs(p.y) + dot(texture(iChannel0, p.xz*0.2),vec4(0.05));\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 ro = vec3(0,0, iTime * 6.); ro -= path(ro);\n\tvec3 cv = ro + vec3(0,0,4); cv -= path(cv);\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(uv.x * x + uv.y * y + z);\n\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<30; i++) // 30 iterations yeah :)\n\t{\n\t\tif (log(d/1e6)>0.) break; // due to this special break condition\n\t\td += df(ro+rd*d);\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(ro-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.001);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(.8,.5,.2);\n    \n    // here the magix happens\n\tfloat sss = df(p - n*0.001)/0.01;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = blackbody(200. * sb);\t\t\t\t\t\t\t\t\t// blackbody color\n\tfloat sss2 = 0.8 - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\n\tvec3 a = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.35 + spe; // near\n    vec3 b = col * sss;\n    \n\tfragColor.rgb = mix(a, b, .8-exp(-0.01*d*d));\n}\n\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcSzn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 233, 233, 291], [293, 293, 312, 312, 427], [428, 428, 446, 446, 580], [582, 582, 616, 616, 816], [818, 1039, 1067, 1067, 1392], [1394, 1476, 1533, 1533, 1757], [1759, 1759, 1795, 1795, 1928], [1930, 1930, 1987, 1987, 3494]], "test": "error"}
{"id": "MlG3R3", "name": "fire particles - PSF+saturation", "author": "FabriceNeyret2", "description": "Accounting for blooming+saturation effect", "tags": ["psf", "sensor"], "likes": 29, "viewed": 1942, "published": "Public API", "date": "1475776075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \n// ->   pix=1 => r = I0^1/3 / dist^2/3\n// graph: see https://www.desmos.com/calculator/6m7cebockb\n// from star shader https://www.shadertoy.com/view/Xty3zc\n\n\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\n#define srnd(x) ( 2.* rnd(x) -1. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float r, t = iTime,t1,v;\n    vec2 R = iResolution.xy, P;\n    U =  (2.*U-R) / R.y;\n\n    O -= O;\n    \n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\n    for(float i=0.; i<3.*256.; i++) {\n       t1 = t + 6.28*rnd(i);\n        v = 2.+srnd(i+.7);\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \n        P = vec2(   cos(t1*v)*r ,          // particle location\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \n        r = length(P-U),\n\t    O += U.x<0. \n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\n    }\n    \n    O *= vec4(1,.5,.2,1);                  // color  \n    \n  //O += .3*texture(iChannel0,vec3(-U,-1));\n}", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlG3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 292, 330, 330, 1097]], "test": "valid"}
{"id": "MlG3zK", "name": "ANIMATION 1", "author": "Imsure1200q_1UWE130", "description": "Sketch [unfinished] But nice!\nT.keena Did U Read The LEtter?", "tags": ["raymarching", "realm"], "likes": 3, "viewed": 689, "published": "Public API", "date": "1475499541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-r;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nfloat blend (float a, float b, float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\nfloat scDir(float p, float s)\n{\n    vec3 x = vec3(p);\n    return length(cross(sin(x), cos(x))-cross(asin(x),acos(x)))-s;\n}\nfloat snDir(float p, float s)\n{\n    vec3 x = normalize(vec3(p));\n    vec2 y = vec2(p);\n    return scDir(length(x)-s, s);\n}\nfloat displacement(vec3 p)\n{\n    return sin(20.*p.x)*sin(20.*p.y)*sin(20.*p.z);\n}\nfloat opDisplace(vec3 p, float d1)\n{\n    float d2 = displacement(p);\n    return d1+d2;\n}\nvec2 blend(vec2 a, vec2 b, float k)\n{\n    return max(vec2(blend(a.x,b.x,k), a.y),vec2(blend(a.x,b.x,k), b.y));\n}\nfloat sdPlane2( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\nvec2 map( vec3 pos)\n{\n    float roundness = .15;\n  \tfloat rot = 1.;\n\tfloat k = .05;\n    float size = .5;\n    \n    float scale = 1. / ( 3. - clamp( pos.y, 1., 7. ) );\n    scale = 1.;\n    \n    vec2 x;\n    float h = 3.5;\n    vec3 p = vec3(pos.x, pos.y-1., pos.z);;\n    p = vec3(pos.x, pos.y, pos.z);\n    float d1;\n    float pl = sdPlane(p);\n    x = vec2(sdPlane2(p, normalize(vec4(-0.9, 1., 1., 1.6))),1.0);\n    p = vec3(pos.x, pos.y, pos.z);\n    p = vec3(pos.x, pos.y-0.8, pos.z);\n    d1 = sdBox(p, vec3(1.9, 0.1, 2.5));\n    x = blend(vec2(d1, 1.1),x,0.1);\n    p = vec3(pos.x, pos.y-0.4, pos.z+9.5);\n    d1 = sdSphere(p, 5.);\n    x = blend(vec2(d1, 1.2),x,2.);\n    p = vec3(pos.x-12.125, pos.y+1.5, pos.z+3.);\n    d1 = sdSphere(p, 9.);\n    x = blend(vec2(d1, 1.2),x,2.);\n    p = vec3(pos.x, pos.y-0.8, pos.z);\n    d1 = sdBox(p, vec3(0.475, clamp(pos.y,-0.6,3.7), 0.625));\n    d1 = opU(vec2(opDisplace(p, d1)),vec2(d1)).x;\n    x = blend(vec2(d1, 0.9),x,0.1);\n    p = vec3(pos.x, pos.y+1.5, pos.z);\n    d1 = sdCappedCone(p, vec3(-3., 0.1, 0.0));\n    //x = blend(vec2(d1, 1.2),x,2.);\n    return x;\n    \n}\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m==1.0 )\n        {\n            \n            float f = 1.;\n            col = 0.4 + 0.1*f*vec3(1.0)+texture(iChannel0, vec2(pos.x,pos.z)).rgb-vec3(1.0,0.0,1.0);\n        }\n        else if( m==1.1 )\n        {\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0)+texture(iChannel1, vec2(pos.x,pos.z)).rgb;\n        }\n        else if( m==1.2 )\n        {\n            col = 0.4*0.1*vec3(1.)+texture(iChannel1, vec2(pos.x,pos.z)).rgb+vec3(1.);\n        }\n        else if( m==0.9)\n        {\n            col = 0.4+0.1*vec3(1.)+texture(iChannel2, vec2(nor.x,nor.z)).rgb;\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 5.*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y+5.,5.*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 2., 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, sin(0.5*time + 6.0*mo.x) );\n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    if(normalize(rd)==vec3(.9))\n    {\n        rd=vec3(0.);\n    }\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlG3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 40], [41, 41, 86, 86, 175], [176, 176, 212, 212, 296], [297, 297, 332, 332, 358], [359, 359, 387, 387, 473], [474, 474, 507, 507, 572], [573, 573, 597, 597, 729], [730, 730, 771, 771, 858], [859, 859, 890, 890, 977], [979, 979, 1009, 1009, 1042], [1043, 1043, 1073, 1073, 1102], [1103, 1103, 1134, 1134, 1225], [1226, 1226, 1257, 1257, 1348], [1349, 1349, 1377, 1377, 1430], [1431, 1431, 1467, 1467, 1519], [1520, 1520, 1557, 1557, 1632], [1633, 1633, 1667, 1693, 1724], [1725, 1725, 1769, 1769, 2062], [2063, 2063, 2084, 2084, 3162], [3163, 3163, 3203, 3203, 3793], [3794, 3794, 3868, 3868, 4129], [4131, 4131, 4163, 4163, 4383], [4384, 4384, 4426, 4426, 4725], [4727, 4727, 4766, 4766, 6809], [6811, 6811, 6863, 6863, 7040], [7042, 7042, 7099, 7099, 7757]], "test": "error"}
{"id": "MlGGDK", "name": "Reactive Voronoi (T-Remix) ", "author": "TimoKinnunen", "description": "Reactive Voronoi by glk7 remixed. \nWhat's new: softer shadows, color phase modulation by music, simple beat detection, grid-hack, lighting tweaks. \nThe track is Neptune Project - John O'Callaghan vs Neptune Project - Rhea.", "tags": ["3d", "voronoi", "raymarch", "visualization", "reactive", "shadows", "palette", "trance"], "likes": 11, "viewed": 960, "published": "Public API", "date": "1476747141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float PI = 3.1416;\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n                          dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// From http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n\n// Modified version of the above iq's voronoi borders. \n// Returns the distance to the border in a given direction.\nvec3 voronoi( in vec2 x, in vec2 dir)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 1e5;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n    \n \t\tif( dot(r-mr,r-mr) > 1e-5 ) {\n            \n            vec2 f = r-mr;\n            \n            if (dot(dir, f) > 1e-5) {\n            \tvec2 m = 0.5*(mr+r);\n   \t \t\t\tfloat c = m.x*(m.y + f.x) - m.y*(m.x - f.y);\n            \tfloat d = 1.0 / dot(dir, f);\n                \n            \tmd = min(md, dot(dir, dir*c*d));\n            }\n        }\n        \n    }\n    \n    return vec3( md, n+mg);\n}\nfloat gridWidth = 1.25;\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, \n               out vec3 p0, out vec3 p1) \n{\n    vec3 orig = .5*bmin+.5*bmax+vec3(iTime*2.5,0,0);\n    vec2 grid = (bmax.xz-bmin.xz)*gridWidth;\n    vec3 plane = (orig.y-ro.y)*invrd.y*rd+ro;\n    vec2 cell = floor((plane.xz+orig.xz)/grid+0.5);\n    vec2 srcCell = floor((ro.xz+orig.xz)/grid+0.5);\n    //vec2 m = cell*0.1;\n    //mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    //mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    bmin.xz+=cell*grid-vec2(iTime*2.5,0);\n    bmax.xz+=cell*grid-vec2(iTime*2.5,0);\n    //bmin.y+= floor(distance(cell,srcCell));\n    //bmax.y+= floor(distance(cell,srcCell));\n    \n    //bmin.yzx*=rotY;\n    //bmax.yzx*=rotY;\n    //bmin.zyx*=rotX;\n    //bmax.zyx*=rotX;\n\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n \n    //p0.y-= floor(distance(cell,srcCell));\n    //p1.y-= floor(distance(cell,srcCell));\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    vec3 n1 = -(1.0 - smoothstep(0.0, 0.03, p - bmin));\n    vec3 n2 = (1.0 -  smoothstep(0.0, 0.03, bmax - p));\n    \n    return normalize(n1 + n2);\n}\n\nconst vec3 background = vec3(0.04);\nconst vec3 scmin = vec3(-2.0, -0.5, -2.0);\nconst vec3 scmax = vec3(+2.0, +1.5, +2.0);\n\nvec3 frequency = vec3(1.0,0.7,0.4);\n// From http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+frequency*mod(t,10.0)+d) );\n}\nvec4 max2(float a, vec4 b){return max(vec4(a),b);}\nvec4 sound(vec2 v) {\n    vec4 bass = max2(0.02,log2(.5+texture(iChannel0, vec2(1./iChannelResolution[0].x,0))));\n    vec4 treble = max2(0.02,texture(iChannel0, vec2(hash2(v).x, 0.0))*2.0-1.0);\n    return treble+bass;\n}\nvec3 color(vec2 p) {\n    //const float varia = 0.02;\n    const float varia = 0.3;\n    return pal(2.+iTime/3.434+hash2(p).x*varia, \n               vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20)+(sound(p).x-0.5)*2.0  );\n}\n\nfloat disp(vec3 v) {\n    return (0.0*smoothstep(0.05,0.08,v.x)+1.0)*(scmin.y + 0.5* (0.1 + hash2(v.yz).x * 0.5 + sound(v.yz).r*2.0));\n}\nvec4  saturate(vec4  a) { return clamp(a, 0.0, 1.0); }\nvec3  saturate(vec3  a) { return clamp(a, 0.0, 1.0); }\nvec2  saturate(vec2  a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec4 doMap(vec3 voro) {\n    vec3 v = voro*0.5;\n    float height = 0.1+0.9*disp(v);\n    //v.x=(-0.05+v.x);\n    return vec4(v, height);\n}\nvec4 map(in vec2 p, in vec2 dir) {\n    return doMap(voronoi(p*2.0, dir));\n}\nvec4 map(in vec2 p) {\n    return doMap(voronoi(p*2.0));\n}\n\nfloat wrappedDiffuse(vec3 N, vec3 L, float w, float n) {\n\treturn pow(saturate((dot(N, L)+ w)/ (1.0+ w)), n)* (1.0+ n)/ (2.0* (1.0+ w));\n}\nfloat ShadowFactor(in vec3 ro, in vec3 rd) {\n\tvec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    \n    IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1);\n    vec2 dir = normalize(rd.xz);\n    float rs = map(ro.xz, dir).x;\n    p0 = ro + rd*0.02;\n    \n    float sf = rd.y / length(rd.xz);\n\n    float m = -1e5;\n    \n    vec4 v;\n    const int max_steps = 32;\n    for (int i = max_steps; i > 0; --i) {\n        \n        if (dot((p1 - p0), rd) < 0.0) return 1.0;\n  \n        v = map(p0.xz, dir);\n        \n        m = v.w;\n        if (p0.y < m) break;// return 0.0;\n        \n        p0 += rd*(length(vec2(v.x, v.x*sf)) + 0.01);\n    }\n    vec3 i1 = vec3(1,0,0);\n    vec3 i2 = vec3(0,1,0);\n    vec3 j1 = (p1 - p0);\n    return (1.0-smoothstep(1.5,0.1,v.x));\n    \n}\n\nvec3 Shade(in vec3 p, in vec3 n, in vec3 ld, in vec2 c) {\n    vec3 col = color(c);\n\treturn col *\n        (\n        0.15 + \n        (0.85+0.95*wrappedDiffuse(n,ld,1.,35.0)) * \n        (0.05+0.95*smoothstep(0.0,0.5,(p.y-scmin.y)/(scmax.y-scmin.y))) * \n        (0.25+0.75*ShadowFactor(p, ld)) * \n        0.85\n    )\n       // * 3.5\n        ;\n}\n\nvec3 Render(in vec3 ro, in vec3 rd, in vec3 ld) {\n    vec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    \n    if (!IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1)) return background;\n    \n    vec2 dir = normalize(rd.xz);\n    float sf = rd.y / length(rd.xz);\n    \n    vec2 lvp = vec2(0);\n    vec2 vp = p0.xz;\n    \n    float m = -1e5;\n    \n    const int max_steps = 32;\n    for (int i = max_steps; i > 0; --i) {\n        if (p0.y < m) {\n            p0 += rd * (-p0.y + m)/rd.y;\n            if (dot((p1 - p0), rd) < 0.0) return background;\n            break;\n        }\n        \n        if (dot((p1 - p0), rd) < 0.0) return background;\n  \n        vec4 v = map(p0.xz, dir);\n\t\t\n        lvp = vp;\n        vp = v.yz;\n        \n        m = v.w;\n        if (p0.y < m) break;\n        \n        p0 += rd*(length(vec2(v.x, v.x*sf)) + 0.01);\n    }\n    \n   \n    vec2 eps = vec2(0,.1);\n    vec4 voro00 = map(p0.xz);\n    vec4 voro01 = map(p0.xz+eps.yx);\n    vec4 voro10 = map(p0.xz+eps);\n    float dist = voro00.x;\n    float p2x = voro01.x;\n    float p2y = voro10.x;\n    \n    vec2 side = normalize(vec2(p2x,p2y)-dist);\n    dist=clamp(dist*10.0,0.0,1.0);\n    vec3 sideN = vec3((1.0-dist)*side, dist).xzy;\n    vec3 n = normalize(sideN);\n    if (all(equal(p0.xz, lvp))) {\n        n = AABoxNormal(scmin, scmax, p0); \n    }\n    vec3 col = Shade(p0, n, ld, vp);\n    return col;\n}\nmat3 fromEuler(vec3 ang) {\n#ifdef EULER_2\n\tvec3 s = sin(ang);\n\tvec3 c = cos(ang);\n\tmat3 m = mat3(\n\tc.x* c.z+ s.x* s.y* s.z,c.x* s.y* s.z+ c.z* s.x,-c.y* s.z,\n\t-c.y* s.x,c.x* c.y,s.y,\n\tc.z* s.x* s.y+ c.x* s.z,s.x* s.z- c.x* c.z* s.y,c.y* c.z);\n\treturn m;\n#else\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n\tvec2 a2 = vec2(sin(ang.y),cos(ang.y));\n\tvec2 a3 = vec2(sin(ang.z),cos(ang.z));\n\tmat3 m;\n\tm[0] = vec3(a1.y* a3.y+ a1.x* a2.x* a3.x,a1.y* a2.x* a3.x+ a3.y* a1.x,-a2.y* a3.x);\n\tm[1] = vec3(-a2.y* a1.x,a1.y* a2.y,a2.x);\n\tm[2] = vec3(a3.y* a1.x* a2.x+ a1.y* a3.x,a1.x* a3.x- a1.y* a3.y* a2.x,a2.y* a3.y);\n\treturn m;\n#endif\n}\nfloat rotating = 0.0;\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, \n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, 0.0, -d);\n    \n    vec2 iM = vec2(iTime*5.0+mod(iTime,10.0)*rotating,iResolution.y*.8);\n    float ff = min(1.0, step(0.001, iM.x) + step(0.001, iM.y));\n    vec2 m = PI*ff + vec2(((iM.xy + 0.1) / iResolution.xy) * (PI*2.0));\n    m.y = -m.y;\n    m.y = sin(m.y*0.5)*0.6 + 0.6;\n        \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    t = rotY * rotX;\n    \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    \n    rd = normalize(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro;\n    vec3 rd;\n    mat3 t = mat3(1.0);\n    float dur = 5.0;\n    float segment = mod(floor(iTime/dur*2.5),12.0);\n    float segs = mod(iTime,dur)/dur*5.0;\n    float swapA = smoothstep(0.0,1.0,-0.5+segs);\n    float swapB = smoothstep(0.0,1.0,-2.0+segs);\n    float swapC = smoothstep(0.0,1.0,-3.5+segs);\n\n    float row0 = step(fragCoord.y,iResolution.y/4.0);\n    float row3 = step(iResolution.y*3.0/4.0,fragCoord.y);\n    float col3 = step(iResolution.x*3.0/4.0,fragCoord.x);\n    float col7 = step(iResolution.x*7.0/8.0,fragCoord.x);\n    float col6 = col3-col7;\n    float seg0 = float(segment==0.0);\n    float seg1 = float(segment==1.0);\n    float seg2 = float(segment==2.0);\n    float seg4 = float(segment==4.0);\n    float seg5 = float(segment==5.0);\n    float seg7 = float(segment==7.0);\n    float seg9 = float(segment==9.0);\n    float seg11 = float(segment==11.0);\n    float t1 = seg2*swapB+seg7*swapB+seg11*swapB;\n    float t2 = seg4*swapB+seg9*swapB;\n    float t3 = float(mod(segment+0.0,3.0)==0.0)*swapA;\n    float t4 = seg0*swapB+seg1+seg5*swapB+seg9*swapC;\n    float t5 = seg0*swapC+seg1+seg5*swapB+seg9*swapC;\n\n    vec2 frag = mod(fragCoord,iResolution.xy/(1.0+3.0*t1));\n    frag.x = mod(frag.x+iResolution.x/(1.0-0.5*t2),iResolution.x/(1.0+3.0*t2));\n    frag.x = mix(frag.x, mod(frag.x, iResolution.x/8.0), col3*t3);\n    frag.y = mix(frag.y, iResolution.y*3.0/4.0+mod(frag.y-iResolution.y*2.0*t4*seg9, iResolution.y/4.0), row3*t4);\n    frag.y = mix(frag.y, mod(frag.y-iResolution.y*7.0/4.0*t5*seg9, iResolution.y/4.0), row0*t5);\n    \n    float zooming = 1.0;\n    float near = 7.0;\n    float far = 7.0;\n    float turner = 0.0;\n    frequency = vec3(vec2(1.0,0.7)*floor(fragCoord/(iResolution.xy/(1.0+3.0*t1)))*0.25*t1,0.4)*t1;\n    frequency = mix(frequency, vec3(0.4,1.0,0.7), fragCoord.y/iResolution.y*col3*t3);\n    gridWidth = mix(gridWidth,0.25,step(0.1,t1+col3*t3));\n    near = mix(near, near+20.0, floor(fragCoord.x/(iResolution.x/(1.0+3.0*t1)))*0.25*t1);\n    zooming = mix(zooming, zooming*0.25, row3*t4);\n    zooming = mix(zooming, zooming*0.25, row0*t5);\n    zooming = mix(zooming, zooming*8.0*(1.5*col6+col7), col3*t3);\n    zooming = mix(zooming, zooming*0.1, floor(fragCoord.y/(iResolution.y/(1.0+3.0*t1)))*0.25*t1);\n    near = mix(near, near+3.0, row3*t4);\n    near = mix(near, near+180.0*col6+280.0*col7, col3*t3);\n    near = mix(near, near+8.0, row0*t5);\n    rotating = mix(rotating, -15.0, col3*t3);\n    turner = mix(turner, 0.25, (1.0-floor(fragCoord.y/(iResolution.y/(1.0+3.0*t1)))*0.25)*t2);\n    \n    float borders = float(frag.x>=5.0&&frag.x<iResolution.x-5.0&&frag.y>=5.0&&frag.y<iResolution.y-5.0);//sign(1.0-dot(vec2(1),step(frag,vec2(5))+step(iResolution.xy-5.0,frag))));\n    borders *= mix(1.0,clamp(abs(iResolution.y/4.0-frag.y)-2.5,0.0,1.0),t5);\n    borders *= mix(1.0,clamp(abs(iResolution.y*3.0/4.0-frag.y)-2.5,0.0,1.0),t4);\n    borders *= mix(1.0,clamp(abs(iResolution.x*3.0/4.0-fragCoord.x)-2.5,0.0,1.0),t3);\n    borders *= mix(1.0,clamp(abs(iResolution.x*3.0/4.0-frag.x)-2.5,0.0,1.0),t2);\n    borders *= mix(1.0,clamp(abs(iResolution.x*2.0/4.0-frag.x)-2.5,0.0,1.0),t2);\n    borders *= mix(1.0,clamp(abs(iResolution.x*1.0/4.0-frag.x)-2.5,0.0,1.0),t2);\n    float circling = segment*10.0*0.5+segs*(0.5+turner);\n    CameraOrbitRay(frag, zooming, vec3(0.0), near+far*(1.0+cos(circling)), ro, rd, t);\n    vec3 ld = normalize(vec3(4,4,-1)*fromEuler(vec3(0,0,5)*circling-4.0*turner));\n\tfragColor = vec4(pow(mix(background,Render(ro, rd, ld),borders), vec3(0.5454)), 1.0);\n}", "image_inputs": [{"id": "XdB3D1", "previewfilepath": "https://soundcloud.com/neptune-project/neptune-project-feat-polly", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/neptune-project/neptune-project-feat-polly", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGGDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 143, 165, 196, 313], [315, 392, 419, 419, 1517], [1520, 1636, 1675, 1675, 2870], [2895, 2895, 3021, 3021, 4151], [4153, 4153, 4202, 4202, 4352], [4513, 4578, 4646, 4646, 4711], [4712, 4712, 4739, 4739, 4762], [4763, 4763, 4783, 4783, 4981], [4982, 4982, 5002, 5034, 5228], [5230, 5230, 5250, 5250, 5365], [5366, 5366, 5391, 5391, 5420], [5421, 5421, 5446, 5446, 5475], [5476, 5476, 5501, 5501, 5530], [5531, 5531, 5556, 5556, 5585], [5587, 5587, 5610, 5610, 5722], [5723, 5723, 5757, 5757, 5798], [5799, 5799, 5820, 5820, 5856], [5858, 5858, 5914, 5914, 5995], [5996, 5996, 6040, 6040, 6743], [6745, 6745, 6802, 6802, 7084], [7086, 7086, 7135, 7135, 8438], [8439, 8439, 8465, 8465, 9059], [9082, 9082, 9217, 9217, 9929], [9931, 9931, 9988, 9988, 13498]], "test": "error"}
{"id": "MlGGDt", "name": "Magic Circle", "author": "Ark", "description": "Magic Circle", "tags": ["magiccircle"], "likes": 38, "viewed": 1226, "published": "Public", "date": "1477408959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec2 rotate(vec2 p, float rad) {\n    mat2 m = mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n    return m * p;\n}\n\nvec2 translate(vec2 p, vec2 diff) {\n    return p - diff;\n}\n\nvec2 scale(vec2 p, float r) {\n    return p*r;\n}\n\nfloat circle(float pre, vec2 p, float r1, float r2, float power) {\n    float leng = length(p);\n    float d = min(abs(leng-r1), abs(leng-r2));\n    if (r1<leng && leng<r2) pre /= exp(d)/r2;\n    float res = power / d;\n    return clamp(pre + res, 0.0, 1.0);\n}\n\nfloat rectangle(float pre, vec2 p, vec2 half1, vec2 half2, float power) {\n    p = abs(p);\n    if ((half1.x<p.x || half1.y<p.y) && (p.x<half2.x && p.y<half2.y)) {\n        pre = max(0.01, pre);\n    }\n    float dx1 = (p.y < half1.y) ? abs(half1.x-p.x) : length(p-half1);\n    float dx2 = (p.y < half2.y) ? abs(half2.x-p.x) : length(p-half2);\n    float dy1 = (p.x < half1.x) ? abs(half1.y-p.y) : length(p-half1);\n    float dy2 = (p.x < half2.x) ? abs(half2.y-p.y) : length(p-half2);\n    float d = min(min(dx1, dx2), min(dy1, dy2));\n    float res = power / d;\n    return clamp(pre + res, 0.0, 1.0);\n}\n\nfloat radiation(float pre, vec2 p, float r1, float r2, int num, float power) {\n    float angle = 2.0*PI/float(num);\n    float d = 1e10;\n    for(int i=0; i<360; i++) {\n        if (i>=num) break;\n        float _d = (r1<p.y && p.y<r2) ? \n            abs(p.x) : \n        \tmin(length(p-vec2(0.0, r1)), length(p-vec2(0.0, r2)));\n        d = min(d, _d);\n        p = rotate(p, angle);\n    }\n    float res = power / d;\n    return clamp(pre + res, 0.0, 1.0);\n}\n\nvec3 calc(vec2 p) {\n    float dst = 0.0;\n    p = scale(p, sin(PI*iTime/1.0)*0.02+1.1);\n    {\n        vec2 q = p;\n        q = rotate(q, iTime * PI / 6.0);\n        dst = circle(dst, q, 0.85, 0.9, 0.006);\n        dst = radiation(dst, q, 0.87, 0.88, 36, 0.0008);\n    }\n    {\n        vec2 q = p;\n        q = rotate(q, iTime * PI / 6.0);\n        const int n = 6;\n        float angle = PI / float(n);\n        q = rotate(q, floor(atan(q.x, q.y)/angle + 0.5) * angle);\n        for(int i=0; i<n; i++) {\n            dst = rectangle(dst, q, vec2(0.85/sqrt(2.0)), vec2(0.85/sqrt(2.0)), 0.0015);\n            q = rotate(q, angle);\n        }\n    }\n    {\n        vec2 q = p;\n        q = rotate(q, iTime * PI / 6.0);\n        const int n = 12;\n        q = rotate(q, 2.0*PI/float(n)/2.0);\n        float angle = 2.0*PI / float(n);\n        for(int i=0; i<n; i++) {\n            dst = circle(dst, q-vec2(0.0, 0.875), 0.001, 0.05, 0.004);\n            dst = circle(dst, q-vec2(0.0, 0.875), 0.001, 0.001, 0.008);\n            q = rotate(q, angle);\n        }\n    }\n    {\n        vec2 q = p;\n        dst = circle(dst, q, 0.5, 0.55, 0.002);\n    }\n    {\n        vec2 q = p;\n        q = rotate(q, -iTime * PI / 6.0);\n        const int n = 3;\n        float angle = PI / float(n);\n        q = rotate(q, floor(atan(q.x, q.y)/angle + 0.5) * angle);\n        for(int i=0; i<n; i++) {\n            dst = rectangle(dst, q, vec2(0.36, 0.36), vec2(0.36, 0.36), 0.0015);\n            q = rotate(q, angle);\n        }\n    }\n    {\n        vec2 q = p;\n        q = rotate(q, -iTime * PI / 6.0);\n        const int n = 12;\n        q = rotate(q, 2.0*PI/float(n)/2.0);\n        float angle = 2.0*PI / float(n);\n        for(int i=0; i<n; i++) {\n            dst = circle(dst, q-vec2(0.0, 0.53), 0.001, 0.035, 0.004);\n            dst = circle(dst, q-vec2(0.0, 0.53), 0.001, 0.001, 0.001);\n            q = rotate(q, angle);\n        }\n    }\n    {\n        vec2 q = p;\n        q = rotate(q, iTime * PI / 6.0);\n        dst = radiation(dst, q, 0.25, 0.3, 12, 0.005);\n    }\n    {\n        vec2 q = p;\n    \tq = scale(q, sin(PI*iTime/1.0)*0.04+1.1);\n        q = rotate(q, -iTime * PI / 6.0);\n        for(float i=0.0; i<6.0; i++) {\n            float r = 0.13-i*0.01;\n            q = translate(q, vec2(0.1, 0.0));\n        \tdst = circle(dst, q, r, r, 0.002);\n        \tq = translate(q, -vec2(0.1, 0.0));\n        \tq = rotate(q, -iTime * PI / 12.0);\n        }\n        dst = circle(dst, q, 0.04, 0.04, 0.004);\n    }\n    return pow(dst, 2.5) * vec3(1.0, 0.95, 0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (iResolution.xy - fragCoord.xy*2.0) / min(iResolution.x, iResolution.y);\n\tfragColor = vec4(calc(uv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 58, 58, 138], [140, 140, 175, 175, 198], [200, 200, 229, 229, 247], [249, 249, 315, 315, 504], [506, 506, 579, 579, 1100], [1102, 1102, 1180, 1180, 1552], [1554, 1554, 1573, 1573, 4044], [4046, 4046, 4103, 4103, 4223]], "test": "valid"}
{"id": "MlGGRV", "name": "Accurate sierpinski triangle WIP", "author": "deadmanswitch", "description": "I use this tetrahedron formula, to generate the fractal: https://www.shadertoy.com/view/ltVGzy\n\nThere is no need to decrease your step during raymarching", "tags": ["raymarch", "triangle", "wip", "sierpinski", "accurate"], "likes": 3, "viewed": 247, "published": "Public", "date": "1475509465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tetrahedron: https://www.shadertoy.com/view/ltVGzy\n\n#define FOV 60.0\n\n#define MAX_STEP   32\n#define MAX_STEP_F 32.0\n\n// constants\nconst float infinity = 1.0/0.000000001;\nconst float PI = asin(1.0)*2.0;\n\n\n// min/max vec\nfloat max4(in vec4 v4) {\n    return max( max(v4.x, v4.y), max(v4.z, v4.w) );\n}\n\nfloat min4(in vec4 v4) {\n    return min( min(v4.x, v4.y), min(v4.z, v4.w) );\n}\n\n// rotations\nvec3 rotateX(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0],\n        vec[1]*cos(rad) - vec[2]*sin(rad),\n        vec[1]*sin(rad) + vec[2]*cos(rad)\n    );\n        \n}\n\nvec3 rotateY(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[2]*sin(rad) + vec[0]*cos(rad),\n        vec[1],\n        vec[2]*cos(rad) - vec[0]*sin(rad)\n    );\n}\n\nvec3 rotateZ(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0]*cos(rad) - vec[1]*sin(rad),\n        vec[0]*sin(rad) + vec[1]*cos(rad),\n        vec[2]\n    );\n}\n\n// return the vector closest to `p`\nvec3 closestTo(in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    \n    vec4 ll = vec4(\n    \tdistance(a,p),\n        distance(b,p),\n        distance(c,p),\n        distance(d,p)\n    );\n    \n    float sh = min4(ll);\n    \n    vec4 eq = vec4(equal(ll, vec4(sh)));\n    \n    //return mix(a, mix( b, mix(c, d, eq.z ), eq.y ), eq.x ); !! with notEqual\n    return eq.x*a + eq.y*b + eq.z*c + eq.w*d;\n    \n}\n\n\n/***************\n\nTetrahedron start\n\n***************/\n\n// normals\nconst vec3 norm1 = vec3(\n\t0.4714045226573944,\n    0.3333333432674408,\n    -0.8164966106414795\n);\nconst vec3 norm2 = vec3(\n\t-0.9428090453147888,\n    0.3333333432674408,\n    0.0\n);\nconst vec3 norm3 = vec3(\n\t0.4714045524597168,\n    0.3333333432674408,\n    0.8164966106414795\n);\n\n// points\nconst vec3 point0 = vec3( 0.0,                 1.0,                 0.0);\nconst vec3 point1 = vec3( 0.9428090453147888, -0.3333333432674408,  0.0);\nconst vec3 point2 = vec3(-0.4714045226573944, -0.3333333432674408, -0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944, -0.3333333432674408,  0.8164966106414795);\n\nfloat planedist(in vec3 point, in vec3 norm) {\n\n    return dot(point, norm) - norm.y;\n\n}\n\nfloat tet(in vec3 point, in float size) {\n    \n    point = point/size;\n\n    // subtracting the planes from a sphere\n    float dist = max4(vec4(\n        planedist(point, norm1),\n        planedist(point, norm2),\n        planedist(point, norm3),\n        -(1.0/3.0+point.y)\n    ));\n\n    // the sphere has a `size` radius\n    dist = max(length(point)-1.0, dist)*size;\n\n    return dist;\n    \n}\n\n/***************\n\nTetrahedron end\n\n***************/\n\n// the distance estimator function\nconst int STEPS = 8;\nfloat DE(in vec3 pos) {\n    \n    // rotation\n    float rot = (iTime*0.25)*PI*2.0;\n    pos = rotateY(pos, rot);\n    \n    // steps\n    vec3 p = pos;\n    for(int i=0; i<STEPS; i++) {\n        \n        // scale the current point, and find the closest point vertex\n        p *= 2.0;\n        p = p-closestTo(p, point0, point1, point2, point3);\n        \n    }\n    \n    // calculate the distance to the last found tetrahedron ( for STEPS=0 -> tet(pos, 1.0) )\n    return tet(p, 1.0)/exp2(float(STEPS));\n    \n}\n\nconst vec3 shadowColor = vec3(0.1, 0.05, 0.0);\nconst vec3 backColor = vec3(0.2, 0.25, 0.2);\nconst vec3 tetColor = vec3(0.2, 0.75, 0.95);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 1.5+sin(iTime)*1.5);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\n        vec3 pos = point;\n\n        float dist = DE(pos);\n\n        if(dist < 0.0025) {\n            fragColor = vec4(mix(\n                tetColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            return;\n        }\n\n        closest = min(closest, dist);\n\n        point += dir*dist;\n\n    }\n\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/0.5, 0.0, 1.0))\n    ), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 222, 246, 246, 300], [302, 302, 326, 326, 380], [382, 395, 436, 436, 577], [579, 579, 620, 620, 752], [754, 754, 795, 795, 927], [929, 965, 1036, 1036, 1369], [1714, 2051, 2097, 2097, 2139], [2141, 2141, 2182, 2182, 2528], [2583, 2639, 2662, 2683, 3138], [3278, 3278, 3335, 3354, 4263]], "test": "error"}
{"id": "MlGGW3", "name": "Velvet Tunnel", "author": "aiekick", "description": "Velvet Tunnel", "tags": ["tunnel", "velvet"], "likes": 2, "viewed": 490, "published": "Public API", "date": "1477046852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nmat3 mat;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.08), sin(t*0.08)) * 4.;\n}\n\nfloat pattern(vec3 p)\n{\n\tp = abs(fract(p*.3) - 0.5);\n\treturn length(p);\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\n    float d = min(pattern(p*mat), pattern(p*mat*mat)) / .9;\n    vec3 col = vec3(1)-clamp(d,0.,1.);\n   \tfloat dist = dot(col,vec3(1));\n\treturn vec4(5. - length(p.xy) - dist*.5, vec3(0));\n}\n\nvec3 nor( vec3 pos, float k )\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n    mat = mx * my * mz;\n    \n    float time = iTime * 8.;\n    \n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,time + .1); //Change camere view here\n\tcamView.xy += path(camView.z);\n    \n  \tvec2 uv = (g+g-si)/si.y;\n    \n    vec3 ro = vec3(0,0,time);\n\tro.xy += path(ro.z);\n    \n    vec3 ld = normalize(vec3(path(ro.z + 1.),ro.z + 0.) - ro);\n    \n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float s = 1.;\n    float d = 0.;\n    for(int i=0;i<60;i++)\n    {      \n        if (log(d*d/s/1e5)>0.) break;\n        d += s = map(ro+rd*d).x * 0.5;\n    }\n\t\n    vec3 p = ro+rd*d;\n    vec3 n = nor(p, 0.1);\n        \n    float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n    float dif = clamp( dot( n, ld ), 0.0, 1.0 );\n    float spe = pow(clamp( dot( n, ld ), 0.0, 1.0 ),16.0);\n    float spe2 = pow(clamp( dot( n, -ld ), 0.0, 1.0 ),16.0);\n        \n\tf = vec4(0.8,0.5,0.2,1)*(amb + spe + spe2) + dif * map(p-n*3.);\n\n    f = mix( f, vec4(0.8,0.9,1,1), 1.0-exp( -0.0005*d*d ) );\n        \n   \tfragColor = f;\n}\n", "image_inputs": [{"id": "4sX3zn", "previewfilepath": "/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGGW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 139, 164, 164, 222], [223, 223, 248, 248, 306], [307, 307, 332, 332, 390], [403, 403, 423, 423, 470], [472, 472, 495, 495, 545], [547, 547, 565, 565, 773], [775, 775, 806, 806, 1021], [1023, 1023, 1080, 1080, 2388]], "test": "valid"}
{"id": "MlGGz3", "name": "transforming ellipses", "author": "mattz", "description": "The result of mapping an ellipse through a homography (2D perspective warp) is generally another ellipse. Note the center of the new ellipse (dark red) is not the same as the transformed center (green).", "tags": ["ellipse", "perspective", "homography"], "likes": 38, "viewed": 13749, "published": "Public API", "date": "1475874012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* transforming ellipses, by mattz.\n   License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Demonstrates how to map an ellipse through a homography (2D perspective transform).\n   Implements math from https://en.wikipedia.org/wiki/Ellipse\n\n*/\n\n\n\n\n// Construct a 3x3 matrix for a 2D rotation \nmat3 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(c, s, 0.0,\n                -s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Construct a 3x3 matrix for a 2D axis-aligned scale\nmat3 scale(vec2 s) {\n    return mat3(s.x, 0.0, 0.0,\n                0.0, s.y, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Construct a 3x3 matrix for a 2D perspective distortion\nmat3 distort(vec2 k) {\n    return mat3(1.0, 0.0, k.x,\n                0.0, 1.0, k.y,\n                0.0, 0.0, 1.0);\n                \n}\n\n// Construct a 3x3 matrix for a 2D translation\nmat3 translate(vec2 t) {\n    return mat3(1.0, 0.0, 0.0,\n                0.0, 1.0, 0.0,\n                t.x, t.y, 1.0);\n}\n\n// Warp a point thru a homography \nvec2 warp(mat3 H, vec2 p) {\n    vec3 Hp = H * vec3(p, 1.0);\n    return Hp.xy / Hp.z;\n}\n\n\n// Convert matrix form of implicit conic parameters to canonical parameters:\n// center, semimajor/semiminor axis lengths, and principal axis direction.\nvoid gparams_from_conic(in mat3 M,\n                        out vec2 ctr,\n                       \tout vec2 ab, \n                       \tout vec2 axis) {\n    \n    float A = M[0][0];\n    float B = M[0][1]*2.0;\n    float C = M[1][1];\n    float D = M[0][2]*2.0;\n    float E = M[1][2]*2.0;\n    float F = M[2][2];\n    \n    float T = B*B - 4.0*A*C;\n    float S = A*E*E + B*B*F + C*D*D - B*D*E - 4.0*A*C*F;\n    float U = sqrt((A-C)*(A-C) + B*B);\n    \n    ab = sqrt(vec2(2.0*S*(A+C+U), 2.0*S*(A+C-U)))/T;\n    ctr = vec2(2.0*C*D - B*E, 2.0*A*E - B*D)/T;\n    axis = normalize(vec2(B, C-A-U));\n       \n}\n\n// Convert the other way from above function.\nmat3 conic_from_gparams(vec2 ctr,\n                        vec2 ab,\n                        vec2 axis) {\n    \n    float a = ab.x;\n    float b = ab.y;\n    float c = axis.x;\n    float s = axis.y;\n    float xc = ctr.x;\n    float yc = ctr.y;\n    \n    float A = a*a*s*s + b*b*c*c;\n    float B = 2.0*(b*b - a*a) * s * c;\n    float C = a*a*c*c + b*b*s*s;\n    float D = -2.0*A*xc - B*yc;\n    float E = -B*xc - 2.0*C*yc;\n    float F = A*xc*xc + B*xc*yc + C*yc*yc - a*a*b*b;\n    \n    return mat3(A, 0.5*B, 0.5*D,\n                0.5*B, C, 0.5*E,\n                0.5*D, 0.5*E, F);\n    \n}\n\n// Return distance of point uv from ellipse in implicit form.\nfloat ellipse_dist(vec2 uv, mat3 M) {\n    \n    vec3 uv1 = vec3(uv, 1.0);\n    \n    float k = dot(uv1, M * uv1);\n    \n    float dist = k / length(vec2(dFdx(k), dFdy(k)));\n    \n    return abs(dist)-0.5;\n    \n}\n\n// Return distance to line segment\nfloat seg_dist(vec2 ba, vec2 pa) {\n    float u = clamp(dot(ba,pa)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-u*ba);\n}\n\n\n// Return distances to points in quadrilateral.\nfloat quad_dist(vec2 uv, vec2 p[5], float scl) {\n    \n    float d_quad = 1e5;\n    \n    for (int i=0; i<4; ++i) {\n        d_quad = min(d_quad, length(uv-p[i])/scl-3.0);\n        d_quad = min(d_quad, seg_dist(p[i+1]-p[i], uv-p[i])/scl-0.5);\n    }\n    \n    return d_quad;\n    \n}\n\n// Return grid distances\nvec2 grid_fract(vec2 x, vec2 i) {\n    return (fract(x/i+0.5)-0.5)*i;\n}\n\n// For mixing colors\nvec3 color_dist_mix(vec3 bg, vec3 fg, float dist, float alpha) {\n    float d = smoothstep(0.0, 0.75, dist); \n    return mix(bg, fg, alpha*(1.0-d));\n}\n\n\n// Do the things now.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Set up coordinate frame (4 units tall window, square pixels).\n\tvec2 uv = (fragCoord.xy + 0.5 - 0.5*iResolution.xy);\n    float scl = 4.0 / iResolution.y;\n    uv *= scl;\n    \n    // Construct a continuously changing homography.\n    float u = iTime;\n    \n    vec2 t = vec2(2.0*cos(0.17*u+0.32), sin(0.13*u+0.45));\n    vec2 k = vec2(0.4*cos(0.19*u+0.57), 0.3*sin(0.21*u+0.92));\n    vec2 s = 1.0 + vec2(0.5*cos(0.27*u+0.34), 0.3*sin(0.23*u+0.12));\n\tfloat a = 0.75*sin(0.07*u);\n    \n    mat3 H = translate(t) * distort(k) * rot(a) * scale(s);\n        \n    // Invert it\n    mat3 Hinv = inverse(H);\n    \n    // Construct a quadrilateral \n    vec2 p[5], Hp[5];\n    \n    p[0] = vec2(1.0, 0.5);\n    p[1] = vec2(-1.0, 0.5);\n    p[2] = vec2(-1.0, -0.5);\n    p[3] = vec2(1.0, -0.5);\n    p[4] = p[0];\n    \n    // Map it through the homography.\n    for (int i=0; i<5; ++i) {\n        Hp[i] = warp(H, p[i]);\n    }\n\n    // Set up our original ellipse\n    vec2 ctr = vec2(0), ab = p[0], axis = vec2(1.0, 0.0);\n    mat3 M = conic_from_gparams(ctr, ab, axis);\n    \n    // Warp ellipse through homography\n    mat3 M2 = transpose(Hinv) * M * Hinv;\n\n    // Get canonical params of warped ellipse\n    vec2 ctr2, ab2, axis2;\n    gparams_from_conic(M2, ctr2, ab2, axis2);\n    \n    //////////////////////////////////////////////////\n    // The rest is just drawing...\n\n    // Get distances to quadrilaterals.\n    float d_quad = quad_dist(uv, p, scl);\n    float d_quad2 = quad_dist(uv, Hp, scl);\n\n    // Sample points along both quadrilaterals\n    float d_stretch = 1e5;\n    \n    for (int i=0; i<32; ++i) {\n        float theta = float(i)*6.283185307179586/32.0;\n        vec2 v = vec2(cos(theta), sin(theta));\n        vec2 p0 = v * ab;\n        vec2 p1 = warp(H, p0);\n        d_stretch = min(d_stretch, seg_dist(p1-p0, uv-p0)/scl-0.5);\n    }\n    \n    // Green stuff\n    vec2 pcw = warp(H, ctr);\n    float d_pcw = length(uv-pcw)/scl-3.0;\n    d_pcw = min(d_pcw, seg_dist(Hp[0]-Hp[2], uv-Hp[2])/scl-0.5);\n    d_pcw = min(d_pcw, seg_dist(Hp[1]-Hp[3], uv-Hp[3])/scl-0.5);\n   \n    // Original ellipse & center\n    float d_ell = ellipse_dist(uv, M);\n    d_ell = min(d_ell, length(uv-ctr)/scl-3.0);\n    \n    // New ellipse & center\n    float d_ell2 = ellipse_dist(uv, M2);\n    d_ell2 = min(d_ell2, length(uv-ctr2)/scl-3.0);\n    \n    // Grid\n    vec2 grid = abs(grid_fract(uv, vec2(0.5)))/scl;\n    float d_grid = min(grid.x, grid.y);\n\n    vec3 color = vec3(1.0);\n    \n    color = color_dist_mix(color, vec3(0.8), d_grid, 1.0);\n    color = color_dist_mix(color, vec3(1.0, 0.7, 1.0), d_stretch, 0.2);\n    color = color_dist_mix(color, vec3(0.7, 0.7, 1.0), d_quad, 1.0);\n    color = color_dist_mix(color, vec3(1.0, 0.7, 0.7), d_ell, 1.0);\n    color = color_dist_mix(color, vec3(0, 0.7, 0), d_pcw, 0.5);\n    color = color_dist_mix(color, vec3(0, 0, 0.7), d_quad2, 1.0);\n    color = color_dist_mix(color, vec3(0.7, 0, 0), d_ell2, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGGz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[282, 327, 350, 350, 491], [493, 547, 567, 567, 663], [665, 723, 745, 745, 858], [860, 907, 931, 931, 1027], [1029, 1064, 1091, 1091, 1150], [1153, 1305, 1456, 1456, 1895], [1897, 1943, 2046, 2046, 2518], [2520, 2582, 2619, 2619, 2788], [2790, 2825, 2859, 2859, 2943], [2946, 2994, 3042, 3042, 3268], [3270, 3295, 3328, 3328, 3365], [3367, 3388, 3452, 3452, 3537], [3540, 3562, 3619, 3693, 6567]], "test": "error"}
{"id": "MlK3R3", "name": "Camera with Depth of Field", "author": "pyrite", "description": "Simulates a camera from the sensor outwards\nPlay with lines 38->42\nfocalDis controls the distance of focus for the lens\nlenRes controls the square root of the number of points on the lens\nThe virtual lens is trimmed to a circle for bokeh reasons. \n", "tags": ["blur", "dof", "camera", "iq", "tech", "field", "depth", "new", "ssaa", "focus", "technique", "virtual"], "likes": 28, "viewed": 1170, "published": "Public", "date": "1475965730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float asphere(in vec3 ro, in vec3 rd, in vec3 sp, in float sr){ \n    // geometric solution\n    float sr2 = sr*sr;\n    vec3 e0 = sp - ro; \n    float e1 = dot(e0,rd);\n    float r2 = dot(e0,e0) - e1*e1; \n    if (r2 > sr2) return 1000.0; \n    float e2 = sqrt(sr2 - r2); \n    return e1-e2; \n}\n\n\nfloat map(in vec3 ro, in vec3 rd){ \n    return min(asphere(ro,rd,vec3(0.0,0.0,0.0), 1.5),\n               min(asphere(ro,rd,vec3(-2,0.0,0.0),1.0), \n                   min(asphere(ro,rd,vec3(0.0,-2,0.0),1.0),\n                       min(asphere(ro,rd,vec3(1.15,1.15,1.15),1.0),\n                           min(asphere(ro,rd,vec3(0.0,0.0,-2),1.0),\n                              asphere(ro,rd,vec3(3.,3.,3.),0.2))))));\n}\n\n\nvec3 ascene(in vec3 ro, in vec3 rd){\n    float t = map(ro,rd);\n    vec3 col = vec3(0);\n    if (t==1000.0){col +=0.5;}\n    \n    else {\n        vec3 loc = t*rd+ro;\n        loc = loc*0.5;\n        col =  vec3(clamp(loc.x,0.0,1.0),clamp(loc.y,0.0,1.0),clamp(loc.z,0.0,1.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //THIS v\n    const int lensRes = 9; //THIS <\n    const int ssaa = 1; //THIS <\n    float lensDis = 0.75; //THIS <\n    float lensSiz = 2.0; //THIS <\n    float focalDis = 11.0; //THIS <\n    //THIS ^\n    //fragcoord is the center of the pixel\n\tvec2 sensorLoc = fragCoord.xy / iResolution.x; //sets x limits from 0-1 y at same scale, center at (0.5,0.?)\n    sensorLoc = vec2(0.5, 0.5*(iResolution.y/iResolution.x)) - sensorLoc; //reverse sensor and center on (0,0)\n    \n    vec3 Z = vec3(0.0,0.0,1.0); //useful later could be hardcoded later instead\n    float t = 0.5*iTime - 5.0*iMouse.x/iResolution.x; //tau used to determine camera position\n    \n    vec3 cameraPos = 10.0*vec3(1.0*sin(3.0*t),1.0*cos(2.0*t),1.0*cos(3.0*t)); //this is not normalized\n    \n    vec3 cameraDir = -cameraPos; //this will and should be normalized\n    cameraDir = normalize(cameraDir); //normalize\n    \n    vec3 cameraX = cross(cameraDir,Z); //right dir for camera\n    cameraX = normalize(cameraX); //normalize\n    \n    vec3 cameraY = cross(cameraX,cameraDir); //up dir for camera\n    cameraY = normalize(cameraY); //normlize\n\t\n    vec3 colorTotal = vec3(0.0,0.0,0.0);//for each pixel reset the accumulated color\n    float colorCount = 0.0;\n    float lensResF = float(lensRes); //for comparing to float later\n    float focal = 1.0+lensDis/focalDis; //brings the image to focus at focalDis from the cameraPos\n    float ssaaF = float(ssaa); // for using later to save a cast.\n    float sscale = 1.0/(iResolution.x); // size of a pixel\n    float sstep = 1.0/ssaaF;\n    float sstart = sstep/2.0-0.5;\n    float lstep = 1.0/lensResF;\n    float lstart = lstep/2.0-0.5;\n    \n    for (float sx = sstart; sx < 0.5; sx += sstep){ //SSAA x direction\n    \tfor (float sy = sstart; sy < 0.5; sy += sstep){ //SSAA y direction\n            \n        \tvec2 ss = vec2(sx,sy)*sscale; //sub pixel offset for SSAA\n            vec3 sensorRel = cameraX*(sensorLoc.x+ss.x) + cameraY*(sensorLoc.y+ss.y); //position on sensor relative to center of sensor. Used once\n            vec3 sensorPos = cameraPos - lensDis*cameraDir + sensorRel; //3d position of ray1 origin on sensor\n            \t\n            for (float lx = lstart; lx < 0.5; lx+=lstep){\n        \t\tfor (float ly = lstart; ly < 0.5; ly+=lstep){\n                    \n            \t\tvec2 lensCoord = vec2(lx,ly); //fragCoord analog for lens array. lens is square\n        \t\t\tvec2 lensLoc = (lensCoord)*lensSiz; //location on 2d lens plane\n            \t\t\n                    if (length(lensLoc)<(lensSiz/2.0)){ //trim lens to circle\n                        \n                \t\tvec3 lensRel = cameraX*(lensLoc.x) + cameraY*(lensLoc.y); //position on lens relative to lens center. Used twice\n            \t\t\tvec3 lensPos = cameraPos + lensRel; // 3d position of ray1 end and ray2 origin on lens\n            \t\t\tvec3 rayDir1 = lensPos - sensorPos; //direction of ray from sensor to lens\n            \t\t\tvec3 rayDir2 = rayDir1 - focal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\trayDir2 = normalize(rayDir2); //normalize after focus \n            \t\t\tvec3 color = ascene(lensPos,rayDir2); //scene returns a color\n            \t\t\tcolorTotal = colorTotal+color; //sum colors over all  points from lens\n                        colorCount += 1.0; //total number of colors added.\n                    }\n                }\n            }\n        }\n    }\n    \n    fragColor = vec4(colorTotal/colorCount - length(sensorLoc)*0.25,0.0); //slight post-processing\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlK3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 90, 287], [290, 290, 324, 324, 704], [707, 707, 743, 743, 1000], [1002, 1002, 1058, 1071, 4530]], "test": "valid"}
{"id": "MlK3RR", "name": "First Raymarching attempt", "author": "TheRomanOne", "description": "First raymarching experiment.", "tags": ["raymarching"], "likes": 1, "viewed": 169, "published": "Public", "date": "1476805957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Added specular light, shadows and lightSource visualization.\n//Special thanks to jackdavenport!\n\n\n#define MAX_DIST 100.0\n#define PI 3.141592654\n#define EULER 2.718281828\n#define EPSILON 0.001\n#define SHADOW 0.01\n\nstruct SphereData\n{\n    float len;\n    vec3 center;\n    float size;\n    vec3 color;\n    float specular;\n    float dumper;\n};\n    \nSphereData sphere(vec3 center, vec3 ray, float size, vec3 color, float spec, float dump)\n{\n    SphereData sp;\n    \n    sp.len = length(ray - center) - size;\n    sp.color = color;\n    sp.center = center;\n    sp.size = size;\n    sp.specular = spec;\n    sp.dumper = dump;\n    \n    return sp;\n}\n\nSphereData map(vec3 ray)\n{\n    vec3 p1 = vec3(-5.*sin(iTime/4.), 5.*cos(iTime/4.), 0.);\n    vec3 p2 = vec3(4.5*sin(iTime/2. + PI), 0, 4.5*cos(iTime/2. + PI));\n    vec3 p3 = vec3(.125 * cos(iTime*3.), .125 * sin(iTime*1.5), .125 * cos(iTime*3.));\n    \n    SphereData[3] spheres;\n    spheres[0] = sphere(p1, ray, 1., vec3(0., 0., .5), 20., 1.5);\n    spheres[1] = sphere(p2, ray, .5, vec3(.5, 0., 0.), -1., 8.);\n    spheres[2] = sphere(p3, ray, 2.5, vec3(0., .5, 0.), 15., 2.5);\n    \n    SphereData temp = spheres[0];\n    \n    for(int index = 0; index < 3; index++)\n        if(spheres[index].len < temp.len)\n            temp = spheres[index];   \n        \n    return temp;\n}\n\nvec3 getNormal(vec3 ray)\n{\n\tvec3 grad = vec3\n    (\n      map(ray + vec3(EPSILON, 0, 0)).len - map(ray - vec3(EPSILON, 0, 0)).len,\n      map(ray + vec3(0, EPSILON, 0)).len - map(ray - vec3(0, EPSILON, 0)).len,\n      map(ray + vec3(0, 0, EPSILON)).len - map(ray - vec3(0, 0, EPSILON)).len\n    );\n    \n    return normalize(grad);\n}\n\nfloat trace(vec3 origin, vec3 dir)\n{\n \tfloat dist = 0.;\n    for(int i = 0;i<128;i++)\n        if(dist < MAX_DIST)\n        {\n        \tvec3 ray = origin + dir * dist;\n        \tdist += map(ray).len;\n        }else return -1.;\n            \n    return dist;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n        \n    vec3 ray = normalize(vec3(uv, 1.));\n    vec3 origin = vec3(0./*5.*sin(iTime/3.)*/,0., -6.);\n    vec3 camDir = normalize(-origin);\n    \n    //vec3 light = vec3(20.*sin(iTime/3.), 0., -20.*cos(iTime/3.));\n    vec3 light = vec3(20.*sin(iTime/5.), 50. * cos(iTime * 2.) * sin(iTime/3.), 20.*cos(iTime/5.));\n    vec3 lightDir = normalize(light);\n    vec3 lightColor = vec3(0.69, 0.0015, .7);\n    \n    ray = (viewMatrix(ray, vec3(0.), vec3(.0, 1.0, 0.0)) * vec4(ray, 0.)).xyz;\n\n    float dist = trace(origin, ray);\n    vec3 color = vec3(0.);\n    if(dist > 0.)\n    {\n        vec3 position = origin + ray * dist;\n        SphereData sp = map(position);\n        vec3 baseColor = sp.color;\n\n        vec3 normal = getNormal(position);\n         \n        float diffuse = max(SHADOW, dot(normal, lightDir));\n        float specular = 0.;\n        if(sp.specular > 0. )\n            specular = pow(max(0., dot(normalize(reflect(ray, normal)), lightDir)), sp.specular)/(sp.dumper);\n        \n        \n        if(trace(position + lightDir * 0.1, lightDir) > 0.)\n        {\n            specular = 0.;\n            diffuse = SHADOW;\n        }\n        \n        float shineBack = 0.;//pow(max(0., dot(lightDir, ray)), 60.);\n        \n        color = baseColor * diffuse + (shineBack*0.1 + specular) * sqrt(lightColor);\n        \n    } else\n    {\n     \tfloat shine = pow(max(0., dot(lightDir, ray)), 20.);\n        float shineBack = pow(max(0., dot(lightDir, camDir)), 2.2);\n        color = (shineBack + shine) * lightColor;\n    }\n    \n    fragColor = vec4(sqrt(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlK3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 345, 435, 435, 635], [637, 637, 663, 663, 1307], [1309, 1309, 1335, 1335, 1637], [1639, 1639, 1675, 1675, 1891], [1893, 1893, 1942, 1942, 2158], [2160, 2160, 2217, 2217, 3834]], "test": "valid"}
{"id": "MlK3zK", "name": "Star gears", "author": "kellyegan", "description": "Experimenting with tiling.", "tags": ["gears", "tiling"], "likes": 7, "viewed": 162, "published": "Public", "date": "1475610500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n\nfloat star( vec2 coord, vec2 center, float radius, float points, float blur, float rot) {\n    vec2 p = center - coord;\n    \n    //Polar coordinates\n    float d = length(p) * 2.0;\n    float a = atan(p.y, p.x);\n    \n    float f = (cos(a * points + rot) + 1.0) / 8.0  + 0.75;\n\n    return 1.0 - smoothstep(f * radius - blur / 2.0, f * radius + blur / 2.0, d);\n}\n\nfloat circle( vec2 coord, vec2 center, float radius, float blur ) {\n    vec2 dist = coord - center;\n\treturn 1.0 - smoothstep(pow(radius - blur, 2.0), pow(radius + blur, 2.0), dot(dist,dist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    \n    uv *= 9.0;\n    float oddR = step(1.0,mod(uv.y,2.0));\n    float oddC = step(1.0,mod(uv.x,2.0));\n    \n    uv = fract(uv);\n    \n    float t = iTime * 10.0;\n    \n    float index = 0.0;\n    \n    if( oddR == 0.0) {\n        t = -t + PI;\n    } else {\n        index += 1.0;\n    }\n    \n    if( oddC == 0.0) {\n        t = -t - PI;\n    } else {\n        index += 2.0;\n    }\n    \n    float st = star( uv, vec2(0.5), 1.0, 8.0, 0.1, t);\n    vec4 c;\n    \n    if( index == 0.0 ) {\n    \tc = vec4(255.0, 53.0, 83.0, 255.0) / 255.0;\n    } else if(index == 1.0) {\n        c = vec4(8.0, 180.0, 150.0, 255.0) / 255.0;\n    } else if(index == 2.0) {\n        c = vec4(255.0, 170.0, 20.0, 255.0) / 255.0;\n    } else {\n        c = vec4(102.0, 95.0, 87.0, 255.0) / 255.0;\n    }\n    \n\tfragColor = mix( c, vec4(194.0, 206.0, 217.0, 255.0) / 255.0, 1.0 - st);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlK3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 111, 111, 379], [381, 381, 448, 448, 574], [577, 577, 634, 634, 1533]], "test": "valid"}
{"id": "MltSRn", "name": "Inkplot Dance", "author": "Blubor2", "description": "added soundcloud support to Andre's inklplot", "tags": ["2d", "distancefield", "soundcloud", "rorschach", "inkplot"], "likes": 13, "viewed": 711, "published": "Public API", "date": "1477819597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// original https://www.shadertoy.com/view/MddSzl# by Andre\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv1 = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    vec2 uv = uv1*4.0;\n    \n    freqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n    \n    float c = 1.;\n    uv.x = abs(uv.x);\n    uv.x -= 1.;\n    float gt = iTime*(1.3+freqs[1]*0.01);\n    for (float i = 0.0; i< 100.0; i++) {\n      gt += i*.72;\n      c *= min(0.1+max(freqs[3]*2.-0.1,1.),distance(uv,\n                            vec2(sin(gt*0.9)+cos(gt*(i/37.))\n                                ,sin(gt*0.7)+cos(gt*(i/23.)))));\n    }\n    \n\tfragColor = vec4(clamp(\n                       mix( vec3(freqs[0]*freqs[0],.1,freqs[2]),\n                            vec3(1.0,1.,0.9),\n                            smoothstep(.1,0.12,c))\n                       *(0.5+texture(iChannel0,vec2(uv1.y*4.,uv.x)+uv1*vec2(7.0,.13)).g\n                       *.25*max(-.2,4.0-length(uv)))\n                       ,0.0,1.0)\n                     ,1.0);\n    vec2 position = (fragCoord.xy / iResolution.xy) - vec2(0.5);\n    float vignette = smoothstep(0.9, 0.2+freqs[1]/5., length(position));\n    fragColor = vec4(fragColor.xyz * vignette, 1.0);\n    \n    \n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "lsBGWR", "previewfilepath": "https://soundcloud.com/adventureclub/flight-facilities-crave-you", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/adventureclub/flight-facilities-crave-you", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 135, 135, 1400]], "test": "error"}
{"id": "MltXRn", "name": "Simple scene for Unreal", "author": "Andree", "description": "Nothing fancy, just needed a simple scene for use in an Unreal material. Had to put everything into one function since the function names are auto generated by Unreal.\n\nTo see the hlsl version in action: https://youtu.be/zMmW1WuJXd0", "tags": ["raymarching", "unreal"], "likes": 1, "viewed": 236, "published": "Public", "date": "1477826949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(2.0 * iResolution.x / iResolution.y, 2.0);\n\n    vec3 origin = vec3(0.0, 0.0, -0.0);\n    float angle = iTime * 0.25 + sin(iTime * 0.15 + 0.3);\n    vec3 direction = normalize(vec3(uv, 1.0));\n    direction.xz *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    float sphereRadius = 0.125 + 0.1 * sin(iTime * 3.1);\n    vec3 qubeDisplacement = vec3(0.5, 0, iTime);\n    vec3 qubeHalfDistance = vec3(0.125, 0.025, 0.125);\n    vec4 dist;\n\n    float t = 0.0;\n    for (int i = 0; i < 50; ++i)\n    {\n        vec3 point = origin + direction * t;\n\n        // distance/normal function\n        vec3 closestCubePosition = fract(point + qubeDisplacement) - 0.5;\n        vec4 cubeDistance = vec4(0, 0, -2, length(max(abs(closestCubePosition) - qubeHalfDistance,0.0))); // make always full lit\n\n        vec3 closestSpherePosition = fract(point) - 0.5;\n        vec4 sphereDistance = vec4(normalize(closestSpherePosition), length(closestSpherePosition) - sphereRadius);\n\n        dist = (cubeDistance.w < sphereDistance.w) ? cubeDistance : sphereDistance;\n\n        t += dist.w * 1.0;\n        if (dist.w < 0.005)\n            break;\n    }\n    dist = vec4(dist.xyz, t);\n    \n    float fog = min(4.0 / (1.0 + 0.5 * dist.w * dist.w), 1.0);\n    \n    vec3 lightDirection = vec3(0.0, 0.0, -1.0);\n    vec3 materialColor = floor(0.5 + length(dist.xyz)) == 2.0 ? vec3(0.3, 0.59, 0.72) : vec3(0.72, 0.59, 0.3);\n    \n    float light = clamp(dot(lightDirection, dist.xyz), 0.0, 1.0) + 0.2;\n                     \n    \n\tfragColor = vec4(materialColor * (light * fog),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1665]], "test": "valid"}
{"id": "MlV3zt", "name": "GGGear", "author": "antonOTI", "description": "I needed a gear for my game", "tags": ["2d", "noob", "gear"], "likes": 4, "viewed": 117, "published": "Public", "date": "1476308475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _Smooth(p,r,s) smoothstep(-s, s, p-(r))\n\n#define radius .4\n#define teehNumber 5.\n#define teethSize .09\n#define teethSteepness .6\n#define centerHoleSize .15\n\n// base gear function\n// by : srtuss\n// from : https://www.shadertoy.com/view/Msf3D7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 pos = uv - vec2(iResolution.x /iResolution.y * .5,.5);\n    \n    float dist = length(pos);\n\t\n\tfloat teeth = sin(atan(pos.y, pos.x) * teehNumber + time);\n\tteeth = _Smooth(teeth,0.,teethSteepness) * teethSize;\n    \n    float f = \n        - _Smooth(dist - teeth,radius,.002) \n        + _Smooth(dist - teeth * .3,centerHoleSize,.002);\n    \n    vec4 col = vec4(vec3(f),1.);\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlV3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 251, 308, 308, 770]], "test": "valid"}
{"id": "MlV3zy", "name": "Sphere skeleton", "author": "deadmanswitch", "description": "Just experimenting...", "tags": ["raymarch", "sphere", "folding", "tetrahedron"], "likes": 3, "viewed": 136, "published": "Public", "date": "1475361274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653\n#define FOV 60.0\n\n#define MAX_STEP   32\n#define MAX_STEP_F 32.0\n\nconst float infinity = 1.0/0.00000001;\n\n\nfloat max4(in vec4 v4) {\n    return max( max(v4.x, v4.y), max(v4.z, v4.w) );\n}\n\n\n// rotations\nvec3 rotateX(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0],\n        vec[1]*cos(rad) - vec[2]*sin(rad),\n        vec[1]*sin(rad) + vec[2]*cos(rad)\n    );\n        \n}\n\nvec3 rotateY(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[2]*sin(rad) + vec[0]*cos(rad),\n        vec[1],\n        vec[2]*cos(rad) - vec[0]*sin(rad)\n    );\n}\n\nvec3 rotateZ(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0]*cos(rad) - vec[1]*sin(rad),\n        vec[0]*sin(rad) + vec[1]*cos(rad),\n        vec[2]\n    );\n}\n\n\n/***************\n\nTetrahedron start\n\n***************/\n\n// normals\nconst vec3 norm1 = vec3(\n\t0.4714045226573944,\n    0.3333333432674408,\n    -0.8164966106414795\n);\nconst vec3 norm2 = vec3(\n\t-0.9428090453147888,\n    0.3333333432674408,\n    0.0\n);\nconst vec3 norm3 = vec3(\n\t0.4714045524597168,\n    0.3333333432674408,\n    0.8164966106414795\n);\n\n// points\nconst vec3 point0 = vec3(0.0,1.0,0.0);\nconst vec3 point1 = vec3(0.9428090453147888,-0.3333333432674408,0);\nconst vec3 point2 = vec3(-0.4714045226573944,-0.3333333432674408,-0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944,-0.3333333432674408,0.8164966106414795);\n\nfloat planedist(in vec3 point, in vec3 norm) {\n\n    return dot(point, norm) - norm.y;\n\n}\n\nconst float size = 3.0;\nfloat tet(in vec3 point) {\n    \n    point = point/size;\n\n    // subtracting the planes from a sphere\n    float dist = max4(vec4(\n        planedist(point, norm1),\n        planedist(point, norm2),\n        planedist(point, norm3),\n        -(1.0/3.0+point.y)\n    ));\n\n    // the sphere has a `size` radius\n    dist = max(length(point)-1.0, dist)*size;\n\n    return dist;\n    \n}\n\n/***************\n\nTetrahedron end\n\n***************/\n\nfloat DE(in vec3 pos) {\n    \n    float rot = (iTime*0.25)*PI*2.0;\n    \n    pos = rotateX(pos, rot);\n    pos = rotateY(pos, rot);\n    pos = rotateZ(pos, rot*0.5);\n    \n    // folding\n    for(int i=0; i<10; i++) {\n        \n        if(pos.x+pos.y<0.0){pos.xy=-pos.yx;}\n        \n        pos = rotateY(pos,  0.95);\n        \n        if(pos.x+pos.z<0.0){pos.xz=-pos.zx;}\n        \n        pos = rotateZ(pos, -0.7);\n        \n        if(pos.y+pos.z<0.0){pos.yz=-pos.zy;}\n        \n    }\n    \n    return max(\n        tet(pos),\n        -(length(pos)-1.7)\n    );\n}\n\nconst vec3 shadowColor = vec3(0.1, 0.0, 0.0);\nconst vec3 backColor = vec3(0.4, 0.4, 0.5);\nconst vec3 oColor = vec3(0.2, 0.4, 0.75);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 5.0+sin(iTime)*1.0);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\n        vec3 pos = point;\n\n        float dist = DE(pos);\n\n        if(dist < 0.0025) {\n            fragColor = vec4(mix(\n                oColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            return;\n        }\n\n        closest = min(closest, dist);\n\n        point += dir*dist;\n\n    }\n\n    // background shading\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/2.0, 0.0, 1.0))\n    ), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlV3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 153, 153, 207], [210, 223, 264, 264, 405], [407, 407, 448, 448, 580], [582, 582, 623, 623, 755], [1100, 1391, 1437, 1437, 1479], [1505, 1505, 1531, 1531, 1877], [1879, 1932, 1955, 1955, 2482], [2617, 2617, 2674, 2693, 3626]], "test": "valid"}
{"id": "MlVGDK", "name": "PlanetSide 2 Plasma Forcefield", "author": "VoidChicken", "description": "I made the planetside 2 warpgate force field (similar to real one).", "tags": ["2d", "noise", "plasma", "perlin", "2", "ps2", "forcefield", "planetside"], "likes": 17, "viewed": 758, "published": "Public", "date": "1476915442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat n ( vec3 x ) {\n\tfloat s = noise(x);\n    for (float i = 2.; i < 10.; i++) {\n    \ts += noise(x/i)/i;\n        \n    }\n    return s;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*10.;\n    float a = abs(n(vec3(uv+iTime*3.14,sin(iTime)))-n(vec3(uv+iTime,cos(iTime+3.))));\n\tfragColor = vec4(0, .5-pow(a, .2)/2., 1.-pow(a, .2), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 59], [60, 60, 86, 86, 455], [456, 456, 476, 476, 591], [592, 592, 649, 649, 841]], "test": "valid"}
{"id": "MlVGRK", "name": "demosplash2016-cxw-06", "author": "cxw", "description": "Part 06: Loops and arrays\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016\n\nYes, this code is clunky!  I wrote it for explanation rather than for speed.", "tags": ["tutorial", "demoparty"], "likes": 0, "viewed": 361, "published": "Public API", "date": "1475777009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp int;precision highp float;\n\n// Parameters for your demo\n\n// blinds\n#define BLIND_CYCLE_TIME (3.0)\n    // Over this time (sec), the blinds will open and then close\n#define BLIND_RAMP_TIME (1.0)\n    // How long they take to open or close.  Keep it < BLIND_CYCLE_TIME/2.0\n#define NBLINDS (7)\n    // An integer!!!!!1!!\n#define BLIND_EDGE_STEP (0.14285714285714285714285714285714)\n    // 1/NBLINDS, precomputed to avoid division\n\n// moire\n#define THICKNESS (0.85)\n    // larger means narrower\n#define SPACING (200.0)\n    //ditto\n#define SPEED (0.6)\n    // Higher is faster\n\n// Computed parameters //////////////////////////////////////////////////\n#define BLIND_HALFCYCLE_TIME (BLIND_CYCLE_TIME*0.5)\n#define BLIND_END_RAMPDOWN_TIME (BLIND_HALFCYCLE_TIME + BLIND_RAMP_TIME)\n    // blinds begin closing halfway through the cycle, and are fully closed\n    // at BLIND_END_RAMPDOWN_TIME.\n#define BLIND_RAMP_RATE (1.0/BLIND_RAMP_TIME)\n    // Laziness!  For the release, precompute this since the shader\n    // may have lower precision than your calculator.\n\n// Transition: Vertical blinds //////////////////////////////////////////\n// Evenly-spaced vertical blinds can be done with mod().  Unevenly, though...\n\nfloat get_blind_mask(in float percent, in float x_01)\n{ // x_01 is X coord, 0..1 (not pixel).\n  // percent is how open the blinds are.  ** No time in this function! **\n  // return value is 0.0 for a pixel that is covered, and 1.0 for a pixel\n  // that is not covered.\n\n    float edges[NBLINDS+1];   // Array.  Can also be outside any function.\n        // Blind x goes from edges[x] to edges[x+1].\n        // edges[0]=0.0; edges[NBLINDS+1]=1.0.\n\n    // Init (each frame!).  Note: \"for\" loops are very fixed-form.\n    // Also note that \"break\" and \"continue\" work in loops.\n\n    for(int edge_idx = 0; edge_idx < NBLINDS+1; ++edge_idx) {\n        float edge_idx_f = float(edge_idx);   //explicit typecast\n        edges[edge_idx] = smoothstep(0.0, 1.0, edge_idx_f * BLIND_EDGE_STEP);\n    } //for each edge\n\n    // See if we are in a blind\n    for(int blind_idx = 0; blind_idx < NBLINDS; ++blind_idx) {\n        float left_edge = edges[blind_idx];\n        float right_edge = edges[blind_idx+1];\n        float center = mix(left_edge, right_edge, 0.5);\n        float open_left = mix(center, left_edge, percent);\n        float open_right = mix(center, right_edge, percent);\n        if( (x_01 >= open_left) && (x_01 <= open_right) ) {\n            return 1.0;     // This pixel is visible!\n        }\n    } //for each blind\n\n    return 0.0;     // If we get here, the pixel is hidden by the blinds.\n\n} //get_blind_mask\n\n// Effect: moire ////////////////////////////////////////////////////////\n\nfloat get_sine_01( in float time, in vec2 coords, in vec2 center, in float radius, in float speed) { float whereami = radius*distance(center,coords) - speed*time; return 0.5+0.5*sin(whereami); }\nfloat squish(in float f) { return (f+1.0)*0.5; }\nvec2 lisa(in float time, in float a, in float b, in float delta) { return vec2(squish(sin(a*time+delta)), squish (sin(b*time))); }\n\nvec4 moire(in float time, in vec2 pixel_coord_01 )\n{ //used to be mainImage() - now it's moire() and has a \"time\" parameter.\n    vec2 ca = lisa(time*0.5*SPEED,        5.0,4.0,0.0); vec2 cb = lisa(time*0.835744*SPEED,   3.0,2.0,1.8); cb = mix(ca, cb, 0.6); float sa = get_sine_01(time, pixel_coord_01, ca, SPACING, 10.0); float sb = get_sine_01(time, pixel_coord_01, cb, SPACING, 10.0); sa=step(THICKNESS,sa); sb=step(THICKNESS,sb); return vec4(max(sa,sb),0.0,0.0,1.0);\n} //moire\n\n// mainImage() //////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 pixel_coord_01 = fragCoord.xy / iResolution.xy;\n    fragColor = moire(t, pixel_coord_01);       // The effect\n\n    // Apply the mask\n\n    // Make a clipped, repeating triangular profile\n    float blind_time = mod(t, BLIND_CYCLE_TIME);        //the repeat\n    float blind_rise = blind_time * BLIND_RAMP_RATE;    //ramp up\n    float blind_fall = (BLIND_END_RAMPDOWN_TIME - blind_time) * BLIND_RAMP_RATE;\n                                                        //ramp down\n    float blind_percent = clamp(min(blind_rise, blind_fall), 0.0, 1.0);\n                                                        //clip\n    // Is this pixel visible through the blinds?\n    float blind_mask = get_blind_mask(blind_percent, pixel_coord_01.x);\n\n    //Black out masked pixels\n    fragColor = mix(vec4(0.0), fragColor, blind_mask);\n        // use fragColor = vec4(vec3(blind_percent),1.0); to see just one value\n} //mainImage\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1064, 1217, 1272, 1484, 2605], [2624, 2699, 2799, 2799, 2893], [2894, 2894, 2920, 2920, 2942], [2943, 2943, 3009, 3009, 3073], [3075, 3075, 3127, 3199, 3545], [3555, 3630, 3687, 3687, 4611]], "test": "valid"}
{"id": "Mly3Rd", "name": "Underwater grass", "author": "tarzain", "description": "underwater grass", "tags": ["procedural", "2d", "water", "plants"], "likes": 0, "viewed": 147, "published": "Public", "date": "1476153705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rgb(r,g,b) (vec4(r,g,b,255.)/255.)\n#define saturate(x) (clamp(0.,1.,x))\n\nfloat rand(float x) { return clamp(0.,1.,fract(sin(x* 71523.5413291))); }\nfloat rand(vec2 x) { return rand(dot(x, vec2(13.4251, 15.5128))); }\n\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = x - i;\n    f *= f*(3.-2.*f);\n    return mix(mix(rand(i), rand(i+vec2(1,0)), f.x),\n               mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), f.x), f.y);\n}\n\nfloat fbm(vec2 x)\n{\n    float r = 0.0, s = 1.0, w = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        s *= 2.0;\n        w *= 0.5;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat cloud(vec2 uv, float scalex, float scaley, float density, float sharpness, float speed)\n{\n    return pow(saturate(fbm(vec2(scalex,scaley)*(uv+vec2(speed,0)*iTime))-(1.0-density)), 1.0-sharpness);\n}\n\nfloat grass(vec2 uv, float seed){\n    float x = clamp(0.,0.5, seed);\n    float y = clamp(0., 1., seed)-0.5;\n    float period = clamp(0.,1., seed)*1.;\n    float amp = clamp(.2,.22, seed);\n    float blade = abs(uv.y-y-(amp*sin((uv.x+iTime)*period)+0.5));\n    float thickness = clamp(0.1,0.3,seed)*0.04;\n    float len = (seed*0.5);\n    \n\treturn smoothstep(0.,thickness*smoothstep(0.1,0.1+len,sin(uv.x+(len-0.5)/2.)), blade);   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    color /= 5.;\n\t//vec4 color = vec4(uv/2.,1.0,1.0)*0.2;\n    \n    //vec4 color = vec4(0.01);\n    \n    vec4 grassColor = rgb(25,75,42);\n    \n    for(float i = 0.; i <= 20.; i++) {\n        float offset = rand(i);\n        grassColor.g += (offset-0.5)*0.1;\n        grassColor.b += (offset-0.2)*0.01;\n        \n    \tcolor = mix(grassColor, color, grass(uv, offset));\n    }\n    \n    //color = vec4(0.01);\n    // clouds\n    vec4 cl1 = mix(rgb(131,158,210), rgb(166,191,224), uv.y-sin(iTime/4.));\n    float d1 = mix(0.9,0.1,pow(uv.y, 0.7));\n    \n    color = mix(color, cl1, cloud(uv,2.,8.,d1,0.4,0.04));\n\n    //color = mix(color, vec4(0.2,0.2,0.2,1.), 5.*cloud(uv,12.,15.,0.9,0.75,0.03) * cloud(uv,2.,8.,0.5,0.0,0.02)*uv.y);\n    fragColor = color;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mly3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 102, 102, 154], [155, 155, 175, 175, 222], [224, 224, 245, 245, 434], [436, 436, 455, 455, 615], [617, 617, 712, 712, 820], [822, 822, 855, 855, 1248], [1249, 1249, 1306, 1306, 2136]], "test": "error"}
{"id": "Mly3WV", "name": "Oldschool Tube", "author": "Shane", "description": "A simple, oldschool, cylindrically-mapped, tunnel flythrough with some bump mapping, and bump-based edging.", "tags": ["voronoi", "tunnel", "oldschool", "bump", "cylinder"], "likes": 17, "viewed": 1077, "published": "Public API", "date": "1477058116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tOldschool Tube\n\t--------------\n\n\tAn oldschool tube effect, with a few extra lines to bump it and light it up. Virtually no \n\tdifferent in concept to the more compact, minimal character versions.\n\n\tAiekick asked about cylindrically wrapping a pattern - like Voronoi - onto a cyclinder, so \n\tI thought I'd put a simple example together and post it privately... However, I got a little \n\tcarried away adding window dressing. It's still not particularly interesting, but I liked\n\tthe simple rendering style, so thought I'd release it publicly.\n\n\tHaving said that, one minor point of interest is that the edging is done in the bump routine.\n\tMost edging examples are raymarched and involved normal-based edge calculations, but this\n\tshows that you can have edging on the bump mapped part of the scene too. There are much more\n\tinteresting applications, and I'll give an example at a later date.\n\n\n\tCreated in repsonse to the following:\n\n    Voro Tri Tunnel - aiekick\n    https://www.shadertoy.com/view/XtGGWy\n\n\tA rough explanation of the oldschool tunnel effect:\n\n\tTraced Minkowski Tube - Shane\n    https://www.shadertoy.com/view/4lSXzh\n\n    // Another example.\n\tLuminescent Tiles - Shane\n\thttps://www.shadertoy.com/view/MtSXRm\n\n*/\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p, float w) { \n\n    // The Voronoi pattern needs to be repeatable. Hence the \"mod\" line below.\n    p = mod(p, w);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n)*.9 + .1; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    //return sin( p*6.2831853 + iTime )*.45 + .5; \n    \n}\n\n\nfloat vx;\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p, float w){\n    \n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1.4142); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o, w) - p;\n            \n\t\t\td.z = length(o);//(dot(o, o)); \n            \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = mix(max(abs(o.x)*.866025 + o.y*.5, -o.y), dot(o, o), .2);//\n            //d.z = max(abs(o.x)*.866025 - o.y*.5, o.y);\n            //d.z = max(abs(o.x) + o.y*.5, -(o.y)*.8660254);\n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n \t\t\t\t\t \n\td/=1.4142;\n    \n    vx = d.x;\n    \n    d = smoothstep(0., 1., d);\n\n    \n    return max(d.y/1.333 - d.x, 0.)*1.333;\n    \n   \n    //return d.y - d.x;\n    \n}\n\nfloat objID;\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    // Stock standard cylindrical mapping. This line here is pretty much\n    // where all the oldschool tunnel examples stem from.\n    vec2 uv = vec2(atan(p.y, p.x)/6.2832, p.z/8.);\n    \n    float c = Voronoi(uv*16., 16.);\n\n    objID = 0.;\n\n    // The web section. Comment it out, if you're not sure what it does.\n    if(c<.15) { c = abs(max(c, 0.01) - .3), objID = 1.; }\n    \n    return c;\n   \n}\n\n\n// Standard function-based bump mapping function, with some edging added to the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    vec2 e = vec2(2.5/iResolution.y, 0);\n    \n    float f = bumpFunction(p); \n    \n    // Samples about the hit point in each of the axial directions.\n    float fx = bumpFunction(p - e.xyy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Same for the nearby sample in the Y-direction.\n\n    // Samples from the other side.\n    float fx2 = bumpFunction(p + e.xyy); // Same for the nearby sample in the X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz2 = bumpFunction(p + e.yyx); // Same for the nearby sample in the Y-direction.\n    \n    // We made three extra function calls, so we may as well use them. Taking measurements\n    // from either side of the hit point has a slight antialiasing effect.\n    vec3 grad = (vec3(fx - fx2, fy - fy2, fz - fz2))/e.x/2.;   \n\n    // Using the samples to provide an edge measurement.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    //edge = abs(fx + fx2 - f*2.) + abs(fy + fy2 - f*2.)+ abs(fz + fz2 - f*2.);\n    edge = smoothstep(0., 1., edge/e.x);\n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n// The second function. This adds the swirly noise patterns to the webbing.\nfloat bumpFunction2(in vec3 p){\n    \n    float c = n3D(p*16.); // Noise value.\n    \n    c = fract(c*4.); // Producing some repeat noise contour rings... Bad description. :)\n    \n    return min(c, c*(1. - c)*4.); // Smooth \"fract.\" It's an old trick.\n   \n}\n\n// A second function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    vec2 e = vec2(2.5/iResolution.y, 0);\n    float f = bumpFunction2(p); \n    \n    float fx = bumpFunction2(p - e.xyy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunction2(p - e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz = bumpFunction2(p - e.yyx); // Same for the nearby sample in the Y-direction.\n    \n    vec3 grad = (vec3(fx, fy, fz )-f)/e.x; \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    \n    // Unit direction ray. Coyote's elegant version. So obvious, yet it never occurred\n    // to me... or most others, it seems. :)\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*0.5, iResolution.y));\n    \n    rd.xy = rot(iTime*0.5)*rd.xy; // Look around, just to show it's a 3D effect.\n    rd.xz = rot(iTime*0.25)*rd.xz;\n    \n    // Ray origin.\n    vec3 ro = vec3(0.0, 0.0, iTime*2.);\n    \n    // Screen color. Initialized to black.\n    vec3 col = vec3(0);\n\n\tconst float rad = 1.; // Initial cylinder radius.\n\n    // Distance fromt the ray origin to the cylinder layer surface point. It's a cut down\n    // version of a traced cylinder with its center fixed to the Z axis.\n    float sDist = rad/max( length(rd.xy), 0.001 );\n\n    // Surface position.\n    vec3 sp = ro + rd*sDist;\n\n    // Surface normal.\n    vec3 sn = normalize(vec3(-sp.xy, 0.)); // Cylinder normal.\n\n    // Bumpmapping (the Voronoi part) with some edge calculations included.\n    float edge;\n    sn = doBumpMap( sp, sn, .75, edge);\n    \n    // The object ID is calculated in the bump function. We save it here. Zero is the bulbous\n    // portion that gets lit up and one is the webbing.\n    float svObjID = objID;\n    \n    // Secondary bump pattern on the webbing. Done separately, so as not to interfere\n    // with the edge calculations.\n    if(svObjID>.5) sn = doBumpMap( sp, sn, .003);\n    \n    // Some rough noise sprinkles. Note that a 3D noise function is being used. You could also\n    // cylindrically map a 2D noise function, but I thought this was less hassle.\n    vec3 tex = vec3(1)*n3D(fract(sp)*192.);\n    vec3 objCol = smoothstep(.1, .9, tex)*.8 + 1.;\n    \n    \n    if(svObjID<.5) objCol *= vec3(.45, .425, .5); // The bulbs. Using a slightly darker tone.\n    else objCol *= vec3(.68, .64, .75); // The Voroni web portion.\n    \n    // Alternative: Egyptian look - gold and turquoise... or lapis lazuli, for the purists. :)\n    //if(svObjID>.5) objCol *= vec3(1, .75, .4)*.75;\n    //else objCol *= vec3(.5, .7, 1);\n\n    // Lighting.\n    //\n    // The light. Placed near the ray origin, camera, etc. We're looking down both ends of the\n    // tunnel, so it helps to keep the light near the camera. A better alternative is to have \n    // two lights on either side, but I'm trying to keep it simple.\n    vec3 lp = ro + vec3(0, .5, 0);\n    vec3 ld = lp - sp; // Light direction.\n    float dist = max(length(ld), 0.001); // Distance from light to the surface.\n    ld /= dist; // Use the distance to normalize \"ld.\"\n\n    // Light attenuation, based on the distance above.\n    float atten = 1.5/(1. + dist*.05 + dist*dist*0.075);\n    \n    // Use the bump texture to darken the crevices. Comment it out to see its effect.\n    atten *= bumpFunction(sp)*.9 + .1;//getGrey(texCol(iChannel0, sp))*.5 + .5;\n\n\n    float diff = max(dot(ld, sn), 0.); // Diffuse light value.\n    diff = pow(diff, 8.)*0.66 + pow(diff, 16.)*0.34;  // Ramping it up.\n    \n    float spec = pow(max(dot(reflect(ld, sn), rd), 0.), 8.); // Specular light value.\n    \n    /////\n    // The blinking light section. All of it is made up.\n    // Basically, we're adding a unit refracted vector to the hit position, then passing it into a\n    // cylindrically mapped Voronoi function, smoothing, then colorizing.\n    vec3 ref = sp + refract(rd, sn, 1./1.6);\n    vec2 tuv = vec2(atan(ref.y, ref.x)/6.2832, ref.z/8.);\n    float c2 = Voronoi(tuv*4. - vec2(1, .5)*iTime, 4.);\n    c2 = smoothstep(0.8, 1., 1.-vx);\n        \n    vec3 elec = (objCol*.7 + .3)*pow(min(vec3(1.5, 1, 1)*c2, 1.), vec3(1,  3, 8)); // Fiery coloring.\n        \n    if (svObjID<.5) objCol += elec*8.; // Add a lot of the color to the bulbs.\n    else objCol += elec*2.; // Add a little to the webbing.\n    //////////\n    \n\n    // Using the values above to produce the layer color.\n    col += (objCol*(diff*vec3(1, .97, .92)*2. + 0.25) + vec3(1, .6, .2)*spec*2.)*atten;// + env*atten;\n\n    // Adding some fake reflection to the walls.\n    ref = reflect(rd, sn);\n    float rc = n3D(ref*2.);\n    col += col*smoothstep(.3, 1., rc)*4.*atten;\n    \n    // Darkening the edges. Without it, the scene would lose its mild cartoony look.\n    col *= 1. - edge*.7;\n    \n    \n    //col = mix(col, vec3(2, 1.5, 1).zyx, 1. - exp(-.002*sDist*sDist)); // Blue fog, if you prefer.\n    col = mix(col, vec3(0), 1. - exp(-.002*sDist*sDist)); // Extra fog at the end of the tunnel.\n    \n    // Gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mly3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1233, 1298, 1319, 1319, 1387], [1390, 1533, 1551, 1551, 1897], [1899, 1921, 1951, 2032, 2911], [2924, 3126, 3160, 3160, 4096], [4112, 4142, 4172, 4308, 4574], [4577, 4662, 4735, 4735, 6061], [6064, 6140, 6171, 6171, 6395], [6397, 6447, 6502, 6502, 7027], [7031, 7031, 7087, 7230, 11553]], "test": "valid"}
{"id": "Mly3zc", "name": "Stretchy Cuboid Lightup", "author": "jfuchs", "description": "My first attempt at 3D graphics programming. Made for my first quarter project in my senior year high school programming class. Amateur programming all around; feedback much appreciated.", "tags": ["raycasting", "beginner", "colorful", "cuboid"], "likes": 1, "viewed": 556, "published": "Public API", "date": "1475851504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Made by Jonathan Fuchs, October 7th 2016\n//No copyright, so feel free to use this code wherever. Even if I don't expect anyone to.\n//Sorry if I got a bit silly with the comments.\n\n#define T iTime\n\nvec4 quatMultiply(vec4 q1, vec4 q2){\n    return vec4(q1.x*q2.x - dot(q1.yzw, q2.yzw), q1.yzw*q2.x + q2.yzw*q1.x + cross(q1.yzw, q2.yzw));\n}\n\nvec3 quatRotate(vec3 p, vec4 q){\n    return quatMultiply(quatMultiply(q, vec4(0, p)),vec4(q.x, -q.yzw)).yzw;\n}\n\n//Quaternion maths courtesy of http://www.3dgep.com/understanding-quaternions/\n\nvoid initPoints(out vec3[4] points, vec3 size, vec4 orientation){\n    //Four points are needed to define a cuboid.\n    points[0] = -size;\n    points[1] = vec3(size.x, -size.yz);\n    points[2] = vec3(-size.x, size.y, -size.z);\n    points[3] = vec3(-size.xy, size.z);\n    for(int i = 0; i < 4; i++){\n        points[i] = quatRotate(points[i], orientation);\n    }\n}\n\nvoid initFaces(out vec4[6] faces, vec3[4] points){\n    //Faces are planes defined by <a, b, c, d>, where ax + by + cz + d = 0.\n    //The boundaries of the faces are determined by the points.\n    vec3 normal = cross(points[1] - points[0], points[2] - points[0]);\n    faces[0] = vec4(normal, -dot(normal, points[0]));\n    faces[3] = vec4(faces[0].xyz, faces[0].w - dot(normal, points[3] - points[0]));\n    normal = cross(points[2] - points[0], points[3] - points[0]); \n    faces[1] = vec4(normal, -dot(normal, points[0]));\n    faces[4] = vec4(faces[1].xyz, faces[1].w - dot(normal, points[1] - points[0]));\n    normal = cross(points[3] - points[0], points[1] - points[0]); \n    faces[2] = vec4(normal, -dot(normal, points[0]));;\n    faces[5] = vec4(faces[2].xyz, faces[2].w - dot(normal, points[2] - points[0]));\n}\n\nvec4 background(){\n    //Lame shifting color background to fill up the rest of the screen.\n    vec4 backColor = vec4(1,1,1,1);\n    float t15 = mod(T, 15.0);\n    float t5 = mod(T, 5.0);\n    vec3 colorShift = vec3(cos(0.314*t5), sin(0.314*t5), 0);\n    if(t15 < 5.0) backColor -= colorShift.xyzz;\n    else if(t15 < 10.0) backColor -= colorShift.zxyz;\n    else backColor -= colorShift.yzxz;\n    backColor.xyz /= 4.0;\n    return backColor;\n}\n\nvec4 castRay(vec3 dir, vec3 points[4], vec4 faces[6], vec4 colors[6]){\n    //I opted for plain raycasting instead of raymarching because I thought it would improve perfomance.\n    //But I'm a terrible graphics programmer, so that didn't turn out to be the case. Oh well.\n    \n    vec3 u[6]; vec3 v[6];\n    //The components of the faces. There has to be a better way to do this...\n    u[0] = points[1] - points[0]; v[0] = points[2] - points[0];\n    u[1] = points[2] - points[0]; v[1] = points[3] - points[0];\n    u[2] = points[3] - points[0]; v[2] = points[1] - points[0];\n    u[3] = points[0] - points[1]; v[3] = points[0] - points[2];\n    u[4] = points[0] - points[2]; v[4] = points[0] - points[3]; \n    u[5] = points[0] - points[3]; v[5] = points[0] - points[1];\n    \n    const vec3 camera = vec3(0, 0, 5);\n    float minT = 1e20;\n    int bestFace = -1;\n    float bestA;\n    float bestB;\n    \n    for(int i = 0; i < 6; i++){ //Iterating over the faces.\n        float t = -(faces[i].w + dot(faces[i].xyz, camera))/(dot(faces[i].xyz, dir));\n        //The distance to the point of intersection with a face. I guess the formula works?\n        if(t < minT && t > 0.0){\n        \tvec3 p = camera + dir*t; //The actual point of intersection.\n        \tif(i < 3) p = p - points[0];\n        \telse p = p + points[0];\n            //...And adjusting it so that the following formulas will work.\n        \tfloat a = (p.x*v[i].y - p.y*v[i].x)/(u[i].x*v[i].y - u[i].y*v[i].x);\n        \tfloat b = (p.x*u[i].y - p.y*u[i].x)/(u[i].y*v[i].x - u[i].x*v[i].y);\n            //a and b are the distances along the face components to the point.\n            //I would use matrices here, but I don't know any linear algebra :(\n            if(a >= 0.0 && a < 1.0 && b >= 0.0 && b < 1.0){\n                //Checking to see if the point of intersection is actually on the face.\n                minT = t;\n            \tbestFace = i;\n                bestA = a;\n                bestB = b;\n            }\n        }      \n    }\n    //What do you mean, non-constant array indices aren't allowed? Guess there's this workaround...\n    for(int i = 0; i < 6; i++){\n        if(bestFace == i) return texture(iChannel0, vec2(bestA, bestB)) * colors[i];\n        //Finally returning the point on the face intersecting the ray.\n    }\n    return background();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 size = vec3(1.0, 1.0, 1.0);\n    vec4 colors[6];\n\tcolors[0] = vec4(0.8,0.5,0.5,1); colors[1] = vec4(0.5,0.8,0.5,1); colors[2] = vec4(0.5,0.5,0.8,1);\n\tcolors[3] = vec4(0.5,0.8,0.8,1); colors[4] = vec4(0.8,0.5,0.8,1); colors[5] = vec4(0.8,0.8,0.5,1);\n    \n    \n    float t3 = mod(T, 3.0);\n    float t1 = mod(T, 1.0);\n\tvec2 deform = vec2(sin(3.14*t1)/2.0, -sin(3.14*t1)/3.0);\n    vec3 lightup = vec3(sin(3.14*t1)/5.0, -sin(3.14*t1)/2.0, 0);\n    //Performing the stretchy and light-up effects.\n    if(t3 < 1.0){\n        size += deform.yyx;\n        colors[0] += lightup.xyyz;\n        colors[3] += lightup.yxxz;\n    }\n    else if(t3 < 2.0){\n        size += deform.xyy;\n        colors[1] += lightup.yxyz;\n        colors[4] += lightup.xyxz;\n    }\n    else{\n        size += deform.yxy;\n        colors[2] += lightup.yyxz;\n        colors[5] += lightup.xxyz;\n    }\n    \n    float angle = T;\n    vec3 rotAxis = normalize(vec3(cos(T/3.0),sin(T/3.0),-sin(T/3.0))); //Chaotic rotation\n    vec4 rotQuat = vec4(cos(angle), sin(angle)*rotAxis);\n    \n    vec3 points[4];\n\tinitPoints(points, size, rotQuat); //Initializing points...\n    vec4 faces[6];\n    initFaces(faces, points); //Initializing faces...\n    vec2 fov = fragCoord.xy / iResolution.y;\n    fov = fov - vec2(iResolution.x/iResolution.y/2.0, 0.5); //Calculating field of view...\n    fragColor = castRay(vec3(fov, -1), points, faces, colors); //Done! :D\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mly3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 199, 235, 235, 338], [340, 340, 372, 372, 450], [452, 532, 597, 646, 893], [895, 895, 945, 1085, 1707], [1709, 1709, 1727, 1799, 2145], [2147, 2147, 2217, 2417, 4457], [4459, 4459, 4516, 4516, 5921]], "test": "error"}
{"id": "MlyGDd", "name": "Smooth RadClick Cristal Lattice", "author": "aiekick", "description": "Use mouse to see the Corresponding Smooth Variation of the 4 patterns. ", "tags": ["tunnel", "smooth", "cristal", "radclick"], "likes": 9, "viewed": 680, "published": "Public API", "date": "1477428143", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n//#define USE_SPECIFIC_POINT_INSTEAD_MOUSE\n\n/*\n\tSmooth RadClick Cristal Tunnel (Radial Click)\n\t\n\tBy Smooth Radial Click, i would say that the shader is divided here in four section.\n\tEach sections have is own Ray Marching Pattern and own Coloration\n\tWith the mouse you can show on the entire screen the section you are under the mouse.\n\t\n\tThe particularity of the Smooth Radial Click, is each section is Mixed according to the range of each Section, \n\tso you have no discontinuity and you have Ray Marching Merged Scene radially.\n\t\n\tThis tech come from my first experiment 2D but extended to the 3d and its cool with the tunnels.\n\t\n\tThe Based 2D Shader : 2D Hex Smooth RadClick\n\thttps://www.shadertoy.com/view/XlK3W1\n*/\n\n// count radial section. \n// with this you can have more section. \n// more sections need more id check, but the tech is exactly the same\nconst float sections = 4.; \t\n\n// some varas\nfloat time = 0.;\t\t\t\t// time\nfloat cid = 0., lid = 0.; \t// current id, last id\nmat3 m1;\t\t\t\t\t\t// matrix used by the pattern merging\nmat3 m2;\t\t\t\t\t\t// matrix used by the pattern merging\n\n// Matrix operations\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\n// tunnel and cam path\nvec2 path(float t){return vec2(cos(t*0.08), sin(t*0.08)) * 4.;}\n\n// continuous angle from atan\nfloat cAtan(vec2 uv)\n{\n\tfloat a = 0.;\n\tif (uv.x >= 0.) a = atan(uv.x, uv.y);\n    if (uv.x < 0.) a = 3.14159 - atan(uv.x, -uv.y);\n    return a;\n}\n\n// return id of region \nfloat GetID(vec2 uv) \n{\n    return cAtan(uv) * floor(sections) * .5 / 3.14159;\n}\n\n// one pettern for each ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat pattern(vec3 p, mat3 m, float s, float id)\n{\n\tfloat r = 0.;\n\tp = abs(fract(p*m*s) - 0.5);\n\tif (id > 3.) r= max(min(abs(p.x),abs(p.z)),abs(p.y));\n    else if (id > 2.) r= max(p.x,abs(p.y)+p.z);\n\telse if (id > 1.) r= length(p);\n    else if (id > 0.) r= max(p.x,-p.y);\n\treturn r;\n}\n\n// redirect dispalce func according to ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat displace(vec3 p, float id)\n{\n\tvec3 a = vec3(0), b = a;\n\tif (id > 3.) a = vec3(-0.32,0.5,.5), b = vec3(0);\n    else if (id > 2.) a = vec3(0.46,0.42,-1.5), b = vec3(0);\n    else if (id > 1.) a = vec3(0.36,0.2,-2.28), b = vec3(0.36,0.24,1.62);\n\telse if (id > 0.) a = vec3(0.62,0.62,-1.02), b = vec3(0);\n        \n    return \n        (1.-min(pattern(p, m1, a.x, id), pattern(p, m2, a.y, id))) * a.z + \n    \t(1.-min(pattern(p, m1, b.x, id), pattern(p, m2, b.y, id))) * b.z;\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\t\t\t\t\t\t\t\t\t\t\t\t\t// tunnel path\n\t\n    // mix from displace of last section id with displace of current section id accroding to id range \n    float r = mix(displace(p, lid), displace(p, cid), fract(cid)); \t// id range [0-1]\n\t\n    p *= getRotZMat(p.z*0.05);\n\t\n    p = mod(p, 10.) - 5.;\n    \n    // tunnel + dispalce\n\treturn vec4(\n        min(\n            min(\n                length(p.xy), \n                length(p.xz)), \n            length(p.yz)\n        ) - 1. + r, p);\n}\n\nvec3 nor( vec3 pos, float k)\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn map(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// color arangement is what i choose\n// its easy to have another coloration wothout modified the lighting.\n// here is an easy way i choose, but you can do alterate more as you want\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nvec4 params(vec4 f, float id)\n{\n\tvec4 c = f;\n    if (id > 3.) c = f.zwyw; \n    else if (id > 2.) c = f.zyzw; \n    else if (id > 1.) c = f.yzyx; \n    else if (id > 0.) c = f.xyzw; \n    return c;\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.001, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// blackbody color according to the subdensity value\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\t\t\t\t\t// use bumpmap fnc of shane here\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 5.) * 0.5; \t\t\t\t\t// one step sub density of df\n\treturn vec4(\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// some mix of WTF :) i tried many different things and this i choose :) but maybe there is other things to do\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\n// get cam \n// g will be gl_FragCoord.xy or uMouse.xy\n//  si is screensize\nvec3 cam(vec2 g, vec2 si, vec3 ro, vec3 cv)\n{\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n\t// matrix used by the pattern\n    m1 = mx * my * mz;\n    m2 = m1 * m1;\n\t\n    time = iTime * 4.;\n    \n    vec3 cu = vec3(0,1,0);\t\t\t\t\t\t\t\t\t\t\t// Camera Up\n  \tvec3 cv = vec3(path(time + .1),time + .1); \t\t\t\t\t// Camera View\n    //cv *= getRotXMat(time * 0.2) * getRotYMat(time * 0.2);\n\tvec3 ro = vec3(path(time),time);\t\t\t\t\t\t\t\t// Camera Origin\n\tvec3 lp = vec3(path(ro.z + 7.),ro.z + 7.); \t\t\t\t\t// light point\n    vec3 cp = vec3(path(ro.z + 25.2),ro.z + 25.2); \t\t// center point for Smooth RadClick\n\tvec3 rd = cam(g, si, ro, cv);\t\t\t\t\t\t\t\t\t// Camera Direction\n\n\t// center point for calculate section id accroding to the tunnel path\n\tvec2 rdID = rd.xy - normalize(cp-ro).xy;\n\t\n#ifndef USE_SPECIFIC_POINT_INSTEAD_MOUSE\n\t// same center point accroding to the mouse pos\n\t// its permit to shwo for the whole screen the current scene with the ID return by mouse\n\tif (iMouse.z > 0.) \n\t\trdID = cam(iMouse.xy, si, ro, cv).xy - normalize(cp-ro).xy;\n#else\n\trdID = cam(si*0.5, si, ro, cv).xy - normalize(cp-ro).xy;\n#endif\n\n\t// radial section id\n    float id = GetID(rdID); // 0 to 4\n\n    // circular sections id \n    cid = id; \t\t\t\t\t\t\t\t\t// current section id\n\tlid = cid - 1.; \t\t\t\t\t\t\t// last section id\n\tif (lid < 0.) lid = id + sections - 1.;\t// circular \n\t\n\t// Ray Marching\n    float s = 1.;\n    float d = 0.;\n    for(int i=0;i<60;i++)\n    {      \n        if (log(d*d/s/1e5)>0.) break;\n        d += s = map(ro+rd*d).x * .6;\n    }\n\t\n\t// Color\n    f = shade(ro, rd, d, lp);\n\t\n\t// mix Color Arangement according to Radial Section Range \n\t// mix from params of last section id with params of current section id \n\t// according to the range between the two sections with fract(cid) => range 0 to 1\n\tf = mix(params(f, lid), params(f, cid), fract(cid)); // id range [0-1]\n\t\n\t// improve light a little bit\n\tf = f + f.x*0.3;\n\n\t// fog for hide some ray marching artifact cause by the low count iteration (60 here )\n    f = mix( f, vec4(0.8), 1.0-exp( -0.001*d*d ) );\n        \n\t// gamma correction for add some contrast without saturation\n   \tfragColor = sqrt(f*f*f*2.); // gamma correction\n\t\n\t// show center point for hide the convergent point of the radial color mix \n\tfragColor += 0.0003/dot(rdID,rdID);\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyGDd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1281, 1302, 1327, 1327, 1385], [1386, 1386, 1411, 1411, 1469], [1470, 1470, 1495, 1495, 1553], [1555, 1578, 1597, 1597, 1641], [1643, 1673, 1695, 1695, 1817], [1819, 1843, 1866, 1866, 1923], [1925, 2036, 2086, 2086, 2320], [2322, 2448, 2482, 2482, 2923], [2925, 2925, 2943, 2943, 3430], [3432, 3432, 3462, 3462, 3677], [3679, 3900, 3928, 3928, 4253], [4255, 4337, 4394, 4394, 4618], [4620, 4620, 4656, 4656, 4792], [4794, 4970, 5021, 5021, 5192], [5194, 5403, 5466, 5466, 5934], [5936, 6201, 6232, 6232, 6396], [6398, 6398, 6446, 6446, 7564], [7566, 7641, 7686, 7686, 7881], [7883, 7883, 7940, 7940, 10289]], "test": "error"}
{"id": "Mt3Szr", "name": "Fractal Thingy", "author": "Klems", "description": "trying to reverse engineer [url]https://www.shadertoy.com/view/XlX3Rj[/url] by looking at it, click and drag to scroll", "tags": ["2d", "fractal", "fold"], "likes": 47, "viewed": 1308, "published": "Public API", "date": "1477709167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PHI 1.61803398875\n\n// fabrice's rotation matrix\nvec2 V;\n#define rot(a) mat2( V= sin(vec2(1.57, 0) + a), -V.y, V.x)\n\n// iq's HSV\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// hexagonal distance\nfloat hexDist(vec2 p) {\n    #define MULT1 (1.0/tan(PI/3.0))\n\t#define MULT2 (1.0/sin(PI/3.0))\n\tfloat dx = abs(p.x);\n\tfloat dy = abs(p.y);\n\treturn max(dx+dy*MULT1, max(dx, dy*MULT2));\n}\n\nvec4 fractal( in vec2 p ) {\n    \n    // keep current scale\n    float scale = 1.0;\n    \n    // used to smoothstep\n    float aliasBase = 1.0 / iResolution.y;\n    \n    // accumulated alpha\n    float alpha = 0.0;\n    // accumulated color\n    vec3 color = vec3(0.0);\n  \n    #define LEVELS 10\n    for (int i = 0 ; i < LEVELS ; i++) {\n        \n        // scale\n        float s = 2.0;\n\t\t\n        // repeat axis according to scale ala TEXTURE_ADDRESS_MIRROR\n        p = 1.0 - abs(s*fract(p-0.5)-s*0.5);\n        \n        // fold\n        float theta = float(i) * PI * 0.125;\n        //theta = iTime*0.02 * float(i); // try this one\n        p *= rot(theta);\n        \n        // update scale\n        scale *= s;\n        \n        // jump first steps cause they're less interesting\n        if (i < 4) continue;\n        \n        // texture\n        \n        // borders\n        vec2 uv = abs(p);\n        float delt1 = abs((hexDist(uv)-0.6)-0.1);\n        float delt2 = min(length(uv)-0.2, min(uv.x, uv.y));\n        float m = min(delt1, delt2);\n        float alias = aliasBase*0.5*scale;\n        float f = smoothstep(0.10+alias, 0.10, m)*0.4 + smoothstep(0.22, 0.11, m)*0.6;\n        \n        // pulse\n        float r = length(uv)/0.707106;\n        float t = mod(iTime*1.5, float(LEVELS-4)*2.0) - float(i);\n        r = (r + 1.0 - t)*step(r*0.5, 1.0);\n        r = smoothstep(0.0, 0.8, r) - smoothstep(0.9, 1.0, r);\n        \n        // mix colors\n        vec3 c = vec3(smoothstep(0.06+alias, 0.06, m));\n        vec3 hue = hsv2rgb( vec3(iTime*0.03+float(i)*0.08, 0.5, 1.0) );\n        c = c*hue;\n        c += c*r*1.5;\n        \n        // front to back compositing\n        color = (1.0-alpha)*c+color;\n        alpha = (1.0-alpha)*f+alpha;\n        \n    }\n    \n    return vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec2 p = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    if (iMouse.z < 0.5)\n    \tuv += vec2(0.4487, 0.17567)*(iTime+10.3312);\n    else\n        uv -= (iMouse.xy-iResolution.xy*0.5)*0.015;\n    \n\tuv *= 0.07;\n    \n    vec4 frac = fractal(uv);\n    \n    // mix fractal with a grey background\n    fragColor.rgb = mix(vec3(0.5), frac.rgb, frac.a);\n    // vignette\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(p, p)*0.5);\n    \n    fragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3Szr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 161, 188, 188, 344], [346, 368, 391, 391, 551], [553, 553, 580, 611, 2318], [2320, 2320, 2377, 2377, 2899]], "test": "valid"}
{"id": "MtcSzn", "name": "CS8EC", "author": "4onen", "description": "Simple line drawing animation of n-sided polygons for extra credit in the UCSB CS8 class.", "tags": ["procedural", "2d"], "likes": 16, "viewed": 353, "published": "Public", "date": "1477692805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Made by Matthew Dupree for fun. No profit, no credit.\n\n//Don't try stealing this to use for credit in CS8.\n//For one thing, you're probably not the only person in the class to find this.\n//If you both submit it and say \"Hey, look how smart we are!\" you two will\n//look pretty dumb to the academic counseling office.\n\n//Also, this is written in the wrong language. Go do your assignment in Python.\n\n//P.P.S. I know Python has an OpenGL library that could theoretically run this code\n//under the hood. That's not going to work either. The ShaderToy environment is\n//too complicated for someone in CS8 to replicate on-the-fly in Python.\n\n//Good luck!\n\n\n\n\n//The actual number of sides each polygon has in the shadertoy\n#define SIDE_COUNT 4\n//---------------------------------\n//CHANGE THE ABOVE VALUE FOR FUN!\n//---------------------------------\n\n//The maximum number of sides the polygon can have.\n//Necessary because loop counters can't be compared to dynamic numbers as the break condition.\n//Weird things happen if this is lower than SIDE_COUNT\n#define MAX_POLY_SIDE_COUNT 16\n\n//Pi. Does this really need explanation?\n#define PI 3.14159265358979323846264338\n\n//Used to rotate things.\n//Returns a matrix that'll rotate a vector2 by angle radians about the origin.\nmat2 rotation(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s\n               ,s,  c);\n}\n\n//Returns 1.0 when in the bounding box given\nfloat inBB(vec2 r, vec2 p1, vec2 p2){\n    if(((r.x<p1.x && r.x<p2.x)||(r.x>p1.x && r.x>p2.x))\n       ||(r.y<p1.y && r.y<p2.y)||(r.y>p1.y && r.y>p2.y))\n       return 0.0;\n    else\n       return 1.0;\n}\n\n//Returns 1.0 when in the _rectangle_ given\nfloat smoothProperRect(vec2 r, vec2 topLeft, vec2 botRight, float edgeBlur){\n    float ret;\n    ret  = smoothstep(topLeft.x-edgeBlur, topLeft.x+edgeBlur, r.x);\n    ret *= smoothstep(topLeft.y-edgeBlur, topLeft.y+edgeBlur, r.y);\n    ret *= 1.0 - smoothstep(botRight.y-edgeBlur, botRight.y+edgeBlur, r.y);\n    ret *= 1.0 - smoothstep(botRight.x-edgeBlur, botRight.x+edgeBlur, r.x);\n    return ret;\n}//Does the same, but doesn't require that you set the edge blur.\nfloat smoothProperRect(vec2 r, vec2 topLeft, vec2 botRight){\n    return smoothProperRect(r,topLeft,botRight,0.005);\n}\n\n//Returns 1.0 at the very center of the given circle, dropping linearly to the edge.\nfloat smoothPointBloom(vec2 r, vec2 center, float radius){\n    return 1.0-smoothstep(0.0,radius,length(center-r));\n}\n\n//Returns 1.0 when on the line given\nfloat line(vec2 r, vec2 p1, vec2 p2, float lineWidth){\n    vec2 midpointRSpace = (p1.xy+p2.xy)/2.0;\n    \n    float angle = atan((p1.y-p2.y)/(p1.x-p2.x));\n    \n    vec2 rotatedSpaceCord = (r-midpointRSpace)*rotation(-angle);\n    \n    float lineLength = length(p1-p2);\n    \n    return smoothProperRect(\n        rotatedSpaceCord,\n        vec2(-lineLength/2.0,-lineWidth/2.0),\n        vec2(lineLength/2.0,lineWidth/2.0),\n        lineWidth\n    );\n}\n\n//Returns 1.0 when on the described polygon's edge.\nfloat polygonWireframe(vec2 r, vec2 center, float radius, int sideCount, float lineWidth){\n    //If we're outside any possible radius, break.\n    if(length(r.xy-center.xy)>radius+lineWidth) return 0.0;\n    //If the side count makes no sense, break.\n    if(sideCount<1) return 0.0;\n    \n    float ret = 0.0;\n    \n    //Point radius length up from center:\n    vec2 p0 = vec2(0.0, radius);\n    //Angle of rotation swept by each edge:\n    float angle = 2.0*PI/float(sideCount);\n    \n    //Loop all possible sides\n    for(int i=0;i<MAX_POLY_SIDE_COUNT;i++){\n        //Loop all given sides\n        if(i>=sideCount) break;\n        vec2 p1 = p0*rotation(angle*float(i));\n        vec2 p2 = p1*rotation(angle);\n        ret += line(r, p1+center, p2+center, lineWidth);\n    }\n    return ret;\n}\n\n//Returns 1.0 if the given point is on one of the lines of the described polygons.\n//Used to render polygons at each tip of a given polygon.\nfloat polyPointedPoly(vec2 r, vec2 center, float radius, int sideCount, float lineWidth){\n    if(length(r.xy-center.xy)>radius+(radius*2.0/float(sideCount))+lineWidth) return 0.0;\n    \n    if(sideCount < 1) return 0.0;\n    \n    float ret = 0.0;\n    \n    vec2 p0 = vec2(0.0, radius);\n    float angle = 2.0*PI/float(sideCount);\n    \n    for(int i=0; i<MAX_POLY_SIDE_COUNT;i++){\n        if(i>=sideCount) break;\n        vec2 p1 = p0*rotation(angle*float(i));\n        ret += polygonWireframe(r, center+p1, radius*2.0/float(sideCount), sideCount, lineWidth);\n    }\n    return ret;\n}\n\n//Returns a vector 2 representing the position of this polygon's sideNumth vertex.\nvec2 getPolyPointN(vec2 center, float radius, int sideCount, int sideNum){\n    vec2 p0 = vec2(0.0, radius);\n    float angle = 2.0*PI/float(sideCount);\n    return center + p0*rotation(angle*float(sideNum));\n}\n\n//Returns a vector 2 representing the position of this polygon's sideNumth point,\n//adjusted for time to linearly phase toward the next side number.\n//Valid time values are 0.0 to 1.0\nvec2 getPolyPointNTimeAdjust(vec2 center, float radius, int sideCount, int sideNum, float time){\n    vec2 p0 = getPolyPointN(center, radius, sideCount, sideNum);\n    vec2 p1 = getPolyPointN(center, radius, sideCount, sideNum + 1);\n    return p0*time+p1*(1.0-time);\n}\n\n//Returns a vector2 representing the position of the sideNumth point of the polyNumth polygon,\n//adjusted for time to linearly phase toward the next side number.\n//Valid time values are 0.0 to 1.0\nvec2 getPolyOfPolysPointNTimeAdjust(vec2 center, float radius, int sideCount, int polyNum, int sideNum, float time){\n    vec2 p0 = vec2(0.0, radius);\n    float angle = 2.0*PI/float(sideCount);\n    vec2 p1 = p0*rotation(angle*float(polyNum));\n    return center + getPolyPointNTimeAdjust(p1, radius*2.0/float(sideCount), sideCount, sideNum, time);\n}\n\n//Main image, GLSL entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Define our grid space\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    //Make an aspect ratio out of it and align the origin to the center of the screen\n    vec2 r = 1.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/(iResolution.y);\n    \n    //The current time, in two second loops.\n    float time = mod(iTime,2.0)/2.0;\n    \n    //A list of colors. Have fun messing with these!\n    const vec3 bgColor = vec3(0.25,0.0,0.3);\n    const vec3 polyColor = vec3(5.0,0.0,5.0);\n    const vec3 lineColor = vec3(1.0,0.99,1.0);\n    const vec3 capColor = vec3(1.0);\n    \n    const vec2 center = vec2(0.0);\n    const float radius = 0.3;\n    \n    vec3 ret = bgColor;\n    ret = mix(ret,polyColor,polyPointedPoly(r, center, radius, SIDE_COUNT, 0.001));\n    for(int side=0; side<MAX_POLY_SIDE_COUNT; side++){\n        if(side>=SIDE_COUNT) break;\n        \n        for(int poly=0; poly<MAX_POLY_SIDE_COUNT; poly++){\n            if(poly>=SIDE_COUNT) break;\n            \n            vec2 p0 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, poly, side, time);\n            vec2 p1 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, poly+1, side+1, time);\n            ret = mix(ret, lineColor, line(r, p0, p1, 0.002));\n            ret = mix(ret, capColor, smoothPointBloom(r, p0, 0.01));\n        }\n    }\n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1161, 1265, 1292, 1292, 1392], [1394, 1439, 1476, 1476, 1638], [1640, 1684, 1760, 1760, 2081], [2081, 2146, 2206, 2206, 2263], [2265, 2350, 2408, 2408, 2466], [2468, 2505, 2559, 2559, 2948], [2950, 3002, 3092, 3143, 3783], [3785, 3926, 4015, 4015, 4502], [4504, 4587, 4661, 4661, 4794], [4796, 4980, 5076, 5076, 5246], [5248, 5445, 5561, 5561, 5792], [5794, 5825, 5882, 5910, 7217]], "test": "valid"}
{"id": "MtdXzr", "name": "Ultra Liquid Bokeh", "author": "weyland", "description": "Messing around with iq's bubbles to get endless bokeh variations and nice colorchannel interactions", "tags": ["procedural", "2d", "bokeh", "bubbles"], "likes": 47, "viewed": 2240, "published": "Public API", "date": "1477935761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013 : https://www.shadertoy.com/view/4dl3zn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Messed up by Weyland\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n      uv.x *=  iResolution.x / iResolution.y;\n      vec3 color = vec3(0.0);\n      for( int i=0; i<128; i++ )\n      {\n        float pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n        float siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n        float pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n        float rad = 0.1+0.5*siz+sin(pha+siz)/4.0;\n        vec2  pos = vec2( pox+sin(iTime/15.+pha+siz), -1.0-rad + (2.0+2.0*rad)*mod(pha+0.3*(iTime/7.)*(0.2+0.8*siz),1.0));\n        float dis = length( uv - pos );\n        vec3  col = mix( vec3(0.194*sin(iTime/6.0)+0.3,0.2,0.3*pha), vec3(1.1*sin(iTime/9.0)+0.3,0.2*pha,0.4), 0.5+0.5*sin(float(i)));\n        float f = length(uv-pos)/rad;\n        f = sqrt(clamp(1.0+(sin((iTime)*siz)*0.5)*f,0.0,1.0));\n        color += col.zyx *(1.0-smoothstep( rad*0.15, rad, dis ));\n      }\n      color *= sqrt(1.5-0.5*length(uv));\n      fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdXzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 189, 246, 246, 1234]], "test": "valid"}
{"id": "MtG3WV", "name": "Pappus Chain", "author": "Patapom", "description": "Pappus chain generated using the circle inversion procedure described in the Numberphile episode called \"Epic Circles\" presented by Simon Pampena.\nCheck it out: https://www.youtube.com/watch?v=sG_6nlMZ8f4\n", "tags": ["circle", "inversion", "chain", "pappus"], "likes": 3, "viewed": 111, "published": "Public", "date": "1476789779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shader inspired by the Numberphile episode \"Epic Circles\"\n// https://www.youtube.com/watch?v=sG_6nlMZ8f4\n//\n#define ANIMATE\t\t\t// Funky animation\n#define FILL_OUTSIDE\t// Fill outside of unit circle\n\n// Here we build the Pappus chain inside the unit circle\n// We notice the Pappus chain's circles, once projected using circle inversion based on a unit circle\n//\tcentered in (0,-1) give an infinite series of circles aligned within the band V€[-0.5,0.0]\n// By projecting each UV within the unit circle and retrieving its position within the band,\n//\twe can know which circle it belongs to...\n//\nvec3 ComputeInnerColor( vec2 _uv, float _radius ) {\n    \n    // Invert using circle located at the bottom of our unit circle\n    #ifdef ANIMATE\n\t\tvec2\tinversionCircleCenter = vec2( 0.5*cos(iTime), -0.5+0.5*sin(iTime) );\n    #else\n    \tvec2\tinversionCircleCenter = vec2( 0.0, -1.0 );\n    #endif\n\n    vec2\trelativeUV = _uv - inversionCircleCenter;\n    float\tdist2Center = length( relativeUV );\n    vec2\tUV = relativeUV / (dist2Center * dist2Center);\n\n    // Isolate main circles of radius 0.25 along the V=0.75 line\n    vec2\tcirclesUV0 = 2.0 * vec2( UV.x, UV.y - 0.75 );\n\t\t\tcirclesUV0.x = fract( 0.5 + circlesUV0.x ) - 0.5;\n    float\tdist2Circles0 = 2.0 * length( circlesUV0 );\n\n    // Isolate secondary circles of radius 0.0625 along the V=1-0.0625 and V=0.5+0.0625 lines\n\tvec2\tcirclesUV1 = 2.0 * vec2( UV.x + 0.25, UV.y - 1.0 + 0.0625 );\n    float\tcircleIndex1 = floor( circlesUV1.x );\n\t\t\tcirclesUV1.x = fract( 0.5 + circlesUV1.x ) - 0.5;\n    float\tdist2Circles1 = 8.0 * length( circlesUV1 );\n\n\tvec2\tcirclesUV2 = 2.0 * vec2( UV.x + 0.25, UV.y - 0.5 - 0.0625 );\n    float\tcircleIndex2 = floor( circlesUV2.x );\n\t\t\tcirclesUV2.x = fract( 0.5 + circlesUV2.x ) - 0.5;\n    float\tdist2Circles2 = 8.0 * length( circlesUV2 );\n    \n    \n\tif ( dist2Circles2 < 1.0 )\n    \treturn vec3( 1, fract( 0.5 + 0.23 * abs(circleIndex2) ), 0.25 );\n\telse if ( dist2Circles1 < 1.0 )\n    \treturn vec3( 0, 0.1 + fract( 0.4 * abs(circleIndex1) ), 1 );\n\telse if ( dist2Circles0 < 1.0 )\n    \treturn vec3( dist2Circles0 );\n        \n\treturn vec3( 0.25 * dist2Center );\n}\n\n// For the points outside our unit circle, we simply reproject them inside the circle and sample its color there...\n// We know that d*D = 1 and we're given D outside of the unit circle\n// We simply find d = 1/D, the new distance inside the circle where to sample the inner color...\nvec3 ComputeOuterColor( vec2 _uv, float D ) {\n    #ifdef FILL_OUTSIDE\n\t    float\td = 1.0 / D;\n\t\tvec2\tinsideUV = _uv * d*d;\n    \treturn ComputeInnerColor( insideUV, d );\n    #else\n    \treturn vec3( 0.0 );\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    #ifdef ANIMATE\n        float\trotationAngle = -iTime;\n    #else\n        float\trotationAngle = 0.0;\n    #endif\n    vec2\trot = vec2( cos(rotationAngle), sin(rotationAngle) );\n    \n\tvec2\tuv = vec2( (iResolution.x / iResolution.y) * (2.0 * fragCoord.x / iResolution.x - 1.0),\n                      \t\t\t\t\t\t\t\t\t  2.0 * fragCoord.y / iResolution.y - 1.0 );\n\t   \t\tuv = vec2( uv.x * rot + uv.y * vec2( -rot.y, rot.x ) );\n   \n    #ifdef ANIMATE\n\t\tuv *= 2.0 + 1.0 * sin( iTime );\n    #endif\n    \n    float\tradius = length( uv );\n    \n    fragColor = vec4( radius < 1.0 ? ComputeInnerColor( uv, radius ) : ComputeOuterColor( uv, radius ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtG3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 597, 648, 721, 2134], [2136, 2418, 2463, 2463, 2634], [2636, 2636, 2693, 2693, 3330]], "test": "valid"}
{"id": "MtGGDc", "name": "All Seeing Eye", "author": "MickLH", "description": "Plotting the complex sine function with animated domain coloring.", "tags": ["mathematics", "complexplot"], "likes": 6, "viewed": 239, "published": "Public", "date": "1477114520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* <-- make the slash a double slash, good luck\n\n/// COSH Function (Hyperbolic Cosine)\nfloat cosh(float val)\n{\n    float tmp = exp(val);\n    float cosH = (tmp + 1.0 / tmp) / 2.0;\n    return cosH;\n}\n \n// TANH Function (Hyperbolic Tangent)\nfloat tanh(float val)\n{\n    float tmp = exp(val);\n    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n    return tanH;\n}\n \n// SINH Function (Hyperbolic Sine)\nfloat sinh(float val)\n{\n    float tmp = exp(val);\n    float sinH = (tmp - 1.0 / tmp) / 2.0;\n    return sinH;\n}\n//*/\n\nfloat hue2rgb(float p, float q, float t) {\n\tif(t < 0.0) t += 1.0;\n\tif(t > 1.0) t -= 1.0;\n\tif(t < 1.0/6.0) return p + (q - p) * 6.0 * t;\n\tif(t < 1.0/2.0) return q;\n\tif(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;\n\treturn p;\n}\nvoid HSL2RGB(out float r, out float g, out float b, float h, float s, float l) {\n\tif (abs(s) <= 0.0000001) {\n\t\tr = g = b = l; // achromatic\n\t} else {\n\t\tfloat q = (l < 0.5) ? l * (1.0 + s) : l + s - l * s;\n\t\tfloat p = 2.0 * l - q;\n\t\tr = hue2rgb(p, q, h + 1.0/3.0);\n\t\tg = hue2rgb(p, q, h);\n\t\tb = hue2rgb(p, q, h - 1.0/3.0);\n\t}\n}\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float sec = iTime;\n    float M_PI = 3.15159;\n    float sca = 1.0 + sin(iTime * 0.25) * 0.25;\n    float in_real = sca * (uv.x * 3.0 - 1.5) * iResolution.x / 640.0;\n\tfloat in_imag = sca * (uv.y * 3.0 - 1.5) * iResolution.y / 480.0;\n\tfloat out_real = sin(in_real) * cosh(in_imag);\n\tfloat out_imag = cos(in_real) * sinh(in_imag);\n\t\t\t\tfloat h = atan(out_imag, out_real) / (2.0 * M_PI);\n\t\t\t\tfloat s = abs(sin(2.0*M_PI*length(vec2(out_real,out_imag))));\n    float t2 = iTime * 0.2;\n    vec2 rm = vec2(t2*sin(t2)+cos(t2), t2*cos(t2)-sin(t2)) / 10.0;\n\t\t\t\tfloat l = sqrt(sqrt(abs(\n\t\t\t\t\tsin(2.0*M_PI*out_imag+rm.x)*\n\t\t\t\t\tsin(2.0*M_PI*out_real+rm.y)\n\t\t\t\t)));\n\t\t\t\tfloat omg = 1.0 / exp(l);\n\t\t\t\tfloat l1 = 0.5 * ((1.0 - s) + l + sqrt((1.0 - s - l)*(1.0 - s - l) + 0.01));\n\t\t\t\tl = 1.0 / (1.0 + l);\n\t\t\t\t\n\t\t\t\tfloat nl = (2.0 - s) * l;\n\t\t\t\ts *= l;\n\t\t\t\ts /= (l <= 1.0) ? l : (2.0 - l);\n\t\t\t\tl = nl / 2.0;\n    float fack = pow(sin(iTime) * 0.5 + 0.5, 5.0);\n\t\t s = 0.75 + fack;\n\t\t\t\n\t\t\t\tif (h < 0.0) h += 1.0 + ceil(-h);\n\t\t\t\th = mod(h, 1.0);\n\t\t\t\tfloat r=0.0, g=0.0, b=0.0;\n\t\t\t\tfloat r1=0.0, g1=0.0, b1=0.0;\n\t\t\t\tfloat r2=0.0, g2=0.0, b2=0.0;\n\t\t\t\tHSL2RGB(r,g,b,h,s,l);\n    float t3 = sin(iTime * 0.383)* 5.0 + 5.0;\n\t\t\t\th = mod(0.0 / 360.0, 1.0);\n\t\t\t\tHSL2RGB(r1,g1,b1,h,s,l);\n\t\t\t\th = mod(195.0 / 360.0, 1.0);\n\t\t\t\tHSL2RGB(r2,g2,b2,h,s,l);\n\n\t\t\t\tfloat t = omg - 0.5;\n\t\t\t\t\n\t\t\t\tr += (r1 + r2 + t * (r2 - r1));// / 2.0;\n\t\t\t\tg += (g1 + g2 + t * (g2 - g1));// / 2.0;\n\t\t\t\tb += (b1 + b2 + t * (b2 - b1));// / 2.0;\n    r/=3.0;g/=3.0;b/=3.0;\n\t\t\t\tomg *= mix(0.5, pow(sin(iTime * 0.5) * 0.5 + 0.5, 20.0), fack) * 0.25;\n\t\t\t\tr += r2 * omg;\n\t\t\t\tg += g2 * omg;\n\t\t\t\tb += b2 * omg;\n\n\tfragColor = vec4(b,g,r,1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mainImage2(fragColor, fragCoord);\n\n    //return; // UN-COMMENT THIS TO DISABLE AA\n   \n    float sp = 0.333;\n    vec4 aa1 = vec4(0.0);\n    vec2 fc2 = fragCoord + vec2(sp, sp);\n    mainImage2(aa1, fc2);\n    fragColor += aa1;\n    \n    //fragColor /= 2.0;return; // UN-COMMENT THIS USE 2x AA (Default = 5x)\n    \n    fc2 = fragCoord + vec2(sp, -sp);\n    mainImage2(aa1, fc2);\n    fragColor += aa1;\n    \n    fc2 = fragCoord + vec2(-sp, sp);\n    mainImage2(aa1, fc2);\n    fragColor += aa1;\n    \n    fc2 = fragCoord + vec2(-sp, -sp);\n    mainImage2(aa1, fc2);\n    fragColor += aa1;\n\n    fragColor /= 5.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 517, 559, 559, 751], [752, 752, 832, 832, 1078], [1079, 1079, 1137, 1137, 2850], [2851, 2851, 2908, 2908, 3511]], "test": "valid"}
{"id": "MtGGDK", "name": "Liquid Symmetry", "author": "guarajeno", "description": "Playing with rgb channels.", "tags": ["noise", "rgb", "liquid"], "likes": 5, "viewed": 223, "published": "Public", "date": "1476788044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 20.0\n#define time iTime * 0.7\n\nfloat hash( vec2 p)\n{\n    vec3 p2 = vec3(p.xy, 2.0);\n    return fract(sin(dot(p2, vec3(27.1, 20.7, 2.4))) * 0.5453123);\n}\n\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f *= f * (3.0 - 2.0 * f);\n    \n    return mix(mix(hash(i + vec2(0., 0.)), hash(i + vec2(1., 0.)), f.x),\n               mix(hash(i + vec2(0., 1.)), hash(i + vec2(1., 1.)), f.x),\n               f.y);\n}\n\nfloat random(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat range(float a, float b, float n)\n{\n    return a + (b - a) * random(n);\n}\n\nfloat lux(vec2 uv, float x, float y)\n{\n    float val = 0.011 / distance(uv, vec2(x, y));\n    return pow(val, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec4 color;\n    \n    for (float i = 0.0; i < N; i += 1.0)\n    {\n        float x = 2.0 * noise(vec2(range(0.9, 2.2, i + 0.1), time * range(0.9, 2.2, i + 0.2))) - 1.0;\n        float y = 2.0 * noise(vec2(range(0.9, 2.2, i + 0.3), time * range(0.9, 2.2, i + 0.4))) - 1.0;\n        \n        x *= 0.8;\n        y *= 0.8;\n        \n    \tcolor.r += lux(uv, -x, y);\n        color.b += lux(uv, x, -y);\n        color.g += lux(uv, x, y);\n    }\n    \n    color = step(0.55, color);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 62, 62, 162], [164, 164, 188, 188, 443], [445, 445, 468, 468, 509], [511, 511, 551, 551, 589], [591, 591, 629, 629, 707], [710, 710, 762, 762, 1352]], "test": "valid"}
{"id": "MtGGWc", "name": "10 years old nattou", "author": "tomohiro", "description": "I accidentally found something looks like worm when I was studying about simplex noise.\nThen, I added some code so that it looks like real worm.", "tags": ["2d", "simplexnoise"], "likes": 55, "viewed": 1350, "published": "Public API", "date": "1477075387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Number of layers.\n//Higher value shows more layers of effects.\n//Lower value higher FPS.\nconst int numLayers = 16;\n\n//Length of worm\nconst int wormLength = 8;\n\n//Write output color from anywhere to see value of temporary variable.\nvec3 cout;\n\nfloat rand(vec3 pos)\n{\n  vec3 p = pos + vec3(2.);\n  vec3 fp = fract(p*p.yzx*222.)+vec3(2.);\n  p.y *= p.z * fp.x;\n  p.x *= p.y * fp.y;\n  return\n    fract\n    (\n\t\tp.x*p.x\n    );\n}\n\nfloat skewF(float n)\n{\n/*\nn∈N\nX∈R^n\nX'∈R^n\nA∈R^n ∧ |A| = 1\ns∈R\nf is a non-uniform scaling along direction A and s is the scaling factor.\nf:R^n → R^n\nX' = f(X)\n   = X・A*s*A - X・A*A + X\n   = X・A*(s-1)*A + X\n\n∀B(B∈R^n ∧ B・A = 0 ⇒ f(X)・B = X)\n\nX' = f^-1(X)\n   = X・A*(1/s-1)*A + X\n\nf^-1(f(X)) = X\nX' = X・A*(s-1)*A + X\nX = X'・A*(1/s-1)*A + X'\n  = (X・A*(s-1)*A + X)・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(s-1)*(A・A)*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(1-s-1/s+1)*A          + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = -X・A*(s-1)*A - X・A*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X\n\nWhen creating simplex noise, A is a unit vector parallel to a unit hypercube's longest diagonal.\nA = (1/√(n), 1/√(n), ...)\n  = 1/√(n)(1, 1, ...)\n\nX' = f(X) = (s-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nIn skewed coordinate system, basis is not orthogonal.\nAny points P in skewed coordinate system such that P∈Z^n become a vertex of a simplex.\nIn the Cartesian coordinate, all edge of a simplex should have a same length.\nBut it is not possible in 3D and higher dimension.\nEquilateral triangle alone can fill space, but regular tetrahedra alone do not.\nFind 's' such that |f^-1((1, 0, 0, ...))| = |f^-1((1, 1, 1, ...))|\n|(1/s-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)/n*(1, 1, ...)・(1, 1, ...)*(1, 1, ...) + (1, 1, 1)|\n|(1/s-1)/n*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)*(1, 1, ...) + (1, 1, 1)|\n((1/s-1)/n+1)^2 + (((1/s-1)/n)^2)*(n-1) = ((1/s)^2)*n\n(1/s-1)*(1/s-1)/(n*n)+ 2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*(n-1)/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*n/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)/n = n/(s*s)\n(1/s-1)/n*(2 + (1/s-1)) + 1 = n/(s*s)\n(1/s-1)/n*(1 + 1/s) + 1 = n/(s*s)\n(1-s)/n*(s + 1) + s*s = n\n(1-s)*(s + 1) + s*s*n = n*n\n(n-1)*s*s + 1 = n*n\ns*s = (n*n - 1)/(n-1) = (n+1)(n-1)/(n-1) = n+1\ns = sqrt(n+1)\n\nX' = f(X) = (√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\nf^-1(X) = (1/√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nLength of edge of a simplex in Cartesian coordinate system:\n f^-1((1, 0, 0, ...))  = (1/√(n+1)-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)\n                       = (1/√(n+1)-1)/n*(1, 1, ...) + (1, 0, 0, ...)\n|f^-1((1, 0, 0, ...))| = √( ((1/√(n+1)-1)/n+1)^2 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n                       = √( ((1/√(n+1)-1)/n)^2 + 2*(1/√(n+1)-1)/n + 1 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n                       = √( (((1/√(n+1)-1)/n)^2)*n + 2*(1/√(n+1)-1)/n + 1 )\n                       = √( (1/√(n+1)-1)/n*(1/√(n+1)-1 + 2) + 1 )\n                       = √( (1/(n+1) - 1)/n + 1 )\n                       = √( -n/(n+1)/n + 1 )\n                       = √( -1/(n+1) + 1 )\n                       = √( n/(n+1) )\nhttps://www.wolframalpha.com/input/?i=sqrt(+((1%2Fsqrt(n%2B1)-1)%2Fn%2B1)^2+%2B+(((1%2Fsqrt(n%2B1)-1)%2Fn)^2)*(n-1)+)\n\nLength of edges of a simplex in Cartesian coordinate system in 3 or higher dimension are not equal.\nY∈{0,1}^n\nm = Y・(1, 1, ...)\nf^-1(Y) = m*(1/√(n+1)-1)/n*(1, 1, ...) + Y\n|f^-1(Y)| = √( ((m*(1/√(n+1)-1)/n+1)^2)*m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n          = √( ((m*(1/√(n+1)-1)/n)^2)*m + 2*m*m*(1/√(n+1)-1)/n + m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n          = √( ((m*(1/√(n+1)-1)/n)^2)*n + 2*m*m*(1/√(n+1)-1)/n + m )\n          = √( (m*(1/√(n+1)-1)/n)*( (m*(1/√(n+1)-1)) + 2*m ) + m )\n          = √( (m*(1/√(n+1)-1)/n)*m*( 1/√(n+1)+1 ) + m )\n          = √( m*m*(1/(n+1)-1)/n + m )\n          = √( m*m*(-n)/(n+1)/n + m )\n          = √( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*m/(n+1))/√( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0 when m = 0.5*(n+1)\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2/(n+1))/√( n/(n+1) )\n                = 0.5*(n-1)/√( n*(n+1) ) > 0 when m = 1\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*n/(n+1))/√( n/(n+1) )\n                = 0.5*(1-n)/√( n*(n+1) ) < 0 when m = n\n\nSo length of edge is shortest when m = 1 or m = n and other edge is longer than them.\n\nShortest distance between a vertex on simplex and the opposite edge:\nL = √( n/(n+1) )*√(3)/2\n\nReferences:\nhttps://en.wikipedia.org/wiki/Simplex_noise\nhttp://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n*/\n    return (sqrt(n + 1.0) - 1.0)/n;\n}\n\nfloat unskewG(float n)\n{\n    return (1.0/sqrt(n + 1.0) - 1.0)/n;\n}\n\nvec2 smplxNoise2DDeriv(vec2 x, float m, vec2 g)\n{\n    vec2 dmdxy = min(dot(x, x) - vec2(0.5), 0.0);\n\tdmdxy = 8.*x*dmdxy*dmdxy*dmdxy;\n\treturn dmdxy*dot(x, g) + m*g;\n}\n\nfloat smplxNoise2D(vec2 p, out vec2 deriv, float randKey, float roffset)\n{\n    //i is a skewed coordinate of a bottom vertex of a simplex where p is in.\n    vec2 i0 = floor(p + vec2( (p.x + p.y)*skewF(2.0) ));\n    //x0, x1, x2 are unskewed displacement vectors.\n    float unskew = unskewG(2.0);\n    vec2 x0 = p - (i0 + vec2((i0.x + i0.y)*unskew));\n\n    vec2 ii1 = x0.x > x0.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 ii2 = vec2(1.0);\n\n//  vec2 i1 = i0 + ii1;\n//  vec2 x1 = p - (i1 + vec2((i1.x + i1.y)*unskew));\n//          = p - (i0 + ii1 + vec2((i0.x + i0.y + 1.0)*unskew));\n//          = p - (i0 + vec2((i0.x + i0.y)*unskew)) - ii1 - vec2(1.0)*unskew;\n    vec2 x1 = x0 - ii1 - vec2(unskew);\n//  vec2 i2 = i0 + ii2;\n//  vec2 x2 = p - (i2 + vec2((i2.x + i2.y)*unskew));\n//          = p - (i0 + ii2 + vec2((i0.x + i0.y + 2.0)*unskew));\n//          = p - (i0 + vec2((i0.x + i0.y)*unskew)) - ii2 - vec2(2.0)*unskew;\n    vec2 x2 = x0 - ii2 - vec2(2.0*unskew);\n\n    vec3 m = max(vec3(0.5) - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n    m = m*m;\n    m = m*m;\n\n    float r0 = 3.1416*2.0*rand(vec3(mod(i0, 16.0)/16.0, randKey));\n    float r1 = 3.1416*2.0*rand(vec3(mod(i0 + ii1, 16.0)/16.0, randKey));\n    float r2 = 3.1416*2.0*rand(vec3(mod(i0 + ii2, 16.0)/16.0, randKey));\n\n    float randKey2 = randKey + 0.01;\n    float spmin = 0.5;\n    float sps = 2.0;\n    float sp0 = spmin + sps*rand(vec3(mod(i0, 16.0)/16.0, randKey2));\n    float sp1 = spmin + sps*rand(vec3(mod(i0 + ii1, 16.0)/16.0, randKey2));\n    float sp2 = spmin + sps*rand(vec3(mod(i0 + ii2, 16.0)/16.0, randKey2));\n\n    r0 += iTime*sp0 + roffset;\n    r1 += iTime*sp1 + roffset;\n    r2 += iTime*sp2 + roffset;\n    //Gradients;\n    vec2 g0 = vec2(cos(r0), sin(r0));\n    vec2 g1 = vec2(cos(r1), sin(r1));\n    vec2 g2 = vec2(cos(r2), sin(r2));\n\n    deriv = smplxNoise2DDeriv(x0, m.x, g0) + smplxNoise2DDeriv(x1, m.y, g1) + smplxNoise2DDeriv(x2, m.z, g2);\n    return dot(m*vec3(dot(x0, g0), dot(x1, g1), dot(x2, g2)), vec3(1.0));\n//    return dot(m*vec3(length(x0), length(x1), length(x2)), vec3(1.0));\n}\n\nvec3 norm(vec2 deriv)\n{\n    deriv *= 2000.0;\n\tvec3 tx = vec3(1.0, 0.0, deriv.x);\n\tvec3 ty = vec3(0.0, 1.0, deriv.y);\n\treturn normalize(cross(tx, ty));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0.0);\n    float s = 1.0;\n    for(int i=0; i<numLayers; ++i)\n    {\n        float sn = 0.0;\n        float y = 0.0;\n        \n        vec2 deriv;\n        float nx = smplxNoise2D(uv*s*4.0, deriv, 0.1+1./s, 0.0);\n        float ny = smplxNoise2D(uv*s*4.0, deriv, 0.11+1./s, 0.0);\n        for(int j=0; j<wormLength; ++j)\n        {\n        \tvec2 deriv;\n\n\t\t\tsn += smplxNoise2D(uv*s+vec2(1./s, 0.)+vec2(nx,ny)*4., deriv, 0.2+1./s, y);\n        \tcolor += vec3(norm(deriv).z)/s;\n            y += 0.1;\n        }\n        s *= 1.1;\n    }\n    color /= 4.;\n\n    vec2 deriv;\n    float delay = smplxNoise2D(uv*s*1.0, deriv, 0.111, 0.0);\n    color = mix(color, vec3(1.0) - color, clamp(sin(iTime*0.25+uv.x*0.5+delay*32.)*32., 0.0, 1.0));\n\n    cout = color;\n\n\tfragColor = vec4(cout, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 245, 267, 267, 422], [424, 424, 446, 4677, 4715], [4717, 4717, 4741, 4741, 4783], [4785, 4785, 4834, 4834, 4950], [4952, 4952, 5026, 5104, 7021], [7023, 7023, 7046, 7046, 7175], [7177, 7177, 7234, 7234, 8089]], "test": "valid"}
{"id": "MtGGzd", "name": "Tunnel Light", "author": "aminere", "description": "An endless tunnel with a light at the end of it.", "tags": ["tunnel", "blob"], "likes": 10, "viewed": 281, "published": "Public", "date": "1476267595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 blob(vec2 point, vec2 uv, vec3 color, float invIntensity, float invGlow)\n{\n    float d = distance(uv, point);\n    //d += sin(uv.x * uv.y);\n\tfloat invD = 1.0/d;\n\tinvD = pow(invD / invIntensity, invGlow);    \n\treturn color * invD;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, res] to [-1, 1]\n\tvec2 coord = -1.0 + (fragCoord.xy / iResolution.xy) * 2.0;\n    vec2 ncoord = coord * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // change look at\n    ncoord.x += sin(radians(iTime*40.0)) * .1;    \n    ncoord.y += cos(radians(iTime*40.0)) * .8;\n    \n    // rotation\n    float angleRot = radians(iTime)*30.0;    \n    vec2 tcoord = vec2(ncoord.x * cos(angleRot) - ncoord.y * sin(angleRot),\n                       ncoord.y * cos(angleRot) + ncoord.x * sin(angleRot));    \n    \n    // tunnel projection    \n    float angle = atan(tcoord.x, tcoord.y);\n    float radius = length(tcoord);\n    vec2 uv = vec2(angle, 1.0/radius);\n    \n    uv /= radians(180.0);  \n    uv.y += iTime*.5; // scrolling    \n    \n    vec4 col = texture(iChannel0, uv);\n    col = vec4(pow(col.r, 3.0));    \n    \n    // glow by Shane + intensity change\n    /**/\n    float intensity = 0.5 + sin(radians(iTime*20.0));\n    float h = fract(sin(dot(uv, vec2(41, 289)))*43758.5453) * intensity;\n\tfloat s = clamp(cos(angle*6.), 0., 1.);\n\tcol = mix(col, vec4(4.2, 2.4, 1.5, 1)*(1.0 + intensity), clamp(s*.15 +.8 + h*.15, 0., 1.)/(1. + radius*radius*32.));\n    /**/\n    \n    // glow - old version\n    /**\n    float invIntensity = 6.0 + sin(radians(iTime*20.0)) * 5.0;\n    float invGlow = 2.3;\n    col.rgb += blob(vec2(0.0, 0.0), tcoord, vec3(1.0, 0.7, 0.6), invIntensity, invGlow);\n\t/**/\n    \n\tfragColor = col;\n}\n\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 80, 80, 236], [238, 238, 295, 322, 1700]], "test": "error"}
{"id": "MtGGzV", "name": "My Naive Raymarcher", "author": "efairbanks", "description": "A simplified raymarcher. Lighting is projected from the camera by way of estimating distance to the object using the number of steps it took to get to it. Fake-ish lighting, but adding diffuse lighting is pretty simple. (disclaimer: probably not simplest)", "tags": ["raymarching"], "likes": 0, "viewed": 180, "published": "Public", "date": "1475630181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 eye = vec3(0,0,-10);\nvec3 sphere1Pos = vec3(0,0,2.);\nvec3 sphere2Pos = vec3(0,0,1.);\nvec3 torusPos = vec3(-1.,0,1.);\nconst float maxIterations = 64.;\n\nstruct ray{\n \tvec3 position;\n    vec3 direction;\n};\n\nfloat distTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n    \nfloat distSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n    \nray lookAt(in vec2 uv, in vec3 targetPoint){\n\tvec3 forward = normalize(targetPoint - eye);\n    vec3 up = vec3(0.,1.0,0.0);\n    vec3 right = cross(forward, up);\n    up = cross(forward, right);\n    vec3 ro = eye + forward * .1 + right * uv.x + up * uv.y;\n    vec3 rd = forward;\n    return ray(ro,rd);\n}\n\nvec3 rayMarch(ray marcher){\n    float epsilon = 0.00001;\n    float t = 0.;\n    for (float i = 0.; i < maxIterations; i++){\n        vec3 point = marcher.position + marcher.direction * t;\n        //float d = distSphere(point, 1.);\n        float d = distTorus(point, vec2(.75,.2));\n        if (d < epsilon){\n            return vec3(1.-i/maxIterations); \n        }\n        t+=d;\n    }\n    return vec3(0,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    eye = vec3(0,sin(iTime) * 12. - 1.,-15.);\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    ray eyeRay = lookAt(uv, vec3(0)); \n\tfragColor = vec4(rayMarch(eyeRay),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 244, 244, 309], [315, 315, 352, 352, 376], [382, 382, 426, 426, 682], [684, 684, 711, 711, 1090], [1092, 1092, 1148, 1148, 1371]], "test": "valid"}
{"id": "MtK3DG", "name": "Reflections And Patterns", "author": "decrooks", "description": "Raytracing with signed distance functions, an evolving pattern and reflections.", "tags": ["3d", "raytracing", "reflection", "torus", "sphere", "pattern"], "likes": 9, "viewed": 265, "published": "Public", "date": "1476614054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This is just me learning raytracing.\n//Use of signed differance functions based on work by inigo quilez  e.g. https://www.shadertoy.com/view/Xds3zN  which I'm sure most people on theis site will be familar with.\n//http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// Other sources, for reflection etc:\n//https://www.cs.unc.edu/~rademach/xroads-RT/RTarticle.html#internet\n//https://www.cs.uaf.edu/2012/spring/cs481/section/0/lecture/02_07_recursion_reflection.html\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n    float mirror;\n    float refractiveIndex;\n    float opacity;  \n};\n    \n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    vec3 normal;\n    Ray \t ray;\n    Ray reflection;\n   //Ray refraction;\n    Material material;\n    bool hit;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2,light3;\nDirectionalLight dirLight;\n\nMaterial blackMat,whiteMat,bluishMat,yellowMat,oscMat,tableMat,tableDarkMat;\n\n\n    \nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nbool checker3D(vec3 p)\n{\n    //Is this point in a white cube or a black cube in a 3d checkerboard? \n    p = floor(p);\n    \n    if (mod(p.x + p.y + p.z, 2.0)>0.0){\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nMapValue cube( vec3 p, float d , Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = length(max(abs(p) -d,0.0));\n  return mv; \n}\n\nMapValue torus( vec3 p, vec2 t ,Material m)\n{\n  MapValue mv;\n  mv.material = m;\n \n   vec2 q = vec2(length(p.xz)-t.x,p.y);\n  mv.signedDistance =length(q)-t.y;\n    return mv;\n}\nMapValue checkerdCube( vec3 p, float d , Material m1,Material m2)\n{\n  Material  m;\n    if(checker3D(6.0*p)){\n        m = m1;\n    }\n    else {\n       m = m2 ;\n    }\n  return cube(p,d, m); \n}\n \nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = p.y - y;\n  return mv;\n}\n\nMapValue tableTop( vec3 p ,float y, Material m1,Material m2)\n{\n \tMaterial  m;\n    //Draw a pattern on the table top by taking a 2d slice through a 3d checkerboard.\n    float t = iTime;\n    float a = sqrt(3.0)/2.0;\n   \tvec3 u = vec3(1.0,-0.5,-0.5);\n   \tvec3 v = vec3(0,a,-a);\n    \n    vec3 n = vec3(0.5);\n   \tfloat scaleFactor = 3.0;\n    vec2 q = p.xz*scaleFactor;\n    vec3 plane = n + q.x*u +q.y*v;\n    \n    \n    if(checker3D(plane + vec3(0.2*t))){\n        m = m1;\n    }\n    else {\n       m = m2 ;\n    }\n    \n  return xzPlane( p ,y, m);\n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n  vec3 a = p - origin;\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = dot(a,normal);\n  return mv;\n}\n\nMapValue sphere(vec3 p, vec3 center, float radius, Material m) {\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = distance(p, center) - radius;\n  return mv;\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\nMapValue subtractObjects( MapValue A, MapValue B )\n{\n    //A-B\n    if (-B.signedDistance>A.signedDistance){\n        B.signedDistance *= -1.0;\n        B.material = A.material;\n    \treturn    B ;\n    }\n    else {\n       \n    \treturn A;\n    }\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n\nvoid setMaterials() {\n    float t  = iTime;\n    float s = 0.4*(1.0+sin(t));\n    vec3 specular = vec3(0.3); \n    float shininess = 16.0;\n    blackMat = Material(LightColor(vec3(0.0,0.0,0.01),vec3(0.1,0.1,0.1)) ,35.0,0.75,1.0,1.0);\n    whiteMat = Material(LightColor(0.95*vec3(1.0,1.0,0.9),0.3*vec3(1.0,1.0,0.9)) ,shininess ,0.75,1.0,1.0);\n    bluishMat = Material(LightColor(vec3(0.3,0.3,0.5),vec3(0.3,0.3,0.5)) ,shininess ,0.75,1.0,1.0);\n    yellowMat = Material(LightColor(vec3(0.6,0.6,0.4),vec3(0.8,0.8,0.2)) ,shininess ,0.75,1.0,1.0);\n    oscMat = Material(LightColor(vec3(1.0-s,1.0-s,0.9-0.7*s),vec3(1.0-s,1.0-s,0.9-0.7*s)) ,shininess ,0.75,1.0,1.0);\n    tableMat = Material(LightColor(vec3(0.33,0.33,0.31),vec3(0.33,0.33,0.31)) ,shininess ,0.00,1.0,1.0);\n    tableDarkMat = Material(LightColor(vec3(0.3,0.3,0.32),vec3(0.33,0.33,0.31)) ,shininess ,0.75,1.0,1.0);   \n}\n\nMapValue map(vec3 p){\n   \tfloat t  = iTime;\n   \tMapValue bigSphere = sphere(p,vec3(0.0),0.5,bluishMat);\n    \n    bigSphere = subtractObjects(bigSphere,sphere(p,0.5*vec3(cos(0.9*t),1.0,sin(0.9*t)),0.3,oscMat));\n    float ssh = 0.85;\n    MapValue obj  = addObjects(sphere(p,0.55*vec3(cos(t),ssh,sin(t)),0.125,blackMat),sphere(p,0.55*vec3(cos(t+ TWO_PI/3.0),ssh,sin(t+TWO_PI/3.0)),0.125,whiteMat));\n    obj  = addObjects(obj,sphere(p,0.55*vec3(cos(t+ 2.0*TWO_PI/3.0),ssh,sin(t + 2.0*TWO_PI/3.0)),0.125,yellowMat));                      \n    obj  = addObjects(obj,bigSphere);\n    obj  = addObjects(obj,torus(p+vec3(0.0,0.15+ 0.2*sin(t),0.0),vec2(0.75,0.1),whiteMat));\n   \tobj  = addObjects( obj ,tableTop(p,-0.5,tableMat,tableDarkMat));\n    obj  = addObjects( obj ,xzPlane(-p,-2.0,yellowMat));\n   \treturn obj;\n}\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\nTrace castRay(in Ray ray, float maxDistance){\n    float dist = 0.01;\n    float presicion = 0.001;\n\tvec3 p;\n    MapValue mv;\n    bool hit = false;\n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion )\n        {\n          hit = true; \n            break;\n        } \n         if(dist>maxDistance) break;\n       \n    }\n    return Trace(dist,p,p,ray,ray,mv.material,hit);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    Trace trace = castRay(ray,maxDistance);\n    trace.normal = calculateNormal(trace.p);\n    trace.reflection = Ray(trace.p,reflect(ray.direction, trace.normal));\n\n    return trace;\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = castRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\nvec3 diffuseLighting(in Trace trace, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,trace.normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\n\n\nvec3 cookTorranceSpecularLighting(in Trace trace, vec3 lightColor,vec3 L){\n    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n    //https://renderman.pixar.com/view/cook-torrance-shader\n    \n    \n    vec3 V = -trace.ray.direction;\n\n    vec3 H = normalize(L + V);\n    \n    float NdotH = dot(trace.normal, H);\n    float NdotV = dot(trace.normal, V);\n    float VdotH = dot(V ,H );\n    float NdotL = dot(trace.normal , L);\n    \n    float lambda  = 0.25;\n    float F = pow(1.0 + NdotV, lambda);\n    \n    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));\n    \n    \n   // Beckmann distribution D\n    float alpha = 5.0*acos(NdotH);\n    float gaussConstant = 1.0;\n\tfloat D = gaussConstant*exp(-(alpha*alpha));\n    \n    \n    float c = 1.0;\n    float specular = c *(F*D*G)/(PI*NdotL*NdotV);\n    \n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\n\n\nvec3 pointLighting(in Trace trace, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, light.color.diffuse, lightDir);\n\n     color += cookTorranceSpecularLighting(trace, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, light.color.diffuse, light.direction);\n    \n    color += cookTorranceSpecularLighting(trace, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(0.7);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(0.7),specular));\n  \tlight2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(0.6),specular)); \n    light3 = PointLight(vec3(1.5*cos(1.6*time),0.15+ 0.15*sin(2.9*time),1.5*sin(1.6*time)),LightColor(vec3(0.6),specular));\n    dirLight = DirectionalLight(normalize(vec3(0.0,1.0,0.0)),LightColor(vec3(0.1),vec3(0.5)));\n} \n\n\nvec3 lighting(in Trace trace){\n    vec3 color = vec3(0.01,0.01,0.1);//ambient color\n        \n\tcolor += pointLighting(trace, light1);\n\tcolor += pointLighting(trace, light2) ;\n    color += pointLighting(trace, light3) ;\n\tcolor += directionalLighting(trace, dirLight);\n    \n    return color;\n}\n\nfloat rayDistance(Ray r,vec3 p){\n    vec3 v = r.origin - p;\n    return length(v - dot(v,r.direction)*r.direction);\n}\n\nvec3  drawLight(PointLight light, Ray ray, vec3 color, float dist){\n    float rayDist = rayDistance(ray,light.position);\n    \n    \n    float lightRadius = 0.1;\n    if(rayDist < lightRadius && distance(light.position,ray.origin) < dist){\n       float a = 1.0-rayDist/lightRadius;\n       return  mix(color,vec3(1.0),a*a*a*a);\n    }\n    return color;\n}\n\nvec3 drawLights(Ray ray,vec3 color,float dist){\n    vec3 c = drawLight(light1,ray,color,dist);\n    c = drawLight(light2,ray,c,dist);\n    c = drawLight(light3,ray,c,dist);\n    return c;\n}\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.0,1.7,-2.2);\n    \n    vec3 lookAt = vec3(0.0,-0.1,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.4);\n    vec3 color = vec3(0.0);\n    float frac = 1.0;\n   \n    float d = 0.0;\n    float maxDist = 10.0;\n    for(int i = 0; i<10; i++) {\n        Trace trace = traceRay(ray,maxDist);\n        \n \t\tif(i==0) d = trace.dist;\n        maxDist -= trace.dist;\n       \n    \tcolor += lighting(trace)*(1.0 - trace.material.mirror)*frac;\n        if(!trace.hit) break;\n        \n        frac *= trace.material.mirror;\n        if(frac < 0.1 || maxDist < 0.0 ) break;\n        ray = trace.reflection;\n    }\n   \t\n    \n    //color = drawLights(ray,color,10.0);\n   \treturn color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtK3DG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[115, 1447, 1477, 1477, 1515], [1517, 1517, 1541, 1616, 1751], [1753, 1753, 1799, 1799, 1899], [1901, 1901, 1946, 1946, 2075], [2076, 2076, 2143, 2143, 2265], [2268, 2268, 2316, 2316, 2396], [2398, 2398, 2460, 2460, 2936], [2938, 2938, 3001, 3001, 3110], [3112, 3112, 3176, 3176, 3277], [3279, 3279, 3327, 3327, 3435], [3438, 3438, 3490, 3500, 3679], [3681, 3681, 3736, 3736, 3878], [3880, 3880, 3901, 3901, 4751], [4753, 4753, 4774, 4774, 5560], [5562, 5562, 5592, 5592, 6037], [6039, 6039, 6084, 6084, 6514], [6516, 6516, 6563, 6563, 6747], [6749, 6749, 6790, 6790, 6941], [6943, 6943, 7010, 7010, 7380], [7382, 7382, 7450, 7450, 7581], [7585, 7585, 7659, 7802, 8498], [8503, 8503, 8556, 8556, 8990], [8992, 8992, 9054, 9054, 9341], [9344, 9344, 9361, 9361, 9855], [9859, 9859, 9889, 9889, 10149], [10151, 10151, 10183, 10183, 10267], [10269, 10269, 10336, 10336, 10618], [10620, 10620, 10667, 10667, 10806], [10808, 10808, 10828, 10828, 11520], [11524, 11524, 11581, 11581, 11914]], "test": "valid"}
{"id": "MtK3W3", "name": "circle inversion fractal", "author": "jz", "description": "crude way of making some circle inversion fractals I saw on numberphile\n\nI know there are if statements and whatnot and I'm sure the rest can also be optimized ", "tags": ["fractal", "circle", "inversion", "reallyunoptimized"], "likes": 13, "viewed": 250, "published": "Public", "date": "1477252399", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define L_SIDE_POS 150.0\n#define S_SIDE_POS 42.4\n#define L_SQR 22500.0\n#define S_SQR 900.0\n\nvec3 getInverse(vec2 p) {\n    float theta = iTime;\n    mat2 sideRotation = mat2(\n        cos(theta), -sin(theta),\n        sin(theta), cos(theta)\n    );\n    mat2 innerRotation = mat2(\n        cos(-theta), -sin(-theta),\n        sin(-theta), cos(-theta)\n    );\n    \n    float sq_radii[8];\n    sq_radii[0] = S_SQR;\n    sq_radii[1] = L_SQR;\n    sq_radii[2] = L_SQR;\n    sq_radii[3] = L_SQR;\n    sq_radii[4] = L_SQR;\n    sq_radii[5] = S_SQR;\n    sq_radii[6] = S_SQR;\n    sq_radii[7] = S_SQR;\n\n    vec2 centers[8];\n    centers[0] = innerRotation*vec2(S_SIDE_POS, 0.0);\n    centers[1] = sideRotation*vec2(-L_SIDE_POS,  L_SIDE_POS);\n    centers[2] = sideRotation*vec2( L_SIDE_POS,  L_SIDE_POS);\n    centers[3] = sideRotation*vec2(-L_SIDE_POS, -L_SIDE_POS);\n    centers[4] = sideRotation*vec2( L_SIDE_POS, -L_SIDE_POS);\n    centers[5] = innerRotation*vec2(-S_SIDE_POS, 0.0);\n    centers[6] = innerRotation*vec2(0.0,  S_SIDE_POS);\n    centers[7] = innerRotation*vec2(0.0, -S_SIDE_POS);\n    \n    float inside = 0.0;\n    float insideSqRadius;\n    vec2 insideCenter;\n    for (int i = 0; i < 8; ++i) {\n        vec2 pShift = p - centers[i];\n        float sqMag = dot(pShift, pShift);\n        float insideCurrent = 1.0 - step(0.0, sqMag - sq_radii[i]);\n        inside += insideCurrent;\n        if (insideCurrent > 0.0) {\n            insideSqRadius = sq_radii[i];\n\t        insideCenter = centers[i];\n        }\n    }\n    \n    if (inside > 0.0) {\n        // perform inversion\n        vec2 pShift = p - insideCenter;\n        float mag = sqrt(dot(pShift, pShift));\n        // sqR = magP*magP1\n        float magP1 = insideSqRadius / mag;\n        vec2 p1 = insideCenter + normalize(pShift)*magP1;\n        return vec3(p1, inside);\n    } else {\n        return vec3(p, inside);\n    }\n}\n\n// colormap functions from these guys:\n// https://github.com/kbinani/glsl-colormap/blob/master/shaders/IDL_Green-White_Linear.frag\nfloat colormap_red(float x) {\n    return 1.61361058036781E+00 * x - 1.55391688559828E+02;\n}\n\nfloat colormap_green(float x) {\n    return 9.99817607003891E-01 * x + 1.01544260700389E+00;\n}\n\nfloat colormap_blue(float x) {\n    return 3.44167852062589E+00 * x - 6.19885917496444E+02;\n}\n\nvec4 colormap(float x) {\n    float t = x * 255.0;\n    float r = clamp(colormap_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(t) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n\n#define MAX_IT 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cCoord = fragCoord.xy - iResolution.xy*0.5;\n    \n \tfloat steps = 0.0;\n    for (int i = 0; i < MAX_IT; ++i) {\n\t    vec3 res = getInverse(cCoord);\n        steps += res.z;\n        cCoord = res.xy;\n    }\n    \n    vec4 c0 = vec4(0, 0, 0, 1);\n    vec4 c1 = vec4(0, 1, 0, 1);\n    steps /= float(MAX_IT);\n\tfragColor = colormap(steps);\n    \n    // circle positions\n    //float inside = getInverse(fragCoord.xy - iResolution.xy*0.5).z;\n    //fragColor = vec4(inside, inside, inside, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtK3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 117, 117, 1850], [1852, 1983, 2012, 2012, 2074], [2076, 2076, 2107, 2107, 2169], [2171, 2171, 2201, 2201, 2263], [2265, 2265, 2289, 2289, 2518], [2539, 2539, 2596, 2596, 3086]], "test": "valid"}
{"id": "MtK3Wc", "name": "Escalated", "author": "drift", "description": "The shader from my recent 1024 byte intro \"Escalated\" http://www.pouet.net/prod.php?which=68360\nIt is a tribute to IQ's famous 4096 byte intro \"Elevated\".\nA few changes were made to get it to work in webGL so it is larger than the original glsl code.", "tags": ["raymarching", "terrain", "elevated", "escalated"], "likes": 35, "viewed": 2411, "published": "Public API", "date": "1477293705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 m=mat2(.8,-.6,.6,.8);\n\n\nfloat g(vec2 p){\n    float e=abs(sin(p.x+sin(p.y)));p=m*p;\n\treturn .1*(e+sin(p.x+sin(p.y)));\n}\n\nfloat n(vec2 p){\n    p*=.1;\n    float s=5.,t=.9;\n\tfor(int i=0;i<9;i++)\n        t-=s*g(p),s*=.4,p=m*2.1*p+t;\n    return 3.-exp(t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float v=iTime*2.,u=sin(v*.1),x=.0,p=.0,o=.0;\n\tvec3 r=vec3(fragCoord/iResolution.xy-1.,0),z,y;\n\tfor(int d=0;d<288;d++)        \n        if (p*.0002<=x)\n\t\t\tz=vec3(0,-8.*g(vec2(0,v)*.1),v)+p*normalize(vec3(r.x-u,r.y*.3+.1,2)),x=z.y+n(z.xz),p+=x,o++;\n    x=n(z.xz);\n    y=normalize(vec3(n(z.xz-vec2(.01,0))-x,0,n(z.xz-vec2(0,.01))-x-n(z.zx*11.)*.002));\n    fragColor.xyz=dot(vec3(-.5),y)*n(z.zx*6.)*vec3(.1,.2,.3)+.1+o*.002+log(p)*.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtK3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 45, 45, 123], [125, 125, 141, 141, 256], [258, 258, 312, 312, 748]], "test": "valid"}
{"id": "MtV3Dd", "name": "Fisheye projections for raymarch", "author": "AmazingThew", "description": "Sample code for raymarching using various curvilinear perspective projections, i.e. \"fisheye lens\"\n\nCouldn't find any clear examples of how to do this, so made one.\n\nMouse Y controls camera angle\nMouse X controls FOV", "tags": ["raymarching", "camera", "fisheye", "curvilinear"], "likes": 14, "viewed": 537, "published": "Public", "date": "1477550346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**************************************************\nHOPEFULLY REUSABLE COLLECTION OF CAMERA PROJECTIONS\n\nThe raymarching/rendering code here is pretty much\nstandard tutorial fare. Only bit you're interested\nin is the code to find the raymarch direction.\n\nCREDITS:\nIq's ubiquitous distance functions: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nSimple raymarching setup adapted from some deleted reddit user's tutorial: https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nUseful maths: http://paulbourke.net/dome/fisheye/\nConvenient list of lens functions: https://en.wikipedia.org/wiki/Fisheye_lens#Mapping_function\n(if you know of more projections described in similar polar form let me know!)\n\n**************************************************/\n\n// CAMERA TYPE:\n//#define PINHOLE\t\t\t\t//Traditional videogame camera. Looks weird unless FOV is relatively narrow\n#define STEREOGRAPHIC\t\t\t//Cool property: Spheres keep round silhouettes\n//#define EQUIANGULAR\n//#define EQUISOLID_ANGLE\n//#define ORTHOGRAPHIC_FISHEYE\n\n// WORLD\n#define ORBS\n//#define SCAFFOLDS\n//#define CAMERA_TARGET\n\n// Dithering looks cool since there's no AA\n#define DITHER\n\n\n//************************************************\n\n\n#define PI 3.14159265359\n\nconst int MAX_ITER = 100;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.00001;\nconst float FOG_START = 10.0;\nconst float FOG_END = 100.0;\nconst float SPIN_SPEED = 0.25;\n\nconst vec4 fogColor = vec4(0.08, 0.15, 0.22, 1.0);\nconst vec4 shadowColor = vec4(1.0, 0.15, 0.22, 1.0);\nconst vec4 lightColor  = vec4(1.00, 0.96, 0.91, 1.0);\n\nvec2 aux;\nvec3 cameraTarget;\nvec3 cameraPosition;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = -sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat distanceField(vec3 p)\n{\n    vec3 c, q;\n    float xBox, yBox, zBox;\n    float dist = MAX_DIST;\n    float minor = 0.05;\n    float major = 2.5;\n    float soften = 0.05;\n    float separation = 5.;\n    \n    #ifdef ORBS\n        c = vec3(5.);\n        q = mod(p,c)-0.5*c;\n        dist = min(dist, sdSphere(q, 0.47));\n    #endif\n    \n    #ifdef SCAFFOLDS\n        c = vec3(separation);\n        q = mod(p,c)-0.5*c;\n\n        xBox = udRoundBox(q, vec3(major,minor,minor), soften);\n        yBox = udRoundBox(q, vec3(minor,major,minor), soften);\n        zBox = udRoundBox(q, vec3(minor,minor,major), soften);\n\n        dist = min(dist, min(min(xBox, yBox), zBox));\n    #endif\n    \n    #ifdef CAMERA_TARGET\n    \tq = p - cameraTarget;\n    \n    \txBox = udRoundBox(q, vec3(major,minor,minor), soften);\n        yBox = udRoundBox(q, vec3(minor,major,minor), soften);\n        zBox = udRoundBox(q, vec3(minor,minor,major), soften);\n\n        dist = min(dist, min(min(xBox, yBox), zBox));\n    #endif\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.0, EPSILON);\n\treturn normalize(vec3(\n        distanceField(pos + eps.yxx) - distanceField(pos - eps.yxx),\n        distanceField(pos + eps.xyx) - distanceField(pos - eps.xyx),\n        distanceField(pos + eps.xxy) - distanceField(pos - eps.xxy)\n    ));\n}\n\nfloat dither(vec2 position, float brightness) {\n    #ifdef DITHER\n        float bayer = texture(iChannel0, position).r;\n        bayer = pow(bayer, 1.0 / 2.2);\n        bayer = (bayer + 1./64.) / (1.+1.2/64.); //Highly unscientific remap to allow full black/white\n        return step(bayer, brightness);\n    #endif\n    \n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aux = iMouse.xy / iResolution.xy;\n    if (length(aux) == 0.0) aux = vec2(0.25);\n    mat4 rotMat = rotationMatrix(vec3(0., 1., 0.), iTime*SPIN_SPEED);\n    \n    \n    //HERE'S THE PART YOU CARE ABOUT\n    //********************************************\n    \n    vec3 up = vec3(0., 1., 0.);\n    cameraPosition = (vec4(-15., 1.5, -15., 1.) * rotMat).xyz;\n    cameraTarget   = vec3(0., mix(-50., 50., aux.y), 0.);\n    \n    \n    vec3 cameraForward = normalize(cameraTarget - cameraPosition);\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = cross(cameraForward, cameraRight);\n    \n    //Need camera orientation as 3D matrix; construct as you see fit\n    mat3 cameraOrientation = mat3(cameraRight, cameraUp, cameraForward);\n    \n    //Fragment coords remapped to -1,1 range\n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    //Aspect correction\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    //Calculate ray direction for current fragment\n    float aperture = aux.x * 2.0*PI;\n    float f = 1.0/aperture;\n    float r = length(screenPos);\n    float phi = atan(screenPos.y, screenPos.x);\n    float theta;\n    \n    #ifdef PINHOLE\n    \ttheta = atan(r/f);\n    #endif\n    \n    #ifdef STEREOGRAPHIC\n    \ttheta = atan(r/(2.0*f))*2.0;\n    #endif\n    \n    #ifdef EQUIANGULAR\n    \ttheta = r/f;\n    #endif\n    \n    #ifdef EQUISOLID_ANGLE\n    \ttheta = asin(r/(2.0*f))*2.0;\n    #endif\n    \n    #ifdef ORTHOGRAPHIC_FISHEYE\n    \ttheta = asin(r/f);\n    #endif\n    \n    //March in this direction for Good Graphics\n    vec3 rayDir = cameraOrientation * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n    \n    //********************************************\n    //END PART YOU CARE ABOUT\n    \n    \n    \n    vec3 normal;\n    vec2 ditherCoords = fragCoord/iChannelResolution[0].xy;\n    vec4 finalColor = fogColor;\n    vec3 sunDir = (vec4(normalize(vec3(-1., -1., 0.)), 1.0) * rotMat).xyz;\n    \n    //Raymarch\n    float totalDist = 0.0;\n    vec3 pos = cameraPosition;\n    float dist = EPSILON;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distanceField(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n    \n    //Shade\n    if (dist < EPSILON)\n    {\n        normal = getNormal(pos);\n        float lightStrength = max(0.0, dot(sunDir, normal));\n      \tlightStrength = pow(lightStrength, 4.);\n        lightStrength = dither(ditherCoords, lightStrength);\n        \n        finalColor = mix(shadowColor, lightColor, lightStrength);\n        \n        float fogStrength = smoothstep(FOG_START, FOG_END, totalDist);\n        fogStrength = dither(ditherCoords, fogStrength);\n        \n        finalColor = mix(finalColor, fogColor, fogStrength);\n    }\n    \n    fragColor = finalColor;\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtV3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1211, 1679, 1724, 1724, 2353], [2355, 2355, 2400, 2400, 2440], [2442, 2442, 2477, 2477, 2501], [2503, 2503, 2532, 2532, 3506], [3508, 3508, 3534, 3534, 3809], [3811, 3811, 3858, 3858, 4153], [4155, 4155, 4212, 4212, 7034]], "test": "error"}
{"id": "MtVGDt", "name": "Lattice Morpher", "author": "aiekick", "description": "Lattice Morpher", "tags": ["smooth", "morphing", "cristal", "radclick", "latice"], "likes": 43, "viewed": 2566, "published": "Public API", "date": "1477516900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n// count radial section. \n// with this you can have more section. \n// more sections need more id check, but the tech is exactly the same\nconst float sections = 4.; \t\n\n// some varas\nfloat time = 0.;\t\t\t\t// time\nfloat cid = 0., lid = 0.; \t// current id, last id\nmat3 m1;\t\t\t\t\t\t// matrix used by the pattern merging\nmat3 m2;\t\t\t\t\t\t// matrix used by the pattern merging\n\n// Matrix operations\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\n// tunnel and cam path\nvec2 path(float t){return vec2(cos(t*0.08), sin(t*0.08)) * 4.;}\n\n// continuous angle from atan\nfloat cAtan(vec2 uv)\n{\n\tfloat a = 0.;\n\tif (uv.x >= 0.) a = atan(uv.x, uv.y);\n    if (uv.x < 0.) a = 3.14159 - atan(uv.x, -uv.y);\n    return a;\n}\n\n// return id of region \nfloat GetID(vec2 uv) \n{\n    return cAtan(uv) * floor(sections) * .5 / 3.14159;\n}\n\n// one pettern for each ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat pattern(vec3 p, mat3 m, float s, float id)\n{\n\tfloat r = 0.;\n\tp = abs(fract(p*m*s) - 0.5);\n\tif (id > 3.) r= max(min(abs(p.x),abs(p.z)),abs(p.y));\n    else if (id > 2.) r= max(p.x,abs(p.y)+p.z);\n\telse if (id > 1.) r= length(p);\n    else if (id > 0.) r= max(p.x,-p.y);\n\treturn r;\n}\n\n// redirect dispalce func according to ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat displace(vec3 p, float id)\n{\n\tvec3 a = vec3(0), b = a;\n\tif (id > 3.) a = vec3(-0.32,0.5,.5), b = vec3(0);\n    else if (id > 2.) a = vec3(0.46,0.42,-1.5), b = vec3(0);\n    else if (id > 1.) a = vec3(0.36,0.2,-2.28), b = vec3(0.36,0.24,1.62);\n\telse if (id > 0.) a = vec3(0.62,0.62,-1.02), b = vec3(0);\n        \n    return \n        (1.-min(pattern(p, m1, a.x, id), pattern(p, m2, a.y, id))) * a.z + \n    \t(1.-min(pattern(p, m1, b.x, id), pattern(p, m2, b.y, id))) * b.z;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k = 1.;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\t\t\t\t\t\t\t\t\t\t\t\t\t// tunnel path\n\t\n    // mix from displace of last section id with displace of current section id accroding to id range \n    float r = mix(displace(p, lid), displace(p, cid), fract(cid)); \t// id range [0-1]\n\t\n    p *= getRotZMat(p.z*0.05);\n\t\n    p = mod(p, 10.) - 5.;\n    \n    // tunnel + dispalce\n\treturn vec4(smin(length(p.xz), abs(p.y)) - 1. + r, p);\n}\n\nvec3 nor( vec3 pos, float k)\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn map(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// color arangement is what i choose\n// its easy to have another coloration wothout modified the lighting.\n// here is an easy way i choose, but you can do alterate more as you want\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nvec4 params(vec4 f, float id)\n{\n\tvec4 c = f;\n    if (id > 3.) c = f.zwyw; \n    else if (id > 2.) c = f.zyzw; \n    else if (id > 1.) c = f.yzyx; \n    else if (id > 0.) c = f.xyzw; \n    return c;\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.001, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// blackbody color according to the subdensity value\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\t\t\t\t\t// use bumpmap fnc of shane here\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 5.) * 0.5; \t\t\t\t\t// one step sub density of df\n\treturn vec4(\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// some mix of WTF :) i tried many different things and this i choose :) but maybe there is other things to do\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\n// get cam \n// g will be gl_FragCoord.xy or uMouse.xy\n//  si is screensize\nvec3 cam(vec2 g, vec2 si, vec3 ro, vec3 cv)\n{\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n\t// matrix used by the pattern\n    m1 = mx * my * mz;\n    m2 = m1 * m1;\n\t\n    time = iTime * 8.;\n    \n    vec3 cu = vec3(0,1,0);\t\t\t\t\t\t\t\t\t\t\t// Camera Up\n  \tvec3 cv = vec3(path(time + .1),time + .1); \t\t\t\t\t// Camera View\n    vec3 ro = vec3(path(time),time);\t\t\t\t\t\t\t\t// Camera Origin\n\tvec3 lp = vec3(path(ro.z + 7.),ro.z + 7.); \t\t\t\t\t// light point\n    vec3 cp = vec3(path(ro.z + 25.2),ro.z + 25.2); \t\t// center point for Smooth RadClick\n\tvec3 rd = cam(g, si, ro, cv);\t\t\t\t\t\t\t\t\t// Camera Direction\n\n\t// center point for calculate section id accroding to the tunnel path\n\tvec2 rdID = rd.xy - normalize(cp-ro).xy;\n\t\n    // fix point in screen center to have progressive id chanage along cam path\n\trdID = cam(si*0.5, si, ro, cv).xy - normalize(cp-ro).xy;\n\n\t// radial section id\n    float id = GetID(rdID); // 0 to 4\n\n    // circular sections id \n    cid = id; \t\t\t\t\t\t\t\t\t// current section id\n\tlid = cid - 1.; \t\t\t\t\t\t\t// last section id\n\tif (lid < 0.) lid = id + sections - 1.;\t// circular \n\t\n\t// Ray Marching\n    float s = 1.;\n    float d = 0.;\n    for(int i=0;i<60;i++)\n    {      \n        if (log(d*d/s/1e5)>0.) break;\n        d += s = map(ro+rd*d).x * .6;\n    }\n\t\n\t// Color\n    f = shade(ro, rd, d, lp);\n\t\n\t// mix Color Arangement according to Radial Section Range \n\t// mix from params of last section id with params of current section id \n\t// according to the range between the two sections with fract(cid) => range 0 to 1\n\tf = mix(params(f, lid), params(f, cid), fract(cid)); // id range [0-1]\n\t\n\t// improve light a little bit\n\tf = f + f.x*0.3;\n\n\t// fog for hide some ray marching artifact cause by the low count iteration (60 here )\n    f = mix( f, vec4(0.8), 1.0-exp( -0.001*d*d ) );\n        \n\t// gamma correction for add some contrast without saturation\n   \tfragColor = sqrt(f*f*f*2.); // gamma correction\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVGDt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[560, 581, 606, 606, 664], [665, 665, 690, 690, 748], [749, 749, 774, 774, 832], [834, 857, 876, 876, 920], [922, 952, 974, 974, 1096], [1098, 1122, 1145, 1145, 1202], [1204, 1315, 1365, 1365, 1599], [1601, 1727, 1761, 1761, 2202], [2204, 2204, 2236, 2236, 2340], [2342, 2342, 2360, 2360, 2747], [2749, 2749, 2779, 2779, 2994], [2996, 3217, 3245, 3245, 3570], [3572, 3654, 3711, 3711, 3935], [3937, 3937, 3973, 3973, 4109], [4111, 4287, 4338, 4338, 4509], [4511, 4720, 4783, 4783, 5251], [5253, 5518, 5549, 5549, 5713], [5715, 5715, 5763, 5763, 6881], [6883, 6958, 7003, 7003, 7198], [7200, 7200, 7257, 7257, 9236]], "test": "error"}
{"id": "Mty3Rc", "name": "Meteor shower", "author": "Karang", "description": "Simulation used to test computer vision algorithms.", "tags": ["earth", "orbit", "meteor", "satellite"], "likes": 2, "viewed": 155, "published": "Public", "date": "1475817134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat hash(float h) {\n    h += 40.0; // prevent center symetry\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat snoise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nvec3 hash3( in vec3 p ) {\n    return vec3(snoise(p),snoise(p+1.5),snoise(p+2.5))*2.0-vec3(1.0);\n}\n\nfloat fbm(vec3 p) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<8 ; i++) {\n        //if (i>6) break;\n        h += abs((snoise(p*f*0.2)-0.5)/f);\n        f *= 2.0;\n    }\n    return h;\n}\n\n/* Return the rotation matrix defined by its axis and angle */\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n/*\n\tReturn true if the ray hit the sphere\n\tIf true, A and B contains the ray entry and exit point\n*/\nbool raySphereI(vec3 ro, vec3 rd, vec3 c, float r, out vec3 A, out vec3 B) {\n    vec3 OC = c - ro;\n    float x = dot(OC, rd);\n    float d = dot(OC, OC) - x*x;\n    if (d > (r*r)) return false;\n    float t = sqrt(r*r - d);\n    A = ro + rd*(x-t);\n    B = ro + rd*(x+t);\n    return x>0.0;\n}\n\nvoid rayRayI(vec3 P0, vec3 u, vec3 Q0, vec3 v, out vec3 P, out vec3 Q) {\n    vec3 w0 = P0-Q0;\n    float a = dot(u, u);\n    float b = dot(u, v);\n    float c = dot(v, v);\n    float d = dot(u, w0);\n    float e = dot(v, w0);\n    float den = a*c-b*b;\n    if (den==0.0) { // parallels\n    \t //TODO\n    } else {\n        float sC = (b*e-c*d)/den;\n        float tC = (a*e-b*d)/den;\n        P = P0+u*sC;\n        Q = Q0+v*tC;\n    }\n}\n\n\nfloat star(vec3 p) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<6 ; i++) {\n        h += (snoise(p*f*200.0)/f);\n        f *= 2.0;\n    }\n    return smoothstep(0.1, 0.9, 1.0-h*2.0);\n}\n\n/*\n\tPerform the light scattering computation.\n\thttp://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n\thttp://scratchapixel.com/lessons/procedural-generation-vritual-worlds/simulating-sky/simulating-colors-of-the-sky\n*/\n\nconst vec3 lightDir = normalize(vec3(1.0,0.0,0.0));\n\nconst vec3 planetCenter = vec3(0.0);\n\nconst float innerRadius = 10.0; // The inner (planetary) radius\nconst float outerRadius = 10.3; // The outer (atmosphere) radius\n\nconst int nSamples = 16;\nconst int nSamplesLight = 8;\n\nconst float Hr = 7994.0;\nconst float Hm = 1200.0;\nconst vec3 betaM = vec3(21e-2);\nconst vec3 betaR = vec3(3.8e-2, 13.5e-2,33.1e-2);\n    \nvec3 lightScattering(vec3 A, vec3 B, vec3 rd) {\n    vec3 samplePoint = A;\n    float sampleLength = length(A-B) / float(nSamples);\n    \n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(rd, lightDir);\n    float phaseR = 3.0 / (16.0*M_PI) * (1.0 + mu*mu);\n    float g = 0.76;\n    float phaseM = 3.0 / (8.0*M_PI) * ((1.0-g*g)*(1.0+mu*mu)) / ((2.0+g*g) * pow(1.0+g*g-2.0*g*mu, 1.5)); \n    \n    for (int i=0 ; i<nSamples ; i++) {\n        float height = length(samplePoint - planetCenter) - innerRadius;\n        \n        // compute optical depth for light\n        float hr = exp(-height / Hr) * sampleLength;\n        float hm = exp(-height / Hm) * sampleLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        \n        // light optical depth\n        vec3 ALight, BLight;\n        raySphereI(samplePoint, lightDir, planetCenter, outerRadius, ALight, BLight);\n        float sampleLengthLight = length(BLight-samplePoint)/float(nSamplesLight);\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        vec3 sampleLightPoint = samplePoint;\n        bool ok = true;\n        for (int j=0; j<nSamplesLight ; j++) {\n            float heightLight = length(sampleLightPoint-planetCenter) - innerRadius;\n            if (heightLight < 0.0) {\n                ok = false;\n                break;\n            }\n            opticalDepthLightR += exp(-heightLight/Hr) * sampleLengthLight;\n            opticalDepthLightM += exp(-heightLight/Hm) * sampleLengthLight;\n            sampleLightPoint += lightDir*sampleLengthLight;\n        }\n\n        if (ok) {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR);\n            tau += betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\n        \n        samplePoint += rd*sampleLength;\n    }\n    return (sumR * betaR * phaseR + sumM * betaM * phaseM) * 20.0;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.005,0.005,0.06);\n    \n     // Space\n    vec3 lCol = vec3(1.0, 0.9, 0.8);\n    float sun = clamp(dot(rd, lightDir),0.0,1.0)+0.05;\n    color += 0.01 * lCol * pow(sun, 150.0);\n    color += star(rd);\n    \n    // Earth\n    vec3 closestPoint;\n    vec3 earthA, earthB;\n    if (raySphereI(ro, rd, planetCenter, innerRadius, earthA, earthB)) {\n        vec3 nor = normalize(earthA);\n        color = vec3(0.0,0.0,1.0);\n        float light = clamp(dot(lightDir, nor), 0.0, 0.9)+0.1;\n        \n        float geography = 1.0-fbm(2.0 * earthA)*2.0;\n\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\n        float population = smoothstep(0.2, 0.8, fbm(40.0 * earthA) + coast - light);\n        vec3 p = 1000.0 * earthA;\n        population *= (snoise(p) + coast);\n        population *= (snoise(p*2.0) + coast);\n        population *= (snoise(p*4.0) + coast);\n        population *= (snoise(p*8.0) + coast);\n        population *= (snoise(p*16.0) + coast);\n        population = smoothstep(0.0, 0.1, population);\n\n        vec3 land = vec3(0.6, 0.4, 0.2) * light;\n        land = mix(land, vec3(2.0, 1.3, 1.0), clamp(population, 0.0, 1.0));\n        vec3 water = vec3(0.0, 0.5, 1.0) * light;\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\n\n        vec3 wind = vec3(fbm(30.0 * earthA + iTime), fbm(60.0 * earthA + iTime), 0.0);\n        float weather = fbm(1.0 * (earthA + wind + iTime*0.1)) * (0.6 + 0.4 * snoise(10.0 * earthA))*2.5;\n\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\n        color = mix(ground, vec3(1.0, 1.0, 1.0)*light*1.5, clouds);\n    }\n    closestPoint = earthA;\n    \n    // Meteors\n    for (int i=0 ; i<10 ; i++) {\n        float time = iTime*3.0+0.1*float(i);\n        //time = iTime+0.1*float(i);\n        vec3 seed = vec3(floor(time), float(i), floor(time));\n        float t = fract(time);\n        vec3 meteorO = hash3(vec3(seed));//*innerRadius\n        vec3 meteorD = normalize(hash3(vec3(seed)+0.5));\n        \n        vec3 A,B;\n        raySphereI(meteorO, meteorD, planetCenter, outerRadius, A,B);\n        vec3 meteorIn = A;\n        raySphereI(meteorO, meteorD, planetCenter, innerRadius, A,B);\n        vec3 meteorOut = A;\n        if (t<0.5)\n            meteorOut = mix(meteorIn, meteorOut, t*2.0);\n        else\n            meteorIn = mix(meteorIn, meteorOut, t*2.0-1.0);\n        \n        vec3 P, Q;\n        rayRayI(ro, rd, meteorO, meteorD, P, Q);\n        if (dot(rd, P-ro)>0.0) {\n            if (length(ro-P)>length(ro-closestPoint))\n                P = closestPoint;\n            vec3 mC = (meteorIn+meteorOut)/2.0;\n            color += vec3(1.0)*pow(clamp(1.0-(length(P-meteorIn)+length(P-meteorOut)*1.01)*2.87/(1.0-abs(t*2.0-1.0)), 0.0, 10.0)*7.2,50.0);\n        }\n    }\n    \n    // Atmosphere\n    vec3 atmoA, atmoB;\n    if (raySphereI(ro, rd, planetCenter, outerRadius, atmoA, atmoB)) {\n        if (length(ro-atmoB)>length(ro-earthA))\n            atmoB = earthA;\n        color += lightScattering(atmoA, atmoB, rd);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    float angle = -1.1;\n    float radius = 10.5;\n    //float t = iMouse.x*0.01;\n    float t = (iTime+150.0)*0.01;\n    vec3 cPos = vec3(radius, 0.0, 0.0);\n    cPos = (rotationMatrix(vec3(0.0, 1.0, 0.0), t)*rotationMatrix(vec3(0.0, 0.0, 1.0), angle)*vec4(cPos, 1.0)).xyz;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n    //vec3 cLook = vec3(0.0, 0.0, 0.0);\n\tvec3 cLook = vec3(radius-0.1, 0.0, 0.0);\n   \tcLook = (rotationMatrix(vec3(0.0, 1.0, 0.0), t+0.1)*rotationMatrix(vec3(0.0, 0.0, 1.0), angle)*vec4(cLook, 1.0)).xyz;\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n    \n\tfragColor = vec4(render(cPos, rd), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mty3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 69, 69, 151], [153, 153, 175, 175, 519], [521, 521, 546, 546, 618], [620, 620, 639, 639, 818], [820, 883, 928, 928, 1556], [1559, 1660, 1736, 1736, 1946], [1948, 1948, 2020, 2020, 2370], [2373, 2373, 2393, 2393, 2569], [2926, 3216, 3263, 3263, 5302], [5304, 5304, 5335, 5335, 8388], [8390, 8390, 8447, 8447, 9318]], "test": "error"}
{"id": "MtyGD3", "name": "WobblyWater", "author": "moakley", "description": "Three sines.", "tags": ["water", "sine"], "likes": 1, "viewed": 113, "published": "Public", "date": "1477066049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////\n// Wobbly sea //\n////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    float speed\t  = 1.3;\n    float heightA = 0.05;\n    float heightB = 0.05;\n    float heightC = 0.03;\n    \n    vec2 xy = fragCoord.xy;\t\t\t\t    // We obtain our coordinates for the current pixel\n    \n    xy.x = xy.x / iResolution.x;\t\t    // We divide the coordinates by the screen size\n    xy.y = xy.y / iResolution.y;\n    \n    xy.y = sin((xy.x + (-iTime*speed))*5.0)*heightA + xy.y;\n    xy.y = xy.y + sin((xy.x + (iTime))*3.0)*heightB;\n    xy.y = xy.y + sin((xy.x + (iTime))*2.0)*heightC;     \n\n    xy.y = xy.y * 4.0;\n        \n    vec4 finalColour = vec4(0,0.0,0.0,1.0);\t// This is actually black right now\n\n    finalColour.r = 0.2;\t\t\t\t\t// Set its red component\n    finalColour.g = 0.4;\t\t\t\t\t// Set its green component\n    finalColour.b = 0.8;\t\t\t\t\t// Set its blue component\n    \n    if(xy.y < 0.9)\n    \n    {\t\t\t\t\t\t\t\t\t\t// Arbitrary number, we don't know how big our screen is!\n        finalColour.r = xy.y + 0.0;\t\t\t// Set its red component to 1.0\n        finalColour.g = xy.y + 0.4;\t\t\t// Set its green component to 1.0\n        finalColour.b = 1.0;\t\t\t\t// Set its blue component to 1.0\n    }\n\t\t\t\t\t\t\t\t\t  \n    fragColor = finalColour;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 109, 109, 1242]], "test": "valid"}
{"id": "MtyGDV", "name": "demosplash2016-cxw-09", "author": "cxw", "description": "Part 09: Basic 3D --- raycasting and simple lighting\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016", "tags": ["phong", "raycasting", "tutorial", "lighting", "shading", "demoparty"], "likes": 1, "viewed": 489, "published": "Public API", "date": "1476804624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp int; precision highp float;\n\n// Parameters for your demo.\n\n//Geometry\n#define QUAD_SIDE_LEN (2.0)\n#define TWOSIDED\n#define SHADING_RULE (3)\n    // 0=>none, 1=>flat, 2=>Lambertian, 3=>Phong\n\n//View\n#define ORBIT_RADIUS (6.0)\n#define FOVY_DEG (20.0)\n    // Sort of like the zoom on a camera --- smaller is closer\n\n// Material\n#define SHININESS (256.0)\n\n// Display physics\n#define GAMMA (2.2)\n#define ONE_OVER_GAMMA (0.45454545454545454545454545454545)\n\n// Routines /////////////////////////////////////////////////////////////\n\n// BASIC 3D ///////////////////////////////////////////\n\nvoid lookat(in vec3 in_eye, in vec3 in_ctr, in vec3 in_up,\n            out mat4 view, out mat4 view_inv)\n{\n    // From Mesa glu.  Thanks to\n    // http://learnopengl.com/#!Getting-started/Camera\n    // and https://www.opengl.org/wiki/GluLookAt_code\n\n    vec3 forward, side, up;\n\n    forward=normalize(in_ctr-in_eye);\n    up = in_up;\n    side = normalize(cross(forward,up));\n    up = cross(side,forward);   // already normalized since both inputs are\n        //now side, up, and forward are orthonormal\n\n    mat4 orient, where;\n\n    // Note: in Mesa gluLookAt, a C matrix is used, so the indices\n    // have to be swapped compared to that code.\n    vec4 x4, y4, z4, w4;\n    x4 = vec4(side,0);\n    y4 = vec4(up,0);\n    z4 = vec4(-forward,0);\n    w4 = vec4(0,0,0,1);\n    orient = transpose(mat4(x4, y4, z4, w4));\n\n    where = mat4(1.0); //identity (1.0 diagonal matrix)\n    where[3] = vec4(-in_eye, 1);\n\n    view = (orient * where);\n\n    // Compute the inverse for later\n    view_inv = mat4(x4, y4, z4, -where[3]);\n    view_inv[3][3] = 1.0;   // since -where[3].w == -1, not what we want\n        // Per https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations ,\n        // M_{view->world}\n} //lookat\n\nvoid gluPerspective(in float fovy_deg, in float aspect,\n                    in float near, in float far,\n                    out mat4 proj, out mat4 proj_inv)\n{   // from mesa glu-9.0.0/src/libutil/project.c.\n    // Thanks to https://unspecified.wordpress.com/2012/06/21/calculating-the-gluperspective-matrix-and-other-opengl-matrix-maths/\n\n    float fovy_rad = radians(fovy_deg);\n    float dz = far-near;\n    float sin_fovy = sin(fovy_rad);\n    float cot_fovy = cos(fovy_rad) / sin_fovy;\n\n    proj=mat4(0);\n    //[col][row]\n    proj[0][0] = cot_fovy / aspect;\n    proj[1][1] = cot_fovy;\n\n    proj[2][2] = -(far+near)/dz;\n    proj[2][3] = -1.0;\n\n    proj[3][2] = -2.0*near*far/dz;\n\n    // Compute the inverse matrix.\n    // http://bookofhook.com/mousepick.pdf\n    float a = proj[0][0];\n    float b = proj[1][1];\n    float c = proj[2][2];\n    float d = proj[3][2];\n    float e = proj[2][3];\n\n    proj_inv = mat4(0);\n    proj_inv[0][0] = 1.0/a;\n    proj_inv[1][1] = 1.0/b;\n    proj_inv[3][2] = 1.0/e;\n    proj_inv[2][3] = 1.0/d;\n    proj_inv[3][3] = -c/(d*e);\n} //gluPerspective\n\nvoid compute_viewport(in float x, in float y, in float w, in float h,\n                        out mat4 viewp, out mat4 viewp_inv)\n{\n    // See https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations#Viewport_Transformation\n    // Also mesa src/mesa/main/viewport.c:_mesa_get_viewport_xform()\n\n    viewp = mat4(0);\n    // Reminder: indexing is [col][row]\n    viewp[0][0] = w/2.0;\n    viewp[3][0] = x+w/2.0;\n\n    viewp[1][1] = h/2.0;\n    viewp[3][1] = y+h/2.0;\n\n    // assumes n=0 and f=1,\n    // which are the default for glDepthRange.\n    viewp[2][2] = 0.5;  // actually 0.5 * (f-n);\n    viewp[3][2] = 0.5;  // actually 0.5 * (n+f);\n\n    viewp[3][3] = 1.0;\n\n    //Invert.  Done by hand.\n    viewp_inv = mat4(1.0);\n    viewp_inv[0][0] = 2.0/w;    // x->x\n    viewp_inv[3][0] = -1.0 - (2.0*x/w);\n\n    viewp_inv[1][1] = 2.0/h;    // y->y\n    viewp_inv[3][1] = -1.0 - (2.0*y/h);\n\n    viewp_inv[2][2] = 2.0;      // z->z\n    viewp_inv[3][2] = -1.0;\n\n}  //compute_viewport\n\n// RAYCASTING /////////////////////////////////////////\n\nvec4 wts(in mat4 modelviewproj, in mat4 viewport,\n                in vec3 pos)\n{   // world to screen coordinates\n    vec4 clipvertex = modelviewproj * vec4(pos,1.0);\n    vec4 ndc = clipvertex/clipvertex.w;\n    vec4 transformed = viewport * ndc;\n    return transformed;\n} //wts\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec4 WorldRayFromScreenPoint(in vec2 scr_pt,\n    in mat4 view_inv,\n    in mat4 proj_inv,\n    in mat4 viewp_inv)\n{   // Returns world coords of a point on a ray passing through\n    // the camera position and scr_pt.\n\n    vec4 ndc = viewp_inv * vec4(scr_pt,0.0,1.0);\n        // z=0.0 => it's a ray.  0 is an arbitrary choice in the\n        // view volume.\n        // w=1.0 => we don't need to undo the perspective divide.\n        //      So clip coords == NDC\n\n    vec4 view_coords = proj_inv * ndc;\n        // At this point, z=0 will have become something in the\n        // middle of the projection volume, somewhere between\n        // near and far.\n    view_coords = view_coords / view_coords.w;\n        // Keepin' it real?  Not sure what happens if you skip this.\n    //view_coords.w = 0.0;\n        // Remove translation components.  Note that we\n        // don't use this trick.\n    vec4 world_ray_point = view_inv * view_coords;\n        // Now scr_pt is on the ray through camera_pos and world_ray_point\n    return world_ray_point;\n} //WorldRayFromScreenPoint\n\n// HIT-TESTING ////////////////////////////////////////\n\nvec3 HitZZero(vec3 camera_pos, vec3 rayend)\n{   // Find where the ray meets the z=0 plane.  The ray is\n    // camera_pos + t*(rayend - camera_pos) per Hook.\n    float hit_t = -camera_pos.z / (rayend.z - camera_pos.z);\n    return (camera_pos + hit_t * (rayend-camera_pos));\n} //HitZZero\n\n// --- IsPointInRectXY ---\n// All polys will be quads in the X-Y plane, Z=0.\n// All quad edges are parallel to the X or Y axis.\n// These quads are encoded in a vec4: (.x,.y) is the LL corner and\n// (.z,.w) is the UR corner (coords (x,y)).\n\nbool IsPointInRectXY(in vec4 poly_coords, in vec2 world_xy_of_point)\n{\n    // return true if world_xy_of_point is within the poly defined by\n    // poly_coords in the Z=0 plane.\n    // I can test in 2D rather than 3D because all the geometry\n    // has z=0 and all the quads are planar.\n\n    float x_test, y_test;\n    x_test = step(poly_coords.x, world_xy_of_point.x) *\n            (1.0 - step(poly_coords.z, world_xy_of_point.x));\n        // step() is 1.0 if world.x >= poly_coords.x\n        // 1-step() is 1.0 if world.x < poly_coords.z\n    y_test = step(poly_coords.y, world_xy_of_point.y) *\n            (1.0 - step(poly_coords.w, world_xy_of_point.y));\n\n    return ( (x_test>=0.9) && (y_test >= 0.9) );\n        // Not ==1.0 because these are floats!\n\n} //IsPointInRectXY\n\n// CAMERA AND LIGHT ///////////////////////////////////\n\nhighp vec3 pos_clelies(in float time, in float radius)\n{   //Clelies curve\n    //thanks to http://wiki.roblox.com/index.php?title=Parametric_equations\n    vec3 pos; float m = 0.8;\n    highp float smt = sin(m*time);\n    pos.x = radius * smt*cos(time);\n    pos.y = radius * smt*sin(time);\n    pos.z = radius * cos(m*time);\n    return pos;\n} //camerapos\n\nvoid get_cam_and_light(\n    in float time,\n    out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up,\n    out float fovy_deg, out vec3 light_pos)\n{\n    camera_pos = pos_clelies(time, ORBIT_RADIUS);\n    camera_look_at = vec3(0.0);\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = FOVY_DEG;\n    light_pos = camera_pos;\n} //get_cam_and_light\n\n// SHADING ////////////////////////////////////////////\n\nfloat lambertian_shade(in vec3 pixel_pos, in vec3 normal,\n                    in vec3 light_pos, in vec3 camera_pos)\n{ //Lambertian shading.  Returns the reflectance visible at camera_pos as a\n  //result of lighting pixel_pos (having normal) from light_pos.  \n  //One-sided object.\n\n    vec3 light_dir = normalize(light_pos - pixel_pos);\n    vec3 eye_dir = normalize(camera_pos - pixel_pos);\n    if(dot(light_dir, eye_dir) < 0.0) {\n        return 0.0;     // Camera behind the object => no reflectance\n    } else {\n        return max(0.0, dot(light_dir, normal));\n            // ^^^^^^^^ light behind the object => no reflectance\n    }\n} //lambertian_shade\n\nvec3 phong_color(\n    in vec3 pixel_pos, in vec3 normal, in vec3 camera_pos,      // Scene\n    in vec3 light_pos, in vec3 ambient_color,                   // Lights\n    in vec3 diffuse_color, in vec3 specular_color,              // Lights\n    in float shininess)                                         // Material\n{   // Compute pixel color using Phong shading.  Modified from\n    // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    // normal must be normalized on input.  All inputs are world coords.\n    // Set shininess <=0 to turn off specular highlights.\n    // Objects are one-sided.\n\n    vec3 light_dir = normalize(light_pos - pixel_pos);\n    vec3 eye_dir = normalize(camera_pos - pixel_pos);\n\n    if(dot(light_dir, eye_dir) < 0.0) {\n        return ambient_color;       // Camera behind the object\n    }\n\n    float lambertian = max(0.0, dot(light_dir, normal));        // Diffuse\n\n    float specular = 0.0;\n    if((lambertian > 0.0) && (shininess > 0.0)) {               // Specular\n        vec3 reflectDir = reflect(-light_dir, normal);\n        float specAngle = max(dot(reflectDir, eye_dir), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    /*\n    return pow(ambient_color + lambertian*diffuse_color + specular*vec3(1.0),\n                vec3(ONE_OVER_GAMMA));\n        // TODO Do I need this?\n    */\n    lambertian = pow(lambertian, ONE_OVER_GAMMA);\n    specular = pow(specular, ONE_OVER_GAMMA);\n\n    vec3 retval = ambient_color + lambertian*diffuse_color + \n        specular*specular_color;\n\n    return clamp(retval, 0.0, 1.0);     // no out-of-range values, please!\n\n} //phong_color\n\n// mainImage() //////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 pixel_coord_01 = fragCoord.xy / iResolution.xy;\n\n    // --- Camera and light ---\n    vec3 camera_pos, camera_look_at, camera_up, light_pos;\n    float fovy_deg;\n\n    get_cam_and_light(time,\n        camera_pos, camera_look_at, camera_up, fovy_deg, light_pos);\n\n    // Camera processing\n\n    mat4 view, view_inv;\n    lookat(camera_pos, camera_look_at, camera_up,\n            view, view_inv);\n\n    mat4 proj, proj_inv;            // VVVVVVVVV squares are square! :)\n    gluPerspective(fovy_deg, iResolution.x/iResolution.y, 1.0, 10.0,\n                    proj, proj_inv);\n\n    mat4 viewport, viewport_inv;    // VVVVVVVVV squares are square! :)\n    compute_viewport(0.0, 0.0, iResolution.x, iResolution.y,\n                        viewport, viewport_inv);\n\n    vec3 material_color = vec3(0.0);    //Color of the quad before shading\n\n    // Raycasting\n\n    vec3 rayend = WorldRayFromScreenPoint(fragCoord,\n                                    view_inv, proj_inv, viewport_inv).xyz;\n        // rayend-camera_pos is the direction of the ray\n    vec3 world_xyz0_of_point = HitZZero(camera_pos, rayend);\n        // Where the ray hits z=0\n    vec3 normal = vec3(0.0,0.0,-1.0 + 2.0*step(0.0, camera_pos.z));\n        // normal Z is -1 if camera_pos.z<0.0, and +1 otherwise.\n\n    // Hit-testing\n    float qh = QUAD_SIDE_LEN*0.5;\n    vec4 theshape = vec4(-qh,-qh,qh,qh);\n\n    if(IsPointInRectXY(theshape, world_xyz0_of_point.xy)) {\n\n#ifndef TWOSIDED\n        material_color = vec3(1.0);\n#else\n        float front_view = step(0.0, camera_pos.z);\n        material_color = vec3(front_view, 0.0, 1.0-front_view);\n#endif\n\n    } else {    //we didn't hit\n        fragColor = vec4(0.0,0.0,0.0,1.0);  //black\n        return; // *** EXIT POINT ***\n            // comment out the \"return\" for a chuckle\n    }\n\n    // Shading (it's a shader, after all!)\n\n#if SHADING_RULE == 0\n    fragColor = vec4(material_color, 1.0);                  //No shading\n\n#elif SHADING_RULE == 1\n    // Flat shading - per-poly\n    float reflectance = // VVVVVVV per-poly, lighting as a the poly's center.\n        lambertian_shade(vec3(0.0), normal, light_pos, camera_pos);\n\n    float reflectance_gc = pow(reflectance, ONE_OVER_GAMMA);\n        // Gamma-correct luminous-intensity reflectance into monitor space.\n        // Hey, it's just math, right?  I did this because the quad was too\n        // dark otherwise.\n\n    // White light for simplicity\n    fragColor = vec4(reflectance_gc * material_color, 1.0);\n\n#elif SHADING_RULE == 2\n    //Lambertian shading\n    float reflectance = //     VVV Lambertian is per-point, not per-poly\n        lambertian_shade(world_xyz0_of_point, normal, light_pos, camera_pos);\n\n    float reflectance_gc = pow(reflectance, ONE_OVER_GAMMA);\n    fragColor = vec4(reflectance_gc * material_color, 1.0);\n\n#else\n    // Phong shading\n    vec3 ambient_color = vec3(0.1);\n    vec3 specular_color = vec3(1.0);\n    vec3 color = phong_color(\n        world_xyz0_of_point, normal, camera_pos, light_pos, \n        ambient_color, material_color, specular_color,  // Light colors\n        SHININESS);\n\n    fragColor = vec4(color, 1.0);\n#endif\n} //mainImage\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[542, 599, 705, 847, 1799], [1800, 1810, 1970, 2149, 2869], [2870, 2888, 3019, 3193, 3848], [3870, 3927, 4007, 4040, 4198], [4206, 4262, 4375, 4476, 5298], [5326, 5383, 5428, 5539, 5657], [5670, 5910, 5980, 6196, 6666], [7082, 7095, 7253, 7253, 7427], [7449, 7506, 7624, 7787, 8143], [8144, 8164, 8480, 8773, 9776], [9792, 9867, 9924, 9924, 13068]], "test": "valid"}
{"id": "MtyGz3", "name": "Diggy", "author": "Belocio", "description": "Modelling of Diamond Digger's main character", "tags": ["raymarching", "diamond", "modelling", "digger", "diggy"], "likes": 13, "viewed": 270, "published": "Public", "date": "1476566252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime * 0.5\n#define lampLightIntensity abs(2.0*sin(time*5.0))\n\nconst float PI=3.14159265;\nconst float PIH = PI*0.5;\nconst int MAX_ITER = 40;\nconst float EPSILON = 0.00001;\nvec3 lightDir = normalize(vec3(0, 1, 0.75)); \nfloat lightIntensity=0.5;\nvec3 ambientLight=vec3(0.1,0.1,0.1);\n\nfloat bgMatType = 0.0;\nfloat PlaneMatType = 1.0;\nfloat BodyMatType = 2.0;\nfloat DressMatType = 3.0;\nfloat LampMatType = 4.0;\nfloat EyesMatType = 5.0;\nfloat TeethMatType = 6.0;\n\nvec3 skyColor = vec3(1.0,1.0,1.0);\nvec3 planeColor = vec3(1.0,1.0,1.0);\nvec3 bodyColor = vec3(0.89,0.74,0.15);\nvec3 dressColor = vec3(0.83,0.52,0.05);\nvec3 lampColor = vec3(0.63,0.99,0.99);\nvec3 eyesColor = vec3(0);\nvec3 teethColor = vec3(1.0,1.0,1.0);\n\n#define jumpFreq iTime * 2.5\nvec3 lampLightColor = vec3(0.63,0.99,0.99);\n#define posDispl vec3(0.0, -abs(sin(jumpFreq)*0.1), 0.0)\n#define lampDispl vec3(-0.1, sin(jumpFreq*2.0+PI*1.2)*0.15, 0.0)\nvec3 lampPos = vec3(0.0, 0.74, 0.15);\nfloat lampLightAtt = 1.5;\n\n//#define SELF_SHADOW\n#define CHEAP_AO\n\n// Thanks iq! https://www.shadertoy.com/view/ld3Gz2\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n//---------------------------------------------\nvec3 rotationCoordY(vec3 n, float t)\n{\n vec3 result;\n\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n\n  result = n * rotate;\n  return result;\n}\n\n//---------------------------------------------\nvec3 rotationCoordX(vec3 n, float t)\n{\n vec3 result;\n\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n\n      rotate = mat3( 1.0,  0.0,  0.0,\n                     0.0,  sc.y, -sc.x,\n                     0.0, sc.x, sc.y);   \n\n  result = n * rotate;\n  return result;\n}\n\n//------------------------------------------\nfloat sdPlaneY( vec3 p )\n{\n\treturn p.y;\n}\n\n//----------------------------------------------------\nfloat sdSphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n\n//----------------------------------------------------\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n//----------------------------------------------------------------\nvec3 InstantiateRotY(vec3 p, float inPiFrac)\n{\n\tfloat rad\t\t= mod(atan(p.x, p.z) +  PIH*inPiFrac, PI*inPiFrac) - PIH*inPiFrac;\n\tp.xz\t\t\t= vec2(sin(rad), cos(rad)) * length(p.xz);\n\treturn p;\n}\n\n//--------------------------------------------------\nfloat smin( float a, float b, float k ) \n{\n   float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------\nvec2 minDistMat(vec2 curDist, vec2 dist)\n{\n   \tif (dist.x < curDist.x) \n   \t{\n    \treturn dist;\n   \t}\n   \treturn curDist;\n}\n\n//---------------------------------------------\nfloat body(in vec3 p) {\n    float d = sdSphere(p*vec3(0.85,1.0,1.2), 0.2);\n    d = smin(d, sdSphere(p*vec3(0.95,1.0,1.2)+vec3(0,-0.22,0), 0.05), 0.22);\n    d = smin(d, sdSphere(p*vec3(0.75,1.5,0.7)+vec3(0,0.15,0), 0.1), 0.3);\n    return d;\n}\n\n//---------------------------------------------\nvec2 diggy(in vec3 p, bool includeLamp) {\n    // body\n    vec2 d = vec2(body(p), DressMatType);\n    float dSmall = body((p+vec3(0.0,-0.05,-0.15))/0.8)*0.8;\n    d.x=max(-dSmall,d.x);\n    \n    // Lamp neck\n    vec3 curLampDispl = vec3(0.0,0.4, 0.2) + lampDispl;\n    vec4 b = sdBezier( vec3(0.0, 0.2, 0.0), vec3(0.0,0.7, 0.0), curLampDispl, p);\n    d.x = smin(d.x, b.x - (0.04 - 0.02*b.y), 0.1);\n    \n    // legs\n    vec3 symYPos = p;\n   \tsymYPos.x = abs(symYPos.x);  \n    d.x = smin(d.x, sdSphere(symYPos * vec3(1.4, mix(0.8, 0.72, abs(sin(jumpFreq))), 1.4) + vec3(-0.25, 0.2, 0.05), 0.1), 0.22); \n    \n    //d=200.0;\n    // arms\n    vec3 armsPos = symYPos + vec3(-0.26, -0.1, 0.0) + posDispl*0.3;\n    b = sdBezier( vec3(0.05, 0.1, 0.0), vec3(0.01, 0.0, 0.0), vec3(-0.05, -0.1, 0.0), armsPos);\n    d.x = smin(d.x, b.x - (0.1*sqrt(b.y)), 0.01);\n    \n    // eyes\n    vec3 eyesPos = symYPos + vec3(-0.08, -0.08, -0.135);\n    b = sdBezier( vec3(0.05, 0.0, -0.02), vec3(0.0, 0.06, -0.01), vec3(-0.05, 0.0, 0.01), eyesPos);\n    d = minDistMat(d, vec2(b.x - 0.01, EyesMatType)); \n    \n    // Lamp\n    if(includeLamp) {\n    \td = minDistMat(d, vec2(sdSphere(p-curLampDispl, 0.05), LampMatType));\n    }\n    \n    // Body inside dress\n    d = minDistMat(d, vec2(body(p/0.95)*0.95, BodyMatType));\n    \n    // Mouth\n    vec3 mouthPos = p + vec3(0.0, 0.06, -0.165);\n    mouthPos = rotationCoordX(mouthPos, -0.6);\n    float dMouth = udRoundBox(mouthPos, vec3(0.15, 0.08, 0.05), 0.01);\n    dMouth = max(sdSphere(p*vec3(0.6, 0.93, 0.85) + vec3(0.0, 0.02, -0.1), 0.1), dMouth);\n    d = max(d, -dMouth);\n    \n    \n    // Teeth\n    vec3 teethPos = symYPos + vec3(-0.036, -0.01, -0.17);\n    teethPos = rotationCoordX(teethPos, 0.47);\n    teethPos = rotationCoordY(teethPos, 0.12);\n    d = minDistMat(d, vec2(udRoundBox(teethPos, \n                                      vec3(0.02+0.008*smoothstep(-0.035, 0.035, teethPos.y), 0.035, 0.005), 0.01), TeethMatType));\n    \n    return d;\n    \n}\n\n//--------------------------------------------------\nvec2 map(in vec3 p, bool includeLamp)\n{\n   \tvec3 pos = p;\n        \n   \tvec2 d = vec2(1.0, bgMatType);\n    \n    d = minDistMat(d, diggy(pos + vec3(0.0, -0.365, 0.0) + posDispl, includeLamp));\n    \n    // Planes\n    d = minDistMat(d, vec2(sdPlaneY(pos), PlaneMatType));\n        \n\treturn d; \n}\n\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n   vec3 e = vec3( EPSILON, 0., 0. );\n   vec3 nor = vec3(\n       map(p+e.xyy, true).x - map(p-e.xyy, true).x,\n       map(p+e.yxy, true).x - map(p-e.yxy, true).x,\n       map(p+e.yyx, true).x - map(p-e.yyx, true).x);\n   return normalize(nor);  \n\n}\n\n//------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {        \n\t\tfloat h = map( ro + rd*t, false ).x;\n        res = min( res, 10.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<EPSILON || t>tmax ) break;\n    }\n    return clamp(res, 0.0, 1.0 );\n}\n\n//------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n#ifdef CHEAP_AO\n    return mix(0.5, 1.0, clamp((nor.y + 1.0) * 0.5, 0.0, 1.0)); \n#else\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n    \tfloat hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( pos, false ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 0.5*occ, 0.0, 1.0 );   \n#endif\n}\n\n\n//------------------------------------------\nvec3 illum(in vec3 pos, in vec3 rd ,in vec3 nor, in vec3 lig, in vec3 col, in float t, in float mat, in vec3 add)\n{\n    // lighitng \n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );  \n    \n    vec3 pointLigDir = (lampPos+lampDispl+posDispl)-pos;\n    float distToPointLig = length(pointLigDir);\n    pointLigDir /= distToPointLig;\n    \n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 )*lightIntensity;\n    float difPoint = clamp( dot( nor, pointLigDir ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),1.0);\n    \n    float pointLightInt = clamp(lampLightIntensity-distToPointLig*lampLightAtt,0.0, lampLightIntensity);\n    difPoint *= pointLightInt;\n        \n#ifndef SELF_SHADOW\n    if(mat == PlaneMatType) \n    {\n#endif\n    \tdif *= softshadow( pos, lig, 0.1, 10.0 );\n        difPoint *= softshadow( pos, pointLigDir, 0.1, 10.0 );\n#ifndef SELF_SHADOW\n    }\n#endif\n    \n    vec3 brdf = vec3(0.0);\n    brdf += dif*vec3(1,1,1)+difPoint*lampLightColor;\n    brdf += 0.5*(spe*vec3(1,1,1)*dif+spe*difPoint*lampLightColor);\n    brdf += 0.30*amb*ambientLight*occ;\n    brdf += 0.10*dom*ambientLight*occ;\n    brdf += 1.0*bac*vec3(0.25,0.25,0.25)*occ;\n   \tbrdf += clamp(lightIntensity+pointLightInt*0.2,0.0,1.0)*fre*vec3(1.00,1.00,1.00)*occ;\n    brdf += 0.02;\n\tcol = col*brdf;\n    \n    return col + add;\n}\n//----------------------------------------------------------------------\nvec3 getColor(inout vec3 ro, vec3 rd, vec2 t)\n{\n  \tvec3 color = skyColor; \n \n   \tfloat mat =  t.y;\n   \tif (mat > 0.0) \n   \t{\n        vec3 hitPos = ro + rd * t.x;\n  \t\tvec3 normal = vec3(1,0,0);\n        vec3 add = vec3(0);\n        \n        if(mat == PlaneMatType)\n        {\n            normal = vec3(0,1,0);\n            color = planeColor;\n        }\n        else \n        {\n        \tnormal = normalize(getNormal(hitPos)); \n            add = vec3(smoothstep(0.6, 0.8, 1.0 - max(dot(-rd, normal), 0.0))); \n   \t\t\tif (mat == BodyMatType) \n   \t\t\t{\n\t\t    \tcolor = bodyColor;\n   \t\t\t}\n        \telse if(mat == DressMatType)\n        \t{\n            \tcolor = dressColor;\n        \t}\n        \telse if(mat == LampMatType)\n        \t{\n            \tfloat intensity = smoothstep(0.0, 2.0, lampLightIntensity);\n            \tfloat diff = max(clamp(intensity, 0.2, 1.0), dot(normal, lightDir));\n    \t\t\tfloat back = max(clamp(intensity, 0.2, 1.0), dot(normal, -lightDir));\n    \t\t\tfloat spec = pow(clamp(dot(lightDir, reflect(rd, normal)), 0.0, 1.0), 32.0);\n            \n            \tvec3 mate = lampLightColor * 0.9;\n            \tcolor = (diff + 0.5 * back) * mate + spec * vec3(1.0);\n        \t}\n        \telse if (mat == EyesMatType)\n        \t{\n            \tcolor = eyesColor;\n        \t}\n        \telse if (mat == TeethMatType)\n        \t{\n            \tcolor = teethColor;\n        \t}\n        }\n        \n        if(mat != LampMatType) {\t    \n    \t\tcolor = illum(hitPos, rd, normal, lightDir, color.rgb, t.x, mat, add);                   \n       \t}\n    }\n   \n  \treturn color;\n}\n\n//-------------------------------------------------\nvec2 render(in vec3 posOnRay, in vec3 rayDir)\n{ \n    vec2 t = vec2(0.0, bgMatType);\n    float maxDist = 25.0;\n    for(int i=0; i<MAX_ITER; ++i)\n    {\n        vec2 d = map(posOnRay + t.x*rayDir, true); \n        if (abs(d.x) < EPSILON || t.x > maxDist) \n            break;\n        t.x += d.x;\n        t.y = d.y;\n    }\n    return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n    pos.x *= iResolution.x / iResolution.y;  \n       \n    vec3 camP = rotationCoordY(vec3(0., 0.4, 1.8), time);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(vec3(0.0, 0.3, 0.0)-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(2. * camDir + pos.x * u + pos.y * v);  \n   \t \n    vec2 t =  render(camP, rayDir);  \n    vec3 color = getColor(camP, rayDir, t); \n    \n    // gamma\n\tcolor = pow( clamp( color, 0.0, 1.0 ), vec3(0.45) );\n    \n    // vignetting\n    pos*=0.35;\n    float distSqr = dot(pos, pos);\n\tfloat vignette = 1.0 - distSqr;\n    color *=  vignette;\n    \n    fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1026, 1142, 1171, 1171, 1197], [1198, 1198, 1245, 1245, 1723], [1725, 1725, 1774, 1774, 2184], [2186, 2234, 2272, 2272, 2504], [2506, 2554, 2592, 2592, 2822], [2824, 2869, 2895, 2895, 2910], [2912, 2967, 3000, 3000, 3027], [3029, 3084, 3129, 3129, 3169], [3171, 3238, 3284, 3284, 3427], [3429, 3482, 3524, 3524, 3615], [3617, 3665, 3707, 3707, 3788], [3790, 3838, 3861, 3861, 4079], [4081, 4129, 4170, 4182, 6091], [6093, 6146, 6185, 6185, 6436], [6438, 6491, 6518, 6518, 6764], [6766, 6811, 6885, 6885, 7162], [7164, 7209, 7251, 7251, 7649]], "test": "valid"}
{"id": "Xl3XRn", "name": "Lorenzo", "author": "metabog", "description": "Fractal style rendering of lorenz attractor, but not actually a fractal. ", "tags": ["fractal", "lorenzattractor"], "likes": 0, "viewed": 95, "published": "Public", "date": "1477565359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n     //float pr = min(cos(uv.y* iTime),   sin(uv.x* iTime)) ;\n     float pr = 0.5;\n\t float r = cos(0.2*iTime)*10.0+5.8;\n\t float b = 3.0;\n\t float\txn = 1.1;\n\t float\tyn = 12.0;\n\t float\tzn = uv.x*iTime;\n    \n    //zooooom\n    xn =(uv.x - 0.5) *4.0;\n    yn =(uv.y-0.5)*65.0;\n    \n    float intens = 0.0;\n    //iterate at this pixel for a while and solve lorenz oscillator equations\n    for(int i = 0; i <40; i++)\n    {\n        float xnn = xn*yn + (pr * (yn - zn));\n\t\tfloat ynn = yn*zn + (-xn * zn*zn);\n\t\tfloat znn = zn*xn + (xn * zn);\n\t\txn = xnn;\n\t\tyn = ynn;\n\t\tzn = znn;\n        if(length(vec3(xnn,ynn,znn))>200.0)\n        {\n            intens = float(i)/40.0;\n            break;\n        }\n    }\n    \n\tfragColor = vec4(hsv2rgb(vec3(intens*0.5,0.8,0.8)),1.0) * pow(intens,0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3XRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 353], [355, 355, 377, 377, 546], [548, 548, 605, 605, 1427]], "test": "valid"}
{"id": "XlG3zV", "name": "Millisecond Timer", "author": "jherico", "description": "A simple tool for creating an on-screen timer that can be used with a high speed camera to count the time between frames.  Each box represents a millisecond of time, with entire grid being a tenth of a second.  ", "tags": ["utility"], "likes": 2, "viewed": 654, "published": "Public API", "date": "1475441445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool squared(out vec2 uv, in vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    float min = min(iResolution.x, iResolution.y);\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    uv.x += (1.0 - aspect) / 2.0;\n    if (clamp(uv, vec2(0.0), vec2(1.0)) != uv) {\n        return false;\n    }\n    return true;\n}\n\n#define GRID_WIDTH 0.05\n#define GRID_DIM 10.0\n#define GRID_COUNT (GRID_DIM * GRID_DIM)\n\nconst vec3 ON_COLOR = vec3(24, 202, 230) / 255.0;\nconst vec3 OFF_COLOR = vec3(251, 0, 9) / 255.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    if (!squared(uv, fragCoord)) {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    } \n\n    vec2 grid = uv * GRID_DIM;\n    vec2 floorGrid = floor(grid);\n    vec2 offset = grid - floorGrid;\n    if (offset != clamp(offset, vec2(GRID_WIDTH), vec2(1.0 - GRID_WIDTH))) {\n        fragColor = vec4(vec3(0.5), 1.0);\n        return;\n    }\n    \n    \n    float square = floorGrid.x + GRID_DIM * floorGrid.y;\n    float f = mod(float(iTime * 1000.0), GRID_COUNT);\n    \n    fragColor = vec4(square > f ? ON_COLOR : OFF_COLOR, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlG3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 337], [526, 526, 583, 583, 1125]], "test": "valid"}
{"id": "XlGGWt", "name": "Primitives - Stripes (color)", "author": "stuaxo", "description": "Extension of this https://www.shadertoy.com/view/XtK3Dc to use different colors.\n\nUpdated from @FabriceNeyret2's comment.", "tags": ["stripe"], "likes": 5, "viewed": 184, "published": "Public", "date": "1477325050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define stripe(t, origin, width, s)   smoothstep(0., s, width/2. - abs(t-(origin)))\n\n#define h2rgb(c)   clamp( abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.) -1., 0., 1.)\n\n#define NUM_STRIPES 7.\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tU /= iResolution.xy;\n    float s = .05, T = iTime, t;\n     \n    O -= O;\n\n    for(float i = 1.; i <= NUM_STRIPES; i++)\n        t = stripe( U.x,\n                    .5 + .25* sin( .4* cos(T*i) * (i-4.+ 2.*U.y + .04*sin(T) -.5) ) ,\n                    .1, s),\n        O = mix(O, h2rgb( (i-4.) / NUM_STRIPES ), t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 231, 231, 545]], "test": "valid"}
{"id": "XlKGRt", "name": "Cube surface", "author": "Nesvi7", "description": "Surface made of rotating cubes. Looks better in fullscreen scale.", "tags": ["raymarching", "cube", "rotations", "module"], "likes": 4, "viewed": 172, "published": "Public", "date": "1476210194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//By Nestor Vina\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n\n\nvec3 rotate( vec3 p, vec3 rot ){\n    rot.z = -rot.z;\n    mat3 ry = mat3(cos(rot.y), 0.0,-sin(rot.y),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(rot.y), 0.0, cos(rot.y)  );\n    \n\tmat3 rz = mat3(cos(rot.z),-sin(rot.z), 0.0,\n\t\t\t   sin(rot.z), cos(rot.z), 0.0,\n\t\t\t   0.0, 0.0, 1.0 );\n     \n\tmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(rot.x), sin(rot.x), \n\t\t\t   0.0,-sin(rot.x), cos(rot.x) );\n    return p*rz*ry*rx;\n}\n\n\nfloat cubes( vec3 p, vec3 b,float c )\n{\n  p = rotate(p,vec3(-PI*0.3,0.0,0.0));\n  vec3 initialp = p;\n  p.xz = mod(p.xz,c) - 0.5 * c;\n  vec2 index = floor(initialp.xz/c);\n  \n  float incidence = length(index)*0.1;\n  incidence += sin((index.x + index.y)*0.1 + iTime*0.1)*0.03;\n\n  p = rotate(p,vec3(iTime*incidence,iTime*incidence,0.0));\n  \n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//Map\nvec2 mapCubeSkin(vec3 p){\n    float c = 1.0;\n    vec2 index = floor(p.xz/c);\n    float minDist = cubes(p,vec3(0.5,0.5,.5),c);\n   \tfloat color = (1.0+sin(length(index.xy)*0.2+iTime))*0.5;\n\treturn vec2(minDist, color);\n}\nvec2 map( vec3 p) {\n    p.y += sin((p.x+p.z)*0.3+iTime*3.0);\n    return mapCubeSkin(p);\n}\n\nvec2 rayMarching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 material( vec3 v, vec3 n, vec3 eye,float randomIndex ) {    \n    //Texturing \n    vec2 uv = v.xz;    \n    \n    //vec3 albedo = texture(iChannel0,vec2(randomIndex,0.0)).xyz;//vec3(0.5,0.0,0.0);\n    vec3 albedo = mix(vec3(0.5,0.1,0.4),vec3(0.1,0.1,0.6),randomIndex);\n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float diffuse = dot(sunDir,n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    \n    return albedo+diffuse+ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, -6.0, 45.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(0,2.0*PI));\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    vec2 rayResult = rayMarching( eye, dir, 2.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(0.3,0.3,0.3,1.0);//Background color\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    vec3 fogColor = vec3(0.3,0.3,0.3);\n    \n   \tfragColor = vec4(material( pos, n, eye,rayResult.y ), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 293, 325, 325, 696], [699, 699, 738, 738, 1121], [1123, 1129, 1154, 1154, 1347], [1348, 1348, 1367, 1367, 1437], [1439, 1439, 1506, 1506, 1835], [1837, 1837, 1885, 1885, 2061], [2063, 2063, 2088, 2088, 2392], [2394, 2394, 2425, 2425, 2582], [2584, 2584, 2626, 2626, 2662], [2664, 2664, 2725, 2746, 3178], [3180, 3180, 3237, 3257, 3875]], "test": "error"}
{"id": "XlVGR3", "name": "Atmospheric Moon", "author": "capitanNeptune", "description": "Experimenting with normals and simplex noise.\nif anybody know how I can fight the atmosphere aliasing, please teach me :D", "tags": ["normals", "planet", "simplex3d"], "likes": 41, "viewed": 2230, "published": "Public API", "date": "1475865779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// all noise from iq!\n\n#define time iTime\n\n// INNER ATMOS PROPIETIES:\n    // inner atmos inner strenght\n    #define in_inner 0.2\n    // inner atmos outer strenght\n    #define in_outer 0.2\n\n// OUTER ATMOS PROPIETIES:\n    // inner atmos inner strenght\n    #define out_inner 0.2 \n    // inner atmos outer strenght\n    #define out_outer 0.4 // 0.01 is nice too\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\tif(x0>=y0)\n\t{\n\t\tif\t\t(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if\t(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse \t\t\t{ i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif\t\t(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if\t(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse \t\t\t{ i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t     \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*(simplex3D( p )); p = p*2.01;\n    f += 0.25000*(simplex3D( p )); p = p*2.02;\n    f += 0.12500*(simplex3D( p )); p = p*2.03;\n    f += 0.06250*(simplex3D( p )); p = p*2.04;\n    f += 0.03125*(simplex3D( p )); p = p*2.05;\n    f += 0.015625*(simplex3D( p ));\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 pos = vec3(gl_FragCoord.xy - iResolution.xy/2.0,0.0); // planet center\n    \n    // LIGHT\n    vec3 l = normalize(vec3(sin(time), sin(time*0.5), (cos(time))));\n    \n    // PLANET\n    float r = iResolution.y/3.0; // radius\n    float z_in = sqrt(r*r - pos.x*pos.x - pos.y*pos.y);\n    float z_out = sqrt(-r*r + pos.x*pos.x + pos.y*pos.y);\n    \n    // NORMALS\n    vec3 norm = normalize(vec3(pos.x, pos.y, z_in)); // normals from sphere\n    vec3 norm_out = normalize(vec3(pos.x, pos.y, z_out)); // normals from outside sphere\n    float e = 0.05; // planet rugosity\n    float nx = fbm(vec3(norm.x+e, norm.y,   norm.z  ))*0.5+0.5; // x normal displacement\n    float ny = fbm(vec3(norm.x,   norm.y+e, norm.z  ))*0.5+0.5; // y normal displacement\n    float nz = fbm(vec3(norm.x,   norm.y,   norm.z+e))*0.5+0.5; // z normal displacement\n    norm = normalize(vec3(norm.x*nx, norm.y*ny, norm.z*nz));\n    //norm = (norm+1.)/2.; // for normals visualization\n\t\n    // TEXTURE\n    float n = 1.0-(fbm(vec3(norm.x, norm.y, norm.z))*0.5+0.5); // noise for every pixel in planet\n    \n    // ATMOS\n    float z_in_atm  = (r * in_outer)  / z_in - in_inner;   // inner atmos\n    float z_out_atm = (r * out_inner) / z_out - out_outer; // outer atmos\n    z_in_atm = max(0.0, z_in_atm);\n    z_out_atm = max(0.0, z_out_atm);\n    \n    // DIFFUSE LIGHT\n    float diffuse = max(0.0, dot(norm, l));\n    float diffuse_out = max(0.0, dot(norm_out, l)+0.3); // +0.3 because outer atmosphere stills when inner doesn't\n    \n\t//fragColor = vec4(vec3(n * diffuse),1.0);\n    //fragColor = vec4(vec3(z_in_atm * diffuse),1.0);\n    //fragColor = vec4(vec3(z_out_atm * diffuse_out),1.0);*/\n    \n    fragColor = vec4(vec3(n * diffuse + z_in_atm * diffuse + z_out_atm * diffuse_out),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 358, 381, 381, 462], [464, 464, 489, 489, 2601], [2603, 2603, 2622, 2622, 2916], [2918, 2918, 2975, 2975, 4731]], "test": "valid"}
{"id": "XlVGRy", "name": " 4-leaf clover", "author": "pnly", "description": "\n\nHappiness of 4-leaf clover for Chieri.", "tags": ["2dparticles"], "likes": 14, "viewed": 600, "published": "Public", "date": "1475335459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _ParticlesAmount 10\n\nfloat rnd(float x)\n{\n    return fract(sin(dot(vec2(x + 47.49,38.2467 / (x + 2.3)), vec2(12.9898, 78.233))) * (43758.5453));\n}\n\nfloat drawLeaf(vec2 uv, float scale, float d) {\n\tfloat ret;\n    vec2 root = uv - vec2(0.0, scale);\n    float r = length(root) / scale;\n    float t = abs(atan(root.x, root.y) / 3.1415);\n    float edge = (3.0 * t - 8.0 * t*t*t*t + 6.0 * t*t*t*t*t) / (4.0 - 3.0 * t);\n    //float edge = (3.0 * t - 8.0 * t*t*t*t*t + 6.0 * t*t*t*t*t*t) / (3.0 - 2.0 * t*t);\n    //float edge = (3.0 * t + 2.0 * t*t - 2.0 * t*t*t - 9.0 * t*t*t*t*t*t + 7.0 * t*t*t*t*t*t*t) / (5.0 - 4.0 * t*t);\n\tret = smoothstep(edge - d, edge + d, r);\n\treturn ret;\n}\n\nmat2 rotate(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat drawClover(vec2 uv, float scale, float d) {\n    float ret = drawLeaf(uv, scale, d);\n    uv = rotate(1.5707) * uv;\n    ret *= drawLeaf(uv, scale, d);\n    uv = rotate(1.5707) * uv;\n    ret *= drawLeaf(uv, scale, d);\n    uv = rotate(1.5707) * uv;\n    ret *= drawLeaf(uv, scale, d);\n    return 1.0 - ret;\n}\n\nvec4 alphaBlend(vec4 base, vec4 blend)\n{\n    return vec4(base.rgb * base.a * (1.0 - blend.a) + blend.rgb * blend.a, blend.a + base.a * (1.0 - blend.a));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float t = smoothstep(1.5, 0.0, length(uv));\n    fragColor = vec4(t * vec3(1, 0.8784, 0.9333) + (1.0 - t) * vec3(0.9568, 0.7451, 0.8118), 1.0);\n    \n    float j;\n    float move_max = 1.0;\n    vec2 spawn_center = vec2(0.0, 0.0);\n    float spawn_length = 0.5;\n    float _ParticlesAmount_f = float(_ParticlesAmount);\n    \n    for (int i = 1; i < _ParticlesAmount; i++)\n    {\n        j = float(i);\n        float rnd1 = rnd(cos(j));\n        float delayedTime = (0.2 + 0.2 * rnd1) * iTime;\n        float d = floor(delayedTime / move_max);\n        float rnd2 = rnd(j * d);\n        float rnd3 = rnd(j * j * d);\n        float r = delayedTime / move_max - d;\n        float x_wave = 0.15 * sin(delayedTime * 7.0 + 6.282 / j);\n        vec2 spawn = vec2(0.0, rnd3 * spawn_length);\n        float ease = pow(2.0, 5.0 * (r - 1.0));\n        float y_move = move_max * ease;\n        float opacity = 1.0 - ease - pow(2.0, -30.0 * r);\n        float scale = 1.0 - 0.65 * rnd1 + 0.15 * sin(1.8 * iTime * j / _ParticlesAmount_f + 6.282 / j);\n        float rot_wave = 2.0 * sin(delayedTime * 3.0 * j / _ParticlesAmount_f * 2.0 + 6.282 / j);\n    \tvec2 center = rotate(rot_wave) * (rotate(6.282 * rnd2) * (uv + spawn_center) + spawn + vec2(x_wave, y_move)) * scale;\n        vec3 cloverColor = vec3(0.3 + 0.3 * rnd2, 0.98, 0.3) * (1.0 - 0.3 * rnd3);\n    \tvec3 cloverCenterColor = cloverColor + (vec3(1.0) - cloverColor) * 0.5;\n    \tvec3 cloverBgColor = vec3(1.0, 0.98, 0.7);\n    \tfragColor = alphaBlend(fragColor, vec4(cloverBgColor, opacity * drawClover(center, 0.1, 0.3)));\n   \t\tfragColor = alphaBlend(fragColor, vec4(cloverColor, opacity * drawClover(center, 0.1, 0.01)));\n    \tfragColor = alphaBlend(fragColor, vec4(cloverCenterColor, opacity * drawClover(center, 0.05, 0.3)));\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 49, 49, 154], [156, 156, 203, 203, 683], [685, 685, 707, 707, 759], [761, 761, 810, 810, 1069], [1071, 1071, 1111, 1111, 1228], [1230, 1230, 1287, 1287, 3138]], "test": "valid"}
{"id": "Xly3Wt", "name": "Spooky Overlay", "author": "StrongJoshua", "description": "Camera overlay for spooky/horror games.", "tags": ["2d", "spooky"], "likes": 2, "viewed": 204, "published": "Public", "date": "1477334909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define white vec4(1, 1, 1, 1)\n#define black vec4(0, 0, 0, 0)\n\nfloat dist(vec2 c, vec2 v) {\n    vec2 d = c - v;\n\treturn sqrt(d.x * d.x + d.y * d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(iResolution.x / 2., iResolution.y / 2.);\n    \n    float speed = 3.;\n    float baseRadius = 350.;\n    float range = 25.;\n    \n\tfloat radius = baseRadius + range * sin(iTime * speed);\n    float x = fragCoord.x - center.x;\n    float y = fragCoord.y - center.y;\n    if(x * x + y * y > radius * radius) fragColor = black;\n    else fragColor = white - white * (dist(center, fragCoord) / radius);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xly3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 91, 91, 150], [152, 152, 209, 209, 624]], "test": "valid"}
{"id": "XlyGRd", "name": "Rhodium Tunnel", "author": "Virgill", "description": "Tunnel effect from Rhodium 4k Intro\n4kb executable: http://www.pouet.net/prod.php?which=68239\nhttps://www.youtube.com/watch?v=YK7fbtQw3ZU", "tags": ["tunnel", "demoscene", "spheretracing", "organic", "colorsplit"], "likes": 19, "viewed": 1289, "published": "Public API", "date": "1476088036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ***********************************************************\n// Alcatraz / Rhodium 4k Intro tunnel\n// by Jochen \"Virgill\" Feldkötter\n//\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\n// ***********************************************************\n\n\n\nfloat bounce;\n\n// rotation\nvoid pR(inout vec2 p,float a) \n{\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n\nfloat map(vec3 p)\n{\t\n// \ttunnel    \n\tp.z+=(3.-sin(0.314*iTime+1.1));\n\tpR(p.zy,1.57);\n\treturn  mix(length(p.xz)-.2,length(vec3(p.x,abs(p.y)-1.3,p.z))-.2,step(1.3,abs(p.y)))-0.1*noise(8.*p+0.4*bounce);\n}\n\n//\tnormal calculation\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.0001;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n// \tstandard sphere tracing inside and outside\nfloat castRayx(vec3 ro,vec3 rd) \n{\n    float function_sign=(map(ro)<0.)?-1.:1.;\n    float precis=.0001;\n    float h=precis*2.;\n    float t=0.;\n\tfor(int i=0;i<120;i++) \n\t{\n        if(abs(h)<precis||t>12.)break;\n\t\th=function_sign*map(ro+rd*t);\n        t+=h;\n\t}\n    return t;\n}\n\n// \trefraction\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\n{\n    float h=0.;\n    t2=2.;\n\tvec3 dir2=refract(dir,nor,angle);  \n \tfor(int i=0;i<50;i++) \n\t{\n\t\tif(abs(h)>3.) break;\n\t\th=map(pos+dir2*t2);\n\t\tt2-=h;\n\t}\n    nor2=calcNormal(pos+dir2*t2);\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\n}\n\n//\tsoftshadow \nfloat softshadow(vec3 ro,vec3 rd) \n{\n    float sh=1.;\n    float t=.02;\n    float h=.0;\n    for(int i=0;i<22;i++)  \n\t{\n        if(t>20.)continue;\n        h=map(ro+rd*t);\n        sh=min(sh,4.*h/t);\n        t+=h;\n    }\n    return sh;\n}\n\n//\tmain function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{    \n    float bounce=abs(fract(0.05*iTime)-.5)*20.; // triangle function\n\n    \n\tvec2 uv=gl_FragCoord.xy/iResolution.xy; \n    vec2 p=uv*2.-1.;\n   \n// \tbouncy cam every 10 seconds\n    float wobble=(fract(.1*(iTime-1.))>=0.9)?fract(-iTime)*0.1*sin(30.*iTime):0.;\n    wobble*=0.3;\n    \n//  camera    \n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y));\n    vec3 org = vec3(0,2.*wobble,-3.);  \n   \tdir = normalize(vec3(dir.xy, sqrt(max(dir.z*dir.z - dot(dir.xy, dir.xy)*.2, 0.))));//barrel\n  \tvec2 m = sin(vec2(0, 1.57) + iTime/8.);\n   \tdir.xy = mat2(m.y, -m.x, m)*dir.xy;\n   \tdir.xz = mat2(m.y, -m.x, m)*dir.xz;\n\n\n// \tstandard sphere tracing:\n    vec3 color=vec3(0.);\n    vec3 color2=vec3(0.);\n    float t=castRayx(org,dir);\n\tvec3 pos=org+dir*t;\n\tvec3 nor=calcNormal(pos);\n\n// \tlighting:\n    vec3 lig=normalize(-pos);//:vec3(.2,6.,.5));\n//\tscene depth    \n    float depth=clamp((1.-0.09*t),0.,1.);\n    \n    vec3 pos2,nor2 =  vec3(0.);\n    if(t<12.0)\n    {\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\n       \tfloat t2;\n\t\tcolor2.r +=refr(pos,lig,dir,nor,0.91, t2, nor2)*depth;\n  \t\tcolor2.g +=refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\n   \t\tcolor2.b +=refr(pos,lig,dir,nor,0.89, t2, nor2)*depth;\n\t\tcolor2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\n\t}      \n    float tmp = 0.;\n    float T = 1.;\n\n//\tanimation of glow intensity    \n    float intensity = 0.1*-sin(.209*iTime+1.)+0.1; \n\tfor(int i=0; i<128; i++)\n\t{\n        float density = 0.; float nebula = noise(org+bounce);\n        density=intensity-map(org+.5*nor2)*nebula;\n\t\tif(density>0.)\n\t\t{\n\t\t\ttmp = density / 128.;\n            T *= 1. -tmp * 100.;\n\t\t\tif( T <= 0.) break;\n\t\t}\n\t\torg += dir*0.078;\n    }    \n\tvec3 basecol=vec3(1./1. ,  1./4. , 1./16.);\n    T=clamp(T,0.,1.5); \n    color += basecol* exp(4.*(0.5-T) - 0.8);\n    color2*=depth*depth;\n    color2+= (1.-depth)*noise(6.*dir+0.3*iTime)*.1;\t// subtle mist\n\n\n\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,0.);\n}\n\n\n\n", "image_inputs": [{"id": "ldSGRm", "previewfilepath": "https://soundcloud.com/virgill/4klang-rhodium", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/virgill/4klang-rhodium", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 349, 381, 381, 418], [421, 447, 468, 468, 718], [721, 721, 740, 756, 922], [924, 946, 973, 973, 1117], [1119, 1166, 1200, 1200, 1440], [1442, 1457, 1546, 1546, 1819], [1821, 1836, 1872, 1872, 2068], [2070, 2087, 2141, 2141, 4216]], "test": "valid"}
{"id": "XtcSRr", "name": "Multiplication Tables", "author": "Patapom", "description": "Based on Mathologer episode https://www.youtube.com/watch?v=qhbuKbxJsk8", "tags": ["circle", "modulo", "multiplication"], "likes": 14, "viewed": 344, "published": "Public", "date": "1477593169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This shows the multiplication table modulo 200 represented as lines connecting points\n//\ton the unit circle, as explained in the Mathologer video https://www.youtube.com/watch?v=qhbuKbxJsk8\n//\n// I also inverted the positions outside the unit disk to reflect the inside so the look\n//\tis even more interesting :D\n//\n// EDIT: Fixed smoothstep not working with singularity when start and end angles are both 0 (obviously gave a 0/0 NaN)\n//\nconst float\tTWOPI = 6.283185307179586476925286766559;\n    \nconst float\tMODULO = 200.0;\t// Amount of subdivisions of the circle\n\nvec3 ComputeInnerColor( vec2 _uv, float _mul ) {\n\n    float\tisOnLine = 0.0;\n    \n\tvec2\tscStart, scEnd;\n\n\t// Compute start and end anglse based on multiplier\n\tfloat\tdStartAngle = TWOPI / MODULO;\n\tfloat\tdEndAngle = _mul * dStartAngle;\n\tfloat\tstartAngle = dStartAngle;\n\tfloat\tendAngle = dEndAngle;\n\n    for ( float i=1.0; i < MODULO; i++ ) {\n        // Compute start and end position on the unit circle, forming a line\n        scStart.x = sin( startAngle );\n        scStart.y = cos( startAngle );\n        scEnd.x = sin( endAngle );\n        scEnd.y = cos( endAngle );\n        \n        // Compute line normal\n        vec2\tnormal = normalize( vec2( scEnd.y - scStart.y, scStart.x - scEnd.x ) );\n        \n        // Compute distance to line\n        vec2\tdelta = _uv - scStart;\n        float\torthoDistance = abs( dot( delta, normal ) );\n        \n        // Check if the current position is on the line or not\n        isOnLine += smoothstep( 0.005, 0.0, orthoDistance );\n        \n        startAngle += dStartAngle;\n        endAngle += dEndAngle;\n    }\n\n    return vec3( 1.0 - clamp( isOnLine, 0.0, 1.0 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2\tR = iResolution.xy;\n    vec2\tuv = ( 2. * fragCoord - R ) / R.y;\n    \nuv *= 2.0 + sin( iTime );\n    \n    float\tmul = 1.0 + 99.0 * (1.0 - cos( 0.02 * iTime ));\n\n    float\tradius = length( uv );\n//\tfloat\tD = radius < 1. ? 1. :  1. / (radius * radius);\n    float\tD = mix( 1.0, 1.0 / (radius*radius), smoothstep( 0.95, 1.0, radius ) );\t// Smoother joint between regular and reciprocal space\n\tfragColor = vec4( ComputeInnerColor( D*uv, mul ), 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[528, 569, 617, 617, 1668], [1670, 1670, 1727, 1727, 2179]], "test": "valid"}
{"id": "XtcSzn", "name": "Dulplicex - 210's limit", "author": "Imsure1200q_1UWE130", "description": "RAYMARCHING RAYCASTING RAYTRACING WATEVER IM GRADE 4 & 9 YRS OLD K????!!!!!\nOkay so this shader is a DULPLICEX which can be a remix. This is still in progress. Plz always do positive.\n-Imsure1200q", "tags": ["ray"], "likes": 2, "viewed": 570, "published": "Public API", "date": "1477579455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pix gl_FragCoord.xy / iResolution.xy\n//Dulplicex - 210's limit -- Copyright October 30, 2016.\n//Dulplicex - 210 ni limit -- Karapatang-ari sa Oktubre 30, 2016.\n//Dulplicex/マルチプレックス  -  210の制限 - 著作権2016年10月30日\n//Dulplicex/復用  -  210's limit  - 版權所有2016年10月30日。\n//límite de 210 - - Dulplicex/Multicine Derechos de Autor 30 de de octubre de 2016.\n//                                                     FFFFF   U   U   L      L      Y   Y\n//                                                     F       U   U   L      L      Y   Y\n//IMPORTANT: VOXELSIZE: DO NOT EDIT OR THE SHADER WILL FFFFF   U   U   L      L       YYY  crash!\n//                                                     F       U   U   L      L        Y\n//                                                     F        UUUU   LLLLL  LLLLL    Y\nfloat size = 4.;\nfloat VoxelSize            = 0.5;  \nconst vec4 CLOUD_COLOR     = vec4(0.5, 0.3, 0.1, 1.0);\nconst vec4 CC              = CLOUD_COLOR + 0.3;\nconst float KEY_SPACE = 36.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return 1.0 - 2.0 * fract(sin(h) * 4358.5453);\n}\n\nfloat Noise(vec2 p, float x)\n{\n    vec2 i = sin(floor(p))*x;\n    i += floor(p)*(1.0-x);\n    vec2 f = fract(p);\n    vec2 u = (f * f * (3.0 - 2.0 * f));\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\nvec2 VecNoise(vec2 point)\n{\n    vec2 res;\n    res.x = Noise(point,0.0);\n    res.y = Noise(point + vec2(iTime),0.0);\n    return res;\n}\n\n\nfloat DistortionNoise(vec2 point, float distortion)\n{\n    vec2 offset = point + vec2(0.5);\n    offset = VecNoise(point);\n    offset *= distortion;\n    point += offset;\n    return Noise(point,0.0);\n}\n\n\nfloat FbmNoise(vec2 p)\n{\n  const float octaves = 8.0;\n  const float lacunarity = 2.0;\n  const float H = 0.5;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += Noise(p,0.0) * pow(lacunarity, -H * i);\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder >= 0.0) {\n    value -= remainder * Noise(p,0.0) - pow(lacunarity, -H * k);\n  }\n  return value;\n}\n\nfloat DistFbmNoise(vec2 p)\n{\n  const float octaves = 8.0;\n  const float lacunarity = 2.0;\n  const float H = 0.5;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += DistortionNoise(p, 1.0) * pow(lacunarity, -H * i);\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder != 0.0) {\n    value += remainder * Noise(p,0.0) * pow(lacunarity, -H * k);\n  }\n  return value;\n}\n\nvec3 Sky( in vec2 fragCoord, vec4 SKY_COLOR )\n{\n\tvec2 uv = vec2(0.1);\n    //uv *= sqrt(uv);\n    //uv = vec2(length(uv));\n        const float threshold = 0.351;\n        float value = DistFbmNoise(2.0 * uv);\n        vec4 ct = mix(SKY_COLOR - 0.1, \n                      CLOUD_COLOR,\n                      smoothstep(threshold, 1.3, value));\n        return ct.xyz;\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-r;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat3 rotate3d(float a)\n{\n    return mat3(cos(a),-sin(a),sin(a),\n                cos(a),cos(a),-sin(a),\n                sin(a),cos(a),cos(a));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nfloat blend (float a, float b, float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\nfloat maxComp(vec2 a)\n{\n    return max(a.x,a.y);\n}\nfloat maxComp(vec3 a)\n{\n    return max(max(a.x,a.y),a.z);\n}\nfloat maxComp(vec4 a)\n{\n    return max(max(a.x,a.y),max(a.z, a.w));\n}\nvec3 getNoiseP(vec3 p, float zoom)\n{\n    float z = FbmNoise(p.xy/zoom);\n    float x = FbmNoise(p.zy/zoom);\n    float y = Noise(p.xz/zoom,4.23);\n    float f = length(z);\n    float s = length(x);\n    float l = length(y);\n    vec3 new = vec3(f, s, l);\n    vec3 squared = sqrt(abs(1.0/exp(-0.002*new)));\n    vec3 other = new*log(squared)+sqrt(abs(squared));\n    return (maxComp(other)+maxComp(squared))*new;\n    \n}\nvec3 repToMt(vec3 p, float x)//Get Each Corner To The Height Of The Edge Of X\n{\n    vec3 y = vec3(p.x, p.y-x, p.z);\n    return y;\n}\nvec2 map( vec3 pos)\n{\n    float roundness = .15;\n  \tfloat rot = 1.;\n\tfloat k = .05;\n    float size = .5;\n    \n    float scale = 1. / ( 3. - clamp( pos.y, 1., 7. ) );\n    scale = 1.;\n    \n    vec2 x;\n    float iGlobalTim = iTime;\n    vec3 p = vec3(pos.x, pos.y, pos.z);\n    float d1;\n    //Putting An Object:\n    p = vec3(pos.x, pos.y-VoxelSize+(clamp(iGlobalTim, 15.96, 19.71)-15.96), pos.z);\n    p.xz*=rotate2d(clamp(iGlobalTim*7., 30.*7., 31.*7.)-30.*7.);\n    d1 = sdBox(opRep(p,vec3(clamp(iGlobalTim,0.0,10.0))-\n                     vec3((clamp(iGlobalTim,20.0,25.0)-20.0))+\n                     vec3(clamp(iGlobalTim,44.0, 64.0)-44.0)), vec3(VoxelSize));\n    x = vec2(d1, 2.0);\n    p = vec3(pos.x, pos.y-VoxelSize+(clamp(iGlobalTim, 15.96, 19.71)-15.96), pos.z);\n    p.xz*=rotate2d(clamp(iGlobalTim*7., 31.*7., 32.*7.)-31.*7.);\n    d1 = sdBox(opRep(p,vec3(clamp(iGlobalTim,1.0,10.0)-1.0)-\n                     vec3((clamp(iGlobalTim,21.0,26.0)-21.0))+\n                     vec3(clamp(iGlobalTim,44.0, 64.0)-44.0)), vec3(VoxelSize));\n    x = opU(vec2(d1, 2.0), x);\n    p = vec3(pos.x, pos.y-VoxelSize+(clamp(iGlobalTim, 15.96, 19.71)-15.96), pos.z);\n    p.xz*=rotate2d(clamp(iGlobalTim*7., 32.*7., 33.*7.)-32.*7.);\n    d1 = sdBox(opRep(p,vec3(clamp(iGlobalTim,2.0,10.0)-2.0)-\n                     vec3((clamp(iGlobalTim,22.0,27.0)-22.0))+\n                    vec3(clamp(iGlobalTim,44.0, 64.0)-44.0)), vec3(VoxelSize));\n    x = opU(vec2(d1, 2.0), x);\n    \n    p = vec3(pos.x, pos.y-(clamp(iGlobalTim,22.0,27.0)-22.0)\n             +(clamp(iGlobalTim,35.,43.0)-35.0)\n             +(clamp(iGlobalTim,45.0,65.0)-45.0), pos.z);\n    d1 = sdSphere(opRep(p, vec3((\n        clamp(iGlobalTim,10., 14.5)-10.)+\n        (clamp(iGlobalTim,45.0, 65.0)-45.)\n                               )),0.5);\n    x = opU(vec2(d1, 0.6), x);\n    \n    p = vec3(pos.x, pos.y+\n             (clamp(iTime, 52.0, 60.0)-52.0)-\n             (clamp(iTime, 34., 42.)-34.),\n             pos.z);\n    d1 = sdSphere(opRep(p, vec3(\n        (clamp(iTime, 9.0, 14.0)-9.0)\n        )//E\n        )\n                        , 0.5);\n    x = opU(vec2(d1, 1.0), x);\n    \n    if(iGlobalTim > 57.5)\n    {\n        float m = iTime-57.5;\n        p = vec3(pos.x, pos.y, pos.z);\n        d1 = sdBox(p, atan(vec3(m*4.)));\n        x = opU(vec2(d1, 1.0), x);\n    }\n    \n    float fx = 1.;\n    if(iTime > 210.*fx)\n    {\n        x -= x*((clamp(iTime, 210., 220.)-210.)/10.);\n    }\n    return x;\n    \n}\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 30.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m==0.6 )\n        {\n            \n            float f = FbmNoise(pos.xz+pos.y*2.);\n            if(f > 0.888) col = vec3(0.9, 0.5, 0.0);\n            else if(f < 0.002) col = vec3(0.4, 0.7, 1.0);\n            else col = vec3(0.0);\n            ;\n            \n        }\n        else if(m==1.0)\n        {\n            float f = FbmNoise(pos.xy+pos.zy+pos.xz);\n            col = 0.1*f*vec3(1.)-(1.-vec3(0.4, 0.7, 1.0));\n        }\n        else if(m==2.0)\n        {\n            float f = FbmNoise(pos.xy+pos.zy+pos.xz);\n            col = 0.4+0.1*f*vec3(1.)-(1.-vec3(0.9, 0.5, 0.01));\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(cos(iTime), cos(iTime/2.), sin(iTime)) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.9, 0.9, 0.7), 1.0-exp(\n            -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 5.*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y,5.*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 1.5, 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, sin(iTime/2.));\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsBGDz", "previewfilepath": "https://www.soundcloud.com/nocopyrightsounds/disfigure-blank", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://www.soundcloud.com/nocopyrightsounds/disfigure-blank", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 1201, 1221, 1221, 1314], [1316, 1316, 1346, 1346, 1673], [1675, 1675, 1702, 1702, 1808], [1811, 1811, 1864, 1864, 2009], [2012, 2012, 2036, 2036, 2431], [2433, 2433, 2461, 2461, 2867], [2869, 2869, 2916, 2916, 3232], [3233, 3233, 3258, 3258, 3273], [3274, 3274, 3319, 3319, 3408], [3409, 3409, 3445, 3445, 3529], [3530, 3530, 3565, 3565, 3591], [3592, 3592, 3620, 3620, 3706], [3707, 3707, 3731, 3731, 3850], [3851, 3851, 3884, 3884, 3949], [3950, 3950, 3974, 3974, 4106], [4107, 4107, 4148, 4148, 4235], [4236, 4236, 4267, 4267, 4354], [4356, 4356, 4386, 4386, 4419], [4420, 4420, 4450, 4450, 4479], [4480, 4480, 4503, 4503, 4530], [4531, 4531, 4554, 4554, 4590], [4591, 4591, 4614, 4614, 4660], [4661, 4661, 4697, 4697, 5071], [5072, 5072, 5151, 5151, 5203], [5204, 5204, 5225, 5225, 7640], [7641, 7641, 7681, 7681, 8271], [8272, 8272, 8346, 8346, 8607], [8609, 8609, 8641, 8641, 8861], [8862, 8862, 8904, 8904, 9203], [9205, 9205, 9244, 9244, 11281], [11283, 11283, 11335, 11335, 11512], [11514, 11514, 11571, 11571, 12152]], "test": "valid"}
{"id": "XtG3DG", "name": "Inverse Perspective small", "author": "ollj", "description": "simpler cleaner version of\nhttps://www.shadertoy.com/view/4djXRh\nlacks features, focuses on its unique camera.", "tags": ["3d", "raymarch", "inverse", "perspective", "orthographic", "fov"], "likes": 5, "viewed": 595, "published": "Public API", "date": "1476360376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inverse Perspective by HLorenzi\n// (Distance Functions by www.iquilezles.org)\n// modified by ollj (no globals; no shadow; no materials; no slider)\n\n#define kMaxIterations 160\n\n//uncomment dynamicEps to have epsilon increase with every raymarch step. \n//-> spatial distortion that enables longer raymarch distances. (distant objects get lager surface epsilon till they fill the view)\n//-> spatial distortion in the distance tends to look better than distance fog.\n//-> tends to hit a surface in linear time even within >10x larger [kMaxIterations]\n//#define dynamicEps\n//this works independent from inverse perspective, but the visual effect is similar.\n\nvoid opU(inout float a,float b){a=min(a,b);}\nfloat dfBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s+vec3(r),0.0))-r;}\n\n//MaterialColor() is a placeholder reminder that\n//EVERY space in 3d is assigned a material\n//and this function does it.\n//by calling a simpler COPY of df();\n//because in the end df() can hit a \"surface\" anywhere.\n//because MaterialColor() is likely called in df();\n//vec3 MaterialColor(vec3 p){return vec3(.5);}\n\nfloat df(vec3 p){float r=p.z;\n opU(r,dfBox(p-vec3( 3, 1,1.05),vec3(1),.5));\n opU(r,dfBox(p-vec3(-3, 1,1.05),vec3(1),.2));\n opU(r,dfBox(p-vec3( 0,-3,1.05),vec3(1),.7));return r;}\n\nvec3 normal(vec3 p){const vec2 e=vec2(.01,0);return normalize(vec3(\n df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx)));}\n\n//return distance of nearest surface along ray with [o]origin and [d]direction.\nfloat raymarch(vec3 o,vec3 i){float e,d;for(int j=0;j<kMaxIterations;j++){float p=df(o+i*d);if(p<e)return d;d+=p;\n#ifdef dynamicEps                                 \n e=e+.00000001+e*1.00000001;\n#endif\n }return d;}\n\n/*\nfloat shadow(vec3 o,vec3 i){const float minDist=1.;float r=1.,t=.25;\n for(int j=0;j<10;j++){r=min(r,4.*df(o+i*t)/t),t+=.25;}return r;}\n*/\n\n//return raydirection and rayorigin from camera input.\n//[s]screenspace, [e]Eyepos, [t]target, [u]up, out Ray [o]origin, out Ray [d]direction , [f]fow\nvoid camera(vec2 s,vec3 e,vec3 t,vec3 u,out vec3 o,out vec3 d,float f){\t\n vec3 z=normalize(t-e),x=normalize(cross(z,u)),y=normalize(cross(x,z))*s.y;x*=s.x;//vec3 x,y,z==vec3 u,v,w\n float w=acos(dot(z,normalize(x))),//fow.xy\n a=(10./(2.*tan(abs(w)*.5)));o=e+(x+y)*(.7+.2*f)*a;d=normalize((e+z*2.+(x+y)*a)-o);}\n\n//q=fragment screenspace, f= fow, h=cameraHeight\nvec3 pixel(vec2 q,float f,float h){float dist=4.;\n vec3 t=vec3(0,0,1),u=vec3(0,0,1),//target,up\n e=t+vec3(cos(iTime/2.0)*dist,sin(iTime/2.)*dist,0.25+h*2.),//EyePos\n o,d;//origin,direction\n camera(q,e,t,u,o,d,f);//set o and d\n vec3 p=o+d*raymarch(o,d);//P=intersection of ray with surface by raymarching.\n vec3 light0=normalize(vec3(1,2,3)*9.-p);\n vec3 n=normal(p);\n vec3 c=n*.5+.5;\n //c=mix(c-vec3(.1),c,shadow(p,vec3(1,2,3)));\n //c*=max(dot(n,normalize(vec3(1,2,3))),0.)*.5+.5;//diffuse light\n if(dot(n,light0)>0.){float s=min(1.,pow(max(0.,dot(reflect(-light0,n),normalize(o-p))), 50.0));\n  return mix(c,vec3(1),s*.75);}\n return c;}\n\n#define clampe(a) clamp(-.2+1.4*(iMouse.a/e.a*2.),0.,2.)\nvoid mainImage(out vec4 r,in vec2 i){\n vec2 e=iResolution.xy,p=i/e;p=p*2.-vec2(1);p.x*=e.x/e.y;\n    float fow =clampe(x);\n    float height=2.-clampe(y);\n r=vec4(pixel(p,fow,height),1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtG3DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 657, 689, 689, 701], [702, 702, 737, 737, 781], [783, 1097, 1114, 1114, 1274], [1276, 1276, 1296, 1296, 1420], [1422, 1502, 1532, 1532, 1715], [1859, 2010, 2081, 2081, 2318], [2320, 2369, 2404, 2404, 3004], [3063, 3063, 3100, 3100, 3248]], "test": "valid"}
{"id": "XtG3RK", "name": "Amiga fx 1", "author": "gigatron", "description": "Amiga Skidrow square flag ... ok it's now running much better than before %95 ; considering finished !!!\nun vrai bordel ce GLSL !!! pire que l'assembleur 68K!", "tags": ["amiga", "square", "flag", "fx"], "likes": 2, "viewed": 299, "published": "Public", "date": "1475391600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Skidrow Amiga Square Flag demo ! \n   Gigatron France ... something is wrong but what ???\n   It's not 100% similar  !!! now it'seem correct !!!\n   rect funct  from ST\n*/\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\nvec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn vec4(color, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float gt=iTime;\n    \n    vec2 center = vec2(-0.2,.90);\n\tvec4 bx = rectangle(uv, center, 0.,0., vec3(0));// box ; \n   \n    float fct=0.0,xx=0.2,yy=0.0; // fct , xpox,ypos\n       \n    for(int i=0;i<322;i++){// iter\n        xx +=0.04;\n        fct= sin(18.*gt+(uv.y-uv.x)*5.0)*0.015;;\n      \n        bx += rectangle(uv, center-vec2(-xx,yy), 0.02+fct, 0.04+fct,\n                        rgb(uv.x-xx-1.,uv.y+xx-0.9,xx*0.8)*2.0);      \n             \n        if(xx> 1.1){xx=0.2; yy +=0.06;} // inc yy\n     }\n         \n\tvec4 bg= vec4(rgb(0., 0.0, 0.0), 0.0);\n\tfragColor = vec4(mix(bg, bx,bx.a));\n  }", "image_inputs": [{"id": "XsSGzw", "previewfilepath": "https://soundcloud.com/other-days/otherdays-unreal-ingame-cover", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/other-days/otherdays-unreal-ingame-cover", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtG3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 172, 209, 209, 258], [259, 259, 333, 333, 526], [528, 528, 585, 585, 1221]], "test": "valid"}
{"id": "XtG3zc", "name": "Progressive Circle", "author": "kailashvetal47", "description": "This will draw circle in continuous manner.\n", "tags": ["2d", "circle", "geometry"], "likes": 2, "viewed": 225, "published": "Public", "date": "1475933496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926536;\nconst float TWO_PI = 6.28318530718;\nconst float radius = 0.25;\nconst vec2 center = vec2(0.5,0.5);\nconst float width = 0.05;\nconst float sharpness = 1.8;\nconst vec4 color1 = vec4(0.0,0.0,0.0,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Progressive angle with respect to time.\n    float theta = mod(iTime,TWO_PI);\n    \n    float minDim = min(iResolution.x,iResolution.y);   \n    float w =  width * minDim;\n    float r = radius * minDim; \n    \n    // find distance and angle of fragment with center\n    vec2 c = center * iResolution.xy; \n    vec2 p = (fragCoord.xy-c);\n    float a = atan(p.x,p.y)+PI;\n    float d = abs(r - length(p));\n    \n    \n    // Set Bg color\n    fragColor = vec4(fragCoord.xy/iResolution.xy,0.5+ 0.5*sin(iTime),1.0);\n    float cond = 1.0 - max(sign( w - d) * sign( theta - a),0.0);\n    float i = clamp(pow(d,sharpness)/w + cond,0.0,1.0 );\n    fragColor = mix(color1,fragColor,i);\n   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtG3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 285, 332, 963]], "test": "valid"}
{"id": "XtGGR3", "name": "Animation house v0.01", "author": "Imsure1200q_1UWE130", "description": "<none> <still in progress>", "tags": ["raytracing", "raymarching", "raycasting", "animation", "house"], "likes": 3, "viewed": 551, "published": "Public API", "date": "1475837220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-r;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat blend (float a, float b, float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\nvec2 blend( vec2 a, vec2 b,float k)\n{\n    vec2 l = vec2(k);\n    return vec2(blend(a.x,b.x,l.x),blend(a.y,b.y,l.y));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\nfloat scDir(float p, float s)\n{\n    vec3 x = vec3(p);\n    return length(cross(sin(x), cos(x))-cross(asin(x),acos(x)))-s;\n}\nfloat snDir(float p, float s)\n{\n    vec3 x = normalize(vec3(p));\n    vec2 y = vec2(p);\n    return scDir(length(x)-s, s);\n}\nvec2 map( vec3 pos)\n{\n    float roundness = .15;\n  \tfloat rot = 1.;\n\tfloat k = .05;\n    float size = .5;\n    \n    float scale = 1. / ( 3. - clamp( pos.y, 1., 7. ) );\n    scale = 1.;\n    \n    vec2 x;\n    float h = 3.5;\n    vec3 p = vec3(pos.x, pos.y, pos.z);\n    float d1;\n    float pl = sdPlane(p);\n    x = vec2(sdPlane(p),1.0);\n    for(float i = 1.; i < 10.; i++)\n    {\n        p = vec3(pos.x+sin(i/5.), pos.y-i/10., pos.z+3.+cos(i/5.)); // Position: Add For Negative, Subtract For Positive.\n        p.xz *= rotate2d(i/5.);\n        d1 = sdBox(p, vec3(0.75, 0.2, 0.9));\n        x = opU(vec2(d1, 5.0), x);\n    }\n    p = vec3(pos.x, pos.y-.6, pos.z+3.); // Position: Add For Negative, Subtract For Positive.\n    d1 = sdCapsule(p, vec3(.5, -1., 0.0), vec3(.5, 1., 0.), 0.5);\n    x = blend(vec2(d1, 1.5), x, 0.1);\n    p = vec3(pos.x-1., pos.y, pos.z+1.);\n    d1 = sdBox(p, vec3(0.3, clamp(p.y, 0.0, 3.0), .3));\n    x = opU(vec2(d1, 1.7), x);\n    p = vec3(pos.x-1., pos.y, pos.z-5.);\n    d1 = sdBox(p, vec3(0.3, clamp(p.y, 0.0, 3.0), .3));\n    x = opU(vec2(d1, 1.7), x);\n    p = vec3(pos.x+3., pos.y, pos.z+1.);\n    d1 = sdBox(p, vec3(0.3, clamp(p.y, 0.0, 3.0), .3));\n    x = opU(vec2(d1, 1.7), x);\n    p = vec3(pos.x+3., pos.y, pos.z-5.);\n    d1 = sdBox(p, vec3(0.3, clamp(p.y, 0.0, 3.0), .3));\n    x = opU(vec2(d1, 1.7), x);\n    p = vec3(pos.x, pos.y, pos.z+1.);\n    d1 = sdBox(p, vec3(clamp(p.x, 2., 3.)+3., clamp(p.y, 0.79, 0.799), clamp(p.z, 1.9, 6.9)));\n    x = opU(vec2(d1, 1.5), x);\n    p = vec3(pos.x, pos.y-4.3, pos.z+1.);\n    d1 = sdBox(p, vec3(clamp(p.x, 2., 3.6)+3., clamp(p.y, 1.21, 1.219), clamp(p.z, 1.9, 6.9)));\n    x = opU(vec2(d1, 1.6), x);\n    p = vec3(pos.x, pos.y-3.3, pos.z);\n    d1 = sdBox(p, vec3(clamp(p.x,0., 0.6), clamp(p.y, 0.71, 0.719), clamp(p.z, 0.45, 0.7)));\n    x = opU(vec2(d1, 1.1), x);\n    return x;\n    \n}\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123);\n}\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 i = f*f*(3.0-2.0*f);\n    return mix(mix(hash(i+vec2(0.0, 0.0)),\n                   hash(i+vec2(0.0, 1.0)), x.x),\n               mix(hash(i+vec2(1.0, 0.0)),\n                   hash(i+vec2(1.0, 1.0)), x.x),x.y);\n                   \n                   \n    \n}\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) + sin(rd.y);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(1.0)*(m-1.0) );\n\t\t\n        if( m==1.5 )\n        {\n            \n            float f = 1.;\n            col = 0.4 + 0.1*f*vec3(1.);\n        }\n        else if( m==1.6 )\n        {\n            \n            float f = 1.;\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n        else if( m==1.7 )\n        {\n            \n            float f = 1.;\n            col = texture(iChannel0, vec2(pos.x, pos.z)).xyz*vec3(0.3);\n        }\n        else if( m==1.0 )\n        {\n            \n            float f = 1.;\n            col = texture(iChannel1, vec2(pos.x, pos.z)).xyz*vec3(0.5, 1.0, 0.5);\n        }\n        if( m==1.1 )\n        {\n            col= 0.4+0.1*vec3(1.)+texture(iChannel2, vec2(pos.x,pos.z)).rgb+\n                (vec3(0.9, 0.5, 0.1)-clamp(sin(iTime/24.), -0.8, 1.9));\n        }\n\n        // lighitng\n        vec3  lig = normalize( vec3(-0.6+cos(iTime/24.), 0.7+sin(iTime/24.), -0.5) );\n        float occ = calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5);\n        dom *= softshadow( pos, ref, 0.2, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 5.*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y,5.*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 2., 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.01);\n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    if(normalize(rd)==vec3(.9))\n    {\n        rd=vec3(0.);\n    }\n    // render\t\n    vec3 col = render( ro, rd );\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 )+clamp(sin(iTime/24.), -0.8, 0.1);\n    if(fragColor.b > 0.9)\n    {\n        fragColor.rgb+ vec3(0.9, 0.5, 0.01);\n    }\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 40], [41, 41, 86, 86, 175], [176, 176, 212, 212, 296], [297, 297, 332, 332, 358], [359, 359, 387, 387, 473], [474, 474, 507, 507, 572], [573, 573, 614, 614, 701], [702, 702, 739, 739, 819], [820, 820, 872, 872, 999], [1000, 1000, 1031, 1031, 1118], [1120, 1120, 1150, 1150, 1183], [1184, 1184, 1214, 1214, 1243], [1244, 1244, 1275, 1275, 1366], [1367, 1367, 1398, 1398, 1489], [1490, 1490, 1511, 1511, 3328], [3329, 3329, 3369, 3369, 3959], [3960, 3960, 4034, 4034, 4295], [4297, 4297, 4329, 4329, 4549], [4550, 4550, 4592, 4592, 4891], [4892, 4892, 4912, 4912, 4978], [4979, 4979, 5000, 5000, 5312], [5313, 5313, 5352, 5352, 7536], [7538, 7538, 7590, 7590, 7767], [7769, 7769, 7826, 7826, 8575]], "test": "error"}
{"id": "XtGGW3", "name": "Modified Bear", "author": "s23b", "description": "Stanley Donwood's bear\nmusic: [url=https://www.youtube.com/watch?v=cedNya7e8Uc]Radiohead's cover of Ceremony by Joy Division[/url]", "tags": ["2d", "sdf", "drawing", "bear", "radiohead", "joydivision"], "likes": 8, "viewed": 562, "published": "Public API", "date": "1477061542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GLOW 1\n#define NEGATIVE 0\n#define GAMMA_CORRECT 1\n#define MASK_ONLY 0\n#define ADD_NOISE 1\n\n#define saturate(x) clamp(x, 0., 1.)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI 3.14159265359\n\nfloat spikes(float x, float t) {\n    x = abs(fract(x) - .5) * 1. - .5 + t;\n    return x < 0. ? 0. : smoothstep(0., t, x);\n}\n\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat rect(vec2 p, vec2 s) {\n    vec2 a = abs(p) - s;\n    return a.x < 0. || a.y < 0. ? max(a.x, a.y) : length(a);\n}\n\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\nfloat bear(vec2 p) {\n    float d = circle(p, 1.);\n    \n    // draw ears\n    float earSize = .6;\n    vec2 earPos = vec2(.7);\n    float ear = circle(p - earPos, earSize);\n    float inEar = circle(p - earPos, earSize- .1);\n    inEar = opS(inEar, circle(p - earPos, earSize- .2));\n    ear = opS(ear, inEar);\n    ear = opS(ear, circle(p - earPos, earSize- .3));\n    d = opU(d, ear);\n    \n    // substract face\n    d = opS(d, circle(p, .9));\n    \n    // substract inside of ears on the top\n    d = opS(d, opS(inEar, p.y - earPos.y));\n    \n    // draw eyes\n    float eyeSize = .49;\n    vec2 eyePos = vec2(.45, .2);\n    d = opU(d, circle(p - eyePos, eyeSize));\n    d = opS(d, circle(p - eyePos, eyeSize - .1));\n    \n    // draw pupil\n    float pupilAngle = PI / 2. * (.9 - spikes(iTime / 6.4, .02) * .8);\n    d = opU(d, rect(p - eyePos, vec2(cos(pupilAngle), sin(pupilAngle)) * (eyeSize)));\n    \n    // draw mouth\n    float mouthPos = eyePos.y - eyeSize + .04;\n    vec2 mouthSize = vec2(1.2, .05);\n    d = opU(d, rect(p - mouthPos, mouthSize));\n    \n    // draw teeth\n    d = opU(d, rect(p * rot(.3) - vec2(.28, -.54), vec2(.05, .4))); \n    d = opU(d, rect(p * rot(-.3) - vec2(.13, -.62), vec2(.05, .35))); \n    d = opU(d, rect(p * rot(.3) - vec2(.63, -.38), vec2(.05, .35))); \n    d = opU(d, rect(p * rot(-.5) - vec2(.39, -.68), vec2(.05, .21))); \n    \n    return d;\n}\n\n// interpolates between two closest fft samples with given resolution\nfloat fft(float t, float resolution) {\n    return mix(\n        texture(iChannel0, vec2(floor(t * resolution) / resolution, .25)).x,\n        texture(iChannel0, vec2(floor(t * resolution + 1.) / resolution, .25)).x,\n        fract(t * resolution));\n}\n\nfloat hash(vec2 uv) {\n    float f = fract(cos(sin(dot(uv, vec2(.009123898, .00231233))) * 480.512353) * 11111.5452313);\n    return f;\n}\n\nfloat noise(vec2 uv) {\n    vec2 fuv = floor(uv);\n    vec4 cell = vec4(\n        hash(fuv + vec2(0, 0)),\n        hash(fuv + vec2(0, 1)),\n        hash(fuv + vec2(1, 0)),\n        hash(fuv + vec2(1, 1))\n    );\n    vec2 axis = mix(cell.xz, cell.yw, fract(uv.y));\n    return mix(axis.x, axis.y, fract(uv.x));\n}\n\n// noise that flows arpind the center\nfloat fbm(vec2 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 8; ++i) {\n        uv *= rot(iTime / 10.);\n        f += noise((uv + float(i) / 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 p = vec2(abs(uv.x), uv.y + .13) * 1.3;\n    \n\tfloat d = bear(p);\n    \n    // add distortion\n    #if ADD_NOISE\n    d += (.5 - fbm(uv * 10.)) * .05;\n    d -= (fft(atan(p.x,p.y) / PI, 10.) - .2) * .05 * smoothstep(0., 1., length(p));\n    #endif\n    \n    // create outline\n    float w = fwidth(d);\n    float mask = smoothstep(-w, w, d); \n    \n    // add glow\n    #if GLOW\n    float glow = pow(100., -d) * (.05 + smoothstep(.0, .5, texture(iChannel0, vec2(.6, .25)).x) * .25);\n\tmask = saturate(mask - glow);\n    #endif\n    \n    #if MASK_ONLY\n    fragColor = vec4(mask);\n    \n    #else\n    // create background flow\n    uv *= 2.;\n    vec4 flow = vec4(fbm(uv), fbm(uv * rot(1.)), fbm(uv * rot(2.)), 1);\n    flow = floor(flow * 16.) / 16.;\n    \n    \n    // apply mask\n    fragColor = mix(flow, vec4(1), mask);\n\n    #if NEGATIVE\n    fragColor = 1. - fragColor;\n    #endif\n\n    #if GAMMA_CORRECT\n    fragColor = pow(fragColor, vec4(.4545));\n    #endif\n    #endif\n}", "image_inputs": [{"id": "4sSGDR", "previewfilepath": "https://soundcloud.com/kasafero/radiohead-ceremony-joy-division-cover", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/kasafero/radiohead-ceremony-joy-division-cover", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 247, 247, 338], [340, 340, 371, 371, 399], [401, 401, 429, 429, 517], [519, 519, 548, 548, 572], [574, 574, 603, 603, 628], [630, 630, 650, 650, 1991], [1993, 2063, 2101, 2101, 2310], [2312, 2312, 2333, 2333, 2447], [2449, 2449, 2471, 2471, 2752], [2754, 2792, 2812, 2812, 3011], [3013, 3013, 3070, 3070, 4133]], "test": "error"}
{"id": "XtGGzt", "name": "Voronoi Spike Spiral", "author": "VoidChicken", "description": "A 2D spike flower spiral thingy that animates and zooms.", "tags": ["2d", "voronoi", "zoom", "spiral", "flower", "hsv", "chicken", "spike"], "likes": 8, "viewed": 243, "published": "Public", "date": "1476051699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Optimized by Fabrice Neyret.\n\n#define h2rgb(c)  abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.) - 1.\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n\tvec2 R = iResolution.xy;\n         U = (U - .5*R) / R.y;\n    float j,y, dmin=1e9,d, time=iTime;\n    \n    for (int i = 0; i < 100; i++) {\n        float y = float(i);\n        vec2 point = vec2(sin(y+y/100.*time), \n                          cos(y+y/100.*time))*  y/100./2.;\n        d = distance(point,U);\n        if (d<dmin) dmin = d, j = y;\n    }\n    \n    O = h2rgb(j/100.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 139, 139, 514]], "test": "valid"}
{"id": "XtK3Dc", "name": "Primitives - Stripes", "author": "stuaxo", "description": "Draw a simple stripe.", "tags": ["asimplestripe"], "likes": 1, "viewed": 74, "published": "Public", "date": "1477318937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float stripe_t( float t, float origin, float width, float smoothness ) {\n    // t for a simple stripe\n    // origin\n    // width\n    float hw = width / 2.0;\n    float blend = smoothstep(origin - hw, \n                             origin+smoothness - hw, \n                             t) * \n        smoothstep(origin+hw, origin+hw-smoothness, t);\n    return blend;\n}\n\n#define NUM_STRIPES 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bgcolor = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 color = vec4(0.9, 0.9, 0.0, 1.0);\n    float smoothness = 0.01;\n \n    // simplest example\n    // fragColor = vec4(mix(bgcolor, color, stripe_t(uv.x, 0.5, 0.1, smoothness)));   \n\n    // Make some wiggly stripes\n    vec4 col = vec4(bgcolor);\n    for(int i = 1; i < NUM_STRIPES+1; i++) {        \n\t\tcol = vec4(mix(col, color, stripe_t(uv.x, .5 + (sin(cos(iTime * float(i)) * (float(i)+uv.y -.5) * .4) * .25), 0.1, smoothness)));\n    }\n    fragColor = col;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtK3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 128, 364], [389, 389, 446, 446, 995]], "test": "valid"}
{"id": "XtK3Rt", "name": "Silly Spiral", "author": "AxleMike", "description": "Nothing special just thought it looked pretty cool.", "tags": ["2d", "spiral"], "likes": 12, "viewed": 622, "published": "Public API", "date": "1476228850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Alexander Lemke, 2016\n// Update 10/12/16: Hash function update to fix artifacts on mobile. \n\n\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n// noise functions based on iq's https://www.shadertoy.com/view/MslGD8\nfloat Hash(in vec2 p)\n{\n    return -1.0 + 2.0 * fract(sin(dot(p, vec2(12.0, 78.0))) * 43758.0);\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\nfloat Spiral(in vec2 texCoord, in float rotation)\n{   \n    float spiral = sin(50.0 * (pow(length(texCoord), 0.25) - 0.02 * atan(texCoord.x, texCoord.y) - rotation));\n    return clamp(spiral, 0.0, 1.0);\n}\n\nvec3 ColoredSpiral(in vec2 texCoord, in float rotation, in vec3 c0, in vec3 c1)\n{\n    return mix(c0, c1, Spiral(texCoord, rotation));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec4 finalColor = vec4(1.0);\n\n    vec2 portalCenter = vec2(sin(iTime * 2.0), cos(iTime * 2.0)) * 0.025;\n    vec2 portalTexCoord = portalCenter + vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n    \n    vec2 pushDirection = normalize(portalTexCoord + vec2(EPSILON));\n    float noise = Noise(pushDirection + iTime) * 0.15 * length(portalTexCoord);\n\n    portalTexCoord = portalTexCoord + (-noise * pushDirection);\n    float r = length(portalTexCoord);\n\n    vec3 portalColor = ColoredSpiral(portalTexCoord, 0.1 * iTime, vec3(0.0, 0.6, 0.0), vec3(0.35, 1.0, 0.0)); \n    finalColor.rgb = mix(finalColor.rgb, mix(portalColor, vec3(0.6, 1.0, 0.35), 0.01 + (r * r)), step(r, 1.0));     \n\n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtK3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 259, 282, 282, 356], [358, 358, 382, 382, 607], [609, 609, 660, 660, 812], [814, 814, 895, 895, 949], [951, 951, 1006, 1006, 1825]], "test": "valid"}
{"id": "XtK3W3", "name": "Video Glitch", "author": "dyvoid", "description": "Simulated video glitches. Random simplex noise displacement, RGB shifting and horizontal line patterns.", "tags": ["noise", "video", "displacement", "distortion", "tv", "glitch", "rgbshift"], "likes": 97, "viewed": 6066, "published": "Public API", "date": "1477145781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat rand(vec2 co)\n{\n   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    float time = iTime * 2.0;\n    \n    // Create large, incidental noise waves\n    float noise = max(0.0, snoise(vec2(time, uv.y * 0.3)) - 0.3) * (1.0 / 0.7);\n    \n    // Offset by smaller, constant noise waves\n    noise = noise + (snoise(vec2(time*10.0, uv.y * 2.4)) - 0.5) * 0.15;\n    \n    // Apply the noise as x displacement for every line\n    float xpos = uv.x - noise * noise * 0.25;\n\tfragColor = texture(iChannel0, vec2(xpos, uv.y));\n    \n    // Mix in some random interference for lines\n    fragColor.rgb = mix(fragColor.rgb, vec3(rand(vec2(uv.y * time))), noise * 0.3).rgb;\n    \n    // Apply a line pattern every 4 pixels\n    if (floor(mod(fragCoord.y * 0.25, 2.0)) == 0.0)\n    {\n        fragColor.rgb *= 1.0 - (0.15 * noise);\n    }\n    \n    // Shift green/blue channels (using the red channel)\n    fragColor.g = mix(fragColor.r, texture(iChannel0, vec2(xpos + noise * 0.05, uv.y)).g, 0.25);\n    fragColor.b = mix(fragColor.r, texture(iChannel0, vec2(xpos - noise * 0.05, uv.y)).b, 0.25);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtK3W3.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 425, 446, 446, 495], [497, 497, 518, 518, 567], [569, 569, 591, 591, 628], [630, 630, 654, 654, 2160], [2162, 2162, 2183, 2183, 2253], [2256, 2256, 2313, 2313, 3359]], "test": "error"}
{"id": "XtVGD3", "name": "\"Sign\" Wave", "author": "VoidChicken", "description": "A bad pun with a \"good\" shader.", "tags": ["2d", "checkerboard", "sine", "sign"], "likes": 2, "viewed": 123, "published": "Public", "date": "1477170056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n\tU = sin(U/iResolution.y * iTime*10.);\n\tO += sign(U.x+U.y) - O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 104]], "test": "valid"}
{"id": "XtVGDc", "name": "Twister - 8th Annual Laundry", "author": "patu", "description": "This is twister used in \"8th Annual Laundry Party by HUGE LOAD\"\nhttp://www.pouet.net/prod.php?which=67975", "tags": ["raymarching", "twister"], "likes": 23, "viewed": 876, "published": "Public API", "date": "1477228076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://bit.ly/shadertoy-plugin\n\n#define FAR 30.\n#define INFINITY 1e32\n#define t iTime\n#define FOV 60.0\n#define FOG .4\n#define PI 3.14159265\n\nfloat \n    glow = 0.;\n\nint iterations = 0;\n    \nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec3 dF(vec3 p) {\n    p = p.yzx;\n\n    \n    vec3 \n        obj = vec3(FAR, -1.0, 0.0),\n        obj2 = obj;\n        \n    p.z += sin(t / 2.) * 3.;\n    p.z *= sin(t) * 1.;\n    \n    pR(p.xy, -t * 2. + p.z);\n    \n    p.x += sin(p.z) / 2.;\n    \n    vec3 orgP = p;\n    \n    pModPolar(p.xy, 4.);\n\n    p.x -= .9;\n        \n    obj = vec3(\n        fBox(p, vec3(0.4, 0.7, 13.4)),\n        2.0,\n        0.0\n    );\n    \n    p = orgP;\n    \n    obj2 = vec3(\n        fBox(p, vec3(1.1, 1.1, 20.)),\n        1.0,\n        0.0\n    );\n\n    return opU2(obj, obj2);\n}\n\nfloat t_min = 0.001;\nfloat t_max = 50.;\nconst int MAX_ITERATIONS = 40;\n\nvec3 trace(vec3 ro,vec3 rd) \n{\n    vec3 mp = dF(ro);\n    glow = 0.;\n    float minDist = INFINITY;\n    float function_sign = (mp.x < 0.) ? -1. : 1.;\n\n    float h = .001;\n    float t = 0.;\n    \n\tfor(int i = 0; i < 60; i++) \n\t{\n        if (abs(h) < .001 || t > FAR) break;\n\t\tmp = dF(ro + rd * t);\n\t\tminDist = min(minDist, mp.x * 9.);\n        glow = pow(1. / minDist, 1.) / 4.;\n        h = function_sign * mp.x;\n        t += h;\n\t}\n    mp.x = t;\n    return mp;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 18;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 2.0;\n    float dist = .05;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = dF(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.1), 1.0);\n}\n\n#define E .1\nvec3 getNormalHex(vec3 pos) {\n\tfloat d=dF(pos).x;\n\treturn normalize(\n        vec3(\n            dF(\n                pos+vec3(E,0,0)).x-d,\n                dF(pos+vec3(0,E,0)).x-d,\n                dF(pos+vec3(0,0,E)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal) {\n    float dist = 0.4;\n    vec3 spos = hitp + normal * dist;\n    float sdist = dF(spos).x;\n    return clamp(sdist / dist, 0.4, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec2 mat) {\n    vec3 col = vec3(1);\n    \n    if (mat.x == 2.0) {\n        col = vec3(8., 3., 0.);\n        col.r *= sin(t);\n        col.g *= cos(t * .2);\n    }\n    \n    return col ;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec2 mat) {\n\tvec3 \n        ld = lp - sp,\n        objCol = getObjectColor(sp, sn, mat);\n\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    float \n        atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*0.05),\n    \tdiff = max(dot(sn, ld), 0.),\n\t\tspec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 7.0);\n    \n    // fresnel\n    vec3 H = normalize(normalize(ld) + rd);\n    \n    float \n        F = 14.0,\n    \tb = 1. - dot(rd, H),\n\t\texponential = pow( b, 5.0),\n\t\tfresnel = exponential + F * (1. - exponential);\t\n    \n    return (objCol * (diff + 0.15) + vec3(1.) * spec * fresnel) * atten;\n\n}\n\nvec4 pixelColor(vec2 fragCoord) {\n    fragCoord *= tan(radians (FOV) / 2.0);\n    \n    vec3 \n        light = vec3(0., 0., 5.),    \n    \tsceneColor = vec3(1.),\n    \n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(0., 0. , 8.2), // cam pos\n    \tvrp =  vec3(0., 0., 0.), // lAt\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + fragCoord.x * u * iResolution.x/iResolution.y + fragCoord.y * v),\n    \t\n        rd = normalize(scrCoord - ro),\n    \ttr = trace(ro, rd),\n        sn;\n    \n    ro += rd * tr.x;\n    sn = getNormalHex(ro);\t\n    \n    float \n        fog = smoothstep(FAR * FOG, 0., tr.x),\n\t\tsh = softShadow(ro, light, .9),\n\t\tao = getAO(ro, sn);\n    \n    sceneColor += doColor(ro, rd, sn, light, tr.yz);\n    \n    if (tr.x < FAR) {\n        sceneColor *= fog;\n        sceneColor *= ao;\n        sceneColor *= sh;\n        sceneColor += pow(max(0., sn.y) , 5.);\n    } else {\n     \tsceneColor *= 0.;\n        sceneColor += pow(glow, 1.4) * .8;\n    }\n\n    return vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pixelColor(fragCoord / iResolution.xy - .5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 192, 224, 224, 266], [268, 268, 299, 299, 348], [350, 350, 370, 370, 405], [407, 520, 570, 570, 960], [962, 998, 1026, 1026, 1107], [1109, 1109, 1126, 1126, 1648], [1722, 1722, 1752, 1752, 2179], [2181, 2181, 2226, 2226, 2800], [2815, 2815, 2844, 2844, 3054], [3056, 3056, 3099, 3099, 3233], [3235, 3235, 3282, 3282, 3452], [3454, 3454, 3527, 3527, 4183], [4185, 4185, 4218, 4218, 5274], [5276, 5276, 5331, 5331, 5394]], "test": "valid"}
{"id": "XtVGWy", "name": "Planetside 2 Inspired Forcefield", "author": "VoidChicken", "description": "A 2D planetside 2 inspired version of the warpgate force field.", "tags": ["2d", "ps2", "forcefield", "planetside"], "likes": 1, "viewed": 173, "published": "Public", "date": "1476474507", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 fromIRGB(vec3 c) {\n    return c/255.;\n}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat h(vec2 uv) {\n    return noise(vec3(uv.xy*5.+iTime, iTime*2.))+texture(iChannel1, uv/5.).r+texture(iChannel0, uv).r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = vec4(0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float y = .5*sin(clamp(fract(iTime/(3.14*1.5-1.))/(3.14*1.5-1.), 3.14/2.+.1, 3.14*1.5-.1))+.5;\n    if (abs(y-h(uv))<.2) {\n    \t  c= vec4(fromIRGB(vec3(47, 112, 216)), 1)*smoothstep(-1.,1.,abs(y-h(uv))*10.)*2.;  \n    }\n\tfragColor = c;\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 44], [45, 45, 68, 68, 104], [105, 105, 131, 131, 500], [501, 501, 519, 519, 624], [625, 625, 682, 682, 986]], "test": "error"}
{"id": "XtVGzc", "name": "In which direction does it turn?", "author": "ttoinou", "description": "Simple lissajou curve", "tags": ["lines", "illusion"], "likes": 4, "viewed": 145, "published": "Public", "date": "1476808601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define dx (iMouse.x/iResolution.x)\n#define dy (iMouse.y/iResolution.y)\n#define TWOPI (6.28318530718)\n\nvec3 segment(  vec2  p,\n               vec2  a,\n               vec2  b,\n               float d ){\n    float len = length(b-a);\n    \n    // avoids vertex overlap\n    // doesn't work :-( \n    /*\n    float dd = d/(sqrt(2.0)*0.2);\n    //float D = d;\n    //float D = dd*exp(0.5-dd*dd);\n    float dhalf = 0.1;\n    float D = d < dhalf ? d*1.3 : smoothstep(0.,dhalf,2.*dhalf - d);\n    //float D = d < 0.1 ? d : 0.0;\n    //float D = d/dhalf*exp(- (1.0-d/dhalf)*(1.0-d/dhalf));\n    if( D < len ){\n    \tb = a+( ((b-a)/len)*max(len-D,0.) );\n    \tlen = length(b-a);\n    }\n    */\n    \n    float sx = (b.x - a.x);\n    float sy = (b.y - a.y);\n    vec2 r;\n    \n    if( sx == 0. && sy == 0. ){\n        r = vec2(length(p-a));\n        return vec3(1. - clamp(r.y/d,0.,1.),0.,0.0);\n    } else {\n    \tr = (mat2(sx,-sy,sy,sx))*(p-a)/len;\n    }\n    \n    r.y = (1.0 - smoothstep(0.0,1.0,abs(r.y)/(d)) )\n        * (smoothstep(0.,1., (r.x+d)/(d)) )\n        * (1.0 - smoothstep(0.,1., (r.x-len)/(d)) );\n    \n    r.x = clamp(r.x,0.0,len);\n    \n    return vec3( r.y\n                , r.x , r.x / len );\n}\n\nvec4 colorSegment(vec2  p,\n              \t  vec2  a,\n                  vec2  b,\n                  float d,\n                  vec4  color1,\n                  vec4  color2){\n    vec3 s = segment(p,a,b,d);\n    return pow(s.x,0.5)*mix(color1*color1.a,color2*color2.a,s.z);\n}\n\nconst float width = 1.1;\n\nvec2 viewport(vec2 p){\n    return vec2( (2.*p.x - iResolution.x)/ iResolution.y,\n                  2.*p.y                 / iResolution.y - 1.)*width;\n}\n\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    //float lineThickness = 16./max(iResolution.x,iResolution.y);\n    float lineThickness = 8./max(iResolution.x,iResolution.y) + dx*0.3*(1. + cos(iTime/3.14/0.40));\n    const int pts = 100;\n    \n\tvec2 uv = viewport(fragCoord);\n\n\to = vec4(0.0,0.0,0.0,0.0);\n    \n    vec2 p1 = vec2(0.5,0.5);\n    vec2 p3 = vec2(-0.5,0.5);\n    vec2 p2 = viewport(vec2(0.5,0.1)*iResolution.xy);\n\n    vec4 c1;\n    vec4 c2;\n    float di;\n    \n    for( int i = 0 ; i < pts ; i++ ){\n        di = float(i)/float(pts-1);\n        \n        // curve\n        p2 = (vec2(\n            sin(di*8.0*TWOPI+iTime)+sin(di*3.0*TWOPI),\n            cos(di*3.0*TWOPI+sqrt(3.0)*iTime)\n        ));\n        // color scheme\n        c2 = vec4(\n            0.5+0.5*cos(di*4.0*TWOPI),\n            0.5+0.5*cos(di*9.0*TWOPI),\n            0.5+0.5*cos(di*2.0*TWOPI),\n            0.5+0.5*cos(di*13.0*TWOPI+iTime*4.0)\n        );\n        \n        if( i > 0 ){\n            o += colorSegment(uv,p1,p2,lineThickness,c1,c2);\n        }\n        \n        c1 = c2;\n        p1 = p2;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 200, 200, 1176], [1178, 1178, 1349, 1349, 1448], [1476, 1476, 1498, 1498, 1628], [1631, 1631, 1680, 1746, 2706]], "test": "valid"}
{"id": "Xty3zc", "name": "stars - PSF + saturation", "author": "FabriceNeyret2", "description": "How to draw stars as in astronomic photos ?\nStars are only a fraction of pixel, but hugely brighter than the max pixel value, plus the lens PSF causes bloom. So the disk you see (L) is just a clamped bloom r~=1/d^2/3, not a projected sphere r~=1/d (R). ", "tags": ["star", "psf", "sensor"], "likes": 5, "viewed": 1277, "published": "Public API", "date": "1475770924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \n// ->   pix=1 => r = I0^1/3 / dist^2/3\n// graph: see https://www.desmos.com/calculator/6m7cebockb\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\n\n#define N 4. // oversampling (use power of 2)\n\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\n\nvoid mainImage( out vec4 O, vec2 U0 )\n{\n    float z = 3.+iTime, r;\n    vec2 R = iResolution.xy, U, Ur, Us;\n    U0 =  (2.*U0-R)/R.y;\n\tU = U0 * z;\n    Ur = U+.2*rnd(floor(U)); // local star location\n    \n    O -= O;\n    \n    //if (floor(U)==floor(Ur))\n        for (float x=-1.; x<=1.; x+=1./N)\n            for (float y=-1.; y<=1.; y+=1./N)\n                \n                Us = Ur + vec2(x,y)*z/R.y,\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\n\t            O += U0.x<0. \n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\n                 //? 1./( pow(r,3.) * z*z)         \n                 //: smoothstep(1.,.8, r/1.5*z);   \n\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xty3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 364, 403, 403, 1216]], "test": "valid"}
{"id": "XtyGWK", "name": "The shallow buoy", "author": "Imsure1200q_1UWE130", "description": "0.-1A6\nVERSION 0.-1 α.4 :\n     Waving Water, Blue.\n-v.0-1A6\n     New color. Special Effect If You Go Further Away From Laptop/Desktop. Move Bouy with mouse.", "tags": ["water", "raynarching"], "likes": 1, "viewed": 698, "published": "Public API", "date": "1476787587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = asin(1.)*2.;\nconst float KEY_SP = 36.5/256.0;\nvec3 translation( vec3 p, vec3 dl )\n{\n    \n    return p-dl;\n}\nvec3 dilation(vec3 ro)\n{\n    return ro+log2(pi);\n}\nvec3 tespos(vec3 p, float i)\n{\n    vec3 p1 = vec3(\n        p.x,\n        p.y,\n        p.z);\n    return p1;\n}\nvec3 rotation(vec3 p)\n{\n    return p*cos(p.x)*sin(p.z);\n}\nvec3 ftal(vec3 p, vec2 uv)\n{\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 center;\n    if(length(uv)-0.5 > 0.2)\n    {\n        center = vec2(1.);\n    }\n    p = vec3(p.xy+center, p.z);\n    vec3 ro = rotation(p);\n    vec3 dl = dilation(ro);\n    vec3 tr = translation(p, dl);\n    return tr;\n    \n}\nfloat sdPlane( vec3 p, bool water, bool sand )\n{\n    if(water == true)\n    {\n    float f = mod( sin(1.0*p.z-iTime)+\n                           tan(1.0*p.x-iTime), 0.25/max(abs(p.z), 1.25));\n    float g = mod( sin(1.0*p.x-iTime)+\n                           atan(1.0*p.z-iTime), 1.25/max(abs(p.x), 2.25));\n    float h = mod( sin(2.5*p.z-iTime)+\n                           tan(0.5*p.x-iTime), 0.5/max(abs(p.z), 1.5));\n    float i = mod( sin(2.5*p.x-iTime)+\n                           atan(0.5*p.z-iTime), 0.7/max(abs(p.x), 1.7));\n\treturn p.y+(f*g+h*i);\n    }\n    else\n    {\n        return p.y;\n    }\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-r;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat3 rotate3d(float a)\n{\n    return mat3(cos(a),-sin(a),sin(a),\n                cos(a),cos(a),-sin(a),\n                sin(a),cos(a),cos(a));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nfloat blend (float a, float b, float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\nfloat scDir(float p, float s)\n{\n    vec3 x = vec3(p);\n    return length(cross(sin(x), cos(x))-cross(asin(x),acos(x)))-s;\n}\nfloat snDir(float p, float s)\n{\n    vec3 x = normalize(vec3(p));\n    vec2 y = vec2(p);\n    return scDir(length(x)-s, s);\n}\nvec2 blend(vec2 a, vec2 b, float k)\n{\n    return vec2(blend(a.x,b.x,k),(a.x>b.x) ? b.y : a.y);\n}\nvec2 map( vec3 pos, vec3 mo )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float lengthuv = length(uv*2.0-1.0)-1.0;\n    vec3 lv = vec3(lengthuv);\n    lv -= vec3(0.1, 0.6, 0.9);\n    vec3 sun = reflect(lv, pos);\n    vec3 p = vec3(pos.x, pos.y+0.1, pos.z);\n    float d1;\n    float d2;\n    float d3;\n    vec2 x = vec2(sdPlane(p, true, false),1.2);\n    float tf = 0.0;\n    //Putting An Object:\n    /*Copy & Paste:\n    p = vec3(pos.x, pos.y, pos.z); // Position: Add For Negative, Subtract For Positive.\n    //p *= rotate2d(<degrees>); //Rotation' <degrees> means the degrees of rotation. ex.:90, 180, 240, 360.\n    d1 = <fos>(<arguments>);\n    //<fos> means function of shape (sdSphere, sdBox, sdRoundBox, sdHexPrism, etc.);\n    //<arguments> means number of variables that should be extracted to he function.\n    x = opU(vec2(d1, 3.0), x);\n    */\n    p = vec3(pos.x+1., pos.y+(sin(iTime))/8.+0.3, pos.z);\n    \n    // Position: Add For Negative, Subtract For Positive.\n    //p *= rotate2d(<degrees>); //Rotation' <degrees> means the degrees of rotation. ex.:90, 180, 240, 360\n    d1 = sdSphere(p, 0.45);\n    //<fos> means function of shape (sdSphere, sdBox, sdRoundBox, sdHexPrism, etc.);\n    //<arguments> means number of variables that should be extracted to he function.\n    x =  blend(vec2(d1, 1.1), x+vec2(0.001, 0.), 0.2);\n    \n    p = vec3(pos.x-13., pos.y, pos.z-0.1);\n    d1 = sdSphere(p, 2.);\n    p = vec3(pos.x-9.6, pos.y, pos.z+3.6);\n    d2 = sdSphere(p, 1.5);\n    d3 = blend(d1, d2, 3.6);\n    p = vec3(pos.x-12.1, pos.y, pos.z-4.2);\n    d1 = sdSphere(p, 3.);\n    p = vec3(pos.x-16.0, pos.y, pos.z+2.5);\n    d2 = sdSphere(p, 2.5);\n    d3 = blend(blend(d3, d1, 1.8), d2, 1.8);\n    p = vec3(pos.x-10.0, pos.y+2.25, pos.z);\n    d1 = sdSphere(p, 3.);\n    d3 = blend(d3, d1, 0.1);\n    x = blend(vec2(d3, 1.3), x, 0.1);\n    \n    \n    return x;\n    \n}\nvec2 castRay( in vec3 ro, in vec3 rd, in vec3 mo )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t, mo );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in vec3 mo )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ,mo).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\nfloat softreflect( in vec3 ro, in vec3 rd, in float mint, in float tmax, in vec3 mo, vec3 ref )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ,mo).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 )-ref.x;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 mo )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy,mo).x - map(pos-eps.xyy,mo).x,\n\t    map(pos+eps.yxy,mo).x - map(pos-eps.yxy,mo).x,\n\t    map(pos+eps.yyx,mo).x - map(pos-eps.yyx,mo).x );\n\treturn normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor, in vec3 mo )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, mo ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec4 render( in vec3 ro, in vec3 rd, in vec3 mo )\n{\n    \n    vec4 dfcol = vec4(0.7, 0.9, 1.0, 1.0);\n    vec2 res = castRay(ro,rd,mo);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 col = dfcol.xyz;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos,mo );\n        vec3 ref = reflect( rd, nor );\n        vec3 refr = refract(rd, nor, m);\n        \n        vec2 uv = gl_FragCoord.xy / iResolution.xy;\n        float lengthuv = length(uv*2.0-1.0)-1.0;\n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        float occ = calcAO(pos, nor, mo);\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref*refr, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5, mo);\n        dom *= softshadow( pos, ref, 0.02, 2.5, mo );\n        \n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        if( m==1.2)\n        {\n            \n            float f = mod( sin(1.0*pos.z-iTime)+\n                           tan(1.0*pos.x-iTime), 0.25);\n            float g = mod( sin(1.0*pos.x-iTime)+\n                           tan(1.0*pos.z-iTime), 0.25);\n            float h = mod( sin(2.5*pos.z-iTime)+\n                           tan(2.5*pos.x-iTime), 0.3);\n            float i = mod( sin(2.5*pos.x-iTime)+\n                           tan(2.5*pos.z-iTime), 0.3);\n            col = 0.4 + 0.1*((f*g+h*i))*vec3(1.0)+vec3(0.1, 0.9, 0.6)-vec3(0.4);\n            col -= (vec3(0.1, 0.8, 0.4)*max(\n                sin(pos.y+pos.x*fract(sin(pos.x)))*\n                cos(pos.z+pos.y*pos.x*fract(cos(pos.z))), 0.1));\n            col -= (vec3(0.0, 0.3, -0.3)*max(\n                (sin(pos.z+cos(pos.x+tan(pos.y))+sin(pos.z+pos.x))+\n                cos(pos.z+pos.x+fract(\n                    sin(\n                        dot(pos, vec3(126.1,311.7,496.3)))\n                *43758.5453123))+sin(cos(pos.x)/pos.z))*sin(pos.x), 0.0));\n            col += ref.y*0.1/fre*spe;\n        }\n        else if(m==1.1)\n        {\n            if(nor.y > -0.1)\n            {\n                if(nor.x > 0.1) col = vec3(calcAO(vec3(calcAO(pos, nor,mo)),ref,mo))-\n                    (vec3(1.)-vec3(1.0, 0.0, 0.0));\n                else if(nor.z < -0.1) col = vec3(1.0);\n                else if(nor.z > 0.1) col = vec3(calcAO(vec3(calcAO(pos, nor,mo)),ref,mo))-\n                    (vec3(1.)-vec3(1.0));\n                    \n                else if(nor.z > -0.1 && nor.z < 0.1){col = vec3(0.0);}\n            }\n            if(nor.y > 0.95)\n            {\n                col = vec3(1.0, 1.0, 0.0);\n            }\n        }\n        else if(m==1.3)\n        {\n            col = texture(iChannel1, vec2(pos.y+pos.x, pos.y+pos.z)*2.).rgb -\n                (vec3(1.0)-vec3(0.9, 0.9, 0.8))+vec3(0.25);\n            col /= smoothstep(-0.1, 0.1, lin);\n        }\n\n        // lighitng        \n\t\t\n\t\tcol = col*lin;\n\n    \tdfcol = vec4(vec3(mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) )), 1.);\n\n    }\n\n\treturn vec4( clamp(dfcol,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 5.*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y,5.*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 2., 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec4 col = render( ro, rd, vec3(mo, iMouse.z/iResolution.z) );\n\n\tcol = pow( col, vec4(0.4545) );\n\n    fragColor=vec4( col );\n    \n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 100, 100, 124], [125, 125, 149, 149, 175], [176, 176, 206, 206, 283], [284, 284, 307, 307, 341], [342, 342, 370, 370, 666], [667, 667, 715, 715, 1265], [1266, 1266, 1311, 1311, 1400], [1401, 1401, 1437, 1437, 1521], [1522, 1522, 1557, 1557, 1583], [1584, 1584, 1612, 1612, 1698], [1699, 1699, 1723, 1723, 1842], [1843, 1843, 1876, 1876, 1941], [1942, 1942, 1966, 1966, 2098], [2099, 2099, 2140, 2140, 2227], [2228, 2228, 2259, 2259, 2346], [2348, 2348, 2378, 2378, 2411], [2412, 2412, 2442, 2442, 2471], [2472, 2472, 2503, 2503, 2594], [2595, 2595, 2626, 2626, 2717], [2718, 2718, 2755, 2755, 2814], [2815, 2815, 2846, 2846, 4675], [4676, 4676, 4728, 4728, 5322], [5323, 5323, 5409, 5409, 5673], [5674, 5674, 5771, 5771, 6043], [6045, 6045, 6089, 6089, 6327], [6328, 6328, 6382, 6382, 6685], [6687, 6687, 6738, 6738, 10278], [10280, 10280, 10332, 10332, 10509], [10511, 10511, 10568, 10568, 11177]], "test": "error"}
{"id": "XtyGWt", "name": "Smooth RadClick Cristal Tunnel", "author": "aiekick", "description": "Use mouse to see the Corresponding Smooth Variation of the 4 patterns. ", "tags": ["tunnel", "smooth", "cristal", "radclick"], "likes": 22, "viewed": 1202, "published": "Public API", "date": "1477332348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\n\tSmooth RadClick Cristal Tunnel (Radial Click)\n\t\n\tBy Smooth Radial Click, i would say that the shader is divided here in four section.\n\tEach sections have is own Ray Marching Pattern and own Coloration\n\tWith the mouse you can show on the entire screen the section you are under the mouse.\n\t\n\tThe particularity of the Smooth Radial Click, is each section is Mixed according to the range of each Section, \n\tso you have no discontinuity and you have Ray Marching Merged Scene radially.\n\t\n\tThis tech come from my first experiment 2D but extended to the 3d and its cool with the tunnels.\n\t\n\tThe Based 2D Shader : 2D Hex Smooth RadClick\n\thttps://www.shadertoy.com/view/XlK3W1\n*/\n\n// count radial section. \n// with this you can have more section. \n// more sections need more id check, but the tech is exactly the same\nconst float sections = 4.; \t\n\n// some varas\nfloat time = 0.;\t\t\t\t// time\nfloat cid = 0., lid = 0.; \t// current id, last id\nmat3 m1;\t\t\t\t\t\t// matrix used by the pattern merging\nmat3 m2;\t\t\t\t\t\t// matrix used by the pattern merging\n\n// Matrix operations\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\n// tunnel and cam path\nvec2 path(float t){return vec2(cos(t*0.08), sin(t*0.08)) * 4.;}\n\n// continuous angle from atan\nfloat cAtan(vec2 uv)\n{\n\tfloat a = 0.;\n\tif (uv.x >= 0.) a = atan(uv.x, uv.y);\n    if (uv.x < 0.) a = 3.14159 - atan(uv.x, -uv.y);\n    return a;\n}\n\n// return id of region \nfloat GetID(vec2 uv) \n{\n    return cAtan(uv) * floor(sections) * .5 / 3.14159;\n}\n\n// one pattern for each ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat pattern(vec3 p, mat3 m, float s, float id)\n{\n\tfloat r = 0.;\n\tp = abs(fract(p*m*s) - 0.5);\n\tif (id > 3.) r= max(min(abs(p.x),abs(p.z)),abs(p.y));\n    else if (id > 2.) r= max(p.x,abs(p.y)+p.z);\n\telse if (id > 1.) r= length(p);\n    else if (id > 0.) r= max(p.x,-p.y);\n\treturn r;\n}\n\n// redirect displace func according to ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat displace(vec3 p, float id)\n{\n\tvec3 a = vec3(0), b = a;\n\tif (id > 3.) a = vec3(-0.32,0,3), b = vec3(0);\n    else if (id > 2.) a = vec3(0.46,0.42,-1.5), b = vec3(0);\n    else if (id > 1.) a = vec3(0.36,0.2,-2.28), b = vec3(0.36,0.24,1.62);\n\telse if (id > 0.) a = vec3(0.62,0.62,-1.02), b = vec3(0);\n        \n    return \n        (1.-min(pattern(p, m1, a.x, id), pattern(p, m2, a.y, id))) * a.z + \n    \t(1.-min(pattern(p, m1, b.x, id), pattern(p, m2, b.y, id))) * b.z;\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\t\t\t\t\t\t\t\t\t\t\t\t\t// tunnel path\n\t\n\t// mix from displace of last section id with displace of current section id accroding to id range \n    float r = mix(displace(p, lid), displace(p, cid), fract(cid)); \t// id range [0-1]\n\t\n\t// tunnel + dispalce\n\treturn vec4(4.5 - length(p.xy) + r, vec3(p));\n}\n\nvec3 nor( vec3 pos, float k)\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn map(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// color arangement is what i choose\n// its easy to have another coloration wothout modified the lighting.\n// here is an easy way i choose, but you can do alterate more as you want\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nvec4 params(vec4 f, float id)\n{\n\tvec4 c = f;\n    if (id > 3.) c = f.zwyw; \n    else if (id > 2.) c = f.zyzw; \n    else if (id > 1.) c = f.yzyx; \n    else if (id > 0.) c = f.xyzw; \n    return c;\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.001, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// blackbody color according to the subdensity value\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\t\t\t\t\t// use bumpmap fnc of shane here\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 5.) * 0.5; \t\t\t\t\t// one step sub density of df\n\treturn vec4(\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// some mix of WTF :) i tried many different things and this i choose :) but maybe there is other things to do\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\n// get cam \n// g will be gl_FragCoord.xy or uMouse.xy\n//  si is screensize\nvec3 cam(vec2 g, vec2 si, vec3 ro, vec3 cv)\n{\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n\t// matrix used by the pattern\n    m1 = mx * my * mz;\n    m2 = m1 * m1;\n\t\n    time = iTime * 4.;\n    \n    vec3 cu = vec3(0,1,0);\t\t\t\t\t\t\t\t\t\t\t// Camera Up\n  \tvec3 cv = vec3(path(time + .1),time + .1); \t\t\t\t\t// Camera View\n\tvec3 ro = vec3(path(time),time);\t\t\t\t\t\t\t\t// Camera Origin\n\tvec3 lp = vec3(path(ro.z + 7.),ro.z + 7.); \t\t\t\t\t// light point\n    vec3 cp = vec3(path(ro.z + 25.2),ro.z + 25.2); \t\t// center point for Smooth RadClick\n\tvec3 rd = cam(g, si, ro, cv);\t\t\t\t\t\t\t\t\t// Camera Direction\n\n\t// center point for calculate section id accroding to the tunnel path\n\tvec2 rdID = rd.xy - normalize(cp-ro).xy;\n\t\n\t// same center point accroding to the mouse pos\n\t// its permit to shwo for the whole screen the current scene with the ID return by mouse\n\tif (iMouse.z > 0.) \n\t\trdID = cam(iMouse.xy, si, ro, cv).xy - normalize(cp-ro).xy;\n\t\n\t// radial section id\n    float id = GetID(rdID); // 0 to 4\n\n    // circular sections id \n    cid = id; \t\t\t\t\t\t\t\t\t// current section id\n\tlid = cid - 1.; \t\t\t\t\t\t\t// last section id\n\tif (lid < 0.) lid = id + sections - 1.;\t// circular \n\t\n\t// Ray Marching\n    float s = 1.;\n    float d = 0.;\n    for(int i=0;i<60;i++)\n    {      \n        if (log(d*d/s/1e5)>0.) break;\n        d += s = map(ro+rd*d).x * .6;\n    }\n\t\n\t// Color\n    f = shade(ro, rd, d, lp);\n\t\n\t// mix Color Arangement according to Radial Section Range \n\t// mix from params of last section id with params of current section id \n\t// according to the range between the two sections with fract(cid) => range 0 to 1\n\tf = mix(params(f, lid), params(f, cid), fract(cid)); // id range [0-1]\n\t\n\t// improve light a little bit\n\tf = f + f.x*0.3;\n\n\t// fog for hide some ray marching artifact cause by the low count iteration (60 here )\n    f = mix( f, vec4(0.8), 1.0-exp( -0.001*d*d ) );\n        \n\t// gamma correction for add some contrast without saturation\n   \tfragColor = sqrt(f*f*f*2.); // gamma correction\n\t\n\t// show center point for hide the convergent point of the radial color mix \n\tfragColor += 0.0003/dot(rdID,rdID);\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGWt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1237, 1258, 1283, 1283, 1341], [1342, 1342, 1367, 1367, 1425], [1426, 1426, 1451, 1451, 1509], [1511, 1534, 1553, 1553, 1597], [1599, 1629, 1651, 1651, 1773], [1775, 1799, 1822, 1822, 1879], [1881, 1992, 2042, 2042, 2276], [2278, 2404, 2438, 2438, 2876], [2878, 2878, 2896, 2896, 3204], [3206, 3206, 3236, 3236, 3451], [3453, 3674, 3702, 3702, 4027], [4029, 4111, 4168, 4168, 4392], [4394, 4394, 4430, 4430, 4566], [4568, 4744, 4795, 4795, 4966], [4968, 5177, 5240, 5240, 5708], [5710, 5975, 6006, 6006, 6170], [6172, 6172, 6220, 6220, 7338], [7340, 7415, 7460, 7460, 7655], [7657, 7657, 7714, 7714, 9891]], "test": "error"}
{"id": "XtyGz3", "name": "waving stars", "author": "DjinnKahn", "description": "a", "tags": ["a"], "likes": 2, "viewed": 141, "published": "Public", "date": "1475705267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 star( vec2 fragCoord, vec3 starPos )\n{\n    float d = length( (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y - starPos.xy/starPos.z );\n\treturn vec4( vec2(.005)/d/starPos.z, 1.0, 1.0 );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0);\n    for ( int i = 0; i <= 8; i++ )\n    for ( int j = 0; j <= 8; j++ )\n    {\n        float z = 1.0+sin( iTime+float(i+j*2)/10.0 )*.3;\n    \tfragColor += star( fragCoord, vec3(float(i)/4.0-1.0,float(j)/4.0-1.0,z) );\n    } \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 198], [200, 200, 257, 257, 508]], "test": "valid"}
{"id": "XtyGzc", "name": "Desert Passage", "author": "Shane", "description": "A cave-like desert passageway.", "tags": ["raymarch", "cellular", "tile", "cave", "rock", "desert", "passage"], "likes": 163, "viewed": 6100, "published": "Public API", "date": "1476198765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tDesert Passage\n\t--------------\n\n\tThis is a rendering of an ancient sandstone passageway, carved out over time on a planet... that \n\tslightly resembles a hastily-constructed, man-made set on the original Star Trek series, and where \n\tthe occasional rock hangs in mid air. Thankfully, I made up for it with some three-layer dust to \n\tgive it a bit more authenticity. :D\n\n\tI tend to favor abstract scenes, simply for the reason that so-called natural looking ones are harder \n\tto produce at decent frame rates... for me, anyway. With abstract scenes, I can use fake physics - or\n\tincorrect physics - then claim that I meant for it to be that way. :)\n\n\tAiekick's \"Weird Canyon\" was the inspiration for this. I liked his idea to carve out a solid object \n\twith Voronoi to create an \"Antelope Canyon\" like setting. The rendering style was influenced by \n\tDave Hoskins's \"Skin Peeler,\" which is based off of Nimitz's \"Xyptonjtroz\" example. Originally, I'd\n\thoped to emulate the look of IQ's \"Fractal Cave\" with cool streaming light shafts, but I thought I'd \n\tsave that for another time.\n\n\tThe scene is created by constructing a sinusoidal cave like mass, then carving out the surface with a\n\tcustom cellular algorithm that emulates Voronoi. It's pretty self explanatory and is contained in the\n\tdistance function. By the way, if you tried rendering the same scene using regular 3D Voronoi, your \n\tcircuits would fry.\n\n\tIn fact, this particular example makes usage of layering in order of aesthetic importance. Basically, \n\tthe larger, undulating base layers are raymarched -- preferably with cheap algorithms -- and the \n    finer details -- which tend to be more expensive -- are bump mapped.\n\t\n\n\tRelated examples:\n\n\t// Gorgeous rendering.\n\tFractal Cave - IQ\n\thttps://www.shadertoy.com/view/Xtt3Wn\n\n\t// A more abstract version.\n\tWeird Canyon - Aiekick\n\thttps://www.shadertoy.com/view/XtjSRm\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 80.\n\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// 1x1 and 3x1 hash functions.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\nfloat hash( vec3 p ){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n\n// Draw the object on the repeat tile. In this case, a sphere. The result it squared, but that can\n// be taken into account after obtaining the minimum. See below.\nfloat drawObject(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return min(d.x, d.y)*2.66; // Scale between zero and one... roughly.\n}\n\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ return vec2(20.*sin(z * .04), 4.*cos(z * .09) + 3.*(sin(z*.025)  - 1.)); }\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool.\n//vec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the passage structure: I came up with the tiled cellular\n// routine in order to raymarch something that resembled Voronoi. Regular 3D Voronoi is so intensive\n// that it's hard enough to bump map, let alone raymarch. Conceptually speaking, this algorithm is as\n// fast as you're going to get, yet it's still only good for one raymarching layer. The other cellular\n// layers (two more) have been bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    float c = cellTile(p/6.); // Resembles a standard 3D Voronoi layer.\n    return mix(c, cos(c*6.283*2.)*.5 + .5, .125); // Mixing in a touch of sinusoidal variation.\n    \n    // Cheaper wall layering (although, not much), for comparison. \n    //p /= 2.;\n    //float c = dot(tri(p*.5 + tri(p*0.25).yzx), vec3(0.666));\n    //return mix(c, cos(c*6.283*1.5)*.5 + .5, .25);\n    \n    //p /= 5.;\n    //return dot(tri(p + tri(p.zxy)), vec3(0.666));\n\n}\n\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// The desert passage scene. Use a gyroid object as the passage-system base layer, carve it out\n// with the cellular function, put in a floor, then cap the whole thing off at roof height.\nfloat map(vec3 p){\n    \n\t// Surface function to perturb the walls.\n    float sf = surfFunc(p);\n\n    // A gyroid object to form the main passage base layer.\n    float cav = dot(cos(p*3.14159265/8.), sin(p.yzx*3.14159265/8.)) + 2.;\n    \n    // Mold everything around the path.\n    p.xy -= path(p.z);\n    \n    // The oval tunnel. Basically, a circle stretched along Y.\n    float tun = 1.5 - length(p.xy*vec2(1, .4));\n   \n    // Smoothly combining the tunnel with the passage base layer,\n    // then perturbing the walls.\n    tun = smax(tun, 1.-cav, 2.) + .75 + (.5-sf);\n    \n    float gr = p.y + 7. - cav*.5 + (.5-sf)*.5; // The ground.\n    float rf = p.y - 15.; // The roof cutoff point.\n    \n    // Smoothly combining the passage with the ground, and capping\n    // it off at roof height.\n    return smax(smin(tun, gr, .1), rf, 1.);\n \n \n}\n\n\n\n// Basic raymarcher. I haven't tweaked this yet. I think it needs it.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \n    for(int i=0; i<128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        \n        t += h*.8;\n    }\n\n    return min(t, FAR);\n}\n\n\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n) - .2, .001); // The original is multiplied by \"7,\" but it feels slightly redundant.\n    n /= (n.x + n.y + n.z );  // Normalize.\n    // Three planes, weighted by their normals. Hence, tri-planar, I guess. :)\n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p; // Rough sRGB to linear.\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Surface bump function: Cheap, but with decent visual impact. Of couse, \"cheap\" is a relative\n// term. This contains two 3D cellular functions and a 3D noise function. Thankfully, they're all\n// custom written and pretty quick.\nfloat bumpSurf3D( in vec3 p){\n\n    float bmp = cellTile(p/3.)*.8 + cellTile(p)*.2;\n    float ns = n3D(p*6. - bmp*6.);\n    \n    return mix(bmp, 1. - abs(ns-.333)/.667, .05);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \n// through some openings... kind of.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\n    // Plus more iterations slow things down, so it works out, in this case.\n    const int maxIterationsShad = 10; \n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\n        // shadows give that illusion... kind of.\n        dist += clamp(h, .2, stepDist); // For this example only. Not to be trusted. :)\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    // look too brutal to me.\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n\n\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function. For a better version, and usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n    const float maxDist = 3.;\n\t//const float falloff = 0.9;\n    for(float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.66 + hash(i)*.34)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n\n// Just a single color. I debated over whether to include the sun, but the dust is there and I'm saving cycles.\nvec3 getSky(){ return vec3(2., 1.4, .7); }\n\n\n/////\n// Code block to produce three layers of fine dust. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n    p = cos(p*2. + (cos(p.yzx) + 1.)*1.57);// + iTime*1.\n    return dot(p, vec3(0.1666)) + 0.5;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, -0.058, 0.433, 0.899519 )*1.5;\n  \n\tfloat res = 0.;\n\n    float t = trig3(p*3.14159265);\n\tp += (t);\n    p = m3RotTheta*p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*3.14159265); \n\tp += (t)*0.7071;\n    p = m3RotTheta*p;\n     //p = (p+0.7071)*1.5;\n    res += t*0.7071;\n\n    t = trig3(p*3.14159265);\n\tres += t*0.5;\n\t \n\treturn res/2.2071;\n}\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Very few layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/3.; // Edge the ray a little forward to begin.\n\n    \n    for (int i = 0; i<3; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = 1./(1. + sDi*0.1 + sDi*sDi*0.01);\n\t    // Noise layer.\n        mist += trigNoise3D(ro/2.)*sAtt;//trigNoise3D\n        // Advance the starting point towards the hit point.\n        ro += rd*t/3.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/1.5 + hash31(ro)*0.1-0.05, 0., 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*8.); // Camera position, doubling as the ray origin.\n\tvec3 lookAt = ro + vec3(0, 0, .5);  // \"Look At\" position.\n \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.5; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\n    \n\t\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\n \n\n\t// Raymarching.\n    float t = trace(ro, rd);\n    \n   \n    // Sky. Only retrieving a single color this time.\n    vec3 sky = getSky();\n    \n    // The passage color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = sky;\n    \n    // Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    // the mist, so that's why it's declared in an untidy postion outside the block below...\n    // It seemed like a good idea at the time. :)\n    vec3 sp = ro+t*rd; \n    \n    float pathHeight = sp.y-path(sp.z).y; // Path height line, of sorts.\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal( sp ); // Surface normal.\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp-sp;\n        ld /= max(length(ld), 0.001); // Normalize the light direct vector.\n\n        \n        // Texture scale factor.        \n        const float tSize = 1./4.;\n        \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .75/(1. + t/FAR*.25));\n        \n        // Bump mapping with the pink sandstone texture to provide a bit of gritty detailing.\n        float bf = (pathHeight + 5. < 0.)?  .05: .025;\n        sn = doBumpMap(iChannel0, sp*tSize, sn, bf/(1. + t/FAR));\n        \n        \n        float shd = softShadow(sp, ld, 0.05, FAR, 8.); // Shadows.\n        float ao = calculateAO(sp, sn); // Ambient occlusion.\n        \n        float dif = max( dot( ld, sn ), 0.0); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 5.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. It's made up, but I figured a little occlusion (less ambient light\n        // in the corners, etc) and reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = ao*.125 + fre*fre2*.2;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = clamp(mix(vec3(1.152, 0.4275,.153), vec3(.225, 0.05985, 0.0153), -sn.y*.5 + pathHeight*.5 + 1.75), vec3(.9, 0.534375, 0.239), vec3(.9, .855, .765));\n        \n              \n        // Give the soil a bit of a sandstone texture.\n        col = smoothstep(-.5, 1., tex3D(iChannel0, sp*tSize, sn)*2.)*(col + vec3(.225, .21375, .19125));\n        \n        // Making the ground reflect just a little more to give the appearance of fine dust or sand...\n        // It's a work in progress. :)\n        col += smoothstep(0., 1., -pathHeight - 5.5)*fre*.25;\n \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        col += getSky()*fre*fre2; \n        \n        \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = (col*(dif + amb) + vec3(1)*fre2*spe)*shd*ao + amb*pow(col, vec3(2.));\n\n        \n    }\n    \n   \n    // Combine the scene with the sky using some cheap volumetric substance.\n\tfloat dust = getMist(ro, rd, lp, t)*(1.-clamp((pathHeight - 5.)*.125, 0., 1.));//(-rd.y + 1.);\n    sky = getSky()*mix(1., .75, dust);\n    col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n    //col = mix(col, sky, min(t*.75/FAR, 1.)); // Linear fade. Much dustier. I kind of like it.\n\n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col = min(col, 1.)*pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125);\n \n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2305, 2364, 2386, 2386, 2454], [2456, 2487, 2509, 2509, 2544], [2545, 2545, 2566, 2566, 2625], [2628, 2792, 2820, 2820, 2857], [2860, 3218, 3244, 3352, 3837], [3841, 3944, 3966, 3966, 4041], [4250, 4702, 4728, 4728, 5179], [5182, 5215, 5254, 5254, 5350], [5352, 5401, 5439, 5439, 5534], [5536, 5724, 5742, 5790, 6561], [6565, 6635, 6671, 6671, 7101], [7104, 7389, 7413, 7413, 7575], [7867, 8025, 8073, 8073, 8425], [8428, 8510, 8572, 8572, 9079], [9081, 9224, 9245, 9245, 9591], [9593, 9823, 9852, 9852, 9998], [10000, 10050, 10107, 10107, 10489], [10491, 10751, 10834, 10834, 13439], [13445, 13742, 13784, 13784, 14111], [14114, 14226, 14240, 14240, 14268], [14271, 14564, 14587, 14587, 14685], [14687, 14832, 14861, 14895, 15328], [15330, 15381, 15402, 15402, 15468], [15470, 15766, 15828, 15828, 16438], [16440, 16440, 16496, 16525, 22371]], "test": "error"}
