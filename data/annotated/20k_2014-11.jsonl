{"id": "4d2SWV", "name": "Soft Sphere Shadows", "author": "ben", "description": "Trying to get correct shadows from spherical lights/occluders. I'm sure someone with an actual education could do it much more elegantly, but I'm pleased with this.\n\nI still have no idea what I'm doing though. Yaaaay!", "tags": ["lighting", "shadows", "analytic"], "likes": 8, "viewed": 328, "date": "1416091637", "time_retrieved": "2024-06-20T18:14:09.446987", "image_code": "//\tCreative Commons CC0 1.0 Universal (CC-0) \n//\t\n//\tAnalytic shadows from spherical occluders and a spherical light.\n//\t\n//\tIt breaks if the light and occluder intersect, but I think all other cases are handled correctly.\n//\t\n//\t~bj.2014\n//\t\n\n#define POST_TONEMAP\n#define POST_DITHER\n#define POST_VIGNETTE\n\nconst float PI = 3.1415927;\nconst int nSpheres\t= 8;\nconst float camDist\t= 32.0;\n\nstruct sphere { vec3 o; float r; int id; };\nstruct ray { vec3 o, d; float t; sphere s; };\n\nvec2 hash(float n) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\nfloat hash(vec2 p) { return fract(1e4*sin(17.0*p.x+p.y*0.1)*(0.1+abs(sin(p.y*13.0+p.x)))); }\n\nfloat shadow(vec3 P, vec3 lightPos, float lightRad, vec3 occluderPos, float occluderRad)\n{\n\tfloat radA = lightRad;\n\tfloat radB = occluderRad;\n\t\n\tvec3 vecA = lightPos - P;\n\tvec3 vecB = occluderPos - P;\n\t\n\tfloat dstA = sqrt(dot(vecA, vecA));\n\tfloat dstB = sqrt(dot(vecB, vecB));\n\t\n\tif (dstA - radA / 2.0 < dstB - radB) return 1.0;\n\t\n\tfloat sinA = radA / dstA;\n\tfloat sinB = radB / dstB;\n\t\n\tfloat cosA = sqrt(1.0 - sinA * sinA);\n\tfloat cosB = sqrt(1.0 - sinB * sinB);\n\t\n\tif (cosA * dstA < cosB * dstB) return 1.0;\n\t\n\tvec3 dirA = vecA / dstA;\n\tvec3 dirB = vecB / dstB;\n\t\n\tfloat cosG = dot(dirA, dirB);\n\t\n\tif (cosG < cosA * cosB - sinA * sinB) return 1.0;\n\t\n\tfloat sinG = length(cross(dirA, dirB));\n\t\n\tfloat cscA = dstA / radA;\n\tfloat cscB = dstB / radB;\n\t\n\tfloat cosTheta = clamp((cosB - cosA * cosG) * cscA / sinG, -1.0, 1.0);\n\tfloat cosPhi = clamp((cosA - cosB * cosG) * cscB / sinG, -1.0, 1.0);\n\t\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tfloat sinPhi = sqrt(1.0 - cosPhi * cosPhi);\n\t\n\tfloat theta = acos(cosTheta);\n\tfloat phi = acos(cosPhi);\n\t\n\tfloat unoccluded = theta - cosTheta * sinTheta \n\t\t\t\t\t + (phi - cosPhi * sinPhi)\n\t\t\t\t\t * cosG * sinB * sinB / (sinA * sinA);\n\t\n\treturn 1.0 - unoccluded / PI;\n}\n\nfloat diffuse(vec3 P, vec3 N, vec3 lightPos, float lightRad)\n{\t// based on Seb Lagarde's Siggraph 2014 stuff - https://seblagarde.wordpress.com/\n\tvec3 vec = lightPos - P;\n\tfloat dst = sqrt(dot(vec, vec));\n\tvec3 dir = vec / dst;\n\t\n\tfloat cosA = dot(N, dir);\n\tfloat sinB = lightRad / dst;\n\t\n\tif (abs(cosA / sinB) > 1.0) return cosA;\n\t\n\tfloat sinA = length(cross(N, dir));\n\tfloat cotA = cosA / sinA;\n\t\n\tfloat cosB = sqrt(1.0 - sinB * sinB);\n\tfloat cotB = cosB / sinB;\n\t\n\tfloat x = sqrt(1.0 - cotA * cotA * cotB * cotB) * sinA;\n\t\n\treturn (acos(-cotA * cotB) * cosA - x * cotB + atan(x / cotB) / (sinB * sinB)) / PI;\n}\n\nfloat aoFromSphere(vec3 s, float r, vec3 p, vec3 n)\n{\t// iq's sphere ao - http://www.iquilezles.org/www/articles/sphereao/sphereao.htm\n\tvec3 dir = s - p;\n\tfloat lenSq = dot(dir, dir);\n\tdir *= inversesqrt(lenSq);\n\treturn 1.0 - max(dot(n, dir) * (r*r / lenSq), 0.0);\n}\n\nvec3 shade(ray r, sphere s[nSpheres], vec3 lightPos, float lightRad)\n{\n\tif (r.s.id == -2) return vec3(8.0);\n\t\n\tvec3 P = r.o + r.d * r.t;\n\tvec3 N = vec3(0.0,1.0,0.0);\n\tvec3 C = vec3(1.0,1.0,1.0);\n\t\n\tfloat sh = 1.0;\n\tfloat ao = 1.0;\n\n\tif (r.s.id == -1)\n\t{\n        float x = min(abs(fract(0.2*P.x) - 0.5), abs(fract(0.2*P.z) - 0.5));\n        C *= mix(1.0, (0.4+0.5*smoothstep(0.0, 0.5/r.t, x-0.04)), exp(-0.005*r.t));\n\t\tfor (int i = 0; i < nSpheres; i++)\n\t\t{\n\t\t\tsh *= shadow(P, lightPos, lightRad, s[i].o, s[i].r);\n\t\t\tao *= aoFromSphere(s[i].o, s[i].r, P, N);\n\t\t}\n\t}\n\telse\n\t{\n\t\tN = normalize(P - r.s.o);\n\t\tao *= N.y * 0.5 + 0.5;\n\n\t\tfor (int i = 0; i < nSpheres; i++)\n\t\t{\n\t\t\tif (i != r.s.id)\n\t\t\t{\n\t\t\t\tsh *= shadow(P, lightPos, lightRad, s[i].o, s[i].r);\n\t\t\t\tao *= aoFromSphere(s[i].o, s[i].r, P, N);\n\t\t\t}\n\t\t}\n\n\t\tsh *= max(0.0, diffuse(P, N, lightPos, lightRad));\n\t\t\n\t\tvec2 uv = hash(123.456 * float(r.s.id) / float(nSpheres));\n\t\tC = texture(iChannel0, 1.0 - uv).xyz * 0.5 + 0.25;\n\t}\n\n\tC *= sh * 0.95 + 0.05;\n\tC *= mix(ao, 1.0, sh);\n\t\n\treturn C;\n}\n\nvoid intersect(inout ray r, sphere s)\n{\n\tvec3 o = r.o - s.o;\n\t\n\tfloat b = dot(r.d, o);\n\tfloat c = dot(o, o) - s.r*s.r;\n\tfloat d = b*b - c;\n\t\n\tif (d < 0.0) return;\n\t\n\tfloat t = -b - sqrt(d);\n\tif (t <= 0.0 || t > r.t ) return;\n\t\n\tr.t = t;\n\tr.s = s;\n}\n\nvec3 trace(vec3 ro, vec3 rd)\n{\n\tray r = ray(ro, rd, 4000.0, sphere(vec3(0.0,0.0,0.0), 4000.0, -1));\n\tif (r.d.y < 0.0) r.t = min(r.t, -ro.y / rd.y);\n\t\n\tfloat time = iTime + 90.0;\n\tfloat d = 0.0;\n\tsphere s[nSpheres];\n\t\n\tfor (int i = 0; i < nSpheres; i++) \n\t{\n\t\tfloat f = float(i) / float(nSpheres);\n\t\tvec2 h = hash(f + 0.5);\n\t\tfloat rad = h.x * 1.5 + 0.5;\n\t\tvec3 pos =  vec3(cos(time * f * 0.1), 0.0, sin(time * f * 0.1)) * (d + rad);\n\t\tpos.y += rad + (sin(time * (1.0 - f) * 0.2) * 0.1 + 0.1) * d;\n\t\ts[i] = sphere(pos, rad, i);\n\t\tintersect(r, s[i]);\n\t\td += rad * 2.0;\n\t}\n\t\n\tfloat lightRad = cos(iTime*0.25) * 20.0 + 21.0;\n\tvec3 lightPos = vec3(sin(iTime*0.1) * 24.0 + 12.0, d * 0.25 + lightRad + 5.0, -4.0);\n\tintersect(r, sphere(lightPos, lightRad, -2));\n\t\n\treturn shade(r, s, lightPos, lightRad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy - iResolution.xy;\n\tuv /= max(iResolution.x, iResolution.y);\n\t\n\tvec2 m = vec2(2.3,1.3);\n\tif (iMouse.xy != vec2(0.0))\n\t\tm = vec2(2.0 * PI, 0.4) * iMouse.xy / iResolution.xy + vec2(-PI / 2.0, 1.0);\n\t\n\tvec3 ro = vec3(sin(m.y)*cos(m.x), cos(m.y), sin(m.y)*sin(m.x)) * camDist;\n\tmat3 r = mat3(normalize(cross(-ro,vec3(0.0,1.0,0.0))), 0.0,1.0,0.0, -normalize(ro));\n\tr[1] = cross(r[0],r[2]);\n\tvec3 rd = normalize(r * vec3(uv,1.0));\n\t\n\tvec3 C = trace(ro, rd);\n\t\n\t#ifdef POST_TONEMAP\n\t// tonemapping by Jim Hejl and Richard Burgess-Dawson\n\tfloat exposure = 1.4;\n\tC = max(vec3(0.0,0.0,0.0), C * exposure - 0.004);\n\tC = (C * (6.2 * C + 0.5)) / (C * (6.2 * C + 1.7) + 0.06);\n\t#endif\n\t\n\t#ifdef POST_DITHER\n\tC += hash(uv) * 0.02 - 0.01;\n\t#endif\n\t\n\t#ifdef POST_VIGNETTE\n\tC *= sqrt(1.0 - dot(uv, uv) * 0.25);\n\t#endif\n\t\n\tfragColor= vec4(C, 1.0 );\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2SWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 480, 500, 500, 570], [571, 571, 591, 591, 663], [665, 665, 755, 755, 1878], [1880, 1880, 1942, 2024, 2493], [2495, 2495, 2548, 2629, 2761], [2763, 2763, 2833, 2833, 3805], [3807, 3807, 3846, 3846, 4055], [4057, 4057, 4087, 4087, 4855], [4857, 4857, 4914, 4914, 5775]]}
{"id": "4d2XWV", "name": "Sphere - soft shadow", "author": "iq", "description": "Fake plausible soft shadows for spheres. The parameter \"k\" controls the softness.", "tags": ["3d", "shadow", "sphere"], "likes": 69, "viewed": 12152, "date": "1416196452", "time_retrieved": "2024-06-20T18:14:10.319905", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n// Compute fake soft shadows for sphere objects. You can see this in action here: \n//\n// https://www.shadertoy.com/view/lsSSWV\n//\n// and\n//\n// https://www.shadertoy.com/view/XdjXWK\n//\n//\n// Related info: http://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\n//\n// Other Soft Shadow functions:\n//\n// Sphere:    https://www.shadertoy.com/view/4d2XWV\n// Ellipsoid: https://www.shadertoy.com/view/llsSzn\n// Box:       https://www.shadertoy.com/view/WslGz4\n// Capsule:   https://www.shadertoy.com/view/MlGczG\n\n\n//-------------------------------------------------------------------------------------------\n// sphere related functions\n//-------------------------------------------------------------------------------------------\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    \n#if 0\n    // physically plausible shadow\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    float t = -b - sqrt( max(h,0.0) );\n    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t );\n#else\n    // cheap but not plausible alternative\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );\n#endif    \n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    return dot(nor,r)*(sph.w*sph.w)/(l*l*l);\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // sphere animation\n    vec4 sph = vec4( cos( iTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(1.5,0.0,1.0), 1.0 );\n\n    if( iMouse.z>0.0 ) { sph.x = -1.0+2.0*iMouse.x/iResolution.x;\n                         sph.y =      4.0*iMouse.y/iResolution.y; }\n    \n    vec3 lig = normalize( vec3(0.6,0.3,0.4) );\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0-sphOcclusion( pos, nor, sph );\n    }\n#if 1\n    float t2 = sphIntersect( ro, rd, sph );\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        vec3 pos = ro + t2*rd;\n        nor = sphNormal( pos, sph );\n        occ = 0.5 + 0.5*nor.y;\n\t}\n#endif \n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n        \n\t\tcol = vec3(1.0);\n        col *= clamp( dot(nor,lig), 0.0, 1.0 );\n        col *= sphSoftShadow( pos, lig, sph, 2.0 );\n        col += 0.05*occ;\n\t    col *= exp( -0.05*tmin );\n    }\n\n    col = sqrt(col);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2XWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1669, 1886, 1945, 1945, 2108], [2111, 2111, 2183, 2183, 2637], [2655, 2655, 2716, 2716, 2817], [2819, 2819, 2863, 2863, 2900], [2902, 2959, 2982, 2982, 3052], [3054, 3054, 3094, 3094, 3127], [3129, 3129, 3186, 3186, 4428]]}
{"id": "4dBXDc", "name": "Equipotential Distortion", "author": "stormjay", "description": "Red lines show paths through space that have equal gravitational/charge potential.\nUse the mouse to move the larger mass.", "tags": ["2d", "physics", "science", "gravity"], "likes": 5, "viewed": 262, "date": "1416398389", "time_retrieved": "2024-06-20T18:14:10.537946", "image_code": "vec4 shade(vec2 fragCoord) {\n    vec2 mouse = (iMouse.xy*vec2(2,2) - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // the positions of the three masses\n    vec2 A = mouse;\n    vec2 B =     vec2(-1.0, 0.0)*sin(iTime);\n    vec2 C = B + vec2( 0.5, 0.5)*sin(iTime*1.5);\n\n    // Fit a square from (-1,-1)-(1,1), maintaining aspect ratio\n    vec2 uv = (fragCoord*vec2(2,2) - iResolution.xy) / min(iResolution.x, iResolution.y);\n \n    // general form is the sum of M/r\n    float potential = 50.0/length(uv-A) + 10.0/length(uv-B) + 1.0/length(uv-C);\n    \n    float P = 750.0/potential+iTime;\n    float r = sin(P*10.0)+sin(P*5.0) + potential*0.01;\n    float g = potential*0.001;\n    float b = 0.25;\n    return vec4(r,g,b,1);\n}\n                                               \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    // could add supersampling here\n    fragColor = shade(uv);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBXDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 28, 28, 729], [778, 778, 835, 835, 928]]}
{"id": "4dBXDd", "name": "Reflecting Cat", "author": "dr2", "description": "Felixa, the quantum cat, relaxing in the reflectorium... (see comments for more)", "tags": ["raymarch", "fade", "cat", "reflect"], "likes": 3, "viewed": 708, "date": "1416995689", "time_retrieved": "2024-06-20T18:14:13.090167", "image_code": "// \"Reflecting Cat\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nint idObj, nRefl;\nmat3 bodyMat, headMat, tailMat;\nvec3 catPos, qHit, ltDir;\nfloat bdLen, tCur;\nconst float dstFar = 150.;\nconst float pi = 3.14159;\nconst int idBody = 11, idLegs = 12, idTail = 13, idHead = 14, idEars = 15,\n   idTongue = 16, idEyes = 17, idNose = 18, idWhisk = 19, idTable = 20,\n   idFrame = 21, idOpen = 22, idFloor = 23, idCeil = 24, idMirror = 25;\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.2, 0.25, 0.7);\n  vec3 col;\n  col = sbCol + 0.2 * 1. * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 100.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.xz += 10. * tCur * vec2 (1., -0.6);\n    vec2 p = 0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.65;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (5. * (f - 0.5) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, ltDir), 0.);\n  col = SkyBg (rd) + 1. * (0.35 * pow (s, 6.) +\n     0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.75), cloudFac);\n  return col;\n}\n\nfloat CatBodyDf (vec3 p, float dHit)\n{\n  vec3 q, qh;\n  float h, d, w, a, ca, sa;\n  q = p;\n  w = q.z / bdLen;\n  d = PrCapsDf (q * vec3 (1.3, 1., 1.), 0.7 * bdLen * (1. - 0.07 * w * w), bdLen);\n  if (d < dHit) {\n    dHit = d;  idObj = idBody;  qHit = q;\n  }\n  q = p - bdLen * vec3 (0., -0.55, 0.);\n  vec3 qo = q;\n  q.xz = abs (q.xz) - bdLen * vec2 (0.4, 0.9);\n  q.xz += q.y * vec2 (0.1, 0.3);\n  h = 0.5 * bdLen;\n  w = q.y / h;\n  d = PrCapsDf (q, 0.15 * bdLen * (1. - 0.3 * w * w), h);\n  if (d < dHit + 0.2) {\n    dHit = SmoothMin (dHit, d, 0.2);  idObj = idLegs;  qHit = q * sign (qo.zyx);\n  }\n  q = p - bdLen * vec3 (0., 0., -1.8);\n  w = q.z / bdLen;\n  q.y -= bdLen * (w * (0.7 - 0.5 * w) + 0.2);\n  h = 0.9 * bdLen;\n  a = 0.5 * sin (0.4 * 2. * pi * tCur);\n  ca = cos (a);\n  sa = sin (a);\n  tailMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n  q.z -= h;\n  q = tailMat * q;\n  q.z += h;\n  d = PrCapsDf (q, 0.12 * bdLen * (1. - 0.1 * w), h);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = idTail;  qHit = q;\n  }\n  return dHit;\n}\n\nfloat CatHeadDf (vec3 p, float dHit)\n{\n  vec3 q, qh;\n  float r, h, d, w, rw, a, ca, sa;\n  qh = p - bdLen * vec3 (0., 0.9, 1.5);\n  a = 0.5 * sin (0.4 * 2. * pi * tCur);\n  ca = cos (a);\n  sa = sin (a);\n  headMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n  qh = headMat * qh;\n  q = qh;\n  q.y += 0.4 * q.z;\n  d = PrCapsDf (q * vec3 (1., 1.2, 1.), 0.65 * bdLen, 0.05 * bdLen);\n  d = max (d, - PrCylDf (q * vec3 (1., 2., 1.) - bdLen * vec3 (0., -0.42, 0.7),\n     0.15 * bdLen, 0.2 * bdLen));\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = idHead;  qHit = q;\n  }\n  q.y += 0.22 * bdLen;\n  a = 0.1 * sin (0.3 * 2. * pi * tCur);\n  q.z -= bdLen * (0.45 + a);\n  d = PrCapsDf (q * vec3 (1., 2., 1.), 0.12 * bdLen, 0.17 * bdLen);\n  if (d < dHit) {\n    dHit = d;  idObj = idTongue;  qHit = q;\n  }\n  vec3 qe = qh - bdLen * vec3 (0., 0.75, -0.1);\n  vec3 qo = qe;\n  qe.x = abs (q.x) - 0.4 * bdLen;\n  r = 0.3 * bdLen;\n  w = qe.x / r;\n  rw = r * (1. - 0.5 * w * w);\n  q = qe;\n  q.z -= 0.5 * q.x;\n  float d1 = max (PrCylDf (q.yxz, rw, 0.03 * bdLen), - q.x);\n  q = qe;\n  q.z += 0.1 * q.x;\n  float d2 = max (PrCylDf (q.yxz, rw, 0.03 * bdLen), q.x);\n  d = min (d1, d2);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = idEars;  qHit = q * sign (qo.zyx);\n  }\n  q = qh - bdLen * vec3 (0., 0., 0.37);\n  q.x = abs (q.x) - 0.3 * bdLen;\n  d = PrSphDf (q * vec3 (1., 1.5, 1.), 0.2 * bdLen);\n  if (d < dHit) {\n    dHit = d;  idObj = idEyes;  qHit = q;\n  }\n  q = qh - bdLen * vec3 (0., -0.2, 0.65);\n  q.z += 0.5 * q.y;\n  d = PrCapsDf (q, 0.1 * bdLen, 0.03 * bdLen);\n  if (d < dHit + 0.05) {\n    dHit = SmoothMin (dHit, d, 0.05);  idObj = idNose;  qHit = q;\n  }\n  q = qh - bdLen * vec3 (0., -0.3, 0.65);\n  q.xy = abs (q.xy) - bdLen * vec2 (0.1, -0.005);\n  q.yz += 0.1 * q.x * vec2 (-1., 1.);\n  d = PrCylDf (q.zyx, 0.01 * bdLen, 0.6 * bdLen);\n  if (d < dHit) {\n    dHit = d;  idObj = idWhisk;  qHit = q;\n  }\n  return dHit;\n}\n\nfloat CatDf (vec3 p, float dHit)\n{\n  vec3 q = p; \n  dHit = CatBodyDf (q, dHit);\n  dHit = CatHeadDf (q, dHit);\n  return 0.5 * dHit;\n}\n\nvec3 FurCol (vec3 p, vec3 n)\n{\n  const vec3 c1 = vec3 (0.7, 0.6, 0.), c2 = vec3 (0.1), c3 = vec3 (0.9);\n  p *= 2.5;\n  float s = Fbmn (p, n);\n  return mix (mix (c1, c2, smoothstep (0.8, 1.2, s)), c3,\n     smoothstep (1.4, 1.7, s));\n}\n\nvec4 CatCol (vec3 n)\n{\n  vec3 col = vec3 (0.);\n  float spec = 1.;\n  const vec3 wCol = vec3 (0.9);\n  vec3 q = 2. * qHit / bdLen;\n  if (idObj >= idBody && idObj <= idEars) {\n    if (idObj == idLegs || idObj == idHead) q *= 1.5;\n    else if (idObj == idTail || idObj == idEars) q *= 2.;\n    if (idObj == idTail) n = tailMat * n;\n    else if (idObj == idHead || idObj == idEars) n = headMat * n;\n    if (idObj == idEars && n.z > 0.4) col = vec3 (0.8, 0.6, 0.6);\n    else {\n      vec3 anis = vec3 (1.);\n      if (idObj == idBody) anis = vec3 (1., 0.7, 1.);\n      else if (idObj == idHead) anis = vec3 (1., 1., 1.3);\n      col = FurCol (q * anis, n);\n    }\n    qHit /= bdLen;\n    if (idObj == idBody) col = mix (mix (wCol, col,\n       smoothstep (-0.65, -0.35, qHit.y)),\n       wCol, (1. - smoothstep (-1.15, -0.95, qHit.z)) *\n       smoothstep (0.3, 0.5, qHit.y));\n    else if (idObj == idHead)\n       col = mix (col, wCol, smoothstep (0.25, 0.45, qHit.z));\n    else if (idObj == idTail)\n      col = mix (col, wCol, smoothstep (0.25, 0.45, qHit.z));\n    spec = 0.1;\n  } else if (idObj == idTongue) {\n    col = vec3 (0.9, 0.4, 0.4);\n  } else if (idObj == idEyes) {\n    n = headMat * n;\n    col = vec3 (0., 0.7, 0.2);\n    if (length (qHit - bdLen * vec3 (0.16, 0.12, 0.3)) < 0.4) {\n      col = vec3 (0.4, 0., 0.);\n      spec = 5.;\n    }\n  } else if (idObj == idNose) {\n    col = vec3 (0.3, 0.2, 0.1);\n  } else if (idObj == idWhisk) {\n    col = vec3 (0.9, 0.7, 0.);\n    spec = 5.;\n  }\n  return vec4 (col, spec);\n}\n\nfloat TableDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, d1, d2;\n  float br = 1.9 * bdLen;\n  float bl = 1.1 * bdLen;\n  p -= vec3 (0., - 2.2 * bdLen - 0.01 * br, 0.);\n  q = p;\n  d = PrCylDf (q.xzy, br, 0.04 * br);\n  p.xz += 0.05 * br * vec2 (1., 1.5);\n  q = p;\n  q.xz += 0.05 * br * vec2 (sin (4. * p.y), cos (4. * p.y));\n  q.y += bl;\n  d1 = PrCylDf (q.xzy, 0.07 * br, bl);\n  q = p;\n  q.y += 2. * bl;\n  d2 = PrCylDf (q.xzy, 0.5 * br, 0.15 * br * (1. -\n     0.7 * smoothstep (0.2 * br, 0.35 * br, length (p.xz))));\n  d = min (d, min (d1, d2));\n  if (d < dHit) {\n    dHit = d;  idObj = idTable;  qHit = q;\n  }\n  return dHit;\n}\n\nfloat RoomDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  float bh = 4.5 * bdLen;\n  float bw = 6. * bdLen;\n  float bl = 4. * bdLen;\n  float bt = 0.4 * bdLen;\n  q = p;\n  d = max (PrBoxDf (q, vec3 (bw, bh, bl) + bt),\n     - min (PrBoxDf (q, vec3 (bw, bh, bl + 2. * bt)),\n     min (PrBoxDf (q, vec3 (bw, bh + 2. * bt, bl)),\n     PrBoxDf (q, vec3 (bw + 2. * bt, bh, bl)))));\n  if (d < dHit) {\n    dHit = d;  idObj = idFrame;  qHit = q;\n  }\n  float ar = 1.4;\n  float rf = 0.95;\n  d = max (PrBoxDf (q, vec3 (bw, bh, bl) + 0.7 * bt),\n     - PrBoxDf (q, vec3 (bw, bh, bl) + 0.3 * bt));\n  if (nRefl == 0 && p.z > 0.) {\n    q.z -= bh - bt;\n    q *= vec3 (1., ar, 1.);\n    d = max (d, - PrCylDf (q, rf * ar * bl, 2. * bt));\n  }\n  if (d < dHit) {\n    dHit = d;  idObj = idMirror;  qHit = q;\n  }\n  if (nRefl == 0 && p.z > 0.) {\n    d = max (PrCylDf (q, rf * ar * bl + 0.4 * bt, 0.4 * bt),\n       - PrCylDf (q, rf * ar * bl - 0.4 * bt, 0.45 * bt));\n    if (d < dHit) {\n      dHit = d;  idObj = idOpen;  qHit = q;\n    }\n  }\n  q = p;\n  q.y += bh - 0.05 * bt;\n  d = PrBoxDf (q, vec3 (bw, 0.05 * bt, bl));\n  if (d < dHit) {\n    dHit = d;  idObj = idFloor;  qHit = q;\n  }\n  q = p;\n  q.y -= bh - 0.05 * bt;\n  d = PrBoxDf (q, vec3 (bw, 0.05 * bt, bl));\n  if (d < dHit) {\n    dHit = d;  idObj = idCeil;  qHit = q;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = CatDf (bodyMat * (p - catPos), dHit);\n  dHit = TableDf (p, dHit);\n  dHit = RoomDf (p, dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.15;\n  for (int i = 0; i < 100; i++) {\n    float h = ObjDf (ro + rd * d);\n    if (idObj < idFrame) sh = min (sh, 20. * h / d);\n    d += 0.15;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 2.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return 0.7 * mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col4 = vec4 (0.);\n  if (idObj >= idBody && idObj <= idWhisk) col4 = CatCol (bodyMat * n);\n  else if (idObj == idTable) col4 = vec4 (WoodCol (qHit, n), 2.);\n  else if (idObj == idFrame) col4 = vec4 (2. * WoodCol (3. * qHit, n), 1.);\n  else if (idObj == idOpen) col4 = vec4 (2. * WoodCol (3. *\n     vec3 (5. * atan (qHit.x, qHit.z) / pi, 3. * length (qHit.xy), qHit.z), n), 1.);\n  else if (idObj == idFloor) col4 = vec4 (0., 0.4, 0.4, 1.);\n  else if (idObj == idCeil) col4 = vec4 (2., 2., 1.2, 1.);\n  return col4;\n}\n\nvoid CatPM (float t)\n{\n  float rl = 0.;\n  float az = -0.15 * pi;\n  float el = 0.;\n  catPos = vec3 (0., -1.42 * bdLen, 0.);\n  vec3 ca = cos (vec3 (el, az, rl));\n  vec3 sa = sin (vec3 (el, az, rl));\n  bodyMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  const int maxRefl = 6;\n  const float atten = 0.93;\n  vec3 vn, objCol, col1, col2;\n  float dstHit;\n  vec3 col = vec3 (0., 0., 0.04);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  float reflFac = 1.;\n  nRefl = 0;\n  bool notFstMir = true;\n  if (idObj == idMirror) col2 = SkyCol (ro, rd);\n  for (int nf = 0; nf < maxRefl; nf ++) {\n    if (idObj == idMirror) {\n      ro += rd * dstHit;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.01 * rd;\n      ++ nRefl;\n      idObj = -1;\n      dstHit = ObjRay (ro, rd);\n      reflFac *= atten * reflFac;\n      if (nf == 0) notFstMir = false;\n    } else break;\n  }\n  int idObjT = idObj;\n  if (idObj < 0 || idObj == idMirror) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj >= idBody && idObj <= idTongue || idObj == idFloor)\n       vn = VaryNf (20. * qHit, vn, 0.4);\n    vec4 col4 = ObjCol (vn);\n    objCol = col4.xyz;\n    float spec = col4.w;\n    float dif = max (dot (vn, ltDir), 0.);\n    vec3 vl = 30. * ltDir - ro;\n    float di = 1. / length (vl);\n    float br = min (1.1, 40. * di);\n    float f = dot (ltDir, vl) * di;\n    col1 = reflFac * ((0.1 + pow (f, 16.)) * br * objCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, ltDir) *\n       (dif + spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.))));\n    if (notFstMir) col2 = col1;\n  } else {\n    col1 = pow (reflFac, 0.3) * SkyCol (ro, rd);\n  }\n  col = mix (col2, col1, SmoothBump (8., 25., 3., mod (tCur, 30.)));\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  float zmFac = 1.02;\n  tCur = iTime;\n  bdLen = 2.;\n  float dist = 15.;\n  float el = 0.;\n  float az = pi;\n  float cEl = cos (el);\n  float sEl = sin (el);\n  float cAz = cos (az);\n  float sAz = sin (az);\n  mat3 vuMat = mat3 (1., 0., 0., 0., cEl, - sEl, 0., sEl, cEl) *\n     mat3 (cAz, 0., sAz, 0., 1., 0., - sAz, 0., cAz);\n  vec3 rd = normalize (vec3 (uv, zmFac)) * vuMat;\n  vec3 ro = - vec3 (0., 0., dist) * vuMat;\n  float a = - pi * (0.5 - 0.5 * cos (0.02 * 2. * pi * tCur));\n  ltDir = normalize (vec3 (0.8 * cos (a), 1., 0.8 * sin (a)));\n  ltDir *= vuMat;\n  CatPM (tCur);\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBXDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 243, 267, 267, 322], [324, 324, 348, 348, 395], [397, 397, 422, 422, 601], [603, 603, 624, 624, 761], [763, 763, 792, 792, 994], [996, 996, 1035, 1035, 1242], [1244, 1244, 1289, 1289, 1387], [1389, 1389, 1446, 1446, 1529], [1531, 1531, 1564, 1564, 1591], [1593, 1593, 1625, 1625, 1720], [1722, 1722, 1764, 1764, 1815], [1817, 1817, 1860, 1860, 1933], [2303, 2303, 2325, 2325, 2455], [2457, 2457, 2489, 2489, 3078], [3080, 3080, 3118, 3118, 4130], [4132, 4132, 4170, 4170, 6070], [6072, 6072, 6106, 6106, 6204], [6206, 6206, 6236, 6236, 6438], [6440, 6440, 6462, 6462, 7945], [7947, 7947, 7983, 7983, 8571], [8573, 8573, 8608, 8608, 9886], [9888, 9888, 9910, 9910, 10052], [10054, 10054, 10087, 10087, 10290], [10292, 10292, 10313, 10313, 10558], [10560, 10560, 10597, 10597, 10830], [10832, 10832, 10863, 10863, 11075], [11077, 11077, 11099, 11099, 11620], [11622, 11622, 11644, 11644, 12003], [12005, 12005, 12040, 12040, 13657], [13659, 13659, 13716, 13716, 14448]]}
{"id": "4dfGDf", "name": "raymarcher", "author": "zephmann", "description": "recursive spheres", "tags": ["procedural", "raymarching"], "likes": 1, "viewed": 168, "date": "1416364767", "time_retrieved": "2024-06-20T18:14:13.635241", "image_code": "float sphIntersect(vec3 p, vec3 c, float r)\n{\t\n\tvec3 tp = p;\n\t\t\n\ttp.x = mod(tp.x+0.,8.)-4.;\n\ttp.y = mod(tp.y+1.,4.)-2.;\n\ttp.z = mod(tp.z+0.,8.)-4.;\n\t\t\n\treturn (distance(tp,c) - r);\n\t\n\tvec3 b = vec3(1.,10.,1.);\n\tfloat temp = distance(p, c) - r;\n\tvec3 d = abs(tp) - b;\n  \tfloat d1 = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\n\ttp.x *= 1.25;\n\ttp.z *= 1.25;\n\ttp.y = mod(tp.y+1., 2.) - 1.;\n\t\n\tfloat d2 = distance(tp, c) - r;\n\t\n\td1 = max(d1,-d2);\n\td2 = -p.y + 1.0;\n\t\n\td1 = min(d1,d2);\n\t\n\ttp.x = mod(p.x+4.0, 8.0) - 4.;\n\ttp.z = mod(p.z+4.0, 8.0) - 4.;\n\ttp.y = p.y;\n\td2 = distance(tp, c) - r;\n\treturn min(d1, d2);\n}\n\nvec3 march(vec3 ro, vec3 rd)\n{\n\tvec3 col = vec3(0.);\n\t\n\tfloat t = 5.;\n\tfloat prevt = 0.;\n\tfloat d = 10000000.;\n\tvec3 p;\n\tint j;\n\tconst int maxSteps = 256;\n\t\n\tvec3 light = (vec3(-1., -2., -1.5));\n\t\n\tfloat maxT = 200.;\n\tvec2 delta = vec2(0.001, 0.0);\n\tfloat radius = 1.5;\n\tvec3 center = vec3(0.0, 0.0, 0.0);\n\t\n\tfor(int i=0; i < maxSteps; i++)\n\t{\n\t\tprevt = t;\n\t\tp = ro + rd * t;\n\t\t\n\t\td = sphIntersect(p, center, radius);\n\t\t\n\t\tj = i+1;\n\t\tt += d;\n\t\t\n\t\tif(abs(d) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif((j < maxSteps) && t < maxT)\n\t{\n\t\tvec3 norm = vec3(sphIntersect(p + delta.xyy, center, radius) - sphIntersect(p - delta.xyy, center, radius),\n\t\t\t\t\t\t sphIntersect(p + delta.yxy, center, radius) - sphIntersect(p - delta.yxy, center, radius),\n\t\t\t\t\t\t sphIntersect(p + delta.yyx, center, radius) - sphIntersect(p - delta.yyx, center, radius));\n\t\t\n\t\tvec3 lvec = normalize(light);\n\t\tfloat lambert = max(dot(lvec, normalize(norm)), 0.0);\n\t\t\n\t\tfloat falloff = (150. - t) / (145.);\n\t\t\n\t\tvec3 ncol = abs(rd) * lambert + vec3(0.075);\n\t\tcol = ncol * falloff + col * (1. - falloff);\n\t\t\n\t\tcol *= vec3(float(maxSteps-j) / float(maxSteps));\n\t}\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv - 0.5;\n\t\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 cam = vec3(sin(iTime*0.125)*30.0, -10.0, cos(iTime*0.125)*30.0);\n\tvec3 dir = normalize(-cam);\n\tcam.y += sin(iTime*0.75)*2.0;\n\t\n\tvec3 v1 = cross(dir, vec3(0,1,0));\n\tvec3 v2 = cross(dir, v1);\n\t\n\tdir += v1 * uv.x;\n\tdir += v2 * uv.y;\n\t\n\tvec3 col = march(cam, dir);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dfGDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 45, 45, 619], [621, 621, 651, 651, 1756], [1759, 1759, 1816, 1816, 2217]]}
{"id": "4djSWK", "name": "Ewma2", "author": "guil", "description": "A  variant of my previous shader", "tags": ["2d", "fractal"], "likes": 1, "viewed": 143, "date": "1416007606", "time_retrieved": "2024-06-20T18:14:13.641255", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = .5*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\n\tvec2 z = p;\n    vec2 zn = csqr(z)/dot(z,z);\n\tfloat k =.02;\n\tfor( int i=0; i<60; i++ ) \n\t{\t\t\t\t   \n\t\t\n        z = csqr(z) - .95*z + p;\n        p/=1.2;\n        z/=.7+.1*sin(iTime*.1);\n        if(dot(z,z)>1e12){\n            float k1 = pow(1e12/dot(z,z),.125)*k;\n            zn = (1.-k1)*zn+k1*csqr(z)/dot(z,z);\n            break;}\n        zn = (1.-k)*zn+k*csqr(z)/dot(z,z);\n\t}\n\t\n\tfloat f = (1.-exp(-.8*dot(zn,zn)));\n\tvec3 color=2.*f*abs(vec3(zn.x*zn.x,zn.x*f,zn.y));\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djSWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 89, 110, 110, 156], [158, 158, 215, 215, 775]]}
{"id": "4djXDy", "name": "Box - occlusion", "author": "iq", "description": "Analytic ambient occlusion of a box. Left side of screen, sampled occlusion. Right side of the screen, analytic solution (no rays casted). Move the mouse to compare. Info: [url]http://www.iquilezles.org/www/articles/boxocclusion/boxocclusion.htm[/url]", "tags": ["3d", "box", "occlusion", "analytic"], "likes": 24, "viewed": 5522, "date": "1415595000", "time_retrieved": "2024-06-20T18:14:15.101980", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical ambient occlusion of a box. Left side of screen, stochastically \n// sampled occlusion. Right side of the screen, analytical solution (no rays casted).\n//\n// If the box was intersecting the ground plane, we'd need to perform clipping\n// and use the resulting triangles for the analytic formula instead.\n//    \n// More info here: http://www.iquilezles.org/www/articles/boxocclusion/boxocclusion.htm\n//\n// Other shaders with analytical occlusion or approximations:\n// \n// Box:                        https://www.shadertoy.com/view/4djXDy\n// Box with horizon clipping:  https://www.shadertoy.com/view/4sSXDV\n// Triangle:                   https://www.shadertoy.com/view/XdjSDy\n// Sphere:                     https://www.shadertoy.com/view/4djSDy\n// Ellipsoid (approximation):  https://www.shadertoy.com/view/MlsSzn\n// Capsule (approximation):    https://www.shadertoy.com/view/llGyzG\n\n\n// Other Box functions (http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm)\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n// Gradient:         https://www.shadertoy.com/view/wlcXD2\n\n// 0  my original method, by iterating all 6 faces/12 edges/8 verts\n// 1  optimized method by clem494949 (https://www.shadertoy.com/view/ttlBWf)\n//    which iterates the solid angle hexagon (1 face/6 edges/6 verts)\n#define METHOD 1\n\n\n\n\n//=====================================================\n\n// returns t and normal\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n#if METHOD==0\n// Box occlusion (if fully visible)\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    \n    // 8 verts\n    vec3 v0 = normalize( vec3(-1.0,-1.0,-1.0)*rad - p);\n    vec3 v1 = normalize( vec3( 1.0,-1.0,-1.0)*rad - p);\n    vec3 v2 = normalize( vec3(-1.0, 1.0,-1.0)*rad - p);\n    vec3 v3 = normalize( vec3( 1.0, 1.0,-1.0)*rad - p);\n    vec3 v4 = normalize( vec3(-1.0,-1.0, 1.0)*rad - p);\n    vec3 v5 = normalize( vec3( 1.0,-1.0, 1.0)*rad - p);\n    vec3 v6 = normalize( vec3(-1.0, 1.0, 1.0)*rad - p);\n    vec3 v7 = normalize( vec3( 1.0, 1.0, 1.0)*rad - p);\n    \n    // 12 edges    \n    float k02 = dot( n, normalize( cross(v2,v0)) ) * acos( dot(v0,v2) );\n    float k23 = dot( n, normalize( cross(v3,v2)) ) * acos( dot(v2,v3) );\n    float k31 = dot( n, normalize( cross(v1,v3)) ) * acos( dot(v3,v1) );\n    float k10 = dot( n, normalize( cross(v0,v1)) ) * acos( dot(v1,v0) );\n    float k45 = dot( n, normalize( cross(v5,v4)) ) * acos( dot(v4,v5) );\n    float k57 = dot( n, normalize( cross(v7,v5)) ) * acos( dot(v5,v7) );\n    float k76 = dot( n, normalize( cross(v6,v7)) ) * acos( dot(v7,v6) );\n    float k37 = dot( n, normalize( cross(v7,v3)) ) * acos( dot(v3,v7) );\n    float k64 = dot( n, normalize( cross(v4,v6)) ) * acos( dot(v6,v4) );\n    float k51 = dot( n, normalize( cross(v1,v5)) ) * acos( dot(v5,v1) );\n    float k04 = dot( n, normalize( cross(v4,v0)) ) * acos( dot(v0,v4) );\n    float k62 = dot( n, normalize( cross(v2,v6)) ) * acos( dot(v6,v2) );\n    \n    // 6 faces    \n    float occ = 0.0;\n    occ += ( k02 + k23 + k31 + k10) * step( 0.0,  v0.z );\n    occ += ( k45 + k57 + k76 + k64) * step( 0.0, -v4.z );\n    occ += ( k51 - k31 + k37 - k57) * step( 0.0, -v5.x );\n    occ += ( k04 - k64 + k62 - k02) * step( 0.0,  v0.x );\n    occ += (-k76 - k37 - k23 - k62) * step( 0.0, -v6.y );\n    occ += (-k10 - k51 - k45 - k04) * step( 0.0,  v0.y );\n        \n    return occ / 6.283185;\n}\n#endif\n#if METHOD==1\n// Box occlusion (if fully visible)\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    \n    // Orient the hexagon based on p\n    vec3 f = rad * sign(p);\n    \n    // Make sure the hexagon is always convex\n    vec3 s = sign(rad - abs(p));\n    \n    // 6 verts\n    vec3 v0 = normalize( vec3( 1.0, 1.0,-1.0)*f - p);\n    vec3 v1 = normalize( vec3( 1.0, s.x, s.x)*f - p);\n    vec3 v2 = normalize( vec3( 1.0,-1.0, 1.0)*f - p);\n    vec3 v3 = normalize( vec3( s.z, s.z, 1.0)*f - p);\n    vec3 v4 = normalize( vec3(-1.0, 1.0, 1.0)*f - p);\n    vec3 v5 = normalize( vec3( s.y, 1.0, s.y)*f - p);\n    \n    // 6 edges\n    return abs( dot( n, normalize( cross(v0,v1)) ) * acos( dot(v0,v1) ) +\n    \t    \tdot( n, normalize( cross(v1,v2)) ) * acos( dot(v1,v2) ) +\n    \t    \tdot( n, normalize( cross(v2,v3)) ) * acos( dot(v2,v3) ) +\n    \t    \tdot( n, normalize( cross(v3,v4)) ) * acos( dot(v3,v4) ) +\n    \t    \tdot( n, normalize( cross(v4,v5)) ) * acos( dot(v4,v5) ) +\n    \t    \tdot( n, normalize( cross(v5,v0)) ) * acos( dot(v5,v0) ))\n            \t/ 6.283185;\n}\n#endif\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n//-----------------------------------------------------------------------------------------\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p.x, p.y-0.3,-3.5) );\n\t\n    // box animation\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( 0.0, 0.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\tvec3 box = vec3(0.2,0.5,0.6) ;\n\n    vec4 rrr = texture( iChannel0, (fragCoord.xy)/iChannelResolution[0].xy, -99.0  ).xzyw;\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = 0.0;\n        \n        if( p.x > s )\n        {\n            occ = boxOcclusion( pos, nor, txx, txi, box );\n        }\n        else\n        {\n   \t\t    vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\t    vec3  rv  = normalize( cross( ru, nor ) );\n\n            occ = 0.0;\n            for( int i=0; i<512; i++ )\n            {\n                // cosine distribution\n                vec2  aa = hash2( rrr.x + float(i)*203.111 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  dir = vec3( rx*ru + ry*rv + rz*nor );\n                vec4 res = boxIntersect( pos+nor*0.001, dir, txx, txi, box );\n                occ += step(0.0,res.x);\n            }\n            occ /= 512.0;\n        }\n\n        col = vec3(1.1);\n        col *= 1.0 - occ;\n    }\n\n    vec4 res = boxIntersect( ro, rd, txx, txi, box );\n    float t2 = res.x;\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.yzw;\n\t\tcol = vec3(0.8);\n\n\t\tvec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n//\t\tcol *= abs(onor.x)*texture( iChannel1, 0.5+0.5*opos.yz ).xyz + \n  //             abs(onor.y)*texture( iChannel1, 0.5+0.5*opos.zx ).xyz + \n    //           abs(onor.z)*texture( iChannel1, 0.5+0.5*opos.xy ).xyz;\n        col *= 1.7;\n        col *= 0.6 + 0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4djXDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2717, 2741, 2826, 2863, 3381], [6573, 6666, 6713, 6713, 7117], [7119, 7119, 7164, 7164, 7280], [7283, 7283, 7306, 7306, 7376], [7378, 7471, 7511, 7511, 7544], [7546, 7546, 7603, 7603, 9998]]}
{"id": "4dS3zy", "name": "Basketball", "author": "Kecho", "description": "Procedural basketball with procedural normals and some fun lighting.", "tags": ["sports", "basketball"], "likes": 25, "viewed": 1552, "date": "1415765156", "time_retrieved": "2024-06-20T18:14:15.101980", "image_code": "// ***************************************//\n// Basketball, by Kleber A Garcia, 2014 (c)\n// ***************************************//\n\n\nconst vec4 BALL = vec4(0.0,0.0,1.0,1.4);\nconst vec3 LIGHT = vec3(2.0, 0.4, -0.5);\nconst vec3 LIGHT2 = vec3(-2.0, 0.4, 0.9);\nconst vec3 LIGHT3 = vec3(-20.0, 4.4, 10.3);\nconst vec3 FLOOR_AMB = vec3(0.65,1.4,0.5);\nconst vec3 CEIL_AMB = vec3(0.95,0.4,0.40);\n#define PI 3.141596\n#define TWO_PI (2.0*PI)\nfloat mat(vec4 ball, vec3 pos, out int material)\n{\n    //try sphere first\n   \tfloat dist = length(ball.xyz - pos) - ball.w;\n  \n    material = 0;\n    \n    return dist;\n}\nvec2 getUv(vec3 normal)\n{\n    vec2 xzNorm = normalize(normal.xz);\n    return vec2((acos(xzNorm.x) / TWO_PI), atan( normal.y/( length(normal.xz) ) ) / TWO_PI);\n}\nvec3 tweakNormal(vec3 normal, float freq, float blending)\n{\n    vec2 uv = getUv(normal);\n    float s = sin(uv.x * freq);\n    float c = cos(uv.y * freq);\n    normal.x += blending*s;\n    normal.z += blending*c;\n    return normalize(normal);\n}\nvoid pointLight(vec3 normal, vec3 pos, vec3 view, vec3 lightPos, out vec3 diffuse, out vec3 spec, float specPow)\n{\n    vec3 lightDir = normalize(lightPos - pos);\n    diffuse = vec3(clamp(dot(lightDir, normal), 0.0, 1.0));\n    \n    vec3 h = reflect(-view, normal);\n    float nDoth = clamp(dot(-lightDir, h), 0.0, 1.0);    \n    spec = vec3(pow(nDoth, specPow));\n    spec = mix(spec, vec3(pow(nDoth, 32.0)), 0.4);\n    \n}\nvoid scene(vec4 ball, vec3 ray, vec3 pos, out vec3 p, out vec3 col)\n{\n    p = pos;\n    int material = -1;\n    for (int it = 0; it < 30; ++it)\n    {\n    \tint m = 0;\n       \tfloat dist = mat(ball, p, m);\n        if (dist < 0.001) { material = m; }\n        else { p = p + dist * ray;}\n    }    \n    \n    if (material == -1) { col = vec3(0,0,0);  }\n    else if (material == 0)\n    {\n        vec3 normal = normalize(p - ball.xyz);\n        \n        vec3 alb = vec3(0.4, 0.08, 0.0);\n        vec3 stripsAlb =vec3(0.01,0.01,0.01); \n\t\tfloat isStrips = 1.0;\n\t\tisStrips *= smoothstep( 0.02, 0.03, abs(normal.x) );\n\t\tisStrips *= smoothstep( 0.02, 0.03, abs(normal.y) );\n\t\tisStrips *= smoothstep( 0.05, 0.06, abs(abs(normal.x) - 2.0*normal.y*normal.y - 0.15) );\n\t\tisStrips = 1.0 - isStrips;\n        vec3 occ = vec3(1.0 - pow(clamp(-p.y, 0.0, 1.0), 4.0));\n        float nDotv = dot(normal, -ray);\n        float fresnel = clamp(0.4 + pow((1.0 - clamp(nDotv, 0.0, 1.0)), 9.0), 0.0, 1.0);\n\t\tfloat roughness = 2.0;\n        float specForce = 1.0;\n        normal = mix(tweakNormal(tweakNormal(normal,3000.0,0.2), 100.0, 0.05), normal, pow(clamp(isStrips+(1.0 - clamp(nDotv, 0.0, 1.0)),0.0,1.0),0.5));\n        float camSpec = 0.2*clamp(pow(clamp(nDotv, 0.0, 1.0), 1.0), 0.0, 0.3);\n        nDotv = dot(normal, -ray);\n        alb = mix(alb, stripsAlb, isStrips);\n        \n        roughness = mix(roughness, 46.0, isStrips);\n        specForce = mix(specForce, 1.5, isStrips);\n\n        vec3 diffuse = vec3(0);\n        vec3 spec = vec3(0);\n        pointLight(normal, p, ray, LIGHT, diffuse, spec, roughness);\n        vec3 diffuse2 = vec3(0);\n        vec3 spec2 = vec3(0);\n        pointLight(normal, p, ray, LIGHT2, diffuse2, spec2, roughness);\n        diffuse += diffuse2;\n        spec += spec2;\n        pointLight(normal, p, ray, LIGHT3, diffuse2, spec2, roughness);\n        diffuse += diffuse2;\n        spec += spec2;\n        vec3 amb = mix(FLOOR_AMB, CEIL_AMB, clamp(2.0*p.y,0.0,1.0));\n        col = alb*(occ*diffuse + amb) + occ*specForce*(spec+camSpec)*fresnel;//spec + alb * (clamp(dot(normal, lightDir),0.0,1.0) + occ*AMB) + occ*0.4*pow((1.0 - clamp(dot(normal, -ray), 0.0, 1.0)), 9.0);\n\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 screen = uv * 2.0 - 1.0;\n    screen.x *= iResolution.x / iResolution.y;\n    vec3 target = vec3(screen.x, screen.y, 0.0);\n    float bounce = pow(0.5*sin(iTime * 10.0) + 0.5 ,0.4);\n    vec4 ball = vec4(BALL.xyz + vec3(0,bounce*1.0,1.0), BALL.w);\n \tvec3 cam = vec3(0,0,-5.0);\n    vec3 ray = normalize(target - cam);\n    vec3 dist = cam - ball.xyz;\n\tfloat s = sin(iTime);\n    float c = cos(iTime); \n    ray = vec3(ray.x*c + ray.z*s, ray.y, ray.x *(-s) + ray.z*c);\n    dist = vec3(dist.x*c + dist.z*s, dist.y, dist.x * (-s) + dist.z*c);\n    \n    cam = dist + ball.xyz;\n\n    vec3 col = vec3(0,0,0);\n    vec3 p = vec3(0,0,0);\n    scene(ball,ray, cam, p, col);\n   \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dS3zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 434, 484, 507, 602], [603, 603, 628, 628, 763], [764, 764, 823, 823, 1004], [1005, 1005, 1119, 1119, 1422], [1423, 1423, 1492, 1492, 3603], [3605, 3605, 3662, 3662, 4411]]}
{"id": "4dSSDy", "name": "Metacircles noodling", "author": "kig", "description": "I wanted to find out how metaballs work, hence playing with distance fields.", "tags": ["2d", "antialiasing"], "likes": 4, "viewed": 267, "date": "1415313564", "time_retrieved": "2024-06-20T18:14:15.108047", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define AA_SIZE 4\n\nfloat meta(vec2 uv) {\n    uv /= 0.8;\n    float l1 = length(uv - vec2(sin(iTime), cos(iTime))*0.5 - vec2(-0.1))-0.3;\n    float l2 = length(uv - vec2(cos(1.4*iTime), sin(iTime))*0.2 - vec2(0.35))-0.4+0.1*sin(1.4*iTime);\n    float l3 = length(uv - vec2(sin(1.5*iTime), cos(1.9*iTime))*0.6 - vec2(-0.1))-0.2+0.1*sin(1.9*iTime);\n    float l4 = length(uv);\n    l4 = max(l4-1.051, -(l4-1.05));\n    return min(l4, min(l3, min(min(l1, l2), l1*l2*l3)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 rand = texture(iChannel0, mod(fragCoord.xy/64.0, 1.0));\n    vec2 pixelAspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 pixelSize = 2.0*pixelAspect / iResolution.xy;\n    vec2 uv = -pixelAspect + fragCoord.xy * pixelSize;\n\n    vec3 accum = vec3(0.0);\n\n    vec3 bg = sqrt(vec3(0.95,0.95, 0.92));\n\n    vec3 color = vec3(1.0-abs(uv*mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime))),0.5+0.5*sin(iTime));\n    color = 1.0-exp(-2.5*(color+pow(color, vec3(16.0))));\n    color += 4.0/256.0*rand.rgb;\n    color = sqrt(color);\n    \n    for (int x=0; x<AA_SIZE; x++) {\n        for (int y=0; y<AA_SIZE; y++) {\n\t\t    float f = meta(uv + vec2(float(x),float(y)) * pixelSize/float(AA_SIZE));\n            accum += mix(color, bg, step(0.0, f-0.005));\n        }\n    }\n\n    fragColor = vec4(accum*accum/float(AA_SIZE*AA_SIZE*AA_SIZE*AA_SIZE), 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSSDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 107, 128, 128, 552], [554, 554, 611, 611, 1462]]}
{"id": "4dSSWV", "name": "Spitfire Pursuit", "author": "dr2", "description": "More fun in the air.", "tags": ["raymarch", "landscape", "flight"], "likes": 17, "viewed": 959, "date": "1415786012", "time_retrieved": "2024-06-20T18:14:18.041520", "image_code": "// \"Spitfire Pursuit\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrCapsDf (vec3 p, vec2 b) {\n  return length (p - vec3 (0., 0., b.x * clamp (p.z / b.x, -1., 1.))) - b.y;\n}\n\nfloat PrCylDf (vec3 p, vec2 b) {\n  return max (length (p.xy) - b.x, abs (p.z) - b.y);\n}\n\nfloat PrConeDf (vec3 p, vec3 b) {\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nint idObj, idObjGrp;\nmat3 flyerMat[2], flMat;\nvec3 flyerPos[2], flPos, qHit, qHitTransObj, sunDir, sunCol;\nvec2 trkOffset;\nfloat szFac, wSpan, fusLen, tCur;\nconst float dstFar = 200.;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (24. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     19. * sin (0.0032 * t) + 100. * trkOffset.x,\n     1. + 3. * sin (0.021 * t) * sin (1. + 0.023 * t), t);\n}\n\nfloat GrndHt (vec2 p, int hiRes)\n{\n  const vec2 vRot = vec2 (1.4624, 1.6721);\n  vec2 q = 0.06 * p;\n  float w = 0.75 * Noisefv2 (0.25 * q) + 0.15;\n  w *= 36. * w;\n  vec2 vyz = vec2 (0.);\n  float ht = 0.;\n  for (int j = 0; j < 10; j ++) {\n    vec3 v = Noisev3v2 (q);\n    vyz += v.yz;\n    ht += w * v.x / (1. + dot (vyz, vyz));\n    if (j == 4 && hiRes == 0) break;\n    w *= -0.37;      \n    q *= mat2 (vRot.x, vRot.y, - vRot.y, vRot.x);\n  }\n  vec3 pt = TrackPath (p.y);\n  pt.y += (sqrt (abs (ht) + 1.) - 1.) * sign (ht) + 0.3 * Noisefv2 (0.1 * p);\n  float g = smoothstep (1., 3.5, sqrt (abs (p.x - pt.x) + 1.) - 1.);\n  return SmoothMin (ht, pt.y * (1. - g) + ht * g, 0.5);\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz, 1);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy, 1), e.x,\n     ht - GrndHt (p.xz + e.yx, 1)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.6, 0.7, 0.7), gCol2 = vec3 (0.2, 0.1, 0.1),\n     gCol3 = vec3 (0.4, 0.3, 0.3), gCol4 = vec3 (0.1, 0.2, 0.1),\n     gCol5 = vec3 (0.7, 0.7, 0.8), gCol6 = vec3 (0.05, 0.3, 0.03),\n     gCol7 = vec3 (0.02, 0.1, 0.02), gCol8 = vec3 (0.1, 0.08, 0.);\n  vec2 q = p.xz;\n  float f, d;\n  float cSpec = 0.;\n  f = 0.5 * (clamp (Noisefv2 (0.1 * q), 0., 1.) +\n      0.8 * Noisefv2 (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n  vec3 col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n  if (n.y < 0.5) {\n    f = 0.4 * (Noisefv2 (0.4 * q + vec2 (0., 0.57 * p.y)) +\n       0.5 * Noisefv2 (6. * q));\n    d = 4. * (0.5 - n.y);\n    col = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n    cSpec += 0.1;\n  }\n  if (p.y > 22.) {\n    if (n.y > 0.25) {\n      f = clamp (0.07 * (p.y - 22. - Noisefv2 (0.2 * q) * 15.), 0., 1.);\n      col = mix (col, gCol5, f);\n      cSpec += f;\n    }\n  } else {\n    if (n.y > 0.45) {\n      vec3 c = (n.y - 0.3) * (gCol6 * vec3 (Noisefv2 (0.4 * q),\n         Noisefv2 (0.34 * q), Noisefv2 (0.38 * q)) + gCol7);\n      col = mix (col, c, smoothstep (0.45, 0.65, n.y) *\n         (1. - smoothstep (15., 22., p.y - 1.5 + 1.5 * Noisefv2 (0.2 * q))));\n    }\n    if (p.y < 0.65 && n.y > 0.4) {\n      d = n.y - 0.4;\n      col = mix (col, d * d + gCol8, 2. * clamp ((0.65 - p.y -\n         0.35 * (Noisefv2 (0.4 * q) + 0.5 * Noisefv2 (0.8 * q) +\n         0.25 * Noisefv2 (1.6 * q))), 0., 0.3));\n      cSpec += 0.1;\n    }\n  }\n  return vec4 (col, cSpec);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 180; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz, 0);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.15, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz, 0));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.2;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = 0.1 * wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.2, 0.3, 0.55);\n  vec3 col;\n  col = sbCol + 0.2 * sunCol * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 150.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 0.5 * tCur;\n    vec2 p = 0.02 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.8;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (5. * (f - 0.4) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + sunCol * (0.35 * pow (s, 6.) +\n     0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.85), cloudFac);\n  return col;\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.01;\n  for (int i = 0; i < 80; i++) {\n    vec3 p = ro + rd * d;\n    float h = p.y - GrndHt (p.xz, 0);\n    sh = min (sh, 20. * h / d);\n    d += 0.5;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nstruct WingParm\n{\n  float span, sRad, trans, thck, tapr;\n};\n\nfloat WingDf (vec3 p, WingParm wg)\n{\n  vec2 q = p.yz;\n  float s = abs (p.x - wg.trans);\n  float dz = s / wg.span;\n  return max (length (abs (q) + vec2 (wg.sRad + wg.tapr * dz * dz * dz, 0.)) -\n     wg.thck, s - wg.span);\n}\n\nfloat PropelDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  dHit /= szFac;\n  p /= szFac;\n  q = p;\n  d = PrCylDf (q - vec3 (0., 0., fusLen - 1.), vec2 (2.3, 0.05));\n  if (d < dHit) {\n    dHit = d;\n    qHitTransObj = q;\n  }\n  return dHit * szFac;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = PropelDf (flyerMat[0] * (p - flyerPos[0]), dHit);\n  dHit = PropelDf (flyerMat[1] * (p - flyerPos[1]), dHit);\n  return dHit;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dHit)\n{\n  vec3 q;\n  WingParm wg;\n  float d, wr, ws;\n  float cLen;\n  float wSweep = 0.1;\n  float taPos = 0.92 * fusLen;\n  dHit /= szFac;\n  p /= szFac;\n  q = p;\n  wr = q.z / fusLen;\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.065 + 0.13 * wr, -0.1),\n     fusLen * vec2 (0.4, 0.08));\n  if (d < dHit) {\n    dHit = d;  idObj = idObjGrp + 1;  qHit = q;\n  }\n  d = PrCapsDf (q - fusLen * vec3 (0., 0., -0.12),\n     fusLen * vec2 (1., 0.14 - 0.1 * wr * wr));\n  d = max (d, q.z - 0.91 * fusLen);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = idObjGrp + 2;  qHit = q;\n  }\n  ws = wSweep * abs (p.x) / wSpan;\n  q = p + vec3 (0., 0.07 * fusLen - 12. * ws, -1. + 2. * ws);\n  wg = WingParm (wSpan, 13.7, 0., 14.05, 0.37);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.3) {\n    dHit = SmoothMin (dHit, d, 0.3);  idObj = idObjGrp + 3;  qHit = q;\n   }\n  q = p + vec3 (0., -0.1 - 6. * ws, taPos + 4. * ws);\n  wg = WingParm (0.45 * wSpan, 6.8, 0., 7.05, 0.37);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.2) {\n    dHit = SmoothMin (dHit, d, 0.2);  idObj = idObjGrp + 4;  qHit = q;\n  }\n  ws = wSweep * abs (p.y) / wSpan;\n  q = p.yxz + vec3 (-0.2, 0., taPos + 20. * ws);\n  wg = WingParm (0.2 * wSpan, 7., 1.5, 7.2, 0.2);\n  d = max (WingDf (q, wg), - q.x);\n  if (d < dHit + 0.4) {\n    dHit = SmoothMin (dHit, d, 0.4);  idObj = idObjGrp + 5;  qHit = q;\n  }\n  q = p + vec3 (0., 0., -0.98 * fusLen);\n  d = PrConeDf (q, vec3 (0.8, 0.6, 0.9));\n  if (d < dHit) {\n    dHit = d;  idObj = idObjGrp + 6;  qHit = q;\n  }\n  q = p + vec3 (0., 0.5, -4.);\n  q.x = abs (q.x) - 3.5;\n  d = PrCylDf (q, vec2 (0.1, 0.5));\n  if (d < dHit) {\n    dHit = d;  idObj = idObjGrp + 7;  qHit = q;\n  }\n  return 0.8 * szFac * dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  idObjGrp = 1 * 256;\n  dHit = FlyerDf (flyerMat[0] * (p - flyerPos[0]), dHit);\n  idObjGrp = 2 * 256;\n  dHit = FlyerDf (flyerMat[1] * (p - flyerPos[1]), dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.07 * szFac;\n  for (int i = 0; i < 50; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.07 * szFac;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjCol (vec3 p, vec3 n)\n{\n  vec3 bCol = vec3 (0.9, 0.9, 0.95), tCol = vec3 (0.9, 0.7, 0.), \n     wCol1 = vec3 (0.3, 0.9, 0.3), wCol2 = vec3 (0.9, 0.3, 0.3),\n     uCol1 = vec3 (0.9, 0.2, 0.), uCol2 = vec3 (0.2, 0.9, 0.),\n     gCol = vec3 (0.05, 0.1, 0.05);\n  float cFac = 1.;\n  int ig = idObj / 256;\n  int id = idObj - 256 * ig;\n  vec3 uCol, wCol;\n  if (ig == 1) {\n    uCol = uCol1;  wCol = wCol1;\n  } else {\n    uCol = uCol2;  wCol = wCol2;\n  }\n  if (id >= 3 && id <= 5) {\n    float s1, s2, s3;\n    if (id == 3) {\n      s1 = 1.9;  s2 = 5.; s3 = 10.;\n    } else if (id == 4) {\n      s1 = 1.;  s2 = 1.2; s3 = 3.8;\n    } else if (id == 5) {\n      s1 = 1.1;  s2 = 1.; s3 = 3.3;\n    }\n    if (abs (qHit.x) > s2 - 0.03 && abs (qHit.x) < s3 + 0.03)\n       cFac = 1. - 0.9 * SmoothBump (- 0.08, 0.08, 0.02, qHit.z + s1);\n    if (qHit.z < - s1)\n       cFac = 1. - 0.9 * (SmoothBump (- 0.05, 0.05, 0.02, abs (qHit.x) - s2)\n       + SmoothBump (- 0.05, 0.05, 0.02, abs (qHit.x) - s3));\n  }\n  vec3 col;\n  if (id == 1 || id == 2) {\n    vec3 nn;\n    if (ig == 1) nn = flyerMat[0] * n;\n    else nn = flyerMat[1] * n;\n    col = mix (uCol, bCol, 1. - smoothstep (-0.9, -0.5, nn.y));\n    col = mix (col, tCol, SmoothBump (-5., -4.5, 0.1, qHit.z) +\n       SmoothBump (-6., -5.5, 0.1, qHit.z));\n  } else if (id == 3) {\n    col = mix (bCol, wCol, SmoothBump (10.5, 11.5, 0.1, abs (qHit.x)));\n    col = mix (col, uCol, SmoothBump (1., 2., 0.3, abs (qHit.x)));\n  } else if (id == 4) {\n    col = mix (bCol, wCol, SmoothBump (4., 4.5, 0.1, abs (qHit.x)));\n    col = mix (col, uCol, SmoothBump (0.1, 1.15, 0.2, abs (qHit.x)));\n  } else if (id == 5) {\n    col = mix (bCol, tCol, SmoothBump (3.5, 4., 0.1, qHit.x));\n    col = mix (col, uCol, SmoothBump (-1., 1., 0.1, qHit.x));\n  } else if (id == 6) {\n    col = tCol;\n  } else if (id == 7) {\n    col = gCol;\n  }\n  if (id == 1) {\n    if (abs (qHit.x) > 0.07 && qHit.z > 1.5 && \n       abs (abs (abs (qHit.z) - 3.2) - 0.6) > 0.07) idObj += 99;\n  }\n  return col * cFac;\n}\n\nvoid PlanePM (float t, float vu)\n{\n  float tInterp = 20.;\n  float dt = 2.;\n  flPos = TrackPath (t);\n  vec3 fpF = TrackPath (t + dt);\n  vec3 fpB = TrackPath (t - dt);\n  vec3 vel = (fpF - fpB) / (2. * dt);\n  float vy = vel.y;\n  vel.y = 0.;\n  vec3 acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  vec3 va = cross (acc, vel) / length (vel);\n  float m1, m2;\n  if (vu == 0.) {\n    m1 = 1.5;  m2 = 25.;\n  } else {\n    m1 = 0.2;  m2 = 10.;\n  }\n  vel.y = vy;\n  vec3 ort = vec3 (m1 * asin (vel.y / length (vel)),\n     atan (vel.z, vel.x) - 0.5 * pi, m2 * length (va) * sign (va.y));\n  if (vu > 0.) {\n    ort.xz *= -1.;  ort.y += pi;\n  }\n  vec3 cr = cos (ort);\n  vec3 sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n  float tDisc = floor ((t) / tInterp) * tInterp;\n  float s = (t - tDisc) / tInterp;\n  flPos.y = (1. - s) * GrndHt (TrackPath (tDisc).xz, 0) +\n     s * GrndHt (TrackPath (tDisc + tInterp).xz, 0) + 5.5;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  const float eps = 0.01;\n  vec3 objCol, col, vn;\n  float dstHit, dstGrnd, dstObj, dstPropel, f;\n  int idObjT;\n  vec3 roo = ro;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  wSpan = 13.;\n  fusLen = 12.;\n  dstPropel = TransObjRay (ro, rd);\n  idObj = 0;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  dstPropel = TransObjRay (ro, rd);\n  if (dstObj < dstPropel) dstPropel = dstFar;\n  float refFac = 1.;\n  if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {\n    float dw = - ro.y / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += eps * rd;\n    dstGrnd = GrndRay (ro, rd);\n    idObj = 0;\n    dstObj = ObjRay (ro, rd);\n    idObjT = idObj;\n    refFac *= 0.4;\n  }\n  bool isGrnd = false;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (ro, vn);\n    if (idObj == 256 + 100 || idObj == 512 + 100)\n       objCol = vec3 (0.2) + 0.5 * SkyCol (ro, reflect (rd, vn));\n    float dif = max (dot (vn, sunDir), 0.);\n    col = sunCol * objCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, sunDir) *\n       (dif + 5. * pow (max (0., dot (sunDir, reflect (rd, vn))), 256.)));\n    dstHit = dstObj;\n  } else {\n    vec3 rp = ro + dstGrnd * rd;\n    if (refFac < 1.) dstHit = length (rp - roo);\n    else dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro = rp;\n      isGrnd = true;\n    } else {\n      col = refFac * SkyCol (ro, rd);\n    }\n  }\n  if (isGrnd) {\n    vn = GrndNf (ro, dstHit);\n    vec4 col4 = GrndCol (ro, vn);\n    col = col4.xyz * refFac;\n    float dif = max (dot (vn, sunDir), 0.);\n    col *= sunCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * GrndSShadow (ro, sunDir) *\n       (dif + col4.w * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));\n  }\n  if (dstPropel < dstFar) col = 0.7 * col + 0.1 -\n     0.04 * SmoothBump (1.6, 1.8, 0.02, length (qHitTransObj.xy));\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, refFac * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return clamp (col, 0., 1.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  if (sd.z > 0.) {\n    vec3 e = vec3 (1., 0., 0.);\n    col = 0.5 * pow (sd.z, 8.) *\n       (1.5 * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n\te.xxy * SmoothBump (0.04, 0.07, 0.07, length (uv - sd.xy)) +\n        e.xyx * SmoothBump (0.15, 0.2, 0.07, length (uv - 0.5 * sd.xy)) +\n        e.yxx * SmoothBump (1., 1.2, 0.07, length (uv + sd.xy)));\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  trkOffset = vec2 (0.);\n  float zmFac = 2.7;\n  tCur = 15. * iTime + 100. * trkOffset.y;\n  sunDir = normalize (vec3 (-0.9, 1., 1.));\n  sunCol = vec3 (1., 0.9, 0.8);\n  szFac = 0.3;\n  float tGap = 16.;\n  tCur += tGap;\n  PlanePM (tCur, 0.);\n  flyerPos[0] = flPos;\n  flyerMat[0] = flMat;\n  PlanePM (tCur + tGap, 0.);\n  flyerPos[1] = flPos;\n  flyerMat[1] = flMat;\n  float vuPeriod = 800.;\n  float lookDir = 2. * mod (floor (tCur / vuPeriod), 2.) - 1.;\n  PlanePM (tCur + (0.5 + 1.5 * lookDir) * tGap, lookDir);\n  vec3 ro = flPos;\n  vec3 rd = normalize (vec3 (uv, zmFac)) * flMat;\n  ro.y += 1.;\n  vec3 col = ShowScene (ro, rd);\n  col += GlareCol (rd, flMat * sunDir, uv);\n  uvs *= uvs * uvs;\n  col = mix (vec3 (0.7), col, pow (max (0., 0.95 - length (uvs * uvs * uvs)), 0.3));\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSSWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 245, 269, 269, 316], [318, 318, 343, 343, 522], [524, 524, 549, 549, 855], [857, 857, 882, 882, 1241], [1243, 1243, 1288, 1288, 1386], [1388, 1388, 1445, 1445, 1528], [1530, 1530, 1563, 1563, 1642], [1644, 1644, 1676, 1676, 1731], [1733, 1733, 1766, 1766, 1839], [2052, 2052, 2078, 2078, 2263], [2265, 2265, 2299, 2299, 2936], [2938, 2938, 2969, 2969, 3151], [3153, 3153, 3184, 3184, 4664], [4666, 4666, 4700, 4700, 5244], [5246, 5246, 5270, 5270, 5505], [5507, 5507, 5539, 5539, 5701], [5703, 5703, 5725, 5725, 5859], [5861, 5861, 5893, 5893, 6466], [6468, 6468, 6506, 6506, 6745], [6808, 6808, 6844, 6844, 7030], [7032, 7032, 7069, 7069, 7279], [7281, 7281, 7308, 7308, 7466], [7468, 7468, 7506, 7506, 7714], [7716, 7716, 7752, 7752, 9435], [9437, 9437, 9459, 9459, 9659], [9661, 9661, 9694, 9694, 9897], [9899, 9899, 9920, 9920, 10165], [10167, 10167, 10204, 10204, 10431], [10433, 10433, 10463, 10463, 12428], [12430, 12430, 12464, 12464, 13497], [13499, 13499, 13534, 13534, 15737], [15739, 15739, 15782, 15782, 16206], [16208, 16208, 16265, 16265, 17178]]}
{"id": "4dSXDc", "name": "Stippling (Black on White)", "author": "Orihaus", "description": " ", "tags": ["2d"], "likes": 0, "viewed": 179, "date": "1416367028", "time_retrieved": "2024-06-20T18:14:18.041520", "image_code": "#define saturate(i) ( clamp( i, 0.0, 1.0 ) )\n\nvec2 hash( vec2 p )\n{\n\treturn -1.0 + 2.0 * fract( sin ( \n       \t\t\t\t\t\t   vec2( dot( p, vec2( 127.1, 311.7 ) ),\n\t\t\t  \t\t\t\t\t     dot( p, vec2( 269.5, 183.3 ) ) ) ) * 43758.5453123 );\n}\n\nvec2 n4rand2( vec2 n )\n{\n\tfloat t = floor( iTime * 24.0 );\n\tvec2 nrnd0 = hash( n + 0.07*t );\n\tvec2 nrnd1 = hash( n + 0.11*t );\t\n\tvec2 nrnd2 = hash( n + 0.13*t );\n\tvec2 nrnd3 = hash( n + 0.17*t );\n    \n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / vec2( 4.0 );\n}\n\nfloat n4rand( vec2 n )\n{\n    vec2 nrndf = n4rand2( n );\n\treturn ( nrndf.x + nrndf.y ) * 0.5;\n}\n\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat doMask( vec2 uv, float radius, float luminance, float pixelWidth )\n{\n    vec2 fractuv = fract( uv ) - 0.5;\n\tfloat fractlength = length( fractuv );// max( abs( fractuv.x ), abs( fractuv.y ) );\n    float pixelMaskRaw = 1.0 - saturate( fractlength );\n    float pixelCircle = smoothstep( radius, radius + pixelWidth, pixelMaskRaw );\n    float pixelMask = ( luminance * 0.005 + pixelCircle ) * pixelMaskRaw; // \"Bloom\"\n    \n    return pixelCircle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n    float scale = 75.0;\n    const int samples = 2;\n    const float fSamples = float( samples * samples * 2 * 2 );\n    const float oneoverfSamples = 1.0 / fSamples;\n    const vec3 luminanceSeed = vec3( 0.2126, 0.7152, 0.0722 );\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 correctedUV = vec2( uv.x * aspect, uv.y );\n    vec2 scaledUV = correctedUV * scale;\n    vec2 pixelUV = fract( scaledUV );\n    vec2 edgeUV = fract( uv );\n    \n   \tvec2 sampleUV = ceil( scaledUV ) / vec2( scale );\n\tsampleUV.x /= aspect;\n    \n    float sample1d = 0.0;\n    for( int x = -samples; x < samples; x++ )\n    {\n    \tfor( int y = -samples; y < samples; y++ )\n        {\n            vec2 subSampleUV = sampleUV;\n            subSampleUV += ( ( aspect ) / ( scale * fSamples ) ) * vec2( float( x ), float( y ) );\n    \t\tsample1d += pow( texture( iChannel0, subSampleUV ).g, 2.2 );\n        }\n    }\n    sample1d *= oneoverfSamples;\n    sample1d = 1.0 - sample1d;\n\n    float luminance = sample1d;\n\n    //\n    \n    vec2 random = n4rand2( floor( scaledUV ) );\n    \n    float pixelRadius = ( luminance + ( ( random.x + random.y ) * 0.025 ) ) * 0.5;\n    pixelRadius = 1.0 - pixelRadius;//saturate( pow( pixelRadius, 2.2 ) );\n    \n    vec2 offset = fwidth( scaledUV ) / float( samples );\n    \n    float mask = 1.0;\n    for( int x = -samples; x < samples; x++ )\n    {\n    \tfor( int y = -samples; y < samples; y++ )\n        {\n            mask -= doMask( 0.025 * random + ( scaledUV + vec2( x, y ) * offset ), pixelRadius, \n                            luminance, max( offset.x, offset.y ) ) * oneoverfSamples;\n        }\n    }\n    \n    //\n    \n    float edgeMaskX;\n    edgeMaskX  = 1.0 - edgeUV.x;\n    edgeMaskX *=       edgeUV.x;\n    \n    float edgeMaskY;\n    edgeMaskY  = 1.0 - edgeUV.y;\n    edgeMaskY *=       edgeUV.y;\n\n    float edgeMask = smin( edgeMaskX, edgeMaskY, 4.0 );\n    \n    edgeMask = pow( edgeMask, mix( 0.333, 2.25, edgeMask ) );\n    edgeMask *= 4.0;\n    edgeMask = min( 1.0, edgeMask );\n    \n    float final = mask * edgeMask;\n\tfragColor = vec4( vec3( pow( mask, 1.0 / 2.2 ) ), 1.0 );\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[46, 46, 67, 67, 227], [229, 229, 253, 253, 480], [482, 482, 506, 506, 576], [578, 578, 619, 619, 697], [699, 699, 773, 773, 1149], [1151, 1151, 1208, 1208, 3332]]}
{"id": "4dSXDd", "name": "Symmetric Origins", "author": "otaviogood", "description": "A fractal that behaves like a Rubik's cube with a bit of a dyson sphere feel.", "tags": ["procedural", "fractal", "raymarch"], "likes": 87, "viewed": 6595, "date": "1417127198", "time_retrieved": "2024-06-20T18:14:20.296457", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// This will lower the framerate, but looks kinda cool\n//#define TOO_MUCH_FRACTAL\n\n//#define MOVING_SUN\nfloat outerSphereRad = 3.5;\n\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\n// Variables for animating and rotating the sides of the object\nfloat chunkAnim = 0.0;\nmat3 rotMat;\nvec3 rotDir;\nfloat rotAmount;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = 0; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n       // wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n*500.0;\n}\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    //p += (1.0/p.y)*0.6;\n\n    // Rotate, but only the part that is on the side of rotDir\n    if (dot(p, rotDir) > 1.0) p *= rotMat;\n\n    // Repeat our position so we can carve out many cylindrical-like things from our solid\n    vec3 rep = fract(p)-0.5;\n    //final = max(final, -(length(rep.xz*rep.xz)*1.0 - 0.0326));\n    float final = -(length(rep.xy*rep.xz) - 0.109);\n    final = max(final, -(length(rep.zy) - 0.33));\n\n    //final = max(final, -(length(rep.xz*rep.xz) - 0.03));\n    //final = max(final, -(length(rep.yz*rep.yz) - 0.03));\n    //final = max(final, -(length(rep.xy*rep.xy) - 0.030266));\n\n    // Repeat the process of carving things out for smaller scales\n    vec3 rep2 = fract(rep*2.0)-0.5;\n    final = max(final, -(length(rep2.xz)*0.5 - 0.125));\n    final = max(final, -(length(rep2.xy)*0.5 - 0.125));\n    final = max(final, -(length(rep2.zy)*0.5 - 0.125));\n\n    vec3 rep3 = fract(rep2*3.0)-0.5;\n    final = max(final, -(length(rep3.xz)*0.1667 - 0.25*0.1667));\n    final = max(final, -(length(rep3.xy)*0.1667 - 0.25*0.1667));\n    final = max(final, -(length(rep3.zy)*0.1667 - 0.25*0.1667));\n\n#ifdef TOO_MUCH_FRACTAL\n    vec3 rep4 = fract(rep3*3.0)-0.5;\n    final = max(final, -(length(rep4.xz)*0.0555 - 0.25*0.0555));\n    final = max(final, -(length(rep4.xy)*0.0555 - 0.25*0.0555));\n    final = max(final, -(length(rep4.yz)*0.0555 - 0.25*0.0555));\n\n    vec3 rep5 = fract(rep4*3.0)-0.5;\n    final = max(final, -(length(rep5.xz)*0.0185 - 0.25*0.0185));\n    final = max(final, -(length(rep5.xy)*0.0185 - 0.25*0.0185));\n    final = max(final, -(length(rep5.yz)*0.0185 - 0.25*0.0185));\n#endif\n\n    // Cut out stuff outside of outer sphere\n    final = max(final, (length(p) - outerSphereRad));\n    // Carve out inner sphere\n    final = max(final, -(length(p) - 2.8));\n    //final = max(final, abs(p.x) - 2.0);\t// for that space station look\n    //final = (length(p) - outerSphereRad);\t// for debugging texture and lighting\n    // Slice the object in a 3d grid so it can rotate like a rubik's cube\n    float slice = 0.02;\n    vec3 grid = -abs(fract(p.xyz)) + slice;\n    final = max(final, grid.x);\n    final = max(final, grid.y);\n    final = max(final, grid.z);\n    //final = min(final, abs(p.y));\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.3)*0.8+0.1;//*PI/2.01;\n    // move camera in and out of the sphere\n    float smallTime = iTime*0.2;\n    float inOut = pow(abs(-cos(smallTime)), 0.6)* sign(-cos(smallTime));\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.35+inOut*2.0);\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 relVec = normalize(worldPix - camPos);\n\n\t// -------------------------------- animate ---------------------------------------\n    float localTime = iTime*0.5;\n    float floorTime = floor(localTime);\n    float zeroToOne = max(0.0,fract(localTime)*1.0-0.0);// *4.0-3.0);\n    // This is the 0..1 for the rotation\n    chunkAnim = smoothstep(0.0, 1.0, zeroToOne);\n    // This is for brightening the outer sphere when a rotation happens\n    float pulse = saturate(-log(zeroToOne*30.0)+2.0);\n\n    //float mft = mod(floorTime, 6.0);\n    // Let's make it rotate a random part every time\n    float mft = Hash1d(floorTime * 2.34567);\n    mft = floor(mft * 5.9999);\t// get a random [0..6) integer\n    // randomize where the rotation slice is\n    float uglyRand = Hash1d(floorTime*1.234567);\n    uglyRand = floor(uglyRand*2.999);\t// get a random [0..3) integer\n    uglyRand = 1.0 / (uglyRand + 1.0);\n\n    // Check which axis we should rotate on and make a matrix for it.\n    if (mft <= 1.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(1.0, 0.0, 0.0,\n                      0.0, cos, sin,\n                      0.0, -sin, cos);\n        rotDir = vec3(uglyRand, 0.0, 0.0);\n    }\n    else if (mft <= 3.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, 0.0, -sin,\n                      0.0, 1.0, 0.0,\n                      sin, 0.0, cos);\n        rotDir = vec3(0.0, uglyRand, 0.0);\n    }\n    else\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, sin, 0.0,\n                      -sin, cos, 0.0,\n                      0.0, 0.0, 1.0);\n        rotDir = vec3(0.0, 0.0, uglyRand);\n    }\n    if (mod(floorTime, 2.0) == 0.0) rotDir = -rotDir;\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.15;\n\tfloat t = 0.2 + Hash2d(uv)*0.1;\t// fade things close to the camera\n\tfloat inc = 0.02;\n\tfloat maxDepth = 11.0;\n\tvec3 pos = vec3(0,0,0);\n    float glow = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 110; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.001)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        // Do some tricks for marching so that we can march the inner glow sphere\n        float lp = length(pos);\n        //if (lp > outerSphereRad + 0.9) break;\n        float inv = max(0.0, 0.1*dist / lp - 0.1);\n        dist = min(max(0.15,lp*0.6 - 0.1), dist);\n        glow += inv;//0.001\n        glow += 0.0025;\n\n        // no deformations messing up the distance function this time. Hurray for getting the math right!\n        t += dist;//*0.9995;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.0025, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.05;\n\t\tfor (int i = 0; i < 30; i++)\n        {\n            vec3 tempPos = pos + sunDir * iter;\n            //if (dot(tempPos, tempPos) > outerSphereRad*outerSphereRad+0.8) break;\n            if (iter > outerSphereRad + outerSphereRad) break;\n            float tempDist = DistanceToObject(tempPos);\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based???\n            iter += max(0.01, tempDist)*1.0;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // make sure the texture gets rotated along with the geometry.\n        vec3 posTex = pos;\n        if (dot(pos, rotDir) > 1.0) posTex = pos * rotMat;\n        posTex = abs(posTex);\t// make texture symetric so it doesn't pop after rotation\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(posTex*32.0);\n        n += noise(posTex*64.0);\n        n += noise(posTex*128.0);\n        n += noise(posTex*256.0);\n        n += noise(posTex*512.0);\n        n *= 0.8;\n        normal = normalize(normal + n*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(posTex*128.0);\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(posTex*8.0))-0.2));\n\n        // make outer edge a little brighter\n\t\ttexColor += (1.0 - vec3(19.0, 5.0, 2.0) * length(normalU))*ambientS;\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.5);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.5);\n        // blue glow light coming from the glow in the middle of the sphere\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n//        lightColor *= ambient;\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        //finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.003));\n        // pulse the outer edge color when something is about to rotate\n        if (dot(pos, rotDir) > 1.0) finalColor += vec3(0.2, 1.4, 0.8)*pulse*saturate(0.000001 / pow(abs(length(pos)-outerSphereRad), 2.0))*2.0;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        //finalColor = saturate(GetSunColorSmall(relVec, sunDir)*0.95-0.01);\n    }\n    // add the ray marching glow\n    finalColor += vec3(0.3, 0.5, 0.9) * glow;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[695, 714, 737, 737, 810], [811, 811, 834, 834, 905], [906, 906, 929, 929, 1015], [1016, 1016, 1057, 1057, 1100], [1138, 1138, 1162, 1162, 1435], [1436, 1436, 1458, 1458, 2043], [2067, 2198, 2221, 2221, 2250], [2251, 2251, 2274, 2274, 2303], [2304, 2304, 2329, 2329, 2358], [2361, 2489, 2543, 2543, 2846], [2847, 2847, 2896, 2896, 3150], [3152, 3681, 3708, 3708, 4272], [4341, 4412, 4444, 4534, 6672], [6674, 6674, 6731, 6816, 16639]]}
{"id": "4dSXDK", "name": "Winter Wonderland", "author": "okro", "description": "If you blur your eyes it looks like snow.", "tags": ["storm", "snow"], "likes": 5, "viewed": 360, "date": "1416093504", "time_retrieved": "2024-06-20T18:14:20.296457", "image_code": "#define time (iTime/20.)\n#define ITERS 6\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.98928,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 old = uv;\n    uv.y += time;\n    uv.x += time;\n   \n    vec3 col = vec3(0.);\n    for(int i = 0; i < ITERS; i++){\n        float g = hash(floor(uv.xy*(120.-float(i)*40.)));\n        if (g >.95){\n    \t\tcol = vec3(1.);\n        \tcol -= (.9-float(i)/float(ITERS));\n        }\n   \t\tuv.y += time;\n    \tuv.x += time*(1.+float(i));\n    }\n       \n    col +=.95;\n    float z = smoothstep(0.4, 1.0, old.y);\n    col -= z / 5.;\n    col.b = 1.;\n    \n\n\tfloat v = smoothstep(0.4, 0.0, old.y);\n    col += v;\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[42, 42, 62, 62, 135], [138, 138, 195, 195, 766]]}
{"id": "4s2SRt", "name": "Oblivion radar", "author": "ndel", "description": "A simple sci-fi radar.", "tags": ["2d", "radar"], "likes": 226, "viewed": 158841, "date": "1415961287", "time_retrieved": "2024-06-20T18:14:20.296457", "image_code": "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n\t    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 2.5 )\n        return 1.0;\n    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )\n        return 1.0;\n    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )\n        return 0.5;\n    else\n\t    return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),3.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 8.0+mod(87.0*iTime, 80.0);\n    return (0.5-0.5*cos(30.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n\tvec2 uv = fragCoord.xy;\n    //center of the image\n    vec2 c = iResolution.xy/2.0;\n    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                  + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n    finalColor += movingLine(uv, c, 240.0) * blue3;\n    finalColor += circle(uv, c, 10.0, 1.0) * blue3;\n    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(iTime)) * blue3;\n    if( length(uv-c) < 240.0 )\n    {\n        //animate some bips with random movements\n    \tvec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*iTime);\n   \t\tfinalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*iTime)+0.15*iTime);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*iTime+7.0)+0.2*iTime);\n        finalColor += bip2(uv,c+p) * red;\n    }\n\n    fragColor = vec4( finalColor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2SRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 585, 639, 663, 1292], [1294, 1294, 1357, 1357, 1460], [1462, 1462, 1541, 1541, 1751], [1752, 1752, 1816, 1816, 2143], [2145, 2145, 2198, 2198, 2619], [2621, 2621, 2671, 2671, 2865], [2866, 2866, 2914, 2914, 3235], [3236, 3236, 3270, 3270, 3316], [3317, 3317, 3351, 3351, 3575], [3576, 3576, 3633, 3633, 4753]]}
{"id": "4s2XDy", "name": "Constructs", "author": "Passion", "description": "Try commenting out lines 23 and 25 :p References - http://www.demoscene.jp/?p=811 https://www.shadertoy.com/view/4s2XRd http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm", "tags": ["3d", "raymarch", "distance"], "likes": 1, "viewed": 140, "date": "1415622968", "time_retrieved": "2024-06-20T18:14:20.296457", "image_code": "float time = iTime;\nfloat mov = -355.+355.*sin(time*.06);\n\nfloat pi = 3.14159265359;\n\nfloat radian = (time*pi)/180.0; \n\nmat3 ry = mat3(cos(radian*12.), 0.0,-sin(radian*12.),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(radian*12.), 0.0, cos(radian*12.)  );    \nmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(radian*13.), sin(radian*13.), \n\t\t\t   0.0,-sin(radian*13.), cos(radian*13.) );\n\nvec3 trans(vec3 p){\n return mod(p,8.0) - 4.0;   \n}\n\nfloat dFunc( vec3 p)\n{\n  p=trans(p);\n  vec2 t = vec2(.8+.5*sin(iTime)*1.0,.3+1.9*cos(iTime)*.1);\n  p.z*=sin(p.y*.4);\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  q.y*=-.05*sin(time*4.);\n  return length(q)-t.y;\n}\n\nvec3 getNormal (vec3 p)\n{\n  const  float  d = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        dFunc (p + vec3 (d, 0.0,0.0)) - dFunc (p + vec3 (-d, 0.0,0.0)),\n        dFunc (p + vec3 (0.0, d, 0.0)) - dFunc (p + vec3 (0.0, -d, 0.0)),\n        dFunc (p + vec3 (0.0,0.0, d)) - dFunc (p + vec3 (0.0,0.0, -d))\n      )\n    );\n}\n\nvec3 light = normalize(vec3(-200.5, -18.0*sin(time), -84.2*-cos(time)));\nvec3 light2 = normalize(vec3(180., 18.2*sin(time), 94.2));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy)/iResolution.y;\n    \n    vec3 camUp = vec3(0.0,1.0,0.0);\n    vec3 camDir = vec3(-sin(-99.),0.0,cos(-99.));\n    vec3 camPos = vec3(2800,0.0,-.5);\n    camPos.x-=mov;\n    camUp  *=rx*ry;//*ry;\n    camDir *=rx*ry;//*ry;\n    \n    vec3 camSide = cross(camDir,camUp);\n    float focus = .8;\n    \n    vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y +camDir*focus);\n    float t =0.0, d;\n    vec3 posOnRay = camPos;\n    \n    for(int i =0; i<32; ++i){\n        d = dFunc(posOnRay);\n        t+=d;\n        posOnRay = camPos + t*rayDir;   \n    }\n    \n    vec4 tex = texture(iChannel0,posOnRay.zy*1.2);\n    vec3 normal=getNormal(posOnRay);\n    vec3 white = vec3(1.0);\n    tex*=1.01;\n    if(abs(d) < 0.001){\n        //https://www.shadertoy.com/view/4s2XRd\n        float diffuse = clamp( dot(normal, light), 0., 1.);\n        float specular = 1.5*pow(clamp(dot(reflect(rayDir, normal), light), 0., 1.), 580.);\n        float specular2 = 1.5*pow(clamp(dot(reflect(rayDir, normal), light2), 0., 1.), 200.);\n        vec3 brdf = 1.5*vec3(.10, .11, .11);\n        float fre = 0.1*pow(clamp(1. + dot(normal, rayDir), 0., 1.), 2.);\n        brdf += 1.30*diffuse*vec3(1., .9, .75);\n        fragColor = vec4(normal+tex.rgb*tex.rgb*tex.rgb+specular+specular2+brdf, 1.0);  \n      }\n    else{\n        fragColor = vec4(0.0);\n      }\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2XDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[372, 372, 391, 391, 422], [424, 424, 446, 446, 631], [633, 633, 658, 658, 968], [1102, 1102, 1159, 1159, 2554]]}
{"id": "4s2XRd", "name": "Fast edge detection", "author": "nimitz", "description": "One thing to keep in mind: The edge detection is sensitive to degenerate or non-continuous SDFs (due to false positives), under-stepping can fix that.", "tags": ["raymarching", "edgedetection", "antialiased", "technique"], "likes": 134, "viewed": 6231, "date": "1415049399", "time_retrieved": "2024-06-20T18:14:21.054128", "image_code": "// Fast Edge detection by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4s2XRd\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define EDGE_SIZE 0.07\n#define SMOOTH 0.025\n\n#define ITR 80\n#define FAR 40.\n#define time iTime\nfloat hash( float n ) { return fract(sin(n)*43758.5453); }\n\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 id = floor( (p+3.)/6.0);\n    p = mod( p+3., 6.0 ) - 3.;\n    float rid = hash(dot(id,vec3(7.,43,113)));\n    p = rotx(p,time*.5+rid+sin(rid*5.+time));\n    p = roty(p,time*0.5+rid*1.1);\n    \n    float d = mix((max(abs(p.x),max(abs(p.y),abs(p.z)))-0.5),max(length(p)-1.,-(length(p)-0.4)),rid);\n    return vec2(d*.85,rid);\n}\n\n\n/*\t\n\tKeeping track of min distance, then, when the min distance \n\tis both under a given threshold and starts increasing (meaning that\n\ta fold was just passed) then I mark that pixel as an edge. The min\n\tdistance can then be smoothed allowing for arbitrarily smooth edges.\n*/\nvec4 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    vec2 d = vec2(0.,10000.);\n    float md = 1.;\n    float id = 0.;;\n    bool stp = false;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d.x>=FAR ) break;\n        d.x += h;\n\t   \tvec2 res = map(ro+rd*d.x);\n        if (!stp) \n        {\n            md = min(md,res.x);\n            if (h < EDGE_SIZE && h < res.x && i>0)\n            {\n                stp = true;\n                d.y = d.x;\n            }\n        }\n        h = res.x;\n        id = res.y;\n    }\n    \n    if (stp) md = smoothstep(EDGE_SIZE-SMOOTH, EDGE_SIZE+0.01, md);\n    else md = 1.;\n\treturn vec4(d, md, id);\n}\n\nvec3 normal(in vec3 p, in float d)\n{  \n    vec2 e = vec2(-1., 1.)*0.003*d;\n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x +\n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy/iResolution.xy*2.-1.;\n    mo = (mo==vec2(-1.))?mo=vec2(0.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t\n    //camera\n    vec3 ro = vec3(4.1,-time*2.,time-0.5);\n    vec3 rd = normalize(vec3(p,2.5));\n    rd = roty(rd,sin(time*0.2)*0.5+0.9+mo.x);\n    rd = rotx(rd,sin(time*0.12+sin(time*.5)*1.)+0.9);\n\t\n\tvec4 rz = march(ro,rd);\n\tvec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    float sun = dot(rd,ligt);\n    vec3 bg = vec3(0.5,0.6,.9)*sun*0.5+0.6;\n    vec3 col = bg;\n    \n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro+rz.x*rd;\n        float d = distance(ro,pos);\n        vec3 nor= normal(pos,d);\n        vec3 h = normalize(ligt - rd);\n        col = sqrt(col);\n        col = mix(sin(vec3(1,2,3)*rz.w*1.9)*0.5+0.35,col,0.2);\n        \n        float dif = clamp( dot(nor, ligt), 0., 1.);\n        float spe = pow(clamp(dot(nor,h), 0., 1.),70.);\n        float fre = 0.1*pow(clamp(1. + dot(nor, rd), 0., 1.), 2.);\n        vec3 brdf = 1.5*vec3(.10, .11, .11);\n        brdf += 1.30*dif*vec3(1., .9, .75);\n        col = col*brdf + col*spe + fre*col;\n    }\n    \n    col  = mix(col,bg,smoothstep(30.,40.,rz.x)); //Distance fog\n    col *= mix(rz.z,1.,smoothstep(30.,40.,rz.y)); //Edges + Fog (using edge-eye distance)\n    \n\tcol = pow(col, vec3(.8))*1.;\n\t//vignetting from iq\n    col *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2XRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 327, 350, 350, 385], [387, 387, 415, 415, 503], [504, 504, 532, 532, 621], [623, 623, 641, 641, 970], [973, 1248, 1284, 1284, 1924], [1926, 1926, 1962, 1962, 2130], [2132, 2132, 2189, 2189, 3681]]}
{"id": "4sjSRt", "name": "sunflower3 (278 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["2tweets", "sunflower", "short"], "likes": 56, "viewed": 2492, "date": "1415008173", "time_retrieved": "2024-06-20T18:14:21.054128", "image_code": "#define N 10.\nvoid mainImage( out vec4 o, vec2 u ) {\n    u = (u+u-(o.xy=iResolution.xy))/o.y;\n    //u = 2.*(u / iResolution.y -vec2(.9,.5));\n    float t = iTime,\n          r = length(u), a = atan(u.y,u.x),\n          i = floor(r*N);\n    a *= floor(pow(128.,i/N)); \t a += 20.*sin(.5*t)+123.34*i-100.*r*cos(.5*t); // (r-0.*i/N)\n    r +=  (.5+.5*cos(a)) / N;    r = floor(N*r)/N;\n\to = (1.-r)*vec4(.5,1,1.5,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjSRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[14, 14, 52, 52, 407]]}
{"id": "4sjSzd", "name": "aliceffekt stripes", "author": "mmalex", "description": "quick 20 min doodle inspired by https://twitter.com/aliceffekt/status/529387010759602177\n", "tags": ["2d", "stripes"], "likes": 4, "viewed": 310, "date": "1415054784", "time_retrieved": "2024-06-20T18:14:21.054128", "image_code": "// quick doodle inspired by https://twitter.com/aliceffekt/status/529387010759602177\n// I should have stayed truer to the original\n// but I'm tired and I guess it didn't go quite to plan :(\n// oh well...\nfloat t=iTime+80.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    uv.y*=2.;\n    uv*=mat2(.4,.3,-.3,.4)*0.3;\n    float z=exp(-uv.y*uv.y*(2000.+1000.*cos(t*0.074+0.36)))*((2.+sin(t*0.035))*0.2)+0.8*cos(uv.y*11.0);\n   uv.x+=0.7*sin(z+t*0.01)*0.3;\n    float d=sin(uv.x*1200.)+0.3;\n    float aa=fwidth(d);\n    float c=smoothstep(-aa,aa,d);\n\tfragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjSzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 223, 280, 280, 627]]}
{"id": "4sSSW3", "name": "Cheap orthonormal basis", "author": "nimitz", "description": "Orthonormal basis without normalization. Mouse enabled.", "tags": ["technique", "tangent", "orthonormal"], "likes": 48, "viewed": 1144, "date": "1416258459", "time_retrieved": "2024-06-20T18:14:21.835834", "image_code": "//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\n\n//I doubt this is needed on gpu, let me know if you need this for it to work.\n//#define HANDLE_SINGULARITY\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n    return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    #ifdef HANDLE_SINGULARITY\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n    #else\n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    #endif\n}\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 dLine(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b)\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\tfloat oad  = dot( oa,  rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(th.x, 0.);\n\tth.y = clamp(th.y, 0., 1.);\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q ), th );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float spe = pow(clamp(dot(reflect(rd,nor), ligt), 0., 1.),100.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        col = col*brdf + col*spe + fre*col;\n    }\n    \n    \n    vec3 pdir = vec3(0.5773);\n    pdir.xz *= mm2(time*0.3);\n    pdir.zy *= mm2(time*.44);\n    float rz2 = march(pdir*3.,-pdir);\n    vec3 bpos = pdir*3.+rz2*-pdir;\n\t\n    vec3 nor= normal(bpos);\n    vec3 r = vec3(0);vec3 f = vec3(0);\n    basis(nor,f,r);\n    \n    vec3 g = dLine(ro,rd,bpos,bpos+nor);\n    float occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.3,.3,1)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+f);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(1.,.2,.2)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+r);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.2,1,.2)*(1.-smoothstep(0.0,.03,g.x)));\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSSW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[234, 393, 414, 414, 466], [468, 468, 487, 487, 557], [559, 559, 596, 596, 825], [827, 827, 857, 857, 1019], [1021, 1133, 1180, 1180, 1619], [1621, 1671, 1729, 1729, 2103], [2106, 2106, 2163, 2163, 4205]]}
{"id": "4sSXDG", "name": "River Flight", "author": "dr2", "description": "Fasten your seatbelts for a wild ride.", "tags": ["raymarching", "landscape", "aircraft"], "likes": 39, "viewed": 2483, "date": "1415275141", "time_retrieved": "2024-06-20T18:14:24.611961", "image_code": "// \"River Flight\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrCapsDf (vec3 p, vec2 b)\n{\n  return length (p - vec3 (0., 0., b.x * clamp (p.z / b.x, -1., 1.))) - b.y;\n}\n\nfloat PrCylDf (vec3 p, vec2 b)\n{\n  return max (length (p.xy) - b.x, abs (p.z) - b.y);\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nint idObj;\nmat3 flyerMat;\nvec3 flyerPos, engPos, qHit, qHitTransObj, sunDir, sunCol;\nvec2 trkOffset;\nfloat szFac, wSpan, tCur;\nconst float dstFar = 400.;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (24. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     19. * sin (0.0032 * t) + 100. * trkOffset.x, 0., t);\n}\n\nfloat GrndHt (vec2 p, int hiRes)\n{\n  const vec2 vRot = vec2 (1.4624, 1.6721);\n  vec2 q = p * 0.06;\n  float w = 0.75 * Noisefv2 (0.25 * q) + 0.15;\n  w *= 36. * w;\n  vec2 vyz = vec2 (0.);\n  float ht = 0.;\n  for (int j = 0; j < 10; j ++) {\n    vec3 v = Noisev3v2 (q);\n    vyz += v.yz;\n    ht += w * v.x / (1. + dot (vyz, vyz));\n    if (j == 4) {\n      if (hiRes == 0) break;\n    }\n    w *= -0.37;      \n    q *= mat2 (vRot.x, vRot.y, - vRot.y, vRot.x);\n  }\n  vec3 pt = TrackPath (p.y);\n  pt.y -= 2.;\n  float g = smoothstep (1.5, 4.5, sqrt (abs (p.x - pt.x)));\n  return min (ht, pt.y * (1. - g) + ht * g);\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz, 1);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy, 1), e.x,\n     ht - GrndHt (p.xz + e.yx, 1)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.6, 0.7, 0.7), gCol2 = vec3 (0.2, 0.1, 0.1),\n     gCol3 = vec3 (0.4, 0.3, 0.3), gCol4 = vec3 (0.1, 0.2, 0.1),\n     gCol5 = vec3 (0.7, 0.7, 0.8), gCol6 = vec3 (0.05, 0.3, 0.03),\n     gCol7 = vec3 (0.1, 0.08, 0.);\n  vec2 q = p.xz;\n  float f, d;\n  float cSpec = 0.;\n  f = 0.5 * (clamp (Noisefv2 (0.1 * q), 0., 1.) +\n      0.8 * Noisefv2 (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n  vec3 col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n  if (n.y < 0.5) {\n    f = 0.4 * (Noisefv2 (0.4 * q + vec2 (0., 0.57 * p.y)) +\n       0.5 * Noisefv2 (6. * q));\n    d = 4. * (0.5 - n.y);\n    col = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n    cSpec += 0.1;\n  }\n  if (p.y > 22.) {\n    if (n.y > 0.25) {\n      f = clamp (0.07 * (p.y - 22. - Noisefv2 (0.2 * q) * 15.), 0., 1.);\n      col = mix (col, gCol5, f);\n      cSpec += f;\n    }\n  } else {\n    if (n.y > 0.45) {\n      vec3 c = (n.y - 0.3) * (gCol6 * vec3 (Noisefv2 (0.4 * q),\n         Noisefv2 (0.34 * q), Noisefv2 (0.38 * q)) + vec3 (0.02, 0.1, 0.02));\n      col = mix (col, c, smoothstep (0.45, 0.65, n.y) *\n         (1. - smoothstep (15., 22., p.y - 1.5 + 1.5 * Noisefv2 (0.2 * q))));\n    }\n    if (p.y < 0.65 && n.y > 0.4) {\n      d = n.y - 0.4;\n      col = mix (col, d * d + gCol7, 2. * clamp ((0.65 - p.y -\n         0.35 * (Noisefv2 (0.4 * q) + 0.5 * Noisefv2 (0.8 * q) +\n         0.25 * Noisefv2 (1.6 * q))), 0., 0.3));\n      cSpec += 0.1;\n    }\n  }\n  return vec4 (col, cSpec);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  float dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz, 0);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.15, 0.4 * h) + 0.008 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz, 0));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.1;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = 0.2 * wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.15, 0.2, 0.65);\n  vec3 col;\n  col = sbCol + 0.2 * sunCol * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 200.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 0.5 * tCur;\n    vec2 p = 0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.65;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (5. * (f - 0.5) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + sunCol * (0.35 * pow (s, 6.) +\n     0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.85), cloudFac);\n  return col;\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.01;\n  for (int i = 0; i < 80; i++) {\n    vec3 p = ro + rd * d;\n    float h = p.y - GrndHt (p.xz, 0);\n    sh = min (sh, 20. * h / d);\n    d += 0.5;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nstruct WingParm\n{\n  float span, sRad, trans, thck, leCut, leRad;\n};\n\nfloat WingDf (vec3 p, WingParm wg)\n{\n  vec2 q = p.yz;\n  float w = max (length (q - vec2 (wg.sRad, 0.)),\n     length (q + vec2 (wg.sRad, 0.)));\n  w = max (max (w - wg.thck, abs (p.x - wg.trans) - wg.span),\n     p.z - wg.leCut);\n  return min (w, max (length (q - vec2 (0., wg.leCut)) - wg.leRad,\n     abs (p.x - wg.trans) - wg.span));\n}\n\nfloat PropelDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  dHit /= szFac;\n  p /= szFac;\n  q = p;\n  q.x = abs (q.x);\n  q -= engPos;\n  d = PrCylDf (q - vec3 (0., 0., 3.65), vec2 (1.9, 0.05));\n  if (d < dHit) {\n    dHit = d;\n    qHitTransObj = q;\n  }\n  return dHit * szFac;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = PropelDf (flyerMat * (p - flyerPos), dHit);\n  return dHit;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dHit)\n{\n  vec3 q;\n  WingParm wg;\n  float d, wr, ws, cLen;\n  const float wSweep = 0.2;\n  const float fusLen = 11.;\n  const float taPos = 12.5;\n  dHit /= szFac;\n  p /= szFac;\n  q = p;\n  wr = q.z / fusLen;\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.045 + 0.08 * wr, 0.),\n     fusLen * vec2 (0.46, 0.11));\n  if (d < dHit) {\n    dHit = d;  idObj = 1;  qHit = q;\n  }\n  d = PrCapsDf (q - fusLen * vec3 (0., 0., -0.32),\n     fusLen * vec2 (1., 0.15 - 0.051 * wr * wr));\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 2;  qHit = q;\n  }\n  ws = wSweep * abs (p.x) / wSpan;\n  q = p + vec3 (0., 0.054 * fusLen - 6. * ws, 12. * ws);\n  wg = WingParm (wSpan, 13.7, 0., 14., 1.72, 0.195);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.2) {\n    dHit = SmoothMin (dHit, d, 0.2);  idObj = 3;  qHit = q;\n   }\n  q = p + vec3 (0., -0.1 - 6. * ws, taPos + 12. * ws);\n  wg = WingParm (0.4 * wSpan, 6.8, 0., 7., 1.2, 0.095);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 4;  qHit = q;\n  }\n  ws = wSweep * abs (p.y) / wSpan;\n  q = p.yxz + vec3 (-0.2, 0., taPos + 12. * ws);\n  wg = WingParm (0.15 * wSpan, 6.8, 2.2, 7., 1.2, 0.095);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 5;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  cLen = 3.5;\n  wr = q.z / cLen;\n  d = PrCylDf (q - engPos, cLen * vec2 (0.2  - 0.07 * wr * wr, 1.));\n  float d2 = PrCylDf (q - engPos, cLen * vec2 (0.04, 1.02));\n  d = max (d, - d2);\n  if (d < dHit) {\n    dHit = d;  idObj = 6;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  d = PrConeDf (q - engPos - vec3 (0., 0., 4.2), vec3 (0.8, 0.6, 0.7));\n  if (d < dHit) {\n    dHit = d;  idObj = 7;  qHit = q;\n  }\n  q = p;\n  cLen = 2.8;\n  q.z += wSweep * wSpan - 0.025 * cLen;\n  q.x = abs (q.x);\n  wr = q.z / cLen;\n  d = PrCapsDf (q - vec3 (wSpan + 0.1, 0.5 * wSweep * wSpan - 0.6, -0.5),\n     cLen * vec2 (1., 0.15 - 0.055 * wr * wr));\n  if (d < dHit) {\n    dHit = d;  idObj = 8;  qHit = q;\n  }\n  return 0.8 * dHit * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = FlyerDf (flyerMat * (p - flyerPos), dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.07 * szFac;\n  for (int i = 0; i < 50; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.07 * szFac;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjCol (vec3 p, vec3 n)\n{\n  vec3 bCol = vec3 (0.8, 0.8, 0.85), wCol = vec3 (0.3, 0.3, 0.7),\n     tCol = vec3 (0.9, 0.7, 0.), uCol = vec3 (0.9, 0.1, 0.);\n  float cFac = 1.;\n  if (idObj >= 3 && idObj <= 5) {\n    float s1, s2;\n    if (idObj == 3) {\n      s1 = 2.2;  s2 = 6.;\n    } else if (idObj == 4) {\n      s1 = 1.2;  s2 = 1.7;\n    } else if (idObj == 5) {\n      s1 = 1.;  s2 = 1.;\n    }\n    if (abs (qHit.x) > s2 - 0.03)\n       cFac = 1. - 0.9 * SmoothBump (- 0.08, 0.08, 0.02, qHit.z + s1);\n    if (qHit.z < - s1)\n       cFac = 1. - 0.9 * SmoothBump (- 0.05, 0.05, 0.02, abs (qHit.x) - s2);\n  }\n  vec3 col;\n  vec3 nn;\n  if (idObj >= 1 && idObj <= 5) nn = flyerMat * n;\n  if (idObj == 1 || idObj == 2) {\n    col = mix (uCol, bCol, 1. - smoothstep (-0.6, 0., nn.y));\n    if (idObj == 2 && nn.y < 0.)\n       col = mix (bCol, wCol, SmoothBump (-0.8, 0.8, 0.3, qHit.z + 0.28));         \n  } else if (idObj == 3 || idObj == 4) {\n    col = mix (bCol, wCol, SmoothBump (-0.8, 0.8, 0.3, qHit.z));\n  } else if (idObj == 5) {\n    col = mix (bCol, tCol, SmoothBump (-0.6, 0.8, 0.3, qHit.z));\n  } else if (idObj == 6) {\n    col = bCol;\n  } else if (idObj == 7 || idObj == 8) {\n    col = tCol;\n  }\n  if (idObj == 1) {\n    if (qHit.z > 4.5 && abs (qHit.x) > 0.07) idObj = 10;\n  } else if (idObj == 2) {\n    float s = - qHit.z;\n    if (s > 0. && s < 9.) {\n      vec2 ws = vec2 (qHit.y - 0.5, mod (s + 1.5, 1.5) - 0.75);\n      ws *= ws;\n      if (dot (ws, ws) < 0.02) idObj = 10;\n    }\n  }\n  return col * cFac;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  const float eps = 0.01;\n  vec4 col4;\n  vec3 objCol, col, vn;\n  float dstHit, dstGrnd, dstObj, dstPropel, f;\n  int idObjT;\n  vec3 roo = ro;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  wSpan = 12.;\n  engPos = vec3 (0.35 * wSpan, -0.2, -1.5);\n  idObj = 0;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  dstPropel = TransObjRay (ro, rd);\n  if (dstObj < dstPropel) dstPropel = dstFar;\n  float refFac = 1.;\n  if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {\n    float dw = - ro.y / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += eps * rd;\n    dstGrnd = GrndRay (ro, rd);\n    idObj = 0;\n    dstObj = ObjRay (ro, rd);\n    idObjT = idObj;\n    refFac *= 0.6;\n  }\n  bool isGrnd = false;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (ro, vn);\n    if (idObj == 10) objCol = vec3 (0.2) + 0.5 * SkyCol (ro, reflect (rd, vn));\n    float dif = max (dot (vn, sunDir), 0.);\n    col = sunCol * objCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, sunDir) *\n       (dif + 0.5 * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));\n    dstHit = dstObj;\n  } else {\n    vec3 rp = ro + dstGrnd * rd;\n    if (refFac < 1.) dstHit = length (rp - roo);\n    else dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro = rp;\n      isGrnd = true;\n    } else {\n      col = refFac * SkyCol (ro, rd);\n    }\n  }\n  if (isGrnd) {\n    vn = GrndNf (ro, dstHit);\n    col4 = GrndCol (ro, vn);\n    col = col4.xyz * refFac;\n    float dif = max (dot (vn, sunDir), 0.);\n    col *= sunCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * GrndSShadow (ro, sunDir) *\n       (dif + col4.w * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));\n  }\n  if (dstPropel < dstFar) col = 0.7 * col + 0.1 -\n     0.04 * SmoothBump (1.5, 1.7, 0.02, length (qHitTransObj.xy));\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, refFac * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  trkOffset = vec2 (0.);\n  float zmFac = 2.7;\n  tCur = 15. * iTime + 100. * trkOffset.y;\n  sunDir = normalize (vec3 (0.9, 1., 0.4));\n  sunCol = vec3 (1., 0.9, 0.8);\n  vec3 ro, rd, vd, fpF, fpB, vDir;\n  szFac = 0.25;\n  float dt = 1.;\n  fpF = TrackPath (tCur + dt);\n  flyerPos = TrackPath (tCur);\n  fpB = TrackPath (tCur - dt);\n  vec3 vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  vec3 acc = (fpF - 2. * flyerPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  vec3 va = cross (acc, vel) / length (vel);\n  float roll = 12. * length (va);\n  if (va.y < 0.) roll *= -1.;\n  vDir = normalize (vel);\n  float cRl = cos (roll);\n  float sRl = sin (roll);\n  flyerMat = mat3 (cRl, - sRl, 0., sRl, cRl, 0., 0., 0., 1.) *\n     mat3 (vDir.z, 0., vDir.x, 0., 1., 0., - vDir.x, 0., vDir.z);\n  float vuPeriod = 500.;\n  flyerPos.y = 3. + 1.5 * sin (2.5 * tCur / vuPeriod);\n  float lookDir = 2. * mod (floor (tCur / vuPeriod), 2.) - 1.;\n  ro = TrackPath (tCur - 40. * lookDir * (1. -\n     0.8 * abs (sin (pi * mod (tCur, vuPeriod) / vuPeriod))));\n  ro.y = 3. + 0.6 * sin (0.16 * tCur / vuPeriod);\n  vd = flyerPos - ro;\n  vd.y = 0.;\n  vd = normalize (lookDir * vDir + 0.3 * normalize (vd));\n  mat3 scMat = mat3 (vd.z, 0., - vd.x, 0., 1., 0., vd);\n  rd = scMat * normalize (vec3 (uv, zmFac));\n  vec3 col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col = mix (vec3 (0.7), col, pow (max (0., 0.95 - length (uvs * uvs * uvs)), 0.3));\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSXDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 241, 265, 265, 312], [314, 314, 339, 339, 518], [520, 520, 545, 545, 851], [853, 853, 878, 878, 1237], [1239, 1239, 1284, 1284, 1382], [1384, 1384, 1441, 1441, 1524], [1526, 1526, 1559, 1559, 1638], [1640, 1640, 1672, 1672, 1727], [1729, 1729, 1762, 1762, 1835], [2018, 2018, 2044, 2044, 2178], [2180, 2180, 2214, 2214, 2783], [2785, 2785, 2816, 2816, 2998], [3000, 3000, 3031, 3031, 4496], [4498, 4498, 4532, 4532, 5076], [5078, 5078, 5102, 5102, 5337], [5339, 5339, 5371, 5371, 5533], [5535, 5535, 5557, 5557, 5692], [5694, 5694, 5726, 5726, 6301], [6303, 6303, 6341, 6341, 6580], [6651, 6651, 6687, 6687, 6985], [6987, 6987, 7024, 7024, 7261], [7263, 7263, 7290, 7290, 7383], [7385, 7385, 7423, 7423, 7631], [7633, 7633, 7669, 7669, 9681], [9683, 9683, 9705, 9705, 9797], [9799, 9799, 9832, 9832, 10035], [10037, 10037, 10058, 10058, 10303], [10305, 10305, 10342, 10342, 10569], [10571, 10571, 10601, 10601, 12073], [12075, 12075, 12110, 12110, 14278], [14280, 14280, 14337, 14337, 15877]]}
{"id": "4sSXDV", "name": "Box - occlusion clipping", "author": "iq", "description": "Analytic occlusion of triangles, with proper clipping. With clipping, polygons can fall (completely or partially) below the visibility horizon of the receiving point, while still computing analytically correct occlusion. Move mouse to compare.", "tags": ["3d", "occlusion", "analytic"], "likes": 51, "viewed": 5356, "date": "1415867064", "time_retrieved": "2024-06-20T18:14:26.205978", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical ambient occlusion of triangles. Left side of screen, stochastically \n// sampled occlusion. Right side of the screen, analytical solution (no rays casted).\n\n// This shader computes proper clipping. With clipping, polygons can fall (completely \n// or partially) below the visibility horizon of the receiving point, while still \n// computing analytically correct occlusion.\n\n// More info here: http://www.iquilezles.org/www/articles/boxocclusion/boxocclusion.htm\n\n\n// Other analytical occlusion or approximations:\n// \n// Box:                        https://www.shadertoy.com/view/4djXDy\n// Box with horizon clipping:  https://www.shadertoy.com/view/4sSXDV\n// Triangle:                   https://www.shadertoy.com/view/XdjSDy\n// Sphere:                     https://www.shadertoy.com/view/4djSDy\n// Ellipsoid (approximation):  https://www.shadertoy.com/view/MlsSzn\n\n\n// Other Box functions (http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm)\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n// Gradient:         https://www.shadertoy.com/view/wlcXD2\n\n\n//=====================================================\n\nfloat sacos( float x ) { return acos( min(max(x,-1.0),1.0) ); }\n\nvec3 clip( in vec3 a, in vec3 b, in vec4 p )\n{\n    return a - (b-a)*(p.w + dot(p.xyz,a))/dot(p.xyz,(b-a));\n//    return ( a*dot(p.xyz,b) - b*dot(p.xyz,a)  - (b-a)*p.w ) / dot(p.xyz,(b-a));\n}\n\n//-----------------------------------------------------------------------------------------\n\n// fully visible front facing Triangle occlusion\nfloat ftriOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = normalize( v0 - pos );\n    vec3 b = normalize( v1 - pos );\n    vec3 c = normalize( v2 - pos );\n\n    return (dot( nor, normalize( cross(a,b)) ) * sacos( dot(a,b) ) +\n            dot( nor, normalize( cross(b,c)) ) * sacos( dot(b,c) ) +\n            dot( nor, normalize( cross(c,a)) ) * sacos( dot(c,a) ) ) / 6.2831;\n}\n\n\n// fully visible front acing Quad occlusion\nfloat fquadOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    vec3 a = normalize( v0 - pos );\n    vec3 b = normalize( v1 - pos );\n    vec3 c = normalize( v2 - pos );\n    vec3 d = normalize( v3 - pos );\n    \n    return (dot( nor, normalize( cross(a,b)) ) * sacos( dot(a,b) ) +\n            dot( nor, normalize( cross(b,c)) ) * sacos( dot(b,c) ) +\n            dot( nor, normalize( cross(c,d)) ) * sacos( dot(c,d) ) +\n            dot( nor, normalize( cross(d,a)) ) * sacos( dot(d,a) ) ) / 6.2831;\n}\n\n// partially or fully visible, front or back facing Triangle occlusion\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec4 plane )\n{\n    if( dot( v0-pos, cross(v1-v0,v2-v0) ) < 0.0 ) return 0.0;  // back facing\n    \n    float s0 = dot( vec4(v0,1.0), plane );\n    float s1 = dot( vec4(v1,1.0), plane );\n    float s2 = dot( vec4(v2,1.0), plane );\n    \n    float sn = sign(s0) + sign(s1) + sign(s2);\n\n    vec3 c0 = clip( v0, v1, plane );\n    vec3 c1 = clip( v1, v2, plane );\n    vec3 c2 = clip( v2, v0, plane );\n    \n    // 3 (all) vertices above horizon\n    if( sn>2.0 )  \n    {\n        return ftriOcclusion(  pos, nor, v0, v1, v2 );\n    }\n    // 2 vertices above horizon\n    else if( sn>0.0 ) \n    {\n        vec3 pa, pb, pc, pd;\n              if( s0<0.0 )  { pa = c0; pb = v1; pc = v2; pd = c2; }\n        else  if( s1<0.0 )  { pa = c1; pb = v2; pc = v0; pd = c0; }\n        else/*if( s2<0.0 )*/{ pa = c2; pb = v0; pc = v1; pd = c1; }\n        return fquadOcclusion( pos, nor, pa, pb, pc, pd );\n    }\n    // 1 vertex aboce horizon\n    else if( sn>-2.0 ) \n    {\n        vec3 pa, pb, pc;\n              if( s0>0.0 )   { pa = c2; pb = v0; pc = c0; }\n        else  if( s1>0.0 )   { pa = c0; pb = v1; pc = c1; }\n        else/*if( s2>0.0 )*/ { pa = c1; pb = v2; pc = c2; }\n        return ftriOcclusion(  pos, nor, pa, pb, pc );\n    }\n    // zero (no) vertices above horizon\n    \n    return 0.0;\n}\n\n\n//-----------------------------------------------------------------------------------------\n\n\n// Box occlusion (if fully visible)\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    vec4 w = vec4( n, -dot(n,p) ); // clipping plane\n    \n    // 8 verts\n    vec3 v0 = vec3(-1.0,-1.0,-1.0)*rad;\n    vec3 v1 = vec3( 1.0,-1.0,-1.0)*rad;\n    vec3 v2 = vec3(-1.0, 1.0,-1.0)*rad;\n    vec3 v3 = vec3( 1.0, 1.0,-1.0)*rad;\n    vec3 v4 = vec3(-1.0,-1.0, 1.0)*rad;\n    vec3 v5 = vec3( 1.0,-1.0, 1.0)*rad;\n    vec3 v6 = vec3(-1.0, 1.0, 1.0)*rad;\n    vec3 v7 = vec3( 1.0, 1.0, 1.0)*rad;\n    \n\n    // 6 faces    \n    float occ = 0.0;\n    occ += triOcclusion( p, n, v0, v2, v3, w );\n    occ += triOcclusion( p, n, v0, v3, v1, w );\n\n    occ += triOcclusion( p, n, v4, v5, v7, w );\n    occ += triOcclusion( p, n, v4, v7, v6, w );\n    \n    occ += triOcclusion( p, n, v5, v1, v3, w );\n    occ += triOcclusion( p, n, v5, v3, v7, w );\n    \n    occ += triOcclusion( p, n, v0, v4, v6, w );\n    occ += triOcclusion( p, n, v0, v6, v2, w );\n    \n    occ += triOcclusion( p, n, v6, v7, v3, w );\n    occ += triOcclusion( p, n, v6, v3, v2, w );\n    \n    occ += triOcclusion( p, n, v0, v1, v5, w );\n    occ += triOcclusion( p, n, v0, v5, v4, w );\n\n    return occ;\n}\n\n//-----------------------------------------------------------------------------------------\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n//-----------------------------------------------------------------------------------------\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // box animation\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,0.9,0.5)), 0.5*iTime );\n\tmat4 tra = translate( 0.0, 0.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\tvec3 box = vec3(0.2,0.7,2.0) ;\n\n    vec4 rrr = textureLod( iChannel0, (fragCoord.xy)/iChannelResolution[0].xy, 0.0  ).xzyw;\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = 0.0;\n        \n        if( p.x > s )\n        {\n            occ = boxOcclusion( pos, nor, txx, txi, box );\n        }\n        else\n        {\n   \t\t    vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\t    vec3  rv  = normalize( cross( ru, nor ) );\n\n            occ = 0.0;\n            for( int i=0; i<256; i++ )\n            {\n                vec2  aa = hash2( rrr.x + float(i)*203.1 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  dir = vec3( rx*ru + ry*rv + rz*nor );\n                vec4 res = boxIntersect( pos, dir, txx, txi, box );\n                occ += step(0.0,res.x);\n            }\n            occ /= 256.0;\n        }\n\n        col = vec3(1.2);\n        col *= 1.0 - occ;\n    }\n\n    vec4 res = boxIntersect( ro, rd, txx, txi, box );\n    float t2 = res.x;\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.yzw;\n\t\tcol = vec3(1.4);//vec3(1.0,0.85,0.6);\n        col *= 0.6 + 0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSXDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2405, 2462, 2486, 2486, 2525], [2527, 2527, 2573, 2573, 2717], [2812, 2861, 2946, 2946, 3274], [3277, 3321, 3419, 3419, 3856], [3858, 3929, 4028, 4028, 5281], [5378, 5414, 5502, 5502, 6627], [6722, 6790, 6875, 6912, 7430], [7432, 7432, 7479, 7479, 7883], [7885, 7885, 7930, 7930, 8046], [8049, 8049, 8072, 8072, 8142], [8144, 8237, 8277, 8277, 8310], [8312, 8312, 8369, 8369, 10415]]}
{"id": "4sSXWt", "name": "Direct Light using MIS", "author": "koiava", "description": "Left - BSDF sampling\nRight - Light sampling\nCenter - Combination those strategies using [b][url=https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf]MIS[/url][/b](E. Veach, and L. Guibas)\n", "tags": ["mis", "rendering", "realtime", "directlight", "unbiased"], "likes": 100, "viewed": 8510, "date": "1417027955", "time_retrieved": "2024-06-20T18:14:31.400321", "image_code": "//Implementation of Multiple Importance Sampling technique(E.Veach 1995)\n//example shows MIS for direct light calculation\n//Idea behind technique is that every monte-carlo sampling technique has \n//variance and this variance comes from low probability of success.\n//So if you have 2 or more unbiased monte-carlo sampling techniques \n//which gives you different response on same situation you can predict \n//which of those responses contains more variance and weight them\n//correspondingly to decrease overal variance and stay unbiased.\n#define PIXEL_SAMPLES 2\n#define LIGHT_SAMPLES 2\n#define BSDF_SAMPLES 2\n#define FRAME_TIME 0.05\t//for motion blur\n#define IMPORTANCE_SAMPLE_LIGHTS\n#define SHADOWS\n\n//light sampling technique *******************\n#define IMPORTANCE_SAMPLE_LIGHT_SOURCE\n//#define SAMPLE_LIGHT_AREA\n#define SAMPLE_LIGHT_SOLIDANGLE\n//********************************************\n\n#define SHOW_PLANES\n#define SHOW_TEXT\n\n#define GAMMA 2.2\nconst vec3 backgroundColor = vec3( 0.2 );\n\n//used macros and constants\n#define HALF_PI \t\t\t1.5707963\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001\n#define IN_RANGE(x,a,b)\t\t(((x) > (a)) && ((x) < (b)))\n#define EQUAL_FLT(a,b,eps)\t(abs(a-(b))<eps)\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n#ifdef SHOW_TEXT\nstruct Disk {\n    vec2 position_;\n    float radius_innder_;\n    float radius_outter_;\n    float angle_begin_;\n    float angle_end_;\n};\n    \nstruct Box {\n    vec2 position_;\n    vec2 dimensions_;\t//positive\n};\n\nbool pointInBox( vec2 p, Box box ) {\n    if( IN_RANGE( p.x, box.position_.x, box.position_.x + box.dimensions_.x ) &&\n      \tIN_RANGE( p.y, box.position_.y, box.position_.y + box.dimensions_.y ) )\n        return true;\n    \n    return false;\n}\n\nbool pointInDisk( vec2 p, Disk disk ) {\n    Box bbox = Box(disk.position_ - vec2(disk.radius_outter_)*1.01, vec2(disk.radius_outter_)*2.01 );\n    \n    //primitive level culling\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 v = p - disk.position_;\n    \n    float rho;\n    rho = sqrt( v.x*v.x + v.y*v.y );\n    \n    if( !IN_RANGE( rho, disk.radius_innder_, disk.radius_outter_ ) )\n        return false;\n    \n\tfloat theta = atan( v.y, v.x );\n    theta += PI;\n    \n    if( !IN_RANGE( theta, disk.angle_begin_, disk.angle_end_ ) )\n        return false;\n    \n    return true;\n}\n\nvec2 fontDim = vec2(5.0,5.0);\n\nbool is_point_on_B( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_R( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 0.0 ), vec2( 1.0, 1.5 ) ) ) \t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, PI, PI+HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_D( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 1.5 ), vec2( 1.0, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 0.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, PI, PI+HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_F( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 2.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_I( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_M( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 4.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 2.0 ), vec2( 1.0, 3.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 4.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_S( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.5, 4.0 ), vec2( 1.5, 1.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, HALF_PI, HALF_PI+PI ) ) \t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, HALF_PI+PI, TWO_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, 0.0, HALF_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_L( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_G( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 1.5 ), vec2( 1.0, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 3.0 ), vec2( 1.0, 0.5 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.5, 0.0 ), vec2( 1.5, 2.0 ) ) ) \t\t\t\t\t||\n       \tpointInDisk( p, Disk( vec2( 1.5, 1.5 ), 0.5, 1.5, 0.0, HALF_PI ) ) \t||\n      \tpointInDisk( p, Disk( vec2( 1.5, 3.5 ), 0.5, 1.5, PI, TWO_PI ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_H( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 0.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 2.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 1.0, 2.0 ), vec2( 1.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_T( vec2 p ) {\n    if( pointInBox( p, Box( vec2( 1.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t\t||\n       \tpointInBox( p, Box( vec2( 0.0, 4.0 ), vec2( 3.0, 1.0 ) ) ) )\n        return true;\n    return false;\n}\n\nbool is_point_on_BRDF( vec2 p ) {\n    //Object level culling\n    Box bbox = Box( vec2(0.0), vec2(16.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_B( p ) ||\n      \tis_point_on_R( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_D( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_F( p - (offsetVec += vec2(4.0,0.0)) ) ) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool is_point_on_MIS( vec2 p ) {\n    //Object level culling\n    Box bbox = Box( vec2(0.0), vec2(12.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 v = vec2(fontDim.x + 1.0,0.0);\n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_M( p ) ||\n      \tis_point_on_I( p - (offsetVec += vec2(6.0,0.0)) ) ||\n      \tis_point_on_S( p - (offsetVec += vec2(2.0,0.0)) )) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool is_point_on_LIGHT( vec2 p ) {\n    //Object level culling\n    Box bbox = Box( vec2(0.0), vec2(20.0,5.0) );\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 offsetVec = vec2( 0.0 );\n    \n    if( is_point_on_L( p ) ||\n      \tis_point_on_I( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_G( p - (offsetVec += vec2(2.0,0.0)) ) ||\n      \tis_point_on_H( p - (offsetVec += vec2(4.0,0.0)) ) ||\n      \tis_point_on_T( p - (offsetVec += vec2(4.0,0.0)) )) {\n        return true;\n    }\n    \n    return false;\n}\n\n#endif\n\n\n#define MATERIAL_COUNT \t\t8\n#define BSDF_COUNT \t\t\t3\n#define BSDF_R_DIFFUSE \t\t0\n#define BSDF_R_GLOSSY \t\t1\n#define BSDF_R_LIGHT \t\t2\n\n//***********************************\n//sampling types\n#define SAMPLING_LIGHT\t\t\t\t0\n#define SAMPLING_BSDF\t\t\t\t1\n#define SAMPLING_LIGHT_AND_BSDF_MIS\t2\n#define SAMPLING_NONE\t\t\t\t3\nint samplingTechnique;\nfloat split1;\nfloat split2;\n\nvoid initSamplingTechnique(float p) {\n    float k = iMouse.x/iResolution.x;\n    if(iMouse.z<0.0 || iMouse.x==0.0) {\n      \tsplit1 = 0.0;\n        split2 = iResolution.x;  \n    } else {\n        split1 = iMouse.x*k;\n        split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    }\n    \n    if(p < split1-1.0) {\n        samplingTechnique = SAMPLING_BSDF;\n    } else if((p > split1+1.0) && (p < split2-1.0)) {\n        samplingTechnique = SAMPLING_LIGHT_AND_BSDF_MIS;\n    } else if(p > split2+1.0){\n        samplingTechnique = SAMPLING_LIGHT;\n    } else {\n        samplingTechnique = SAMPLING_NONE;\n    }\n}\n//***********************************\n\n#define LIGHT_COUNT (4)\n#define LIGHT_COUNT_INV (0.25)\n#define WALL_COUNT \t(2)\n\n//MIS heuristics *****************************\n#define MIS_HEURISTIC_BALANCE\n//#define MIS_HEURISTIC_POWER\n\nfloat misWeightPower( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\nfloat misWeightBalance( in float a, in float b ) {\n    float ab = a + b;\n    \n    return a / ab;\n}\nfloat misWeight( in float pdfA, in float pdfB ) {\n#ifdef MIS_HEURISTIC_POWER\n    return misWeightPower(pdfA,pdfB);\n#else\n    return misWeightBalance(pdfA,pdfB);\n#endif\n}\n//********************************************\n            \n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n// Color corversion code from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//************************************************************************************\n\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\n// Data structures ****************** \nstruct Sphere { vec3 pos; float radius; float radiusSq; float area; };\nstruct LightSamplingRecord { vec3 w; float d; float pdf; };\nstruct Plane { vec4 abcd; };\nstruct Range { float min_; float max_; };\nstruct Material { vec3 color; float roughness_; int bsdf_; };\nstruct RaySurfaceHit { vec3 N; vec3 E; int mtl_id; int obj_id; float dist; };\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera { mat3 rotate; vec3 pos; float fovV; };\n//***********************************\n    \n// ************ SCENE ***************\nPlane walls[WALL_COUNT];\nSphere lights[LIGHT_COUNT];\n\n#ifdef SHOW_PLANES\n#define PLANE_COUNT (3)\nPlane planes[PLANE_COUNT];\nRange planeZRanges[PLANE_COUNT];\nfloat planeHalfWidth = 2.3;\n#endif\n//***********************************\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool raySphereIntersection( Ray ray, in Sphere sph, out float t ) {\n    t = -1.0;\n\tvec3  ce = ray.origin - sph.pos;\n\tfloat b = dot( ray.dir, ce );\n\tfloat c = dot( ce, ce ) - sph.radiusSq;\n\tfloat h = b*b - c;\n    if( h > 0.0 ) {\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn ( t > 0.0 );\n}\n\nbool rayPlaneIntersection( Ray ray, Plane plane, out float t ){\n    float dotVN = dot( ray.dir, plane.abcd.xyz );\n   \n    if ( abs( dotVN ) < EPSILON ) {\n        return false;\n    }\n    \n\tt = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;\n    \n    return ( t > 0.0 );\n}\n// ***************************************************************************\n\nvoid updateScene(float t) {\n    //init lights\n    t *= 4.0;\n\n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    //1\n    val = a+t*speed;    \n    lights[0].pos = vec3( -2.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //2\n    val = a+t*speed;    \n    lights[1].pos = vec3( -1.1, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //3\n    val = a+t*speed;    \n    lights[2].pos = vec3( 0.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //4\n    val = a+t*speed;    \n    lights[3].pos = vec3( 1.6, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n}\n\nvoid initScene() {\n    //init lights\n    lights[0] = Sphere( vec3( -2.0, 1.4, -5.0 ), 0.05, 0.0025, 0.0314159 );\n\tlights[1] = Sphere( vec3( -1.1, 1.4, -5.0 ), 0.2, 0.04, 0.5026548 );\n\tlights[2] = Sphere( vec3( 0.0, 1.4, -5.0 ), 0.4, 0.16, 2.0106193 );\n\tlights[3] = Sphere( vec3( 1.6, 1.4, -5.0 ), 0.8, 0.64, 8.0424770 );\n    \n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    //1\n    val = a+iTime*speed;    \n    lights[0].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //2\n    val = a+iTime*speed;    \n    lights[1].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //3\n    val = a+iTime*speed;    \n    lights[2].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //4\n    val = a+iTime*speed;    \n    lights[3].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //init walls\n    walls[0].abcd = vec4( normalize(vec3(0.0, 1.0, -EPSILON)), 1.0 );\n    //walls[0].abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    walls[1].abcd = vec4( 0.0, 0.0, 1.0, 6.2 );\n    \n#ifdef SHOW_PLANES\n    //init planes\n    vec3 planeNormal = normalize( vec3( 0.0, 1.0, 1.2 ) );\n    planes[0].abcd = vec4( planeNormal, 3.8 );\n    planeZRanges[0].min_ = -5.8;\n    planeZRanges[0].max_ = -5.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.7 ) );\n    planes[1].abcd = vec4( planeNormal, 2.8 );\n    planeZRanges[1].min_ = -4.8;\n    planeZRanges[1].max_ = -4.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.3 ) );\n    planes[2].abcd = vec4( planeNormal, 1.8 );\n    planeZRanges[2].min_ = -3.8;\n    planeZRanges[2].max_ = -3.0;\n#endif\n}\n\n#define GET_LIGHT_SPHERE_CONST(i) lights[i]\n\n\nMaterial materialLibrary[MATERIAL_COUNT];\n\n#define INIT_MTL(i,bsdf,phongExp,colorVal) materialLibrary[i].bsdf_=bsdf; materialLibrary[i].roughness_=phongExp; materialLibrary[i].color=colorVal;\nvoid initMaterialLibrary()\n{\n    vec3 white = vec3( 1.0, 1.0, 1.0 );\n    vec3 gray = vec3( 0.8, 0.8, 0.8 );\n    \n    //walls\n    INIT_MTL( 0, BSDF_R_DIFFUSE, 0.0, white );\n\t\n    //planes\n    INIT_MTL( 1, BSDF_R_GLOSSY, 4096.0, gray );\n    INIT_MTL( 2, BSDF_R_GLOSSY, 128.0, gray );\n    INIT_MTL( 3, BSDF_R_GLOSSY, 32.0, gray );\n    \n    //lights\n    float totalIntencity = 6.0;\n    float min_x = lights[0].pos.x;\n    float max_x = lights[3].pos.x;\n    float x_range = max_x - min_x;\n    float h1 = ((lights[0].pos.x-min_x)/x_range)*0.6;\n    float h2 = ((lights[1].pos.x-min_x)/x_range)*0.6;\n    float h3 = ((lights[2].pos.x-min_x)/x_range)*0.6;\n    float h4 = ((lights[3].pos.x-min_x)/x_range)*0.6;\n    float s = 0.7;\n    float v1 = 1.0/(FOUR_PI*lights[0].radiusSq);\n    float v2 = 1.0/(FOUR_PI*lights[1].radiusSq);\n    float v3 = 1.0/(FOUR_PI*lights[2].radiusSq);\n    float v4 = 1.0/(FOUR_PI*lights[3].radiusSq);\n    \n    INIT_MTL( 4, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h1, s, v1 ) )*totalIntencity );\n    INIT_MTL( 5, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h2, s, v2 ) )*totalIntencity );\n    INIT_MTL( 6, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h3, s, v3 ) )*totalIntencity );\n    INIT_MTL( 7, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h4, s, v4 ) )*totalIntencity );\n}\n\nMaterial getMaterialFromLibrary( int index ){\n#if __VERSION__ >= 300\n    return materialLibrary[index];\n#else\n    if(index == 0) return materialLibrary[0];\n    if(index == 1) return materialLibrary[1];\n    if(index == 2) return materialLibrary[2];\n    if(index == 3) return materialLibrary[3];\n    if(index == 4) return materialLibrary[4];\n    if(index == 5) return materialLibrary[5];\n    if(index == 6) return materialLibrary[6];\n    return materialLibrary[7];\n#endif\n}\n\nvoid getLightInfo( in int index, out Sphere sphere, out vec3 intensity ) {\n#if __VERSION__ >= 300\n    sphere = lights[index];\n#else\n    if(index == 0) { sphere = lights[0]; } else\n    if(index == 1) { sphere = lights[1]; } else\n    if(index == 2) { sphere = lights[2]; } else\n    \t\t\t   { sphere = lights[3]; }\n#endif\n    intensity = getMaterialFromLibrary(4+index).color;\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) {\n    float sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n\n// BSDF functions *************************************************************\nfloat evaluateBlinn( in  vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n    return (roughness + 2.0) / (8.0 * PI) * pow(cosTheta, roughness);\n}\n\nfloat pdfBlinn(in vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n\tfloat normalizationFactor = (roughness + 1.0) / TWO_PI;\n    return pow( cosTheta, roughness ) * normalizationFactor / (4.0 * dot(E, H));\n}\n\nvec3 sampleBlinn( in vec3 N, in vec3 E, in float roughness, in float r1, in float r2, out float pdf ) {\n    float cosTheta = pow( r1, 1.0/( roughness ) );\n    float phi = r2*TWO_PI;\n    float theta = acos( cosTheta );\n    vec3 H = localToWorld( sphericalToCartesian( 1.0, phi, theta ), N );\n    float dotNH = dot(H,N);\n    vec3 L = reflect( E*(-1.0), H );\n    \n    pdf = pdfBlinn(N, E, L, roughness );\n    \n    return L;\n}\n\nfloat evaluateLambertian( in vec3 N, in vec3 L ) {\n    return INV_PI;\n}\n\nfloat pdfLambertian( in vec3 N, in vec3 L ) {\n    return max(.0, dot( N, L )) * INV_PI;\n}\n\nvec3 sampleLambertian( in vec3 N, in float r1, in float r2, out float pdf ){\n    vec3 L = sampleHemisphereCosWeighted( N, r1, r2 );\n    pdf = pdfLambertian(N, L);\n    return L;\n}\n//*****************************************************************************\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( in vec3 pos, in vec3 frontDir, in vec3 upDir, in float fovV, out Camera dst ) {\n\tvec3 back = normalize( -frontDir );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    dst.rotate[0] = right;\n    dst.rotate[1] = up;\n    dst.rotate[2] = back;\n    dst.fovV = fovV;\n    dst.pos = pos;\n}\n\nRay genRay( in Camera camera, in vec2 pixel ) {\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    Ray ray;\n    ray.origin = camera.pos;\n\tray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\n\treturn ray;\n}\n\n\nbool raySceneIntersection( \tin Ray ray,\n                          \tin float distMin,\n                          \tout RaySurfaceHit hit ) {\n    hit.obj_id = -1;\n    hit.dist = 1000.0;\n    hit.E = ray.dir*(-1.0);\n    \n    //check lights\n    for( int i1=0; i1<LIGHT_COUNT; i1++ ){\n        float dist;\n        if( raySphereIntersection( ray, lights[i1], dist ) && (dist>distMin) && ( dist < hit.dist ) ) {\n            hit.dist = dist;\n          \tvec3 hitpos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = (hitpos - lights[i1].pos)*(1.0/lights[i1].radius);\n    \t\thit.mtl_id = 4 + i1;\n            hit.obj_id = i1;\n        }\n    }\n    \n    //check walls\n    for( int i=0; i<WALL_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, walls[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            hit.dist = dist;\n//            hit.pos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = walls[i].abcd.xyz;\n    \t\thit.mtl_id = 0;\n            hit.obj_id = LIGHT_COUNT + i;\n        }\n    }\n    \n#ifdef SHOW_PLANES\n    //check planes\n    for( int i=0; i<PLANE_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, planes[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            vec3 hitPos = ray.origin + ray.dir*dist;\n            if( (hitPos.z < planeZRanges[i].max_ ) && (hitPos.z > planeZRanges[i].min_) && (hitPos.x < planeHalfWidth ) && (hitPos.x > -planeHalfWidth ) ) {\n                hit.dist = dist;\n//                hit.pos = hitPos;\n                hit.N = planes[i].abcd.xyz;\n                hit.mtl_id = 1+i;\n                hit.obj_id = LIGHT_COUNT + WALL_COUNT + i;\n            }        \n        }\n    }\n#endif\n    \n    return ( hit.obj_id != -1 );\n}\n\nvoid sampleSphericalLight( in vec3 x, in Sphere sphere, float Xi1, float Xi2, out LightSamplingRecord sampleRec ) {\n#ifdef SAMPLE_LIGHT_AREA\n    vec3 n = randomDirection( Xi1, Xi2 );\n    vec3 p = sphere.pos + n*sphere.radius;\n    float pdfA = 1.0/sphere.area;\n    \n    vec3 Wi = p - x;\n    \n    float d2 = dot(Wi,Wi);\n    sampleRec.d = sqrt(d2);\n    sampleRec.w = Wi/sampleRec.d; \n    float cosTheta = max( 0.0, dot(n, -sampleRec.w) );\n    sampleRec.pdf = PdfAtoW( pdfA, d2, cosTheta );\n#else\n    vec3 w = sphere.pos - x;\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = sphere.radiusSq / dc_2;\n\t\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    \tfloat cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n        float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    \tfloat sin_theta = sqrt(sin_theta_2);\n        sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    \tsampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n        //Calculate intersection distance\n\t\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n        sampleRec.d = dc*cos_theta - sqrt(sphere.radiusSq - dc_2*sin_theta_2);\n    } else {\n        sampleRec.w = randomDirection( Xi1, Xi2 );\n        sampleRec.pdf = 1.0/FOUR_PI;\n    \traySphereIntersection( Ray(x,sampleRec.w), sphere, sampleRec.d );\n    }\n#endif\n}\n\nfloat sphericalLightSamplingPdf( in vec3 x, in vec3 wi, float d, in vec3 n1, in Sphere sphere ) {\n#ifdef SAMPLE_LIGHT_SOLIDANGLE\n    float solidangle;\n    vec3 w = sphere.pos - x;\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = clamp( sphere.radiusSq / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n#else\n    float lightPdfA = 1.0/sphere.area;\n    float cosTheta1 = max( 0.0, dot( n1, -wi ) );\n    return PdfAtoW( lightPdfA, d*d, cosTheta1 );\n#endif\n}\n\nfloat lightChoosingPdf(in vec3 x, in int lightId) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 / (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] /= cdf[LIGHT_COUNT-1];\n    }\n    \n    return cdf[lightId] - (lightId==0? 0.0 : cdf[lightId-1]);\n#else\n   \treturn 1.0/float(LIGHT_COUNT);\n#endif\n}  \t\n\nint chooseOneLight(in vec3 x, in float Xi, out float pdf) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 / (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] /= cdf[LIGHT_COUNT-1];\n    }\n    \n    int id = 0;\n    for(int i=0; i<LIGHT_COUNT; i++) {\n        if(Xi < cdf[i]) {\n        \tid = i;\n            pdf = cdf[i] - (i==0? 0.0 : cdf[i-1]);\n            break;\n        }\n    }\n    \n    return id;\n#else\n   \tpdf = 1.0/float(LIGHT_COUNT);\n    return int(Xi*float(LIGHT_COUNT));\n#endif\n}\n\nvec3 sampleBSDF( in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS ) {\n    vec3 Lo = vec3( 0.0 );\n    float bsdfSamplingPdf = 1.0/float(BSDF_SAMPLES);\n    vec3 n = hit.N * vec3((dot(hit.E, hit.N) < 0.0) ? -1.0 : 1.0);\n    \n    for( int i=0; i<BSDF_SAMPLES; i++ ) {\n        //Generate direction proportional to bsdf\n        vec3 bsdfDir;\n        float bsdfPdfW;\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(BSDF_SAMPLES);\n        Xi2 = strataSize * (float(i) + Xi2);\n        float brdf;\n        \n        if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n            bsdfDir = sampleBlinn( n, hit.E, mtl.roughness_, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateBlinn( n, hit.E, bsdfDir, mtl.roughness_ );\n        } else {\n            bsdfDir = sampleLambertian( n, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateLambertian( n, bsdfDir );\n        }\n        \n        float dotNWi = dot( bsdfDir, n );\n\n        //Continue if sampled direction is under surface\n        if( (dotNWi > 0.0) && (bsdfPdfW > EPSILON) ){\n            //calculate light visibility\n            RaySurfaceHit newHit;\n            if( raySceneIntersection( Ray( x, bsdfDir ), EPSILON, newHit ) && (newHit.obj_id < LIGHT_COUNT) ) {\n                //Get hit light Info\n                vec3 Li;\n                Sphere lightSphere;\n                getLightInfo( newHit.obj_id, lightSphere, Li );\n\n                //Read light info\n                float weight = 1.0;\n\t\t\t\tfloat lightPdfW;\n                if ( useMIS ) {\n                    lightPdfW = sphericalLightSamplingPdf( x, bsdfDir, newHit.dist, newHit.N, lightSphere );\n                    lightPdfW *= lightChoosingPdf(x, newHit.obj_id);\n                    weight = misWeight( bsdfPdfW, lightPdfW );\n                }\n\n                Lo += brdf*dotNWi*(Li/bsdfPdfW)*weight;\n            }\n        }\n    }\n\n    return Lo*bsdfSamplingPdf;\n}     \n\nvec3 sampleLight( \tin vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS ) {\n    vec3 Lo = vec3( 0.0 );\t//outgoing radiance\n    float lightSamplingPdf = 1.0/float(LIGHT_SAMPLES);\n   \n    for( int i=0; i<LIGHT_SAMPLES; i++ ) {\n        //select light uniformly\n        float Xi = rnd();\n        float strataSize = 1.0 / float(LIGHT_SAMPLES);\n        Xi = strataSize * (float(i) + Xi);\n        float lightPickPdf;\n        int lightId = chooseOneLight(x, Xi, lightPickPdf);\n\n        //Read light info\n        vec3 Li;\t\t\t\t//incomming radiance\n        Sphere lightSphere;\n        getLightInfo( lightId, lightSphere, Li );\n        \n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        LightSamplingRecord sampleRec;\n        sampleSphericalLight( x, lightSphere, Xi1, Xi2, sampleRec );\n        \n        float lightPdfW = lightPickPdf*sampleRec.pdf;\n        vec3 Wi = sampleRec.w;\n        \n        float dotNWi = dot(Wi,hit.N);\n\n        if ( (dotNWi > 0.0) && (lightPdfW > EPSILON) ) {\n            Ray shadowRay = Ray( x, Wi );\n            RaySurfaceHit newHit;\n            bool visible = true;\n#ifdef SHADOWS\n            visible = ( raySceneIntersection( shadowRay, EPSILON, newHit ) && EQUAL_FLT(newHit.dist,sampleRec.d,EPSILON) );\n#endif\n            if(visible) {\n                float brdf;\n    \t\t\tfloat brdfPdfW;\t\t\t//pdf of choosing Wi with 'bsdf sampling' technique\n                \n                if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n                    brdf = evaluateBlinn( hit.N, hit.E, Wi, mtl.roughness_ );\n                    brdfPdfW = pdfBlinn(hit.N, hit.E, Wi, mtl.roughness_ );\t//sampling Pdf matches brdf\n                } else {\n                    brdf = evaluateLambertian( hit.N, Wi );\n                    brdfPdfW = pdfLambertian( hit.N, Wi );\t//sampling Pdf matches brdf\n                }\n\n                float weight = 1.0;\n                if( useMIS ) {\n                    weight = misWeight( lightPdfW, brdfPdfW );\n                }\n                \n                Lo += ( Li * brdf * weight * dotNWi ) / lightPdfW;\n            }\n        }\n    }\n    \n    return Lo*lightSamplingPdf;\n}\n\nvec3 Radiance( in Ray ray ) {\n    RaySurfaceHit hit;\n    if( raySceneIntersection( ray, 0.0, hit ) ) {\n    \tMaterial mtl = getMaterialFromLibrary( hit.mtl_id );\n\n        vec3 f, Le;\n\n        if( mtl.bsdf_ == BSDF_R_LIGHT ) {\n            Le = mtl.color;\n            f = vec3( 1.0, 1.0, 1.0 );\n        } else {\n            Le = vec3( 0.0 );\n            f = mtl.color;\n        }\n        \n        vec3 hitPos = ray.origin + ray.dir*hit.dist;\n            \n        vec3 directLight = vec3(0.0);\n        if( samplingTechnique == SAMPLING_LIGHT ) {\n            directLight += sampleLight( hitPos, hit, mtl, false );\n        } else if( samplingTechnique == SAMPLING_BSDF ) {\n            directLight += sampleBSDF( hitPos, hit, mtl, false );\n        } else {\n            directLight += sampleBSDF( hitPos, hit, mtl, true );\n            directLight += sampleLight( hitPos, hit, mtl, true );\n        }\n\n        return Le + f * directLight;\n    }\n\n    return backgroundColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n\tfloat sinTime = sin(iTime*0.2);\n    \n    Camera camera;\n    initScene();\n    initMaterialLibrary();\n    \n    vec2 splitterPos = iMouse.xy;\n    if ( splitterPos.x == 0.0 && splitterPos.y == 0.0 ) {\n        splitterPos = iResolution.xy*0.5;\n    }\n    initSamplingTechnique((iMouse.x==0.0)?iResolution.x*0.5:fragCoord.x);\n    \n    if(samplingTechnique == SAMPLING_NONE) {\n        fragColor = vec4( 1.0 );\n        return;\n    }\n\t\n    Ray ray;\n\tvec3 accumulatedColor = vec3( 0.0 );\n\tfor(int si=0; si<PIXEL_SAMPLES; ++si ){\n        //stratified sampling for t\n        float tprev = iTime;\n        float tnext = iTime+FRAME_TIME;\n        float tStrata = 1.0/float(PIXEL_SAMPLES);\n        float tnorm = tStrata*(float(si)+rnd());\n        float t = mix(tprev,tnext,tnorm);\n        \n        //for object motion blur\n        updateScene(t);\n        \n        //update camera for camera motion blur\n        vec3 cameraPos = vec3( 0.0, 1.0 + sin(t*0.45), 3.0 + sin(t*0.4)*3.0 );\n    \tvec3 cameraTarget = vec3( sin(t*0.4)*0.3, 0.0, -5.0 );\n    \tinitCamera( cameraPos, cameraTarget - cameraPos, vec3( 0.0, 1.0, 0.0 ), radians(45.0), camera );\n        \n        vec2 subPixelCoord = vec2(rnd(), rnd());\n        vec2 screenCoord = fragCoord.xy + subPixelCoord;\n        ray = genRay( camera, screenCoord );\n        \n        accumulatedColor += Radiance( ray );\n        \n#ifdef SHOW_TEXT\n        float fontScale = 3.2;\n        vec2 offset_brdf = vec2( 2.0*fontScale, 0.0 )*fontScale;\n        vec2 offset_mis = vec2( 1.5*fontScale, 0.0 )*fontScale;\n        vec2 offset_light = vec2( 2.0*fontScale, 0.0 )*fontScale;\n\n        if( is_point_on_BRDF( (screenCoord.xy - vec2(split1*0.5,iResolution.y*0.03) + offset_brdf )*(1.0/fontScale) ) ) {\n            float val = clamp(split1/iResolution.x, 0.0, 0.9 );\n            accumulatedColor += vec3( val ); \n        }\n        \n        if( is_point_on_MIS( (screenCoord.xy - vec2((split1+split2)*0.5,iResolution.y*0.03) + offset_mis )*(1.0/fontScale) ) ) {\n            float val = clamp((split2-split1)/(0.6*iResolution.x), 0.0, 0.9 );\n            accumulatedColor += vec3( val );\n        }\n        \n        if( is_point_on_LIGHT( (screenCoord.xy - vec2((split2+iResolution.x)*0.5,iResolution.y*0.03) + offset_light )*(1.0/fontScale) )) {\n            float val = clamp((iResolution.x-split2)/iResolution.x, 0.0, 0.9 );\n            accumulatedColor += vec3( val );\n        }\n#endif\n\t}\n\t\n\t//devide to sample count\n\taccumulatedColor = accumulatedColor*(1.0/float(PIXEL_SAMPLES));\n\t\n\t//gamma correction\n    accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n    \n\tfragColor = vec4( accumulatedColor,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSXWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[8191, 8418, 8455, 8455, 9015], [9212, 9243, 9291, 9291, 9381], [9382, 9382, 9432, 9432, 9480], [9481, 9481, 9530, 9530, 9650], [9711, 9808, 9821, 9821, 9864], [9904, 9991, 10013, 10013, 10182], [10272, 10390, 10450, 10450, 10543], [10545, 10596, 10656, 10656, 10796], [11659, 11738, 11805, 11805, 12013], [12015, 12015, 12078, 12078, 12296], [12297, 12377, 12404, 12422, 13204], [13206, 13206, 13224, 13242, 14971], [15211, 15211, 15239, 15239, 16463], [16465, 16465, 16510, 16510, 16936], [16938, 16938, 17012, 17012, 17311], [17313, 17395, 17473, 17473, 17581], [17583, 17583, 17673, 17673, 17823], [17825, 17825, 17874, 17874, 18074], [18076, 18076, 18131, 18131, 18231], [18233, 18233, 18306, 18306, 18414], [18416, 18416, 18491, 18491, 18634], [18636, 18636, 18688, 18688, 18816], [18899, 18979, 19056, 19056, 19190], [19192, 19192, 19262, 19262, 19464], [19466, 19466, 19569, 19569, 19888], [19890, 19890, 19940, 19940, 19961], [19963, 19963, 20008, 20008, 20052], [20054, 20054, 20130, 20130, 20232], [20314, 20386, 20482, 20482, 20720], [20722, 20722, 20769, 20769, 21022], [21025, 21025, 21162, 21162, 22729], [22731, 22731, 22846, 22846, 24228], [24230, 24230, 24327, 24327, 25001], [25003, 25003, 25054, 25054, 25538], [25543, 25543, 25602, 25602, 26266], [26268, 26268, 26353, 26353, 28183], [28190, 28190, 28277, 28277, 30314], [30316, 30316, 30345, 30345, 31280], [31282, 31282, 31339, 31339, 34078]]}
{"id": "ld2SRt", "name": "missmoothstep", "author": "yastero", "description": "random missmoothstep", "tags": ["random"], "likes": 2, "viewed": 99, "date": "1415123974", "time_retrieved": "2024-06-20T18:14:31.400321", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float t = iTime;\n\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n  float w, z, i, m, n, o, j = 0.0;\n\n  z = 1.0 - pow(p.x,0.4);\n\n  i = pow(pow(p.x,2.0)+pow(p.y,2.0),0.5);\n\n  m = 0.5 + (sin(t)*0.5);\n\n  n = 0.5 + (sin(t/7.0)*0.5);\n\n  o = smoothstep(m, n, z);\n\n  j = smoothstep(m, n, i);\n\n  w = mix(o, j, 0.5);\n\n  fragColor = vec4(w, w, w, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2SRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 412]]}
{"id": "ld2SW3", "name": "A Pattern Emerges", "author": "okro", "description": "Takes a few seconds.", "tags": ["dots"], "likes": 1, "viewed": 141, "date": "1416719065", "time_retrieved": "2024-06-20T18:14:31.400321", "image_code": "#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 70; i++) {\n        vec2 flake = vec2(cos(time*float(i)/6.)/7., abs(sin(time+float(i))));\n        uv.x -= (float(i))/1000.;\n        col.b +=  1.0 - smoothstep(.03, .031, length(uv - flake));\n        col.b += (1.0 - smoothstep(0.03, .08, length(uv - flake))) / 8.;\n        col.r += (1.0 - smoothstep(0., .031, length(uv - flake))) / 1.5;\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2SW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 19, 76, 76, 586]]}
{"id": "ldBSDd", "name": "Wind of change", "author": "FatumR", "description": "Background reacts on the song.", "tags": ["procedural", "2d", "noise", "fractals", "smoke", "wind"], "likes": 43, "viewed": 1929, "date": "1417172940", "time_retrieved": "2024-06-20T18:14:31.406342", "image_code": "/*\n * Copyright 2014 Roman Bobniev (FatumR)\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define OCTAVES  8.0\n\n#define LIVE_SMOKE 1\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Rough Value noise implementation\nfloat valueNoiseSimple(vec2 vl) {\n   float minStep = 1.0 ;\n\n   vec2 grid = floor(vl);\n   vec2 gridPnt1 = grid;\n   vec2 gridPnt2 = vec2(grid.x, grid.y + minStep);\n   vec2 gridPnt3 = vec2(grid.x + minStep, grid.y);\n   vec2 gridPnt4 = vec2(gridPnt3.x, gridPnt2.y);\n\n    float s = rand2(grid);\n    float t = rand2(gridPnt3);\n    float u = rand2(gridPnt2);\n    float v = rand2(gridPnt4);\n    \n    float x1 = smoothstep(0., 1., fract(vl.x));\n    float interpX1 = mix(s, t, x1);\n    float interpX2 = mix(u, v, x1);\n    \n    float y = smoothstep(0., 1., fract(vl.y));\n    float interpY = mix(interpX1, interpX2, y);\n    \n    return interpY;\n}\n\nfloat getLowFreqs()\n{\n    const int NUM_FREQS = 32;\n    /* Close to the spectrum of the voice frequencies for this song. */\n    const float lowStart = 0.65;\n    const float lowEnd = 0.75;\n    float result = 0.0;\n    \n    for (int i = 0; i < NUM_FREQS; i++)\n    {\n        result += texture(iChannel0,\n                            vec2(lowStart + (lowEnd - lowStart)*float(i)/float(NUM_FREQS - 1),\n                                 0.25)).x;\n    }\n\n    return smoothstep(0.0, 1.0, (result / float(NUM_FREQS)) * 2.);\n}\n\nfloat fractalNoise(vec2 vl) {\n    float persistance = 2.0;\n    float amplitude = 0.5;\n    float rez = 0.0;\n    vec2 p = vl;\n    \n    for (float i = 0.0; i < OCTAVES; i++) {\n        rez += amplitude * valueNoiseSimple(p);\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez;\n}\n\nfloat complexFBM(vec2 p) {\n    float sound = getLowFreqs();\n    float slow = iTime / 2.5;\n    float fast = iTime / .5;\n    vec2 offset1 = vec2(slow  , 0.); // Main front\n    vec2 offset2 = vec2(sin(fast )* 0.1, 0.); // sub fronts\n\n    return \n#if LIVE_SMOKE\n        (1. + sound) * \n#endif\n        fractalNoise( p + offset1 + fractalNoise(\n            \tp + fractalNoise(\n                \tp + 2. * fractalNoise(p - offset2)\n            \t)\n        \t)\n        );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    vec3 blueColor = vec3(0.529411765, 0.807843137, 0.980392157);\n    vec3 orangeColor2 = vec3(0.509803922, 0.203921569, 0.015686275);\n    \n    vec3 rez = mix(orangeColor2, blueColor, complexFBM(uv));\n    \n    fragColor = vec4(rez, 1.0);\n    \n}", "image_inputs": [{"id": "ld23Dm", "previewfilepath": "https://soundcloud.com/user7393752/scorpions-wind-of-change", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/user7393752/scorpions-wind-of-change", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "apache-2.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 654, 674, 674, 745], [747, 747, 768, 768, 839], [841, 877, 910, 910, 1511], [1513, 1513, 1534, 1534, 2026], [2028, 2028, 2057, 2057, 2332], [2334, 2334, 2360, 2360, 2794], [2797, 2797, 2854, 2854, 3148]]}
{"id": "ldBSRd", "name": "LSD 2D fx", "author": "caiwan", "description": "Hey kids, wanna buy some LSD?\nI've been collecting effects around here, and I came up with this.", "tags": ["2d", "plasma", "perlin", "fx", "procerural", "yiq"], "likes": 45, "viewed": 4273, "date": "1414857303", "time_retrieved": "2024-06-20T18:14:31.764103", "image_code": "#define PI 3.14159\n\nvec2 random2(vec2 c) { float j = 4906.0*sin(dot(c,vec2(169.7, 5.8))); vec2 r; r.x = fract(512.0*j); j *= .125; r.y = fract(512.0*j);return r-0.5;}\n\nconst float F2 =  0.3660254;\nconst float G2 = -0.2113249;\n\nfloat simplex2d(vec2 p){vec2 s = floor(p + (p.x+p.y)*F2),x = p - s - (s.x+s.y)*G2; float e = step(0.0, x.x-x.y); vec2 i1 = vec2(e, 1.0-e),  x1 = x - i1 - G2, x2 = x - 1.0 - 2.0*G2; vec3 w, d; w.x = dot(x, x); w.y = dot(x1, x1); w.z = dot(x2, x2); w = max(0.5 - w, 0.0); d.x = dot(random2(s + 0.0), x); d.y = dot(random2(s +  i1), x1); d.z = dot(random2(s + 1.0), x2); w *= w; w *= w; d *= w; return dot(d, vec3(70.0));}\n\nvec3 rgb2yiq(vec3 color){return color * mat3(0.299,0.587,0.114,0.596,-0.274,-0.321,0.211,-0.523,0.311);}\nvec3 yiq2rgb(vec3 color){return color * mat3(1.,0.956,0.621,1,-0.272,-0.647,1.,-1.107,1.705);}\n\nvec3 convertRGB443quant(vec3 color){ vec3 out0 = mod(color,1./16.); out0.b = mod(color.b, 1./8.); return out0;}\nvec3 convertRGB443(vec3 color){return color-convertRGB443quant(color);}\n\nvec2 sincos( float x ){return vec2(sin(x), cos(x));}\nvec2 rotate2d(vec2 uv, float phi){vec2 t = sincos(phi); return vec2(uv.x*t.y-uv.y*t.x, uv.x*t.x+uv.y*t.y);}\nvec3 rotate3d(vec3 p, vec3 v, float phi){ v = normalize(v); vec2 t = sincos(-phi); float s = t.x, c = t.y, x =-v.x, y =-v.y, z =-v.z; mat4 M = mat4(x*x*(1.-c)+c,x*y*(1.-c)-z*s,x*z*(1.-c)+y*s,0.,y*x*(1.-c)+z*s,y*y*(1.-c)+c,y*z*(1.-c)-x*s,0.,z*x*(1.-c)-y*s,z*y*(1.-c)+x*s,z*z*(1.-c)+c,0.,0.,0.,0.,1.);return (vec4(p,1.)*M).xyz;}\n\nfloat varazslat(vec2 position, float time){\n\tfloat color = 0.0;\n\tfloat t = 2.*time;\n\tcolor += sin(position.x*cos(t/10.0)*20.0 )+cos(position.x*cos(t/15.)*10.0 );\n\tcolor += sin(position.y*sin(t/ 5.0)*15.0 )+cos(position.x*sin(t/25.)*20.0 );\n\tcolor += sin(position.x*sin(t/10.0)*  .2 )+sin(position.y*sin(t/35.)*10.);\n\tcolor *= sin(t/10.)*.5;\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    uv = (uv-.5)*2.;\n   \n    vec3 vlsd = vec3(0,1,0);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    \n    vec2 \n        v0 = .75 * sincos(.3457 * iTime + .3423) - simplex2d(uv * .917),\n        v1 = .75 * sincos(.7435 * iTime + .4565) - simplex2d(uv * .521), \n        v2 = .75 * sincos(.5345 * iTime + .3434) - simplex2d(uv * .759);\n    \n    vec3 color = vec3(dot(uv-v0, vlsd.xy),dot(uv-v1, vlsd.yz),dot(uv-v2, vlsd.zx));\n    \n    color *= .2 + 2.5*vec3(\n    \t(16.*simplex2d(uv+v0) + 8.*simplex2d((uv+v0)*2.) + 4.*simplex2d((uv+v0)*4.) + 2.*simplex2d((uv+v0)*8.) + simplex2d((v0+uv)*16.))/32.,\n        (16.*simplex2d(uv+v1) + 8.*simplex2d((uv+v1)*2.) + 4.*simplex2d((uv+v1)*4.) + 2.*simplex2d((uv+v1)*8.) + simplex2d((v1+uv)*16.))/32.,\n        (16.*simplex2d(uv+v2) + 8.*simplex2d((uv+v2)*2.) + 4.*simplex2d((uv+v2)*4.) + 2.*simplex2d((uv+v2)*8.) + simplex2d((v2+uv)*16.))/32.\n    );\n    \n    color = yiq2rgb(color);\n    \n    color *= 1.- .25* vec3(\n    \tvarazslat(uv *.25, iTime + .5),\n        varazslat(uv * .7, iTime + .2),\n        varazslat(uv * .4, iTime + .7)\n    );\n    \n    \n    //fragColor = vec4(convertRGB443(color),1.0);\n    \n    \n    color = vec3(pow(color.r, 0.45), pow(color.g, 0.45), pow(color.b, 0.45));\n\n\tfragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[20, 20, 42, 42, 166], [227, 227, 251, 251, 646], [648, 648, 673, 673, 752], [753, 753, 778, 778, 847], [849, 849, 885, 885, 960], [961, 961, 992, 992, 1032], [1034, 1034, 1057, 1057, 1086], [1087, 1087, 1121, 1121, 1194], [1195, 1195, 1236, 1236, 1521], [1523, 1523, 1566, 1566, 1882], [1884, 1884, 1941, 1941, 3345]]}
{"id": "ldBXDd", "name": "Crease Machine", "author": "timeiskey", "description": "based on IQ's TOOT\n      https://www.youtube.com/watch?v=0ifChJ0nJfM\n\nIt generates infinite butts", "tags": ["2d"], "likes": 0, "viewed": 122, "date": "1417140511", "time_retrieved": "2024-06-20T18:14:31.764103", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    \n    \n    \n    //shape position\n    vec2 shapeCenter = vec2( 0.5, 0.5);\n    //distance from pixel to shape center\n    vec2 distanceToShape = p - shapeCenter;\n    \n    //color vector\n    vec3 col = vec3( 0.0, 1.0, 1.0 );\n    \n    //shape radius\n    float shapeRadius = 0.2 + 0.1*cos( atan(distanceToShape.x, distanceToShape.y)\n                                      *iTime );\n    //shape sharpness (smaller is sharper)\n    float sharpnessMod = 0.008;\n\n    col *=  smoothstep( shapeRadius, shapeRadius+sharpnessMod, length(distanceToShape));\n    col = vec3( 1.0, 1.0, 1.0) - col;\n    \n    //finally changes the color\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBXDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 751]]}
{"id": "ldBXDG", "name": "Simplex Cells", "author": "daeken", "description": "Simplex noise cells", "tags": ["noise", "shaderforth"], "likes": 1, "viewed": 156, "date": "1415386225", "time_retrieved": "2024-06-20T18:14:32.054776", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\niResolution frag->position =p\n\np time .37 * sin 2 ** 3 * abs .5 + * time 2 / sin 2 * rotate-2d [ time .17 * time .37 * ] 5 * + snoise-2d =v\n[ v 100 * time 3.7 * + sin 180 * 180 + v abs v neg 17 * time 1.4 * + sin v * abs ] hsv->rgb ->fragcolor\n*/\n\nvec2 rotate_2d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec3 hsv_rgb(vec3 hsv) {\n\treturn mix(vec3(1., 1., 1.), clamp(abs(mod(hsv.x / 60. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.), hsv.y) * hsv.z;\n}\nvec3 permute(vec3 x) {\n\treturn mod((x * 34. + 1.) * x, 289.);\n}\nfloat snoise_2d(vec2 v) {\n\tvec4 C = vec4(.211324865405187, .366025403784439, -.577350269189626, .024390243902439);\n\tvec2 i = floor(dot(v, C.yy) + v);\n\tvec2 x0 = v - i + dot(i, C.xx);\n\tvec2 i1 = x0.x > x0.y ? vec2(1., 0.) : vec2(0., 1.);\n\tvec4 x12 = x0.xyxy + C.xxzz - vec4(i1, 0., 0.);\n\ti = mod(i, 289.);\n\tvec3 p = permute(permute(vec3(0., i1.y, 1.) + i.y) + i.x + vec3(0., i1.x, 1.));\n\tvec3 m = max(.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\n\tm = m * m * m * m;\n\tvec3 x = 2. * fract(p * C.www) - 1.;\n\tvec3 h = abs(x) - .5;\n\tvec3 ox = floor(x + .5);\n\tvec3 a0 = x - ox;\n\tm = (1.79284291400159 - .85373472095314 * (a0 * a0 + h * h)) * m;\n\treturn dot(m, vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw)) * 130.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tfloat v = snoise_2d(rotate_2d(p * (abs(pow(sin(iTime * .37), 2.) * 3.) + .5), sin(iTime / 2.) * 2.) + vec2(iTime * .17, iTime * .37) * 5.);\n\tfragColor = vec4(hsv_rgb(vec3(sin(v * 100. + iTime * 3.7) * 180. + 180., abs(v), abs(sin(-v * 17. + iTime * 1.4) * v))), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBXDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 413, 446, 446, 544], [545, 545, 569, 569, 688], [689, 689, 711, 711, 752], [753, 753, 778, 778, 1505], [1506, 1506, 1563, 1563, 1928]]}
{"id": "ldjSDG", "name": "gradation", "author": "torutoru", "description": "gradation test", "tags": ["2d"], "likes": 3, "viewed": 142, "date": "1415653212", "time_retrieved": "2024-06-20T18:14:32.055005", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    for (float i = 1.; i < 11.; i ++){\n        if (uv.x > (i - 1.) / 10. && uv.x < i / 10.) {\n            uv.y -= 1. * abs(cos(time + i / 10.)) * abs(sin(time + i / 2.));\n                fragColor = vec4(uv.y, abs(cos(time * 0.5)), 1.0-uv.y, uv.x);\n        } \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjSDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 391]]}
{"id": "ldjSRd", "name": "Circules", "author": "Optimus", "description": "I was bored.", "tags": ["2d", "line", "circle"], "likes": 2, "viewed": 153, "date": "1415129634", "time_retrieved": "2024-06-20T18:14:32.182299", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float time = iTime;\n    vec3 resolution = iResolution;\n\n\tvec2 p = ( fragCoord.xy / resolution.x ) - vec2(0.5, 0.5 * (resolution.y / resolution.x));\n\tfloat c = 0.0;\n\n\tfor (int i=0; i<16; i++)\n\t{\n\t\tfloat a = abs(length(p) - 0.2 + sin(time + float(i*i)*p.x*p.y + p.x*p.y) * 0.2);\n\t\tc += 1.0 - pow(a, 0.1);\n\t\tif (c < 0.5) c = 0.0;\n\t}\n\n\tvec4 bgColor = 1.0 - vec4(abs(p.x*p.y*8.0));\n\tfragColor = bgColor * 0.2 + vec4(c*p.x, c*p.y, c*p.x*p.y, 1.0) * 2.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 512]]}
{"id": "ldjXD3", "name": "Texture flow III", "author": "iq", "description": "Integrating uv coordinates given a noise flow texture.", "tags": ["2d", "texture"], "likes": 39, "viewed": 3031, "date": "1416782906", "time_retrieved": "2024-06-20T18:14:32.188358", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec4 texture0( in vec2 x )\n{\n    //return texture( iChannel0, x );\n    vec2 res = iChannelResolution[0].xy;\n    vec2 u = x*res - 0.5;\n    vec2 p = floor(u);\n    vec2 f = fract(u);\n    f = f*f*(3.0-2.0*f);    \n    vec4 a = texture( iChannel0, (p+vec2(0.5,0.5))/res, -64.0 );\n\tvec4 b = texture( iChannel0, (p+vec2(1.5,0.5))/res, -64.0 );\n\tvec4 c = texture( iChannel0, (p+vec2(0.5,1.5))/res, -64.0 );\n\tvec4 d = texture( iChannel0, (p+vec2(1.5,1.5))/res, -64.0 );\n    return mix(mix(a,b,f.x), mix(c,d,f.x),f.y);\n}\n    \nvec2 flow( vec2 uv, in mat2 m )\n{\n    for( int i=0; i<50; i++ )\n        uv += 0.00015 * m * (-1.0+2.0*texture0(0.5*uv).xz);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // animate\n    float an = 0.5*iTime;\n    float co = cos(an);\n    float si = sin(an);\n    mat2  ma = mat2( co, -si, si, co );\n\n    // orbit, distance and distance gradient\n    vec2 uva = 0.05*(p + vec2(1.0,0.0)/iResolution.xy);\n\tvec2 uvb = 0.05*(p + vec2(0.0,1.0)/iResolution.xy);\n\tvec2 uvc = 0.05*p;\n\tvec2 nuva = flow( uva, ma );\n\tvec2 nuvb = flow( uvb, ma );\n\tvec2 nuvc = flow( uvc, ma );\n    float fa = length(nuva-uva)*95.0;\n    float fb = length(nuvb-uvb)*95.0;\n    float fc = length(nuvc-uvc)*95.0;\n    vec3 nor = normalize( vec3((fa-fc)*iResolution.x,1.0,(fb-fc)*iResolution.y ) );\n\n    // material\n  \tvec3 col = 0.2 + 0.8*texture(iChannel1, 50.0*nuvc).xyz;\n    col *= 1.0 + 0.15*nor;\n    float ss, sw;\n    ss = sin(6000.0*nuvc.x); sw = fwidth(ss); col *= 0.5 + 0.5*smoothstep(-sw,sw,ss+0.95);\n    ss = sin(6000.0*nuvc.y); sw = fwidth(ss); col *= 0.5 + 0.5*smoothstep(-sw,sw,ss+0.95);\n    \n    // ilumination\n    vec3 lig = normalize( vec3( 1.0,1.0,-0.4 ) );\n    col *= vec3(0.7,0.8,0.9) + vec3(0.6,0.5,0.4)*clamp( dot(nor,lig), 0.0, 1.0 );    \n    col += 0.40*pow( nor.y, 4.0 );\n    col += 0.15*pow( nor.y, 2.0 );\n    col *= sqrt( fc*fc*fc );\n \n    // postpro\n    col = 1.5*pow( col+vec3(0.0,0.0,0.015), vec3(0.6,0.8,1.0) );\n    col *= 0.5 + 0.5*sqrt( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y) );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjXD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 125, 153, 191, 634], [640, 640, 673, 673, 780], [782, 782, 839, 839, 2220]]}
{"id": "ldSSWK", "name": "my test", "author": "sliz", "description": "test", "tags": ["test"], "likes": 1, "viewed": 119, "date": "1415854385", "time_retrieved": "2024-06-20T18:14:32.351939", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t//fragColor = vec4(vec3(sin(iTime)),1.0);\n        \n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    float t = iTime*1000.0;\n    \n    float adx2 = (sin(t/1000.0+3.0) + 1.0) * 200.0;\n    float ady2 = (sin(t/1000.0+.5) + 1.0) * 200.0;\n    float adx3 = (sin(t/1000.0+.8) + 1.0) * 200.0;\n    float ady3 = (sin(t/1000.0+1.5) + 1.0) * 200.0;\n\n    float d = sqrt(x*x+y*y)+t/12.0;\n    float v = sin(d/4.0);\n    \n    d = sqrt((x-adx2) * (x-adx2) + (y-ady2) * (y-ady2))+t/16.0;\n    float v2 = sin(d / 5.0);\n    d = sqrt((x-adx3) * (x-adx3) + (y-ady3) * (y-ady3))+t/34.0;\n    float v3 = sin(d / 4.0);\n    v = ((v + 1.0) * 2.0 + (v2 + 1.0) * 3.0 + (v3 + 1.0) * 2.0) / 14.0; \n    fragColor = vec4(vec3(v),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSSWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 192, 858]]}
{"id": "ldSXRt", "name": "boksit", "author": "janneasdf", "description": "lots of boxes", "tags": ["3d", "raymarching"], "likes": 2, "viewed": 141, "date": "1414802654", "time_retrieved": "2024-06-20T18:14:32.351939", "image_code": "vec3 ambientLight;\nvec3 dirLightColor = vec3(0.5, 0.5, 0.5);\nvec3 dirLightDir;\nfloat c = 2.0;\n\nfloat dBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.07;\n}\n\nfloat map(vec3 p)\n{\n    vec3 b = vec3(0.5);\n    vec3 q = vec3(\n        mod(p.x, c) - 0.5 * c,\n        mod(p.y, c) - 0.5 * c,\n        mod(p.z, c) - 0.5 * c);\n    return dBox(q, b);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float threshold = 0.001;\n\tvec2 t = vec2(0.0, threshold);\n    vec3 n = vec3(map(pos + t.yxx) - map(pos - t.yxx),\n           \t  map(pos + t.xyx) - map(pos - t.xyx),\n              map(pos + t.xxy) - map(pos - t.xxy));\n    return normalize(n);\n}\n\nbool getDepth(vec3 rayPos, vec3 rayDir, inout float depth)\n{\n    const int max_iters = 1000;\n    float phase = (.5 + .5 * sin(iTime));\n    float eps = mix(0.001, 0.5, phase);\n    vec3 p = rayPos;\n    float d;\n    float d_total = 0.0;\n    for (int i = 0; i < max_iters; ++i)\n    {\n        d = map(p);\n        d_total += d;\n        p += d * rayDir;\n        if (d < eps)\n            break;\n    }\n    depth = d_total;\n    return d < eps;\n}\n\nbool intersect(vec3 rayPos, vec3 rayDir, inout vec3 color, inout vec3 normal)\n{\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    \n    float depth;\n    bool hit = getDepth(rayPos, rayDir, depth);\n    \n    normal = vec3(0.0);\n    \n    if (hit)\n    {\n        normal = getNormal(rayPos + depth * rayDir);\n        vec3 kd = vec3(0.1, 0.1, 0.1);\n        vec3 ka = ambientLight;\n        color = ka + kd * max(dot(normal, -dirLightDir), 0.0);\n        return true;\n    }\n    else\n    {\n\t    color = bg;\n        normal = vec3(0.0);\n        return false;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ambientLight = vec3(.2 + .2 * sin(iTime), .2 + .2 * cos(iTime), 0.2) * .2;\n\tdirLightDir = normalize(vec3(sin(iTime), -0.3, 1.0));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    uv -= .5;\n    uv.x = aspect * uv.x;\n    \n    vec3 camPos = vec3(2.0, 1.5, -2.) * iTime;\n    vec3 camTarget = vec3(0.);\n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = normalize(cross(camDir, camRight));\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    float zNear = 10.0;\n    rayPos += zNear * rayDir;\n    \n    vec3 c;\n    vec3 n;\n    bool hit = intersect(rayPos, rayDir, c, n);\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSXRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[95, 95, 123, 123, 225], [227, 227, 246, 246, 408], [410, 410, 436, 436, 682], [684, 684, 744, 744, 1119], [1121, 1121, 1200, 1200, 1667], [1669, 1669, 1726, 1726, 2536]]}
{"id": "ldSXzt", "name": "2d fx collection", "author": "caiwan", "description": "2D Effect library of code snippets\nSeparately on github in a gists: https://gist.github.com/caiwan/0261ed2d42467d29eddb", "tags": ["codesnippets"], "likes": 3, "viewed": 298, "date": "1414855634", "time_retrieved": "2024-06-20T18:14:34.613141", "image_code": "#define PI 3.14159\n\n/** \n\t*** EFFEKTGYUJTEMENY ***\n\tMindent egy sorba, hogy ne zavarjon\n*/\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** KALEIDOSCOPE ***\nvec2 kaleidoscope( vec2 uv, float n, float bias ) { float angle = PI / n; float r = length( uv ); float a = atan( uv.y, uv.x ) / angle; a = mix( fract( a ), 1.0 - fract( a ), mod( floor( a ), 2.0 ) ) * angle; return vec2( cos( a ), sin( a ) ) * r;}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** PERLIN ZAJ ***\n/// 2D random\nvec2 random2(vec2 c) { float j = 4906.0*sin(dot(c,vec2(169.7, 5.8))); vec2 r; r.x = fract(512.0*j); j *= .125; r.y = fract(512.0*j);return r-0.5;}\n\n/// 1D random / hash\nfloat hash(float f){ return fract(56546.235423 * sin(f*235345.345345));}\n\nconst float F2 =  0.3660254;\nconst float G2 = -0.2113249;\n\n/// simplex 2D zaj; perlin zaj egy frekvenciajahoz tartozo ertekek\nfloat simplex2d(vec2 p){vec2 s = floor(p + (p.x+p.y)*F2),x = p - s - (s.x+s.y)*G2; float e = step(0.0, x.x-x.y); vec2 i1 = vec2(e, 1.0-e),  x1 = x - i1 - G2, x2 = x - 1.0 - 2.0*G2; vec3 w, d; w.x = dot(x, x); w.y = dot(x1, x1); w.z = dot(x2, x2); w = max(0.5 - w, 0.0); d.x = dot(random2(s + 0.0), x); d.y = dot(random2(s +  i1), x1); d.z = dot(random2(s + 1.0), x2); w *= w; w *= w; d *= w; return dot(d, vec3(70.0));}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** COLOR TRANSFORMATION ***\n//http://beesbuzz.biz/code/hsv_color_transforms.php\n\nvec3 rgb2yiq(vec3 color){return color * mat3(0.299,0.587,0.114,0.596,-0.274,-0.321,0.211,-0.523,0.311);}\nvec3 yiq2rgb(vec3 color){return color * mat3(1.,0.956,0.621,1,-0.272,-0.647,1.,-1.107,1.705);}\n\n// Direkt HSV transzformacio \nvec3 hsvTransform(vec3 color, vec3 hsv){float  _h = hsv.x, _s = hsv.y, _v = hsv.y; float  VSU = _v*_s*cos(_h*PI/180.), VSW = _v*_s*sin(_h*PI/180.), rr = (.299*_v+.701*VSU+.168*VSW)*color.x + (.587*_v-.587*VSU+.330*VSW)*color.y + (.114*_v-.114*VSU-.497*VSW)*color.z, gg = (.299*_v-.299*VSU-.328*VSW)*color.x + (.587*_v+.413*VSU+.035*VSW)*color.y + (.114*_v-.114*VSU+.292*VSW)*color.z, bb = (.299*_v-.300*VSU+1.25*VSW)*color.x + (.587*_v-.588*VSU-1.05*VSW)*color.y + (.114*_v+.886*VSU-.203*VSW)*color.z; return vec3(rr,gg,bb); }\n\nvec3 convertRGB4quant(vec3 color){ vec3 out0 = mod(color,1./16.); return out0;}\nvec3 convertRGB4(vec3 color){return color-convertRGB4quant(color);}\n\nvec3 convertRGB443quant(vec3 color){ vec3 out0 = mod(color,1./16.); out0.b = mod(color.b, 1./8.); return out0;}\nvec3 convertRGB443(vec3 color){return color-convertRGB443quant(color);}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); rgb = rgb*rgb*(3.0-2.0*rgb); return c.z * mix( vec3(1.0), rgb, c.y);}\nvec3 hsv2rgb_trigonometric( in vec3 c ){vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);return c.z * mix( vec3(1.0), rgb, c.y);}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** TUNNEL ***\nvec3 tunnel_uvw(vec2 pos){ float u = length(pos); return vec3 (u, atan(pos.y, pos.x), 1.0/u);}\nvec3 tunnel_coord(vec2 p, float frekv, float radius, mat4 mat){\n    vec3 o = mat[3].xzy, d = normalize(mat[2].xyz*radius + mat[0].xyz*p.x + mat[1].xyz*p.y);\n    float D=1./(d.y*d.y+d.z*d.z), a=(o.y*d.y+o.z*d.z)*D, b=(o.y*o.y+o.z*o.z-36.)*D, t=-a-sqrt(a*a-b); o+=t*d;// t = sqrt(a*a-b);\n    return vec3(o.x, atan(o.y,o.z)*(frekv/PI), t);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** TRANSZFORMACIOK ***\nvec2 sincos( float x ){return vec2(sin(x), cos(x));}\nvec2 rotate2d(vec2 uv, float phi){vec2 t = sincos(phi); return vec2(uv.x*t.y-uv.y*t.x, uv.x*t.x+uv.y*t.y);}\nvec3 rotate3d(vec3 p, vec3 v, float phi){ v = normalize(v); vec2 t = sincos(-phi); float s = t.x, c = t.y, x =-v.x, y =-v.y, z =-v.z; mat4 M = mat4(x*x*(1.-c)+c,x*y*(1.-c)-z*s,x*z*(1.-c)+y*s,0.,y*x*(1.-c)+z*s,y*y*(1.-c)+c,y*z*(1.-c)-x*s,0.,z*x*(1.-c)-y*s,z*y*(1.-c)+x*s,z*z*(1.-c)+c,0.,0.,0.,0.,1.);return (vec4(p,1.)*M).xyz;}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** 2D TEXTURA FX ***\nfloat checker(vec2 p){ return mod(floor(p.x)+floor(p.y), 2.);}\nfloat stripe(float p, float h){return (abs(1.-mod(p,2.)) < h) ? 1. : 0.;}\nfloat gradient(float p){return abs(1.-mod(p,2.));}\n\nfloat IsGridLine(vec2 fragCoord, float rows)\n{\n    float sizeOfSquares = iResolution.y / rows;\n\tvec2 vPixelsPerGridSquare = vec2(sizeOfSquares, sizeOfSquares);\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\tvec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);\n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\treturn fIsGridLine;\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** DEMOS ***\n/**\n************************************************\nFustscroll\nPerlin noise + scroll fel\n************************************************\n*/\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float k = (1.-uv.y);\n\tvec2 sh;\n    sh.x = (uv.x - .5) * (k/3.);\n    sh.y = -iTime * .5 - k*k*k;\n    \n    // + ide jon nulla sebesseggel a backbuffer eltolva\n    float a = simplex2d(2.*uv + 3.*sh);\n    float b = simplex2d(4.*uv + 9.*sh) / 4.;\n    float c = simplex2d(8.*uv + 13.*sh) / 8.;\n    float d = simplex2d(16.*uv + 21.*sh)/ 16.;\n    float e = simplex2d(32.*uv + 27.*sh)/ 32.;\n    \n    // + itt kell kivonni a backbufferbol\n    float f = .5 + a + b + c + d + e + .45*uv.y;\n    \n    fragColor.rgb = vec3(1.-(f*f));\n    fragColor.a = 1.;\n\n}\n#endif\n\n/************************************************\nFustscroll 2\nBased on https://www.shadertoy.com/view/Xsl3zN\n************************************************\n*/\n#if 1\n\nfloat fbm(vec2 n){\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 9; i++) {\n\t\ttotal += simplex2d(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float k = (1.-uv.y);\n\tvec2 sh;\n    sh.x = (uv.x - .5) * (k/3.);\n    sh.y = -iTime * .5 - k*k*k;\n       \n    float t = iTime*.2; // let globally control the time\n\tfloat q = fbm(uv+t * 0.1);\n    vec2 r = vec2(fbm(uv + q+ t * 0.7 - uv.x - uv.y), fbm(uv + q -t * 0.4));\n\t\n    fragColor.rgb = hsv2rgb_smooth(vec3(.6, .9, 1.) - .5*vec3(.2*sin(r.x), r.x, r.y));\n    fragColor.a = 1.;\n    \n}\n#endif\n\n/**\n************************************************\nGLICCS 1\n************************************************\n*/\n\n/**\n\tMegbasz-effekt\n\tTY Pasy, finom volt.\n\t@param uv koordinata\n\t@param color bemeno szin\n\t@return megbaszott szin\n*/\n\nvec4 megbasz(vec2 uv, vec4 color);\n\n#define ITERATIONS 16\n\n/**\n\tVizszintes eltolas + HSV eltolas random\n\tv1\n\t@param uv texturakoordinata\n\t@param shift szegmens y-eltolasa\n\t@param seed random seed\n\t@param speed random valtas sebessege\n\t@param segment segmens meret\n\t@return HSV transform (xyz) es vizszintes eltolas (w)\n*/\nvec4 distort(vec2 uv, float shift, float seed, float speed, float segment){\n\tvec4 transform = vec4(0.,2.,1.,0.);\n\tif (seed>0.){\n\t\tfloat \tf = hash(sin(uv.y)), dir, s, p, v, t = speed * iTime;\n\t\t\n\t\tv = hash(ceil(segment*uv.y));\n\t\tdir = hash(seed*v)>.5?-1.:1.;\n\t\tp = hash(fract(v + .0005*floor(t) ) );\n\t\ts = fract(seed*uv.y+dir*shift); \n\t\t\n\t\tif(s-v>0.1)\n\t\t\ttransform = vec4(\n\t\t\t\t360. *hash(v*v*p*p),\t\t\t\t// H\n\t\t\t\t.1 + 2.* hash(seed*sin(v*v*p*p)),\t// S\n\t\t\t\t.1 + 2.* hash(seed*cos(v*v*p*p)),\t// V\n\t\t\t\tdir*(.1 * v * p));\t\t\t\t\t// X-shift\n\t\telse if (s-v<-0.175)\n\t\t\ttransform = vec4(\n\t\t\t\t180. *v*v*p*p,\t\t\t\t\t\t// H\n\t\t\t\t.1 + 2.* hash(sin(v*v*p*p)),\t\t// S\n\t\t\t\t.1 + 2.* hash(cos(v*v*p*p)),\t\t// V\n\t\t\t\tdir*(.1 * v * p) + p*uv.x);\t\t\t// X-shift\n\t}\n\treturn transform;\n}\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\t\n\tvec4 trans;\n\tfor (int i=0; i<ITERATIONS; i++){\n\t\ttrans += distort(uv, .5*iTime + float(i), 2., 10., 1.+float(i)) / float(ITERATIONS);\n\t}\n\t\n\tvec4 color = texture(iChannel0, uv + .02 * vec2(trans.w,0));\n\tfloat f = .5+.5*rgb2hsv(color.rgb).x;\n\t\n\tcolor.rgb = hsvTransform(color.rgb, trans.rgb);\n\t\n    fragColor = megbasz(uv, color);\n}\n\n#endif \n\n\n/**\n************************************************\nTUNNEL\n************************************************\n*/\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy / iResolution.y);\n\tfloat ar = (iResolution.x / iResolution.y); \n    uv = uv-vec2(ar*.5,.5);\n    \n    float time = iTime;\n    \n    // ----\n\tvec3 eltolas = vec3(-5.*time, .05*sin(2.*time), .05*cos(2.*time));\n    vec3 nezet   = vec3(10., .5-.05*sin(time), 0);\n    vec3 irany   = vec3(0,.05*cos(time),.05*sin(time));\n    \n    vec3 cp=eltolas, ct=cp+nezet,\t// cp = szem, ct = center\n        cd=normalize(ct-cp),  /*nezet irany*/\n        cr=normalize(cross(cd,irany)), /*nezet 'elfordulas';*/\n        cu=cross(cr,cd);\t/*up vektor*/\n\n    mat4 m = mat4( vec4(cr, 0.), vec4(cu, 0.), vec4(cd, 0.), vec4(eltolas, 1.));\n    // ----\n    \n\tvec3 tunnel_pos = tunnel_coord(uv, 5., 1.5, m);\n    \n    float a = (stripe(tunnel_pos.y-.3, .15) + stripe(tunnel_pos.y-.5, .25) + stripe(tunnel_pos.y-.4, .2)) * .333;\n    float b = (stripe(tunnel_pos.y+.3, .15) + stripe(tunnel_pos.y+.5, .25) + stripe(tunnel_pos.y+.4, .2)) * .333;\n    \n    float z = -tunnel_pos.z*.051 - 1.; z=z/(z+1.); clamp(z,0.,1.);\n    \n    vec3 ca0 = mix(vec3(.082,.110,.388), vec3(.243,.275,.573), z);\n    vec3 ca1 = mix(vec3(.541,.565,.784), vec3(.541,.565,.784), z);\n    \n\tvec3 cb0 = mix(vec3(  1.,.847,.639), vec3( 1. ,.949,.639), z);\n    vec3 cb1 = mix(vec3(.561,.345,.051), vec3(.561,.490,.051), z);\n    \n    vec3 color = mix(cb0, cb1, b); if (a>b) color = mix(ca0, ca1, a);\n    \n    //color = vec3(a+b) * .5;\n    \n    fragColor = vec4(color,1.);\n}\n#endif\n\n/**\n************************************************\nRGB 4 es RGB 443 konverter + gerimotor\n************************************************\n*/\n\nvec3 gerimotor(vec2 uv){ return texture(iChannel0, uv-mod(uv,1./vec2(128,64))).rgb; }\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfragColor.rgb = convertRGB443(gerimotor(uv)).rgb;\n\tfragColor.a = 1.;\n\t\t\n}\n#endif\n\n/**\n************************************************\nMEGBASZ TV CSIK\n************************************************\n*/\n\nvec4 megbasz(vec2 uv, vec4 color) \n{ \n\t//fragColor = texture(texture, gl_TexCoord[0].st); \n    vec4 res = color;\n\tfloat x      = uv.s * iResolution.x; \n\tfloat y      = uv.t * iResolution.y; \n\tfloat modx2  = mod(x,       2.0); \n\tfloat mody3  = mod(y,       3.0); \n\tfloat mody13 = mod(y - 1.0, 3.0); \n\tfloat mody23 = mod(y - 2.0, 3.0); \n\tif (modx2 < 1.0 && mody3  < 1.0 ) res *= vec4(1.0,0.0,0.0,1.0);  \n\tif (modx2 > 1.0 && mody3  < 1.0 ) res *= vec4(0.0,1.0,0.0,1.0); \n\tif (modx2 < 1.0 && mody13 < 1.0 ) res *= vec4(0.0,0.0,1.0,1.0);  \n\tif (modx2 > 1.0 && mody13 < 1.0 ) res *= vec4(1.0,0.0,0.0,1.0); \n\tif (modx2 < 1.0 && mody23 < 1.0 ) res *= vec4(0.0,1.0,0.0,1.0);  \n\tif (modx2 > 1.0 && mody23 < 1.0 ) res *= vec4(0.0,0.0,1.0,1.0);\n    \n    return res;\n} \n\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\t\n    vec4 color = texture(iChannel0, uv );\n    \n\tfragColor = megbasz(uv,color);\n}\n#endif \n\n/**\n************************************************\nlofasz szinatmenet meg baszo gululo geci fasszal\n************************************************\n*/\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    uv = rotate2d(uv, iTime);\n    \n    vec3 c00 = vec3(180., 231., 251.) / 255.; //#b4e7fb\n    vec3 c01 = vec3(157., 172., 216.) / 255.; //#9dacd8\n    vec3 c02 = vec3(049., 130., 163.) / 255.; //#3182a3\n    vec3 c03 = vec3(119., 126., 198.) / 255.; //#777ebd\n    \n    vec3 cv = mix(c00, c01, length(uv-vec2(0.,1.)));\n    vec3 ch = mix(c02, c03, uv.x);\n    \n    vec3 color = mix(ch, cv, dot(uv, vec2(-1.,1.)));\n    \n    fragColor = vec4(color,1.0);\n}\n#endif\n\n/**\n************************************************\nHSV Transzform proba \n************************************************\n*/\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = (uv-.5)*2.;\n    vec2 duv = vec2(1./256.); vec3 yiq;\n    \n    yiq = vec3(cos(iTime), uv); vec3 colorM = yiq2rgb(yiq);\n\n    yiq = vec3(cos(iTime), uv+vec2( 0., 1.)*duv); vec3 colorU = convertRGB443quant(yiq2rgb(yiq));\n    yiq = vec3(cos(iTime), uv+vec2( 0.,-1.)*duv); vec3 colorD = convertRGB443quant(yiq2rgb(yiq));\n    \n    //yiq = vec3(cos(iTime), uv+vec2( 1., 1.)*duv); vec3 colorUL = convertRGB443quant(yiq2rgb(yiq));\n    //yiq = vec3(cos(iTime), uv+vec2( 1.,-1.)*duv); vec3 colorDL = convertRGB443quant(yiq2rgb(yiq));\n    \n\t//yiq = vec3(cos(iTime), uv+vec2(-1., 1.)*duv); vec3 colorUR = convertRGB443quant(yiq2rgb(yiq));\n    //yiq = vec3(cos(iTime), uv+vec2(-1.,-1.)*duv); vec3 colorDR = convertRGB443quant(yiq2rgb(yiq));\n    \n\tyiq = vec3(cos(iTime), uv+vec2( 1., 0.)*duv); vec3 colorL = convertRGB443quant(yiq2rgb(yiq));\n    yiq = vec3(cos(iTime), uv+vec2(-1., 0.)*duv); vec3 colorR = convertRGB443quant(yiq2rgb(yiq));\n    \n    //vec3 color = convertRGB443(colorM + (colorU + colorD + colorL + colorR + colorUR + colorDR + colorUL + colorDL) / 16.);\n    vec3 color = convertRGB443(\n        colorM + \n        /*(7./16.)* */colorU + \n        /*(3./16.)* */colorD + \n        /*(5./16.)* */colorL + \n        /*(1./16.)* */colorR);\n    \n    /** */\n    // mind a negy siknyegyedre visszaadja az UV-t jol\n    // erre itt vigyazni kell, mert ertekes cucc \n    #if 0\n    vec3 color = vec3(abs(uv), dot(uv+.5,normalize(vec2(1.,1.))));\n    #endif\n    /** */\n    fragColor = vec4(color,1.0);\n}\n#endif \n\n\n/**\n************************************************\nLSD\n************************************************\n*/\n\nfloat varazslat(vec2 position, float time){\n\tfloat color = 0.0;\n\tfloat t = 2.*time;\n\tcolor += sin(position.x*cos(t/10.0)*20.0 )+cos(position.x*cos(t/15.)*10.0 );\n\tcolor += sin(position.y*sin(t/ 5.0)*15.0 )+cos(position.x*sin(t/25.)*20.0 );\n\tcolor += sin(position.x*sin(t/10.0)*  .2 )+sin(position.y*sin(t/35.)*10.);\n\tcolor *= sin(t/10.)*.5;\n\t\n\treturn color;\n}\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    uv = (uv-.5)*2.;\n   \n    vec3 vlsd = vec3(0,1,0);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    \n    vec2 \n        v0 = .75 * sincos(.3457 * iTime + .3423) - simplex2d(uv * .917),\n        v1 = .75 * sincos(.7435 * iTime + .4565) - simplex2d(uv * .521), \n        v2 = .75 * sincos(.5345 * iTime + .3434) - simplex2d(uv * .759);\n    \n    vec3 color = vec3(dot(uv-v0, vlsd.xy),dot(uv-v1, vlsd.yz),dot(uv-v2, vlsd.zx));\n    \n    color = yiq2rgb(color);\n    \n    color *= 1.- .25* vec3(\n    \tvarazslat(uv *.25, iTime + .5),\n        varazslat(uv * .7, iTime + .2),\n        varazslat(uv * .4, iTime + .7)\n    );\n    \n    fragColor = vec4(color,1.0);\n}\n#endif \n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    uv = (uv-.5)*2.;\n   \n    vec3 vlsd = vec3(0,1,0);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    \n    vec2 \n        v0 = .75 * sincos(.3457 * iTime + .3423) - simplex2d(uv * .917),\n        v1 = .75 * sincos(.7435 * iTime + .4565) - simplex2d(uv * .521), \n        v2 = .75 * sincos(.5345 * iTime + .3434) - simplex2d(uv * .759);\n    \n    vec3 color = vec3(dot(uv-v0, vlsd.xy),dot(uv-v1, vlsd.yz),dot(uv-v2, vlsd.zx));\n    \n    color *= .2 + 2.5*vec3(\n    \t(16.*simplex2d(uv+v0) + 8.*simplex2d((uv+v0)*2.) + 4.*simplex2d((uv+v0)*4.) + 2.*simplex2d((uv+v0)*8.) + simplex2d((v0+uv)*16.))/32.,\n        (16.*simplex2d(uv+v1) + 8.*simplex2d((uv+v1)*2.) + 4.*simplex2d((uv+v1)*4.) + 2.*simplex2d((uv+v1)*8.) + simplex2d((v1+uv)*16.))/32.,\n        (16.*simplex2d(uv+v2) + 8.*simplex2d((uv+v2)*2.) + 4.*simplex2d((uv+v2)*4.) + 2.*simplex2d((uv+v2)*8.) + simplex2d((v2+uv)*16.))/32.\n    );\n    \n    color = yiq2rgb(color);\n    /*\n    color *= 1.- .25* vec3(\n    \tvarazslat(uv *.25, iTime + .5),\n        varazslat(uv * .7, iTime + .2),\n        varazslat(uv * .4, iTime + .7)\n    );\n    */\n    //fragColor = vec4(convertRGB443(color),1.0);\n    fragColor = vec4(color, 1.0);\n}\n#endif \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSXzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[92, 256, 307, 307, 504], [506, 682, 704, 704, 828], [830, 851, 871, 871, 923], [984, 1051, 1075, 1075, 1470], [1472, 1697, 1722, 1722, 1801], [1802, 1802, 1827, 1827, 1896], [1898, 1928, 1968, 1968, 2454], [2456, 2456, 2490, 2490, 2535], [2536, 2536, 2565, 2565, 2603], [2605, 2605, 2641, 2641, 2716], [2717, 2717, 2748, 2748, 2788], [2790, 2823, 2856, 2856, 3004], [3005, 3005, 3045, 3045, 3151], [3154, 3312, 3338, 3338, 3406], [3407, 3407, 3470, 3470, 3745], [3748, 3915, 3938, 3938, 3967], [3968, 3968, 4002, 4002, 4075], [4076, 4076, 4117, 4117, 4402], [4405, 4570, 4592, 4592, 4632], [4633, 4633, 4664, 4664, 4706], [4707, 4707, 4731, 4731, 4757], [4759, 4759, 4805, 4805, 5256], [7355, 7618, 7693, 7693, 8366], [10434, 10579, 10603, 10603, 10664], [10857, 10979, 11015, 11069, 11734], [14402, 14512, 14555, 14555, 14871]]}
{"id": "lsBSRd", "name": "sunflower (256 chars)", "author": "FabriceNeyret2", "description": "NB: try to uncomment line 6 and reset time :-)", "tags": ["sunflower", "short"], "likes": 26, "viewed": 1762, "date": "1414868453", "time_retrieved": "2024-06-20T18:14:34.613141", "image_code": "#define N 20.\nvoid mainImage( out vec4 o, vec2 u ) {\n    u = (u+u-(o.xy=iResolution.xy))/o.y;\n    //vec2 R=iResolution.xy;\n    //u = (u+u -R)/R.y;\n    float t = iTime,\n          r = length(u), a = atan(u.y,u.x);\n    // r *= 1.-.1*(.5+.5*cos(2.*r*t));\n    float i = floor(r*N);\n    a *= floor(pow(128.,i/N)); \t a += 10.*t+123.34*i;\n    r +=  (.5+.5*cos(a)) / N;    r = floor(N*r)/N;\n\to = (1.-r)*vec4(3,2,1,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[14, 14, 52, 52, 410]]}
{"id": "lsBSW3", "name": "Thick orbits", "author": "guil", "description": "test", "tags": ["2d", "fractal", "orbit"], "likes": 3, "viewed": 134, "date": "1416416204", "time_retrieved": "2024-06-20T18:14:34.613141", "image_code": "/* public domain */\n\n#define N 40\n\n\nvec2 cinv( vec2 z)  { float d = dot(z,z); return vec2( z.x, -z.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\n\nvec2 p;\nvec2 f( vec2 x ){float t = cos(0.1*iTime);return csqr(x+t*cinv(x))+p;}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tp = 2.*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 z=p;\n\tfloat zoom = 1.2;\n\tfloat thick = 0.30;\n\tfor ( int i = 0; i < N; i++ ){\n\t\tz = f(z);\n\t\tfloat ot = abs(dot(z+p,cinv(z-p)));\n\t\tif ( ot > 1.0 ){\n\t\t\tot = 1.0/ot;\n\t\t\tz *=  ot;\t\t\t\n\t\t}\n\t\tif ( ot > 1.0-thick ){\n\t\t\tfloat c = float(i)/float(N)*5.0;\n\t\t\tvec3 color = vec3(cos(c*1.0), cos(c*2.0), cos(c*4.0))*.5+.5;\n\t\t\tfloat shade = 1.0-(1.0-ot)/thick;\n\t\t\tfragColor = vec4( color*shade, 1.0 );\n\t\t\treturn;\n\t\t}\n\t\tz *= zoom;\n        \n\t}\n\tfragColor = vec4( 0.0,0.0,0.0, 1.0 );\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBSW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 36, 57, 57, 109], [110, 110, 131, 131, 177], [187, 187, 204, 204, 257], [261, 261, 318, 318, 850]]}
{"id": "lsBSzt", "name": "The wall, it breathes", "author": "ErnstHot", "description": "Inspired by Amiga demos like Keftales by Kefrens and Total Triple Trouble by Rebels.", "tags": ["procedural", "2d", "psychedelic", "trippy", "keftales"], "likes": 6, "viewed": 502, "date": "1414849705", "time_retrieved": "2024-06-20T18:14:34.618871", "image_code": "// Ugly code ahead. Yolo.\n\nconst float Pi = 3.14159;\nconst float Pi2 = Pi * 2.0;\nconst float hPi = Pi * 0.5;\nvec3 ct[9]; \n\nvec3 lookup(const float pos)\n{\n    float p = fract(pos) * 7.999;\n    int i = int(p);\n    float f = fract(p);\n    vec3 res = vec3(0.0);\n    vec3 a = vec3(0.0);\n    vec3 b = vec3(0.0);\n    \n    // This used to be 8 * \"if\". There if no else.\n    \n    if (i < 4)\n    {\n        if (i < 2)\n        {\n            if (i == 0)\n            {\n                a = ct[0]; b = ct[1];    \n            }\n            else\n            {\n                a = ct[1]; b = ct[2];\n            }            \n        }\n        else\n        {\n            if (i == 2)\n            {\n                a = ct[2]; b = ct[3];    \n            }\n            else\n            {\n                a = ct[3]; b = ct[4];\n            }            \n        }    \n    }\n    else\n    {\n\t    if (i < 6)\n        {\n            if (i == 4)\n            {\n                a = ct[4]; b = ct[5];    \n            }\n            else\n            {\n                a = ct[5]; b = ct[6];\n            }            \n        }\n        else\n        {\n            if (i == 6)\n            {\n                a = ct[6]; b = ct[7];    \n            }\n            else\n            {\n                a = ct[7]; b = ct[8];\n            }            \n        }    \n    }\n    \n\treturn mix(a, b, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// Alternative colors.\n/*\n\tct[0] = vec3(0.5, 0.0, 0.3);\n\tct[1] = vec3(1.0, 0.4, 0.0);\n\tct[2] = vec3(1.0, 0.0, 0.3);\n\tct[3] = vec3(1.0, 0.6, 0.0);\n\tct[4] = vec3(1.0, 0.0, 0.6);\n\tct[5] = vec3(1.0, 0.8, 0.0);\n\tct[6] = vec3(1.0, 0.4, 0.0);\n\tct[7] = vec3(1.0, 0.6, 0.0);\n\tct[8] = vec3(0.5, 0.0, 0.3);\n*/  \n    \n\tct[0] = vec3(0.5, 0.0, 0.3);\n\tct[1] = vec3(0.3, 0.1, 0.0);\n\tct[2] = vec3(1.0, 0.3, 0.0);\n\tct[3] = vec3(1.0, 0.6, 0.0);\n\tct[4] = vec3(1.0, 0.9, 0.0);\n\tct[5] = vec3(1.0, 0.6, 0.0);\n\tct[6] = vec3(1.0, 0.3, 0.0);\n\tct[7] = vec3(0.3, 0.1, 0.0);\n\tct[8] = vec3(0.5, 0.0, 0.3);\n     \n    float zoomTime = iTime * 0.073;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uvCos = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x = uv.x * aspect;\n    \n    uvCos.x = -cos(uvCos.x * Pi2) * 0.5 + 0.5;\n    uvCos.y = -cos(uvCos.y * Pi2) * 0.5 + 0.5;\n    \n    float zp = -sin(hPi + zoomTime) * 0.5 + 0.5;\n    float s = 0.5 + 8.0 * zp * ((0.8 + uvCos.x * 0.9) + (0.9 + (1.0 - -cos(uvCos.y + iTime)) * 1.3) + (0.9 + (1.0 - -cos(uvCos.x + iTime)) * 1.3) );\n    uv.xy *= s;\n    uv.x -= s;\n    uv.y -= s * 0.5;\n      \n    \n    float x = 0.5 + 0.5 * -cos(uv.x * Pi2 + iTime * 2.0)  * (uvCos.y + 1.0);\n    x += 0.25 + 0.25 * -cos((uv.x + iTime * 0.2) * Pi2 * 2.5);\n    float y = 0.5 + 0.5 * -cos(uv.y * Pi2);\n    float blah = (0.5 + 0.5 * -cos(iTime * 0.134)) * (uv.x + iTime * 0.1);\n    y += 0.25 + 1.0 * -cos(blah + uv.y * Pi2 * 0.1);\n    \n\tfragColor = vec4(lookup(x * y * (1.1 - pow(zp, 0.125)) * 4.1 + iTime * 0.001), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBSzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 123, 153, 153, 1348], [1351, 1351, 1408, 1707, 2968]]}
{"id": "lsBXDd", "name": "Fractal gaze", "author": "guil", "description": "Click on the image to change the parameter of the Julia set.", "tags": ["3d", "fractal"], "likes": 1, "viewed": 153, "date": "1417129153", "time_retrieved": "2024-06-20T18:14:35.479379", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 10.5) // '.'\n\t{\n\t\tdata = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(n < 11.5) // '-'\n\t{\n\t\tdata = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\n\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}\n\n//-----------------------------------------------------------------\n\nvec2 cinv( vec2 z)  { float d = dot(z,z); return vec2( z.x, -z.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p =1.2*((-iResolution.xy+2.0*fragCoord.xy)/iResolution.y+vec2(1.,0.));\n\tvec2 c= p;\t\n\tvec2 z = p;\n\tfloat f = 1.;\n\tfloat g = 0.;\n    \n\tfloat k =.02;\n\tif(p.x>1.2){\n\t\tc = (iMouse.z>0.)?1.2*((-iResolution.xy+2.0*iMouse.xy)/iResolution.y+vec2(1.,0.)):vec2(0.62,.0);\n\t\tz.x-= 1.5;\n\t\tz*=1.5;\n\t}\n    vec2 zn = vec2(1.,0.);\n\tvec2 cc=c;\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\t\n\t\t//z=abs(z);\n\t\t\n\t\tz=cmul(z,z)-0.95*z+cc;\n\t\tcc=.95*cc+.2*z*abs(cos(.1*iTime));\n\t\tif(dot(z,z)>1e5){\n            float k1 = pow(1e5/dot(z,z),.125)*k;\n            zn = (1.-k1)*zn+k1*csqr(z)/dot(z,z);\n            break;\n        }\n        zn = (1.-k)*zn+k*csqr(z)/dot(z,z);\t\t\n\t\tg  +=1.;\n\t}\n    f = (1.-exp(-.8*dot(zn,zn)));\n    g = g + 1.0 - log2( 0.5*(log2(dot(z,z))) );\n\tvec3 col;\n    //col =2.*f*abs(vec3(zn.y,zn.x*zn.y,zn.x*zn.x));\n\t//col = 0.5 + 0.5*cos( 3.0 + g*0.1 -2.* vec3(zn.y,zn.y,zn.x));\n\tf = 1.0+log(f)/5.0;\n\tg = 1.0+log(g)/10.0;\n\t\n\tcol = 1.-g*abs(vec3(g,f*g,f*f));\n\t\n\t\n\tcol = mix(col, vec3(1.),PrintValue((p-vec2(1.,1.))/.07, c.x,5.,3.));\n\tcol = mix(col, vec3(1.),PrintValue((p-vec2(1.5,1.))/.07, c.y,5.,3.));\n\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBXDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[89, 336, 392, 392, 1690], [1693, 1693, 1825, 1825, 3105], [3107, 3176, 3197, 3197, 3249], [3250, 3250, 3271, 3271, 3317], [3318, 3318, 3348, 3348, 3403], [3405, 3405, 3462, 3462, 4579]]}
{"id": "lsBXWy", "name": "Self-playing interference", "author": "FatumR", "description": "Found my old shader. Simple \"self-playing\" interference demonstration", "tags": ["2d"], "likes": 10, "viewed": 285, "date": "1415440684", "time_retrieved": "2024-06-20T18:14:35.721757", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 resolution = iResolution;\n\tfloat time = iTime;\n\t\n\tvec2 center = resolution.xy / 2.0;\n\tfloat radius = max(resolution.x, resolution.y) / 4.0;\n\t\n\tfloat indx =  fract(time ) * 500.0;\n\t\n\tfloat fluctuationX0 = 0.0;\n\tfloat fluctuationY0 = 0.0;\n\tfloat fluctuationX1 = 0.0;\n\tfloat fluctuationY1 = 0.0;\n\t\n\t\t\n\tfluctuationX0 =  100.0 * sin(time * 2.0 + time / 2.0);\n\tfluctuationY0 =  100.0 * sin(time * 2.0 - time / 2.5);\n\tfluctuationX1 =  100.0 * cos(time * 2.0 + time / 1.5);\n\tfluctuationY1 =  100.0 * cos(time * 2.0 - time / 3.0);\n\n\tvec2 waveCenter[5];\n\twaveCenter[0] = vec2(center.x + (resolution.x / 3.0) + fluctuationX0,\n\t\t\t\t\tcenter.y + fluctuationY0);\n\twaveCenter[1] = vec2(center.x - (resolution.x / 3.0) + fluctuationY0,\n\t\t\t\t\tcenter.y + fluctuationX0);\n\twaveCenter[2] = vec2(center.x + fluctuationX1,\n\t\t\t\t\tcenter.y + (resolution.y / 3.0)  + fluctuationY1);\n\twaveCenter[3] = vec2(center.x + fluctuationY1,\n\t\t\t\t\tcenter.y - (resolution.y / 3.0)   + fluctuationX1);\n\twaveCenter[4] = vec2(center.x + fluctuationX0 + fluctuationX1,\n\t\t\t\t\tcenter.y + fluctuationX1 + fluctuationY1);\n\tfloat amplitude[5];\n\tamplitude[0] = 5.0;\n\tamplitude[1] = 8.0;\n\tamplitude[2] = 7.0;\n\tamplitude[3] = 3.0;\n\tamplitude[4] = 10.0;\n\t\n\tfloat dst = 0.0;\n\tfloat partialClr[5];\n\t\n\tfor (int i = 0; i < 5; i++) {\n\t\tdst = distance(waveCenter[i], fragCoord.xy);\n\t\tpartialClr[i] = amplitude[i] / dst * sin(dst / 1.0 - time * 10.0);\n\t}\n\t\n\tfloat mainColor = partialClr[0] + partialClr[1] + partialClr[2] + \n\t\t\t\t\tpartialClr[3] + partialClr[4];\n\t\n    fragColor = vec4(vec3(clamp(mainColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBXWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1626]]}
{"id": "lsjSDK", "name": "Flag: Japan", "author": "4rknova", "description": "Flag of Japan.", "tags": ["flag", "japan"], "likes": 2, "viewed": 1064, "date": "1416174126", "time_retrieved": "2024-06-20T18:14:35.727890", "image_code": "// by nikos papadopoulos, 4rknova / 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPS 0.001\n\n#define SUPERSAMPLING 4.\n#define ANIMATE\n\n// Flag ####################################################################\n#define FLAG_JP_PROP      3./2.\n#define FLAG_JP_COL_WHITE vec3(1)\n#define FLAG_JP_COL_RED   vec3(1, 0, 0)\n#define FLAG_JP_RADIUS    .3\n\nvec3 flag_jp(in vec2 p) {\n    if (p.x > FLAG_JP_PROP || p.x < 0. ||\n        p.y > 1. || p.y <0.) return vec3(0.);\n  \n    vec3 c = FLAG_JP_COL_WHITE;\n\t\n    if (length(p - vec2(FLAG_JP_PROP * .5, .5)) < FLAG_JP_RADIUS)\n        c = FLAG_JP_COL_RED;\n  \t\n\treturn c;\n}\n// #########################################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x/iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * vec2(ar, 1);\n    \n    float zoom = 1.4;\n    vec2  pos  = vec2(.5,.25);\n    \n    uv = uv * zoom - pos; // Position the flag\n    vec2 pv = uv;\n\n#ifdef ANIMATE // Wave animation    \n    vec2 cv = uv;    \n\tpv.y = uv.y + (.3 + cv.x) * pow(sin(cv.x * 6. - iTime * 6.0), 2.) * .032;\n    pv.x = uv.x + cv.y * cos(cv.x - cv.y * 2. - iTime * .5) * .05;\n#endif\n    \n    vec3 col = vec3(0);\n\n#ifdef SUPERSAMPLING\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x) / zoom;\n    for (float i = -SUPERSAMPLING; i < SUPERSAMPLING; ++i) {\n        for (float j = -SUPERSAMPLING; j < SUPERSAMPLING; ++j) {\n    \t\tcol += flag_jp(pv + vec2(i, j) * (e/SUPERSAMPLING)) \n                / (4.*SUPERSAMPLING*SUPERSAMPLING);\n        }\n    }\n#else\n     col = flag_jp(pv);\n#endif\n\n    float s = 1.;\n    \n#ifdef ANIMATE\n    s = pow(dot(normalize(vec3(pv - uv, 1)), normalize(vec3(0,25, 4))),.4);\n    #endif\n    \n\tfragColor = vec4(col * s, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjSDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[182, 395, 420, 420, 657], [658, 736, 793, 793, 1837]]}
{"id": "lsjXDy", "name": "Eth rainbow", "author": "bytewave", "description": " ", "tags": ["rainbow", "hsv2rgb"], "likes": 24, "viewed": 893, "date": "1415722958", "time_retrieved": "2024-06-20T18:14:35.727890", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat uniformRand(vec2 p)\n{ \n     return fract(975.121*sin(dot (vec2(p.x,p.y),vec2(321.654,654.987))))*0.5+0.5;\n}\n\nfloat noise1D(float p)\n{\n    float a = uniformRand( floor( vec2(p,0. )));\n    float b = uniformRand( floor( vec2(p + 1.,0. ) ));\n    float t = mix(a,b,fract(p));\n    return t;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    vec2 oriuv = uv;\n    uv.y *= 2.5;    \n    uv += sin(uv.x * 10. * (uv.y * 1.11)  + iTime) * 0.15;\n    \n    oriuv = mix(oriuv,uv,0.1);\n    float m = clamp((.37 - abs( uv.y )) * 3.,0.,1.);    \n    vec3 V = hsv2rgb( vec3((uv.x * 0.1) + iTime * 0.25 ,1.,1.));\n    V *=  m;    \n    V *= 1. - (sin( uv.y * uv.y * 30. ) * .26);\n    \n    fragColor = vec4(V,1.0) * noise1D(oriuv.x * 50.+iTime*5.)* noise1D(oriuv.x * 40.+iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjXDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 27, 27, 153], [155, 155, 182, 182, 268], [270, 270, 294, 294, 452], [454, 454, 511, 511, 1005]]}
{"id": "lsjXRd", "name": "Implicit Functions 2D", "author": "mAlk", "description": "graphical representation of various implicit functions", "tags": ["graph", "function", "implicit"], "likes": 7, "viewed": 181, "date": "1415228078", "time_retrieved": "2024-06-20T18:14:35.727890", "image_code": "vec3 F1(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale*0.5+(0.5*sin(iTime*Speed));\n    y *= Scale*0.5+(0.5*sin(iTime*Speed));\n    \n\tfloat f = pow(x*x+y*y,3.0) - 27.0*x*x*y*y;\n    float dx = 6.0*x*pow(x*x+y*y,2.0) - 54.0*x*y*y;\n    float dy = 6.0*y*pow(x*x+y*y,2.0) - 54.0*x*x*y;\n    return vec3(f,dx,dy);\n}\n\nvec3 F2(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale*0.5+(0.5*sin(iTime*Speed));\n    y *= Scale*0.5+(0.5*sin(iTime*Speed));\n    \n\tfloat f = x*x+y*y-1.0;\n    float dx = 2.0*x;\n    float dy = 2.0*y;\n    return vec3(f,dx,dy);\n}\n\nvec3 F3(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale*0.5+(0.5*sin(iTime*Speed));\n    y *= Scale*0.5+(0.5*sin(iTime*Speed));\n    \n\tfloat f = pow(x*x-y,2.0) - pow(x,5.0);\n    float dx = 4.0*x*(x*x-y) - 5.0*pow(x,4.0);\n    float dy = 2.0*(x*x-y);\n    return vec3(f,dx,dy);\n}\n\nvec3 F4(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale*0.5+(0.5*sin(iTime*Speed));\n    y *= Scale*0.5+(0.5*sin(iTime*Speed));\n    \n\tfloat f = x*x*x-2.0*x*x-y*y+x;\n    float dx = 3.0*x*x-4.0*x+1.0;\n    float dy = -2.0*y;\n    return vec3(f,dx,dy);\n}\n\nvec3 F5(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale+(3.0*sin(iTime*Speed));\n    y *= Scale+(3.0*sin(iTime*Speed));\n    \n\tfloat f = pow(x*x+y*y-6.0*x,2.0)-x*x-y*y;\n    float dx = (4.0*x-12.0)*(x*x+y*y-6.0*x)-2.0*x;\n    float dy = 4.0*y*(x*x+y*y-6.0*x)-2.0*y;\n    return vec3(f,dx,dy);\n}\n\nvec3 F6(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale+(1.5*sin(iTime*Speed));\n    y *= Scale+(1.5*sin(iTime*Speed));\n    \n\tfloat f = x*x*x*x+y*y*y*y-8.0*x*x-10.0*y*y+16.0;\n    float dx = 4.0*x*x*x-16.0*x;\n    float dy = 4.0*y*y*y-20.0*y;\n    return vec3(f,dx,dy);\n}\n\nvec3 F7(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale*0.5+(0.5*sin(iTime*Speed));\n    y *= Scale*0.5+(0.5*sin(iTime*Speed));\n    \n    float a = 0.75;\n\tfloat f = pow(x*x-y*y+a,2.0)-x*x/(y*y);\n    float dx = 4.0*x*(x*x-y*y+a)-2.0*x/(y*y);\n    float dy = -4.0*y*(x*x-y*y+a)+2.0*x*x/(y*y*y);\n    return vec3(f,dx,dy);\n}\n\nvec3 F8(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale*0.5+(0.5*sin(iTime*Speed));\n    y *= Scale*0.5+(0.5*sin(iTime*Speed));\n    \n    float a = 1.0;\n\tfloat f = pow(x,2.0/3.0)+pow(y,2.0/3.0)-a;\n    float dx = pow(x,-1.0/3.0);\n    float dy = pow(y,-1.0/3.0);\n    return vec3(f,dx,dy);\n}\n\nvec3 F9(in float x, in float y, in float Scale, in float Speed)\n{   \n    x *= Scale*0.75+(0.25*sin(iTime*Speed));\n    y *= Scale*0.75+(0.25*sin(iTime*Speed));    \n\n\tfloat f = pow(x*x+y*y,2.0)-x*x+y*y;\n    float dx = 4.0*x*(x*x+y*y)-2.0*x;\n    float dy = 4.0*y*(x*x+y*y)+2.0*y;\n    return vec3(f,dx,dy);\n}\n\nfloat Graph(in vec3 f, in float s)\n{\n    float Distance = abs(f.x)/length(s*f.yz);\n    return smoothstep(0.1,0.15,Distance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord.xy/iResolution.yy-vec2(0.5*iResolution.x/iResolution.y,0.5));\n        \n\tvec2 grid = min(vec2(1.0,1.0),floor(abs(uv*min(iResolution.y,512.0))));\n    \n    float a = Graph(F1(uv.x,uv.y,8.0,2.0),0.16);\n    \n\tfloat b = Graph(F2(uv.x,uv.y,5.0,2.0),0.09);\n    \n    float c = Graph(F3(uv.x,uv.y,5.0,2.0),0.08);\n    \n    float d = Graph(F4(uv.x,uv.y,5.0,2.0),0.07);\n    \n    float e = Graph(F5(uv.x,uv.y,10.0,2.0),0.3);\n    \n    float f = Graph(F6(uv.x,uv.y,8.0,2.0),0.2);      \n    \n    float g = Graph(F7(uv.x,uv.y,6.0,2.0),0.08);\n    \n    float h = Graph(F8(uv.x,uv.y,4.5,2.0),0.05);      \n    \n    float i = Graph(F9(uv.x,uv.y,2.0,2.0),0.05);    \n   \n    float m = floor(fract((iTime-9.0)/24.0)*9.0);\n    \n    float graph = a;\n    \n    if (m == 0.0)\n    {graph = a;}\n    \n    else if (m == 1.0)\n    {graph = b;}\n    \n    else if (m == 2.0)\n    {graph = c;}\n    \n    else if (m == 3.0)\n    {graph = d;}\n    \n    else if (m == 4.0)\n    {graph = e;}\n    \n    else if (m == 5.0)\n    {graph = f;}\n    \n    else if (m == 6.0)\n    {graph = g;}\n    \n    else if (m == 7.0)\n    {graph = h;}\n    \n    else\n     graph = i;\n    \n    fragColor = vec4( mix(vec4(0.0,0.0,1.0,0.0),vec4(1.0),graph)*grid.x*grid.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjXRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 65, 65, 335], [337, 337, 402, 402, 592], [594, 594, 659, 659, 896], [898, 898, 963, 963, 1174], [1176, 1176, 1241, 1241, 1493], [1495, 1495, 1560, 1560, 1790], [1792, 1792, 1857, 1857, 2137], [2139, 2139, 2204, 2204, 2453], [2455, 2455, 2520, 2520, 2759], [2761, 2761, 2797, 2797, 2887], [2889, 2889, 2946, 2946, 4169]]}
{"id": "lsSSDt", "name": "barycentricscreensaver", "author": "jt", "description": "A \"screen-saver\" based on three bouncing particles connected to a triangle using barycentric coordinates.", "tags": ["barycentriccoordinates", "bouncingparticles"], "likes": 4, "viewed": 299, "date": "1417018718", "time_retrieved": "2024-06-20T18:14:35.727890", "image_code": "// A \"screen-saver\" based on barycentric coordinates\n// written 26.11.2014 by Jakob Thomsen\n// (jakobthomsen@gmx.de)\n\n// mirror/bounce inside -1,+1\nvec2 mirror(vec2 pos)\n{\n    return (2.0 * abs(2.0 * fract(pos) - 1.0) - 1.0);\n}\n\nfloat light(vec2 pos, float size, vec2 uv)\n{\n    return exp(-pow(distance(uv, pos) / size, 2.0));\n}\n\nvec3 barycentric(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    float d = (b.y - c.y) * (a.x - c.x) + (c.x - b.x) * (a.y - c.y);\n    float alpha = ((b.y - c.y) * (p.x - c.x)+(c.x - b.x) * (p.y - c.y)) / d;\n    float beta = ((c.y - a.y) * (p.x - c.x) + (a.x - c.x) * (p.y - c.y)) / d;\n    float gamma = 1.0 - alpha - beta;\n    return vec3(alpha, beta, gamma);\n}\n\nvec3 inRange3(vec3 p)\n{\n    return step(p, vec3(1.0)) * step(vec3(0.0), p);\n}\n\nfloat inRangeAll(vec3 p)\n{\n    vec3 r = inRange3(p);\n    \n    return r.x * r.y * r.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 speed0 = vec2(0.0432, 0.0123);\n    vec2 speed1 = vec2(0.0257, 0.0332);\n    vec2 speed2 = vec2(0.0835, 0.0674);\n    float size = 0.1;\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xy;\n    uv *= 2.0;\n    float val = 0.0;\n    vec2 pos0 = mirror(iTime * speed0);\n    vec2 pos1 = mirror(iTime * speed1);\n    vec2 pos2 = mirror(iTime * speed2);\n    vec3 bc = barycentric(pos0, pos1, pos2, uv);\n    val = inRangeAll(bc);\n    //val = mix(val, light(vec2(0.0), 1.0, uv), max(step(1.0, abs(uv.x)),step(1.0, abs(uv.y))));\n    vec3 c = bc * val;\n    c = c + vec3(1.0, 0.0, 0.0) * light(pos0, size, uv);\n    c = c + vec3(0.0, 1.0, 0.0) * light(pos1, size, uv);\n    c = c + vec3(0.0, 0.0, 1.0) * light(pos2, size, uv);\n\n    fragColor = vec4(c, 1.0);\n}\n\n/*\n#define mirror(v) (2.0 * abs(2.0 * fract(v) - 1.0) - 1.0)\n\nvec3 barycentric(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    float d = (b.y - c.y) * (a.x - c.x) + (c.x - b.x) * (a.y - c.y);\n    float alpha = ((b.y - c.y) * (p.x - c.x)+(c.x - b.x) * (p.y - c.y)) / d;\n    float beta = ((c.y - a.y) * (p.x - c.x) + (a.x - c.x) * (p.y - c.y)) / d;\n    float gamma = 1.0 - alpha - beta;\n    return vec3(alpha, beta, gamma);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 speed0 = vec2(0.0432, 0.0123);\n    vec2 speed1 = vec2(0.0257, 0.0332);\n    vec2 speed2 = vec2(0.0835, 0.0674);\n    float size = 0.1;\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xy;\n    uv *= 2.0;\n    float val = 0.0;\n    vec2 pos0 = mirror(iTime * speed0);\n    vec2 pos1 = mirror(iTime * speed1);\n    vec2 pos2 = mirror(iTime * speed2);\n    vec3 bc = barycentric(pos0, pos1, pos2, uv);\n    vec3 c = bc * (all(greaterThan(bc, vec3(0))) ? 1. : 0.);\n    c *= 0.5 + 0.5 * cos(100.*min(bc.x, min(bc.y, bc.z)));\n\n    fragColor = vec4(c, 1.0);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSSDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[118, 148, 171, 171, 227], [229, 229, 273, 273, 328], [330, 330, 380, 380, 681], [683, 683, 706, 706, 760], [762, 762, 788, 788, 849], [851, 851, 908, 908, 1672]]}
{"id": "lsSXDG", "name": "J. Noodling", "author": "Jokes", "description": "New to the language, learning my way around by messing with pretty things. Adapted this from 'Tileable Water Caustic' by Dave_Hoskins.", "tags": ["2d"], "likes": 17, "viewed": 410, "date": "1416622767", "time_retrieved": "2024-06-20T18:14:36.037026", "image_code": "// Adapted from 'Tileable Water Caustic' by Dave_Hoskins\n// -J.\n\n// -----------------------------------------------------------------------\n// Water turbulence effect by joltz0r 2013-07-04, improved 2013-07-07\n// Altered\n// -----------------------------------------------------------------------\n\n// Redefine below to see the tiling...\n//#define SEE_TILING\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5+23.0;\n    // uv should be the 0-1 uv of texture...\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#ifdef SEE_TILING\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\n#else\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n#endif\n\tvec2 i = vec2(p);\n    vec2 i2 = vec2(p);\n\tfloat c = 1.0;\n    float c2 = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n        float t2 = time * (1.0 - (3.5 / float(MAX_ITER+n+1)));\n        \n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n        \n\t\ti2 = p + vec2(cos(t2 - i2.x) + sin(t2 + i2.y), sin(t2 - i2.y) + cos(t2 + i2.x));\n\t\tc2 += 1.0/length(vec2(p.x / (sin(i2.x+t2)/inten),p.y / (cos(i2.y+t2)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n    c2 /= float(MAX_ITER);\n    c2 = 1.17-pow(c2, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour *= vec3(sin(time*1.9), sin(time*1.5), sin(time*1.1));\n    vec3 col2 = vec3(pow(abs(c2), 8.0)) * vec3(cos(time));\n    vec3 space = vec3(0.4 + 0.1*uv.y + 0.1*uv.x, 0.6 - 0.2*uv.y, 0.4 + 0.2*uv.x);\n\tfragColor = vec4(clamp(colour + col2 + space, 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[297, 404, 462, 462, 1688]]}
{"id": "lsSXRd", "name": "This is your brain on GLSL", "author": "ErnstHot", "description": "Aliasing is your friend.\nBecause of the aliasing, this will look somewhat different in different resolutions.", "tags": ["2d", "plasma", "psychedelic"], "likes": 1, "viewed": 243, "date": "1414876946", "time_retrieved": "2024-06-20T18:14:36.037026", "image_code": "const float Pi = 3.14159;\nconst float Pi2 = Pi * 2.0;\nconst float hPi = Pi * 0.5;\nvec3 ct[9]; \n\nvec3 lookup(const float pos)\n{\n    float p = fract(pos) * 7.999;\n    int i = int(p);\n    float f = fract(p);\n    vec3 res = vec3(0.0);\n    vec3 a = vec3(0.0);\n    vec3 b = vec3(0.0);\n      \n    if (i < 4)\n    {\n        if (i < 2)\n        {\n            if (i == 0)\n            {\n                a = ct[0]; b = ct[1];    \n            }\n            else\n            {\n                a = ct[1]; b = ct[2];\n            }            \n        }\n        else\n        {\n            if (i == 2)\n            {\n                a = ct[2]; b = ct[3];    \n            }\n            else\n            {\n                a = ct[3]; b = ct[4];\n            }            \n        }    \n    }\n    else\n    {\n\t    if (i < 6)\n        {\n            if (i == 4)\n            {\n                a = ct[4]; b = ct[5];    \n            }\n            else\n            {\n                a = ct[5]; b = ct[6];\n            }            \n        }\n        else\n        {\n            if (i == 6)\n            {\n                a = ct[6]; b = ct[7];    \n            }\n            else\n            {\n                a = ct[7]; b = ct[8];\n            }            \n        }    \n    }\n    \n\treturn mix(a, b, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tct[0] = vec3(0.5, 0.0, 0.3);\n\tct[1] = vec3(0.3, 0.1, 0.0);\n\tct[2] = vec3(1.0, 0.3, 0.0);\n\tct[3] = vec3(1.0, 0.6, 0.0);\n\tct[4] = vec3(1.0, 0.9, 0.0);\n\tct[5] = vec3(1.0, 0.6, 0.0);\n\tct[6] = vec3(1.0, 0.3, 0.0);\n\tct[7] = vec3(0.3, 0.1, 0.0);\n\tct[8] = vec3(0.5, 0.0, 0.3);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    float t = 100.0 + iTime * 0.04;\n    uv.y += 1.0  + t * 2.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n\tfloat c = -cos(uv.y * Pi2 + t) * 0.0125 + 0.25 + -cos(uv.x * Pi2 + t * -0.23) * 0.125;\n       \n    float b = -cos(uv.x * (1.5 + uv.y * 14.0) * 12.0 * c + t * 0.2) * 0.5 + 0.5;\n    vec3 col = lookup(b * 2.0 + iTime * 0.5);\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[96, 96, 126, 126, 1267], [1269, 1269, 1326, 1326, 2027]]}
{"id": "lsSXWc", "name": "Procedural mushroom 2", "author": "moshev", "description": "alternate ray marching", "tags": ["raymarching", "distancefields"], "likes": 0, "viewed": 188, "date": "1416515758", "time_retrieved": "2024-06-20T18:14:37.206871", "image_code": "// set to 0 for regular shading\n#define TOON 0\n\nfloat TAU = 6.2831853;\n\nfloat mixfix(float a, float b, float t) {\n    return mix(a, b, t);\n    // this piece is nonsensical but without it\n    // we get a black screen, fuck you nVidia\n    // fuck you with a rusty rake\n    // (pls fix your floating point)\n    float u;\n    t = clamp(t, 0.0, 1.0);\n    u = 1.0 - t;\n    u = clamp(u, 0.0, 1.0);\n    return a * u + b * t;\n}\n\n/*sphere*/\nfloat sphere(vec3 p, vec3 c, float r) {\n    return distance(c, p) - r;\n}\n\n/*cylinder with spherical caps at ends*/\n/* a, b - centres of the caps, r - radius */\nfloat cylinder_caps(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 n = normalize(b - a);\n    vec3 p1 = p - a;\n    float d = dot(n, p1);\n    vec3 c = d * n;\n    if (dot(n, c) < 0.0) {\n        return sphere(p, a, r);\n    }\n    if (dot(n, c) > distance(a, b)) {\n        return sphere(p, b, r);\n    }\n    float daxis = length(p1 - d * n);\n    return daxis - r;\n}\n\nfloat dist_object(vec3 p) {\n    float t = smoothstep(-0.1, 0.6, p.y);\n    float c = cylinder_caps(p, vec3(0, -0.9, 0), vec3(0, 0.9, 0), 0.3);\n    float s = sphere(p, vec3(0, 0.3, 0), 0.9);\n    float cutplane = 0.1-p.y;\n    //s = max(s, cutplane);\n    return mixfix(c, s, t);\n}\n\n\n/* gradient */\nvec3 grad(vec3 p) {\n    float eps = 0.0001;\n    return normalize(vec3(\n                dist_object(p - vec3(eps, 0.0, 0.0)) - dist_object(p + vec3(eps, 0.0, 0.0)),\n                dist_object(p - vec3(0.0, eps, 0.0)) - dist_object(p + vec3(0.0, eps, 0.0)),\n                dist_object(p - vec3(0.0, 0.0, eps)) - dist_object(p + vec3(0.0, 0.0, eps))));\n}\n\n\nconst float epsilon = 2.0e-4;\n#define MAXITERS 128\n/* trace from point p along ray r */\nvec4 trace(vec3 p, vec3 r) {\n    vec3 p1 = p;\n    float d = dist_object(p);\n    float d1;\n    for (int i = 0; i < MAXITERS; i++) {\n        // escape if too long\n        if (dot(p1 - p, p1 - p) > 16.0 * 16.0) {\n            return vec4(p1, 0.0);\n        }\n        if (abs(d) < epsilon) {\n            return vec4(p1, 1.0);\n        }\n        d1 = distance(p1, p);\n        p1 = (d + d1) * r + p;\n        d = dist_object(p1);\n    }\n    return vec4(p1, 0.0);\n}\n\n/* Get the minimal distance along a segment a to b\nReturns < epsilon if an object is hit, > 0 otherwise\n*/\nfloat min_distance_along_segment(vec3 a, vec3 b) {\n    vec3 p = a;\n    vec3 r = normalize(b - a);\n    float mindist = -1.0;\n    float maxlength2 = dot(b - a, b - a);\n    float d = dist_object(a);\n    float d1;\n    vec3 n;\n    for (int i = 0; i < MAXITERS; i++) {\n        n = grad(p);\n        if (abs(d) < mindist || mindist < 0.0) {\n            if (dot(n, r) < 0.0) {\n                mindist = abs(d);\n            }\n        }\n        if (dot(p - a, p - a) >= maxlength2) {\n            break;\n        }\n        if (abs(d) < epsilon) {\n            if (dot(n, r) < 0.0) {\n            \tbreak;\n            }\n        }\n        d1 = distance(p, a);\n        p = (d + d1) * r + a;\n        d = dist_object(p);\n    }\n    return mindist;\n}\n\nfloat manhattan_distance(vec2 a, vec2 b) {\n    vec2 c = a - b;\n    return abs(c.x) + abs(c.y);\n}\n\nvec3 texgen(vec3 p, vec3 n, vec3 ray) {\n    // glTexGen GL_SPHERE_MAP\n    return abs(n);\n    vec3 u = normalize(p);\n    vec3 f = u - 2.0 * dot(n, u) * n;\n    f += vec3(0, 0, 1);\n    float m = 2.0 * sqrt(dot(f, f));\n    vec2 t = f.xy / m + vec2(0.5, 0.5);\n    \n    vec2 rep = fract(t * 4.0);\n    float d = distance(vec2(0.5, 0.5), rep);\n    float c = smoothstep(-0.4, -0.35, -d) * 0.5 + 0.5;\n    return vec3(c, c, c);\n}\n\nvec3 light_pos = vec3(0, 0, 3);\nvec3 shade(vec3 p, vec3 ray) {\n    vec3 n = grad(p);\n    vec3 light = normalize(p - light_pos);\n    float lit = 1.0;//min_distance_along_segment(light_pos, p);\n    if (lit > epsilon || lit < 0.0) {\n        lit = dot(n, light);\n    } else {\n        lit = 0.0;\n    }\n    #if !TOON\n    vec3 c = texgen(p, n, ray);\n    return c;\n    #else\n    float t = dot(n, ray);\n    vec3 np = normalize(p);\n    vec2 s = vec2(acos(np.z), atan(np.y, np.x));\n    //s += vec2(fract(iTime * 0.16));\n    t -= texture(iChannel0, s).r * 0.25;\n    lit += 0.025 - texture(iChannel0, s).r * 0.05;\n    if (t < 0.123) {\n        return vec3(0.1, 0.1, 0.1);\n    } else if (lit < 0.1) {\n        return vec3(0.15, 0.15, 0.32);\n    } else if (lit < 0.9) {\n        return vec3(0.65, 0.7, 0.8);\n    } else {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    #endif\n}\n\nvec4 go(vec3 p, vec3 ray) {\n    vec4 q = trace(p, ray);\n    vec3 result;\n    if (q.w < 1.0) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    p = q.xyz;\n    return vec4(shade(p, ray), 1.0);\n}\n\nmat4 mkrotationm4(vec3 axis, float angle) {\n    float c = cos(angle);\n    float nc = 1.0 - c;\n    float s = sin(angle);\n    float v0 = axis.x;\n    float v1 = axis.y;\n    float v2 = axis.z;\n    /* Formula copied from wikipedia\n     * matrices are column-major so this looks transposed\n     * with regards to what you'd find there */\n    return mat4(\n        vec4(v0 * v0 * nc + c, v1 * v0 * nc + v2 * s, v2 * v0 * nc - v1 * s, 0),\n        vec4(v0 * v1 * nc - v2 * s, v1 * v1 * nc + c, v2 * v1 * nc + v0 * s, 0),\n        vec4(v0 * v2 * nc + v1 * s, v1 * v2 * nc - v0 * s, v2 * v2 * nc + c, 0),\n        vec4(0, 0, 0, 1));\n}\n\nvec3 srgb_from_rgb(vec3 rgb) {\n    vec3 a = vec3(0.055, 0.055, 0.055);\n    vec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n    vec3 g = vec3(2.4, 2.4, 2.4);\n    vec3 ginv = 1.0 / g;\n    vec3 select = vec3(greaterThan(rgb, vec3(0.0031308, 0.0031308, 0.0031308)));\n    vec3 lo = rgb * 12.92;\n    vec3 hi = ap1 * pow(rgb, ginv) - a;\n    return select * hi + (vec3(1.0, 1.0, 1.0) - select) * lo;\n}\n\nvec3 rgb_from_srgb(vec3 srgb) {\n    vec3 a = vec3(0.055, 0.055, 0.055);\n    vec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n    vec3 g = vec3(2.4, 2.4, 2.4);\n\tvec3 select = vec3(greaterThan(srgb, vec3(0.04045, 0.04045, 0.04045)));\n    vec3 lo = srgb / 12.92;\n    vec3 hi = pow((srgb + a) / ap1, g);\n    return select * hi + (vec3(1, 1, 1) - select) * lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 camera = mkrotationm4(vec3(1, 0, 0), iTime * 0.5);\n    vec2 pixelcenter = \t(2.0 * fragCoord.xy) / iResolution.xy - vec2(1, 1);\n    vec3 p = vec3(0.0, 0.0, 3);\n    vec3 t = vec3(pixelcenter, 1.5);\n    light_pos = vec3(8.0*(iMouse.xy - iResolution.xy * 0.5) / iResolution.xy, 2.0);\n    light_pos = (camera * vec4(light_pos, 1.0)).xyz;\n    p = (camera * vec4(p, 1.0)).xyz;\n    vec3 ray = normalize((camera * vec4(t, 1.0)).xyz - p);\n\tvec4 result = go(p, ray);\n    vec3 col;\n    if (result.w < 0.5) {\n        col = vec3(0.15, 0.3, 0.2);\n    } else {\n\t\tcol = result.xyz;\n    }\n    fragColor = vec4(srgb_from_rgb(col), 1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 72, 113, 113, 417], [419, 430, 469, 469, 502], [504, 590, 644, 644, 945], [947, 947, 974, 974, 1223], [1226, 1241, 1260, 1260, 1594], [1648, 1685, 1713, 1713, 2138], [2140, 2247, 2297, 2297, 2974], [2976, 2976, 3018, 3018, 3072], [3074, 3074, 3113, 3143, 3492], [3526, 3526, 3556, 3556, 4351], [4353, 4353, 4380, 4380, 4547], [4549, 4549, 4592, 4592, 5169], [5171, 5171, 5201, 5201, 5552], [5554, 5554, 5585, 5585, 5898], [5900, 5900, 5957, 5957, 6586]]}
{"id": "Md2SDc", "name": "A Quad's Life", "author": "poljere", "description": "It is all about quads!", "tags": ["2d", "colors", "quads"], "likes": 7, "viewed": 3953, "date": "1416911167", "time_retrieved": "2024-06-20T18:14:37.206871", "image_code": "// Returns 1.0 when the uv is inside the quad\n// Parameter pos indicates the center of the rect\nfloat rect(vec2 uv, vec2 pos, vec2 size)\n{\n    return 1.0 - clamp(length(max(abs(uv - pos)-size, 0.0))*800.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Let's work with Y=0 on top and a space [0.0, 1.0]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    // Correct Aspect Ration    \n    uv.x *= iResolution.x / iResolution.y;    \n    vec3 col = vec3(0.0);\n    \n    // Calculate rectangles    \n    float i = floor(uv.x / 0.3);\n    float j = floor(uv.y / 0.35);   \n    \n    // Calculate if the pixel belongs to the rect or not    \n    vec2 center    = vec2(0.14, 0.16) + vec2(0.3, 0.33) * vec2(i,j);\n    vec2 size1     = vec2(0.12);\n    vec2 size2     = max(vec2(0.02,0.02), size1 * 0.9 * (0.5 + 0.5 * sin(iTime * 0.2 * center.x + center.x)));\n    float rect1    = rect(uv, center, size1);\n    float rect2    = rect(uv, center, size2);\n    \n    // Calculate the final color\n    vec3  col1     = 0.5 + 0.5*cos(iTime * 0.1 + 5.5*(center.x+center.y) + vec3(1.57, 0.0, 3.14) );\n    vec3  col2     = 0.5 + 0.5*cos(iTime * 0.5  + 5.5*(center.x) + vec3(1.57, 0.0, 3.14) );\n    col += mix(col1 * (rect1), col2, (rect1 * rect2));\n    \n    // Add background color\n    col += step(col, vec3(0.0)) * vec3(0.9);\n    \n    // Output the color to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2SDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 96, 138, 138, 218], [220, 220, 277, 334, 1427]]}
{"id": "Md2SDK", "name": "stripey diamond", "author": "dydx", "description": "diamond", "tags": ["diamond"], "likes": 3, "viewed": 159, "date": "1416184432", "time_retrieved": "2024-06-20T18:14:37.206871", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat saw(float x) {\n    return mod(x, 2.0) * 0.5;\n}\n\nfloat tri(float x) {\n    return 1.0 - abs( mod(x, 2.0) - 1.0 );\n}\n\nfloat cosPos(float x) {\n\treturn cos(x) * 0.5 + 0.5;\n}\n\nfloat signGte0(float x) {\n    return step(0.0, x)*2.0 - 1.0;\n}\n    \nvec3 invert(vec3 col, float mask) {\n    mask = signGte0(mask);\n\t// change col from 0 <-> 1 to -1 <-> 1\n    col = col * 2.0 - 1.0;\n\treturn (col * mask)*0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat time = iTime;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t// stripes\n\tfloat width = 0.20; // how wide is each pair (wavelength)\n\tfloat balance = 0.90; // 0.5 == 50/50 black and white\n    float offset = -0.20;\n\n\tfloat stripe = sin((p.y + offset)*2.0*PI/width) * 0.5 + balance;\n\tstripe = smoothstep(0.50, 0.51, stripe);\n\tvec3 col = vec3(stripe);\n\n\t// mask\n    float radius = 3.0 * saw(time);\n    float radius2 = 3.0 * saw(time - 1.0);\n    \n    float mask = (abs(p.x)+abs(p.y)) - radius;\n    float mask2 = (abs(p.x)+abs(p.y)) - radius2;\n\n    col = invert(col, mask);\n    col = invert(col, mask2);\n    //col = invert(col, -sin(time*PI)); //lol\n    col = invert(col, saw(time) - 0.5); //lol\n    \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2SDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[46, 46, 66, 66, 98], [100, 100, 120, 120, 165], [167, 167, 190, 190, 220], [222, 222, 247, 247, 284], [290, 290, 325, 325, 453], [455, 455, 512, 512, 1300]]}
{"id": "Md2SDV", "name": "twist sol1", "author": "denis", "description": "new solution at row 156\nanother test here https://www.shadertoy.com/view/XsSXW3\n", "tags": ["twist"], "likes": 6, "viewed": 272, "date": "1416225583", "time_retrieved": "2024-06-20T18:14:37.218700", "image_code": "// This examples show a solution for twist problem based on the iq sample by Denis\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n#if 0\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n#else\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif    \n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opTwist2( vec3 p )\n{\n    float  c = cos(4.0*p.y+10.0);\n    float  s = sin(4.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\n    res = opU( res, vec2(  opS(\n\t\t             udRoundBox(opTwist2(  pos-vec3(-1.0,0.2, 1.0)), vec3(0.15),0.05)*0.8,\n\t                 sdSphere(   pos-vec3(-1.0,0.2, 1.0), 0.25)), 13.0 ) );\n    \n    \n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;///2.0;\t//a solution for the twist\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2SDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 264, 289, 289, 304], [306, 306, 341, 341, 367], [369, 369, 400, 400, 487], [489, 489, 534, 534, 574], [576, 576, 609, 609, 662], [664, 664, 700, 700, 942], [944, 944, 996, 996, 1110], [1112, 1112, 1148, 1148, 1396], [1398, 1398, 1434, 1434, 1533], [1536, 1536, 1574, 1574, 1815], [1817, 1817, 1842, 1842, 1879], [1881, 1881, 1906, 1906, 1964], [1966, 1966, 1991, 1991, 2056], [2058, 2058, 2093, 2093, 2160], [2162, 2162, 2197, 2197, 2264], [2266, 2266, 2303, 2303, 2354], [2356, 2430, 2463, 2463, 2489], [2491, 2491, 2521, 2521, 2554], [2556, 2556, 2586, 2586, 2615], [2617, 2617, 2641, 2641, 2773], [2775, 2775, 2800, 2800, 2930], [2931, 3005, 3030, 3030, 3382], [3384, 3384, 3424, 3424, 4049], [4052, 4052, 4126, 4126, 4387], [4389, 4389, 4421, 4421, 4642], [4644, 4644, 4686, 4686, 4985], [4990, 4990, 5029, 5029, 6615], [6617, 6617, 6674, 6674, 7314]]}
{"id": "Md2SWy", "name": "hash noise", "author": "dzira", "description": "a quick hash noise", "tags": ["noise", "hashnoise"], "likes": 5, "viewed": 302, "date": "1415684235", "time_retrieved": "2024-06-20T18:14:37.218959", "image_code": "float hash( float n )\n{\n    return fract(sqrt(abs(n))*3734.421891);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv = floor(uv*40.+80.*vec2(sin(iTime/2.),cos(iTime/2.)));\n    float x = hash(fract(hash(.213*uv.x+.5*uv.y)+hash(.73*uv.y+7.)));\n    \n\tfragColor = vec4(x,x,x,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2SWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 69], [71, 71, 128, 128, 357]]}
{"id": "Md2XDV", "name": "Tesseract Wireframe vs 3D slice", "author": "iapafoto", "description": "[Mouse] Y pos => the w coord part of 4D tesserac which is a 3D shape :)  (3D slice of the 4D shape) \nPause anim to understand !  :)  Color indicates location in 4th dimension (w coord)\n#define to change SHAPE to test it with other 4D classical geometries", "tags": ["wireframe", "4d", "slice", "tesseract", "hypercube"], "likes": 58, "viewed": 2345, "date": "1416262577", "time_retrieved": "2024-06-20T18:14:38.758460", "image_code": "// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// To understand what it is, look at part \"Where is the Inside?\" at url:\n// http://eusebeia.dyndns.org/4d/vis/09-interp-1\n\n// less calcul and loop \n#define FAST \n\n//  0 nothing, 1 Cubinder, 2 Duo-Cylinder, 3 3-Sphere, 4 Tesseract,\n#define SHAPE 4\n\nconst float RAYON = .02;\nconst vec3 C1 = vec3(.2,.9,1), C2 = vec3(1,.3,.5);  // Colors for w coord\nconst vec3 E = vec3(0,.001,0); // epsilon\n\nvec3 L = normalize(vec3(.6, .7, .5)); // light\n\nmat4 B;\nfloat WCurrent;\n\n#ifdef FAST\nvec4 v0000,v1000,v0100,v0010,v0001,v1100,v1010,v1001;\n#endif\n\nfloat hash(in float x) {\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\n\nvec3 dmin(in vec3 v1, in vec3 v2) {\n    return v1.x<v2.x ? v1 : v2;\n}\n\nvec4 mv4D;\n\n// From 4D to 3D \nvec3 line4D(in vec3 p, vec4 p1, vec4 dp) {\n    p1+=mv4D;\n    //dp+=mv4D;\n \tvec3 pa = p-p1.xyz, ba = dp.xyz;\n    float k = clamp(dot(pa,ba)/dot(ba,ba),0., 1.);\n    return vec3(length(pa - ba*k) - RAYON ,k, p1.w +k*dp.w);\n}\n\n#ifdef FAST\n// FASTER like this but uggly and not working in firefox\nvec3 sdTesserac(in vec3 p) {\n     \n\tvec3 d;    \n        d = // 000\n            dmin(line4D(p, v0000, B[3]),\n\t\t\tdmin(line4D(p, v0000, B[2]),\n\t\t    dmin(line4D(p, v0000, B[1]), \n                 line4D(p, v0000, B[0]))));\n        d = dmin(d, // 100\n            dmin(line4D(p, v1000, B[3]),\n\t\t\tdmin(line4D(p, v1000, B[2]),\n\t\t    dmin(line4D(p, v1000, B[1]), \n                 line4D(p, v0100, B[0])))));\n        d = dmin(d, // 010\n            dmin(line4D(p, v0100, B[3]),\n\t\t\tdmin(line4D(p, v0100, B[2]),\n\t\t    dmin(line4D(p, v0010, B[1]), \n                 line4D(p, v0010, B[0])))));\n        d = dmin(d, // 110\n            dmin(line4D(p, v1100, B[3]),\n\t\t\tdmin(line4D(p, v1100, B[2]),\n\t\t    dmin(line4D(p, v1010, B[1]), \n                 line4D(p,-v1001, B[0])))));\n        d = dmin(d, // 001\n            dmin(line4D(p, v0010, B[3]),\n\t\t\tdmin(line4D(p, v0001, B[2]),\n\t\t    dmin(line4D(p, v0001, B[1]), \n                 line4D(p, v0001, B[0])))));\n        d = dmin(d, // 101\n            dmin(line4D(p, v1010, B[3]),\n\t\t\tdmin(line4D(p, v1001, B[2]),\n\t\t    dmin(line4D(p, v1001, B[1]), \n                 line4D(p,-v1010, B[0])))));\n        d = dmin(d, // 011\n            dmin(line4D(p,-v1001, B[3]),\n\t\t\tdmin(line4D(p,-v1010, B[2]),\n\t\t    dmin(line4D(p,-v1100, B[1]), \n                 line4D(p,-v1100, B[0])))));\n        d = dmin(d, // 111\n            dmin(line4D(p,-v0001, B[3]),\n\t\t\tdmin(line4D(p,-v0010, B[2]),\n\t\t    dmin(line4D(p,-v0100, B[1]), \n                 line4D(p,-v1000, B[0])))));    \n\treturn d;\n}\n#else\n// Tesserac projection (smartest but loop make it a little bit slower)\nvec3 sdTesserac(in vec3 p) {\n\tvec3 d = vec3(100.,-1.,0.);\n\tvec4 k = vec4(-.5);    \n\t// Simple initialisation of the 32 Edges of tesserac \n\tfor (int i=0; i<8; i++) {\n\t\tk.x = mod(float(i),2.)-.5; k.y = mod(float(i/2),2.)-.5; k.z = mod(float(i/4),2.)-.5; \n        d = dmin(d,\n            dmin(line4D(p, B*k    ,  B[3]),\n\t\t\tdmin(line4D(p, B*k.xywz, B[2]),\n\t\t    dmin(line4D(p, B*k.xwyz, B[1]), \n                 line4D(p, B*k.wxyz, B[0])))));\n\t}\n\treturn d;\n} \n#endif\n\n// 4D box => Tesserac\nfloat sdBox(in vec4 p, in vec4 b) {\n  vec4 d = abs(p) - b;\n  return min(max(d.x,max(d.y,max(d.z,d.w))),0.) + length(max(d,0.));\n}\n\n// 3-sphere (4d hypersphere)\nfloat sdSphere( vec4 p, float s ) {\n    return length(p)-s;\n}\n\n// http://eusebeia.dyndns.org/4d/cubinder\nfloat sdCubinder(vec4 p, vec3 rh1h2) {\n\tvec3 d = abs(vec3(length(p.xz), p.y, p.w)) - rh1h2;\n\treturn min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));\n}\n\n// http://eusebeia.dyndns.org/4d/duocylinder\nfloat sdDuoCylinder( vec4 p, vec2 r1r2) {\n  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - r1r2;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\n\n// x: distance, y : distance on segment, z : 4th dimension coord\nvec3 map(vec3 p) {\n    //p*=2.;\n  //  vec3 d1 = vec3(1000);\n  //  for (int u=0; u<4; u++) {\n  //  \tmv4D = B[u]; //vec4(1,0,0,0);\n//\t    d1 = dmin(d1,sdTesserac(p));\n //       mv4D = -B[u]; //vec4(1,0,0,0);\n//\t    d1 = dmin(d1,sdTesserac(p));\n//    }\n    mv4D = vec4(0);\n    return dmin(sdTesserac(p), vec3(\n#if SHAPE==0\n        999.,\n#elif SHAPE==1\n        sdCubinder(vec4(p,WCurrent)*B, vec3(.5-RAYON*.5)),\n#elif SHAPE==2 \n        sdDuoCylinder(vec4(p,WCurrent)*B, vec2(.5-RAYON*.5)),\n#elif SHAPE==3\n        sdSphere(vec4(p,WCurrent)*B, .5),\n#else        \n        sdBox(vec4(p,WCurrent)*B, vec4(.5-RAYON*.5)),\n#endif\n        -.1, WCurrent));\n}\n\n// Classical AO calculation\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float hr=.01, ao=.0, sca=1.;\n    for(int aoi=0; aoi<5; aoi++) {\n        ao += -(map(nor * hr + pos).x-hr)*sca;\n        sca *= .7;\n        hr += .05;\n    }\n    return clamp(1.-4.*ao, 0., 1.);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k ) {\n    float res=1., t=.02, h=1.;\n    for(int i=0; i<38; i++ ) {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, .015, 1. );\n\t\tif( h<0.012 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n   // vec2 e = vec2(E.y, -E.y); \n   // return normalize(e.xyy * map(p + e.xyy).x + e.yyx * map(p + e.yyx).x + e.yxy * map(p + e.yxy).x + e.xxx * map(p + e.xxx).x);;\n\tfloat pitch = .2 * t / iResolution.x;\n    \n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = p+d.xxx; // tetrahedral offsets\n\tvec3 p1 = p+d.xyy;\n\tvec3 p2 = p+d.yxy;\n\tvec3 p3 = p+d.yyx;\n\t\n\tfloat f0 = map(p0).x;\n\tfloat f1 = map(p1).x;\n\tfloat f2 = map(p2).x;\n\tfloat f3 = map(p3).x;\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t//return normalize(grad);\t\n    // prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n// Classical 3D to 2D rendering loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 mouse = iMouse.xwzy;\n\n\t// Configure camera\n\tvec2 r = iResolution.xy, \n         m = mouse.xy/r, \n         q = fragCoord.xy/r.xy, \n         p =q+q-1.;\n\tp.x *= r.x/r.y;\n    \n\tfloat j=.032, s=1., h = .1;\n\n    \n    WCurrent = clamp(2.*(mouse.w/iResolution.y)-1.,-.5,.7);\n\tvec3 c = vec3(.22,.26,.28);\n    float k = 0.;\n\n\t// Ray marching\n\n    if (q.x>.95) {\n        float w = 2.*(fragCoord.y/iResolution.y)-1.;\n        c = mix(C1,C2, .5+1.2*w);\n        k=1.-smoothstep(abs(w-WCurrent),-.003,.003);\n        \n    } else if (length(q-.5)<.4) {\n        \n        float hs = hash(4.+floor(10.+.15*iTime));\n\t\tfloat time = 1.*(15.+.5*iTime * hs + 10.2*hash(hs)); //+ .08*hash(iTime);;\n \n        // Rotation Matrix to apply to 4D objects\n        float aaa = 10.+time*1.4, bbb = 11.+time*1.65, ccc = 11.+time*1.32;\n        float c1 = cos(aaa), s1 = sin(aaa), \n              c2 = cos(bbb), s2 = sin(bbb), \n              c3 = cos(ccc), s3 = sin(ccc);\t\n        \n        B = mat4(c2,  s2*s3,   0, -s2*c3,   \n      \t\t\t  0,  c1*c3, -s1,  c1*s3,\n      \t\t\t  0,  c3*s1,  c1,  s1*s3,\n       \t\t\t s2, -c2*s3,   0,  c2*c3);\n#ifdef FAST\n    \tv0000 = B*vec4(-.5,-.5,-.5,-.5);\n    \tv1000 = B*vec4( .5,-.5,-.5,-.5);\n    \tv0100 = B*vec4(-.5, .5,-.5,-.5);\n    \tv0010 = B*vec4(-.5,-.5, .5,-.5);\n    \tv0001 = B*vec4(-.5,-.5,-.5, .5);\n    \tv1100 = B*vec4( .5, .5,-.5,-.5);\n    \tv1010 = B*vec4( .5,-.5, .5,-.5);\n    \tv1001 = B*vec4( .5,-.5,-.5, .5);\n#endif\n       \tvec3 res,\n            o = 3.*normalize(vec3(cos(time+4.*m.x), c1, s1*sin(time+4.*m.x))),\n             w = normalize(-o),\n        \t u = normalize(cross(w, vec3(0,1,0))), v = cross(u, w),\n         \t d = normalize(p.x * u + p.y * v + w+w), n, x;\n\n\t\tfloat t=0.;\n        \n        for(int i=0;i<56;i++) { \n            if (h<.003 || t>4.) break;\n            t += h = map(o+d*t).x;\n        }\n        // Rendering    \n        if (h <= .003) {\n            x = o + t * d;\n            res = map(x);\n            n = normal(x, d,t);\n\n            // Calculate Shadows\n          //  s = softshadow(x, L, 32.); // faster with soft shadow but need to find good params \n            float h;\n            for(int i=0;i<30;i++){\n                h = map(x+L*j).x;\n                j += clamp( h, .032, 1. );\n               \ts = min(s, h/j);\n             \tif(j>7.|| h<.001) break;\n            } \n            float ao= calcAO(x, n);\n            // Teserac color\n            vec3 co = (mod(res.y,.25)>.1?.7:1.) * mix(C1,C2, .5+1.2*res.z); \n            co*=ao;\n            if (res.y >= 0.)  k=1.-smoothstep(abs(res.z-WCurrent),-.002,.002);\n            // Shading\n            c = mix(c, mix(sqrt((clamp(3.*s,0.,1.)+.3)*co), vec3(pow(max(dot(reflect(L,n),d),0.),99.)),.4),2.*dot(n,-d));\n        } \n    }\n    \n\tvec4 col = vec4(c+vec3(2,2,.8)*k,1);\n   \n    if (q.x<.95) {\n    \tcol *= pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);\n    }\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2XDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[554, 663, 687, 687, 747], [749, 749, 784, 784, 818], [832, 850, 892, 892, 1071], [3187, 3209, 3244, 3244, 3338], [3340, 3369, 3404, 3404, 3430], [3432, 3474, 3512, 3512, 3626], [3628, 3673, 3714, 3714, 3823], [3826, 3891, 3909, 4140, 4535], [4537, 4565, 4605, 4605, 4802], [4805, 4805, 4858, 4858, 5074], [5076, 5076, 5125, 5290, 5783], [5786, 5823, 5880, 5880, 8740]]}
{"id": "Md2XRd", "name": "Isometric Maze", "author": "fizzer", "description": "Some more sizecoding doodling. I'm not finished with it (there are most likely more minifying transformations to be done) but I'm publishing it anyway! (p.s. I know, it's not truly isometric...)", "tags": ["isometric", "maze", "small"], "likes": 30, "viewed": 1049, "date": "1415155094", "time_retrieved": "2024-06-20T18:14:38.758460", "image_code": "mat2 z=mat2(1,1,1,-1);\nfloat m(vec2 p)\n{\n    return step(cos(1.257*(texture(iChannel0, floor(z*p*.1)/64.,-32.).r>.5?p.y:p.x)),.17);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = z * (fragCoord.xy / iResolution.y * 35. + iMouse.xy*.1 + iTime*vec2(1.8,1.08)),c = floor(p);\n    float s = step(1. - p.x + c.x, p.y - c.y), f = m(c), g = m(c + vec2(-1, 0) + s);s/=4.;\n\tfragColor.rgb = mix(vec3(1,.3,.25),vec3(1),m(c-z[1])+(g < f ? f*(.75-s) : g*(.5+s)));\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2XRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 23, 40, 40, 133], [134, 134, 191, 191, 477]]}
{"id": "MdBSWy", "name": "Grey Matter", "author": "daeken", "description": "Simplex noise rendered to look like brains.", "tags": ["simplex", "shaderforth", "brains"], "likes": 6, "viewed": 213, "date": "1415402889", "time_retrieved": "2024-06-20T18:14:39.073628", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\niResolution frag->position !=p =op\n\n:m light [ 0.81 0.80 0.70 ] ;\n:m dark [ 0.19 0.15 0.06 ] ;\n\np time .37 * sin 2 ** 3 * abs .5 + * time 2 / sin 2 * rotate-2d [ time .17 * time .37 * ] 5 * + =p\n&snoise-2d p gradient =v\n1 op [ .1 .2 ] - length - abs v 2 ** * 0 v 0 < select =spec\nlight dark v 1 + 2 / mix spec abs .3 * + ->fragcolor\n*/\n\nvec2 rotate_2d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec3 permute(vec3 x) {\n\treturn mod((x * 34. + 1.) * x, 289.);\n}\nfloat snoise_2d(vec2 v) {\n\tvec4 C = vec4(.211324865405187, .366025403784439, -.577350269189626, .024390243902439);\n\tvec2 i = floor(dot(v, C.yy) + v);\n\tvec2 x0 = v - i + dot(i, C.xx);\n\tvec2 i1 = x0.x > x0.y ? vec2(1., 0.) : vec2(0., 1.);\n\tvec4 x12 = x0.xyxy + C.xxzz - vec4(i1, 0., 0.);\n\ti = mod(i, 289.);\n\tvec3 p = permute(permute(vec3(0., i1.y, 1.) + i.y) + i.x + vec3(0., i1.x, 1.));\n\tvec3 m = max(.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\n\tm = m * m * m * m;\n\tvec3 x = 2. * fract(p * C.www) - 1.;\n\tvec3 h = abs(x) - .5;\n\tvec3 ox = floor(x + .5);\n\tvec3 a0 = x - ox;\n\tm = (1.79284291400159 - .85373472095314 * (a0 * a0 + h * h)) * m;\n\treturn dot(m, vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw)) * 130.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 var_0 = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tvec2 p = var_0;\n\tvec2 op = var_0;\n\tp = rotate_2d(p * (abs(pow(sin(iTime * .37), 2.) * 3.) + .5), sin(iTime / 2.) * 2.) + vec2(iTime * .17, iTime * .37) * 5.;\n\tvec2 h = vec2(.00001, 0.);\n\tfloat v = snoise_2d(p) / abs(length(vec2(snoise_2d(p + h) - snoise_2d(p - h), snoise_2d(p + h.yx) - snoise_2d(p - h.yx)) / (2. * h.x)));\n\tfloat spec = v < 0. ? abs(1. - length(op - vec2(.1, .2))) * pow(v, 2.) : 0.;\n\tfragColor = vec4(mix(vec3(.81, .80, .70), vec3(.19, .15, .06), (v + 1.) / 2.) + abs(spec) * .3, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBSWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 502, 535, 535, 633], [634, 634, 656, 656, 697], [698, 698, 723, 723, 1450], [1451, 1451, 1508, 1508, 2114]]}
{"id": "MdBSzt", "name": "Awful Graphics from 2014 ", "author": "Branch", "description": "Awful Graphics from 2014 ", "tags": ["awfulgraphicsfrom2014"], "likes": 1, "viewed": 604, "date": "1414838780", "time_retrieved": "2024-06-20T18:14:39.431288", "image_code": "float roundBox(vec2 coord, vec2 pos, vec2 b, float c ){\n  return 1.-floor(length(max(abs(coord-pos)-b,c)));\n}\nfloat circle(vec2 coord, vec2 pos, float size){\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 s = coord;\n\tfloat vignette = 1.0 / max(0.25 + 0.3*dot(coord,coord),1.);\n    \n\tvec3 COLOR =(vec3(0.9,0.4,0.5)\n        \t\t+vec3(0.2,0.5,0.2) );\n    if(mod(coord.y*200.+coord.x*200.,8.)<1.1){\n        COLOR -= vec3(0.05);\n    }else if(mod(coord.y*200.-coord.x*200.,8.)<1.1){\n        COLOR -= vec3(0.05);\n    }\n    \n    vec2 Xpos = vec2(1.1,-0.35);\n    COLOR += 3.*vec3(0.0,-2.0,-0.0)*sdCapsule(coord, vec2(-0.15,-0.15)+Xpos, vec2( 0.15, 0.15)+Xpos, 0.025);\n    COLOR += 3.*vec3(0.0,-2.0,-0.0)*sdCapsule(coord, vec2( 0.15,-0.15)+Xpos, vec2(-0.15, 0.15)+Xpos, 0.025);\n    \n    COLOR += 3.*vec3(0.1,-0.3,-0.3)*sdCapsule(coord, vec2(-1.7,-0.5), vec2( -0.7,-0.5), 0.025);\n    COLOR += 3.*vec3(1.)*sdCapsule(coord, vec2( -1.7,0.3), vec2( -0.7,0.3), 0.025);\n    COLOR -= 2.*vec3(1.)*sdCapsule(coord, vec2( -1.7,0.5), vec2( -0.7, 0.5), 0.025);\n    \n    float surface = texture(iChannel0, coord*length(coord)+vec2(sin(iTime),cos(iTime))).r;\n    COLOR -= vec3(1.)*circle(coord, vec2(0.0), surface);\n    if(circle(coord, vec2(0.0), .4)<0.)\n    \tCOLOR = vec3(1.9,0.97,0.4);\n    if(circle(coord, vec2(0.0), .3)<0.)\n    \tCOLOR = vec3(1.2,1.6,0.3);\n    \n    float total_circle = circle(coord, vec2(0.0), .08);\n    for(float i=0.0; i<3.141*2.0; i+=0.2*3.141){\n        total_circle += circle(coord, vec2(0.4*cos(i+iTime),0.4*sin(i+iTime)), .04);\n    }\n    if(total_circle<0.)\n    \tCOLOR = vec3(1.9,0.97,0.4);\n    vec2 position = vec2(0.0);\n    vec2 size = vec2(6.,2.);\n    float corner = 0.2;\n    if( roundBox(coord*5., position, size, corner ) < 1.)\n    COLOR =vec3(0.0);\n    \n    coord = vec2(mod(s.x,.999)-.333,mod(s.y,.75)-0.21);\n    \n\tfragColor = vec4( texture(iChannel0,s).rgb*.04+.7*COLOR*vignette\n         \t\t\t\t,1.0);\n} ", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBSzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 55, 55, 109], [110, 110, 157, 157, 211], [212, 212, 263, 263, 405], [406, 406, 432, 432, 564], [565, 565, 621, 621, 2537]]}
{"id": "MdjSzt", "name": "Anisotropic Shading", "author": "mAlk", "description": "ward's anisotropic specular reflectance model", "tags": ["2d", "anisotropic", "anisotropy"], "likes": 14, "viewed": 884, "date": "1415284580", "time_retrieved": "2024-06-20T18:14:39.437385", "image_code": "float WardAnisotropy (in vec3 vNormal, in vec3 vDirection, in vec3 vEye, in vec3 vLight,in vec2 Roughness) \n{    \n    vec3 A = normalize(vEye+vLight);\n    \n    float X = dot(A,normalize(cross(vNormal,vDirection)))/Roughness.x;\n    \n    float Y = dot(A,normalize(cross(vNormal,A)))/Roughness.y;\n    \n    float B = 1.0+dot(A,vNormal);\n    \n    float XY = -2.0*(pow(X,2.0)+pow(Y,2.0)) / B;\n    \n    float C = exp(XY) * (1.0/12.5664*Roughness.x*Roughness.y);\n    \n    return C * (1.0/sqrt(max(dot(vEye,vNormal),0.0)/max(dot(vLight,vNormal),0.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.yy;\n    \n    vec2 uvl = fragCoord.xy / iResolution.xy-0.5;\n    \n    //Cones  \n    float s1 = 1.0-clamp(length(uv*4.0-vec2(1.5,1.2)),0.0,1.0);\n    \n    float s2 = 1.0-clamp(length(uv*4.0-vec2(5.67,1.2)),0.0,1.0);\n        \n    float s3 = 1.0-clamp(length(uv*4.0-vec2(3.67,2.8)),0.0,1.0);\n    \n    float sph = s1+s2+s3;\n    \n    float spm = clamp((s1+s2+s3)*96.0,0.0,1.0);\n    \n    \n    //Normals\n    float dx = dFdx(sph)*iResolution.x/15.0*spm;\n    \n    float dy = dFdy(sph)*iResolution.x/15.0*spm;\n     \n    vec3 vNormal = normalize(vec3(dx,dy,sqrt(clamp(1.0-dx*dx-dy*dy,0.0,1.0))));\n\n    \n    //Shading\n    vec2 Roughness = vec2(0.2,0.8);\n\n\tvec3 Dir1 = normalize(vec3(fract(uv.x*4.0)-0.5,fract(uv.y*4.0)-0.5,0.0));\n    \n\tvec3 Dir2 = normalize(vec3(0.0,1.0,0.0));\n    \n    vec3 Dir3 = normalize(vec3(uv.x*4.0-5.67,uv.y*4.0-1.2,0.0));\n    \n    vec3 vLight = normalize(vec3(uvl.x+(0.5*sin(iTime)),uvl.y+(0.5*cos(iTime)),0.5));\n    \n    vec3 vEye = vec3(0.0,0.0,1.0);\n    \n    float sh = clamp(dot(vNormal,vLight),0.0,1.0);\n    \n    vec3 Dir = mix(mix(Dir1,Dir2,spm),Dir3,min(s1*48.0,1.0));\n    \n    vec3 sp = WardAnisotropy(vNormal,Dir,vEye,vLight,Roughness)*vec3(24.0);\n    \n    vec3 Color = vec3(0.15)+vec3(0.45)*sh+sp;\n    \n    fragColor = vec4(Color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjSzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 109, 109, 545], [547, 547, 604, 604, 1904]]}
{"id": "MdjXD3", "name": "Basic Twister", "author": "aji", "description": "plasmas and twisters and pastel color schemes, oh my", "tags": ["demo", "twister", "scene", "trope"], "likes": 5, "viewed": 236, "date": "1416782364", "time_retrieved": "2024-06-20T18:14:39.976811", "image_code": "#define M_PI_1_2 1.5707963267948966\n#define M_PI_2_2 3.141592653589793\n#define M_PI_3_2 4.71238898038469\n#define M_PI_4_2 6.283185307179586\n\n#define M_CORNER_1 2.356194490192345\n#define M_CORNER_2 3.9269908169872414\n#define M_CORNER_3 5.497787143782138\n\nvec4 pal1 = vec4(0.7, 1.0, 1.0, 1.0);\nvec4 pal2 = vec4(1.0, 0.7, 0.7, 1.0);\n\nvec4 palette(float v)\n{\n    float at = mod(v, 1.0) * 2.0;\n    float x = mod(at, 1.0);\n    float y = floor(at);\n    vec4 c1, c2;\n    \n    if (y < 1.0) {\n        c1 = pal1; c2 = pal2;\n    } else {\n        c1 = pal2; c2 = pal1;\n    }\n    \n    x *= M_PI_1_2;\n    x = sin(x) * sin(x);\n\n    return c1 * x + c2 * (1.0 - x);\n}\n\nvec4 background(float t, vec2 uv)\n{\n    return palette(\n        sin(sin(3.0 * t) * sin((2.2 + sin(2.0 * t)) * (2.0 * uv.x + sin(t + uv.y))                  \n\t\t\t+ sin(1.2 * t)) + cos(4.0 * uv.y + sin(t)))\n    );\n}\n\nfloat rotation(float t, float y)\n{\n    return 1.3 * sin(1.3 * t + 0.6 * y) + t;\n}\n\nvec2 decode(float rot)\n{\n    return vec2(\n        mod(rot, M_PI_1_2),\n        mod(rot / M_PI_1_2, 4.0)\n    );\n}\n\nvec3 parameters(float rot, float ctr, float sz)\n{\n    return vec3(\n        ctr + sz * cos(rot + M_CORNER_1),\n        ctr + sz * cos(rot + M_CORNER_2),\n        ctr + sz * cos(rot + M_CORNER_3)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat center = iResolution.x / 2.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 rotface = decode(rotation(iTime, uv.y));\n    float size = iResolution.x / 4.0;\n    vec3 params = parameters(rotface.x, center, size);\n    float face = 0.0;\n    float facepos = 0.0;\n    float norm = 0.0;\n    if (fragCoord.x < params.x || fragCoord.x > params.z) {\n        fragColor = background(iTime, uv);\n        return;\n    } else if (fragCoord.x < params.y) {\n        face = mod(rotface.y + 1.0, 4.0);\n        norm = (params.y - params.x) / size;\n        facepos = (fragCoord.x - params.x) / (params.y - params.x);\n    } else {\n        face = rotface.y;\n        norm = (params.z - params.y) / size;\n        facepos = (fragCoord.x - params.y) / (params.z - params.y);\n    }\n    \n    float vpos = sin(iTime + 0.2) + uv.y;\n\n    vec4 color = texture(iChannel0, vec2(facepos, vpos));;\n    if (face < 1.0) {\n        color *= vec4(1.0, 0.4, 0.0, 1.0);\n    } else if (face < 2.0) {\n        color *= vec4(0.0, 1.0, 0.4, 1.0);\n    } else if (face < 3.0) {\n        color *= vec4(0.4, 0.0, 1.0, 1.0);\n    } else {\n        color *= vec4(1.0, 0.0, 0.4, 1.0);\n    }\n    \n    vec4 ones = vec4(1.0,1.0,1.0,1.0);\n    color = ones - (ones - color) * (ones - color);\n    \n    fragColor = (color + vec4(0.2,0.2,0.2,0.2)) * (0.1 + 0.6 * norm);\n\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjXD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[331, 331, 354, 354, 649], [651, 651, 686, 686, 863], [865, 865, 899, 899, 946], [948, 948, 972, 972, 1059], [1061, 1061, 1110, 1110, 1261], [1263, 1263, 1320, 1320, 2639]]}
{"id": "MdjXDV", "name": "Folding", "author": "reinder", "description": "I was hoping that 'folding' the input domain of the distance function would lead to some elegant math. Unfortunately, the math isn't that elegant at all, and also it isn't stable for large folding-angles (hence the 'clipping hack' at lines 90 to 99).", "tags": ["distancefields", "folding", "paper", "inputdomain"], "likes": 12, "viewed": 1705, "date": "1416338272", "time_retrieved": "2024-06-20T18:14:39.983059", "image_code": "// Folding. Created by Reinder Nijhoff 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdjXDV\n//\n\n#define MARCHSTEPS 250\n#define PAPERHEIGHT 0.002\n#define PI 3.1415926\n\nfloat time;\n\n//----------------------------------------------------------------------\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle ) {\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n   \n    return vResult;\n}\n   \nvec3 RotateZ( const in vec3 vPos, const in float fAngle ) {\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n   \n    return vResult;\n}\n\n//----------------------------------------------------------------------\n// distance primitives\n\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------\n// Map functions\n\nvec3 fold( const in vec3 p, in float offset, const in float rot, in float a, const bool left ) {    \n    a = clamp( a, -PI, PI );\n    float b = PI-a;   \n    vec3 rp = p;\n\n    if( !left ) offset = -offset;\n    \n\trp.x -= offset;\n    rp = RotateY( rp, rot );\n    \n\tfloat angle = atan( rp.y, rp.x * (left?-1.:1.) );\n     \n    if( angle < 0. ) {\n        if(  angle >  - b * 0.5 ) {\n            rp = RotateZ( rp, a * (left?-1.:1.) );\n        }\n    } else {\n        if( angle - a < b * 0.5 ) {\n\t        rp = RotateZ( rp, a * (left?-1.:1.) );\n        }\n    }\n    \n    rp = RotateY( rp, -rot );      \n    rp += vec3(offset,0.,0.);\n    \n   \n    return rp;\n}\n\nfloat timedAngle( const in float starttime, const in float totaltime, const in float angle ) {\n\tfloat i = clamp( time - starttime, 0., totaltime );\n    return 3.1415926 * angle * i / totaltime;\n}\n\nfloat map( in vec3 p ) {\n    \n\t// folding input domain\n    p = fold( p, 0.,    0.,  \t\t   timedAngle( 6., 2., 0.25), false );\n    p = fold( p, 0.,    0.,  \t\t   timedAngle(10., 2., 0.25), true );\n    p = fold( p, -0.25,  0., \t\t   timedAngle( 8., 2.,-0.25), false  );\n    p = fold( p, -0.25,  0., \t\t   timedAngle(12., 2.,-0.25), true  );\n    \n    if( time < 6.  ) \n    \tp = fold( p, -1.4, PI*0.25,  timedAngle( 4., 2., -0.8 ) , true );\n    if( time < 4.  ) \n\t\tp = fold( p, -1.4, -PI*0.25, timedAngle( 2., 2., -0.8 ) , false );\n    \n    // just one paper plane\n    float d = sdBox( p, vec3( 1., PAPERHEIGHT, 1.4) );\n    \n    if( time >= 6.  ) { // clip the plane hack :(\n        vec3 po = p + vec3( 1.53, 0., 2.707 ); po = RotateY( po, PI*0.25 );\n        d = opS( d, sdBox( po, vec3( 2., 1., 2. ) ) );\n    } \n    \n    if( time >= 4.  ) { // clip the plane hack :(\n        vec3 po = p + vec3( -1.53, 0., 2.707 ); po = RotateY( po, PI*0.25 );\n        d = opS( d, sdBox( po, vec3( 2., 1., 2. ) ) );\n    } \n    \n\treturn d;\n}\n\n//----------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos ) {\n    const vec2 e = vec2(1.0,-1.0)*0.0025;\n\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t    e.yyx*map( pos + e.yyx )   + \n\t\t\t\t\t    e.yxy*map( pos + e.yxy )   + \n\t\t\t\t\t    e.xxx*map( pos + e.xxx )   );  \n    return n;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd ) {\n\tconst float maxd = 60.0;\n\tconst float precis = 0.001;\n    float d = precis*2.0;\n    float t = 0.;\n    float m = 1.;\n    \n    for( int i=0; i<MARCHSTEPS; i++ ) {\n\t    d = 0.2 * map( ro+rd*t );\n\t\tt+=d;\n        if( d<precis||t>maxd ) break;\n    \n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    time = mod( iTime + 8., 32. );\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n        \n    if (q.y < .12 || q.y >= .88) {\n\t\tfragColor=vec4(vec4(0.0));\n\t\treturn;\n\t}\n    \n    if ( time > 16. ) { time = 32.-time; }\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n\tvec3 ro = vec3(0.,1.75 + 0.25*sin( iTime * 0.42 ), 3.);\n    ro = RotateY( ro, iTime*0.05 );\n    vec3 ta = vec3( 0. ,0., 0. );\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n    \n    \n     vec3 col = vec3(0.01);\n\n    // raymarch\n    vec2 ints = intersect(ro ,rd );\n    if(  ints.y > -0.5 ) {\n        vec3 i = ro + ints.x * rd;\n        vec3 nor =  calcNormal( i );\n    \tcol = vec3(1.) * (0.1+0.9 * clamp(dot( nor, normalize(vec3(0.5, 0.8, 0.2))),0.,1.));\n\t}\n    \n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjXDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[279, 353, 412, 412, 581], [586, 586, 645, 645, 814], [816, 913, 946, 946, 968], [970, 970, 1007, 1007, 1098], [1100, 1191, 1287, 1287, 1838], [1840, 1840, 1934, 1934, 2035], [2037, 2037, 2061, 2091, 3053], [3055, 3129, 3161, 3161, 3391], [3393, 3393, 3435, 3435, 3738], [3740, 3740, 3797, 3797, 4916]]}
{"id": "MdjXRt", "name": "LED Watch [Barcode]", "author": "Nrx", "description": "Just a little experiment, to try mimic one of my LED watch.\n\nNote: The two bars on the left represent hours, the two on the right minutes. LEDs in the first bar count for 6, LEDs in the third bar count for 10; LEDs in the 2 other bars count for 1. :)", "tags": ["led", "watch"], "likes": 2, "viewed": 354, "date": "1415186636", "time_retrieved": "2024-06-20T18:14:40.467825", "image_code": "// LED watch: the two bars on the left represent hours, the two on the\n// right minutes. LEDs in the first bar count for 6, LEDs in the third\n// bar count for 10; LEDs in the 2 other bars count for 1.\n\n#define M_PI 3.1415926535897932384626433832795\n#define VERTICAL\n#define HSV2RGB_FAST\n\nfloat boxDist (in vec2 p, in vec2 b) {\n\treturn length (max (abs (p) - b, 0.0));\n}\n\nfloat boxDist (in vec2 p, in vec3 b) {\n\treturn length (max (abs (p) - b.xy + b.z, 0.0)) - b.z;\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * M_PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Get the fragment's position in the watch space\n\t#ifndef VERTICAL\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n\t#else\n\tvec2 frag = (2.0 * fragCoord.yx - iResolution.yx) / iResolution.y;\n\t#endif\n\tfrag *= 1.0 - vec2 (0.02, 0.04) * cos (frag.yx * 2.0) * max (0.0, 50.0 * sin (iTime * M_PI * 2.0 / 5.0) - 49.0);\n\t#ifndef VERTICAL\n\tfrag *= 8.0;\n\t#else\n\tfrag *= vec2 (6.0, -6.0);\n\t#endif\n\n\t// Define the panel and the border\n\tvec3 panelSize = vec3 (5.0, 2.2, 1.0);\n\tfloat panelDist = -boxDist (frag, panelSize);\n\tfloat borderDist = boxDist (frag, panelSize + 0.1);\n\n\t// Define the LEDs\n\tvec2 led = frag;\n\tled.x -= 0.5;\n\tvec2 ledId = floor (led);\n\tfloat random = rand (ledId);\n\tfloat ledThresholdBar2 = step (-1.5, ledId.y);\n\tfloat ledThresholdBar4 = step (0.5, ledId.y);\n\tfloat ledTimeModulo = 10.0 - 4.0 * ledThresholdBar2 - 2.0 * ledThresholdBar4;\n\tfloat ledMode = max (0.0, cos (iTime * 0.5));\n\tfloat ledIntensity = mix (0.8 * step (ledId.x + 6.0, mod (iDate.w / (60.0 + 540.0 * ledThresholdBar2 + 3000.0 * step (-0.5, ledId.y) + 18000.0 * ledThresholdBar4), ledTimeModulo)), 0.5 + 0.5 * cos (random + random * iTime + iTime), ledMode);\n\tfloat ledDist = boxDist (fract (led) - 0.5, vec2 (0.2, 0.03));\n\n\t// Create everything (panel, casing, small indicator and LEDs)\n\tvec3 color = vec3 (0.2, 0.2, 0.2) * (0.7 + 0.3 * cos (frag.x * M_PI / panelSize.x)) * smoothstep (0.1, 0.15, panelDist) * smoothstep (0.2, 0.25, abs (fract (frag.y) - 0.5));\n\tcolor += (0.4 + 0.2 * cos (frag.x + frag.y + iTime)) * smoothstep (0.1, 0.0, max (borderDist, panelDist));\n\tcolor += 0.3 * smoothstep (0.05, 0.0, boxDist (frag + vec2 (0.0, 1.9), vec3 (0.04, 0.1, 0.04)));\n\tcolor += mix (vec3 (0.1) * smoothstep (0.025, 0.0, ledDist), hsv2rgb (vec3 (random + iTime * 0.1, ledMode, 1.0)) * smoothstep (0.25, 0.0, ledDist), ledIntensity) * step (-4.5, frag.x) * step (5.5 - ledTimeModulo, -frag.x) * step (-2.0, -abs (frag.y));\n\n\t// Get the fragment's position in the background tile space\n\t#ifndef VERTICAL\n\tfrag = 15.0 * fragCoord.xy / iResolution.x;\n\t#else\n\tfrag = 15.0 * fragCoord.yx / iResolution.y;\n\t#endif\n\tfrag -= vec2 (iTime, sin (iTime));\n\n\t// Create the background tiles\n\trandom = rand (floor (frag));\n\tcolor += hsv2rgb (vec3 (random, 1.0, 1.0)) * smoothstep (0.6, 0.0, length (fract (frag) - 0.5)) * (0.2 + 0.2 * cos (random + random * iTime + iTime)) * smoothstep (0.0, 0.2, borderDist);\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjXRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 288, 326, 326, 369], [371, 371, 409, 409, 467], [469, 469, 497, 497, 834], [836, 836, 863, 863, 934], [936, 936, 992, 1044, 3451]]}
{"id": "MdSSDc", "name": "FloatingCircles", "author": "nonlogical", "description": "This is my very first shader attempt", "tags": ["circles"], "likes": 7, "viewed": 300, "date": "1416562429", "time_retrieved": "2024-06-20T18:14:40.467825", "image_code": "#define PI 3.141592\n\nfloat hash(float n) {return fract(sin(n * 0.021) * 43758.5453123);}//from iq\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    mo -= 0.5;\n    mo.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * 0.5;\n    \n    float subd = 15.0;\n    float radius = 0.5;\n    vec3  color = vec3(0.0);\n    \n    float hsub = subd*2.0;\n    vec2 grid = uv * subd;\n    grid = vec2(floor(grid.x)/subd, floor(grid.y)/subd);\n    vec2 gridC = vec2(grid.x + 1.0/hsub, grid.y+1.0/hsub);\n    \n    vec2 mDist = vec2(sin(time)*0.5, cos(time)*0.3) - grid;\n    \n    float weight = 0.0;\n    if(length(mDist) < radius) {\n        weight = smoothstep(0.0, 0.3, max(0.0, radius - length(mDist)));\n    }\n    \n    float qbRadius = clamp(0.5*smoothstep(0.5, 0.1, length(mDist)), 0.2, 0.5);\n    float qbWeight = 0.85*smoothstep(0.5, 0.1, length(mDist));   \n    \n    vec2 cellD = uv - gridC;\n\tfloat finalRadius = qbRadius/subd;\n    float rings = 0.0;\n    if(length(cellD) < qbRadius/subd) {\n        float col = 0.0;\n        col = smoothstep(1.0,0.9,length(cellD)/(qbRadius/subd));\n        col -= 1.0*smoothstep(1.0,0.9,length(cellD)/(qbRadius/subd*qbWeight));\n        \n        rings += col;\n    }\n        \n    color = \n        vec3(0.03) \n        + rings*vec3(grid.x+0.7, grid.y+0.7, 0.7)*0.1\n        + rings*weight*vec3(grid.x+0.7, grid.y+0.7, 0.7)*2.0\n        + weight*vec3(grid.x+0.5, grid.y+0.5, 0.5)*0.3;\n    \n    fragColor = vec4(color.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSSDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[21, 21, 42, 42, 88], [88, 99, 156, 156, 1606]]}
{"id": "MdSSzt", "name": "SuperNova", "author": "Passion", "description": "I was trying to do some plane deformation but came up with this instead.\nReference - https://www.shadertoy.com/view/XsX3Rn", "tags": ["2d", "texture"], "likes": 15, "viewed": 408, "date": "1414823775", "time_retrieved": "2024-06-20T18:14:40.467825", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    float t = iTime*.5;\n    vec2 p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n    p *= .8;\n    \n    float x = p.x*cos(t)-p.y*sin(t);\n    float y = p.x*sin(t)+p.y*cos(t);\n     \n    vec2 uv = 0.2*vec2(x,y)/abs(y*8.);\n    uv.y += .01*iTime;\n    uv.x += .1*iTime;\n\t\n\tfloat w = max(-0.3, 0.3-abs(y) );\n    float w2 = max(-0.6, 0.4-abs(x) );\n    vec4 tex1 = texture(iChannel0,uv*3.);\n    vec4 tex2 = texture(iChannel2,uv*4.);\n    \n\tfragColor = vec4( mix(tex1,tex2,sin(t)).xyz+w+w2, 1.0);\n    \n}\n\n// 2014 - Passion\n// Reference - https://www.shadertoy.com/view/XsX3Rn\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSSzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 551]]}
{"id": "Ms2SDc", "name": "Structures", "author": "rez", "description": "my very first raymarching scene!\n100% try/error/repeat code, it was very fun to do and finally I ended up with something (I hope) not so bad :3\n\"original\" version (with tons of post-process) here: http://www.pouet.net/prod.php?which=59105", "tags": ["raymarching"], "likes": 45, "viewed": 3765, "date": "1416851663", "time_retrieved": "2024-06-20T18:14:40.467825", "image_code": "const float PI=3.14159265358979323846;\nconst float value=0.0;\n\nfloat rand(in vec2 p,in float t)\n\t{\n\treturn fract(sin(dot(p+mod(t,1.0),vec2(12.9898,78.2333)))*43758.5453);\n\t}\n\nvec2 rotate(vec2 k,float t)\n\t{\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n\t}\n\nfloat scene1(vec3 p)\n\t{\n\tfloat speed=iTime*0.5;\n\tfloat ground=dot(p,vec3(0.0,1.0,0.0))+0.75;\n\tfloat t1=length(abs(mod(p.xyz,2.0)-1.0))-1.35+0.05*cos(PI*p.x*4.0)+0.05*sin(PI*p.z*4.0);\t// structure\n\tfloat t3=length(max(abs(mod(p.xyz,2.0)-1.0).xz-1.0,0.5))-0.075+0.1*cos(p.y*36.0);\t\t\t// structure slices\n\tfloat t5=length(abs(mod(p.xyz,0.5))-0.25)-0.975;\n\tfloat bubble_w=0.8+0.2*cos(PI*p.z)+0.2*cos(PI*p.x);\n\tfloat bubble=length(mod(p.xyz,0.125)-0.0625)-bubble_w;\n\tfloat hole_w=0.05;\n\tfloat hole=length(abs(mod(p.xz,1.0)-0.5))-hole_w;\n\tfloat tube_p=2.0-0.25*sin(PI*p.z*0.5);\n\tfloat tube_v=PI*8.0;\n    float tube_b=tube_p*0.02;\n\tfloat tube_w=tube_b+tube_b*cos(p.x*tube_v)*sin(p.y*tube_v)*cos(p.z*tube_v)+tube_b*sin(PI*p.z+speed*4.0);\n\tfloat tube=length(abs(mod(p.xy,tube_p)-tube_p*0.5))-tube_w;\n\treturn min(max(min(-t1,max(-hole-t5*0.375,ground+bubble)),t3+t5),tube);\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n\tfloat speed=iTime*0.5;\n    float ground_x=1.5*cos(PI*speed*0.125);\n    float ground_y=4.0-3.0*sin(PI*speed*0.125)+0.125*value;\n    float ground_z=-1.0-speed;\n\tvec2 position=fragCoord.xy/iResolution.xy;        \n\tvec2 p=-1.0+2.0*position;\n\tvec3 dir=normalize(vec3(p*vec2(1.625,1.0),0.75));\t// screen ratio (x,y) fov (z)\n\tdir.yz=rotate(dir.yz,PI*0.25*sin(PI*speed*0.125)-value*0.25);\t// rotation x\n\tdir.zx=rotate(dir.zx,PI*cos(-PI*speed*0.05));\t\t// rotation y\n\tdir.xy=rotate(dir.xy,PI*0.125*cos(PI*speed*0.125));\t// rotation z\n\tvec3 ray=vec3(ground_x,ground_y,ground_z);\n\tfloat t=0.0;\n\tconst int ray_n=96;\n\tfor(int i=0;i<ray_n;i++)\n\t\t{\n\t\tfloat k=scene1(ray+dir*t);\n        if(abs(k)<0.005) break;\n\t\tt+=k*0.5;\n\t\t}\n\tvec3 hit=ray+dir*t;\n\tvec2 h=vec2(-0.02,0.01); // light\n\tvec3 n=normalize(vec3(scene1(hit+h.xyy),scene1(hit+h.yxx),scene1(hit+h.yyx)));\n\tfloat c=(n.x+n.y+n.z)*0.1;\n\tvec3 color=vec3(c,c,c)-t*0.0625;\n    //color*=0.6+0.4*rand(vec2(t,t),iTime); // noise!\n\tfragColor=vec4(vec3(c+t*0.08,c+t*0.02,c*1.5-t*0.01)+color*color,1.0);\n\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2SDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[63, 63, 98, 98, 173], [175, 175, 205, 205, 267], [269, 269, 292, 292, 1134], [1136, 1136, 1194, 1194, 2231]]}
{"id": "Ms2SWc", "name": "My astronaut", "author": "Lio", "description": "my first attempt to create an object", "tags": ["raymarching", "tagsprocedural"], "likes": 2, "viewed": 184, "date": "1416797598", "time_retrieved": "2024-06-20T18:14:40.473888", "image_code": "// ÃÂÃÂ´ÃÂµÃÂ»ÃÂ°ÃÂ½ÃÂ¾ ÃÂ½ÃÂ° ÃÂ¾ÃÂÃÂ½ÃÂ¾ÃÂ²ÃÂµ https://www.shadertoy.com/view/4sfGzj\nconst int MAX_ITER = 55;\n//-------------------------------------------\n#define time iTime\n\n//--------------------------------------------------\n// ÃâÃâ¬ÃÂ°Ãâ°ÃÂµÃÂ½ÃÂ¸ÃÂµ - ÃÂ¿ÃÂµÃâ¬ÃÂµÃÂÃâ¡ÃÂµÃâ ÃÂ¼ÃÂ°ÃâÃâ¬ÃÂ¸Ãâ Ãâ¹\n//--------------------------------------------------\nvec3 rotationCoord(vec3 n, float paramRotate)\n{\n vec3 result;\n //--------------------------------------------\n   float t = time;\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   if(paramRotate <= 0.1)\n   {\n\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0,  1.0,  0.0,\n                      0.0,  0.0,  1.0);   \n   }\n   else if(paramRotate <= 1.0)\n   {\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0, sc.y,-sc.x,\n                      0.0, sc.x, sc.y);\n   }\n   else if(paramRotate <= 2.0)\n   {\n       rotate = mat3(  1.0,  0.0,  0.0,\n                       0.0, sc.y,sc.x,\n                       0.0, -sc.x, sc.y);  \n   }\n   else if (paramRotate <= 3.0)\n   {\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n   }\n   else if (paramRotate <= 4.0)\n   {\n      rotate = mat3( sc.y,  0.0, sc.x,\n                     0.0,   1.0,  0.0,\n                    -sc.x,  0.0, sc.y);   \n   }   \n   else if (paramRotate <= 5.0)\n   {\n       rotate = mat3( sc.y,sc.x,  0.0,\n                     -sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }   \n   else if (paramRotate <= 6.0)\n   {\n       rotate = mat3( sc.y,-sc.x, 0.0,\n                      sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }     \n   else\n   {\n   mat3 rotate_x = mat3(  1.0,  0.0,  0.0,\n                          0.0, sc.y,-sc.x,\n                          0.0, sc.x, sc.y);\n   //sc = vec2(sin(t), cos(t));\n   mat3 rotate_y = mat3( sc.y,  0.0, -sc.x,\n                         0.0,   1.0,  0.0,\n                         sc.x,  0.0,  sc.y);\n  // sc = vec2(sin(t), cos(t));\n   mat3 rotate_z = mat3( sc.y, sc.x,  0.0,\n                        -sc.x, sc.y,  0.0,\n                         0.0,  0.0,   1.0);\n   rotate = rotate_z * rotate_y * rotate_z;                \n   }\n  result = n * rotate;\n  return result;\n}\n//-------------------------------------------------- ÃÅ¸ÃÂ¾ÃÂ»ÃÆÃâ¡ÃÂµÃÂ½ÃÂ¸ÃÂµ Ãâ ÃÂ²ÃÂµÃâÃÂ° Ãâ¡ÃÂ°ÃÂÃâÃÂµÃÂ¹ ÃÂ¾ÃÂ±ÃÅ ÃÂµÃÂºÃâÃÂ°\nvec3 getmaterial(vec3 p, float mat)\n{\n   vec3 p1 = rotationCoord(p, 7.);\n    \n    if (mat < 0.5)\n      return vec3(0.4662, 0.4565, 0.4488);\n   else if (mat < 1.5)\n      return vec3(0, 0, 0);   \n   else if (mat < 2.5)\n      return vec3(floor(length(floor(mod(p1, 2.0)+0.5))-0.5));\n   else if (mat < 3.5)\n      return vec3(0.8392, 0.0629,1.0);\n   else if (mat < 4.5)\n      return vec3(0.6289, 0.7216, 1.0);  \n   return vec3(0.3, 0.9,0.5);\n}\n//--------------------------------------------------ÃÂ¡ÃÂºÃâ¬ÃÆÃÂ³ÃÂ»ÃÂµÃÂ½ÃÂ½Ãâ¹ÃÂ¹ Ãâ ÃÂµÃÂ»ÃÂ¸ÃÂ½ÃÂ´Ãâ¬\n// capsule in Y axis\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n//--------------------------------------------------ÃÅ¡ÃÂ¾ÃÂ½ÃÆÃÂ\nfloat dist_cone( vec3 p, float r, float h )\n{\n   vec2 c = normalize( vec2( h, r ) );\n    float q = length(p.xy);\n    return max( dot(c,vec2(q,p.z)), -(p.z + h) );\n}\n//--------------------------------------------------\nfloat disttube(vec2 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------ÃÂ¨ÃÂ°Ãâ¬\nfloat distsphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------ÃÂ¢ÃÂ¾Ãâ¬\nfloat disttorus(vec3 p, vec2 t)\n{\n   vec2 q = vec2(length(p.xz) - t.x, p.y);\n   return length(q) - t.y;\n}\n//----------------------------------------------------ÃÅ¡ÃÆÃÂ±\nfloat distbox(vec3 p, vec3 b)\n{\n   return length(max(abs(p) - b, 0.0));\n}\n//----------------------------------------------------ÃâÃâ¬ÃÂ°Ãâ°ÃÂµÃÂ½ÃÂ¸ÃÂµ ÃÂ´ÃÂµÃâÃÂ°ÃÂ»ÃÂ¸\nvec2 rotate(vec2 v, float a) {\n   return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n//----------------------------------------------------\n\nvec2 astronaut(vec3 p)\n{\n   float material = 0.;\n //  p.y -= tmpY;    // ÃËÃÂ·ÃÂ¼ÃÂµÃÂ½ÃÂµÃÂ½ÃÂ¸ÃÂµ ÃÂ¿ÃÂ¾ÃÂ»ÃÂ¾ÃÂ¶ÃÂµÃÂ½ÃÂ¸ÃÂ ÃÂ²ÃÂÃÂµÃÂ³ÃÂ¾ ÃÂ¾ÃÂ±ÃÅ ÃÂµÃÂºÃâÃÂ° ÃÂ¿ÃÂ¾ Y   \n   vec3 r1 = vec3(rotate(p.xz, 0.1), p.y); // ÃÂ¢ÃÆÃâ ÃÂ¼ÃÂ¾ÃÂ¶ÃÂ½ÃÂ¾ ÃÂ¾ÃâÃâ¬ÃÂµÃÂ³ÃÆÃÂ»ÃÂ¸Ãâ¬ÃÂ¾ÃÂ²ÃÂ°ÃâÃÅ ÃÂ½ÃÂ°ÃÂºÃÂ»ÃÂ¾ÃÂ½\n   vec3 pAbs = p;\n   // ÃÂ·ÃÂµÃâ¬ÃÂºÃÂ°ÃÂ»ÃÂ¾\n   pAbs.x = abs(pAbs.x);\n   float d = 1.;\n\n   // head ÃÂ³ÃÂ¾ÃÂ»ÃÂ¾ÃÂ²ÃÂ°\n //  d = min(d, distsphere(p * tmpSize + tmpOffset, tmpRadius));\n   d = min(d, distsphere(p * vec3(1.0) + vec3(0.0, 2.5, 0.0), 1.));\n   float maska =   min(d, distsphere(p * vec3(1.2, 2.0, 1.8) + vec3(0, 4.7, -1.), 1.));\n   // body ÃâÃÂµÃÂ»ÃÂ¾\n   d = min(d, distsphere(p * vec3(1.1, 0.5, 1.1) + vec3(0, 0.2, 0), 1.0));   \n   // arms Ãâ¬ÃÆÃÂºÃÂ¸\n   d = min(d, distsphere(pAbs * vec3(1.8, 1.2, 1.8) + vec3(-1.3, 0.7, 0), 1.0));\n   float arms = min(d, distsphere(pAbs * vec3(1.9, -3.2, 1.9) + vec3(-1.0, 0.5, -0.4), 1.0)/1.6);   \n   // feet ÃÂ½ÃÂ¾ÃÂ³ÃÂ¸\n   d = min(d, distsphere(pAbs * vec3(1.8, -0.6, 1.8) + vec3(-0.8, 0.9, 0), 1.0));\n   float feet = min(d, distsphere(pAbs * vec3(3.0, -3., 1.6) + vec3(-1.4, 9.0, -0.5), 1.0)/1.6);\n   //ÃÂ ÃÅ½ÃÂºÃÂ·ÃÂ°ÃÂº\n   float baul = min(d, max(distbox(p + vec3(0, 0.8, 0.9), vec3(0.6)), \n                  disttorus(p.yzx + vec3(1.0, 1.4, 0), vec2(0.4, 0.8))));\n    // ÃÂ¢Ãâ¬ÃÆÃÂ±ÃÂºÃÂ¸\n    float trubka =  min(d, max(distbox(p + vec3(0, 2.0, 0.9), vec3(0.7)), \n                  disttorus(pAbs.yzx + vec3(1.0, 1.4, 0.5), vec2(1.0, 0.1)))); \n   trubka = min(trubka, max(distsphere(r1 + vec3(0.9, 0.4, 1.6), 1.3), \n                  disttube(r1.xz + vec2(0.1, 1.85), 0.1)));    \n   \n\n   if (maska < d) material = 4.0; \n   else if (baul < d) material = 4.0;\n   else if(trubka < d) material = 4.0; \n   else if(arms < d) material = 0.0;\n   else if (feet < d)material = 0.0;\n   else material = 3.0;\n   \n   d = min(d, maska); \n   d = min(d, baul); \n   d = min(d, trubka);        \n   d = min(d, arms);  \n   d = min(d, feet);     \n   return vec2(d, material);\n}\n//--------------------------------------------------\n//----------------------------------------------------\nvec2 rocket(vec3 p)      \n{\n   p.y = 1.- p.y + 0.5;\n   float material = 3.0;\n   float korpus = 1., sopla = 1.;\n   vec3 r1 = vec3(rotate(p.xz, 0.), p.y);    float d = 1.;\n   d =   min(d, capsuleY( p -  vec3(0, 1., 0.0), 0.9, 2.3));     \n   korpus = min(d, distbox(p -  vec3(0, 1.7, 0.0), vec3(0.75, 2.0, 0.75))); \n   korpus =   min(korpus, dist_cone(   r1 + vec3(0.0, 0., -5.5) , 0.9, 1.9 ));   \n\n vec3 pos = r1;\n pos.y = abs(pos.y); \n korpus =  min(korpus, dist_cone( pos + vec3(0.50, -0.55, 0.0) , 0.5, 1.4 ));   \n korpus =  min(korpus, dist_cone( pos + vec3(-0.50, -0.55, 0.0) , 0.5, 1.4 ));   \n \n  p.z = abs(p.z);\n  korpus =   min(korpus, distsphere(p + vec3(0.00, -2.7, -0.5), 0.55));   \n  korpus =   min(korpus, distsphere(p + vec3(0.00, -1.5, -0.5), 0.55));  \n  //--------------------------------\n  if(korpus < d)material = 4.0; \n  if(sopla < d)material = 3.0; \n  d = min(d, korpus); \n   return vec2(d, material);\n\n}\n//--------------------------------------------------\nvec2 station(vec3 p)     \n{\n\n   vec3 r1 = vec3(rotate(p.xz, 1.55), p.y); \n   float material = 2.;\n   float korpus = 1.;\n   float d = 1.;\n   korpus = disttorus(p.zxy  * vec3(1.06, -0.42, 1.), vec2(2.5, 0.2));\n   korpus = min(korpus, disttorus(p.yzx * vec3(1.06, -0.42, 1.) , vec2(2.5, 0.2))); \n   korpus = min(korpus, disttorus(p  * vec3(1.06, -0.42, 1.), vec2(2.5, 0.2))); \n  d = min(d, distsphere(p  , 2.0));     \n  d = min(d, distsphere(p - vec3(0.0, -2.5, 0.0) , 0.5));\n\n  vec3 pAbs = p;\n  pAbs.x = abs(pAbs.x); \n  d = min(d, distsphere(pAbs - vec3(2.5, 0.0, 0.0) , 0.4));\n\n  pAbs = r1;\n  pAbs.x = abs(pAbs.x);\n  d = min(d, distsphere(pAbs - vec3(2.5, 0.0, 0.0) , 0.4)); \n  //--------------------------------\n  if(korpus < d)material = 4.0; \n  d = min(d, korpus); \n  return vec2(d, material);\n\n}\n\n//-------------------------------------------------\n// ÃÂ¡ÃÂºÃâ¬ÃÆÃÂ³ÃÂ»ÃÂµÃÂ½ÃÂ½Ãâ¹ÃÂ¹ ÃÂºÃÂ²ÃÂ°ÃÂ´Ãâ¬ÃÂ°Ãâ\nfloat lengthN(vec3 v, float n)\n{\n  vec3 tmp = pow(abs(v), vec3(n));\n  return pow(tmp.x+tmp.y+tmp.z, 1.0/n);\n}\n//-------------------------------------------------\n// ÃÂ²Ãâ¹ÃÂ²ÃÂ¾ÃÂ´ ÃÂ¾ÃÂ±ÃÅ ÃÂµÃÂºÃâÃÂ°\nvec2 renderFunction(vec3 pos)\n{\n  vec3 pos1 = pos; \n pos1 = rotationCoord(pos, 3.0);      // ÃÅ¸ÃÂµÃâ¬ÃÂµÃÂÃâ¡ÃÂµÃâ ÃÂºÃÂ¾ÃÂ¾Ãâ¬ÃÂ´ÃÂ¸ÃÂ½ÃÂ°Ãâ ÃÂ´ÃÂ»ÃÂ ÃÂ²Ãâ¬ÃÂ°Ãâ°ÃÂµÃÂ½ÃÂ¸ÃÂ\n vec2 result;\n vec2 astr =  astronaut(pos1);\n\n pos1 = rotationCoord(pos, 2.0); \n pos1.x -= 8.5;\n vec2 roket = rocket(pos1);\n \n pos1 = rotationCoord(pos, 7.0);  \n pos1.x += 4.0;  \n vec2 stat = station(pos1);\n\n  result = (astr.x < roket.x) ? astr : roket;\n  result = (result.x < stat.x) ? result : stat;\n  return result;\n\n\n}\n//-------------------------------------------------\nvec3 getNormal(vec3 p)\n{\n  const float d = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        renderFunction(p+vec3(d,0.0,0.0)).x - renderFunction(p+vec3(-d,0.0,0.0)).x,\n        renderFunction(p+vec3(0.0,d,0.0)).x - renderFunction(p+vec3(0.0,-d,0.0)).x,\n        renderFunction(p+vec3(0.0,0.0,d)).x - renderFunction(p+vec3(0.0,0.0,-d)).x\n      )\n    );\n}\n//-------------------------------------------------\nvec3 getlighting(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n   float b = max(0.0, dot(normal, lightDir));\n   return b * color;\n}\n//-------------------------------------------------\nvec3 getlightingPhong(in vec3 pos,in vec3 camPos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n   vec3  specColor = vec3(0.2126, 0.9023, 0.2128);\n   float specPower = 12.0;\n    \n    vec3   l = normalize (lightDir-pos);                  \n    vec3   v = normalize(camPos-pos);\n    vec3   n = normalize (normal); \n    vec3   r = reflect ( -l, n ); \n    vec3 diff = color * max ( dot ( n, l ), 0.0 );\n    vec3 spec = specColor * pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    \n    return diff + spec;\n}\n//-------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pos =   ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n  pos.y = 1.0 - pos.y - 1.0;\n  \n  vec3 camPos =  vec3(0.0, 0.0, 9.0);\n  vec3 camDir = vec3(0.0, 0.0, -1.0);\n  vec3 camUp = vec3(0.0, 1.0, 0.0);  \n  vec3 camSide = cross(camDir, camUp);\n  float focus = 1.8;//1.8\n \n  vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir/* *focus*/);\n \n  float t = 0.0;\n  vec2 object = vec2(1., 1.);\n//------------------------------\n\n  vec3 posOnRay = camPos;\n//------------------------------ \n  for(int i=0; i<MAX_ITER; ++i)\n  {\n\n    object = renderFunction(posOnRay);\n    t += object.x;\n    posOnRay = camPos + t*rayDir;    \n  }\n//------------------------------ \n\n  if(abs(object.x) < 0.01)\n  {\n    vec3 materialColor = getmaterial(posOnRay.xyz, object.y); \n    vec3 normal = getNormal(posOnRay);                        \n  //  vec3 lightDir = -rayDir;\n  //  vec3 color = getlighting(posOnRay.xyz, normal, lightDir, materialColor);  \n\n  vec3 lightDir =  vec3(5.0, 0.0, 4.0);\n  vec3 color = getlightingPhong(posOnRay, camPos, normal, lightDir, materialColor); // ÃÅ¸ÃÂ¾ ÃÂ¤ÃÂ¾ÃÂ½ÃÂ³ÃÆ   \n  \n  fragColor = vec4(color, 1.0);\n  }else\n  {\n   fragColor = vec4(0.5);// \n  }\n}\n  \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2SWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[195, 411, 458, 458, 2309], [2310, 2481, 2518, 2518, 2919], [2920, 3071, 3113, 3113, 3172], [3173, 3246, 3291, 3291, 3410], [3411, 3464, 3497, 3497, 3524], [3525, 3593, 3628, 3628, 3655], [3656, 3724, 3757, 3757, 3829], [3830, 3897, 3928, 3928, 3970], [3971, 4087, 4117, 4117, 4186], [4187, 4243, 4267, 4267, 6375], [6376, 6484, 6511, 6511, 7406], [7407, 7460, 7487, 7487, 8258], [8260, 8393, 8425, 8425, 8502], [8503, 8610, 8641, 8641, 9148], [9149, 9201, 9225, 9225, 9567], [9568, 9620, 9700, 9700, 9769], [9770, 9822, 9922, 9922, 10329], [10330, 10382, 10439, 10439, 11627]]}
{"id": "Ms2SWG", "name": "Sewer", "author": "TheJimJames40", "description": "Just a simple sewer, it smells bad in here.", "tags": ["simple", "tunnel", "sewer"], "likes": 1, "viewed": 158, "date": "1415638666", "time_retrieved": "2024-06-20T18:14:40.473888", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.x;\n    \n    vec2 c = uv;\n\n    c.x += sin(time/5.0)/4.0;\n    c.y += cos(time/3.0)/4.0;\n    \n    vec2 p = vec2(0,0);\n    p.y = 1.0/length(c*4.0);\n    float angle = atan(c.x,c.y);\n    p.x = angle/4.0;\n    p.y += time/8.0;\n    vec4 color = mix(texture(iChannel0,p),texture(iChannel1,p),0.3);\n    \n  \tvec4 water = vec4(1.0,0.5,0.0,1.0)*0.1;\n    color = mix(color,water,smoothstep(0.0,0.08,sin(p.y*8.0+time*3.0)*0.02+(abs(angle)-2.0)));\n    color *= min(1.0,(c.x*c.x+c.y*c.y));\n\tfragColor = color;\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2SWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 634]]}
{"id": "Ms2XRt", "name": "Wavelength color conversion", "author": "BeRo", "description": "Various color wavelengths to XYZ and *RGB conversion functions", "tags": ["rgb", "xyz", "wavelength"], "likes": 7, "viewed": 583, "date": "1415109208", "time_retrieved": "2024-06-20T18:14:41.273838", "image_code": "// Various color wavelengths to XYZ and *RGB conversion functions\n// Copyright (C) 2014 by Benjamin 'BeRo' Rosseauc\n// Because the german law knows no public domain in the usual sense,\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvec3 wl2rgbTannenbaum(float w){\n  vec3 r;\n  if(w < 350.0){\n    r = vec3(0.5, 0.0, 1.0);\n  }else if((w >= 350.0) && (w < 440.0)){\n    r = vec3((440.0 - w) / 90.0, 0.0, 1.0);\n  }else if((w >= 440.0) && (w <= 490.0)){\n    r = vec3(0.0, (w - 440.0) / 50.0, 1.0);\n  }else if((w >= 490.0) && (w < 510.0)){\n    r = vec3(0.0, 1.0, (-(w - 510.0)) / 20.0);\n  }else if ((w >= 510.0) && (w < 580.0)){\n    r = vec3((w - 510.0) / 70.0, 1.0, 0.0);\n  }else if((w >= 580.0) && (w < 645.0)){\n    r = vec3(1.0, (-(w - 645.0)) / 65.0, 0.0);\n  }else{    \n    r = vec3(1.0, 0.0, 0.0);\n  }\n  if(w < 350.0){\n    r *= 0.3;\n  }else if((w >= 350.0) && (w < 420.0)){\n    r *= 0.3 + (0.7 * ((w - 350.0) / 70.0));\n  }else if((w >= 420.0) && (w <= 700.0)){\n    r *= 1.0;\n  }else if((w > 700.0) && (w <= 780.0)){\n    r *= 0.3 + (0.7 * ((780.0 - w) / 80.0));\n  }else{\n    r *= 0.3;\n  }\n  return r;\n}\n\n\nvec3 wl2xyzCIE1931(const in float w){\n  // based on the informations from http://jcgt.org/published/0002/02/01/paper.pdf\n  vec4 t = vec4((w - 446.8) / 19.44, (w - 595.8) / 33.33, (log(w) - log(556.3)) / 0.075, (log(w) - log(449.8)) / 0.051);  \n  t = vec4(0.366, 1.065, 1.014, 1.839) * exp((-0.5) * (t * t));\n  return vec3(t.x + t.y, t.zw);\n}\n\nvec3 wl2xyzCIE1931Approximation(const in float w){\n  // based on the informations from http://jcgt.org/published/0002/02/01/paper.pdf\n  vec3 xc = vec3((w - 442.0) *((w < 442.0) ? 0.0624 :0.0374), (w - 599.8) * ((w < 599.8) ? 0.0264 :0.0323), (w - 501.1) *((w < 501.1) ? 0.0490 :0.0382));\n  vec2 yc = vec2((w - 568.8) * ((w < 568.8) ? 0.0213 : 0.0247), (w - 530.9) * ((w < 530.9) ? 0.0613 : 0.0322));\n  vec2 zc = vec2((w - 437.0) * ((w < 437.0) ? 0.0845 : 0.0278), (w - 459.0) * ((w < 459.0) ? 0.0385 : 0.0725));\n  xc *= xc;  \n  yc *= yc;  \n  zc *= zc;  \n  return vec3(dot(vec3(0.362, 1.056, -0.065) * exp((-0.5) * xc), vec3(1.0)), dot(vec2(0.821, 0.286) * exp((-0.5) * yc), vec2(1.0)), dot(vec2(1.217, 0.681) * exp((-0.5) * zc), vec2(1.0)));\n}\n\n    \nvec3 wl2xyzCIE1964(const in float w){\n  // based on the informations from http://jcgt.org/published/0002/02/01/paper.pdf\n  vec4 t = vec4(log((w + 570.1) / 1014.0), log((1338.0 - w) / 743.5), (w - 556.1) / 46.14, log((w - 265.8) / 180.4));  \n  t = vec4(0.398, 1.132, 1.011, 2.060) * exp(vec4(-1250.0, -234.0, -0.5, -32.0) * (t * t));\n  return vec3(t.x + t.y, t.zw);\n}\n\n// based from the informations from CIE RGB http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html \nconst mat3 SRGB2XYZ = mat3(0.4124564, 0.3575761, 0.1804375,\n                           0.2126729, 0.7151522, 0.0721750,\n                           0.0193339, 0.1191920, 0.9503041);\n\n// based from the informations from CIE RGB http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html \nconst mat3 XYZ2SRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                           -0.9692660, 1.8760108, 0.0415560,\n                           0.0556434, -0.2040259, 1.0572252);\n\n// based from the informations from CIE RGB http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html \nconst mat3 CIERGB2XYZ = mat3(0.4887180, 0.3106803, 0.2006017,\n                             0.1762044, 0.8129847, 0.0108109,\n                             0.0000000, 0.0102048, 0.9897952);\n\n// based from the informations from CIE RGB http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html \nconst mat3 XYZ2CIERGB = mat3(2.3706743, -0.9000405, -0.4706338,\n                             -0.5138850, 1.4253036,  0.0885814,\n                             0.0052982, -0.0146949, 1.0093968);\n                           \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(wl2xyzCIE1931(uv.x * 1000.0) * XYZ2CIERGB, 1.0);\n\t//fragColor = vec4(wl2xyzCIE1931Approximation(uv.x * 1000.0) * XYZ2SRGB, 1.0);\n    float t = iTime; \n\tfragColor = vec4(mix(mix(mix(wl2xyzCIE1931Approximation(uv.x * 1000.0) * XYZ2SRGB,\n                                    wl2xyzCIE1931(uv.x * 1000.0) * XYZ2SRGB,\n                                   (sin(t * (4.0 * PI)) * 0.5) + 0.5),\n                                wl2xyzCIE1964(uv.x * 1000.0) * XYZ2SRGB,\n                                (sin(t * (2.0 * PI)) * 0.5) + 0.5),\n                            wl2rgbTannenbaum(uv.x * 1000.0), \n                            (sin(t * PI) * 0.5) + 0.5), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "public-domain", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2XRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 340, 371, 371, 1206], [1209, 1209, 1246, 1329, 1550], [1552, 1552, 1602, 1685, 2295], [2302, 2302, 2339, 2422, 2668], [3556, 3886, 3942, 3942, 4654]]}
{"id": "MsBSW3", "name": "Dragonfly", "author": "dr2", "description": "A hungry dragonfly.\n", "tags": ["raymarching", "flower", "flight", "insect"], "likes": 9, "viewed": 830, "date": "1416418851", "time_retrieved": "2024-06-20T18:14:43.704319", "image_code": "// \"Dragonfly\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Length6 (vec2 p)\n{\n  p *= p * p;\n  p *= p;\n  return pow (p.x + p.y, 1. / 6.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nint idObj;\nmat3 bugMat;\nvec3 bugPos, qHit, sunDir, sunCol;\nfloat tCur, szFac;\nconst float dstFar = 150.;\nconst float pi = 3.14159;\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.5;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = 0.2 * wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return 0.3 * ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.2, 0.25, 0.7);\n  vec3 col;\n  col = sbCol + 0.2 * sunCol * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 50.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 10. * tCur;\n    vec2 p = 0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.65;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (5. * (f - 0.5) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + sunCol * (0.35 * pow (s, 6.) +\n     0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.75), cloudFac);\n  return col;\n}\n\nfloat StoneRingDf (vec3 p, float r, float w, float n)\n{\n  vec2 q = vec2 (length (p.xz) - r, p.y);\n  float a = atan (p.x, p.z);\n  a = 0.2 * pow (abs (sin (a * n)), 0.25) + 0.8;\n  return Length6 (q) - w * a;\n}\n\nstruct WingParm\n{\n  float span, sRad, trans, thck, tapr;\n};\n\nfloat WingDf (vec3 p, WingParm wg)\n{\n  float s = abs (p.x - wg.trans);\n  float dz = s / wg.span;\n  return max (length (abs (p.yz) + vec2 (wg.sRad + wg.tapr * dz * dz * dz, 0.))\n     - wg.thck, s - wg.span);\n}\n\nfloat BugDf (vec3 p, float dHit)\n{\n  vec3 q;\n  WingParm wg;\n  float d, wr, ws;\n  float wSpan = 3.;\n  float bdyLen = 2.;\n  float wFreq = 21.3;\n  float wAngF = cos (wFreq * tCur);\n  float wAngB = cos (wFreq * tCur + 0.3 * pi);\n  dHit /= szFac;\n  p /= szFac;\n  ws = 0.11 * (wAngF + 0.3) * max (0., abs (p.x) - 0.12 * bdyLen) / (wSpan * szFac);\n  q = p - vec3 (0., 14. * ws, 3. * ws);\n  wg = WingParm (0.9 * wSpan, 2.14, 0., 2.17, 0.04);\n  d = WingDf (q, wg);\n  if (d < dHit) {\n    dHit = min (dHit, d);  idObj = 21;  qHit = q;\n  }\n  ws = 0.13 * (wAngB + 0.3) * max (0., abs (p.x) - 0.12 * bdyLen) / (wSpan * szFac);\n  q = p - vec3 (0., 14. * ws, 3. * ws);\n  q.z -= 0.38 * bdyLen;\n  wg.span *= 1.1;\n  d = WingDf (q, wg);\n  if (d < dHit) {\n    dHit = min (dHit, d);  idObj = 21;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  q -= bdyLen * vec3 (0.085, 0.035, 1.);\n  d = PrSphDf (q, 0.072 * bdyLen);\n  if (d < dHit) {\n    dHit = d;  idObj = 22;  qHit = q;\n  }\n  q = p;\n  wr = q.z / bdyLen;\n  float tr, u;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr * bdyLen, bdyLen);\n  if (d < dHit + 0.02) {\n    dHit = SmoothMin (dHit, d, 0.02);  idObj = 23;  qHit = q;\n  }\n  q -= bdyLen * vec3 (0., 0.1 * (wr + 1.) * (wr + 1.), -1.8);\n  d = PrCylDf (q, 0.009 * bdyLen, 0.8 * bdyLen);\n  if (d < dHit) {\n    dHit = min (dHit, d);  idObj = 23;  qHit = q;\n  }\n  q = p;\n  q -= bdyLen * vec3 (0., -0.03, 1.03);\n  d = PrSphDf (q, 0.03 * bdyLen);\n  if (d < dHit) {\n    dHit = d;  idObj = 24;  qHit = q;\n  }\n  q = p;\n  wr = q.y / bdyLen;\n  q.x = abs (q.x) - 0.03 * bdyLen;\n  q.xz -= 2.4 * wr * wr;\n  q -= bdyLen * vec3 (0., 0.17, 0.9);\n  d = PrCylDf (q.xzy, 0.01 * bdyLen - 0.2 * wr * wr, 0.1 * bdyLen);\n  if (d < dHit) {\n    dHit = d;  idObj = 25;  qHit = q;\n  }\n  return 0.8 * dHit * szFac;\n}\n\nvec3 BugCol (vec3 n)\n{\n  const vec3 wCol = vec3 (1., 1., 0.7), bCol = vec3 (0., 0.1, 0.6),\n     mCol = vec3 (0.9, 0.3, 0.), gCol = vec3 (0.8, 0.8, 0.1),\n     eCol = vec3 (0.7, 0., 0.1);\n  const vec4 g1 = vec4 (-1.2, -0.5, -0.18, -0.05),\n     g2 = vec4 (1.65, 0.725, 0.225, 0.1),\n     g3 = 1. / vec4 (0.1, 0.075, 0.075, 0.075);\n  float cFac = 1.;\n  vec3 col;\n  qHit *= 5. * szFac;\n  if (idObj == 21) {\n    col = wCol;\n    vec4 b = (g1 * abs (qHit.x) + max (qHit.z, - qHit.z) + g2) * g3;\n    vec2 bb = b.xz + step (abs (b.yw), abs (b.xz)) * (b.yw - b.xz);\n    float ds = bb.x + step (abs (bb.y), abs (bb.x)) * (bb.y - bb.x);\n    ds = sqrt (max (0., 1. - ds * ds)) * sign (ds);\n    if (ds != 0.) {\n      col *= (1. - 0.2 * abs (ds));\n      if (dot (n, sunDir) > 0.) {\n\t    vec3 nn = bugMat * n;\n\t    nn.yz = clamp (nn.yz - vec2 (sqrt (1. - ds * ds), ds), -1., 1.);\n\t    nn = normalize (nn) * bugMat;\n\t    col *= (1. + 1.5 * max (dot (nn, sunDir), 0.));\n      }\n    }\n  } else if (idObj == 22) {\n    col = bCol;\n    if (qHit.z > 0.3) {\n      col = eCol;\n      idObj = 29;\n    }\n  } else if (idObj == 23) {\n    vec3 nn = bugMat * n;\n    col = mix (mix (bCol, mCol, smoothstep (0.5, 1.5, nn.y)), wCol,\n       1. - smoothstep (-1.3, -0.7, nn.y));\n    if (qHit.y < 0.) col *= (1. - 0.3 * SmoothBump (-0.07, 0.07, 0.03, qHit.x));\n  } else if (idObj == 24) {\n    col = mCol;\n  } else if (idObj == 25) {\n    col = gCol;\n  }\n  return col * cFac;\n}\n\nstruct FlwParm\n{\n  float spRad, spWid, nRot, bAng, wgThk, wgOff;\n};\n\nfloat FlwDf (vec3 q, float yp, float aa, FlwParm f, float dHit, int id)\n{\n  q.y -= yp;\n  vec3 qq = q;\n  float d = max (PrSphDf (qq, f.spRad),\n     - PrSphDf (qq - vec3 (0., 0.5 * f.spWid, 0.), f.spRad * (1. - f.spWid)));\n  float s = f.nRot / (2. * pi);\n  float a = (floor (aa * s) + 0.5) / s;\n  qq.xz = cos (a) * qq.xz + sin (a) * qq.zx * vec2 (-1., 1.);\n  qq.xy = cos (f.bAng) * qq.xy + sin (f.bAng) * qq.yx * vec2 (1., -1.);\n  qq.x += f.wgOff * f.spRad;\n  float wgRad = 3. * f.spRad;\n  qq.xz /= wgRad;\n  d = max (d, wgRad * (sqrt (dot (qq.xz, qq.xz) + 2. * abs (qq.z) + 1.) -\n     (1. + f.wgThk)));\n  if (d < dHit) {\n    dHit = d;  idObj = id;  qHit = q;\n  }\n  d = PrCylDf (q.xzy + vec3 (0., 0., 0.98 * f.spRad),\n     0.05 * f.spRad, 0.04 * f.spRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 13;  qHit = q;\n  }\n  return dHit;\n}\n\nvec3 FlwCol (vec3 n)\n{\n  vec3 col;\n  float h;\n  if (idObj == 11 || idObj == 12) {\n    h = 0.6 * abs (asin (qHit.y / length (qHit))) / pi;\n  }\n  if (idObj == 11) {\n    col = HsvToRgb (vec3 (h, 1., 1.));\n  } else if (idObj == 12) {\n    col = HsvToRgb (vec3 (0.3, 1. - 2. * h, 1. - 2. * h));\n  } else if (idObj == 13) {\n    col = vec3 (0.3, 0.5, 0.3) * (1. -\n       0.5 * SmoothBump (0.3, 0.5, 0.1, mod (20. * qHit.y, 1.)));\n  } else if (idObj == 15) {\n    col = 0.9 * vec3 (0.6, 0.4, 0.2);\n  }\n  return col * col;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  float flFac = 1.2;\n  vec3 q;\n  float vOff = 1.;\n  float d;\n  float s = 3.3 * (flFac - 1.);\n  float aa = atan (p.z, - p.x);\n  dHit = FlwDf (p, vOff + s + 0.3 * flFac, aa,\n     FlwParm (1. * flFac, 0.02, 21., 0.8, 0.02, 0.9), dHit, 11);\n  dHit = FlwDf (p, vOff + s, aa,\n     FlwParm (3.3 * flFac, 0.015, 42., 1.5, 0.01, 0.8), dHit, 12);\n  d = PrCylDf (p.xzy + vec3 (0.03 * sin (6. * p.y), 0.03 * cos (6. * p.y),\n     - (vOff + s) + 1.9 * flFac), 0.03 * flFac, 1.3 * flFac);\n  if (d < dHit) {\n    dHit = d;  idObj = 13;  qHit = p;\n  }\n  d = PrCylDf (p.xzy - vec3 (0., 0., vOff - 3.3), 6. * flFac, 0.01);\n  if (d < dHit) {\n    dHit = d;  idObj = 14;  qHit = p;\n  }\n  d = StoneRingDf (p - vec3 (0., vOff - 3.1, 0.), 6. * flFac, 0.3 * flFac, 10.);\n  if (d < dHit) {\n    dHit = d;  idObj = 15;  qHit = p;\n  }\n  dHit = BugDf (bugMat * (p - bugPos), dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.04;\n  for (int i = 0; i < 100; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.04;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvoid BugPM (float t)\n{\n  float aimHt = 2.;\n  float fa = 0.3 * t + pi * (0.3 * sin (0.4 * t) + 0.22 * sin (0.44 * t));\n  float fe = pi * (0.35 + 0.1 * sin (0.3 * t) + 0.05 * sin (0.33 * t));\n  float fd = 5. + 0.6 * sin (2.5 * t) + 0.3 * sin (2.61 * t);\n  bugPos = fd * vec3 (cos (fa) * sin (fe), cos (fe), sin (fa) * sin (fe));\n  bugPos.y += aimHt;\n  vec3 vo = vec3 (0., aimHt, 0.);\n  vec3 vd = normalize (bugPos - vo);\n  float azF = 0.5 * pi + atan (vd.z, vd.x);\n  float elF = asin (vd.y);\n  float rlF = pi * (0.2 * sin (3.2 * t) + 0.15 * sin (3.51 * t));\n  vec3 ori = vec3 (elF, azF, rlF);\n  vec3 ca = cos (ori);\n  vec3 sa = sin (ori);\n  bugMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, objCol;\n  float dstHit;\n  vec3 col = vec3 (0.);\n  float spec = 0.5;\n  float specEx = 128.;\n  dstHit = ObjRay (ro, rd);\n  float refFac = 1.;\n  if (dstHit < dstFar && idObj == 14) {\n    ro += rd * dstHit;\n    rd = reflect (rd, WaterNf (qHit, dstHit));\n    ro += 0.01 * rd;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    refFac = 0.8;\n  }\n  int idObjT = idObj;\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) {\n    if (refFac == 1.) col = vec3 (0.);\n    else col = refFac * SkyCol (ro, rd);\n  } else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    spec = 0.5;\n    if (idObj < 20) {\n      if (idObj == 15) {\n        vn = VaryNf (5. * qHit, vn, 1.);\n        spec = 0.1;\n      } else if (idObj != 14) vn = VaryNf (100. * qHit, vn, 0.2);\n      objCol = FlwCol (vn);\n    } else {\n      vec3 vno = vn;\n      if (idObj != 25) vn = VaryNf (100. * qHit, bugMat * vn, 0.3) * bugMat;\n      idObj = idObjT;\n      objCol = BugCol (vn);\n      spec = 2.;\n      if (idObj == 29) {\n\t    spec = 0.5;\n\t    specEx = 8.;\n      }\n    }\n    float dif = max (dot (vn, sunDir), 0.);\n    col = refFac * (0.2 * objCol * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, sunDir) *\n       (objCol * dif + spec * pow (max (0., dot (sunDir, reflect (rd, vn))), specEx)));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  float zmFac = 3.;\n  tCur = iTime;\n  szFac = 1.;\n  sunDir = normalize (vec3 (0.5, 1., -0.4));\n  sunCol = vec3 (1.);\n  float dist = 25.;\n  vec3 rd = normalize (vec3 (uv, zmFac));\n  float el = 0.9;\n  float az = pi * cos (0.01 * tCur) + pi;\n  float cEl = cos (el);\n  float sEl = sin (el);\n  rd = vec3 (rd.x, rd.y * cEl - rd.z * sEl, rd.z * cEl + rd.y * sEl);\n  float cAz = cos (az);\n  float sAz = sin (az);\n  rd = vec3 (rd.x * cAz + rd.z * sAz, rd.y, rd.z * cAz - rd.x * sAz); \n  vec3 ro = - dist * vec3 (cEl * sAz, - sEl, cEl * cAz);\n  BugPM (tCur);\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBSW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 238, 262, 262, 309], [311, 311, 336, 336, 515], [517, 517, 542, 542, 848], [850, 850, 874, 874, 935], [937, 937, 982, 982, 1080], [1082, 1082, 1139, 1139, 1222], [1224, 1224, 1248, 1248, 1379], [1381, 1381, 1410, 1410, 1612], [1614, 1614, 1653, 1653, 1860], [1862, 1862, 1895, 1895, 1922], [1924, 1924, 1966, 1966, 2017], [2019, 2019, 2062, 2062, 2135], [2269, 2269, 2293, 2293, 2534], [2536, 2536, 2568, 2568, 2730], [2732, 2732, 2754, 2754, 2888], [2890, 2890, 2922, 2922, 3496], [3498, 3498, 3553, 3553, 3705], [3768, 3768, 3804, 3804, 3976], [3978, 3978, 4012, 4012, 5904], [5906, 5906, 5928, 5928, 7341], [7412, 7412, 7485, 7485, 8241], [8243, 8243, 8265, 8265, 8756], [8758, 8758, 8780, 8780, 9670], [9672, 9672, 9705, 9705, 9908], [9910, 9910, 9931, 9931, 10176], [10178, 10178, 10215, 10215, 10427], [10429, 10429, 10451, 10451, 11249], [11251, 11251, 11286, 11286, 12695], [12697, 12697, 12754, 12754, 13462]]}
{"id": "MsBXDy", "name": "Gold", "author": "daeken", "description": "A little experiment with various levels of noise.", "tags": ["noise", "shaderforth"], "likes": 15, "viewed": 533, "date": "1415478302", "time_retrieved": "2024-06-20T18:14:44.007416", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\niResolution frag->position 1000 / =p\n:m light [ 0.87 0.64 0.25 ] ;\n:m dark [ 0.41 0.22 0.02 ] ;\n: val ( p:vec2 level:float -> float )\n\t&pnoise-2d p gradient abs\n;\n$[1:16:1] !size =>t /{ ( x ) 2 x ** p * x + [ time .1337 * sin time .0879 * sin ] p+ x val } \\+ t / =v\ndark light v abs 0 1 clamp mix ->fragcolor\n*/\n\nvec4 pnoise_permute(vec4 x) {\n\treturn mod((x * 34. + 1.) * x, 289.);\n}\nfloat pnoise_2d(vec2 v) {\n\tvec4 Pi = mod(floor(v.xyxy) + vec4(0., 0., 1., 1.), 289.);\n\tvec4 Pf = fract(v.xyxy) - vec4(0., 0., 1., 1.);\n\tvec4 i = pnoise_permute(pnoise_permute(Pi.xzxz) + Pi.yyww);\n\tvec4 gx = fract(i * .024390) * 2. - 1.;\n\tvec4 gy = abs(gx) - .5;\n\tgx = gx - floor(gx + .5);\n\tvec2 g00 = vec2(gx.x, gy.x);\n\tvec2 g10 = vec2(gx.y, gy.y);\n\tvec2 g01 = vec2(gx.z, gy.z);\n\tvec2 g11 = vec2(gx.w, gy.w);\n\tvec4 norm = 1.79284291400159 - .85373472095314 * vec4(length(g00), length(g01), length(g10), length(g11));\n\tvec2 fade_xy = Pf.xy * Pf.xy * Pf.xy * ((Pf.xy * 6. - 15.) * Pf.xy + 10.);\n\tvec2 n_x = mix(vec2(dot(g00 * norm.x, Pf.xy), dot(g01 * norm.y, Pf.xw)), vec2(dot(g10 * norm.z, Pf.zy), dot(g11 * norm.w, Pf.zw)), fade_xy.x);\n\treturn mix(n_x.x, n_x.y, fade_xy.y) * 2.3;\n}\nfloat val(vec2 p, float level) {\n\tvec2 h = vec2(.00001, 0.);\n\treturn abs(pnoise_2d(p) / abs(length(vec2(pnoise_2d(p + h) - pnoise_2d(p - h), pnoise_2d(p + h.yx) - pnoise_2d(p - h.yx)) / (2. * h.x))));\n}\nvec2 polar_cart(vec2 p) {\n\treturn vec2(cos(p.x), sin(p.x)) * p.y;\n}\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan(p.y, p.x), length(p));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.) / 1000.;\n\tfloat v = (val(polar_cart(cart_polar(2. * p + 1.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 1.) + val(polar_cart(cart_polar(4. * p + 2.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 2.) + val(polar_cart(cart_polar(8. * p + 3.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 3.) + val(polar_cart(cart_polar(16. * p + 4.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 4.) + val(polar_cart(cart_polar(32. * p + 5.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 5.) + val(polar_cart(cart_polar(64. * p + 6.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 6.) + val(polar_cart(cart_polar(128. * p + 7.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 7.) + val(polar_cart(cart_polar(256. * p + 8.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 8.) + val(polar_cart(cart_polar(512. * p + 9.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 9.) + val(polar_cart(cart_polar(1024. * p + 10.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 10.) + val(polar_cart(cart_polar(2048. * p + 11.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 11.) + val(polar_cart(cart_polar(4096. * p + 12.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 12.) + val(polar_cart(cart_polar(8192. * p + 13.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 13.) + val(polar_cart(cart_polar(16384. * p + 14.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 14.) + val(polar_cart(cart_polar(32768. * p + 15.) + vec2(sin(iTime * .1337), sin(iTime * .0879))), 15.)) / 15.;\n\tfragColor = vec4(mix(vec3(.41, .22, .02), vec3(.87, .64, .25), clamp(abs(v), 0., 1.)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBXDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 478, 507, 507, 548], [549, 549, 574, 574, 1331], [1332, 1332, 1364, 1364, 1534], [1535, 1535, 1560, 1560, 1602], [1603, 1603, 1628, 1628, 1671], [1672, 1672, 1729, 1729, 3396]]}
{"id": "MsBXW3", "name": "Dragon IFS", "author": "knighty", "description": "Distance estimation to the dragon IFS.", "tags": ["ifs", "distance", "dragon"], "likes": 15, "viewed": 536, "date": "1416428799", "time_retrieved": "2024-06-20T18:14:44.801369", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Distance estimation for dragon IFS. by knighty (nov. 2014).\n////////////////////////////////////////////////////////////////////////////////\n\n#define DEPTH 15\n//The refine step doesn't work well :-/\n//#define REFINE_DE\n//interior only mode is much faster :-)\n#define INTERIOR_ONLY\n////////////////////////////////////////////////////////////////////////////////\n\n#ifdef INTERIOR_ONLY\n#ifdef REFINE_DE\n#undef REFINE_DE\n#endif\n#endif\n\n#define ITER_NUM pow(2., float(DEPTH))\n//Bounding radius to bailout. must be >1. higher values -> more accurate but slower (try 1000)\n//for raymarching a value of 2 or 4 is enought in principle. A vuale of 1 (when REFINE_DE is undefined) will show the bounding circle and its transformations\n#ifdef INTERIOR_ONLY\n#define BR2BO 1.\n#else\n#define BR2BO 64.\n#endif\nvec2  A0   = vec2(1.,-1.);//1st IFS's transformation similatrity\nvec2  F0   = vec2(-1.,0.);//fixed point of 1st IFS's transformation.\nvec2  T0; //Translation term Computed in ComputeBC().\nfloat scl0;// = length(A0);//scale factor of the 1st IFS's \n\n//2nd IFS's transformation.\nvec2  A1   = vec2(-1.,-1.);\nvec2  F1   = vec2(1.,0.);\nvec2  T1;\nfloat scl1;// = length(A1);\n\nfloat Findex=0.;//mapping of IFS point to [0,1[\nfloat minFindex=0.;//for colouring\nfloat BR;//Computed in ComputeBC(). Bounding circle radius. The smaller, the better (that is faster) but it have to cover the fractal (actually it have to cover it's images under the transforms)\nfloat BO;//Computed in ComputeBC(). Bailout value. it should be = (BR*s)^2 where s>1. bigger s give more accurate results but is slower.\n\n//Complex multiplication\nvec2 Cmult(vec2 a, vec2 b){ return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);}\n\n//Compute bounding circle\nvoid ComputeBC(){\n    //Compute bounding circle center w.r.t. fixed points\n    float ss0=length(vec2(1.,0.)-A0);\n    float ss1=length(vec2(1.,0.)-A1);\n    float s= ss1*(1.-scl0)/(ss0*(1.-scl1)+ss1*(1.-scl0));\n    vec2 C=F0+s*(F1-F0);\n    //Translate the IFS in order to center the bounding circle at (0,0)\n    F0-=C;\n    F1-=C;\n    //Pre-compute translations terms\n    T0 = Cmult(vec2(1.,0.)-A0,F0);\n    T1 = Cmult(vec2(1.,0.)-A1,F1);\n    //Bounding circle radius\n    BR = -ss0*length(F0)/(1.-scl0);\n    //\n    BO = BR*BR*BR2BO;\n}\n\n//Computes distance to the point in the IFS which index is the current index.\n//lastDist is a given DE. If at some level the computed distance is bigger than lastDist\n//that means the current index point is not the nearest so we bail out and discard all\n//children of the current index point.\n//We also use a static Bail out value to speed things up a little while accepting less accurate DE.\nfloat dragonSample(vec2 p, float lastDist){\n\tfloat q=Findex;//Get the index of the current point\n\tfloat dd=1.;//running scale\n\tfloat j=ITER_NUM;\n\tfor(int i=0; i<DEPTH; i++){\n        float l2=dot(p,p);\n#ifndef INTERIOR_ONLY\n\t\tfloat temp=BR+lastDist*dd;//this is to avoid computing length (sqrt)\n\t\tif(l2>0.001+temp*temp || l2>BO) break;//continue;//continue is too slow here\n#else\n        if(l2>BO) break;\n#endif\n\t\t\n\t\t//get the sign of the translation from the binary representation of the index\n\t\tq*=2.;\n        float sgn=floor(q); q=fract(q); j*=.5;\n\t\t\n        if(sgn==0.){\n            p=Cmult(A0,p)+T0;\n            dd*=scl0;\n        } else {\n            p=Cmult(A1,p)+T1;//similarity\n            dd*=scl1;\n        }\n\t}\n\t//update current index. it is not necessary to check the next j-1 points.\n\t//This is the main optimization\n\tFindex = ( Findex + j*1./ITER_NUM );\n#ifdef REFINE_DE\n    for(int i=0; i<DEPTH; i++){\n        if(j==1.) break;\n        j*=0.5;\n        vec2 p0=Cmult(A0,p)+T0, p1=Cmult(A1,p)+T1;\n        if(dot(p0,p0)<dot(p1,p1)){p=p0; dd=dd*scl0;}\n        else {p=p1; dd=dd*scl1;}\n    }\n#endif\n    float d=(length(p)-1.*BR)/dd;//distance to current point\n\tif(d<lastDist) minFindex=Findex;\n\treturn min(d,lastDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tscl0 = length(A0);\n    scl1 = length(A1);\n    \n    float t=iTime*0.2-.5*3.14159;\n    vec2 rot=vec2(cos(t),sin(t));\n    A1=Cmult(rot,A0);\n    ComputeBC();\n    //coordinates of current pixel in object space. \n\tvec2 uv = 1.7*BR*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\t//Get an estimate. not necessary, but it's faster this way.\n\tfloat d=length(uv)+0.5;\n\t//refine the DE\n\tfor(int i=0; i<500; i++){//experiment: try other values\n\t// In principle max number of iteration should be ITER_NUM but we actually\n\t//do much less iterations. Maybe less than O(DEPTH^2). Depends also on scl.\n\t\td=dragonSample(uv,d);\n\t\tif(Findex>=1.) break;\n\t}\n#ifdef INTERIOR_ONLY\n    d=max(0.,-d);\n#endif\n\tfragColor = vec4(pow(abs(d),0.2))*(0.75+0.25*sin(vec4(15.,6.5,3.25,1.)*minFindex));//\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBXW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1664, 1689, 1716, 1716, 1764], [1766, 1792, 1809, 1866, 2322], [2324, 2717, 2760, 2760, 3944], [3946, 3946, 4003, 4003, 4779]]}
{"id": "MsBXWc", "name": "Sineoscope", "author": "jazonxyz", "description": "Sine wave on an analog oscope", "tags": ["sinewaveoscilloscope"], "likes": 6, "viewed": 491, "date": "1416533433", "time_retrieved": "2024-06-20T18:14:44.807370", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float horGrid = 10.0*max(max(mod(uv.x, 0.1), mod(-uv.x, 0.1)), max(mod(uv.y, 0.1), mod(-uv.y, 0.1)));\n    \n    horGrid = pow(horGrid, 100.0);\n    horGrid = mix(0.0, 0.1, horGrid);\n    vec4 background = vec4(horGrid, horGrid, horGrid, 1.0);\n    \n    float mag = 1.0 - distance(uv.y, 0.5 + 0.25*sin(uv.x*5.0+iTime*2.0));\n    mag = pow(mag, 200.0);\n\tbackground += vec4(mag*uv.x, mag*uv.y, mag*sin(iTime / 2.0), 1.0);\n    \n    fragColor = background;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBXWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 552]]}
{"id": "MsjXW3", "name": "Simple Rain", "author": "inferno", "description": "A simple comic like rain effect with 2 lines of code", "tags": ["noise", "simple", "rain"], "likes": 9, "viewed": 722, "date": "1416744395", "time_retrieved": "2024-06-20T18:14:44.807370", "image_code": "float hash2(vec2 uv) { \treturn fract(sin(uv.x * 455.78 + uv.y / 34532.14) * iTime * 13.9);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ vec2 uv = (fragCoord.xy / iResolution.xy); fragColor = vec4(mix(vec3(0.0),vec3(1.0),smoothstep(0.95,1.0,hash2(uv))),1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjXW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 91], [92, 92, 148, 148, 271]]}
{"id": "MssSDj", "name": "heart.throb", "author": "thallippoli", "description": "There's enough love in this world for everyone.", "tags": ["raymarching", "distancefield", "heart"], "likes": 3, "viewed": 611, "date": "1416687184", "time_retrieved": "2024-06-20T18:14:44.807370", "image_code": "// Created by Ashwin Sudhir - thallippoli/2014\n// ray marched field of hearts\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float max_iterations = 150.0;\nconst float stop_threshold = 0.0001;\nconst float grad_step = 0.1;\nconst float clip_far = 90.0;\n\n// thanks to IQ for smin, path, and hash ===============================================\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 path( float t )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 10. + 4.0*sin(0.05*t), p.y );   \n}\n\nfloat hash( vec2 p )\n{\n    float h = dot(p,vec2(127.1,311.7));\n    \n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n// =====================================================================================\n\nfloat heart( vec3 pos, vec3 origin, float r ) \n{\n    mat4 m = mat4( 1.0 );\n    m[ 3 ] = vec4( 1.0, 1., 2. * hash( origin.zy ) * ( sin( 25.0 * iTime ) * 0.5 + 0.5 ) , 1.0 );\n    vec3 c = vec3( 15, 20, 20 );\n\tpos = mod( pos, c ) - 0.5 * c;\n    pos = ( m * vec4( pos, 1. ) ).xyz;\n    \n    float oval = length( pos - origin + vec3( 0, 7. * r / 3., 0 ) ) - 4. * r / 3. - pos.y / 2.8;\n    float sphereLeft = length( pos - origin + vec3( r, r/3., 0 ) ) - r;\n    float sphereRight = length( pos - origin + vec3( -r , r/3., 0 ) ) - r;\n    \n    return smin( min( sphereLeft, sphereRight ), oval, 1.8 ); \n}\n\nfloat dist_field( vec3 pos ) \n{\n\tfloat d0 = heart( pos, vec3( 0.0, 1.5, 10.0 ), 1. );\n\n    return d0;\n}\n\nvec2 rayMarch( vec3 origin, vec3 dir, float end ) \n{\n\tfloat depth = 0.0;\n\tfor ( float i = 0.0; i < max_iterations; i++ ) \n\t{\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold )\n\t\t\treturn vec2( depth, i / max_iterations );\n\t\tdepth += dist;\n\t\tif ( depth >= end)\n\t\t\treturn vec2( end, i / max_iterations );\n\t}\n\treturn vec2( end, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3( path( iTime * 10. ).xy, iTime * 25.);\n\t\t\n\tfloat ar = iResolution.x / iResolution.y;\n\t\n\tvec2 ndcPoint = vec2( ( fragCoord.x / iResolution.x - 0.5) * ar, fragCoord.y / iResolution.y - 0.5 );\n\tvec3 dir = normalize( vec3( ndcPoint, 1.) );\n    \t\n\tvec2 result = rayMarch( eye, dir, clip_far );\n    float s = 1.0 - result.x / clip_far;\n    float o = result.y;\n    fragColor = vec4( o * 2.5 + s, 0, 0, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssSDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[388, 424, 465, 465, 558], [560, 560, 582, 582, 765], [767, 767, 789, 789, 887], [888, 978, 1026, 1026, 1573], [1575, 1575, 1606, 1606, 1678], [1680, 1680, 1732, 1732, 2043], [2045, 2045, 2102, 2102, 2525]]}
{"id": "MsSSDy", "name": "hÃÂ¤mÃÂ¤hÃÂ¤kki", "author": "Branch", "description": "hÃÂ¤mÃÂ¤hÃÂ¤mÃÂ¤hÃÂ¤kki", "tags": ["2dspmurhahmhkki"], "likes": 4, "viewed": 165, "date": "1415463502", "time_retrieved": "2024-06-20T18:14:45.152916", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nfloat circle(vec2 coord, vec2 pos, float size){\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat circle(vec2 coord, vec2 pos, float size, float start, float end){\n    float angle = atan(coord.x, coord.y);\n    if(angle>start && angle<end) return 0.0;\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat repeat_circle(vec2 coord, vec2 pos, float size, float slice){\n    float angle = atan(coord.x, coord.y);\n    if(mod(angle * slice,3.141*2.0)<3.141) return 0.0;\n    return min(floor(distance(coord,pos)-size),0.);\n}\nmat2 rotate(float Angle){\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\n\n//imdone\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    coord *= .6+sin(iTime+length(coord)*sin(length(coord)+iTime))/2.65;\n    coord *= rotate(iTime);\n    coord *= vec2(1.)+0.1*vec2(sin(iTime+coord.x*10.), cos(sin(iTime)*11.+coord.y));\n\tfloat vignette = 2.0 / max(0.5 + 12.0*dot(coord,coord),1.);\n    float time = iTime * 0.9;\n    float dist = 0.0;\n    vec2 goto_pos = vec2(0.5) - vec2(rand( vec2(0.0, 0.0) ), rand( vec2( 0.0 ) ) );\n    float millisecs = time - floor(time);\n    \n    float Tfast = mod(time,1.0+sin(iTime/16.)/5.);\n    float boing = 0.5-0.5*cos(Tfast*10.0)/(1.0+Tfast*Tfast*20.0);\n    for(float k=1.0; k<10.0; k++){\n        vec2 pos = vec2(0.0);\n        for(float i=1.0; i<12.0; i++){\n            float j = floor(time) + i ;\n            float new_j = floor(time+1.0) + i;\n            vec2 cur_pos = pos + 0.7 * (vec2(0.5) - vec2(rand( vec2(k, j) ), rand( vec2( j * k ) ) ) );\n            vec2 new_pos = pos + 0.7 * (vec2(0.5) - vec2(rand( vec2(k, new_j) ), rand( vec2( new_j * k ) ) ) );\n            dist += sdCapsule( coord, pos, cur_pos * (1.0 - boing) + new_pos * boing, 0.01 - i * 0.0008 );\n            pos = cur_pos * (1.0 - boing) + new_pos * boing;\n        }\n    }\n    for(float i=0.0; i<20.0; i++){\n        vec2 circle_position = mod(iTime+i,5.0)*vec2(0.5-rand(vec2(i)),0.5-rand(vec2(i*i)));\n        dist += 0.8 / max(0.2 + 100.0*dot(coord-circle_position,coord-circle_position),0.8);\n    }\n    vec3 COLOR = +vec3(0.2,0.9,0.8)-vec3(min(max(1.0/dist,0.0),1.0))+vignette-0.025*rand(time*coord*coord);\n\tfragColor = vec4(COLOR,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSSDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 21, 21, 93], [94, 94, 145, 145, 287], [288, 288, 335, 335, 389], [390, 390, 461, 461, 602], [603, 603, 670, 670, 821], [822, 822, 847, 847, 979], [981, 990, 1046, 1046, 2752]]}
{"id": "MsSSWV", "name": "Sphere - antialias", "author": "iq", "description": "Analytical antialiasing for raytraced spheres. Only one ray/sample per pixel is casted. This shader also uses analytical ambient occlusion and analytical soft shadows.", "tags": ["3d", "sphere", "antialias", "analytical", "conetracing"], "likes": 129, "viewed": 10435, "date": "1415959692", "time_retrieved": "2024-06-20T18:14:46.559256", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//  https://www.youtube.com/c/InigoQuilez\n//  https://iquilezles.org/\n\n\n// Analytical antialiasing of raytraced spheres. Only one ray/sample per pixel is casted. \n// However, spheres have simple analytical pixel coverage computation, so some degree of \n// edge antialiasing can be performed.\n//\n// For that, all intersections and near-intersections must be found and sorted for proper composition.\n//\n// Try undefining the flag below to see the difference.\n//\n// Related info: http://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\n\n\n//#define NO_ANTIALIAS\n\n//-------------------------------------------------------------------------------------------\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat sphShadow( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    return step( min( -b, min( c, b*b - c ) ), 0.0 );\n}\n            \nvec2 sphDistances( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.0)) );\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float s = 1.0;\n    vec2 r = sphDistances( ro, rd, sph );\n    if( r.y>0.0 )\n        s = max(r.x,0.0)/r.y;\n    return s;\n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0.0, 1.0 );\n\n}\n\n//-------------------------------------------------------------------------------------------\n#define NUMSPHEREES 12\n\nvec4 sphere[NUMSPHEREES];\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n\tfloat res = 1.0;\n\tfor( int i=0; i<NUMSPHEREES; i++ )\n        res = min( res, 8.0*sphSoftShadow(ro,rd,sphere[i]) );\n    return res;\t\t\t\t\t  \n}\n\nfloat occlusion( in vec3 pos, in vec3 nor )\n{\n\tfloat res = 1.0;\n\tfor( int i=0; i<NUMSPHEREES; i++ )\n\t    res *= 1.0 - sphOcclusion( pos, nor, sphere[i] ); \n    return res;\t\t\t\t\t  \n}\n\n//-------------------------------------------------------------------------------------------\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in float id, in vec4 sph )\n{\n    vec3 ref = reflect(rd,nor);\n    float occ = occlusion( pos, nor );\n    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n    \n    occ = occ*0.5 + 0.5*occ*occ;\n    vec3 lig = vec3(occ)*vec3(0.9,0.95,1.0);\n    lig *= 0.7 + 0.3*nor.y;\n    lig += 0.7*vec3(0.3,0.2,0.1)*fre*occ;\n    lig *= 0.9;\n\n    \n    lig += 0.7*smoothstep(-0.05,0.05,ref.y )*occ*shadow( pos, ref ) * (0.03+0.97*pow(fre,3.0));\n\n    return lig;\n}    \n\nvec3 trace( in vec3 ro, in vec3 rd, vec3 col, in float px )\n{\n#ifdef NO_ANTIALIAS\n\tfloat t = 1e20;\n\tfloat id  = -1.0;\n    vec4  obj = vec4(0.0);\n\tfor( int i=0; i<NUMSPHEREES; i++ )\n\t{\n\t\tvec4 sph = sphere[i];\n\t    float h = sphIntersect( ro, rd, sph ); \n\t\tif( h>0.0 && h<t ) \n\t\t{\n\t\t\tt = h;\n            obj = sph;\n\t\t\tid = float(i);\n\t\t}\n\t}\n\t\t\t\t\t\t  \n    if( id>-0.5 )\n    {\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = sphNormal( pos, obj );\n        col = shade( rd, pos, nor, id, obj );\n    }\n\n#else\n\n    \n    // intersect spheres\n    vec3 tao[NUMSPHEREES];\n\tint num = 0;\n    for( int i=0; i<NUMSPHEREES; i++ )\n\t{\n\t\tvec4 sph = sphere[i];\n        vec2 dt = sphDistances( ro, rd, sph );\n        float d = dt.x;\n\t    float t = dt.y;\n        //if( t<0.0 ) continue; // skip stuff behind camera. If I enable it, I loose mipmapping\n        \n        float s = max( 0.0, d/t );\n        if( s < px ) // intersection, or close enough to an intersection\n        {\n            tao[num].x = t;                         // depth\n            tao[num].y = 1.0 - clamp(s/px,0.0,1.0); // pixel coverage\n            tao[num].z = float(i);                  // object id\n            num++;\n        }\n\t}\n\n    // sort intersections\n\tfor( int i=0; i<num-1; i++ )\n    for( int j=i+1; j<num; j++ )\n    {\n        if( tao[j].x > tao[i].x )\n        {\n            vec3 tm = tao[i];\n            tao[i] = tao[j];\n            tao[j] = tm;\n        }\n\t}\n    \n    // composite\n    float ot = tao[0].x;\n\tfor( int i=0; i<num; i++ )\n    {\n        float t   = tao[i].x;\n        float al  = tao[i].y;\n        float fid = tao[i].z;\n\n        if( (i+1)<num )\n        {\n            float tn = tao[i+1].x;\n        \tal *= clamp( 0.5 - 0.5*(tn-t)/(px*1.0), 0.0, 1.0 );\n        }\n        \n        vec4 sph = sphere[int(fid)];\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph );\n\n        vec3 tmpcol = shade( rd, pos, nor, fid, sph );\n        \n        col = mix( col, tmpcol.xyz, al );\n    }\n    \n#endif\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec2 m = step(0.0001,iMouse.z) * iMouse.xy/iResolution.xy;\n\t\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n\tfloat time = iTime*0.5;\n\t\n\tfloat an = 0.3*time - 7.0*m.x;\n\n\tfor( int i=0; i<NUMSPHEREES; i++ )\n\t{\n\t\tfloat id  = float(i);\n        float ra = pow(id/float(NUMSPHEREES-1),3.0);\n\t    vec3  pos = 1.0*cos( 6.2831*hash3(id*14.0) + 0.5*(1.0-0.7*ra)*hash3(id*7.0)*time );\n\t\tsphere[i] = vec4( pos, (0.3+0.6*ra) );\n    }\n\t\t\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    float le = 1.8;\n\tvec3 ro = vec3(2.5*sin(an),1.5*cos(0.5*an),2.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + le*ww );\n\n    float px = 1.0*(2.0/iResolution.y)*(1.0/le);\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\tvec3 col = vec3(0.02) + 0.02*rd.y;\n    \n    col = trace( ro, rd, col, px );\n    \n\n    //-----------------------------------------------------\n\t// postpro\n    //-----------------------------------------------------\n    \n    // gamme    \n    col = pow( col, vec3(0.4545) );\n\n    // vignetting    \n    col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n    // dithering\n    col += (1.0/255.0)*hash3(q.x+13.0*q.y);\n    \n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSSWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1651, 1746, 1790, 1790, 1827], [1829, 1829, 1888, 1888, 2051], [2053, 2053, 2109, 2109, 2265], [2279, 2279, 2337, 2337, 2555], [2557, 2557, 2617, 2617, 2742], [2760, 2760, 2821, 2821, 3063], [3065, 3210, 3250, 3250, 3391], [3393, 3393, 3438, 3438, 3573], [3575, 3670, 3693, 3693, 3749], [3751, 3751, 3829, 3829, 4238], [4244, 4244, 4305, 4305, 6224], [6226, 6226, 6283, 6283, 7973]]}
{"id": "Xd2XWt", "name": "Rolling Forever", "author": "dr2", "description": "Balls rolling endlessly.", "tags": ["raymarch", "balls", "helix", "track"], "likes": 26, "viewed": 1548, "date": "1417183156", "time_retrieved": "2024-06-20T18:14:48.686614", "image_code": "// \"Rolling Forever\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  vec2 q = vec2 (length (p.xy) - rc, p.z);\n  return length (q) - ri;\n}\n\nint idObj;\nconst int nBall = 8;\nmat3 vuMat;\nvec3 bPos[nBall], bNv[nBall], trNv, qHit, ltDir;\nfloat tCur, posLin, radSpir, dhSpir, ballRad, rollVel, fnSpir, dLinSeg,\n   dRotSeg, lenPath, bAng[nBall], trAng;\nbool showFlap;\nconst int nSpir = 3;\nconst float dstFar = 60.;\nconst float pi = 3.14159;\n\nfloat TrackDf (vec3 p, float dHit)\n{\n  vec3 q, qq;\n  vec2 b;\n  float d, tw;\n  float i2 = 1. / sqrt (2.);\n  float hTrk = 0.25;\n  float rTrk = 0.3;\n  float dpTrk = 0.3;\n  float wWid = 0.1;\n  float wdTrk = 2.3;\n  float posSpir = posLin + radSpir;\n  vec3 sn = sign (p);\n  q = p;\n  q.xz -= posSpir * sn.xz;\n  qq = q;\n  qq.xz = sn.z * (qq.xz * vec2 (i2, i2) + sn.x * qq.zx * vec2 (- i2, i2));\n  qq.y -= 0.5 * (atan (qq.z, - sn.z * sn.x * qq.x) / pi - fnSpir +\n     0.25 * sn.z + 0.5) * dhSpir - hTrk;\n  tw = (length (qq.xz) - radSpir) / wdTrk;\n  for (int j = 0; j <= nSpir; j ++) {\n    d = length (vec2 (tw, qq.y)) - rTrk;\n    b = vec2 (abs (tw) - (rTrk - wWid), abs (qq.y - hTrk) - dpTrk);\n    d = max (d, - (min (max (b.x, b.y), 0.) + length (max (b, 0.))));\n    d = max (d, abs (q.y) - (0.5 * fnSpir + 0.2) * dhSpir);\n    if (j == 0) d = max (d, - PrBoxDf (p + vec3 (0., 0.5 * fnSpir * dhSpir, 0.),\n       vec3 (2. * posSpir, 2.2 * hTrk, posSpir)));\n    else if (j == nSpir) d = max (d, - sn.x * q.x);\n    if (d < dHit) {\n      dHit = d;  idObj = 1;\n    }\n    qq.y -= dhSpir;\n  }\n  q = p;\n  q.y += 0.1 * dhSpir;\n  for (int k = 0; k <= 1; k ++) {\n    qq = q;\n    if (k == 0) {\n      qq.y -= 0.5 * fnSpir * dhSpir;\n    } else {\n      qq.xz = qq.zx;\n      qq.y += 0.5 * (fnSpir - 0.5) * dhSpir;\n    }\n    qq.z = abs (qq.z) - posLin;\n    tw = qq.z / wdTrk;\n    d = length (vec2 (tw, qq.y)) - rTrk;\n    b = vec2 (abs (tw) - (rTrk - wWid), abs (qq.y - hTrk) - dpTrk);\n    d = max (d, - (min (max (b.x, b.y), 0.) + length (max (b, 0.))));\n    d = max (d, abs (qq.x) - posSpir);\n    if (d < dHit) {\n      dHit = d;  idObj = 1;\n    }\n  }\n  q = p;\n  q.xz = abs (q.xz) - posLin - radSpir;\n  d = PrCylDf (q.xzy, 0.1 * radSpir, 0.5 * fnSpir * dhSpir);\n  if (d < dHit) {\n    dHit = d;  idObj = 2;\n  }\n  q.y -= 0.1 * dhSpir;\n  q.y += 0.5 * (fnSpir - 0.5) * dhSpir;\n  float cl = 0.5 * (radSpir - 0.25 * wdTrk);\n  for (int j = 0; j < nSpir; j ++) {\n    qq = q;\n    qq.z -= cl;\n    d = PrCylDf (qq, 0.03 * radSpir, cl);\n    if (d < dHit) {\n      dHit = d;  idObj = 2;\n    }\n    qq.y -= 0.5 * dhSpir;\n    qq.z += 2. * cl;\n    d = PrCylDf (qq, 0.03 * radSpir, cl);\n    if (d < dHit) {\n      dHit = d;  idObj = 2;\n    }\n    q.y -= dhSpir;\n  }\n  q = p;\n  q.y += 0.5 * (fnSpir * dhSpir - wdTrk);\n  q.x = abs (q.x) - posLin;\n  d = PrTorusDf (q.yxz, 0.07 * radSpir, 0.5 * wdTrk);\n  if (d < dHit) {\n    dHit = d;  idObj = 3;\n  }\n  if (showFlap) {\n    d = max (PrCylDf (q.yxz, 0.5 * wdTrk, 0.03 * radSpir), - q.y - 0.2 * wdTrk);\n    if (d < dHit) {\n      dHit = d;  idObj = 3;\n    }\n  }\n  q = p - vec3 (0., - 0.5 * fnSpir * dhSpir - 0.2, 0.);\n  d = PrBoxDf (q, vec3 (posLin + 2. * radSpir, 0.2, posLin + 2. * radSpir));\n  if (d < dHit) {\n    dHit = d;  idObj = 4;  qHit = q;\n  }\n  return dHit;\n}\n\nvec3 BallPos (int k)\n{\n  float ht = 0.5 * fnSpir * dhSpir;\n  float htSeg = (2. * ht - 0.25 * dhSpir) / dRotSeg;\n  float htd = ht - 0.25 * dhSpir;\n  float posSpir = posLin + radSpir;\n  float da = (2. * fnSpir - 0.5) * pi / dRotSeg;\n  float dLRSeg = 0.25 * lenPath;\n  float d = mod (tCur * rollVel + lenPath * float (k) / float (nBall), lenPath);\n  trAng = mod (d / ballRad, 2. * pi);\n  trNv = vec3 (0.);\n  vec3 p = vec3 (0.);\n  float a;\n  if (d < 2. * dLRSeg) {\n    if (d < dLinSeg) {\n      p = vec3 (- posSpir + d, htd, posLin);\n      trNv.z = -1.;\n    } else if (d < dLRSeg) {\n      d -= dLinSeg;\n      a = d * da - 0.5 * pi;\n      trNv.xz = vec2 (cos (a), sin (a));\n      p.xz = vec2 (posSpir, posSpir) + radSpir * trNv.xz;\n      p.y = htd - d * htSeg;\n    } else if (d < dLinSeg + dLRSeg) {\n      d -= dLRSeg;\n      p = vec3 (posLin, - ht, posSpir - d);\n      trNv.x = -1.;\n    } else {\n      d -= dLinSeg + dLRSeg;\n      a = d * da + pi;\n      trNv.xz = vec2 (cos (a), sin (a));\n      p.xz = vec2 (posSpir, - posSpir) + radSpir * trNv.xz;\n      p.y = - ht + d * htSeg;\n    }\n  } else {\n    d -= 2. * dLRSeg;\n    if (d < dLinSeg) {\n      p = vec3 (posSpir - d, htd, - posLin);\n      trNv.z = 1.;\n    } else if (d < dLRSeg) {\n      d -= dLinSeg;\n      a = d * da - 0.5 * pi;\n      trNv.xz = - vec2 (cos (a), sin (a));\n      p.xz = - vec2 (posSpir, posSpir) + radSpir * trNv.xz;\n      p.y = htd - d * htSeg;\n    } else if (d < dLinSeg + dLRSeg) {\n      d -= dLRSeg;\n      p = vec3 (- posLin, - ht, - posSpir + d);\n      trNv.x = 1.;\n    } else {\n      d -= dLinSeg + dLRSeg;\n      a = d * da + pi;\n      trNv.xz = - vec2 (cos (a), sin (a));\n      p.xz = vec2 (- posSpir, posSpir) + radSpir * trNv.xz;\n      p.y = - ht + d * htSeg;\n    }\n  }\n  p.y += 1.75 * ballRad;\n  return p;\n}\n\nfloat BallDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p - bPos[0];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[0];  trAng = bAng[0];  qHit = q;\n  }\n  q = p - bPos[1];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[1];  trAng = bAng[1];  qHit = q;\n  }\n  q = p - bPos[2];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[2];  trAng = bAng[2];  qHit = q;\n  }\n  q = p - bPos[3];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[3];  trAng = bAng[3];  qHit = q;\n  }\n  q = p - bPos[4];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[4];  trAng = bAng[4];  qHit = q;\n  }\n  q = p - bPos[5];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[5];  trAng = bAng[5];  qHit = q;\n  }\n  q = p - bPos[6];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[6];  trAng = bAng[6];  qHit = q;\n  }\n  q = p - bPos[7];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[7];  trAng = bAng[7];  qHit = q;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = TrackDf (p, dHit);\n  dHit = BallDf (p, dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.05;\n  for (int i = 0; i < 100; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.05;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao = 0.;\n  for (int i = 0; i < 8; i ++) {\n    float d = 0.1 + float (i) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec4 BallCol ()\n{\n  vec3 col;\n  vec3 q = qHit;\n  float aa = atan (trNv.x, trNv.z);\n  q.xz = q.xz * cos (aa) * vec2 (1., 1.) + q.zx * sin (aa) * vec2 (-1., 1.);\n  if (q.z * (mod (pi + atan (q.x, q.y) + trAng, 2. * pi) - pi) > 0.)\n     col = vec3 (0., 0.6, 0.);\n  else col = vec3 (0.6, 0., 0.);\n  return vec4 (col, 2.);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return 0.5 * mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col4;\n  if (idObj == 1) col4 = vec4 (0., 0.6, 0.6, 1.);\n  else if (idObj == 2) col4 = vec4 (0.5, 0.3, 0., 3.);\n  else if (idObj == 3) col4 = vec4 (0.5, 0.5, 0., 3.);\n  else if (idObj == 4) col4 = vec4 (WoodCol (qHit, n), 1.);\n  else if (idObj == 5) col4 = BallCol ();\n  return col4;\n}\n\nvoid BallPM ()\n{\n  float dGap = lenPath / float (nBall);\n  float db = tCur * rollVel;\n  showFlap = true;\n  for (int nb = 0; nb < nBall; nb ++) {\n    if (abs (abs (mod (db, lenPath) - (2.5 * dLinSeg + 2. * dRotSeg)) -\n       (dLinSeg + dRotSeg)) < 3. * ballRad) showFlap = false;\n    db += dGap;\n  }\n  bPos[0] = BallPos (0);  bNv[0] = trNv;  bAng[0] = trAng;\n  bPos[1] = BallPos (1);  bNv[1] = trNv;  bAng[1] = trAng;\n  bPos[2] = BallPos (2);  bNv[2] = trNv;  bAng[2] = trAng;\n  bPos[3] = BallPos (3);  bNv[3] = trNv;  bAng[3] = trAng;\n  bPos[4] = BallPos (4);  bNv[4] = trNv;  bAng[4] = trAng;\n  bPos[5] = BallPos (5);  bNv[5] = trNv;  bAng[5] = trAng;\n  bPos[6] = BallPos (6);  bNv[6] = trNv;  bAng[6] = trAng;\n  bPos[7] = BallPos (7);  bNv[7] = trNv;  bAng[7] = trAng;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, objCol;\n  float dstHit;\n  vec3 col = vec3 (0., 0., 0.02);\n  BallPM ();\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  int idObjT = idObj;\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    vec4 col4 = ObjCol (vn);\n    objCol = col4.xyz;\n    float spec = col4.w;\n    float dif = max (dot (vn, ltDir), 0.);\n    float ao = ObjAO (ro, vn);\n    col = objCol * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, ltDir) *\n       (dif + ao * spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  float zmFac = 4.2;\n  tCur = iTime;\n  fnSpir = float (nSpir);\n  posLin = 1.5;\n  radSpir = 3.;\n  dhSpir = 2.5;\n  rollVel = 2.;\n  dLinSeg = 2. * (posLin + radSpir);\n  dRotSeg = length (vec2 (2. * pi * (fnSpir - 0.25) * radSpir,\n     (fnSpir - 0.25) * dhSpir));\n  lenPath = 4. * (dLinSeg + dRotSeg);\n  ballRad = 0.6;\n  ballRad = lenPath / (2. * pi * floor (lenPath / (2. * pi * ballRad)));\n  float dist = 15. + 7.5 * fnSpir;\n  float el = 0.1;\n  float az = 0.;\n  el += 0.4 * SmoothBump (5., 25., 5., mod (tCur, 40.));\n  az += mod (0.1 * tCur, 2. * pi);\n  float cEl = cos (el);\n  float sEl = sin (el);\n  float cAz = cos (az);\n  float sAz = sin (az);\n  vuMat = mat3 (1., 0., 0., 0., cEl, - sEl, 0., sEl, cEl) *\n     mat3 (cAz, 0., sAz, 0., 1., 0., - sAz, 0., cAz);\n  vec3 rd = normalize (vec3 (uv, zmFac)) * vuMat;\n  vec3 ro = - vec3 (0., 0., dist) * vuMat;\n  ro.y -= 0.03 * dist;\n  ltDir = normalize (vec3 (0.3, 0.5, -1.)) * vuMat;\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2XWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 244, 268, 268, 315], [317, 317, 342, 342, 521], [523, 523, 544, 544, 681], [683, 683, 740, 740, 823], [825, 825, 857, 857, 952], [954, 954, 987, 987, 1014], [1016, 1016, 1058, 1058, 1109], [1111, 1111, 1157, 1157, 1228], [1525, 1525, 1561, 1561, 4290], [4292, 4292, 4314, 4314, 6072], [6074, 6074, 6109, 6109, 7259], [7261, 7261, 7283, 7283, 7378], [7380, 7380, 7413, 7413, 7616], [7618, 7618, 7639, 7639, 7884], [7886, 7886, 7923, 7923, 8135], [8137, 8137, 8169, 8169, 8351], [8353, 8353, 8370, 8370, 8672], [8674, 8674, 8705, 8705, 8917], [8919, 8919, 8941, 8941, 9233], [9235, 9235, 9251, 9251, 10007], [10009, 10009, 10044, 10044, 10757], [10759, 10759, 10816, 10816, 11903]]}
{"id": "XdBSDV", "name": "ShaderKK", "author": "pjdevpl", "description": "testing ", "tags": ["shadows", "spheretracing", "repeat"], "likes": 5, "viewed": 244, "date": "1415832286", "time_retrieved": "2024-06-20T18:14:48.686614", "image_code": "#define add(a,b)    min((a),(b))\n#define com(a,b)    max((a),(b))\n#define neg(a)        (-(a))\n#define sub(a,b)    com((a),neg(b))\n#define inf(a,v)    ((a)+(v))\n\n#define pi2            (2.*3.141593)\n#define R(plane,a)  (plane=vec2(cos((a)*pi2)*plane.x+sin((a)*pi2)*plane.y,cos((a)*pi2)*plane.y-sin((a)*pi2)*plane.x))\n\n#define pmod(a,b)    ( mod(mod((a),(b))+(b),(b)) )\n#define rep(a,r)    ( pmod(((a)+(r)*.5),(r))-(r)*.5 )\n\n#define repx(a,r)    vec3( rep((a).x,(r)), (a).yz )\n#define repy(a,r)    vec3( (a).x, rep((a).y,(r)), (a).z )\n#define repz(a,r)    vec3( (a).xy,rep((a).z,(r)) )\n#define repxy(a,r)    vec3( rep((a).xy,(r)), (a).z )\n#define repyz(a,r)    vec3( (a).x, rep((a).yz,(r)) )\n#define repxz(a,r)    vec3( rep((a).x,(r)), (a).y, rep((a).z,(r)) )\n\n\nfloat qla(vec3 pos,float r)\n{\n    return length(pos)-r;\n}\n\nfloat szescian(vec3 pos,vec3 s)\n{\n    pos = abs(pos)-s;\n    return max(pos.x,max(pos.y,pos.z));\n}\n\n\nfloat fn(vec3 pos)\n{\n    R(pos.xy,iTime/8.);\n    pos = repxy(pos,3.);\n    float q = qla(pos,1.2);\n    float s = szescian(pos,vec3(1.,1.,1.));\n    return sub(s,q);\n}\n\nfloat light(vec3 n,vec3 pos,vec3 ldir)\n{\n    ldir = normalize(ldir);\n\n    pos += n*.02;\n    vec3 spos = pos;\n    for(int i=0;i<50;i++)\n        pos += ldir*fn(pos);\n    if( length(pos-spos)<50. )\n        return 0.;\n\n    return clamp(dot(n,ldir),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vpos = uv*2.-1.;\n    vpos.x *= iResolution.x/iResolution.y;\n    vpos *= .65;\n\n    float t = iTime;\n//    vec3 front = normalize(vec3(sin(t),cos(t),0));\n    vec3 front = normalize(vec3(1.,0.,-0.5));\n    vec3 up = vec3(0,0,1);\n    vec3 right = cross(up,front);\n    vec3 pos = vec3(0.,0.,0.)-front*8.0;\n\n    vec3 rdir = normalize(front + vpos.x*right + vpos.y*up);\n\n    vec3 rpos = pos;\n    float d;\n\n    for(int i=0;i<50;i++)\n    {\n        d = fn(rpos);\n        rpos += d*rdir;\n        if(d<0.01) break;\n    }\n\n    if( d>0.05 )\n    {\n        // pustkosc\n        fragColor = vec4(.5,.8,.9,0.)*(pow(1.-abs(rdir.z),1.5));\n    }\n    else\n    {\n        // trafiony - normalka z pochodnych czastkowych (gradient)\n        vec2 e = vec2(0.01,0.);    // delta (epsilon)\n        // to sie dobrze kompresuje, ale Pawel tego nieeeee chceeeee... :P\n        // (chce, ale potem)\n        //vec3 n = normalize( vec3(\n        //    fn(rpos+e.xyy)-fn(rpos-e.xyy),\n        //    fn(rpos+e.yxy)-fn(rpos-e.yxy),\n        //    fn(rpos+e.yyx)-fn(rpos-e.yyx)\n        //) );\n\n        vec3 n = normalize(vec3(\n            fn(vec3(rpos.x+e.x, rpos.y, rpos.z)) - fn(vec3(rpos.x-e.x, rpos.y, rpos.z)),\n            fn(vec3(rpos.x, rpos.y+e.x, rpos.z)) - fn(vec3(rpos.x, rpos.y-e.x, rpos.z)),\n            fn(vec3(rpos.x, rpos.y, rpos.z+e.x)) - fn(vec3(rpos.x, rpos.y, rpos.z-e.x))));\n\n        vec3 col = vec3(0.);\n        float sunh = (sin(iTime)*.5+.5)*.5+.2;\n        col += light(n,rpos,vec3(-1.,-1.,sunh))*vec3(1,.8,.7);    // sun light\n        col += (1.-col)*(n.z*.5+.5)*vec3(.2,.6,.9);    // sky light; *(1-col) - soft swiatlo\n\n        fragColor = vec4(sqrt(col),0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBSDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[761, 761, 790, 790, 818], [820, 820, 853, 853, 917], [920, 920, 940, 940, 1084], [1086, 1086, 1126, 1126, 1339], [1341, 1341, 1398, 1398, 3101]]}
{"id": "XdBXDG", "name": "CubeSpace", "author": "Passion", "description": "I added some camera movement and rotation to this example http://www.demoscene.jp/?p=811 and added shading from this shader https://www.shadertoy.com/view/4s2XRd -Edit- Added rotation to the reprojected cube (line 40)", "tags": ["3d", "raymarch", "cubes"], "likes": 6, "viewed": 325, "date": "1415275040", "time_retrieved": "2024-06-20T18:14:49.232069", "image_code": "// References - http://www.demoscene.jp/?p=811\n//            - https://www.shadertoy.com/view/4s2XRd \nconst float eps = 0.001;\nconst float thresh = 2.0;\nconst float lowThresh = 0.25;\n\nvec3 light = normalize(vec3(-.5, 0.2, -0.2));\nvec3 light2 = normalize(vec3(.5, 0.2, 0.2));\n\n\nconst float pi = 3.14159265359;\n\n\nvec3 trans(vec3 p)\n{\n  return mod(p, 8.0)-4.0;\n}\n \nmat3 rx, ry, rz;\n\nfloat lengthN(vec3 v, float n)\n{\n  v*=rx*ry*rz;\n  vec3 tmp = pow(abs(v), vec3(n));\n  return pow(tmp.x+tmp.y+tmp.z, 1.0/n);\n}\n \nfloat distanceFunction(vec3 pos)\n{\n  //pos*=rz;  \n  return lengthN(trans(pos), 4.0) - 1.0;\n}\n \nvec3 getNormal(vec3 p)\n{\n  const float d = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),\n        distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),\n        distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))\n      )\n    );\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float movX = -100.+100.*sin(iTime*.02);\n    float movY = -155.+155.*sin(iTime*.06);\n    float movZ = -115.+115.*sin(iTime*.04);\n\n  vec2 pos = (fragCoord.xy*2.0 -iResolution.xy) / iResolution.y;\n  vec3 camPos = vec3(movX,movY,movZ);\n  vec3 camDir = vec3(0.0, 0.0, -1.0);\n  vec3 camUp = vec3(0.0, 1.0, 0.0);\n    \n  float radian = (iTime*pi)/180.0; \n\n  ry = mat3(cos(radian*12.), 0.0,-sin(radian*12.),\n            0.0, 1.0, 0.0, \n            sin(radian*12.), 0.0, cos(radian*12.)  );\n    \n  rz = mat3(cos(radian*150.),-sin(radian*150.), 0.0,\n            sin(radian*150.), cos(radian*150.), 0.0,\n            0.0, 0.0, 1.0 );\n     \n  rx = mat3(1.0, 0.0, 0.0,\n            0.0, cos(radian*13.), sin(radian*13.), \n            0.0,-sin(radian*13.), cos(radian*13.) );\n    \n        \n  camDir *= rx*ry;//*ry;//*rx;\n  camUp  *= rx*ry;//*ry;//*rx;\n\n  vec3 camSide = cross(camDir, camUp);\n  float focus = 1.8;\n  \n  vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*focus);\n \n  float t = 0.0, d;\n  vec3 posOnRay = camPos;\n \n  for(int i=0; i<48; ++i)\n  {\n    d = distanceFunction(posOnRay);\n    t += d;\n    posOnRay = camPos + t*rayDir;\n  }\n  \n  vec3 normal = getNormal(posOnRay);\n      \n  if(abs(d) < 0.001)\n  {  \n    //https://www.shadertoy.com/view/4s2XRd\n    float diffuse = clamp( dot(normal, light), 0., 1.);\n    float specular = 1.5*pow(clamp(dot(reflect(rayDir, normal), light), 0., 1.), 180.);\n    float specular2 = 1.5*pow(clamp(dot(reflect(rayDir, normal), light2), 0., 1.), 200.);\n\tvec3 brdf = 1.5*vec3(.10, .11, .11);\n\tfloat fre = 0.1*pow(clamp(1. + dot(normal, rayDir), 0., 1.), 2.);\n    brdf += 1.30*diffuse*vec3(1., .9, .75);\n\t\n\tfragColor = vec4(normal+specular+specular2+fre+brdf, 1.0);\n  }else\n  {\n    fragColor = vec4(0.0);\n  }\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBXDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 311, 331, 331, 359], [380, 380, 412, 412, 504], [507, 507, 541, 556, 599], [602, 602, 626, 626, 962], [965, 965, 1022, 1022, 2775]]}
{"id": "XdBXDt", "name": "de Casteljau", "author": "vgs", "description": "Approximating a cubic BÃÂ©zier Curve by 15 line segments using the de Casteljau's algorithm.\nClick to move the third control point.", "tags": ["bezier", "approximation", "casteljau", "decasteljau"], "likes": 19, "viewed": 711, "date": "1416952561", "time_retrieved": "2024-06-20T18:14:49.662517", "image_code": "// Created by Vinicius Graciano Santos - vgs/2014\n// This shader renders an approximation of a cubic Bezier using the de Casteljau's algorithm.\n// It splits the bezier into multiple smaller ones and renders their control points connected with line segments.\n\nstruct Bezier {\n    vec2 a, b, c, d;\n};\n\n// splits a bezier B (t = 0.5) into beziers L and R.\nvoid decasteljau(in Bezier B, out Bezier L, out Bezier R) {\n\tL.a = B.a;          R.d = B.d;\n    L.b = .5*(B.a+B.b); R.c = .5*(B.c+B.d); \n    vec2 tmp = .5*(B.b+B.c);\n    L.c = .5*(L.b+tmp); R.b = .5*(R.c+tmp);\n    L.d = R.a = .5*(L.c+R.b);\n}\n\n// distance to the control points.\nfloat distCP(vec2 p, Bezier B) {\n    return min(min(length(p - B.a), length(p - B.b)),\n               min(length(p - B.c), length(p - B.d)));\n}\n\n// distance to a line segment.\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a, ab = b - a;\n    float k = clamp(dot(ap, ab)/dot(ab,ab), 0.0, 1.0);\n    return length(ap - k*ab);\n}\n\n// distance to the linear approximation.\nfloat distLinear(vec2 p, Bezier B) {\n    return min(min(segment(p, B.a, B.b), segment(p, B.b, B.c)), segment(p, B.c, B.d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float c = cos(iTime), s = sin(iTime);\n    \n    // Control points (change these to play with the curve).\n\tvec2 PA = vec2(-1.5*c, .8*s);\n\tvec2 PB = iMouse.z > 0.0 ? (-iResolution.xy + 2.0*iMouse.xy) / iResolution.y : vec2(.5);\n\tvec2 PC = vec2(-c*s, -.8*c);\n\tvec2 PD = vec2(1.5*s, 0.);\n    \n    Bezier bezier[16]; \n    bezier[0] = Bezier(PA, PB, PC, PD);\n    float dCP  = distCP(uv, bezier[0]), dLCP = distLinear(uv, bezier[0]);\n                    \n    // just an unrolled recursion, yey! :D\n    decasteljau(bezier[0], bezier[0], bezier[8]);    decasteljau(bezier[0], bezier[0], bezier[4]);\n    decasteljau(bezier[8], bezier[8], bezier[12]);   decasteljau(bezier[0], bezier[0], bezier[2]);\n    decasteljau(bezier[4], bezier[4], bezier[6]);    decasteljau(bezier[8], bezier[8], bezier[10]);\n    decasteljau(bezier[12], bezier[12], bezier[14]); decasteljau(bezier[0], bezier[0], bezier[1]);\n    decasteljau(bezier[2], bezier[2], bezier[3]);    decasteljau(bezier[4], bezier[4], bezier[5]);\n    decasteljau(bezier[6], bezier[6], bezier[7]);    decasteljau(bezier[8], bezier[8], bezier[9]);\n    decasteljau(bezier[10], bezier[10], bezier[11]); decasteljau(bezier[12], bezier[12], bezier[13]);\n    decasteljau(bezier[14], bezier[14], bezier[15]);\n    \n\tfloat dLA = 100.0;\n    for (int i = 0; i < 16; ++i)\n        dLA = min(dLA, distLinear(uv, bezier[i]));\n    \n    // shading.\n    vec3 blue   = pow(vec3(189., 199., 255.)/255., vec3(2.2));\n    vec3 green  = pow(vec3(194., 255., 148.)/255., vec3(2.2));\n    vec3 dgreen = pow(vec3(125., 178., 86. )/255., vec3(2.2));\n    \n    vec3 col = mix(green, dgreen, smoothstep(0.005, 0.01, dLCP));\n    col = mix(blue, col, smoothstep(0.01, 0.015, dLA));\n    col = mix(green, col, smoothstep(0.05, 0.06, dCP));\n    col = mix(col, green, pow(st.x*st.y*(1.0-st.x)*(1.0-st.y), .3));\n    col = smoothstep(0.0, 1.0, col);\n    \n\tfragColor = vec4(pow(col, vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBXDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[300, 353, 412, 412, 594], [596, 631, 663, 663, 774], [776, 807, 846, 846, 966], [968, 1009, 1045, 1045, 1134], [1136, 1136, 1193, 1193, 3210]]}
{"id": "XdjSDy", "name": "Triangle - occlusion", "author": "iq", "description": "Analytical ambient occlusion of a triangle. Left side of screen, stochastically sampled occlusion. Right side of the screen, analytical solution (no rays casted). Move the mouse to compare.", "tags": ["3d", "triangle", "occlusion", "analytic"], "likes": 30, "viewed": 3204, "date": "1415594551", "time_retrieved": "2024-06-20T18:14:50.602013", "image_code": "// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytical ambient occlusion of a triangle. Left side of screen, stochastically \n// sampled occlusion. Right side of the screen, analytical solution (no rays casted).\n//\n// If the polygons was intersecting the ground plane, we'd need to perform clipping\n// and use the resulting triangles for the analytic formula instead.\n    \n\n// Other shaders with analytical occlusion or approximations:\n// \n// Box:                        https://www.shadertoy.com/view/4djXDy\n// Box with horizon clipping:  https://www.shadertoy.com/view/4sSXDV\n// Triangle:                   https://www.shadertoy.com/view/XdjSDy\n// Sphere:                     https://www.shadertoy.com/view/4djSDy\n// Ellipsoid (approximation):  https://www.shadertoy.com/view/MlsSzn\n// Capsule (approximation):    https://www.shadertoy.com/view/llGyzG\n\n\n// Other triangle functions:\n//\n// Occlusion:    https://www.shadertoy.com/view/XdjSDy\n// Distance:     https://www.shadertoy.com/view/4sXXRN\n// Intersection: https://www.shadertoy.com/view/MlGcDz\n// Closest:      https://www.shadertoy.com/view/ttfGWl\n\n//=====================================================\n\n// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = v0 - v1;\n    vec3 b = v2 - v0;\n    vec3 p = v0 - ro;\n    vec3 n = cross( b, a );\n    vec3 q = cross( p, rd );\n\n    float idet = 1.0/dot( rd, n );\n\n    float u = dot( q, b )*idet;\n    float v = dot( q, a )*idet;\n    float t = dot( n, p )*idet;\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n\n    return vec3( t, u, v );\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = normalize( v0 - pos );\n    vec3 b = normalize( v1 - pos );\n    vec3 c = normalize( v2 - pos );\n    \n    float s = sign(dot(v0-pos,cross(v1-v0,v2-v1))); // side of the triangle\n\n    return s*(dot( nor, normalize( cross(a,b)) ) * acos( dot(a,b) ) +\n              dot( nor, normalize( cross(b,c)) ) * acos( dot(b,c) ) +\n              dot( nor, normalize( cross(c,a)) ) * acos( dot(c,a) ) ) / 6.2831;\n}\n\n//=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // triangle animation\n    vec3 v1 = cos( iTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(1.5,1.0,1.0);\n\tvec3 v2 = cos( iTime + vec3(5.0,2.0,3.0) + 2.0 )*vec3(1.5,1.0,1.0);\n\tvec3 v3 = cos( iTime + vec3(1.0,3.0,5.0) + 4.0 )*vec3(1.5,1.0,1.0);\n\n    vec4 rrr = texture( iChannel0, (fragCoord.xy)/iChannelResolution[0].xy, -99.0  ).xzyw;\n\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = 0.0;\n        \n        if( p.x > s )\n        {\n            occ = triOcclusion( pos, nor, v1, v2, v3 );\n        }\n        else\n        {\n   \t\t    vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\t    vec3  rv  = normalize( cross( ru, nor ) );\n\n            occ = 0.0;\n            for( int i=0; i<256; i++ )\n            {\n                vec2  aa = hash2( rrr.x + float(i)*203.1 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  dir = vec3( rx*ru + ry*rv + rz*nor );\n                vec3 res = triIntersect( pos+nor*0.001, dir, v1, v2, v3 );\n                occ += step(0.0,res.x);\n            }\n            occ /= 256.0;\n        }\n\n        col = vec3(1.0);\n        col *= 1.0 - occ;\n    }\n\n    vec3 res = triIntersect( ro, rd, v1, v2, v3 );\n    float t2 = res.x;\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = normalize( cross( v2-v1, v3-v1 ) );\n\t\tcol = vec3(1.0,0.8,0.5);\n        col *= 1.5*texture( iChannel1, res.yz ).xyz;\n        col *= 0.6 + 0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjSDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2203, 2249, 2330, 2330, 2675], [2677, 2718, 2802, 2802, 3214], [3216, 3273, 3296, 3296, 3366], [3368, 3368, 3408, 3408, 3441], [3443, 3443, 3500, 3500, 5631]]}
{"id": "XdjXDV", "name": "VR Post FX Projection", "author": "mplanck", "description": "A post process that modulates the final color using a 2D texture lookup but sticks to the environment as head position changes in 3d - an interesting depth/sphere/cubemap trick.  Camera origin moves around to simulate VR.  Spheres are moving in and out.", "tags": ["posteffect", "vr"], "likes": 10, "viewed": 615, "date": "1416202263", "time_retrieved": "2024-06-20T18:14:52.377746", "image_code": "#define BIG_FLOAT 1e10\n#define SMALL_FLOAT 1e-5\n#define PI 3.14159\n\n#define STATIC_TEXTURE 1\n#define ANIMATED_NOISE 2\n#define SLIDING_PROJECTION 3\n\n#define PROJECTION_TYPE ANIMATED_NOISE\n\n//----------------------------------------------------------------------------------------\n// Thanks to Dave Hoskins\nvec3 hash32(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4337, p.x * p.y * 97.597, p.x * p.y * 93.8365));\n}\n\n// XXX: To get around a case where a number very close to zero can result in \n// eradic behavior with sign, we assume a positive sign when a value is \n// close to 0.\nfloat ztsign(float value)\n{\n    float s = 1.;\n    if (abs(value) > SMALL_FLOAT) {\n        s = sign(value);\n    }\n    return s;   \n}\n\n// intersection for an enclosing sphere with a ray.\n// Returns a vec3 where:\n//  result.x = number of intersections taking place\n//  result.y = tmin\n//  result.z = tmax\n\nvec3 intersect_sphere(vec3 ro,                 \n                             vec3 rd, \n                             float r,\n                             vec3 sc)\n{\n    // Calculate the ray origin in object space of the sphere\n    vec3 oro = ro - sc;\n\n    // We don't consider an intersection if the ray is inside the sphere\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (dot(ospaceRayOrigin, ospaceRayOrigin) < radius*radius) {\n    //     return vec3(0.);\n    // }\n    float inside = step(dot(oro, oro), r*r);\n    \n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - r*r;\n    float discr = b*b - a*c; // discriminant\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (discr > 0.) {\n    //     ...\n    // }\n\n    float isdiscrgtZero = step(0., discr);\n\n    // Real root of disc, so intersection\n    float sdisc = sqrt(abs(discr));\n    float tmin = (-b - sdisc)/a;\n    float tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmin) + step(0., tmax);\n\n    return step(0., isdiscrgtZero) * vec3(hit, tmin, tmax);\n}\n\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that origin + t*dir = hit point\nvec2 intersect_plane(vec3 ro,\n                     vec3 rd,\n                     vec3 pn,\n                     vec3 po)\n{\n    float rddotpn = dot(rd, pn);\n    // if the ray direction is parallel to the plane, let's just treat the \n    // ray as intersecting *really* far off, which will get culled as a\n    // possible intersection.\n\n    float denom = ztsign(rddotpn) * max(abs(rddotpn), SMALL_FLOAT);\n    float t = min(BIG_FLOAT, -dot(pn, (ro - po)) / denom);    \n    return vec2(step(SMALL_FLOAT, t), t);\n}\n\nvec3 rotate_look(vec3 l)\n{\n    float y = .05 * iTime;\n    if (iMouse.y/iResolution.y > .1)\n    {\n        y = -PI * iMouse.x/iResolution.x;\n    }\n    return l * mat3(cos(y), 0., sin(y),\n                    0.,     1., 0.,\n                   -sin(y), 0., cos(y));\n}\n\nvec3 texture_cube(vec3 usphp, float scale)\n{\n    // cheap way of turning a 2D texture into a cube\n    // map lookup by ray casting sphere intersection direction \n    // to the appropriate plane of the surrounding cube and then\n    // using the uv of that plane intersection as a 2d vector.\n    \n    vec3 p = usphp;\n#if PROJECTION_TYPE == SLIDING_PROJECTION\n    p.y -= sin(.1 * iTime);\n#endif\n    \n    float ml = max(abs(p.x), max(abs(p.y), abs(p.z)));\n    vec3 ansphp = abs(p/ml); \n    \n    // select the plane offset of a unit cube\n    vec3 upo = sign(p) * step(vec3(1. - SMALL_FLOAT), ansphp);\n    \n    // scale the plane we are intersecting by the offset\n    vec2 pr = intersect_plane(vec3(0.), p, -upo, scale * upo);\n    vec3 pp = pr.y * p;\n\n    // get the uv lookup of the plane intersection.\n    vec2 uv = step(1. - SMALL_FLOAT, ansphp.x) * pp.yz;\n    uv += step(1. - SMALL_FLOAT, ansphp.y) * pp.xz;\n    uv += step(1. - SMALL_FLOAT, ansphp.z) * pp.xy;\n\n#if PROJECTION_TYPE == STATIC_TEXTURE | PROJECTION_TYPE == SLIDING_PROJECTION\n    \n    // filter texture lookup more when unit cube is closer to\n    // unit sphere - cheap hack to compensate for the fact\n    // that the texture lookup is more stretched near the\n    // corners.\n    float f = 1.2 * (1. - length(pp/scale - p));\n    \n    return texture(iChannel0, .5 * uv + .5, f).rgb;\n#elif PROJECTION_TYPE == ANIMATED_NOISE\n    \n    return hash32(.5 * uv + .5);\n    \n#endif\n\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\nfloat spheredf( vec3 p, float r )\n{\n    return length(p) - r;    \n}\n\nfloat yplanedf( vec3 p, float offset )\n{\n    return abs(p.y - offset);\n}\n\nfloat cyldf( vec3 p, float r)\n{\n    return - (length(p.xz) - r);\n}\n\nfloat scenedf( vec3 pos )\n{\n    float dist = BIG_FLOAT;\n\n    for (float i = 0.; i < 12.; i += 1.)\n    {\n        float s = PI * i/6.;\n        float r = 5. + 5. * (.5 * cos(PI * i/2. + .2 * iTime) + .5);\n        vec3 sphc = vec3(r * cos(s), .7, r * sin(s));\n        dist = min(spheredf(pos - sphc, 1.), dist);\n    }\n\n    dist = min(yplanedf(pos, -1.3), dist);\n\tdist = min(cyldf(pos, 15.), dist);\n    return dist;\n}\n\n#define DISTMARCH_STEPS 50\n#define DISTMARCH_MAXDIST 20.\n\nvec3 surface_normal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scenedf(p + epsilon.xyy) - scenedf(p - epsilon.xyy),\n        scenedf(p + epsilon.yxy) - scenedf(p - epsilon.yxy),\n        scenedf(p + epsilon.yyx) - scenedf(p - epsilon.yyx) );\n    return normalize( n );\n}\n\n\n#define SOFTSHADOW_STEPS 30\n#define SOFTSHADOW_STEPSIZE .3\n\nfloat soft_shadow( vec3 ro, \n                   vec3 rd, \n                   float mint, \n                   float maxt, \n                   float k )\n{\n    float shadow = 1.0;\n    float t = mint;\n\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\n    {\n        if( t < maxt )\n        {\n            float h = scenedf( ro + rd * t );\n            shadow = min( shadow, k * h / t );\n            t += SOFTSHADOW_STEPSIZE;\n        }\n    }\n    return clamp( shadow, 0.0, 1.0 );\n\n}\n\n#define AO_NUMSAMPLES 5\n#define AO_STEPSIZE .3\n#define AO_STEPSCALE .7\n\nfloat ambient_occ( vec3 p, \n\t\t          vec3 n )\n{\n    float ao = 0.0;\n    float aoscale = 1.0;\n\n    for( int aoi=0; aoi < AO_NUMSAMPLES ; aoi++ )\n    {\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\n        vec3 aop =  n * step + p;\n        \n        float d = scenedf( aop );\n        ao += -(d-step)*aoscale;\n        aoscale *= AO_STEPSCALE;\n    }\n    \n    return clamp( ao, 0.0, 1.0 );\n}\n\n\nvec2 dist_march( vec3 ro, vec3 rd, float maxd )\n{\n    \n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || t > maxd ) break;\n        t += dist;\n        dist = scenedf( ro + t * rd );\n    }\n\n\n    float objhit = 0.;\n    if( t < maxd ) \n    {\n        objhit = 1.;\n    }\n\n    return vec2(objhit, t);\n}\n\nvec3 shade_scene( vec3 ip, vec3 ro, vec3 rd )\n{\n    vec3 lpos = 4. * vec3(0., 1., 0.);\n    vec3 n = surface_normal( ip );\n    vec3 ldir = normalize(lpos - ip);\n    \n    float s = soft_shadow( ip, ldir, .02, 10., 10.);\n    float ao = ambient_occ( ip, n );\n    \n    float mody = mod(4. * ip.y, 1.);\n    float stripes = step(length(ip.xz), 14.) * (smoothstep(0., .05, mody) - smoothstep(.5, .55, mody));\n    vec3 scol =  mix(vec3(.5, .6, 1.), vec3(.2, .2, .4), stripes);\n\n    float falloff = pow(max(0., 1. - length(lpos - ip)/19.), 2.);\n\n    vec3 diff = 5. * scol * max(0., dot(ldir, n));\n    vec3 spec = vec3(2.) * pow(max(0., dot(ldir, reflect(rd, n))), 8.);\n    vec3 amb = scol * .8 * (1. - ao);\n    vec3 bnc = scol * .6 * pow(ip.y + 1.3,2.) * max(0., dot(n, normalize(ro - ip + vec3(0., -8., 0.))));\n    \n    return falloff * (s * (diff + spec) + \n           \t\t      (amb + bnc));\n}\n\nvec3 renderEye( in vec3 fragRayOri, in vec3 fragRayDir, in vec2 uv )\n{\n    vec3 scol = vec3(0.);\n    \n    vec3 ro = fragRayOri;\n    vec3 rd = fragRayDir;\n    vec2 dr = dist_march(ro, rd, DISTMARCH_MAXDIST);\n    \n    // shade\n    if (dr.x > 0.5)\n    {\n\t    vec3 ip = ro + rd * dr.y;\n        scol = shade_scene(ip, ro, rd);\n    \n        // post effect projection\n        vec3 sphc = vec3(0.);\n        vec3 sphr = intersect_sphere(ro, rd, 1. * length(ip), sphc);     \n        vec3 sphp = ro + sphr.z * rd;\n\n        scol *= .5 + .5 * texture_cube(normalize(sphp - sphc), 5.);\n\t\t//scol = pow(scol, vec3(1.) + .5 * texture_cube(normalize(sphp - sphc), 5.));\n            \n        // gamma\n\t    scol = pow(scol, vec3(.5));\n    }    \n            \n    // spherical vignette\n    scol *= pow(max(1. - length(uv),0.), 1.);\n\n    return scol;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    // camera\n    vec3 f = rotate_look(vec3(0., 0., 1.));\n    vec3 u = vec3(0., 1., 0.);\n\n    vec3 cx = normalize(cross(f, u));\n    vec3 cy = cross(cx, f);\n    vec3 cz = f;\n    \n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(uv.x * cx + uv.y * cy + 1. * cz);\n    \n    vec3 scol = vec3(0.);\n\n    ro = 1. * vec3(2. * pow((.5 * sin(.5 * iTime) + .5), 4.) - 1., \n                   1. * pow((.5 * cos(.8 * iTime + 1.) + .5), 4.), \n\t\t\t        0.);\n    \n    vec3 scene_color = renderEye(ro, rd, uv);\n    \n    fragColor.rgb = scene_color;\n    fragColor.a = 1.;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    vec3 col = renderEye( fragRayOri + vec3(0.,1.,0.), fragRayDir, uv );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjXDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[188, 305, 326, 326, 502], [504, 670, 697, 697, 801], [803, 973, 1137, 1199, 2017], [2020, 2143, 2264, 2264, 2651], [2653, 2653, 2679, 2679, 2916], [2918, 2918, 2962, 3207, 4353], [4355, 4452, 4487, 4487, 4519], [4521, 4521, 4561, 4561, 4593], [4595, 4595, 4626, 4626, 4661], [4663, 4663, 4690, 4690, 5075], [5135, 5135, 5166, 5166, 5443], [5506, 5506, 5658, 5658, 5976], [6050, 6050, 6100, 6100, 6446], [6449, 6449, 6498, 6498, 6858], [6860, 6860, 6907, 6907, 7744], [7746, 7746, 7816, 7816, 8578], [8580, 8580, 8637, 8637, 9293], [9295, 9295, 9389, 9389, 9549]]}
{"id": "XdSSDc", "name": "Energy Wave", "author": "aaaidan", "description": "I have no idea what this is or how I made it.", "tags": ["stripes"], "likes": 3, "viewed": 277, "date": "1416358237", "time_retrieved": "2024-06-20T18:14:52.990048", "image_code": "//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat fancyStep(vec2 position, float x, float width, float offset) {\n    float stepCenter = snoise(position.xy*0.01) * (width*(sin(iTime *0.5)*1.5+1.)) + 0.5 + offset;\n    float stepWidth = snoise(position.xy*0.01 + 289.) * 0.3 + 0.4;\n    return smoothstep( stepCenter - stepWidth, stepCenter + stepWidth, x);\n}\n\nfloat striation(vec2 position, float time) {\n    return sin(position.y*0.17 + \n        0.2*sin(position.x*0.1 - time*10.) +\n        1.*snoise(position.xy*0.01 + time*0.1) +\n        2.*snoise(position.x*0.007 - position.y*0.003 + vec2(289.,1232.) ) +\n        8.*snoise(position.xx*0.001 + position.yy * 0.001 - time * 0.1)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float t = iTime * 0.3;\n    float scale = 1.0 / (iResolution.x * 0.001);\n    vec2 position = scale * (fragCoord.xy - iResolution.xy/2. + vec2(t *100.,0.) + 50.*vec2(sin(t )*0.4, cos(t *0.4)*3.2));\n    \n    float red = fancyStep(position, striation(position, t -0.0), -1.2, -0.6);\n    float green = fancyStep(position, striation(position, t ), 1.1, 0.0);\n    float blue = fancyStep(position, striation(position, t +0.0), 2.8, 0.5);\n    fragColor = vec4( red, green, blue, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSSDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 369, 390, 390, 439], [441, 441, 462, 462, 511], [513, 513, 535, 535, 572], [574, 574, 598, 598, 2104], [2106, 2106, 2174, 2174, 2417], [2419, 2419, 2463, 2463, 2753], [2755, 2755, 2812, 2812, 3297]]}
{"id": "XdSSWy", "name": "rainbow wave", "author": "neo", "description": "using sin wave for rainbow color", "tags": ["rainbowsinwave"], "likes": 9, "viewed": 328, "date": "1415330971", "time_retrieved": "2024-06-20T18:14:52.990048", "image_code": "\nfloat cube_width = 20.0;\nfloat wave_width = 2.5;\nfloat PI = 3.1415926;\nvec4 rainbow_color(int i)\n{\n    vec4 c;\n\t\n\tif (i == 0) c=vec4(0,0,0,0); else\n\tif (i == 1) c= vec4(255,43,14,255)/255.0; else\n\tif (i == 2) c= vec4(255,168,6,255)/255.0; else\n\tif (i == 3) c= vec4(255,244,0,255)/255.0; else\n\tif (i == 4) c= vec4(51,234,5,255)/255.0; else\n\tif (i == 5) c= vec4(8,163,255,255)/255.0; else\n\tif (i == 6) c= vec4(122,85,255,255)/255.0; else\n\t\tc=vec4(0,0,0,0);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 1.0 - 2.0 * uv;\n   \n    //wave\n    vec4 wave_color = vec4(0.);\n    for(int i = 0;i<7;++i)\n    {\n    \tfloat y = 0.1 * sin(uv.x*PI + float(i)/3. + iTime*PI ) + uv.y+float(i)/10.0 - 0.5;\n    \tfloat wave = abs(1.0 / (y * iResolution.y /wave_width));\n    \twave_color += rainbow_color(i)*wave;\n    }\n    \n    //back ground\n    float c1 = mod(fragCoord.x,2.0 * cube_width);\n    c1 = smoothstep(cube_width*0.7,cube_width*1.3,c1);\n    float c2 = mod(fragCoord.y,2.0 * cube_width);\n    c2 = smoothstep(cube_width*0.7,cube_width*1.3,c2);\n    vec4 bcolor = mix(vec4(0.0,0.2,0.3,1.0),vec4(0.5,0.0,0.,1.0),c1*c2);\n\tfragColor = bcolor + wave_color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSSWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[72, 72, 99, 99, 468], [470, 470, 527, 527, 1217]]}
{"id": "XdSXDc", "name": "Pustules", "author": "nimitz", "description": "Alternate name: \"Wet turd\"\n\nMouse enabled.", "tags": ["3d", "raymarching", "voronoi", "pbr", "tasty"], "likes": 67, "viewed": 2894, "date": "1416366785", "time_retrieved": "2024-06-20T18:14:54.577946", "image_code": "//Pustules by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XdSXDc\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTrying to achive high percieved detail with while keeping\n\tcomputational cost to a minimum.\n\n\tThe render is done in 3 steps. The base raymarched geometry,\n\twhich is then followed by a refined domain raymarching loop\ton more \n\tcomplex geometry (2 layers of 8-tap 3d voronoi displacement).\n\tAnd finally fine detail is added with gradient bump mapping on a 3d field.\n*/\n\n//#define USE_DISNEYS_DIFFUSE\n\n#define FAR 7.\n#define time iTime*0.5\n#define PI 3.14159265\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat smin( in float a, in float b, in float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rand22(in vec2 p){\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\nfloat hash( float n ) { return fract(sin(n)*43758.5453); }\n\n//Trying to get away with 8-tap 3d voronoi\nvec3 vor(in vec3 p)\n{\n    p *= 4.;\n    float pri = -1.;\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float rid = -1.;\n    vec2 rz = vec2(2.);\n    float dc = 0.;\n    for (int i=-1; i<=0; i++) \n\tfor (int j=-1; j<=0; j++) \n\tfor (int k=-1; k<=0; k++) \n\t{\n\t\tvec3 ir = ip + vec3(i, j, k);\n\t\tvec3 fr = fp - vec3(i, j, k);\n\t\tvec2 uid = ir.xy * vec2(0.037, 0.119) + ir.z * 0.00301;\n        vec2 rand = rand22(uid)*.66+.67;\n        vec3 pp = fr -(vec3(rand.x));\n        float d = dot(pp, pp);\n        if (d < rz.x)\n\t\t{\n            rz.y = rz.x;\n            rz.x = d;\n            dc = d;\n            rid = hash(dot(uid,vec2(1.01,17.01)));\n\t\t}\n        else if(d < rz.y)\n\t{\n    \trz.y = d;\n\t}\n\t}\n\n    rz.y = rz.y-rz.x;\n    return vec3(rz,rid);\n}\n\nfloat map(vec3 p)\n{\n    float mv =sin(time*1.5+sin(time*2.7))*0.51;\n    float d = length(p-mv)-.51;\n    d = smin(d,length(p+mv)-.45,1.9);\n    \n    return d;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<70; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*1.1;\n        h = res;\n    }\n\treturn d;\n}\nvec2 mapHD(vec3 p)\n{\n    float d = map(p);\n    float id = 0.;\n    vec3 rz = vor(p*1.1)*0.1;\n    d += rz.x;\n    id = rz.y+rz.z*0.7;\n    rz =  vor(p*2.1)*0.05;\n    d += rz.x;\n    id += rz.y+rz.z;\n    \n    return vec2(d*0.9,id);\n}\n\nvec2 marchHD(in vec3 ro, in vec3 rd, in float d)\n{\n\tfloat maxd = FAR;\n    float precis = 0.008;\n    float h=precis*2.0;\n    float id = 0.;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(h)<precis || d>maxd ) break;\n        d += h;\n\t    vec2 res = mapHD(ro+rd*d);\n        h = res.x;\n        id = res.y;\n    }\n    if (d>maxd)d = 1000.;\n\treturn vec2(d,id);\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\tvec3 n = normalize(e.yxx*mapHD(p + e.yxx).x + e.xxy*mapHD(p + e.xxy).x + \n\t\t\t\t\t e.xyx*mapHD(p + e.xyx).x + e.yyy*mapHD(p + e.yyy).x ); \n    \n    float k = dot(-rd,n);\n    return n + rd*k*(0.5-0.5*sign(k));\n}\n\n\n//from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat ssin(float x) \n{\n    float rz = sin(x)*0.5+0.5;\n\treturn rz*rz;\n}\n\nfloat fbm(vec3 p) \n{\n    float t = 0.;\n    float z = 4.;\n    for (int i=0;i<3;i++)\n    {\n        t += (noise(p) / z);\n        z *= 3.;\n        p *= 2.8;\n    }\n    return t;\n}\n\nfloat bnoise(in vec3 p)\n{\n    float n = ssin(fbm(p*21.)*40.)*0.003;\n    return n;\n}\n\nvec3 bump(in vec3 p, in vec3 n)\n{\n    vec2 e = vec2(.01,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*2.);\n    return n;\n}\n\n//shadows and AO from iq\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {\n\t\tfloat h = mapHD(ro + rd*t).x;\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.02, .20 );\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = mapHD( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat hornerD(in float f, in float x){return 1. + (f - 1.) * exp2((-5.55473 * x - 6.98316) * x);}\n\n//mostly from: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 shade(in vec3 pos, in vec3 n, in vec3 rd, in vec3 l, in vec3 lcol, in vec3 alb)\n{\n    //material data (could be passed in)\n    const float rough = 0.4;\n    const vec3 F0 = vec3(.02);\n    const float kr = .3; //diff/spec ratio\n    \n    float nl = dot(n, l);\n    float nv = dot(n, -rd);\n    vec3 col = vec3(0.);\n    float ao = calcAO(pos, n);\n    if (nl > 0. && nv > 0.)\n    {\n        vec3 haf = normalize(l - rd);\n        float nh = dot(n, haf); \n        float vh = dot(-rd, haf);\n        \n        #ifdef USE_DISNEYS_DIFFUSE\n        float fd90 = 0.5+ 2.*vh*vh*rough;\n        vec3 dif = nl*alb*hornerD(fd90, nl)*hornerD(fd90, nv);\n        #else\n        vec3 dif = alb*nl;\n        #endif\n        \n        float a = rough*rough;\n        float a2 = a*a;\n        float dn = nh*nh*(a2 - 1.) + 1.;\n        float D = a2/(PI*dn*dn);\n        \n        float k = pow( rough*0.5 + 0.5, 2.0 )*0.5;\n        float nvc = max(nv,0.);\n        float gv = nvc/(nvc*(1.-k) + k);\n        float gl = nl/(nl*(1.-k) + k);\n        float G = gv*gl;\n\n        vec3 F = F0 + (1. - F0) * exp2((-5.55473 * vh - 6.98316) * vh);\n        \n        vec3 spe = D*F*G/(nl*nv);\n    \t\n        #if 1\n        col = lcol*mix(spe*nl, dif, kr);\n        #else\n        col = lcol*nl*mix(spe, dif, kr);\n        #endif\n        col *= shadow( pos, l, 0.05, 10.);\n    }\n    col += 0.07*alb*ao;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 bp = fragCoord.xy/iResolution.xy;\n    vec2 p = bp*2.-1.;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.5,0.3):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    \n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-3.6));\n    mat2 mx = mm2(time*.04+mo.x*6.);\n    mat2 my = mm2(time*0.06+mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    float edl = dot(rd,ligt)*0.5+.5;\n    vec3 bgvor = vor(rd*4.2)*0.35;\n    bgvor += vor(rd*9.)*0.25;\n    bgvor += vor(rd*25.)*0.1;\n    vec3 bgcol = ((bgvor.z*.5 + 0.1)*(.5 - bgvor.x*1.5*(1.5 - bgvor.y*10.)))\n        *(sin(vec3(1,1.5,1.7) + noise(rd*24.))*.5+.5);\n    vec3 lcol = vec3(.9,.85,.75)*1.2;\n    bgcol *= bgcol;\n    vec3 col = bgcol*0.8 + edl*bgcol + (pow(edl,150.)*2.5 + smoothstep(0.998,1.,edl))*lcol*0.35;\n    \n    float rz = march(ro,rd);\n    if ( rz < FAR )\n    {\n        vec2 rzH = marchHD(ro,rd,rz);\n        float rzHD = rzH.x;\n        rz = rzH.x;\n        if (rzHD < FAR)\n        {\n            vec3 pos = ro+rzHD*rd;\n            vec3 nor= normal(pos, rd);\n            nor = bump(pos,nor);\n            col = sin(vec3(1.95,1.63,1.4)+rzH.y*13.+8.6)*.57+.7;\n            col *= col;\n            col = shade(pos, nor, rd, ligt, lcol,col);\n        }\n    }\n\t\n   \tcol *= pow(16.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y),0.1);\n   \n   \tcol = clamp(col,0.,1.);\n   \tcol = clamp(pow(col, vec3(0.416667))*1.055 - 0.055,0.,1.); //cheap sRGB approx\n   \tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSXDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[592, 684, 705, 705, 757], [759, 759, 809, 809, 898], [900, 900, 923, 923, 1015], [1016, 1016, 1039, 1039, 1074], [1076, 1119, 1140, 1140, 1856], [1858, 1858, 1877, 1877, 2016], [2018, 2018, 2055, 2055, 2287], [2288, 2288, 2308, 2308, 2515], [2517, 2517, 2567, 2567, 2878], [2880, 2880, 2916, 2916, 3164], [3167, 3177, 3203, 3203, 3570], [3572, 3572, 3594, 3594, 3642], [3644, 3644, 3664, 3664, 3818], [3820, 3820, 3845, 3845, 3903], [3905, 3905, 3938, 3938, 4116], [4118, 4143, 4211, 4211, 4468], [4470, 4470, 4512, 4512, 4812], [4814, 4814, 4852, 4852, 4911], [4913, 5023, 5109, 5150, 6385], [6387, 6387, 6444, 6444, 8005]]}
{"id": "XdSXWG", "name": "Paper Logo", "author": "daeken", "description": "Paper sketch version of my logo.", "tags": ["2d", "shaderforth"], "likes": 4, "viewed": 247, "date": "1415221605", "time_retrieved": "2024-06-20T18:14:55.505268", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m anim\n\t1 iTime 8 mod 4 - abs 1 - 1.5 / 0 1 clamp 3 pow -\n;\n\n: cwarp ( c:vec3 -> vec3 )\n\tanim =t\n\t[\n\t\t\tc .xy 1 t - *\n\t\t\t[ t pi * -1 * 0 ]\n\t\tp+\n\t\tc .z t 2.5 * 1 + *\n\t]\n;\n\n: p-circle ( p:vec2 c:vec3 -> float )\n\tc cwarp =c\n\tc .xy p - length c .z -\n;\n\n:m circle ( c ) p c p-circle ;\n\n:m intersect max ;\n:m subtract neg max ;\n:m union min ;\n:m shape call ;\n\n: zrotate ( v:vec3 a:float -> vec3 )\n\t[ v .xy a rotate-deg v .z ]\n;\n\niResolution frag->position [ 1.2 -1.2 ] * =p\n\n: distance-field ( p:vec2 -> float )\n\tp iTime neg rotate-2d =p\n\t{\n\t\t[ 0 0 0.6 ] circle\n\t\t{\n\t\t\t{\n\t\t\t\t[\n\t\t\t\t\t[ 0 0 0.4 ] circle\n\t\t\t\t\t$[0:+360:120] /{ ( a )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t[ .14 -.04 .52 ] a zrotate circle\n\t\t\t\t\t\t\t[ -.25 .135 .46 ] a zrotate circle intersect\n\t\t\t\t\t\t\t[ -.3 -.101 .46 ] a zrotate circle subtract\n\t\t\t\t\t\t} shape\n\t\t\t\t\t} flatten\n\t\t\t\t] \\subtract\n\t\t\t} shape \n\n\t\t\t{\n\t\t\t\t[ 0 .184 .295 ] circle\n\t\t\t\t[ 0 .184 .295 ] 120 zrotate circle intersect\n\t\t\t\t[ 0 .184 .295 ] 240 zrotate circle intersect\n\t\t\t\t[ 0 0 .0434 ] circle subtract\n\t\t\t} shape subtract\n\t\t} shape subtract\n\t} shape\n;\n\n:m paper-color [ 0.83 0.83 0.83 ] ;\n:m line-color [ .23 .20 .19 ] ;\n:m fill-color [ 0.44 0.38 0.37 ] ;\n\n:m rfac\n\t1 iTime 1000 * sin abs .025 * .025 + - *\n;\n\n: hatching ( p:vec2 -> float )\n\tp 1000 * sin .0015 * p + =p\n\t[\n\t\t[\n\t\t\tp rfac \\+ 100 * sin .9 1 clamp .9 - 10 * rfac\n\t\t\tp [ 1 -1 ] * \\+ 100 * sin p .x p .y 137 * sin 5 * + sin + .9 1 clamp .9 - 10 *\n\t\t] \\-\n\t\t[\n\t\t\tp rfac [ -1.4 1 ] * \\+ 50 * sin .95 1 clamp .95 - 20 *\n\t\t] \\- .4 *\n\t] \\+ 2 /\n;\n\n:m fill-pattern ( p )\n\tp [ .5 .05 p .x sin abs * + rfac 1 rfac ] * \\+ 200 * sin .9 1 clamp .9 - 10 *\n;\n\n:m paper ( p )\n\tpaper-color p hatching .2 * -\n;\n\n:m line ( d p )\n\tline-color\n;\n\n: fill ( d:float p:vec2 -> vec3 )\n\t[\n\t\tfill-color\n\t\tp hatching .05 *\n\t\tp fill-pattern .2 *\n\t] \\-\n;\n\n:m line-thickness .01 ;\n\n: texturize ( d:float p:vec2 -> vec3 )\n\td iTime 100 * d p .y * 10 * * sin .4 * d * + =d\n\t[\n\t\t\td abs line-thickness <=\n\t\t\td abs p hatching .04 * - line-thickness <=\n\t\tor { d p line }\n\t\td 0 < { d p fill }\n\t\t{ p paper }\n\t] cond\n;\n\n\tp\n\t[ 0 p .y 100 * iTime 10 * + sin .003 * ] p+\n\t[ p .y 10 * iTime 10 * iTime 17 / sin * + sin .005 * 0 ] +\n=wp\n\n&distance-field wp gradient p texturize ->fragcolor\n*/\n\nfloat hatching(vec2 p) {\n\tp = sin(p * 1000.) * .0015 + p;\n\tvec2 var_1 = p * (1. - (abs(sin(iTime * 1000.)) * .025 + .025));\n\tvec2 var_2 = p * vec2(1., -1.);\n\tvec2 var_3 = p * (1. - (abs(sin(iTime * 1000.)) * .025 + .025)) * vec2(-1.4, 1.);\n\treturn ((clamp(sin((var_1.x + var_1.y) * 100.), .9, 1.) - .9) * 10. * (1. - (abs(sin(iTime * 1000.)) * .025 + .025)) - (clamp(sin((var_2.x + var_2.y) * 100.) + sin(p.x + sin(p.y * 137.) * 5.), .9, 1.) - .9) * 10. + (clamp(sin((var_3.x + var_3.y) * 50.), .95, 1.) - .95) * 20. * .4) / 2.;\n}\nvec3 fill(float d, vec2 p) {\n\tvec2 var_2 = p * vec2((.5 + .05 * abs(sin(p.x))) * (1. - (abs(sin(iTime * 1000.)) * .025 + .025)), 1. * (1. - (abs(sin(iTime * 1000.)) * .025 + .025)));\n\treturn vec3(.44, .38, .37) - hatching(p) * .05 - (clamp(sin((var_2.x + var_2.y) * 200.), .9, 1.) - .9) * 10. * .2;\n}\nvec2 polar_cart(vec2 p) {\n\treturn vec2(cos(p.x), sin(p.x)) * p.y;\n}\nvec3 texturize(float d, vec2 p) {\n\tvec3 temp_30;\n\td = d + sin(iTime * 100. * d * p.y * 10.) * .4 * d;\n\tif(abs(d) <= .01 || (abs(d) - hatching(p) * .04) <= .01) {\n\t\ttemp_30 = vec3(.23, .20, .19);\n\t} else if(d < 0.) {\n\t\ttemp_30 = fill(d, p);\n\t} else {\n\t\ttemp_30 = vec3(.83, .83, .83) - hatching(p) * .2;\n\t}\n\treturn temp_30;\n}\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan(p.y, p.x), length(p));\n}\nvec3 cwarp(vec3 c) {\n\tfloat t = 1. - pow(clamp((abs(mod(iTime, 8.) - 4.) - 1.) / 1.5, 0., 1.), 3.);\n\treturn vec3(polar_cart(cart_polar(c.xy * (1. - t)) + vec2(t * 3.14159 * -1., 0.)), c.z * (t * 2.5 + 1.));\n}\nfloat p_circle(vec2 p, vec3 c) {\n\tc = cwarp(c);\n\treturn length(c.xy - p) - c.z;\n}\nvec2 rotate_2d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec3 zrotate(vec3 v, float a) {\n\treturn vec3(rotate_2d(v.xy, a * .017453), v.z);\n}\nfloat distance_field(vec2 p) {\n\tp = rotate_2d(p, -iTime);\n\treturn max(p_circle(p, vec3(0., 0., .6)), -max(max(max(max(max(p_circle(p, vec3(0., 0., .4)), -max(max(p_circle(p, zrotate(vec3(.14, -.04, .52), 0.)), p_circle(p, zrotate(vec3(-.25, .135, .46), 0.))), -p_circle(p, zrotate(vec3(-.3, -.101, .46), 0.)))), -max(max(p_circle(p, zrotate(vec3(.14, -.04, .52), 120.)), p_circle(p, zrotate(vec3(-.25, .135, .46), 120.))), -p_circle(p, zrotate(vec3(-.3, -.101, .46), 120.)))), -max(max(p_circle(p, zrotate(vec3(.14, -.04, .52), 240.)), p_circle(p, zrotate(vec3(-.25, .135, .46), 240.))), -p_circle(p, zrotate(vec3(-.3, -.101, .46), 240.)))), -max(max(p_circle(p, zrotate(vec3(.14, -.04, .52), 360.)), p_circle(p, zrotate(vec3(-.25, .135, .46), 360.))), -p_circle(p, zrotate(vec3(-.3, -.101, .46), 360.)))), -max(max(max(p_circle(p, vec3(0., .184, .295)), p_circle(p, zrotate(vec3(0., .184, .295), 120.))), p_circle(p, zrotate(vec3(0., .184, .295), 240.))), -p_circle(p, vec3(0., 0., .0434)))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.) * vec2(1.2, -1.2);\n\tvec2 wp = polar_cart(cart_polar(p) + vec2(0., sin(p.y * 100. + iTime * 10.) * .003)) + vec2(sin(p.y * 10. + iTime * 10. * sin(iTime / 17.)) * .005, 0.);\n\tvec2 h = vec2(.00001, 0.);\n\tfragColor = vec4(texturize(distance_field(wp) / abs(length(vec2(distance_field(wp + h) - distance_field(wp - h), distance_field(wp + h.yx) - distance_field(wp - h.yx)) / (2. * h.x))), p), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSXWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 2334, 2358, 2358, 2864], [2865, 2865, 2893, 2893, 3165], [3166, 3166, 3191, 3191, 3233], [3234, 3234, 3267, 3267, 3557], [3558, 3558, 3583, 3583, 3626], [3627, 3627, 3647, 3647, 3835], [3836, 3836, 3868, 3868, 3917], [3918, 3918, 3951, 3951, 4049], [4050, 4050, 4081, 4081, 4132], [4133, 4133, 4163, 4163, 5129], [5130, 5130, 5187, 5187, 5678]]}
{"id": "XdSXWt", "name": "Logistic Map - Complex", "author": "iq", "description": "Logistic map in complex numbers (real numbers superimposed in yellow). It's isomorphic to the Mandelbrot set. The smooth iteration count is sn = n + 1 - log2( log2|c| + log2|z| ). More info: [url]https://www.shadertoy.com/view/4dSXWt[/url]", "tags": ["2d", "fractal", "logistic", "bifurcation", "feigenbaum"], "likes": 24, "viewed": 4149, "date": "1416917739", "time_retrieved": "2024-06-20T18:14:56.159874", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// The Logistic Map in complex numbers. Since it's a quadratic funcion,\n// it's isomorphic to the Mandelbrot Set.\n//\n// The bifurcation diagram for the Logistic Map in real numbers is\n// superimposed to better see the overlap in the dynamics across the\n// x axis. More info here: https://www.shadertoy.com/view/4dSXWt\n//\n// Since f(z) = hÂ·zÂ·(1-z), as |Zn| approaches infinity we have that\n// Z = h^(2^n-1)Â·Zo^(2^n)\n//\n// Hence the normalization map phi = (ZnÂ·h)^(1/2^n). \n//\n// The Green function is therefore G = log|phi| = (log|Zn|+log|h|)/(2^n)\n\n\n// supersampling factor (1 for slow machines, 5 for monsters!)\n#define AA 2\n\n// complex number operations\nvec2 cadd( float s, vec2 a ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (-iResolution.xy + 2.0*q)/iResolution.y;\n\n        // zoom\n        float zoo = 0.62 + 0.38*cos(.02*iTime);\n        float coa = cos( 0.1*(1.0-zoo)*iTime );\n        float sia = sin( 0.1*(1.0-zoo)*iTime );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 cc = vec2(1.0,0.0)+smoothstep(1.0,0.5,zoo)*vec2(0.24814,0.7369) + xy*zoo*2.0;\n\n        vec3 col = vec3( 0.0 );\n        \n        //---------------------------------\n        // logistic map in complex numbers\n        //---------------------------------\n        \n        vec2 sc = vec2( abs(cc.x-1.0)-1.0,cc.y);\n        if( dot(sc,sc)<1.0 )\n        {\n            // trick: in order to accelerate the rendering, we can detect if we\n            // are inside the convergent part of the set (any of the two bulbs of period 1).\n            //col = vec3(0.2);\n        }\n        else\n        {\n            float co = 0.0;\n            vec2 z  = vec2(0.5,0.0);\n            for( int i=0; i<256; i++ )\n            {\n                if( dot(z,z)>1024.0 ) break;\n                z = cmul(cc, cmul( z, cadd(1.0,-z) ) );\n                co += 1.0;\n            }\n\n            // smooth interation count = n + 1 - log2( log2|h| + log2|z| );\n            float sco = co + 1.0 - log2( 0.5*(log2(dot(cc,cc)) + log2(dot(z,z))) );\n\n            col = 0.5 + 0.5*cos( 3.0 + sco*0.1 + vec3(0.0,0.5,1.0));\n            if( co>255.5 ) col = vec3(0.0);\n        }\n\n        // Hubbard-Douady potential, |G|\n        //float d = (log(length(z)) + log(length(cc)))/pow(2.0,co);\n\n\n        //---------------------------------\n        // logic map in real numbers    \n        //---------------------------------\n        if( abs(cc.x-1.0)<3.0 )\n        {\n            float al = smoothstep( 17.0, 12.0, iTime );\n            col = clamp(col,0.0,1.0);\n            float x = 0.5;\n            for( int i=0; i<200; i++ )\n            x = cc.x*x*(1.0-x);\n            for( int i=0; i<200; i++ )\n            {\n                x = cc.x*x*(1.0-x);\n                col = mix( col, vec3(1.0,1.0,0.0), \n                           (0.15+0.85*pow(clamp(abs(sc.x+1.0)*0.4,0.0,1.0),4.0))*al*\n                           0.06*exp(-15000.0*(cc.y-x)*(cc.y-x)) );\n            }\n        }\n\n        tot += col;\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSXWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[757, 786, 816, 816, 845], [846, 846, 876, 876, 931], [933, 933, 990, 990, 3553]]}
{"id": "XdSXWV", "name": "flowing", "author": "Doublefresh", "description": "simple warp effect, a la iq.\nPlayed with this some more.", "tags": ["noise", "warp", "iterations"], "likes": 4, "viewed": 234, "date": "1415813440", "time_retrieved": "2024-06-20T18:14:56.165951", "image_code": "#define WARP_F 0.5\n#define SWIRLYNESS 1.4\n\n/* from iq */\nfloat hash(float n){\n\treturn fract(sin(n)*43758.5453);\n}\nvec3 noise(in vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return vec3(res);\n}\n/* --- */\n\nvec2 rotate(vec2 p, float a) {\n    float i = cos(a) * p.x + sin(a) * p.y;\n    float j = -sin(a) * p.x + cos(a) * p.y;\n    \n    return vec2(i,j);\n}\n\nvec3 nice(vec2 p) {\n    vec3 warp = SWIRLYNESS*noise(p + vec2(WARP_F * iTime));\n    \n    float s, A, F;\n    \n    s = 0.1;\n    A = 1.0;\n    F = 1.0;\n    \n    for(int i = 0; i < 10; i++){\n        p =  rotate(p, float(i)*SWIRLYNESS);\n \t\tp += warp.y + s;\n        s += A * noise(p * F).x;\n        F = F * 2.0;\n        A = A / 2.0;\n    }\n    \n    float a = 1.0 / sqrt(3.0), b = a, c = a;\n    \n    return vec3(\n    \ta * smoothstep(0.6, 0.9, s*s),\n    \tb * smoothstep(1.1, 1.3, s*s),\n    \tc * smoothstep(1.5, 1.51, s*s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0 * uv - 1.0;\n    vec3 col, n;\n    \n    p.x *= iResolution.x / iResolution.y;  \n    p += iTime * 0.01;\n    \n    float A = 1.0, F = 4.0;\n   \t\n    // two or more? use a for!\n    for(int i = 0; i < 1; ++i) {   \n    \tn += A * nice(p * F);\n        A *= 0.5;\n        F *= 2.0;\n    }\n                 \n    \n    col += (n.x) * vec3(0.5, 0.3, 0.4);\n    col += (n.y) * vec3(0.4, 0.3, 0.2);\n    col += (n.z) * vec3(0.2, 0.2, 0.2);\n    \n    \n\tfragColor = vec4(col * sqrt(length(col)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSXWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[43, 57, 77, 77, 113], [114, 114, 136, 136, 386], [387, 398, 428, 428, 544], [546, 546, 565, 565, 1061], [1063, 1063, 1120, 1120, 1658]]}
{"id": "Xs2XDc", "name": "URZq playground", "author": "urzq", "description": "my really first shader <img src=\"/img/emoticonHappy.png\"/>", "tags": ["tutorial", "circle", "moving", "step", "metalball"], "likes": 2, "viewed": 166, "date": "1416697948", "time_retrieved": "2024-06-20T18:14:56.165951", "image_code": "float IsWithinCircle(vec2 point, vec2 circleCenter, float circleRadius)\n{\n    circleCenter = vec2(circleCenter.x * iResolution.x, circleCenter.y * iResolution.y);\n    circleRadius = circleRadius * iResolution.x;\n\n    float len = length(point-circleCenter);\n    \n    return smoothstep( circleRadius*0.5, circleRadius*1.5, len);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.2;\n    vec2 center_1 = vec2((sin(iTime*0.4) + 1.0)/2.2, (cos(iTime*0.5)+1.0)/2.2);\n    vec2 center_2 = vec2((cos(iTime) + 1.0)/3.2, (sin(iTime)+1.0)/2.20);\n    vec2 center_3 = vec2(0.5, (sin(iTime)+1.0)/2.2);\n\tvec2 center_4 = vec2( (cos(iTime*1.4)+1.0)/2.2, 0.3);\n\n    float color = IsWithinCircle(fragCoord.xy, center_1, radius) + \n        IsWithinCircle(fragCoord.xy, center_2, radius) +\n        IsWithinCircle(fragCoord.xy, center_3, radius) +\n        IsWithinCircle(fragCoord.xy, center_4, radius);\n    \n    color = color /4.0;\n    color = step(0.9, color);\n    \n       \n       \n    fragColor = vec4(color, color, color, 1.0);\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2XDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 73, 73, 328], [330, 330, 387, 387, 1133]]}
{"id": "Xs2XDt", "name": "Boat at Sunset", "author": "timeiskey", "description": "boat eclipse", "tags": ["2d"], "likes": 0, "viewed": 141, "date": "1417318657", "time_retrieved": "2024-06-20T18:14:56.165951", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    \n    \n    \n    //shape position\n    vec2 shapeCenter = vec2( 0.35, 0.67);\n    //distance from pixel to shape center\n    ////vec2 distanceToShape = p - shapeCenter;\n    vec2 distanceToShape = p - shapeCenter;\n    \n    //color vector\n    vec3 col = vec3( 0.9, 0.4, 0.0 );\n    \n    //shape radius\n    float shapeRadius = 0.2 + 0.1*cos( atan(distanceToShape.x, distanceToShape.y)*10000.00\n                           - 20.00*distanceToShape.x*iTime + 20.1*iTime  );\n    \n        //shape sharpness (smaller is sharper)\n    float sharpnessMod = 0.008;\n\n    col *= smoothstep( shapeRadius, shapeRadius+sharpnessMod, length(distanceToShape));\n    //col = vec3( 1.0, 1.0, 1.0) - col;\n    \n    //tree trunk\n    ////trunk width\n    float trunkWidth = 0.022*iTime;\n    //////trunk wiggle\n    trunkWidth += 0.001*cos(70.0*distanceToShape.y);\n    //////trunk expand downward\n    trunkWidth += exp(-10.00*p.x);\n    \n    ////trunk smoothness mod\n    float trunkSmoothMod = 0.002;\n    \n    //trunk draw\n    col *= (1.00 - (1.00 - \n                    smoothstep( trunkWidth, trunkWidth+trunkSmoothMod, \n                               abs(distanceToShape.x - 0.2*sin(2.6*distanceToShape.y)) ))\n                   *(1.00 - smoothstep( 0.0, 0.01, distanceToShape.y)));\n    \n    \n    \n    //finally changes the color\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2XDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1432]]}
{"id": "Xs2XDV", "name": "twofield", "author": "w23", "description": "Oh, this stuff is repulsive.", "tags": ["raymarching", "metaballs"], "likes": 57, "viewed": 2580, "date": "1416772177", "time_retrieved": "2024-06-20T18:14:57.293528", "image_code": "#define resolution (iResolution.xy)\n#define t (iTime * .3)\n\n// Simplest Lambert+Phong material shading model parameters\nstruct mat_t {\n    vec3 diffuse;\n    vec4 specular;\n};\n\n// There are two separate distance fields, each consists of 6 metaballs and a plane.\n#define N 6\nvec3 b1[N];\nvec3 b2[N];\n\n// Four lights with their positions and colors\nvec3 l1pos = 1.*vec3(6., 3., -7.);\nvec3 l2pos = 1.*vec3(-7., 1., 6.);\nvec3 l3pos = 1.*vec3(7., -4., 7.);\nvec3 l4pos = vec3(0.,5.,25.);\nvec3 l1color = 40.*vec3(1.,.7,.7);\nvec3 l2color = 20.*vec3(.7,.7,1.);\nvec3 l3color = 60.*vec3(.7,1.,.7);\nvec3 l4color = vec3(100.);\n\n// Distance function approximation for the first field only\nfloat t1(vec3 p) {\n    float v = 0.;\n    for (int i = 0; i < N; ++i) {\n        vec3 b = p - b1[i];\n        // metaball field used here is a simple sum of inverse-square distances to metaballs centers\n        // all numeric constants are empirically tuned\n        v += 5. / dot(b, b);\n    }\n    // add top y=12 (red) plane\n    float d = 12. - p.y; v += 3. / (d*d);\n    return v;\n}\n\n// Second field distance function is basically the same, but uses b2[] metaballs centers and y=-12 plane\nfloat t2(vec3 p) {\n    float v = 0.;\n\tfor (int i = 0; i < N; ++i) {\n        vec3 b = p - b2[i];\n        v += 5. / dot(b, b);\n    }\n    float d = 12. + p.y; v += 3. / (d*d);\n    return v;\n}\n\n// \"Repulsive\" distance functions which account for both fields\nfloat w1(vec3 p) { return 1. - t1(p) + t2(p); }\nfloat w2(vec3 p) { return 1. + t1(p) - t2(p); }\n\n// Combined world function that picks whichever field is the closest one\nfloat world(vec3 p) {\n    return min(w1(p), w2(p));\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.001,0.);\n    return normalize(vec3(\n        world(p+e.xyy) - world(p-e.xyy),\n        world(p+e.yxy) - world(p-e.yxy),\n        world(p+e.yyx) - world(p-e.yyx)));\n}\n\n// Material is picked based on which field's distance function is the smallest\nmat_t material(vec3 p) {\n    mat_t m;\n    m.diffuse = vec3(0.);\n    m.specular = vec4(0.);\n    if (w1(p) < w2(p)) {\n        m.diffuse = vec3(.92, .027, .027);\n        m.specular = vec4(mix(vec3(1.),m.diffuse,.7), 2000.);\n    } else {\n        m.diffuse = vec3(.14, .17, 1.57);\n\t    m.specular = vec4(mix(vec3(1.),m.diffuse,.5), 100.);\n    }\n    return m;\n}\n\nfloat iter = 0.;\n\n// Raymarcher\nfloat trace(in vec3 O, in vec3 D, in float L, in float Lmax) {\n    // The usual \"step along the ray\" loop\n    float Lp = L;\n    for (int i = 0; i < 40; ++i) {\n        iter = float(i);\n        float d = world(O + D * L);\n        if (d < .01*L || L > Lmax) break;\n        // Store previous point (see below)\n        Lp = L;\n        \n        // Overstep a bit to find intersetion faster (metaball fields aren't cheap)\n        L += d * 1.5;\n    }\n    \n    if (L < Lmax) {\n        // Binary search for more exact intersestion position\n        // Needed to fix artifacts due to overstep\n        for (int i = 0; i < 5; ++i) {\n            float Lm = (Lp + L) * .5;\n            if (world(O + D * Lm) < .01*Lm) L = Lm; else Lp = Lm;\n        }\n    }\n    iter /= 32.;\n    return L;\n}\n\n// Simpler tracing function that tries to determine whether the point is in shadow\nfloat shadowtrace(vec3 p, vec3 d, float lmax) {\n    float v = .02;\n    // Take a few samples between the point and the light position and chech\n    // whether they are \"inside\" geometry\n    for (int i = 1; i < 9; ++i) {\n        v = min(v, world(p+d*lmax*float(i)/12.));\n    }\n    return smoothstep(.0, .02, v);\n    \n}\n\n// Compute shading color from a single light\nvec3 enlight(vec3 p, vec3 v, vec3 n, mat_t m, vec3 lpos, vec3 lcolor) {\n    vec3 ldir = lpos - p; // direction from the point to the light source\n    float ldist2 = dot(ldir, ldir); // square distance to the light source\n    float ldist = sqrt(ldist2); // distance\n    ldir /= ldist; // ldir is now normalized\n    float shadow = shadowtrace(p, ldir, ldist-.2); // whether the point is in shadow\n    return shadow * lcolor * (\n        // Diffuse term (simple Lambert)\n\t  m.diffuse * max(0., dot(n,ldir))\n        // Specular term (Phong-ish)\n\t+ m.specular.rgb * pow(max(0.,dot(normalize(ldir-v), n)), m.specular.w)\n        // Specular energy conservation? (or something, it was 3 years ago :D)\n        * (m.specular.w + 2.) * (m.specular.w + 4.) / (24. * (m.specular.w + pow(2., -m.specular.w/2.)))\n\t) / ldist2;\n}\n\n// A ridiculous hack to display light sources\n// Basic idea is to check whether the ray is \"close enough\" to the light source position in screen space\n// Which is done by calculating the angle between the actual pixel ray and a vector from origin to the light source\nvec3 lightball(vec3 lpos, vec3 lcolor, vec3 O, vec3 D, float L) {\n    vec3 ldir = lpos-O;\n    float ldist = length(ldir);\n    if (ldist > L) return vec3(0.);\n    float pw = pow(max(0.,dot(normalize(ldir),D)), 20000.);\n    return (normalize(lcolor)+vec3(1.)) * pw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Calculate metaball trajectories (all empirical)\n    for (int i = 0; i < N; ++i) {\n        float fi = float(i)*.7;\n        b1[i] = vec3(3.7*sin(t+fi), 1.+10.*cos(t*1.1+fi), 2.3*sin(t*2.3+fi));\n        fi = float(i)*1.2;\n        b2[i] = vec3(4.4*cos(t*.4+fi),-1.-10.*cos(t*0.7+fi), -2.1*sin(t*1.3+fi));\n    }\n\n    vec2 uv = fragCoord.xy / resolution.xy * 2. - 1.;\n    uv.x *= resolution.x / resolution.y;\n\n    vec3 O = vec3(0.,0.,20.);\n    vec3 D = normalize(vec3(uv,-1.6));\n\n    if (iMouse.z > 0.)\n    {\n        vec2 m = iMouse.xy/iResolution.xy*2.-1.;\n        float a = - m.x * 2. * 3.1415926;\n        float s = sin(a), c = cos(a);\n        O = vec3(s*20.,-m.y*10.,c*20.);\n        vec3 fw = normalize(vec3(0.) - O);\n        vec3 rg = cross(fw,vec3(0.,1.,0.));\n        D = normalize(mat3(rg, cross(rg, fw), -fw) * D);\n    }\n\n    // Raymarch\n    float L = trace(O, D, 0., 40.);\n    vec3 color = vec3(0.);\n    if (L < 40.) {\n        // If a hit is detected, then get the position\n        vec3 p = O + D * L;\n        // And normal\n        vec3 n = normal(p); \n        // And material\n        mat_t m = material(p);\n        \n        // Ambient term (I don't think it is visible much)\n        color = .001 * m.diffuse * n;\n        \n        // Shade for all lights\n        color += enlight(p, D, n, m, l1pos, l1color);\n        color += enlight(p, D, n, m, l2pos, l2color);\n        color += enlight(p, D, n, m, l3pos, l3color);\n        color += enlight(p, D, n, m, l4pos, l4color);\n        \n        // Fog-like hack-ish attenuation, so the only the center of the scene is visible\n        color *= (1. - smoothstep(10., 20., length(p)));\n\t} else L = 100.;\n \n    // Add light sources hack\n    color += lightball(l1pos, l1color, O, D, L);\n    color += lightball(l2pos, l2color, O, D, L);\n    color += lightball(l3pos, l3color, O, D, L);\n    color += lightball(l4pos, l4color, O, D, L);\n\n    // Gamma correct and out\n\tfragColor = vec4(pow(color,vec3(.7)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2XDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[613, 673, 691, 691, 1052], [1054, 1159, 1177, 1177, 1347], [1349, 1413, 1431, 1431, 1460], [1461, 1461, 1479, 1479, 1508], [1510, 1583, 1604, 1604, 1636], [1638, 1638, 1659, 1659, 1841], [1843, 1922, 1946, 1946, 2277], [2297, 2311, 2373, 2416, 3082], [3084, 3167, 3214, 3214, 3484], [3486, 3531, 3602, 3602, 4342], [4344, 4611, 4676, 4676, 4876], [4878, 4878, 4935, 4990, 6892]]}
{"id": "XsBXW3", "name": "monkey saddle", "author": "joates", "description": "raymarching a parametric surface. (rotate with mouse click+drag) if you comment out line #4 it looks a bit more like a (bicycle) saddle !!", "tags": ["surface", "parametric", "monkey", "saddle"], "likes": 5, "viewed": 147, "date": "1416325735", "time_retrieved": "2024-06-20T18:14:57.299324", "image_code": "// monkey saddle by joates (Nov-2014)\n// see http://mathworld.wolfram.com/MonkeySaddle.html\n\n#define IS_BOXED\nconst float size = 0.45;\n\nfloat map( in vec3 p )\n{\n\t#ifdef IS_BOXED\n\t    vec3  d = abs(p) - size;\n\t\tfloat d1 = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    #else\n\t    // sphere\n\t    float d1 = length(p) - size;\n    #endif\n\n    // saddle\n    float d2 = p.y*size - (p.x*p.x*p.x - 3.0*p.x*p.z*p.z);\n\n    return max(d1,d2);\n}\n\nvec3 calcNormal( in vec3 p ) {\n    vec2 e = vec2( 0.0001, 0.0 );\n    return normalize( vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                            map( p + e.yxy ) - map( p - e.yxy ),\n                            map( p + e.yyx ) - map( p - e.yyx ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tfloat time = iTime*0.1;\n\n    // view origin & direction\n\tvec3 ro = vec3( size );\n\tvec3 tp = vec3( 0.0 );\n    tp.y = -0.25*size;\n\n    // camera orbit\n    float m = iMouse.x * 0.02;\n    ro.x = cos(time+m)*length(ro);\n    ro.z = sin(time+m)*length(ro);\n\n    vec3 lit = vec3( 0.5773 );\n    vec3 col = vec3( 0.0 );\n    \n    // camera view\n\tvec3 cw = normalize( tp-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw, cp) );\n\tvec3 cv = normalize( cross(cu, cw) );\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\n\n    float tmax = 200.0;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i = 0; i < 100; i++ ) {\n        if( h < 0.0001 || t > tmax ) break;\n        h = map( ro + t*rd );\n        t += h;\n    }\n\n    if ( t < tmax ) {\n        vec3 pos = ro + t*rd;\n       \tvec3 nor = calcNormal( pos );\n\n       \tcol  = vec3( 1.0, 0.8, 0.5 ) * clamp( dot( nor, lit ), 0.0, 1.0 );\n       \tcol += vec3( 0.2, 0.3, 0.4 ) * clamp( nor.y, 0.0, 1.0 );\n       \tcol += vec3( 0.1, 0.1, 0.3 );\n    }\n        \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBXW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 136, 160, 160, 443], [445, 445, 475, 475, 710], [712, 712, 769, 769, 1908]]}
{"id": "XsjSWt", "name": "DIGI Thing", "author": "timeiskey", "description": "let's all love alin", "tags": ["2d"], "likes": 0, "viewed": 117, "date": "1417203846", "time_retrieved": "2024-06-20T18:14:57.299551", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    \n    \n    \n    //shape position\n    vec2 shapeCenter = vec2( 0.5, 0.5);\n    //distance from pixel to shape center\n    ////vec2 distanceToShape = p - shapeCenter;\n    vec2 distanceToShape = p - shapeCenter;\n    \n    //color vector\n    vec3 col = vec3( 0.0, 1.0, 0.0 );\n    \n    //shape radius\n    float shapeRadius = 0.2 + 0.1*cos( atan(distanceToShape.x, distanceToShape.y)*10.00\n                           - 20.00*distanceToShape.x*iTime + 10000000.0  );\n    //shape sharpness (smaller is sharper)\n    float sharpnessMod = 0.008;\n\n    col *=  1.00 - smoothstep( shapeRadius, shapeRadius+sharpnessMod, length(distanceToShape));\n    //col = vec3( 1.0, 1.0, 1.0) - col;\n    \n    //finally changes the color\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjSWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 842]]}
{"id": "XsSSDK", "name": "3 Spheres", "author": "lamogui", "description": "i try to GLSL in 3D for the first time", "tags": ["sphere"], "likes": 2, "viewed": 145, "date": "1415751503", "time_retrieved": "2024-06-20T18:14:57.778221", "image_code": "const int rays_hits=9;\nconst float epsilon=0.001;\nvec3 vertical;\n\nvec3 sphere1;\nvec3 sphere2;\nvec3 sphere3=vec3(1.0,1.0,1.0);\n\nvec3 back(vec3 rd)\n{\n\tfloat s=pow(dot(rd,vertical),0.68);//Sky\n\tfloat f=dot(rd,-vertical);//floor\n\tvec3 sc=s*vec3(66.0/255.0,111.0/255.0,169.0/255.0);\n\tvec3 fc=f*vec3(185./255.,122./255.,87./255.);\n\treturn max(sc,fc);\n}\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius, float closed_hit, out vec3 normal)\n{\n  vec3 rc = ray-center;\n  float c = dot(rc, rc) - (radius*radius);\n  float b = dot(dir, rc);\n  float d = b*b - c;\n  float t = -b - sqrt(abs(d));\n  if (d < 0.0 || t < 0.0 || t > closed_hit) \n\treturn closed_hit;\n  else {\n    normal = center-(ray+dir*t);\n\treturn t;\n }\n \n}\n\nfloat scene(vec3 ro, vec3 rd, out vec3 normal, float max_dist)\n{\n\tfloat dist=max_dist;\n\tdist=sphere(ro,rd,sphere1,0.7,dist,normal);\n\tdist=sphere(ro,rd,sphere2,0.5,dist,normal);\n\tdist=sphere(ro,rd,sphere3,0.88,dist,normal);\n\treturn dist;\n}\n\n\nmat2 rotate2D(float a)\n{\n\treturn mat2(cos(a), -sin(a),\n\t\t\t\tsin(a),  cos(a));\n}\n\nvec2 rotateY(vec2 v, float a)\n{\n\treturn v*rotate2D(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vertical = vec3(sin(0.8*iTime),1.0,0.0);\n    sphere1=vec3(0.0,0.0,-2.0);\n\tsphere2=vec3(0.0,sin(iTime),0.0);\n    vec2 v = (-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n\tvec3 light = vec3(0.0);    \n\tvec3 transmit = vec3(1.0); \n\tvec3 ro=vec3(3.0*cos(iTime),0.0,3.0*sin(iTime))+vertical;   \n\tvec2 vd=normalize(vec3(0.0,0.0,0.0) - ro).xz; //View direction\n\tfloat va=atan(vd.y,vd.x);\n\tvec2 r2d=rotateY(vec2(1.0,v.x),va);\n\tvec3 rd=normalize(vec3(r2d.x,v.y,r2d.y));    //direction \n\t\n\tfor (int r=0;r < rays_hits; r++)\n\t{\n\t\tvec3 normal;\n\t\tfloat max_dist=1000.0;\n\t\tfloat dist=scene(ro,rd,normal,max_dist);\n\t\tif (dist < max_dist)\n\t\t{\n\t\t\t\n\t\t\ttransmit*=0.9;\n\t\t\tro += rd*dist;\n\t\t\trd =reflect(rd,normalize(normal));\n\t\t\tro += rd*epsilon; \n\t\t}\n\t\telse { //Hit infinite (or default object)\n\t\t\tlight += transmit*back(rd); //here background fonction\n\t\t\tbreak;\n\t\t}\n\t}\n\tfragColor = vec4(light, 1.0); // Set pixel color to the amount of light seen.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSSDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[127, 127, 147, 147, 346], [348, 348, 444, 444, 714], [716, 716, 780, 780, 954], [957, 957, 981, 981, 1035], [1037, 1037, 1068, 1068, 1093], [1095, 1095, 1152, 1152, 2081]]}
