{"id": "4dGSR3", "name": "raymarcher lecture", "author": "kaswan", "description": "raymarching", "tags": ["raymarchinglecture"], "likes": 3, "viewed": 199, "published": "Public", "date": "1465538216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// RAYMARCHER for lecture\n\n\n// add Random rotations suggested by @FabriceNeyret2 (Thanks!)\n#define rnd(p) fract(3467.91*sin(dot(p,vec3(77.1,-47.9,123.41))))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat sphere(vec3 pos, vec3 center, float r)\n{\n \treturn length(pos - center) - r;   \n}\n\nfloat scene(vec3 pos)\n{\n\t// add Random rotations suggested by @FabriceNeyret2 (Thanks!)\n    vec3 cell = floor(pos/4.);\n\tpos = mod(pos, 4.0) - vec3(2.0); \n\t\n    float a;\n\tvec3 r = .5*vec3(sin(iTime), cos(iTime), 0.);\n\ta = rnd(cell); r.xy *= rot(a);\n\ta = rnd(cell+1.); r.yz *= rot(a*17.1);\n\n\tfloat d = sphere(pos, vec3(0.0), 1.0);\n\tfloat d2 = sphere(pos, r, 1.0);\n    \n\td = max(d, -d2);\n    \n    return d;\n}\n\nvec3 normal(vec3 pos)\n{\n \tvec3 eps = vec3(0.01, 0.0, 0.0);\n    \n    vec3 n;\n    \n    n.x = scene(pos + eps.xyy) - scene(pos - eps.xyy);\n    n.y = scene(pos + eps.yxy) - scene(pos - eps.yxy);\n    n.z = scene(pos + eps.yyx) - scene(pos - eps.yyx);\n    \n    return normalize(n);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n    //float aspectRatio = iResolution.x / iResolution.y;\n    //uv *= 2.0; uv -= vec2(1.0);\n    //uv.x *= aspectRatio;\n    \n    // @FabriceNeyret2 (Thanks!) \n    vec2 R = iResolution.xy,\n\tuv = (2.*fragCoord.xy - R ) / R.y;\n    \n    vec3 light = vec3(-1.0 + sin(iTime), 1.0 + cos(iTime), 2.0);\n    vec3 pos = vec3(1.0 + cos(iTime), 0.0 + sin(iTime), 4.0);\n    vec3 ray = normalize(vec3(uv, -1.0));\n    \n    vec3 color;\n    for (int i = 0; i < 50; i++){\n   \t\tfloat d = scene(pos);\n        if (d < 0.002) {\n        \tcolor = vec3(1.0, 0.0, 0.0);\n            \n            vec3 N = normal(pos);\n            vec3 L = normalize(light - pos);\n            vec3 R = reflect(-L,N);\n\t\t\tvec3 V = normalize(-ray);\n            \n            float diffuse = max(dot(N,L),0.0);\n            float specular = pow(max(dot(R,V),0.0), 32.0);\n            color *= diffuse;\n            color += specular;\n            \n            \n            fragColor = vec4(color, 1.0);\n            return;\n        }\n        \n        pos += ray * d;\n        \n    }\n    \n\tfragColor = vec4(vec3(0.1, 0.2, 1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 208, 254, 254, 294], [296, 296, 319, 383, 701], [703, 703, 726, 726, 985], [987, 987, 1044, 1245, 2163]], "test": "valid"}
{"id": "4dGSW3", "name": " hexagonal tiling 7 -psychedelic", "author": "FabriceNeyret2", "description": "Only change  =  last lines", "tags": ["2d", "pattern", "tiling", "hexagonal", "short"], "likes": 9, "viewed": 732, "published": "Public API", "date": "1466844960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// psychedelic version of https://www.shadertoy.com/view/ldKXWG\n\n\nvoid mainImage( out vec4 O, vec2 uv )\n{ \n    vec2 R = iResolution.xy,\n         U = uv = (uv-R/2.)/R.y * 5. *  1.73/2.;          // centered coords\n    \n    U *= mat2(1,-1./1.73, 0,2./1.73);                     // conversion to\n    vec3 g = vec3(U, 1.-U.x-U.y), g2,                     // hexagonal coordinates\n         id = floor(g);                                   // cell id\n    \n    g = fract(g); g.z = 1.-g.x-g.y;                       // triangle coords     \n    g2 = abs(2.*g-1.);                                    // distance to borders\n\n    U = id.xy * mat2(1,.5, 0,1.73/2.);\n    float l00 = length(U-uv),                    // screenspace distance to nodes\n          l10 = length(U+vec2(1,0)-uv), \n          l01 = length(U+vec2(.5,1.73/2.)-uv),\n          l11 = length(U+vec2(1.5,1.73/2.)-uv),\n            l = min(min(l00, l10), min( l01, l11)); // closest node: l=dist, C=coord\n    vec2 C = U+ ( l==l00 ? vec2(0) : l==l10 ? vec2(1,0) : l==l01 ? vec2(.5,1.73/2.) : vec2(1.5,1.73/2.) );\n    U = uv-C;\n    float  s = 2.*mod(ceil(C.x+C.y),2.)-1.,\n           r = length(U)/(1.73/2.)*3.,\n           a = atan(U.y,U.x) - 3.*iTime;// * mod(C.x+C.y,3.); // uncomment *mod for random rotation speed\n    \n            //  spiral              // rainbow color scheme\n    O = (.5+.5*sin(8.*log(r)+s*a + vec4(0,2.1,-2.1,0)));\n  //O = mix (O,vec4(.5),r*r/4.);   // fade to grey at cells border\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 105, 105, 1456]], "test": "valid"}
{"id": "4dGSWy", "name": "8 Bit demo", "author": "gigatron", "description": "8 Bit machine demo example, base code from here ;https://www.shadertoy.com/view/MsKSWw\n", "tags": ["spiral", "demo", "8bit"], "likes": 3, "viewed": 265, "published": "Public", "date": "1466179581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from Hud practice https://www.shadertoy.com/view/MsKSWw\n// .. it's look like 8 bit machines demo now ! Gigatron !\n\n#define tt iTime\n\nfloat spiralr(float a, float l){\n    float f = smoothstep(.0, -.2, cos(a*15.0 + iTime*5.0))*.341;\n\n \tfloat g = 1.0-smoothstep(0.0, 1.0, l*3.0);\n\n    f = f-g;\n    f = 1.0-smoothstep(f, f+0.008, l);\n    return f;\n}\nfloat spirall(float a, float l){\n    float f = smoothstep(.0, -.2, cos(a*15.0 - iTime*5.0))*.341;\n\n \tfloat g = 1.0-smoothstep(0.0, 1.0, l*3.0);\n\n    f = f-g;\n    f = 1.0-smoothstep(f, f+0.008, l);\n    return f;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = (2.*fragCoord.xy- iResolution.xy)/iResolution.y;\n \n    \n    float a = atan(uv.y,uv.x);\n    \n    float l = length(uv)+0.2*sin(tt*0.8);\n   \n    vec3 color = vec3(.4, 0.4, 0.4);\n   \n  \n    for(float i=0.0;i<8.0;i++){\n        \n    color = mix(color, vec3(sin(tt) ,i/2.0, i/4.0), spirall(a, l/(i*0.2)/i*2.0));\n        \n    }\n/*    color = mix(color, vec3(1. ,1., 1.), spiralr(a, l/0.5));\n        \n    color = mix(color, vec3(1. ,.0, 0.), spirall(a, l/0.7));\n    \n    color = mix(color, vec3(0. ,1., 1.), spiralr(a, l/0.9));\n    \n    color = mix(color, vec3(1. ,0., 1.), spirall(a, l/1.1));\n    color = mix(color, vec3(1. ,1., 1.), spiralr(a, l/1.4));\n    \n    color = mix(color, vec3(1. ,1., 0.), spirall(a, l/1.8));\n    color = mix(color, vec3(1. ,1., 1.), spiralr(a, l/2.2));\n    \n    color = mix(color, vec3(0. ,1.,0.), spirall(a, l/2.8));\n    color = mix(color, vec3(0. ,0., 1.), spiralr(a, l/3.6));\n*/    \n\t//fragColor = vec4(color*sin(300.*uv.x*iResolution.y),1.0);\n    fragColor =vec4(color/mod(fragCoord.y+fragCoord.x, 4.),1.0);\n    \n    // scanline is ok now !\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 136, 168, 168, 348], [349, 349, 381, 381, 561], [566, 566, 623, 623, 1706]], "test": "valid"}
{"id": "4dGSz3", "name": "Ray Tracer (Reflection + Shadow)", "author": "Themperror", "description": "This is a basic raytracers that probably nears shadertoys limits (atleast with this code), I'm unable to enable the multisample define as it crashes when you do (it works when disabling reflections)", "tags": ["raytracing", "reflection", "shadow", "sphere", "plane", "hard"], "likes": 1, "viewed": 690, "published": "Public API", "date": "1465549573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This demonstrates multisampling by casting 4 rays per pixel, thus softening up edges (results are like anti-aliasing)\n//This option only allows shadowing and second light\n//#define MULTISAMPLE\n\n//This option automatically disables shadowing when used without multisampling\n//#define ENABLE_SECOND_LIGHT\n\n//Reflections are only enabled without multisampling, It disables shadowing when ENABLE_SECOND_LIGHT is set\n#define ALLOW_REFLECTIONS \n\n//This will get disabled depending on settings, feel free to disable manually\n#define ALLOW_SHADOW\n\n//do not change anything here, it's to prevent crashes with certain settings, the code is too big for shadertoy to handle otherwise\n#ifndef MULTISAMPLE \n\t#ifdef ENABLE_SECOND_LIGHT\n\t\t#ifdef ALLOW_REFLECTIONS\n\t\t\t#undef ALLOW_SHADOW\n\t\t#endif\n\t#endif\n#else\n\t#undef ALLOW_REFLECTIONS\n#endif\n////end\n\n\n\n#define EPSILON   0.001\n#define PI 3.14159265359\n#define MAX_DEPTH 4\n#define MAX_DEPTH_F 4.0\n#define NUM_LIGHTS_F 2.0\n#define NUM_LIGHTS_I 2\n\n#define LIGHT_START_FALL_OFF_RANGE 0.0\n#define LIGHT_END_FALL_OFF_RANGE 70.0\n#define FARPLANE 1000.0\n#define NEARPLANE 1.0\n#define AMBIENT vec3(0.05,0.05,0.05)\nstruct ViewPlane\n{\n\tvec3 pos;\n    vec2 size;\n};\nstruct Sphere\n{\n    vec3 p;\n    float r;\n\tvec4 c;\n};\nstruct Plane\n{\n\tvec3 p;\n    vec3 n;\n    vec4 c;\n};\nstruct Light\n{\n\tvec3 p;\n    vec4 c;\n};\nstruct Scene\n{\n\tSphere s[3];\n\tPlane p[6];\n};\nstruct Ray\n{\n\tvec3 p,d;\n};\nstruct HitInfo\n{\n\tbool hit;\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    vec4 objColor; //only used in reflection code\n};\n\nScene scene;\nViewPlane vPlane;\nLight light;\nLight light2;\nSphere lightSphere;\nSphere lightSphere2;\n\n//project function should I need it, in-efficient though\nvec3 project(vec3 a, vec3 b)\n{\n    float wL = length(a);\n    float vL = length(b);\n    vec3 wN = normalize(a);\n    vec3 vN = normalize(b);\n    float d = dot(wN,vN);\n    return wL*d*vN;\n}\n\n\n//Can't remember where I found this, I converted it from some mathlab-ish code, This piece was the most efficient that I found across 3 versions\nHitInfo RaySphere(Ray ray, Sphere s)\n{\n    HitInfo info;\n    info.hit = false;\n\n    vec3 m = ray.p - s.p; \n    float b = dot(m, ray.d); \n    float c = dot(m, m) - s.r * s.r; \n\n    // Exit if râ€™s origin outside s (c > 0) and r pointing away from s (b > 0) \n    if (c > 0.0 && b > 0.0) return info; \n    float discr = b*b - c; \n\n    // A negative discriminant corresponds to ray missing sphere \n    if (discr < 0.0) return info; \n\n    // Ray now found to intersect sphere, compute smallest t value of intersection\n    float t = -b - sqrt(discr); \n\n    // If t is negative, ray started inside sphere so clamp t to zero \n    t = clamp(t,0.0,t); \n    vec3 q = ray.p + t * ray.d; \n\n    info.hit = true;\n    info.pos = q;\n    info.dist = t;\n    info.normal = -normalize(s.p-q);\n    return info;\n}\n\n//converted code from: http://geomalgorithms.com/a05-_intersect-1.html    :  intersect3D_SegmentPlane()\nHitInfo RayPlane(Ray ray, Plane p)\n{\n\tHitInfo info;\n    info.hit = false;\n    \n    vec3    u = (ray.p+ray.d*FARPLANE) - ray.p;\n    vec3    w = ray.p - p.p;\n\n    float     D = dot(p.n, u);\n    float     N = -dot(p.n, w);\n\n    if (abs(D) < EPSILON) //either they're parallel or never intersecting, in both cases return hit = false;\n    {          \n\t\treturn info;\n    }\n    \n    // they are not parallel\n    // compute intersect param\n    float sI = N / D;\n    if (sI < 0.0 || sI > 1.0)\n        return info;                        // no intersection\n\n    info.hit = true;\n    info.pos = ray.p + sI * u;                  // compute ray intersection point\n    info.dist = distance(ray.p,info.pos);\n    info.normal = -p.n;\n    return info;\n}\n\n//get spherical UV coordinates based on given normal, adjusted from source: https://www.cse.msu.edu/~cse872/tutorial4.html\nvec2 SphereUV(vec3 n)\n{\n    return vec2(atan(n.x, n.z) / (2.0 * PI) + 0.5,asin(n.y) / PI + 0.5);\n}\n\n//This function clamps a value between 0 and 1 based on the min and max value given\nfloat OneZeroClamp(float val, float minv, float maxv)\n{\n    val = clamp(val,minv,maxv);\n\tval -= minv;\n    float maxV = maxv - minv;\n    return (val/maxV);\n}\n//vec3 version\nvec3 OneZeroVClamp(vec3 val, vec3 minv, vec3 maxv)\n{\n   return vec3(OneZeroClamp(val.x,minv.x,maxv.x),OneZeroClamp(val.y,minv.y,maxv.y),OneZeroClamp(val.z,minv.z,maxv.z));\n}\n//vec4 version, .w value set to 1.0\nvec4 OneZeroVClamp(vec4 val, vec4 minv, vec4 maxv)\n{\n   return vec4(OneZeroClamp(val.x,minv.x,maxv.x),OneZeroClamp(val.y,minv.y,maxv.y),OneZeroClamp(val.z,minv.z,maxv.z),1.0);\n}\n\n//Calculates lighting and color based on ray hit, object position, object normal and object color.\nvec3 DoLighting(HitInfo hit,vec3 pos, vec4 col)\n{\n    float distIntensity =0.0;\n    float lightIntensity = 0.0;\n    bool canSeeLight = true;\n    Ray nRay;\n    HitInfo nHit;\n    #ifdef ALLOW_SHADOW\n        nRay.d = -normalize(hit.pos-light.p);\n        nRay.p = hit.pos + nRay.d*EPSILON;\n        nHit = RaySphere(nRay,lightSphere);\n        float hitDist = nHit.dist;\n        for(int i =0; i < 3;i++)\n        {\n            nHit = RaySphere(nRay,scene.s[i]);\n            if(nHit.hit)\n            {\n                if(hitDist > nHit.dist)\n                {\n                    canSeeLight = false;\n                    break;\n                }\n            }\n        }\n    #endif\n    if(canSeeLight)\n    {\n\t\t//calculate the distance in a range between 0 to 1 relative to the maximum light range  and then inverse it (one minus)\n    \tdistIntensity += 1.0-OneZeroClamp(distance(hit.pos,light.p),LIGHT_START_FALL_OFF_RANGE,LIGHT_END_FALL_OFF_RANGE);\n    \t//calculate light intensity based on the surface normal, distance and light.w value\n\t\tlightIntensity += light.c.w* clamp(dot(normalize(light.p-hit.pos),hit.normal),0.0,1.0);\n    }\n    \n    #ifdef ENABLE_SECOND_LIGHT\n    \t#ifdef ALLOW_SHADOW\n            nRay.d = -normalize(hit.pos-light2.p);\n            nHit = RaySphere(nRay,lightSphere2);\n            hitDist = nHit.dist;\n            canSeeLight= true;\n            for(int i =0; i < 3;i++)\n            {\n                nHit = RaySphere(nRay,scene.s[i]);\n                if(nHit.hit)\n                {\n                    if(hitDist > nHit.dist)\n                    {\n                        canSeeLight = false;\n                        break;\n                    }\n                }\n            }\n   \t\t#endif\n        if(canSeeLight)\n        {\n            distIntensity += 1.0-OneZeroClamp(distance(hit.pos,light2.p),LIGHT_START_FALL_OFF_RANGE,LIGHT_END_FALL_OFF_RANGE);\n            lightIntensity += light2.c.w* clamp(dot(normalize(light2.p-hit.pos),hit.normal),0.0,1.0);\n        }\n    #endif\n    \n\tlightIntensity *= distIntensity;\n    //return the final color in a range between 0 and 1+(total lights) + ambient \n    #ifndef ENABLE_SECOND_LIGHT\n    return OneZeroVClamp((col.rgb *lightIntensity + (light.c.xyz*lightIntensity ) + AMBIENT),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0)*(1.0)+AMBIENT);       \n \t#else\n    //double light\n    return OneZeroVClamp((col.rgb *lightIntensity + (light.c.xyz+light2.c.xyz)/2.0*lightIntensity ) + AMBIENT,vec3(0.0,0.0,0.0),(vec3(1.0,1.0,1.0)*(2.0+1.0)+AMBIENT));       \n\t#endif\n}\n\n\nHitInfo TraceReflect(Ray ray)\n{\n    //if we don't hit anything in the end, we output black.\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    HitInfo hit;\n    HitInfo outHit;\n    bool setOuthit = false;\n   \n    float minDist = FARPLANE;\n\n    //Cast rays against the 3 spheres\n    for(int i=0;i<3;i++)\n    {\n        hit = RaySphere(ray,scene.s[i]);\n        if(hit.hit && hit.dist < minDist)\n        {\n            minDist = hit.dist;\n            vec4 sphereColor = scene.s[i].c;\n            vec2 UV = SphereUV(hit.normal);\n            if(mod(floor(10.0*UV.x)+floor(10.0*UV.y), 2.0) == 0.0)\n            {\n                //set color to oneminus sphere color\n                sphereColor = vec4(1.0 - scene.s[i].c.xyz,scene.s[i].c.w);\n            }\n            color = vec4(DoLighting(hit,scene.s[i].p,sphereColor),scene.s[i].c.w);\n            outHit = hit;setOuthit=true;\n            //color = vec4(5,0,0,1);\n            outHit.objColor = color;\n        }\n    }\n    //Cast rays against the 6 planes\n    for(int i =0; i<6;i++)\n    {\n\n        hit = RayPlane(ray,scene.p[i]);\n        if(hit.hit && hit.dist < minDist)\n        {\n            minDist = hit.dist;\n            color = vec4(DoLighting(hit,scene.s[i].p,scene.p[i].c),scene.p[i].c.w);\n            outHit = hit;setOuthit=true;\n            //color = vec4(0,5,0,1);\n            outHit.objColor = color;\n        }\n    }\n\n    //Cast ray against the visualisation of the light\n    hit = RaySphere(ray,lightSphere);\n    if(hit.hit)\n    {\n\t\tif(hit.dist < minDist)\n        {\n            color = lightSphere.c;\n            //color = vec4(0,0,5,1);\n            outHit = hit;setOuthit=true;\n            outHit.objColor = color;\n        }\n    }\n    hit = RaySphere(ray,lightSphere2);\n    if(hit.hit)\n    {\n\t\tif(hit.dist < minDist)\n        {\n\t\t\tcolor = lightSphere2.c;\n            outHit = hit;setOuthit=true;\n            outHit.objColor = color;\n        }\n    }\n    if(setOuthit==false)\n    {\n        outHit.hit = false;\n        outHit.pos = vec3(0,0,0);\n        outHit.normal = vec3(0,0,0);\n        outHit.dist = 0.0;\n        outHit.objColor = vec4(5,0,5,0);\n    }\n\treturn outHit;\n}\n\n//Sends out a ray into the scene and retrieves object color if it hits, otherwise vec3(0.0,0.0,0.0)\nvec4 Trace(Ray ray)\n{\n    //if we don't hit anything in the end, we output black.\n    vec3 color = vec3(0.0,0.0,0.0);\n    HitInfo hit;\n    \n    //set minimum distance on FARPLANE, this allows us to draw nothing behind this point (even if we were to hit something)\n    float minDist = FARPLANE;\n    \n    //Cast rays against the 3 spheres\n    for(int i=0;i<3;i++)\n    {\n        hit = RaySphere(ray,scene.s[i]);\n        if(hit.hit && hit.dist < minDist)\n        {\n            minDist = hit.dist;\n            vec4 sphereColor = scene.s[i].c;\n            vec2 UV = SphereUV(hit.normal);\n            if(mod(floor(10.0*UV.x)+floor(10.0*UV.y), 2.0) == 0.0)\n            {\n                //set color to oneminus sphere color\n                sphereColor = vec4(1.0 - scene.s[i].c.xyz,sphereColor.w);\n            }\n            \n\t\t\t#ifdef ALLOW_REFLECTIONS \n      ////////////////// REFLECTION ON SPHERES////////////////////\n            vec3 reflectColor = vec3(0.0,0.0,0.0);\n            vec4 tempColor = vec4(0.0,0.0,0.0,0.0);\n            \n            if(scene.s[i].c.w > EPSILON)\n            {\n                \n                Ray nRay;\n                nRay.d = reflect(ray.d,hit.normal);\n                nRay.p = hit.pos + nRay.d*EPSILON;\n                float t =0.0;\n                for(float j = 0.0; j < MAX_DEPTH_F; j++)\n\t\t\t\t{\n                    t = j;\n                    HitInfo tempHit = TraceReflect(nRay);\n                    if(tempHit.hit)\n                    {\n                        tempColor = tempHit.objColor;\n                        nRay.d = reflect(nRay.d,tempHit.normal);\n                        nRay.p = tempHit.pos+nRay.d*EPSILON;\n                        reflectColor += tempColor.xyz *(1.0- tempColor.w);\n                        if(tempColor.w <= EPSILON)\n                        {\n\t\t\t\t\t\t\tbreak;\n                        }  \n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                \n           \t\tsphereColor = vec4(sphereColor.xyz*(1.0-clamp(sphereColor.w,0.0,1.0))+(reflectColor.xyz*(MAX_DEPTH_F-t)),1.0);\n          \t  \tcolor = DoLighting(hit,scene.s[i].p,sphereColor);\n            }\n      ////////////////// END REFLECTION ON SPHERES////////////////////\n            else\n            {\n                #endif\n            \tcolor = DoLighting(hit,scene.s[i].p,sphereColor);\n                \n            #ifdef ALLOW_REFLECTIONS \n            }\n            #endif\n        }\n    }\n    //Cast rays against the 6 planes\n    for(int i =0; i<6;i++)\n    {\n\n        hit = RayPlane(ray,scene.p[i]);\n        if(hit.hit && hit.dist < minDist)\n        {\n            minDist = hit.dist;\n            vec4 planeColor =scene.p[i].c;\n            #ifdef ALLOW_REFLECTIONS  \n    ////////////////// REFLECTION ON PLANES////////////////////\n            vec3 reflectColor = vec3(0.0,0.0,0.0);\n            vec4 tempColor = vec4(0.0,0.0,0.0,0.0);\n          \t\n            if(scene.p[i].c.w > EPSILON)\n            {\n                Ray nRay;\n                nRay.d = reflect(ray.d,hit.normal);\n                nRay.p = hit.pos + nRay.d*EPSILON;\n                float t = 0.0;\n                for(float j = 0.0; j < MAX_DEPTH_F; j++)\n                {\n                    t = j+1.0;\n                    HitInfo tempHit = TraceReflect(nRay);\n                    if(tempHit.hit)\n                    {\n                        tempColor = tempHit.objColor;\n                        nRay.d = reflect(nRay.d,tempHit.normal);\n                        nRay.p = tempHit.pos+nRay.d*EPSILON;\n                        reflectColor += tempColor.xyz*(1.0- tempColor.w);\n                        if(tempColor.w <= EPSILON)\n                        {\n                            break;\n                        }  \n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n\n                planeColor = vec4(planeColor.xyz*(1.0-clamp(planeColor.w,0.0,1.0))+(reflectColor.xyz*(MAX_DEPTH_F-t)),1.0);\n                color = DoLighting(hit,scene.s[i].p,planeColor);\n            }\n     ////////////////// END REFLECTION ON PLANES////////////////////\n            else\n            {\n            #endif\n                color = DoLighting(hit,scene.p[i].p,planeColor);\n            #ifdef ALLOW_REFLECTIONS\n            }\n\t\t\t#endif\n        }\n    }\n    \n    //Cast ray against the visualisation of the light\n    hit = RaySphere(ray,lightSphere);\n    if(hit.hit)\n    {\n\t\tif(hit.dist < minDist)\n        {\n\t\t\tcolor = lightSphere.c.xyz;\n        }\n    }\n    hit = RaySphere(ray,lightSphere2);\n    if(hit.hit)\n    {\n\t\tif(hit.dist < minDist)\n        {\n\t\t\tcolor = lightSphere2.c.xyz;\n        }\n    }\n\treturn vec4(color,1.0);\n}\n\n\n\n//program entrypoint\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //creats a ray object\n    Ray ray;\n    //set fragCoords to be from 0 to iResolution instead of 0.5 to iResolution+0.5\n    fragCoord.xy -= vec2(0.5,0.5);\n    \n    //calculate aspect ration\n    float aspect = iResolution.x / iResolution.y;\n   \t\n    //set the \"view plane\" variables\n    vPlane.pos = vec3(0.0,0.0, NEARPLANE);\n    vPlane.size = vec2(aspect,1.0);\n    \n    //get the current coordinates on the viewplane (similiar to UV coords)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //get the world size of 1 pixel on the viewplane\n    vec2 pixSize = vPlane.size / iResolution.xy;\n    \n    float lightDistance = 7.0;\n    float timeSpeed = 1.5;\n    float time = iTime*timeSpeed;\n    vec3 lightOffset = vec3(0,0,20.0);\n    //float time = 90.00;\n    \n    //construct scene\n    light.p = vec3((sin(time/1.5)-cos(time/1.5))*lightDistance,sin(time)*lightDistance,cos(time)*lightDistance)+lightOffset; // move light around in a 3D \"infinity symbol\"\n    light.c = vec4(1.0,1.0,1.0,0.4);\n    light2.p = vec3((sin(-time/1.5)-cos(-time/1.5))*lightDistance,sin(-time)*lightDistance,cos(-time)*lightDistance)+lightOffset; // move light around in a 3D \"infinity symbol\"\n    light2.c = vec4(1.0,1.0,1.0,0.4);\n    lightSphere.p = light.p;\n    lightSphere.r = 0.2;\n    lightSphere.c = vec4(1.0,1.0,1.0,0.0);\n    \n    #ifdef ENABLE_SECOND_LIGHT\n    lightSphere2.p = light2.p;\n\t#else \n    lightSphere2.p = light.p;\n\t#endif\n    lightSphere2.r = 0.2;\n    lightSphere2.c = vec4(1.0,1.0,1.0,0.0);\n    \n    //Big sphere\n    scene.s[0].p = vec3(sin(time)*7.0,0.0,20.0);\n    scene.s[0].r = 4.0;\n    scene.s[0].c = vec4(0.0,0.0,1.0,0.9);\n    //left sphere\n    scene.s[1].p = vec3(sin(time)*2.0+5.0,cos(time)+2.0,9.0);\n    scene.s[1].r = 1.0;\n    scene.s[1].c = vec4(0.0,1.0,0.0,0.0);\n    //right sphere\n    scene.s[2].p = vec3(-9.0,2.0,20.0);\n    scene.s[2].r = 1.0;\n    scene.s[2].c = vec4(1.0,0.0,0.0,0.0);\n    \n    \n    //ground\n    scene.p[0].p = vec3(0.0,10,0.0);\n    scene.p[0].n = normalize(vec3(0.0,1.0,0.0));\n    scene.p[0].c = vec4(1.0,0.0,0.0,0.0);\n    //back wall\n    scene.p[1].p = vec3(0.0,0,40.0);\n    scene.p[1].n = normalize(vec3(-0.3,0.0,1.0));\n    scene.p[1].c = vec4(0.0,0.5,0.5,1.0);\n    //left wall\n    scene.p[2].p = vec3(20.0,0,0.0);\n    scene.p[2].n = normalize(vec3(1.0,0.0,0.0));\n    scene.p[2].c = vec4(0.0,0.5,0.5,0.0);\n    //right wall\n    scene.p[3].p = vec3(-20.0,0,0.0);\n    scene.p[3].n = normalize(vec3(-1.0,0.0,0.0));\n    scene.p[3].c = vec4(0.0,0.5,0.5,0.0);\n    //ceiling wall\n    scene.p[4].p = vec3(0.0,-10,0.0);\n    scene.p[4].n = normalize(vec3(0.0,-1.0,0.0));\n    scene.p[4].c = vec4(0.0,0.5,0.5,0.0);\n    //front wall\n    scene.p[5].p = vec3(0.0,0,-2.0);\n    scene.p[5].n = normalize(vec3(0.0,0.0,-1.0));\n    scene.p[5].c = vec4(0.0,0.5,0.5,0.0);\n    \n    \n    //raytrace & output\n   \t\n    //set ray position and calculate normal adjustment based on pixel size\n    ray.p = vec3(0.0,0.0,0.0);\n\tvec3 normalAdjust = vec3(iResolution.xy/2.0 * pixSize,0.0);\n\n#ifdef MULTISAMPLE\n\t//if we use multisample we send out 4 rays instead of 1, add them up and average the final color (result will give a anti-aliased image)   \n    \n//    crude visual explanation: every * is a trace, image represents 1 pixel\n//\t  __________\n//\t  |         |\n//    | *    *  |\n//    |\t\t    |\n//    | *    *  |\n//    -----------\n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x+0.25) * pixSize.x,(fragCoord.y + 0.25) * pixSize.y, 0.0)-normalAdjust));\n    vec4 col1 = Trace(ray);\n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x+0.75) * pixSize.x,(fragCoord.y + 0.25) * pixSize.y,0.0)-normalAdjust));\n    vec4 col2 = Trace(ray);\n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x+0.25) * pixSize.x,(fragCoord.y + 0.75) * pixSize.y,0.0)-normalAdjust));\n    vec4 col3 = Trace(ray);\n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x+0.75) * pixSize.x,(fragCoord.y + 0.75) * pixSize.y,0.0)-normalAdjust));\n    vec4 col4 = Trace(ray);\n    fragColor = (col1+col2+col3+col4) /4.0;\n    \n   #else\n    \n    // we cast a single ray, retrieve the final color and output it \n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x) * pixSize.x,fragCoord.y * pixSize.y,0.0)-normalAdjust));\n    vec4 col = Trace(ray);\n    fragColor = col;\n    \n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1635, 1692, 1722, 1722, 1878], [1881, 2026, 2064, 2064, 2822], [2824, 2928, 2964, 2964, 3663], [3665, 3788, 3811, 3811, 3886], [3888, 3972, 4027, 4027, 4128], [4129, 4144, 4196, 4196, 4317], [4318, 4354, 4406, 4406, 4531], [4533, 4632, 4681, 4681, 7139], [7142, 7142, 7173, 7233, 9258], [9260, 9360, 9381, 9441, 14112], [14116, 14137, 14194, 14220, 18441]], "test": "valid"}
{"id": "4dGXWy", "name": "Spherical harmonics exercise 1", "author": "xchip", "description": "Left side computes visibility sampling the hemisphere\nRight side, computes and encode visibility into spherical harmonics, then decodes visibility. \n\n", "tags": ["sphericalharmonicsvisibility"], "likes": 3, "viewed": 466, "published": "Public", "date": "1466271122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Raul Aguaviva - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The point of this shader is to show the sort of artifacts that SH introduce.\n\n// The left side of the screen shows the visibility computed stochastically, \n// The right side encodes that visibility in spherical harmonics and immediately it decodes it. \n//\n// Spherical harmonics are using extensively in quantum mechanics to study the hydrogen atom. \n// did you ever wonder why the SHs use the letters 'l' and 'm'? That is because 'l' is the angular \n// momentum and 'm' is the magnetic number. All the SHs that have the same 'l' have the same angular \n// momentum (represented often with the letter 'L')\n//\n// This sample uses a fair amount of code from these samples (Thanks to IQ): \n// \t- https://www.shadertoy.com/view/4djSDy\n// \t- https://www.shadertoy.com/view/lsfXWH\n//\n// Thanks to Matt Pharr for his excellent PBR book and in special for the SH chapter.\n\n#define SAMPLECOUNT 1024\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SphericalHarmonic( in int l, in int m, in vec3 s ) \n{ \n\tvec3 n = s.zxy;\n\t\n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    \n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    \n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n    if( l==3 && m==-3 ) return -k06*n.y*(3.0*n.x*n.x-n.y*n.y);\n    if( l==3 && m==-2 ) return  k07*n.z*n.y*n.x;\n    if( l==3 && m==-1 ) return -k08*n.y*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 0 ) return  k09*n.z*(5.0*n.z*n.z-3.0);\n    if( l==3 && m== 1 ) return -k08*n.x*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 2 ) return  k10*n.z*(n.x*n.x-n.y*n.y);\n    if( l==3 && m== 3 ) return -k06*n.x*(n.x*n.x-3.0*n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\nstruct SphericalHarmonicsCoeffs\n{\n    float v[9];\n};\n\nvoid  SphericalHarmonicsInit(out SphericalHarmonicsCoeffs coeffs)\n{\n    for (int i = 0; i < 9; i++)\n    {\n        coeffs.v[i] = 0.;\n    }\n}\n\nvoid SphericalHarmonicsMul(float scalar, inout SphericalHarmonicsCoeffs coeffs)\n{\n    for (int i = 0; i < 9; i++)\n    {\n        coeffs.v[i] *= scalar;\n    }\n}\n\n\n\nvoid SphericalHarmonicsProject(vec3 n, float value, inout SphericalHarmonicsCoeffs coeffs)\n{\n    coeffs.v[0] += SphericalHarmonic(0,  0, n) * value;\n\n    coeffs.v[1] += SphericalHarmonic(1, -1, n) * value;\n    coeffs.v[2] += SphericalHarmonic(1,  0, n) * value;\n    coeffs.v[3] += SphericalHarmonic(1,  1, n) * value;\n\n    coeffs.v[4] += SphericalHarmonic(2, -2, n) * value;\n    coeffs.v[5] += SphericalHarmonic(2, -1, n) * value;\n    coeffs.v[6] += SphericalHarmonic(2,  0, n) * value;\n    coeffs.v[7] += SphericalHarmonic(2,  1, n) * value;\n    coeffs.v[8] += SphericalHarmonic(2,  2, n) * value;\n    \n}\n\nfloat SphericalHarmonicsEval(vec3 n, in SphericalHarmonicsCoeffs coeffs)\n{\n    float res = 0.;\n\n    res += SphericalHarmonic(0,  0, n) * coeffs.v[0];\n\n    res += SphericalHarmonic(1, -1, n) * coeffs.v[1];\n    res += SphericalHarmonic(1,  0, n) * coeffs.v[2];\n    res += SphericalHarmonic(1,  1, n) * coeffs.v[3];\n\n    res += SphericalHarmonic(2, -2, n) * coeffs.v[4];\n    res += SphericalHarmonic(2, -1, n) * coeffs.v[5];\n    res += SphericalHarmonic(2,  0, n) * coeffs.v[6];\n    res += SphericalHarmonic(2,  1, n) * coeffs.v[7];\n    res += SphericalHarmonic(2,  2, n) * coeffs.v[8];\n    \n    return res;\n}\n\n//=====================================================\n\n// Sphere intersection\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nfloat Scene(in vec3 pos, in vec3 dir, out vec3 normal)\n{\n   float tmin = 1e3;\n    \n    pos+=dir*0.0001; //just to avoid self intersections\n\n   vec4 sph = vec4( cos( .5* iTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(0.,1.2,0.0), 1.0 );\n   float t2 = sphIntersect( pos, dir, sph );        \n   if( t2>0.0 && t2<tmin )\n   {\n       tmin = t2;\n       vec3 pos = pos + tmin*dir;\n       normal = normalize( pos - sph.xyz );\n   }      \n    \n   t2 = iPlane( pos, dir );\n   if( t2>0.0 && t2<tmin )\n   {\n       tmin = t2;\n       normal = vec3(0.0,1.0,0.0);\n   }    \n    \n    \n    return tmin;    \n}\n\nfloat SceneViz(in vec3 pos, in vec3 dir)\n{\n    vec3 normal;\n    float res = Scene(pos, dir, normal);\n    return res!=1e3?1.:0.;//step(0.0,res);    \n}\n\n\n//=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat ComputeViz(in vec3 pos, in vec3 dir)\n{\n    vec3  ru  = normalize( cross( dir, vec3(0.0,1.0,1.0) ) );\n    vec3  rv  = normalize( cross( ru, dir ) );\n\n    float occ = 0.0;\n    for( int i=0; i<SAMPLECOUNT; i++ )\n    {\n        vec2  aa = hash2( float(i)*203.1 );\n        float ra = sqrt(aa.y);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        float rz = sqrt( 1.0-aa.y );\n        vec3  rdir = vec3( rx*ru + ry*rv + rz*dir );\n        \n        occ += SceneViz(pos, rdir);\n    }\n    occ /= float(SAMPLECOUNT);\n    \n    return occ;\n}\n\nvoid ComputeVizSH(in vec3 pos, in vec3 dir, out SphericalHarmonicsCoeffs coeffsVis)\n{\n    SphericalHarmonicsInit(coeffsVis);    \n    \n    vec3  ru  = normalize( cross( dir, vec3(0.0,1.0,1.0) ) );\n    vec3  rv  = normalize( cross( ru, dir ) );\n\n    for( int i=0; i<SAMPLECOUNT; i++ )\n    {\n        vec2  aa = hash2( float(i)*203.1 );\n        float ra = sqrt(aa.y);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        float rz = sqrt( 1.0-aa.y );\n        vec3  rdir = vec3( rx*ru + ry*rv + rz*dir );\n        \n        float occ = SceneViz(pos, rdir);\n        if (occ>.0)\n        {\n        \tSphericalHarmonicsProject(rdir, 1., coeffsVis);\n        }\n    }\n    \n    //montecarlo stuff\n    SphericalHarmonicsMul( 2.0*( 2.0 * 3.1415)/ float(SAMPLECOUNT), coeffsVis);   \n}\n\n\n//note that when we are evaluating we need to sample the whole sphere\nfloat EvalVisibilitySH(SphericalHarmonicsCoeffs coeffsVis)\n{\n    float occ = 0.0;\n    for( int i=0; i<SAMPLECOUNT; i++ )\n    {\n        vec2  aa = hash2( float(i)*203.1 );\n        float rz = 1. - 2.*aa.y;\n        float ra = sqrt(1.-rz*rz);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        \n        vec3  rdir = vec3( rx , ry , rz );\n        \n        occ += SphericalHarmonicsEval(rdir, coeffsVis);\n    }\n    occ /= float(SAMPLECOUNT);\n    \n    return occ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    vec3 nor = vec3(0.0,0.0,0.0);\n    float t1 = Scene( ro, rd, nor );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        \n        float occ = 0.0;\n        \n        col = vec3(1.0);\n        \n        if( p.x > s )\n        {\n            SphericalHarmonicsCoeffs vizCoeffs;\n            \n            //encode visibility function into spherical harmonics            \n            ComputeVizSH(pos, nor, vizCoeffs);\n\n            //evaluate for the normal direction\n            occ = EvalVisibilitySH(vizCoeffs);           \n        }\n        else\n        {\n            occ = ComputeViz(pos, nor);           \n        }                    \n        \n        col *= 1.0 - occ;\n    }\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    //gamma, not used to make the effect more dramatic\n    col = pow( col, vec3(1.0/2.2) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGXWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1529, 1590, 1649, 1649, 2830], [2886, 2886, 2953, 2953, 3025], [3027, 3027, 3108, 3108, 3185], [3189, 3189, 3281, 3281, 3794], [3796, 3796, 3870, 3870, 4402], [4461, 4484, 4543, 4543, 4706], [4708, 4708, 4748, 4748, 4781], [4783, 4783, 4839, 4839, 5362], [5364, 5364, 5406, 5406, 5513], [5516, 5573, 5596, 5596, 5666], [5668, 5668, 5712, 5712, 6239], [6241, 6241, 6326, 6326, 7041], [7044, 7114, 7174, 7174, 7610], [7612, 7612, 7669, 7669, 8902]], "test": "valid"}
{"id": "4dKSDV", "name": "2D trabeculum", "author": "FabriceNeyret2", "description": "Voronoi diagram are nice, but for CG use several goodies are welcome. \nHere, I show how to make an organic look (no sharp angle), i.e., trabeculum patterns. ", "tags": ["procedural", "voronoi", "noise", "worley", "short", "trabeculum"], "likes": 34, "viewed": 1767, "published": "Public API", "date": "1466704896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simplification of https://www.shadertoy.com/view/lt2GDt\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\n\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy, p,c;\n    U = 5.* (U+U - R ) / R.y + iTime; \n    float l;\n    \n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\n    { // windows Angle bug with ,, instead of {}\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\n                : l < O.y  ? O.z =O.y , O.y=l \n                : l < O.z  ?            O.z=l : l;\n    }\n    O = 5.*sqrt(O); \n    \n    \n    // --- smooth distance to borders and nodes\n    \n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\n // O += smoothstep(.0,.3, l-.5) -O;\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 193, 234, 234, 1151]], "test": "valid"}
{"id": "4dKSWG", "name": "[SIG15] Furyroad2", "author": "Makio64", "description": "As warm up for July competition I rewritten my shader done for the sig15 and it should now works but I wonder how improve it in a performance point of view and looking forward for tips and advices.", "tags": ["raymarching"], "likes": 13, "viewed": 1035, "published": "Public API", "date": "1466337680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t  _______  _______  ______     _______  _______\n\t(       )(  ___  )(  __  \\   (       )(  ___  )|\\     /|\n\t| () () || (   ) || (  \\  )  | () () || (   ) |( \\   / )\n\t| || || || (___) || |   ) |  | || || || (___) | \\ (_) /\n\t| |(_)| ||  ___  || |   | |  | |(_)| ||  ___  |  ) _ (\n\t| |   | || (   ) || |   ) |  | |   | || (   ) | / ( ) \\\n\t| )   ( || )   ( || (__/  )  | )   ( || )   ( |( /   \\ )\n\t|/     \\||/     \\|(______/   |/     \\||/     \\||/     \\|\n\n*/\n\n// SIG2015 : Mad Max Fury Road\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n//#define DUST\n#define RAYMARCHING_STEP 36\n\n//------------------------------------------------------------------ DEBUG\n// #define RENDER_DEPTH\n// #define RENDER_NORMAL\n// #define RENDER_AO\n\n//------------------------------------------------------------------ MATERIALS\n\nprecision lowp float;\n\nvec3 material = vec3(1.);\nvec3 tmpMaterial = vec3(1.);\nbool isDone = false;\n\nconst vec3 wheelColor = vec3(.4,.36,.036);\nconst vec3 truckColor = vec3(.8,.72,.48);\n\nvoid setMaterial(inout vec3 mat, in vec3 color1, in vec3 color2, in float d1, in float d2){\n\tif(isDone){return;}\n\tmat = mix(color1,color2,step(0.,d1-d2));\n}\n//------------------------------------------------------------------  BASIC & SIGNED PRIMITIVES\n\nconst float PI = 3.14159265359;\n#define MOD2 vec2(3.07965, 7.4235)\n#define MOD3 vec3(3.07965, 7.1235, 4.998784)\nfloat sgn(float x) { return (x<0.)?-1.:1.; }\nvec2 sgn(vec2 v) { return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.); }\nfloat square (float x) { return x*x; }\nvec2 square (vec2 x) { return x*x; }\nvec3 square (vec3 x) { return x*x; }\nfloat lengthSqr(vec3 x) { return dot(x, x); }\nfloat Hash11( float n ){ return fract(sin(n)*1751.5453); }\nfloat Hash12(vec2 p) {\n\tp  = fract(p / MOD2);\n\tp += dot(p.xy, p.yx+19.19);\n\treturn fract(p.x * p.y);\n}\nvec2 Hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) / MOD3);\n\tp3 += dot(p3.zxy, p3.yxz+19.19);\n\treturn fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\nfloat Hash21( float p ) {\n\tvec2 p2 = fract(vec2(p) * MOD2);\n\tp2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\nfloat Hash33(vec3 p) {\n\tp  = fract(p * MOD3);\n\tp += dot(p.xyz, p.yzx + 19.19);\n\treturn fract(p.x * p.y * p.z);\n}\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat opS( float a, float b ) { return max( a, -b ); }\nfloat fCheapBox(vec3 p, vec3 b) { return vmax(abs(p) - b);}\nvoid pR(inout vec2 p, float a) { p = cos(a)*p + sin(a)*vec2(p.y, -p.x); }\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tlowp vec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat pMirror (inout float p, float dist) {\n\tlowp float s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tlowp float halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n//------------------------------------------------------------------ NOISES\n\n#define X .211324865405187\n#define Y .36602540378443\nvec3 permute(in vec3 x) { return mod( x*x*34.+x, 289.); }\nfloat snoise(in vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i,\n       j = step(x0.yx, x0),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\nfloat nse3d(in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = texture(iChannel1, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat fbm(vec3 p)\n{\n\tvec3 q = p;\n\tp += (nse3d(p * 3.0) - 0.5) * 0.3;\n\tfloat mtn = iTime * 0.15;\n\tfloat v = 0.0;\n\tfloat fq = 1.0, am = 0.5;\n\tfor(int i = 0; i < 6; i++)\n\t{\n\t\tv += nse3d(p * fq + mtn * fq) * am;\n\t\tfq *= 2.0;\n\t\tam *= 0.5;\n\t}\n\treturn v;\n}\n\n//------------------------------------------------------------------ VEHICLES\n\nfloat sdWheel( vec3 p, float height ) {\n\tfloat d = length(p.xy)-1.;\n\td = max(d, abs(p.z) - height);\n\tpR(p.xy,iTime*-4.);\n\tpModPolar(p.xy,16.);\n\tp.x -= 1.;\n\tfloat d2 = length(p.xy*1.1)-.15;\n\td2 = max(d2, abs(p.z) - height);\n\treturn opS(d,d2);\n}\n\nfloat sdTruck( in vec3 p ){\n\n\t//cockpit\n\tvec3 q = p - vec3(0.,0.5,0.);\n\tfloat d = fCheapBox(q, vec3(2.,1.7,2.) );\n\n\t//Base of cockpit\n\tq = p-vec3(1.,0.,0.);\n\tpR(q.xy,-.1);\n\td = min( d, fCheapBox(q, vec3(4.,1.3,1.6) ));\n\n\t// TODO : made it follow the truck with a easing\n\t//citern\n\tq = p-vec3(-9.,1.,0.);\n\tpR(q.xy,(1.57) );\n\td = min( d, fCylinder(q,2.3,6.));\n\n\t// Wheels\n\tq = p - vec3(-7.,-1.5,0.);\n\tfloat s = pMirror(q.x, 6.);\n\tq.x*=s;\n\tpModInterval1(q.x, 2.3, 0., 2.);\n\tfloat d2 = sdWheel(q,2.3);\n\n\t// Details\n\tq = p;\n\tpR(q.xy,0.4);\n\tq = q-vec3(-1.,2.1,0.);\n\tpMirror(q.z, 2.);\n\tpMirror(q.x, .2);\n\td = min(d, fCylinder(q, 0.2,1.3 ));\n\n\tsetMaterial(tmpMaterial,truckColor,wheelColor,d,d2);\n\td = min(d,d2);\n\treturn d;\n}\n\nfloat sdCar1( in vec3 p ){\n\tp/=0.8;\n\n\t// cockpit\n\tvec3 q = p-vec3(0.,1.3,0.);\n\tpR(q.xy,.05);\n\tfloat d = fCheapBox(q, vec3(2.,.5,1.4) );\n\n\t// Cutting the front of the cockpit\n\tq = p-vec3(3.5,0.,0.);\n\tpR(q.xy,-0.9);\n\td = opS(d,fCheapBox(q, vec3(3.5,.7,2.) ));\n\n\t// Base of the car\n\tq = p-vec3(1.,0.,0.);\n\tpR( q.xy, -0.05 );\n\td = min(d,fCheapBox(q, vec3(4.5,.7,1.8) ));\n\n\t// Cutting front of the car\n\tq = p-vec3(6.2,0.,0.);\n\tpR(q.xy,-.9);\n\td = opS(d, fCheapBox(q, vec3(4.,.7,3.) ));\n\n\t// Front motor\n\tq = p - vec3(3.,0.9,0.);\n\td = min( d, fCheapBox(q, vec3(1.,.2,0.8) ));\n\n\t// Wheels\n\tq = p - vec3(1.,-0.5,0.);\n\tq.x *= pMirror(q.x,2.8);\n\tpMirror(q.z,2.);\n\tfloat d2 = sdWheel(q, .5);\n\tsetMaterial(tmpMaterial,truckColor,wheelColor,d,d2);\n\treturn min(d,d2);\n}\n\nfloat sdCar2( in vec3 p){\n\t//cockpit\n\tp/=0.85;\n\tvec3 q = p - vec3(0.,.8,0.);\n\tpR(q.xy, -0.08);\n\tfloat d = fCheapBox(q, vec3(1.3,.3,1.05) );\n\n\t//Base of the car\n\tq = p - vec3(1.,0.,0.);\n\tpR(q.xy,-0.05);\n\td = min(d, fCheapBox(q, vec3(3.5,.4,1.2)));\n\n\t//Front motor\n\tq = p - vec3(3.,0.5,0.);\n\td = min( d, fCheapBox(q, vec3(1.,.2,0.8) ));\n\n\t// details\n\tq = p - vec3(-1.9, 1., 0.);\n\tpR(q.xy,1.1);\n\tpMirror(q.z,1.4);\n\td = min( d, fCylinder(q, 0.19,1.4 ));\n\n\t// Spears\n\tq = p - vec3(-2.5,2.8,1.3);\n\tpR(q.xy,.2);\n\tpR(q.zy,-.1);\n\td = min( d,fCylinder(q, 0.05,2.4) );\n\n\t// Spears 2\n\tq = p - vec3(-2.6,2.8,.3);\n\tpR(q.xy,.2);\n\tpR(q.zy,.1);\n\td = min( d,fCylinder(q, 0.05,3.4) );\n\n\t// Spears 3\n\tq = p - vec3(-2.5,2.8,-1.6);\n\tpR(q.xy,.26);\n\tpR(q.zy,.25);\n\td = min( d,fCylinder(q, 0.05,2.5) );\n\n\t// wheels\n\tq = p - vec3(1.1,-1.,0.);\n\tq.x *= pMirror(q.x,3.);\n\tpMirror(q.z,1.6);\n\tfloat d2 = sdWheel(q, .6);\n\tsetMaterial(tmpMaterial,truckColor,wheelColor,d,d2);\n\td = min(d,d2);\n\treturn min(d,d2);\n}\n\n//------------------------------------------------------------------ TORNADO\n\nfloat sdTornado( in vec3 p ){\n\tvec3 q = p;\n\tfloat radius = 0.2 + snoise(p.xz)*0.1;\n\tfloat angle = p.y*4.+iTime*20.;\n\n\tq.x += sin(angle)*radius;\n\tq.z += cos(angle)*radius;\n\n\t// curve the tornado\n\tq.x += sin(p.y/2.+iTime*2.5);\n\tq+=sin(p.x+snoise(p.yy+iTime)*9.+iTime)*0.25;\n\tfloat d = fCylinder(q, p.y/8.+4.,50.);\n\n\treturn d;\n}\n\nfloat sdTempest2( in vec3 p ){\n\tvec3 q = p;\n\tfloat x = pow(1.045,p.y*3.3)+20.;\n\tfloat d = fCylinder(q, x, 45.);\n\tq = p - vec3(0.,-1.5,0.);\n\td = min(d,fCylinder(q, 28.,.4));\n\td = min(d,fCheapBox(q,vec3(100.,.4,20.)));\n\td-=fbm(q/10.+iTime/1.5)*15.;\n\treturn d;\n}\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n\tfloat time = iTime;\n\n\t// // Car\n\tvec3 q = pos - vec3(5.+cos(time*2.)*2.5+cos(time/3.)*10.,1.2,12.+4.*sin(time/2.));\n\tfloat d = sdCar2(q);\n\tmaterial = tmpMaterial;\n\n\t// Truck\n\tq = pos - vec3(6.+cos(time*0.3)*9.,2.6,cos(time*0.9));\n\tfloat d2 = sdTruck(q);\n\tsetMaterial(tmpMaterial,material,tmpMaterial,d,d2);\n\tmaterial = tmpMaterial;\n\td = min(d,d2);\n\n\t// Car2\n\tq = pos - vec3(-4.+sin(time/2.)*7.,1.7,-10.-cos(time/3.)*2.);\n\td2 = sdCar1(q);\n\tsetMaterial(tmpMaterial,material,tmpMaterial,d,d2);\n\tmaterial = tmpMaterial;\n\td = min(d,d2);\n\n\t// ground\n\tsetMaterial(tmpMaterial,material,vec3(1.,0.,0.),d,pos.y);\n\td = min(pos.y,d);\n\n\t// Tornado\n\tq = pos+vec3(-40.,15.,-20.);\n\tpR(q.xz,time);\n\td2 = sdTornado(q);\n\tsetMaterial(tmpMaterial,material,vec3(0.,0.,1.),d,d2);\n\tmaterial = tmpMaterial;\n\td = fOpUnionRound(d,d2,7.);\n\n\td2 = sdTempest2(pos-vec3(15.,0.,-57.));\n\td = fOpUnionRound(d,d2,7.);\n\treturn d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING / RENDER\nfloat fogmap(in vec3 p, in float d)\n{\n\tp.x += iTime*50.;\n\treturn nse3d(p*1.1)*.02;\n}\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float dust, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd, inout float dust )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( pos.z>50. || res < 0.01 || t > 90. ) break;\n\t\tt += res;\n\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\n\t\t#ifdef DUST\n\t\tdust += fogmap(pos, t);\n\t\t#endif\n\t}\n\tisDone = true;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tconst vec2 e = vec2(0.001,-0.001);\n\treturn normalize( e.xyy*map( pos + e.xyy ) +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tfloat dust = 0.0;\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,dust,depth);\n\t#else\n\tfloat t = castRay(ro,rd,dust);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,3.,2.);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n\tvec3 bgCol = vec3(fbm(pos/10.+iTime)+fbm(pos/3.+iTime)*.3)*vec3(.5,.2,.02);\n\tbgCol *= t/40.;\n\tbgCol += vec3((1.-uv.y+.4)*(1.-uv.x+.2))*1.5;\n\n\tvec2 groundUv = vec2(pos.x/200.+iTime*.5,pos.z/100.);\n\tvec3 groundCol = texture( iChannel0, groundUv, 0.0 ).rgb;\n\tgroundCol = groundCol*vec3(max(.4,(pos.x+18.)/15.))*vec3(.6,.3,0.02);\n\n\tvec3 col = material*ao*ao*dot(nor,vec3(.5+cos(iTime)*.2,.5,.5+cos(iTime/1.5)*.2))*(texture( iChannel0, pos.yy/vec2(5.,30.), 0.0 ).rgb*1.4)*(1.3+.3*sin(iTime*2.));\n\tcol = mix( groundCol, col, smoothstep(0., 2.+smoothstep(30., 60., t)*30., pos.y));\n\tcol = mix( col, bgCol, smoothstep(70., 100., t));\n\n\t#ifdef DUST\n\t\tvec3 dustCol = vec3(3.,3.,3.)*dust*vec3(smoothstep(0.01,5.,max(0.,12.-pos.y))*(1.-smoothstep(1.,20.,max(0.,12.-pos.y))));\n\t\tcol += mix(col,dustCol,dust);\n\t#endif\n\n\treturn col;\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\n\nvec3 bw( in vec3 col ) { return vec3(0.299*col.r + 0.587*col.g + 0.114*col.b); }\n\nvoid postEffects( inout vec3 col, in vec2 uv, in float time )\n{\n\t// vigneting\n\tcol *= 0.25+0.75*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\n\t// noise\n\tcol -= snoise((uv+time)*500.)*.1;\n\n\t// lightning\n\tfloat lightning = 0.0;\n\tfloat f = mod(time+1.5, 2.);\n\tif( f < .8){\n\t\tf = smoothstep(1., .0, f)* 1.5;\n\t\tlightning = mod(-time*(1.5-Hash21(time*.5)*.002), 1.0) * f*1.2;\n\t}\n\tcol = mix(col,bw(col+lightning),lightning);\n}\n#endif\n\n//------------------------------------------------------------------ CAMERA\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize( cross(cw,vec3(sin(cr), cos(cr),0.0)) );\n\treturn mat3( cu, normalize( cross(cu,cw) ), cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y /= iResolution.x/iResolution.y;\n\n    // Camera\n    float phi = 1.25;\n    float theta = 2.4+sin(iTime/2.)*1.3;\n    float radius = 30.+cos(iTime*.8)*5.;\n    //shaking\n    phi += +sin(iTime*123132.)*0.005;\n    theta += +sin(iTime*3132.)*0.005;\n    \n    \n\tvec3 ro = orbit(phi,theta,radius);\n\tmat3 ca = setCamera( ro, vec3(0.,10.,0.), 0. );\n\tvec3 rd = ca * normalize( vec3(2.*uv-1.,1.0) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\n\t#ifdef POSTPROCESS\n\tpostEffects( color, uv, iTime );\n\t#endif\n\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[814, 1080, 1171, 1171, 1236], [1237, 1446, 1466, 1466, 1490], [1491, 1491, 1509, 1509, 1558], [1559, 1559, 1583, 1583, 1597], [1598, 1598, 1620, 1620, 1634], [1635, 1635, 1657, 1657, 1671], [1672, 1672, 1697, 1697, 1717], [1718, 1718, 1742, 1742, 1776], [1777, 1777, 1799, 1799, 1879], [1880, 1880, 1901, 1901, 2020], [2021, 2021, 2046, 2046, 2142], [2143, 2143, 2165, 2165, 2255], [2256, 2256, 2276, 2276, 2310], [2311, 2311, 2342, 2342, 2365], [2366, 2366, 2399, 2399, 2425], [2426, 2426, 2458, 2458, 2499], [2500, 2500, 2548, 2548, 2622], [2623, 2623, 2671, 2671, 2761], [2762, 2762, 2805, 2805, 2860], [2861, 2861, 2934, 2934, 3225], [3226, 3226, 3276, 3276, 3514], [3516, 3646, 3671, 3671, 3703], [3704, 3704, 3729, 3729, 4364], [4366, 4366, 4390, 4390, 4605], [4607, 4607, 4626, 4626, 4856], [4858, 4937, 4976, 4976, 5180], [5182, 5182, 5209, 5221, 5899], [5901, 5901, 5927, 5927, 6655], [6657, 6657, 6682, 6693, 7636], [7638, 7716, 7745, 7745, 8041], [8043, 8043, 8073, 8073, 8302], [8304, 8377, 8403, 8403, 9299], [9301, 9391, 9428, 9428, 9475]], "test": "error"}
{"id": "4dVXRd", "name": "Heart_Beat", "author": "visnyin", "description": "for love", "tags": ["love"], "likes": 1, "viewed": 142, "published": "Public", "date": "1466156710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float heart2(float xx,float yy,float zz)\n{\n    float x = xx*3.0;\n    float y = yy*3.0;\n    float z = zz*3.0;\n    vec4 fragColor = vec4(1.0,0.0,0.0,1.0);\n    float value = pow(x*x + 9.0/4.0*y*y + z*z - 1.0,3.0) - x*x*z*z*z - 9.0/80.0*y*y*z*z*z;\n    return value;\n}\n\nvoid drawHeart3(in vec3 trans1,in vec3 trans2,out vec4 fragColor, in vec2 fragCoord,float size1, float size2,float size3, float size4, in vec4 basecolor)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float x = uv.x*2.0 - 1.0;\n    float y = uv.y*2.0 - 1.0;\n    float z = 0.0;\n    \n    for(int i=0;i<2000;i++)\n    {\n        float temp = float(i);\n        z = (temp-1000.0)/1000.0;\n        \n        vec3 interPos = vec3(x,y,z);\n        vec3 interPos1 = interPos + trans1;\n        vec3 interPos2 = interPos + trans2;\n        \n        vec3 pos1_1 = interPos1/size1;\n        vec3 pos1_2 = interPos1/size2;\n        \n        vec3 pos2_1 = interPos2/size3;\n        vec3 pos2_2 = interPos2/size4;\n               \n\n        float inheart1_1 = heart2(pos1_1.x,pos1_1.z,pos1_1.y);\n        float inheart1_2 = heart2(pos1_2.x,pos1_2.z,pos1_2.y);\n        \n        float inheart2_1 = heart2(pos2_1.x,pos2_1.z,pos2_1.y);\n        float inheart2_2 = heart2(pos2_2.x,pos2_2.z,pos2_2.y);\n        \n        vec4 tempColor;\n        \n        if(inheart1_2 < 0.0 && inheart1_1 > 0.0)\n            tempColor = 0.001*basecolor;\n        else if(inheart1_1 > 0.0)\n        {\n            if(inheart2_2 < 0.0 && inheart2_1 > 0.0)\n            \ttempColor = 0.001*basecolor;\n            else\n                tempColor = vec4(0.0,0.0,0.0,1.0);\n        }\n        else\n            tempColor = vec4(0.0,0.0,0.0,1.0);\n        \n      \tfragColor += tempColor;        \n    }\n    \n    float scale = 3.0;\n    fragColor *= scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    float size1 = 1.0;\n    float size2 = 2.0;\n    float size3 = 1.0;\n    float size4 = 2.0;\n    float scale = 1.0;\n    const float dul = 50.0;\n    float total1 = 80.0*iTime;\n    float temp01 = total1/dul;\n    temp01 = total1 - float(int(temp01))*dul;\n    temp01 /= dul;\n    \n    float total2 = 80.0*(iTime - 0.1);\n    float temp02 = total2/dul;\n    temp02 = total2 - float(int(temp02))*dul;\n    temp02 /= dul;\n    \n    temp01 = abs(temp01*2.0 - 1.0)*scale;   \n    temp01 += 1.0;\n    size2 = temp01;\n        \n    temp02 = abs(temp02*2.0 - 1.0)*scale;   \n    temp02 += 1.0;\n    size4 = temp02;\n\n    drawHeart3(vec3(0.3,-0.1,0.0),vec3(-0.3,0.1,0.0),fragColor,fragCoord,size1,size2,size3,size4,vec4(0.5,0.0,0.0,1.0));\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 263], [265, 265, 420, 420, 1756], [1758, 1758, 1815, 1815, 2574]], "test": "valid"}
{"id": "4dVXWy", "name": "Loading - With Glow + Falloff", "author": "kgn", "description": "Glowing loading indicator who's tail tapers off and fades out.", "tags": ["loading", "ui"], "likes": 20, "viewed": 1103, "published": "Public API", "date": "1466353924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat radius = 0.3;\n\tfloat lineWidth = 5.0; // in pixels\n\tfloat glowSize = 5.0; // in pixels\n    \n    float pixelSize = 1.0/min(iResolution.x, iResolution.y);\n\tlineWidth *= pixelSize;\n\tglowSize *= pixelSize;\n    glowSize *= 2.0;\n    \n  \tvec2 uv = (fragCoord.xy / iResolution.xy)-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float len = length(uv);\n\tfloat angle = atan(uv.y, uv.x);\n    \n\tfloat fallOff = fract(-0.5*(angle/pi)-iTime*0.5);\n    \n    lineWidth = (lineWidth-pixelSize)*0.5*fallOff;\n\tfloat color = smoothstep(pixelSize, 0.0, abs(radius - len) - lineWidth)*fallOff;\n\tcolor += smoothstep(glowSize*fallOff, 0.0, abs(radius - len) - lineWidth)*fallOff*0.5;    \n    \n\tfragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 83, 794]], "test": "valid"}
{"id": "4dyXDD", "name": "Multi-biomes Planet", "author": "Karang", "description": "Small Planet", "tags": ["procedural", "planet"], "likes": 7, "viewed": 316, "published": "Public", "date": "1466891289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nvec3 lPos = normalize(vec3(1.0, 0.0, 0.0)); // Sun direction\nvec3 pAxis = normalize(vec3(0.0, 1.0, 0.5)); // Axe de rotation\nfloat pRadius = 10.0; // Planet radius\nfloat sLevel = 0.8; // Sea level\n\nfloat hash(float h) {\n    h += 40.0; // prevent center symetry\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat snoise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat star(vec3 p) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<6 ; i++) {\n        h += (snoise(p*f*300.0)/f);\n        f *= 2.0;\n    }\n    return smoothstep(0.1, 0.9, 1.0-h*2.0);\n}\n\n// Ridged multi-fractal helps to create mountain chains and ocean rift\nfloat elevation(vec3 p, int octaves) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<8 ; i++) {\n        if (i>octaves) break;\n        h += abs((snoise(p*f*0.2)-0.5)/f);\n        f *= 2.0;\n    }\n    return h-1.0;\n}\n\nfloat rivers(vec3 p, float height, float t, int octaves) {\n    p = (rotationMatrix(pAxis, iTime*0.05) * vec4(p,1.0)).xyz;\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<3 ; i++) {\n        if (i>octaves) break;\n        h += (snoise(p*f*2.0+80.0)-0.5)/f;\n        f *= 2.0;\n    }\n    return abs(h)*0.2+1.0-smoothstep(0.0, 1.0, (1.0-t)*10.0);\n}\n\n// Compute temperature gradient based on lattitude and altitude\nfloat meanTemperature(vec3 p) {\n    float lat = asin(dot(normalize(p), pAxis))/(3.14159/2.0);\n    float h = length(p) - pRadius;\n    return 1.5 - abs(lat)*1.5 - h*0.3;\n}\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n    p = (rotationMatrix(pAxis, iTime*0.05) * vec4(p,1.0)).xyz;\n    \n    d = length(p) - pRadius + elevation(p, 8);\n    \n    if (d<dMin) {\n        dMin = d;\n        mID = 0.0;\n    }\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 screenP) {\n\tconst int geoLOD = 8;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n    \n    vec3 color = vec3(0.005,0.005,0.06);\n    float sun = clamp(dot(rd, lPos),0.0,1.0)+0.05;\n    color += 0.01 * lCol * pow(sun, 100.0);\n    \n    color += star(rd);\n    \n    // Fake atmosphere\n    float uFrac = 0.55;\n    float uWidth = 0.05;\n    color += vec3(0.6, 0.8, 1.0)*(1.0-smoothstep(0.0, (1.0+uWidth)*uFrac, length(screenP)-uFrac));\n    \n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n    int norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\t\n    vec3 pos = ro + rd*res.x;\n    float h = length(pos) - pRadius;\n    float t = meanTemperature(pos);\n    float riv = rivers(pos, h, t, norLOD);\n    \n\t// vec3 nor = normalize(pos); // Sphere normals (disable relief visualisation)\n\tvec3 nor = calcNormal(pos, norLOD);\n    \n    float slope = dot(normalize(pos), nor);\n\t\n    // Temperature visualisation\n\t//color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), t);\n    \n    \n    if (h<sLevel || riv<0.005) {\n        color = vec3(0.0, 0.0, 1.0);\n        if (t<0.1) {\n            color = vec3(0.4, 0.7, 1.0);\n        }\n    } else {\n        if (t<0.1) {\n            color = vec3(0.7, 0.8, 1.0);\n            if (slope<0.98) color = vec3(0.1, 0.1, 0.1);\n        } else if (t<0.8 && h>sLevel+0.01) {\n            color = vec3(0.3, 0.5, 0.2);\n            if (slope<0.98) color = vec3(0.1, 0.1, 0.1);\n        } else if(t<0.83 || (t>0.8 && (h<(sLevel+0.02) || riv<0.025)))\n            color = vec3(0.4, 0.5, 0.2);\n         else\n            color = vec3(0.8, 0.7, 0.5);\n    }\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.09, 2.0);\n\n    color += (0.3*lAmb) * lCol;\n    color *= (1.1*lDif) * lCol;\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    \n\t// Camera\n    float radius = 26.0;\n    vec3 cPos = vec3(radius, 0.0, 0.0);\n    cPos = (rotationMatrix(vec3(0.0, 1.0, 0.0), iMouse.x*0.01)*rotationMatrix(vec3(0.0, 0.0, 1.0), clamp(-2.0+iMouse.y*0.01, -3.14/2.0, 3.14/2.0))*vec4(cPos, 1.0)).xyz;\n\t/*float x = 0.0 + radius*cos(iMouse.x*0.01);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + radius*sin(iMouse.x*0.01);\n\tvec3 cPos = vec3(x, y, z);*/\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(0.0, 0.0, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd, pos);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 298, 319, 319, 401], [403, 403, 425, 425, 769], [771, 771, 816, 816, 1444], [1446, 1446, 1466, 1466, 1642], [1644, 1715, 1753, 1753, 1940], [1942, 1942, 2000, 2000, 2294], [2296, 2360, 2391, 2391, 2529], [2531, 2531, 2562, 2562, 2821], [2823, 2887, 2932, 2932, 3218], [3220, 3220, 3258, 3258, 3513], [3515, 3515, 3560, 3560, 5375], [5377, 5377, 5434, 5434, 6271]], "test": "valid"}
{"id": "4dyXDt", "name": "Ray Marching Experiment 53", "author": "aiekick", "description": "Ray Marching Experiment 53", "tags": ["sss", "ray", "experiment", "marching", "cheap", "53"], "likes": 4, "viewed": 489, "published": "Public API", "date": "1467277854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nfloat df(vec3 p)\n{\n    float disp = dot(texture(iChannel0, (p.xz + iTime)*0.2),vec4(0.2));\n\tfloat l = length(p) - 4.5;\n    return l + disp;\n}\n\nvec3 nor( in vec3 p, vec3 prec )\n{\n\tvec3 e = vec3( 0.03, 0., 0. );\n\tvec3 n = vec3(\n\t    df(p+e.xyy) - df(p-e.xyy),\n\t    df(p+e.yxy) - df(p-e.yxy),\n\t    df(p+e.yyx) - df(p-e.yyx) );\n\treturn normalize(n);\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,vec3( 0.0001, 0, 0)); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s)/s;\t\t\t\t\t\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvec2 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, vec3( 0.0001, 0, 0));\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 1.; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 2.2); \t\t\t\t\t\t\t// sub density of df\n\treturn vec2(\n        (diff + fre + spe) * amb * li, \t\t\t\t\t\t\t\t// ambiant diffuse + fresenl + specular => out\n        (diff + fre + sss) * amb * li\t\t\t\t\t\t\t\t// ambient diffuse + fresnel + subsurface => in\n    );\n}\n\nfloat pn( in vec3 x ) // iq noise\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture(iChannel1, (uv+ 0.5)/iChannelResolution[1].xy, -100.0 ).gr;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nvec3 stars(vec2 uv, vec3 rd, float d)\n{\n    uv *= 1000.;\n\tfloat k = fract( cos(uv.y * 0.0001 + uv.x) * 90000.);\n\tfloat var = sin(pn(d*0.6+rd*182.14))*0.5+0.5;// thank to klems for the variation in my shader subluminic\n\tvec3 col = vec3(mix(0., 1., var*pow(k, 200.)));// come from CBS Shader \"Simplicity\" : https://www.shadertoy.com/view/MslGWN\n\treturn col;\n}\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n    float time = iTime*0.25;\n    float cam_e = 5.; \n    float cam_d = 1.2; \n  \n    vec2 si = iResolution.xy;\n    vec2 uv = (g+g-si.xy)/si.y;\n    \n    vec3 ro = vec3(sin(time), 5., cos(time))*1.2;\n  \tvec3 cu = vec3(0,1,0);\n  \tvec3 cv = vec3(0); \n\tvec3 rov = normalize(cv-ro);\n    vec3 u = normalize(cross(cu,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float md = 6.;\n    \n    float s = 1., d = 0.;\n    for(int i=0;i<150;i++)\n    {      \n        if (log(d*d/s/1e5)>0.||s>md) break;\n        d += s = df(ro+rd*d);\n    }\n    \n    if (d<md)\n\t\tf.rgb = shade(ro, rd, d*d, ro, 0.55).y * vec3(1,0.57,0);\n    else\n        f.rgb = stars(uv, rd, d);\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyXDt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 196, 214, 214, 337], [339, 339, 373, 373, 543], [545, 545, 581, 581, 739], [741, 741, 799, 799, 1573], [1575, 1575, 1610, 1610, 1846], [1848, 1848, 1887, 1887, 2205], [2207, 2207, 2245, 2245, 2929]], "test": "error"}
{"id": "4dyXWd", "name": "bwarf", "author": "alexerrington", "description": "bwarf", "tags": ["bwarf"], "likes": 1, "viewed": 73, "published": "Public", "date": "1467297352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform vec2 resolution;\n\nfloat unite( float a, float b){return min(a, b);}\nfloat subtract( float a, float b ){ return max(-a, b); }\nfloat intersect( float a, float b ){ return max(a, b); }\n\nfloat sphere( vec3 pos, vec3 center, float radius )\n{\n    return length( pos - center ) - radius;\n}\n \nfloat box( vec3 pos, vec3 center, vec3 size, float corner )\n{\n    return length( max( abs( pos-center )-size, 0.0 ) )-corner;\n}\n\nfloat sdf(vec3 p)\n{\n    float s = sphere( p, vec3( 0. ), 1.25 );\n \n    float b = box( p, vec3( 0. ), vec3( 1. ), .0 );\n \n    return unite( s,b  );\n}\n\n\n/*float sdf(vec3 p)\n{\n\treturn length(p) - 1.0;\n}*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0,1.0,0.0,1.0);\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    //uv.x *= (resolution.x / resolution.y) / 10.0;\n    \n    vec3 pos = vec3(0., 0., -5.);\n    vec3 dir = normalize(vec3(uv, 1.));\n    \n    vec3 ip;\n    \n    float t = 0.0;\n    for(int i = 0; i < 24; i++){\n        ip = pos + dir * t;\n        \n        float temp = sdf(ip);\n        //if(temp < 0.01) break;\n        \n\t\tif(t < 0.0)\n        \tt += temp * sin(iTime) * 2.0;\n        else\n            t -= temp * sin(iTime) * 2.0;\n        \n        \n    }\n    fragColor = vec4(ip, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 57, 57, 75], [76, 76, 111, 111, 132], [133, 133, 169, 169, 189], [191, 191, 244, 244, 290], [293, 293, 354, 354, 420], [422, 422, 441, 441, 570], [573, 624, 681, 681, 1266]], "test": "error"}
{"id": "4sdGWr", "name": "Schottky Mountain", "author": "soma_arc", "description": "Kissing Schottky groups + Terrain raymarching\nReference: Terrain raymarching by iq\nhttp://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm", "tags": ["3d", "fractal", "schottkygroups"], "likes": 8, "viewed": 199, "published": "Public", "date": "1465379908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\nconst float PI = 3.14159265;\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nfloat LINE_THRESHOLD = 0.0001;\nvec3 getLine(vec2 p1, vec2 p2){\n  float xDiff = p2.x - p1.x;\n  float yDiff = p2.y - p1.y;\n  if(abs(xDiff) < LINE_THRESHOLD){\n    //x = c\n    return vec3(1, 0, p1.x);\n  }else if(abs(yDiff) < LINE_THRESHOLD){\n    //y = c\n    return vec3(0, 1, p1.y);\n  }else{\n    //y = ax + b\n    return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);\n  }\n}\n\nfloat calcX(vec3 line, float y){\n  if(line.z == 0.){\n    return (y - line.y) / line.x;\n  }else{\n    return line.z;\n  }\n}\n\nfloat calcY(vec3 line, float x){\n  if(line.z == 0.){\n    return line.x * x + line.y;\n  }else{\n    return line.z;\n  }\n}\n\nvec2 calcIntersection(vec3 line1, vec3 line2){\n  if(line1.z == 0. && line2.z == 0.){\n    float x1 = 1.;\n    float x2 = 5.;\n    float y1 = calcY(line1, x1);\n    float y2 = calcY(line1, x2);\n\n    float x3 = 4.;\n    float x4 = 8.;\n    float y3 = calcY(line2, x3);\n    float y4 = calcY(line2, x4);\n\n    float ksi   = ( y4-y3 )*( x4-x1 ) - ( x4-x3 )*( y4-y1 );\n    float eta   = ( x2-x1 )*( y4-y1 ) - ( y2-y1 )*( x4-x1 );\n    float delta = ( x2-x1 )*( y4-y3 ) - ( y2-y1 )*( x4-x3 );\n\n    float lambda = ksi / delta;\n    float mu    = eta / delta;\n    return vec2(x1 + lambda*( x2-x1 ), y1 + lambda*( y2-y1 ));\n  }else{\n    if(line1.x == 1.){\n      return vec2(line1.z, calcY(line2, line1.z));\n    }else if(line1.y == 1.){\n      return vec2(calcX(line2, line1.z), line1.z);\n    }else if(line2.x == 1.){\n      return vec2(line2.z, calcY(line1, line2.z));\n    }\n    return vec2(calcX(line1, line2.z), line2.z);\n  }\n}\n\nconst vec2 commonCirclePos = vec2(0, 0);\nconst float commonCircleR = 10.;\nconst vec2 p = commonCirclePos + vec2(0, commonCircleR);\nconst vec2 q = commonCirclePos + vec2(-commonCircleR, 0);\nconst vec2 r = commonCirclePos + vec2(0, -commonCircleR);\nconst vec2 s = commonCirclePos + vec2(commonCircleR, 0);\n\nvec2 c1Pos, c2Pos, c3Pos, c4Pos;\nfloat c1R, c2R, c3R, c4R;\n\nvoid calcContactCircles(vec2 commonCirclePos, float commonCircleR){\n  vec2 pqMid = (p + q)/2.;\n  vec2 u = (pqMid - commonCirclePos)/distance(commonCirclePos, pqMid);\n  vec2 a = u * commonCircleR * (sin(iTime) * 6. + 6.72) + commonCirclePos;\n  c1Pos = a;\n  c1R = distance(a, p);\n\n  vec3 aq = getLine(a, q);\n  vec3 qrMidPer = getLine(commonCirclePos, (q + r) / 2.);\n  vec2 b = calcIntersection(aq, qrMidPer);\n  c2Pos = b;\n  c2R = distance(b, q);\n\n  vec3 br = getLine(b, r);\n  vec3 rsMidPer = getLine(commonCirclePos, (r + s) / 2.);\n  vec2 c = calcIntersection(br, rsMidPer);\n  c3Pos = c;\n  c3R = distance(c, r);\n\n  vec3 cs = getLine(c, s);\n  vec3 spMidPer = getLine(commonCirclePos, (s + p) / 2.);\n  vec2 d = calcIntersection(cs, spMidPer);\n  c4Pos = d;\n  c4R = distance(d, s);\n}\n\nfloat loopNum = 0.;\nconst int ITERATIONS = 6;\nfloat IIS(vec2 pos){\n    loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tcont = false;\n\t\tif(distance(pos, c1Pos) < c1R){\n\t\t\tpos = circleInverse(pos, c1Pos, c1R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c2Pos) < c2R){\n\t\t\tpos = circleInverse(pos, c2Pos, c2R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c3Pos) < c3R){\n\t\t\tpos = circleInverse(pos, c3Pos, c3R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c4Pos) < c4R){\n\t\t\tpos = circleInverse(pos, c4Pos, c4R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}\n\t\tif(cont == false) break;\n\t}\n\tif(length(pos) < commonCircleR)\n        return float(ITERATIONS) + abs(loopNum - float(ITERATIONS));\n\treturn loopNum;\n}\n\nfloat calcHeight(vec2 p){\n    return IIS(p) * 1.3;\n}\n\nconst vec3 BLACK = vec3(0);\nfloat march(vec3 rayOrigin, vec3 rayDir){\n    const float delt = 0.04;\n    const float mint = 3.;\n    const float maxt = 100.;\n    for( float t = mint; t < maxt; t += delt ) {\n        vec3 p = rayOrigin + rayDir * t;\n        if( p.y < calcHeight(p.xz)) {\n            return t - 0.5 * delt;\n        }\n    }\n    return maxt;\n}\n\nconst vec2 d = vec2(0.1, 0.);\nvec3 calcNormal(const vec3 p){\n  return normalize(vec3(calcHeight(p.xz - d.xy) - calcHeight(p.xz + d.xy),\n                     \t2. * d.x,\n                     \tcalcHeight(p.xz - d.yx) - calcHeight(p.xz + d.yx)));\n}\n\nconst float PI_4 = 12.566368;\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. ) ?\n    \t(lightPower * (d / (PI_4 * r * r))) * diffuseColor\n    \t: vec3(0.);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst vec3 lightPos = vec3(0, 100, 0);\nconst vec3 lightPower = vec3(50000.);\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \tfloat coeff = 1.;\n    float t = march(eye, ray);\n  \t\n    //if(t > 0.){\n        vec3 intersection = eye + ray * t;\n        vec3 normal = calcNormal(intersection);\n        vec3 matColor = vec3(hsv2rgb(vec3(loopNum / 10. ,1., 1.)));\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n    //}\n  \treturn l;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 xaxis = normalize(cross(v, up));\n  \tvec3 yaxis =  normalize(cross(v, xaxis));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  \treturn normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 target = vec3(0., 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float sampleNum = 50.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    calcContactCircles(commonCirclePos, commonCircleR);\n    vec3 eye = vec3(15. * cos(iTime/2.) , 25. + 15. * (sin(iTime)), 15. *sin(iTime/2.));\n    const vec2 coordOffset = vec2(0.5);\n  \tvec3 ray = calcRay(eye, target, up, fov,\n    \t               iResolution.x, iResolution.y,\n        \t           gl_FragCoord.xy + coordOffset);\n\n  \tfragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGWr.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[0, 159, 219, 219, 335], [368, 368, 399, 399, 713], [715, 715, 747, 747, 835], [837, 837, 869, 869, 955], [957, 957, 1003, 1003, 1865], [2232, 2232, 2299, 2299, 3009], [3057, 3057, 3077, 3077, 3800], [3802, 3802, 3827, 3827, 3854], [3884, 3884, 3925, 3925, 4208], [4240, 4240, 4270, 4270, 4454], [4486, 4486, 4625, 4625, 4807], [4809, 4809, 4830, 4830, 4999], [5078, 5078, 5113, 5113, 5469], [5471, 5471, 5623, 5623, 5987], [6033, 6033, 6062, 6062, 6242], [6367, 6367, 6423, 6423, 6818]], "test": "valid"}
{"id": "4sdGzs", "name": "Radiolarian #3", "author": "tdhooper", "description": "See the [url=https://twitter.com/tdhooper/status/738925905796575232]gif export without artefacts[/url], I need a better way of modelling spikes.", "tags": ["sdf", "icosahedron", "subdivision", "polyhedra", "geodesic"], "likes": 43, "viewed": 1139, "published": "Public API", "date": "1465056247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat t;\nfloat pulse;\nfloat move;\n\n// HG_SDF\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\nfloat fPlane(vec3 p, vec3 a, vec3 b, vec3 c, vec3 inside, float distanceFromOrigin) {\n    vec3 n = normalize(cross(c - b, a - b));\n    float d = -dot(a, n);\n    \n    if (dot(n, inside) + d > 0.) {\n        n = -n;\n        d = -d;\n    }\n\n    return fPlane(p, n, d + distanceFromOrigin);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n\n\n// Knighty https://www.shadertoy.com/view/XlX3zB\n\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nint Type=5;\n\nvec3 nc,pab,pbc,pca;\nvec3 icoF0;\nvec3 icoF1a;\nvec3 icoA0;\nvec3 icoB0;\nvec3 icoC0;\nvec3 icoA1;\nvec3 icoB1;\nvec3 icoC1;\nvec3 fold1;\nvec3 fold2;\nvec3 fold3;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n    vec3 A = pbc;\n    vec3 C = reflect(A, normalize(cross(pab, pca)));\n    vec3 B = reflect(C, normalize(cross(pbc, pca)));\n    \n    icoF0 = pca;\n    \n\ticoA0 = A;\n\ticoC0 = B;\n\ticoB0 = C;\n\n    vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n    vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n    fold1 = normalize(cross(p1, p2));\n    \n    // Get corners of triangle created by fold\n    vec3 A2 = reflect(A, fold1);\n    vec3 B2 = p1;\n    vec3 C2 = p2;\n    \n    icoF1a = pca;\n    \n    icoA1 = A2;\n    icoB1 = normalize(B2);\n    icoC1 = normalize(C2);\n    \n    p1 = bToC(A2, B2, C2, vec3(.5, .0, .5));\n    p2 = bToC(A2, B2, C2, vec3(.5, .5, .0));\n    fold2 = normalize(cross(p1, p2));\n    \n\tp1 = bToC(A2, B2, C2, vec3(.0, .5, .5));\n    fold3 = normalize(cross(p2, p1));\n}\n\n\n\nfloat pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    float i = 0.;\n    \n    if (subdivisions > 0) {\n\n        // Fold in corner A \n        i += pReflect(p, fold1, 0.) / 2. + .5;\n        \n        if (subdivisions > 1) {\n            \n            // Fold in corner A\n            pReflect(p, fold2, 0.);\n            \n            // Fold in corner B\n            pReflect(p, fold3, 0.);\n        }\n    }\n\n    return i;\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );       \n}\n\nvec3 pRoll(inout vec3 p) {\n    pR(p.yx, PI/3.);\n    pR(p.yz, PI/-5.);\n    mat3 m = rotationMatrix(normalize(icoF1a), t * ((PI*2.)/3.));\n    p *= m;\n    return p;\n}\n\nfloat fCone(vec3 p, float radius, float height, vec3 direction) {\n    p = reflect(p, normalize(mix(vec3(0,1,0), -direction, .5)));\n    //p -= vec3(0,height,0);\n    return fCone(p, radius, height);\n}\n\n\nfloat fHolePart(\n    vec3 p,\n    vec3 a,\n    vec3 b,\n    vec3 c,\n    vec3 d,\n    float round,\n    float thick\n) {\n    vec3 center = (a + b + c + d) / 4.;\n    float f0 = fPlane(p, a, b, c, center, thick);\n    float f1 = fPlane(p, a, c, d, center, thick);\n   \tfloat f = f0;\n   \tf = fOpIntersectionRound(f, f1, round);\n   \treturn f;\n}\n\n    \nfloat fHole(\n    vec3 p,\n    vec3 a,\n    vec3 b,\n    vec3 c\n) {\n    float w = 1.;\n    float h = 1.;\n    float round = .08;\n    float thick = .02;\n\n\tfloat d = 1000.;\n\n    vec3 AB = mix(a, b, 0.5);\n    vec3 AAB = mix(a, b, w);\n    vec3 ABB = mix(a, b, 1. - w);\n    vec3 n = normalize(cross(a, b));\n    vec3 cn = dot(c, n) * n;\n    vec3 AF = c - cn * (1. - h);\n    vec3 AF2 = reflect(AF, n);\n\n    float part1 = fHolePart(p, vec3(0), AF2, AAB, AF, round, thick);\n\tfloat part2 = fHolePart(p, vec3(0), AF2, ABB, AF, round, thick);\n\tfloat hole = fOpIntersectionRound(part1, part2, round);\n    return hole;\n}\n\nfloat holes(vec3 p, float i) {\n    float d = 1000.;\n\n    if (i > 0.) {  \n        return min(d, fHole(p, icoC1, icoB1, icoF1a));\n    }\n    \n    d = min(d, fHole(p, icoC1, icoB1, icoF1a));\n    d = min(d, fHole(p, icoA1, icoB1, icoF1a));\n    return d;\n}\n\n\nfloat spikes(vec3 p) {\n    float d = 1000.;\n    d = min(d, fCone(p, .05, 1.3, icoF1a));\n    d = min(d, fCone(p, .05, 1.7, icoA1));\n    d = min(d, fCone(p, .05, 1.8, icoB1));\n    return d;\n}\n\nfloat shell(vec3 p, float i) {\n\n    float thick = .03;\n    float round = .015;\n\n    float d = length(p) - 1.;\n    d = fOpUnionRound(d, spikes(p), .12);\n    d = max(d, -(length(p) - (1. - thick)));\n\tfloat h = holes(p, i);\n    h = max(h, (length(p) - 1.1)); // Stop holes clipping spikes\n    d = fOpIntersectionRound(d, -h, round);\n    return d;\n}\n\nfloat model(vec3 p) {\n    pRoll(p);\n\n    float d = 1000.;\n    float i = 0.;\n \n    i = pModIcosahedron(p, 1);\n    d = min(d, shell(p, i)); \n    return d;\n}\n\nvec3 doBackground(vec3 rayVec) {\n    return vec3(.13);\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n//const float MAX_STEP_DISTANCE = 0.05;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n    return (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 p ){  \n    \n    vec2 res = vec2(model(p) ,1.); \n    \n    return res;\n}\n\n\n\n// LIGHTING\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvec3 doLighting(vec3 col, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n\n    // lighitng        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, 0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    //float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    //float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n    \n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    //dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    //lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    //lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n\n    return col;\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro+rd*t );\n        h = m.x;\n        //t += min(h, MAX_STEP_DISTANCE);\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    vec3 orient = normalize(vec3(.1, 1, 0.));\n    float zoom = 4.;\n    zoom -= mouse.y * 3.5;\n    camPos = zoom * orient;\n    camTar = vec3(0);\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n\n  vec3 color = vec3(.04,.045,.05);\n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 ref = reflect(rd, norm);\n\t//return norm * 0.5 + 0.5;\n      \n\tcolor = vec3(.5);  \n\tcolor = doLighting(color, pos, norm, ref, rd);\n  }\n   \n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    t = mod(t/4., 1.);    \n\n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera movement\n    doCamera(ro, ta, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n    \n    vec3 color = render( res , ro , rd );\n\tcolor = linearToScreen(color);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 110, 130, 130, 165], [167, 203, 231, 231, 312], [314, 398, 442, 442, 545], [547, 619, 668, 668, 705], [707, 707, 763, 763, 808], [810, 810, 895, 895, 1096], [1098, 1098, 1153, 1153, 1288], [1290, 1386, 1435, 1435, 1934], [1936, 2174, 2206, 2206, 2251], [2253, 2281, 2343, 2343, 2467], [2469, 2548, 2596, 2596, 2727], [2782, 2811, 2864, 2864, 2933], [3102, 3102, 3126, 3159, 4352], [4356, 4356, 4411, 4411, 4906], [4908, 4977, 5022, 5022, 5499], [5501, 5501, 5527, 5527, 5664], [5666, 5666, 5731, 5731, 5864], [5867, 5867, 5980, 5980, 6198], [6205, 6205, 6268, 6268, 6805], [6807, 6807, 6837, 6837, 7057], [7060, 7060, 7082, 7082, 7249], [7251, 7251, 7281, 7281, 7596], [7598, 7598, 7619, 7619, 7752], [7754, 7754, 7786, 7786, 7810], [8114, 8208, 8237, 8237, 8283], [8286, 8370, 8389, 8389, 8455], [8459, 8472, 8546, 8546, 8816], [8819, 8819, 8861, 8861, 9163], [9191, 9191, 9224, 9224, 9258], [9260, 9260, 9297, 9297, 9341], [9343, 9343, 9409, 9434, 10343], [10347, 10347, 10395, 10395, 10910], [10913, 10944, 11008, 11008, 11186], [11188, 11188, 11267, 11267, 11413], [11416, 11529, 11560, 11560, 11804], [11807, 11807, 11851, 11851, 12151], [12154, 12154, 12211, 12211, 12898]], "test": "valid"}
{"id": "4sGSDy", "name": "Lattices", "author": "jaburns", "description": "Simple 2d scrolling cellular noise lattices", "tags": ["voronoi", "noise"], "likes": 11, "viewed": 366, "published": "Public API", "date": "1466198928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from \"Voronoi - distances\" https://www.shadertoy.com/view/ldl3W8\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n// JS color parser:\n//function f(a) { var y=[parseInt(a.substr(0,2),16)/0xff, parseInt(a.substr(2,2),16)/0xff, parseInt(a.substr(4,2),16)/0xff]; return JSON.stringify(y).replace(\"[\",\"vec3(\").replace(\"]\",\");\"); }\n\nconst vec3 COLOR_0 = vec3(0.11372549019607843,0.16862745098039217,0.3254901960784314);\nconst vec3 COLOR_1 = vec3(0.49411764705882355,0.1450980392156863,0.3254901960784314);\nconst vec3 COLOR_2 = vec3(1,0,0.30196078431372547);\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\t//return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x, in float t )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        o = 0.3+0.3*sin( t + 6.2831*o );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        o = 0.3+0.3*sin( t + 6.2831*o );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nfloat layer1( in vec2 p, in float t )\n{\n    vec3 c = voronoi( 8.0*p, t );\n    return mix( 1.0, 0.0, smoothstep( 0.12, 0.14, c.x ) ); \n}\n\nfloat layer2( in vec2 p, in float t )\n{\n    vec3 c = voronoi( 12.0*p, t );\n    return mix( 1.0, 0.0, smoothstep( 0.09, 0.11, c.x ) ); \n}\n\nvoid mainImage( out vec4 O, in vec2 p )\n{\n    // Thanks Fabrice :)\n    p /= iResolution.x;\n    O -= O;\n    float t = iTime;\n    for (float z = 120.; z > 20.; z -= 20.)      \n        O = mix( vec4(1,.15,.3,0)*(1.2-.8*z/120.),  O, \n                smoothstep( -.01, .01, voronoi( z*.1*p+vec2(30.*t/z, 0), t ).x - 4./z ) );\n    \n//  vec2 p = fragCoord.xy/iResolution.xx;\n//  float v2 = layer2(p+vec2(iTime/30.0, 0), 123.456+iTime / 2.0);\n//  vec3 color = mix(COLOR_0, COLOR_1, v2);\n//  float v1 = layer1(p+vec2(iTime/20.0, 0), iTime / 4.0);\n//  color = mix(color, COLOR_2, v1);\n//  fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 587, 609, 730, 820], [822, 822, 861, 861, 1882], [1884, 1884, 1923, 1923, 2019], [2021, 2021, 2060, 2060, 2157], [2159, 2159, 2200, 2225, 2768]], "test": "valid"}
{"id": "4sGSRV", "name": "Abstract Plane", "author": "Shane", "description": "Using a randomized 3D tile to add some pronounced surfacing to a warped plane.", "tags": ["raymarching", "terrain", "abstract", "plane", "mapping", "environment", "tile"], "likes": 202, "viewed": 11975, "published": "Public API", "date": "1465388127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Abstract Plane\n    --------------\n\n\tPerforming 2nd order distance checks on randomized 3D tiles to add some pronounced \n\tsurfacing to a warped plane... Verbose description aside, it's a pretty simple process. :)\n\n\tI put this example together some time ago, but couldn't afford a reflective pass, so \n\tforgot about it. Anyway, I was looking at XT95's really nice \"UI\" example - plus a \n\tcouple of my own - and realized that a little bit of environment mapping would work \n\tnicely. I'm using a less sophisticated environment mapping function than XT95's, but \n\tit produces the desired effect. \n\t\n    By the way, XT95's is really worth taking a look at. It gives off a vibe of surrounding \n\tarea lights. I tested it on other surfaces and was pretty pleased with the results. The \n\tlink is below.\n\n\tAs for the geometry itself, it's just a variation of 3D repetitive tiling. I colored in\n\tsome of the regions - Greyscale with a splash of color is on page five of the \"Tired Old \n\tCliche Design\" handbook. :) However, I also to wanted to show that it's possible to \n\tidentify certain regions within the tile in a similar way to which it is done with regular \n\tVoronoi.\t\n\n\tOther examples:\n    \n\t// Excellent environment mapping example.\n\tUI easy to integrate - XT95    \n\thttps://www.shadertoy.com/view/ldKSDm\n\n\t// As abstact terrain shaders go, this is my favorite. :)\n\tSomewhere in 1993 - nimitz\n\thttps://www.shadertoy.com/view/Md2XDD\n*/\n\n\n#define FAR 40.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n \n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    \n    // Try this one for a regular, beveled Voronoi looking pattern. It's faster to\n    // hone in on too, which is a bonus.\n    //p = fract(p)-.5;    \n    //return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec3(.5));\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n    \n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    //p = abs(fract(p)-.5);\n    //return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    //return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n\n// The 3D tiling process. I've explained it in the link below, if you're interested in the process.\n//\n// Cellular Tiled Tunnel\n// https://www.shadertoy.com/view/MscSDB\nfloat cellTile(in vec3 p){\n    \n    p /= 5.5;\n    // Draw four overlapping objects at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // First order.\n        \n    return d.x*2.66; // Normalize... roughly.\n    \n}\n\n\nvec3 cellTileColor(in vec3 p){\n    \n    \n    int cellID = 0;\n    \n    p/=5.5;\n    \n    vec3 d = (vec3(.75)); // Set the maximum.\n   \n    \n    // Draw four overlapping shapes using the darken blend \n    // at various positions on the tile.\n    d.z = drawObject(p - vec3(.81, .62, .53)); if(d.z<d.x)cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawObject(p - vec3(.39, .2, .11)); if(d.z<d.x)cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06)); if(d.z<d.x)cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawObject(p - vec3(.2, .82, .64)); if(d.z<d.x)cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n   \n    \n    vec3 col = vec3(.25);//vec3(.7, .8, 1);\n    \n   \n    if (cellID == 3) col = vec3(1, .05, .15);\n    //vec3(.1, .8, .0);//vec3(.4, .7, 1.);//vec3(.8, .4, .2);//vec3(1, .05, .15)//\n    \n    // Extra color, if desired.\n    //if (cellID == 4) col = vec3(.1, .8, .0);//vec3(.5, .4, .35);\n    \n    // Interesting, but probably a little to abstract for this example.\n    //col *= (vec3(clamp(sin(d.x*24.*6.283)*2., 0., 1.)) + .5);\n    \n    return col;\n    \n    \n    \n    //return (1.-sqrt(d.x)*1.33);\n    \n}\n\n\n// Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p){\n    \n    float n = (.5-cellTile(p))*1.5;\n    return p.y + dot(sin(p/2. + cos(p.yzx/2. + 3.14159/2.)), vec3(.5)) + n;\n \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.0;\n    \n    for (int i = 0; i < 96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<0.0025*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d*.7;  // Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the larger than usual sampline distance (epsilon value). It's an old trick to give\n    // rounded edges, and with the right objects it gives a slightly blurred antialiased look.\n    vec2 e = vec2(0.015, -0.015);\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n*/\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy. I used it to do a bit of fake shadowing.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected ray at the surface hit point, then \n// pass it into a 3D function. If you wanted, you could convert the 3D ray coordinates (p) \n// to polar coordinates and index into a repeat texture. It can be pretty convincing (in an \n// abstract way) and allows environment mapping without the need for a cube map, or a \n// reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n   \n    // Some functions work, and others don't. The surface is created with the function\n    // below, so that makes it somewhat believable.\n    float c = cellTile(p*6.);\n    c = smoothstep(0.2, 1., c); // Contract gives it more of a lit look... kind of.\n    \n    return vec3(pow(c, 8.), c*c, c); // Icy glow... for whatever reason. :)\n    // Alternate firey glow.\n    //return vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.));\n\n}\n\n// Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 3.5, iTime*6.);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(0, .25, -.25); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, .75, 2);// Put it a bit in front of the camera.\n\tvec3 lp2 = ro + vec3(0, .75, 9);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\tlp2.xy += path(lp2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.57; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= rot2( path(lk.z).x/64. );\n    \n    /*    \n    // Mouse controls, as per TambakoJaguar's suggestion.\n    // Works better if the line above is commented out.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/ \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n\t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    vec3 sn = getNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        // Texture-based bump mapping.\n\t    sn = texBump(iChannel0, sp*tSize0, sn, 0.01);\n        \n        // Obtaining the texel color. \n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lp-sp;\n\t    vec3 ld2 = lp2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n\t    float lDist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    ld2 /= lDist2;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*0.025);\n\t    float atten2 = 1./(1. +lDist2*lDist2*0.025);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.1;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 8.);\n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\n    \t\n    \t// Darkening the crevices. Otherse known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.5+0.5; //smoothstep(-.05, .1, cellTile(sp));//\n        shading *= smoothstep(-.1, .15, cellTile(sp));\n        \n        \n        // I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        // to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*.5;\n    \n\n        // Combining the above terms to procude the final color.\n        vec3 rCol = cellTileColor(sp)*dot(texCol, vec3(.299, .587, .114));\n        sceneCol += (rCol*(diff + ambience) + vec3(.8, .95, 1)*spec*1.5 + env)*atten;\n        sceneCol += (rCol*(diff2 + ambience) + vec3(.8, .95, 1)*spec2*1.5 + env)*atten2;\n        \n        // Cube mapping, for those who want more believable environment mapping.\n        //vec3 rfCol = texture(iChannel1, reflect(rd, sn)).xyz; // Forest scene.\n        //sceneCol += rfCol*rfCol*.25;\n        \n\n        // Shading.\n        sceneCol *= shading*ao;\n        \n        \n\t\n\t}\n    \n    // Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    // the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    sceneCol = mix(sceneCol, vec3(.0, .003, .01), smoothstep(0., FAR-5., t));\n    \n    \n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1458, 1610, 1631, 1631, 1697], [1702, 1702, 1730, 2069, 2418], [2420, 2589, 2615, 2615, 3364], [3367, 3367, 3397, 3397, 4766], [4769, 4845, 4863, 4863, 4984], [4987, 5020, 5050, 5050, 5321], [5324, 5523, 5550, 5550, 5708], [6156, 6308, 6353, 6353, 6612], [6614, 6680, 6730, 6766, 6960], [6962, 7149, 7209, 7209, 7716], [7718, 8169, 8204, 8204, 8408], [8411, 9098, 9118, 9261, 9549], [9551, 9603, 9625, 9625, 9684], [9686, 9686, 9742, 9768, 14817]], "test": "error"}
{"id": "4sGSWm", "name": "Cellular test  1 (218c)", "author": "aiekick", "description": "modification of shane shader : [url=https://www.shadertoy.com/view/MdKXDD]One Tweet Cellular Pattern[/url]\nbetter in full screen", "tags": ["test", "cellular"], "likes": 2, "viewed": 528, "published": "Public API", "date": "1464970393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/* 218c by FabriceNeyret2 */\n#define f    ( p *= m, v = abs( fract(p/70.) - .5 ) +.1 , min(v.x, v.y) )\n\nvoid mainImage(out vec4 o, vec2 p){\n\t \n    vec2 v = iResolution.xy;\n    p = (p+p-v)/v.y * 1.2;\n       \n    // Used to rotate cells with slight warping.\n    mat2 m = mat2(v=cos(iTime*.2+vec2(0,1.6)),-v.y,v.x)*7.;\n\tp *= m;\n    \n    // Very cheap wrappable cellular tiles.\n    o += min(min(f, f), f)/.6 - o;   \n}\n\n/* original\nfloat f(vec2 p)\n{\n    p = fract(p/70.) - .5;\n    return min(abs(p.x), abs(p.y)) + 0.1;\n}\n\nvoid mainImage(out vec4 o, vec2 p){\n\t \n    p = (p+p-iResolution.xy)/iResolution.y*1.5;\n\n    float c = cos(iTime*.2)*7.0;\n   \tfloat z = sin(iTime*.2)*7.0;\n   \n    // Used to rotate cells with slight warping.\n    mat2 m = mat2(c, -z, z, c);\n    p *= m*m*.8;\n    \n    // Very cheap wrappable cellular tiles.\n    o += min(min(f(p), f(p*m)), f(p*m*m))/.6 - o;\n    \n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 105, 140, 140, 414]], "test": "valid"}
{"id": "4sGXRt", "name": "Automatic Julia Fractal", "author": "Uriopass", "description": "This is a julia fractal visualisator. ", "tags": ["procedural", "2d", "fractal", "julia", "iteration"], "likes": 1, "viewed": 146, "published": "Public", "date": "1465894081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // TO control with mouse, uncomment this line\n\t//vec2 c = vec2(-1.+2.*mouse.x, -1.+2.*mouse.y);\n\t// and comment the next line :\n    vec2 c = cos(time)*vec2(cos(time*2.), sin(time));\n\tvec2 z = 3.*(uv-.5);\n\tfloat iter = 0.0;\n\tconst int max_iter = 150;\n\tfor(int i = 0 ; i < max_iter ; i++)\n\t{\n        z = mat2(z, -z.y, z.x)*z + c;\n\t\tif(dot(z, z) > 4.0)\n\t\t{\n\t\t\titer = float(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tconst float max2 = float(max_iter);\n    fragColor = vec4(0);\n\tif(iter <= max2)\n\t\tfragColor += sqrt(iter/max2)*vec4(0, .3, iter, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 701]], "test": "valid"}
{"id": "4sKSzK", "name": "2D Blob Effect", "author": "daseyb", "description": "https://pay.reddit.com/r/opengl/comments/4n5k1x/need_help_identifying_shader_effect/", "tags": ["sdf"], "likes": 11, "viewed": 291, "published": "Public", "date": "1465409337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////\n// Settings\n////////////////////////\n#define GRADIENT_FALL_OFF 0.02\n#define GRADIENT_MOVEMENT_SPEED 0.0\n#define SOLID_INSIDE true\n#define COLOR_INSIDE vec3(32.0/255.0, 72.0/255.0, 211.0/255.0)\n\nvec3 GET_COLOR(int index) {\n    if(index == 0) {\n    \treturn vec3(32.0/255.0, 72.0/255.0, 211.0/255.0);\n    } else if(index == 1) {\n        return vec3(211.0/255.0, 72.0/255.0, 32.0/255.0);\n    } else {\n        return vec3(32.0/255.0, 211.0/255.0, 72.0/255.0);   \n    }\n}\n\n\n// I recommend http://mercury.sexy/hg_sdf/ for more primitives and operations.\n////////////////////////\n// Utility Methods\n////////////////////////\n\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define PI 3.14159265\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);   \n}\n\nstruct MinPoint {\n    float dist;\n    int matId;\n};\n\n////////////////////////\n// Operations\n////////////////////////\nMinPoint opUnion(MinPoint d1, MinPoint d2) {\n    if(d1.dist < d2.dist)\n        return d1;\n    else\n        return d2;\n}\n\nMinPoint opUnionSoft(MinPoint a, MinPoint b, float r) {\n\tfloat e = max(r - abs(a.dist - b.dist), 0.0);\n    MinPoint res = opUnion(a,b);\n    res.dist = min(a.dist, b.dist) - e*e*0.25/r;\n\treturn res;\n}\n\n\n////////////////////////\n// Primitives\n////////////////////////\nMinPoint sdCircle (vec2 p, vec2 pos, float r, int matId) {\n\treturn MinPoint(length(p - pos) - r, matId);\n}\n\n\n////////////////////////\n// Scene\n////////////////////////\n// EDIT THIS TO CHANGE WHAT'S BEING RENDERED\nMinPoint scene(vec2 p) {\n\n    MinPoint staticD = sdCircle(p, iResolution.xy * vec2(0.4, 0.5), 80.0 + cos(iTime * 10.0) * 4.0, 0);\n    staticD = opUnion(staticD, sdCircle(p, iResolution.xy * vec2(0.6, 0.5), \n                                        40.0 + sin(iTime * 10.0) * cos(2.0 + iTime * 3.0) *4.0, 1));\n    \n    \n    return opUnionSoft(\n                   staticD,\n                   sdCircle(p, iMouse.xy, 40.0, 2), 40.0 + sin(iTime*10.0) * 20.0);\n}\n\n////////////////////////\n// Visualization\n////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n\tvec2 uv = fragCoord.xy;\n    MinPoint minp = scene(uv);\n    float dist = minp.dist;\n    float absDist = abs(dist);\n    vec3 finalColor;\n    \n    \n    vec3 white = vec3(1, 1, 1);\n    vec3 black = vec3(0, 0, 0);\n\n    vec3 colorOutside = mix(white, black,  1.0 - exp(-20.0 * dist * GRADIENT_FALL_OFF));\n    \n    float insideFalloffMultiplier = (sin(iTime*10.0) + 2.0) * 3.0;\n    vec3 colorInside = mix(GET_COLOR(minp.matId), vec3(0, 0, 0),  1.0 - exp(insideFalloffMultiplier * dist * GRADIENT_FALL_OFF)); \n\n    finalColor = dist < 0.0 ? colorInside : colorOutside;\n\n    finalColor = mix(white, finalColor, smoothstep(0.0, 4.0, absDist));\n    \n    finalColor = clamp(finalColor, vec3(0, 0, 0), vec3(1, 1, 1));    \n\n    \n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 219, 246, 246, 490], [493, 699, 719, 719, 747], [802, 866, 910, 910, 985], [987, 987, 1042, 1042, 1186], [1189, 1253, 1311, 1311, 1359], [1362, 1466, 1490, 1490, 1921], [1923, 1990, 2047, 2047, 2806]], "test": "valid"}
{"id": "4sKXRV", "name": "Plane Ellipsoid Distance", "author": "paniq", "description": "computes for a given orthonormal the line offset required to contact an ellipse. The 3D case for planes and ellipsoids works the same.", "tags": ["line", "distance", "plane", "ellipsoid", "ellipse"], "likes": 11, "viewed": 1264, "published": "Public API", "date": "1465443601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\ngeneral strategy for computing plane distances:\n\n1. equate derivative formula for implicit (yielding the normal at `{x y z}`) \n   to `q * plane_normal` where `q` is an unknown scalar.  solve for `{x y z}`\n2. insert coordinates into implicit surface function and solve for `q`\n3. insert coordinates and `q` into plane normal form and solve for `w`\n\n`q * plane_normal` produces a coordinate where the normalized gradient of the\nimplicit surface equals `plane_normal`. this coordinate lies not necessarily\non the surface.\n\nin the case of the ellipsoid, the solution is \n\nq = 2.0 / sqrt(dot(plane_normal^2, ellipsoid_scale^2))\n\nw = 2.0 / q = sqrt(dot(plane_normal^2, ellipsoid_scale^2))\n\n*/\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    float scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n// save current source color, stroke width and starting\n// point from active context.\nContext save();\n// restore source color, stroke width and starting point\n// to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    ScreenH = min(iResolution.x,iResolution.y);\n    AA = ScreenH*0.4;\n    AAINV = 1.0 / AA;\n\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n    \n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        1.0,\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;    \n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;    \n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);    \n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape.x * 6.0, \n            1.0, (_stack.shape.x>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;    \n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA, 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);    \n\treturn wa * wb; //min(wa,wb);    \n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nfloat get_gradient_eps() {\n    return _stack.scale/AA;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o += s;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    add_field(max(dmin.xz, dmin.yw) + length2(dmax));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add_field(length2(pa - ba.xyxy*h.xxyy));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis; // * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    add_field(vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw)));\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\n#define PI 3.1415927\n\nvec2 ClosestPointOnEllipse(vec2 p, vec2 ab)\n{\n\t//focal point of ellipse - either on x axis if a>b or y otherwise\n\tfloat c = ab.x > ab.y ? sqrt(ab.x*ab.x - ab.y*ab.y) : sqrt(ab.y*ab.y - ab.x*ab.x);\n\n\tfloat t = 0.;\n\tif (ab.y < ab.x && abs(p.x) < c)\n\t{\n\t\tt = p.y > 0. ? 0. * PI : -0.5 * PI;\n\t}\n\telse if (ab.x < ab.y && abs(p.y) < c)\n\t{\n\t\tt = p.x > 0. ? 0. : -PI;\n\t}\n\telse\n\t{\n\t\tt = atan(ab.x*p.y,ab.y*p.x);\n\t}\n\n\tfloat aa_bb = ab.x * ab.x - ab.y * ab.y;\n\tvec2 pab = p*ab;\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tfloat sint = sin(t);\n\t\tfloat cost = cos(t);\n\t\tfloat ft = aa_bb * cost * sint - pab.x * sint + pab.y * cost;\n\t\tfloat dft = aa_bb * (cost * cost - sint * sint) - pab.x * cost - pab.y * sint;\n\n\t\tt = t - ft/dft;\n\t}\n\n\treturn vec2(cos(t),sin(t))*ab;\n}\n\nfloat sdEllipse(vec2 p, vec2 ab)\n{\n\tab = abs(ab);\n    p = -abs(p);\n\tvec2 closest = ClosestPointOnEllipse(p, ab);\n\n\tfloat dist = length(closest-p);\n\n\tvec2 poverab = p/ab;\n\tfloat inouttest = dot(poverab,poverab);\n\n\tif (inouttest < 1.) dist = -dist;\n\treturn dist;\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy,r),sdEllipse(c.zw,r)));\n}\n\nvoid ellipse(float x, float y, float w, float h) { ellipse(vec2(x,y),vec2(w,h)); }\n\nvoid plane(vec3 q) {\n    vec4 c = _stack.position;\n    \n    add_field(vec2(dot(vec3(c.xy,1.0),q), dot(vec3(c.zw,1.0),q)));\n}\n\nvoid paint() {\n    float t = iTime;\n    \n    // clear screen\n    \n    set_source_rgb(vec3(0.0,0.0,0.5));\n    clear();\n\n    // normal\n    vec2 n = vec2(cos(t),sin(t));\n    \n    // ellipse scaling\n    vec2 s = vec2(0.8 - 0.7 * abs(cos(t * 0.2)), 0.5 - 0.4 * abs(sin(t * 0.2)));\n    // computing normal scalar\n    float q = 2.0 / sqrt(dot(n * n, s * s));\n    \n    // computing point on ellipse from normal\n    float w = sqrt(dot(n * n, s * s));\n    \n    // change point of reference so it looks like\n    // the ellipse is a tumbling egg\n    translate(0.0, w - 0.5);\n    rotate(-t+1.571);\n    \n    // fill ellipse\n    ellipse(vec2(0.0), s);\n    bool in_circle = in_fill();\n    set_source_rgb(hsl(0.0, 1.0, in_circle?0.7:0.5));\n    fill_preserve(); // don't reset shape    \n    set_source_rgb(vec3(1.0));\n    set_line_width(0.01);\n   \tstroke();\n    move_to(vec2(0.0));\n    line_to(vec2(s.x,0.0));\n    //line_to(n * 2.0 / q);\n    stroke();\n    \n    plane(vec3(n, w));\n    set_source_rgba(hsl(0.0, 1.0, 0.2, 0.3));\n    fill_preserve();\n    set_source_rgb(vec3(1.0));\n    stroke();\n    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5799, 5859, 5886, 5886, 5912], [5914, 5974, 5995, 5995, 6104], [6106, 6106, 6143, 6143, 6229], [6231, 6231, 6277, 6277, 6310], [6312, 6420, 6448, 6448, 6996], [7024, 7024, 7043, 7043, 7076], [7078, 7078, 7096, 7096, 7129], [7131, 7131, 7155, 7155, 7223], [7225, 7225, 7241, 7241, 7262], [7264, 7264, 7291, 7313, 7394], [7396, 7396, 7424, 7424, 7658], [7660, 7660, 7684, 7684, 7764], [7766, 7766, 7793, 7793, 7999], [8001, 8001, 8027, 8027, 8261], [8263, 8263, 8285, 8285, 8411], [8413, 8413, 8434, 8434, 8490], [8492, 8492, 8516, 8516, 8576], [8578, 8578, 8612, 8612, 8636], [8638, 8638, 8652, 8652, 8716], [8718, 8718, 8744, 8744, 8776], [8778, 8778, 8804, 8804, 8825], [8827, 8827, 8851, 8851, 8924], [8926, 8926, 8951, 8951, 8998], [9000, 9000, 9017, 9017, 9061], [9063, 9063, 9086, 9086, 9213], [9215, 9215, 9239, 9239, 9379], [9381, 9381, 9419, 9419, 9557], [9559, 9559, 9596, 9596, 9631], [9633, 9633, 9662, 9662, 9842], [9844, 9844, 9866, 9866, 9930], [9932, 9932, 9945, 9945, 9984], [9986, 9986, 10016, 10016, 10045], [10047, 10047, 10080, 10080, 10125], [10127, 10127, 10153, 10153, 10183], [10185, 10185, 10206, 10206, 10271], [10273, 10273, 10297, 10297, 10380], [10382, 10382, 10397, 10397, 10438], [10440, 10440, 10456, 10456, 10494], [10496, 10496, 10514, 10514, 10571], [10573, 10573, 10603, 10603, 10628], [10630, 10630, 10688, 10688, 10727], [10729, 10729, 10758, 10758, 10794], [10796, 10796, 10844, 10844, 10875], [10877, 10877, 10911, 10911, 10970], [10972, 10972, 10994, 10994, 11040], [11042, 11042, 11069, 11069, 11113], [11115, 11115, 11147, 11147, 11336], [11338, 11338, 11394, 11394, 11437], [11439, 11439, 11469, 11469, 11562], [11563, 11563, 11603, 11603, 11626], [11628, 11628, 11650, 11650, 11701], [11703, 11703, 11735, 11735, 11757], [11759, 11774, 11796, 11796, 12014], [12016, 12016, 12048, 12048, 12070], [12072, 12072, 12091, 12091, 12123], [12172, 12206, 12252, 12252, 12765], [12767, 12836, 12882, 12882, 13402], [13404, 13404, 13437, 13437, 13603], [13605, 13605, 13664, 13664, 13709], [13711, 13711, 13754, 13754, 13815], [13817, 13817, 13859, 13859, 13901], [13903, 14009, 14054, 14121, 14751], [14753, 14753, 14787, 14787, 15015], [15017, 15017, 15047, 15047, 15146], [15148, 15148, 15198, 15198, 15230], [15232, 15232, 15252, 15252, 15356], [15358, 15358, 15372, 15372, 16438], [16440, 16500, 16557, 16557, 16624]], "test": "error"}
{"id": "4sKXRy", "name": "Sun With Small Sunspots", "author": "somesuch", "description": "My modification of https://www.shadertoy.com/view/MtXSzS  by Duke ", "tags": ["sun"], "likes": 4, "viewed": 200, "published": "Public", "date": "1465069614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// my -somesuch- modification of https://www.shadertoy.com/view/MtXSzS \n// port from http://glslsandbox.com/e#8625.0 by Duke \n// Fireball\n// Awd\n// @AlexWDunn\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n// Quality Settings\n#define MarchSteps 8\n// Scene Settings\n#define ExpPosition vec3(0.0)\n#define Radius 2.0\n#define Background vec4(0.1, 0.0, 0.0, 1.0)\n// Noise Settings\n#define NoiseSteps 1\n#define NoiseAmplitude 0.05\n#define NoiseFrequency 12.0\n#define Animation vec3(0.0, -3.0, 0.5)\n// Colour Gradient\n#define Color1 vec4(1.0, 1.0, 1.0, 1.0)\n#define Color2 vec4(1.0, 0.8, 0.2, 1.0)\n#define Color3 vec4(1.0, 0.03, 0.0, 1.0)\n#define Color4 vec4(0.05, 0.02, 0.02, 1.0)\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n\tfor(int i=NoiseSteps ; i>=0 ; i--)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\t\tfOut *= 2.0;\n\t\tvalue += abs(snoise(position * fOut))/fOut;\n\t}\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\tvalue += fade * abs(snoise(position * fOut))/fOut;\n\treturn 1.0-value;\n}\n\nfloat SphereDist(vec3 position)\n{\n\treturn length(position - ExpPosition) - Radius;\n}\n\nvec4 Shade(float distance)\n{\n\tfloat c1 = saturate(distance*5.0 + 0.5);\n\tfloat c2 = saturate(distance*5.0);\n\tfloat c3 = saturate(distance*3.4 - 0.5);\n\tvec4 a = mix(Color1,Color2, c1);\n\tvec4 b = mix(a,     Color3, c2);\n\treturn \t mix(b,     Color4, c3);\n}\n\n// Draws the scene\nfloat RenderScene(vec3 position, out float distance)\n{\n\tfloat noise = Turbulence(position * NoiseFrequency + Animation*iTime, 0.1, 1.5, 0.03) * NoiseAmplitude;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\treturn noise;\n}\n\n\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n\tvec3 relDistance = (ro - pos);\n\tfloat b = dot(relDistance, rd);\n\tfloat c = dot(relDistance, relDistance) - radius*radius;\n\tfloat d = b*b - c;\n\tintersectPoint = ro + rd*(-b - sqrt(d));\n\treturn d >= 0.0;\n}\n\n// Basic ray marching method.\nvec4 March(vec3 rayOrigin, vec3 rayStep)\n{\n\tvec3 position = rayOrigin;\n\tfloat distance;\n\tfloat displacement;\n\tfor(int step = MarchSteps; step >=0  ; --step)\n\t{\n\t\tdisplacement = RenderScene(position, distance);\n\t\tif(distance < 0.05) break;\n\t\tposition += rayStep * distance;\n\t}\n\treturn mix(Shade(displacement), Background, float(distance >= 0.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tp.x *= iResolution.x/iResolution.y;\n\tfloat rotx = iMouse.y * 0.01;\n\tfloat roty = -iMouse.x * 0.01;\n\tfloat zoom = 5.0;\n\t// camera\n\tvec3 ro = zoom * normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n\tvec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n\tvec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\tvec4 col = Background;\n\tvec3 origin;\n\tif(IntersectSphere(ro, rd, ExpPosition, Radius + NoiseAmplitude*6.0, origin))\n\t{\n\t\tcol = March(origin, rd);\n\t}\n\tfragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[716, 1105, 1126, 1126, 1173], [1174, 1174, 1195, 1195, 1242], [1243, 1243, 1265, 1265, 1300], [1301, 1301, 1328, 1328, 1378], [1380, 1380, 1402, 1402, 3180], [3182, 3182, 3259, 3259, 3627], [3629, 3629, 3662, 3662, 3713], [3715, 3715, 3743, 3743, 3967], [3969, 3988, 4042, 4042, 4237], [4240, 4240, 4329, 4329, 4534], [4536, 4566, 4608, 4608, 4913], [4916, 4916, 4973, 4973, 5587]], "test": "valid"}
{"id": "4sKXWG", "name": "KaliTrace", "author": "bergi", "description": "Quite happy with speed and look :)", "tags": ["3d", "fractal", "kaliset", "environment", "bumpmap"], "likes": 10, "viewed": 695, "published": "Public API", "date": "1466408051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** KaliTrace\n\thttps://www.shadertoy.com/view/4sKXWG\n\n\t(cc) 2016, stefan berke\n\n\tAnother attempt to ray-march the kali-set. \n\tQuite happy this time, not so much artefacts and good framerate. \n\t\n\tIt's quite inspired by Shane's general visual style,\n\tespecially bump-mapping and evironment-mapping.\n\tBoth drawn from the kaliset as well.\n\t\n\n*/\n\n\n// minimum distance to axis-aligned planes in kali-space\n// uses eiffie's mod (/p.w) https://www.shadertoy.com/view/XtlGRj\n// to keep the result close to a true distance function\nvec3 kali_set(in vec3 pos, in vec3 param)\n{\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        d = min(d, p.xyz/p.w);\n        p.xyz -= param;\n    }\n    return d;\n}\n\n\nfloat DE(in vec3 p, in vec3 param)\n{\n    // floor and ceiling\n    float d = min(p.y, -p.y+.2);\n\n    // displaced by kaliset\n\td -= kali_set(p*vec3(1,2,1), param).x;\n    \n    return d;\n}\n\nvec3 DE_norm(in vec3 p, in vec3 param)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(\n        DE(p+e.xyy, param) - DE(p-e.xyy, param),\n        DE(p+e.yxy, param) - DE(p-e.yxy, param),\n        DE(p+e.yyx, param) - DE(p-e.yyx, param)));\n}\n\n\nconst float max_t = 1.;\n\n// common sphere tracing\n// note the check against abs(d) to get closer to surface\n// in case of overstepping\nfloat trace(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float t = 0.001, d = max_t;\n    for (int i=0; i<50; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE(p, param);\n        if (abs(d) <= 0.0001 || t >= max_t)\n            break;\n        t += d * .5; // above kali-distance still needs a lot of fudging\n    }\n    return t;\n}\n\n// \"Enhanced Sphere Tracing\"\n// Benjamin Keinert(1) Henry SchÃ¤fer(1) Johann KorndÃ¶rfer Urs Ganse(2) Marc Stamminger(1)\n// 1 University of Erlangen-Nuremberg, 2 University of Helsinki\n// \n// It was a try... disabled by default (see rayColor() below)\n// Obviously the algorithm does not like \"fudging\" which is needed for my distance field..\n// It renders more stuff close to edges but creates a lot of artifacts elsewhere\nfloat trace_enhanced(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float omega = 1.2; // overstepping\n    float t = 0.001;\n    float candidate_error = 100000.;\n    float candidate_t = t;\n    float previousRadius = 0.;\n    float stepLength = .0;\n    float signedRadius;\n    float pixelRadius = .012;\n    float fudge = 0.6;\n    for (int i = 0; i < 50; ++i) \n    {\n        signedRadius = DE(rd*t + ro, param);\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. && (radius + previousRadius) < stepLength;\n        if (sorFail) \n        {\n        \tstepLength -= omega * stepLength;\n        \tomega = 1.;\n        } \n        else \n        {\n        \tstepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) \n        {\n        \tcandidate_t = t;\n        \tcandidate_error = error;\n    \t}\n    \tif (!sorFail && error < pixelRadius || t > max_t)\n    \t\tbreak;\n    \tt += stepLength * fudge;\n    }\n    return (t > max_t || candidate_error > pixelRadius)\n        ? max_t : candidate_t;\n}\n\n// common ambient occlusion\nfloat traceAO(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float a = 0., t = 0.01;\n    for (int i=0; i<5; ++i)\n    {\n        float d = DE(ro+t*rd, param);\n        a += d / t;\n        t += d;\n    }\n    return min(1., a / 5.);\n}\n\n// environment map, also drawn from kaliset\nvec3 skyColor(in vec3 rd)\n{\n    //vec3 par = vec3(0.075, 0.565, .03);\n    vec3 par = vec3(1.2, 1.01, .71);\n    \n    vec3 c = kali_set(rd*2., par);\n    c = vec3(.9*c.x,.7,1.)*pow(vec3(c.x),vec3(.7,.5,.5));\n    \n    return clamp(c, 0., 1.);\n}\n\n// trace and color\nvec3 rayColor(in vec3 ro, in vec3 rd)\n{\n    // magic params for kali-set\n    vec3 par1 = vec3(1.),\t\t\t\t// scene geometry \n         par2 = vec3(.63, .55, .73);\t// normal/bump map\n    \n#if 1\n    float t = trace(ro, rd, par1);\n#else    \n    float t = trace_enhanced(ro, rd, par1);\n#endif    \n    vec3 p = ro + t * rd;\n    float d = DE(p, par1);\n    \n    vec3 col = vec3(0.);\n\n    // did ray hit?\n    if (d < 0.03) \n    // note, we always find a surface in this scene except for rays parallel to the \n\t// two enclosing planes. The 0.03 is quite large, just to remove the blackness\n    // close to edges\n    {\n        // surface normal\n        vec3 n = DE_norm(p, par1);\n        // normal displacement\n        n = normalize(n + min(p.y+0.05,.14)*DE_norm(p+.1*n, par2));\n        n = normalize(n + 0.04*DE_norm(sin(p*30.+n*10.), par2)); // micro-bumps\n        // reflected ray\n        vec3 rrd = reflect(rd,n);\n\t\t// normal towards light\n        vec3 ln = normalize(vec3(0.7,0.2,0) - p);\n\t\t// 1. - occlusion\n        float ao = traceAO(p, n, par1);\n        // surface color\n        vec3 surf = .1*mix(vec3(1,1.4,1), vec3(3,3,3), ao);\n\n        // lighting\n        surf += .25 * ao * max(0., dot(n, ln));\n        float d = max(0., dot(rrd, ln));\n        surf += ao * (.5 * d + .7 * pow(d, 8.));\n\n        // environment map\n        surf += .5 * ao * skyColor(rrd);\n    \n        // distance fog\n    \tcol = surf * (1.-t / max_t);\n    }\n    \n    return col;\n}\n\n// camera path\nvec3 path(in float ti)\n{\n    ti /= 7.;\n    vec3 p = vec3(sin(ti)*.5+.5, \n                  .05+.03*sin(ti*3.16), \n                  -.5*cos(ti));\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n        \n    float ti = iTime+23.;\n    \n    vec3 ro = path(ti);\n    vec3 look = path(ti+1.+.5*sin(ti/2.3))+vec3(0,.02+.03*sin(ti/5.3),0);\n    float turn = sin(ti/6.1); \n        \n    // lazily copied from Shane\n    // (except the hacky turn param)\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(look-ro);\n    vec3 rgt = normalize(vec3(fwd.z, turn, -fwd.x));\n    vec3 up = cross(fwd, rgt);\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    \n    \n    //vec3 col = kali_set(vec3(uv, 0.), vec3(1.));\n    vec3 col = rayColor(ro, rd);\n    //col = skyColor(rd);\n    \n    \n    col *= pow(1.-dot(suv-.5,suv-.5)/.5, .6);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 522, 565, 565, 768], [771, 771, 807, 832, 955], [957, 957, 997, 997, 1206], [1234, 1344, 1396, 1396, 1677], [1679, 2106, 2167, 2167, 3202], [3204, 3232, 3286, 3286, 3458], [3460, 3504, 3531, 3573, 3744], [3746, 3765, 3804, 3837, 5208], [5210, 5225, 5249, 5249, 5386], [5388, 5388, 5445, 5445, 6244]], "test": "valid"}
{"id": "4sVSRd", "name": "POV-Ray tilings", "author": "bergi", "description": "Tiling functions from the popular [url]http://povray.org[/url] raytracer. ", "tags": ["pattern", "tiling", "hexagonal", "povray"], "likes": 33, "viewed": 1039, "published": "Public API", "date": "1466076000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Povray tiling & pavement functions \n   License aGPLv3 \n\n   Original code by J. Gimbert\n   See https://github.com/POV-Ray/povray/blob/master/source/core/material/pattern.cpp\n\n   Lazily converted to GLSL by S. Berke\n\n   The pattern.cpp is a useful resource for all kinds of 2d effects and part of the\n   reason for povray's popularity - in the old days, at least ;)\n   I only adjusted the function return values for the tiling functions,\n   everything else is kept as-is. There are much more tilings in the original source \n   but they will be harder to convert to GLSL ES due to the lack of arrays. \n\n   original copyright notice: \n */\n/// Persistence of Vision Ray Tracer ('POV-Ray') version 3.7.\n/// Copyright 1991-2016 Persistence of Vision Raytracer Pty. Ltd.\n///\n/// POV-Ray is free software: you can redistribute it and/or modify\n/// it under the terms of the GNU Affero General Public License as\n/// published by the Free Software Foundation, either version 3 of the\n/// License, or (at your option) any later version.\n///\n/// POV-Ray is distributed in the hope that it will be useful,\n/// but WITHOUT ANY WARRANTY; without even the implied warranty of\n/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n/// GNU Affero General Public License for more details.\n///\n/// You should have received a copy of the GNU Affero General Public License\n/// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n///\n/// ----------------------------------------------------------------------------\n///\n/// POV-Ray is based on the popular DKB raytracer version 2.12.\n/// DKBTrace was originally written by David K. Buck.\n/// DKBTrace Ver 2.0-2.12 were written by David K. Buck & Aaron A. Collins.\n  \n\n\n/* ----- Interface -----\n\n   pov_tiling*() functions return\n     x: distance to inside, outside = 1.\n     y: shape index 0-2 (when there are different shapes in one pattern)\n*/\n\nvec2 pov_tiling_square(in vec2 p);\nvec2 pov_tiling_square_offset(in vec2 p);\nvec2 pov_tiling_hexagon(in vec2 p);\nvec2 pov_tiling_triangle(in vec2 p);\nvec2 pov_tiling_lozenge(in vec2 p);\nvec2 pov_tiling_rhombus(in vec2 p);\nvec2 pov_tiling_rectangle(in vec2 p);\nvec2 pov_tiling_octa_square(in vec2 p);\nvec2 pov_tiling_square_triangle(in vec2 p);\nvec2 pov_tiling_hexa_triangle(in vec2 p);\n\n/* One function to get all, pattern = 0-9 */\nvec2 pov_tiling(in vec2 p, in int pattern)\n{\n\tif (pattern == 0) return pov_tiling_square(p);\n\tif (pattern == 1) return pov_tiling_square_offset(p);\n\tif (pattern == 2) return pov_tiling_hexagon(p);\n\tif (pattern == 3) return pov_tiling_triangle(p);\n\tif (pattern == 4) return pov_tiling_lozenge(p);\n\tif (pattern == 5) return pov_tiling_rhombus(p);\n\tif (pattern == 6) return pov_tiling_rectangle(p);\n\tif (pattern == 7) return pov_tiling_octa_square(p);\n\tif (pattern == 8) return pov_tiling_square_triangle(p);\n\tif (pattern == 9) return pov_tiling_hexa_triangle(p);\n\treturn vec2(-1, 0.);\n}\n\n\n// ########################## IMPLEMENTATION ###########################\n\n#define POV_SQRT3_2     0.86602540378443864676372317075294  ///< sqrt(3)/2\n#define POV_SQRT3       1.7320508075688772935274463415059   ///< sqrt(3)\n#define POV_SQRT2       1.4142135623730950488016887242097   ///< sqrt(2)\n#define POV_SQRT2_2     0.70710678118654752440084436210485  ///< sqrt(2)/2\n\nvec2 pov_tiling_square(in vec2 p)\n{\n    p = abs(p);\n\tvec2 x = p - floor(p);\n\tx = 2. * abs(x - .5);\n\treturn vec2(max(x.x, x.y), 0.);\n}\n\nvec2 pov_tiling_hexagon(in vec2 p)\n{\n\tvec2 x = p;\n\tx.x += 0.5;\n\tx.x -= 3.0*floor(x.x/3.0);\n\tx.y -= POV_SQRT3*floor(x.y/POV_SQRT3);\n\t/* x,z is in { [0.0, 3.0 [, [0.0, SQRT3 [ } \n\t ** but there is some symmetry to simplify the testing\n\t */\n\tif (x.y > POV_SQRT3_2)\n\t\tx.y = POV_SQRT3 - x.y;\n\t/* \n\t ** Now only [0,3[,[0,SQRT3/2[\n\t */\n\tif (x.x > 1.5)\n\t{\n\t\tx.x -= 1.5; /* translate */\n\t\tx.y = POV_SQRT3_2 - x.y; /* mirror */\n\t}\n\t/*\n\t ** And now, it is even simpler :  [0,1.5],[0,SQRT3/2]\n\t ** on the bottom left corner, part of some other hexagon\n\t ** on the top right corner, center of the hexagon\n\t */\n\tif ((POV_SQRT3*x.x + x.y) < POV_SQRT3_2)\n\t{\n\t\tx.x = 0.5 - x.x;\n\t\tx.y = POV_SQRT3_2 - x.y; /* mirror */\n\t}\n\tif (x.x > 1.0)\n\t{\n\t\tx.x = 2.0 - x.x; /* mirror */\n\t}\n\t/* Hexagon */\n\treturn vec2(clamp(\n\t\t\t\tmax(1. - x.y / POV_SQRT3_2,\n                    1. - ((POV_SQRT3 * x.x + x.y - POV_SQRT3_2) / POV_SQRT3)\n\t\t\t\t), 0., 1.), 0.);\n}\n\nvec2 pov_tiling_triangle(in vec2 p)\n{\n\tvec2 x = p;\n\tx.x -= floor(x.x);\n\tx.y -= POV_SQRT3 * floor(x.y/POV_SQRT3);\n\tfloat delta = 0.;\n\t/* x,z is in { [0.0, 1.0 [, [0.0, SQRT3 [ } \n\t ** but there is some symmetry to simplify the testing\n\t */\n\tif (x.y > POV_SQRT3_2)\n\t{\n\t\tx.y = POV_SQRT3 - x.y; /* mirror */\n\t\tdelta = 1.-delta;\n\t}\n\tif (x.x > 0.5)\n\t{\n\t\tx.x = 1.0 - x.x; /* mirror */\n\t}\n\tif (x.x != 0.0)\n\t{\n\t\tfloat slop1 = x.y / x.x;\n\t\tif (slop1 > POV_SQRT3)\n\t\t{\n\t\t\tx.y = POV_SQRT3_2 - x.y;\n\t\t\tx.x = 0.5 - x.x;\n\t\t\tdelta = 1.-delta;\n\t\t}\n\t}\n\telse\n\t{\n\t\tx.y = POV_SQRT3_2 - x.y;\n\t\tx.x = 0.5;\n\t}\n\tfloat d1 = 1. - (x.y * 2. * POV_SQRT3);\n\tfloat d2 = 1. - ((POV_SQRT3 * x.x - x.y) * POV_SQRT3);\n\treturn vec2(max(d1, d2), delta);\n//\treturn delta>.5 ? max(d1, d2)*.5 : 1.-.5*max(d1, d2); \n\t// XXX original, not sure if this is right??\n\t//return delta*.5 + .5 * max(d1, d2);\n}\n\nvec2 pov_tiling_lozenge(in vec2 p)\n{\n\tvec2 x = p;\n\tx.x -= floor(x.x);\n\tx.y -= POV_SQRT3*floor(x.y/POV_SQRT3);\n\t/* x,z is in { [0.0, 1.0 [, [0.0, SQRT3 [ } \n\t ** There is some mirror to reduce the problem\n\t */\n\tif (x.y > POV_SQRT3_2)\n\t{\n\t\tx.y -= POV_SQRT3_2;\n\t\tx.x += 0.5;\n\t}\n\tif ((2.*x.y) > POV_SQRT3_2)\n\t{\n\t\tx.y = POV_SQRT3_2 - x.y;\n\t\tx.x = 1.5 - x.x;\n\t}\n\tif (x.x > 0.75)\n\t{\n\t\tx.x -= 1.0;\n\t}\n\tif (x.x != 0.0)\n\t{\n\t\tfloat slop1 = x.y / x.y;\n\t\tif (slop1 > POV_SQRT3)\n\t\t{\n\t\t\tx.y = POV_SQRT3_2 - x.y;\n\t\t\tx.x = 0.5 - x.x;\n\t\t}\n\t}\n\tfloat d1 = 1.0 - (x.y * 4.0 * POV_SQRT3 / 3.0 );\n\tfloat d2 = 1.0 - (abs(POV_SQRT3 * x.x - x.y) * POV_SQRT3 * 2.0 / 3.0);\n\treturn vec2(max(d1, d2), 0.);\n}\n\nvec2 pov_tiling_rhombus(in vec2 p)\n{\n\tfloat x = p.x, z = p.y, delta = 0.;\n\tx += 0.5;\n\tx -= 3.0*floor(x/3.0);\n\tz -= POV_SQRT3*floor(z/POV_SQRT3);\n\t/* x,z is in { [0.0, 3.0 [, [0.0, SQRT3 [ } \n\t ** There is some mirror to reduce the problem\n\t */\n\tif ( z > POV_SQRT3_2 )\n\t{\n\t\tz = POV_SQRT3 -z; /* mirror */\n\t\tdelta = 2. - delta;\n\t}\n\tif (x > 1.5)\n\t{\n\t\tx -= 1.5 ; /* translate */\n\t\tz = POV_SQRT3_2 -z; /* mirror */\n\t\tdelta = 2. - delta;\n\t}\n\t/* Now in [0,1.5],[0,SQRT3/2] \n\t ** from left to right\n\t ** part of a horizontal (z=0)\n\t ** half a vertical \n\t ** part of a horizontal \n\t */\n\tif (x < 0.5)\n\t{\n\t\t/* mirrror */\n\t\tx = 1.0 - x;\n\t\tdelta = 2. - delta;\n\t}\n\t/* \n\t ** Let shift the [0.5,1.5],[0,SQRT3/2] to [0,1]....\n\t */\n\tx -= 0.5;\n\tif (x != 0.0)\n\t{\n\t\tfloat slop1 = z/x;\n\t\tif (slop1>POV_SQRT3)\n\t\t{ /* rotate the vertical to match the horizontal on the right */\n\t\t\tfloat dist1 = ( x / 2.0 ) + ( z * POV_SQRT3_2 );\n\t\t\tfloat dist2 = ( z / 2.0 ) - ( x * POV_SQRT3_2 );\n\t\t\tz = dist2;\n\t\t\tx = dist1;\n\t\t\tdelta = 1.;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* rotate the vertical to match the horizontal on the right */\n\t\tfloat dist1 = ( x / 2.0 ) + ( z * POV_SQRT3_2 );\n\t\tfloat dist2 = ( z / 2.0 ) - ( x * POV_SQRT3_2 );\n\t\tz = dist2;\n\t\tx = dist1;\n\t\tdelta = 1.;\n\t}\n\t/* It may be similar to lozenge (in fact, IT IS !), now */\n\n\tif ( (2.0*z) > POV_SQRT3_2 )\n\t{\n\t\tz = POV_SQRT3_2 - z;\n\t\tx = 1.5 - x;\n\t}\n\tif (x > 0.75)\n\t{\n\t\tx -= 1.0;\n\t}\n\tif (x != 0.0)\n\t{\n\t\tfloat slop1 = z / x;\n\t\tif (slop1 > POV_SQRT3)\n\t\t{\n\t\t\tz = POV_SQRT3_2 - z;\n\t\t\tx = 0.5 -x;\n\t\t}\n\t}\n\tfloat d1 = 1.0 - (z * 4.0 * POV_SQRT3 / 3.0 );\n\tfloat d2 = 1.0 - (abs(POV_SQRT3 * x - z) * POV_SQRT3 *2.0 / 3.0);\n\treturn vec2(clamp(max(d1, d2), 0., 1.), delta);\n\t// original\n\t//return clamp( (max(d1, d2) + delta) / 3., 0., 1.);\n}\n\nvec2 pov_tiling_rectangle(in vec2 po)\n{\n\t/*\n\t ** Tiling with rectangles\n\t ** resolve to square [0,4][0,4]\n\t ** then 16 cases\n\t **\n\t **  +-----+--+  +\n\t **  |     |  |  |\n\t **  +--+--+  +--+\n\t **     |  |  |\n\t **  +--+  +--+--+\n\t **  |  |  |     |\n\t **  +  +--+--+--+\n\t **  |  |     |  |\n\t **  +--+-----+  +\n\t */\n\tfloat x = po.x, z = po.y, \n\t\t  delta = 1.;\n\tx -= 4.0*floor(x/4.0);\n\tz -= 4.0*floor(z/4.0);\n    int idx = int(x) + 4*int(z);\n\tif (idx == 0 || idx == 4)\n\t\tz -= 1.0;\n    if (idx == 1 || idx == 2)\n\t\tx -= 2.0, delta = 0.0;\n\tif (idx == 3)\n\t\tx -= 3.0;\n\tif (idx == 5 || idx == 9)\n\t\tx -= 1.0, z -= 2.0;\n\tif (idx == 6 || idx == 7)\n\t\tx -= 3.0, z -= 1.0, delta = 0.0;\n    if (idx == 8)\n\t\tz -= 2.0, delta = 0.0;\n\tif (idx == 10 || idx == 14)\n\t\tx -= 2.0, z -= 3.0;\n\tif (idx == 11)\n\t\tx -= 4.0, z -= 2.0, delta = 0.0;\n\tif (idx == 12 || idx == 13)\n\t\tx -= 1.0, z -= 3.0, delta = 0.0;\n\tif (idx == 15)\n\t\tx -= 3.0, z -= 4.0;\n\n    if (delta >= 1.0)\n\t{\n\t\tx = 2.*abs(x - 0.5);\n\t\tz = 2.*(max(abs(z), 0.5) - 0.5);\n\t}\n\telse\n\t{\n\t\tx = 2.*(max(abs(x), 0.5) - 0.5);\n\t\tz = 2.*abs(z - 0.5);\n\t}\n\treturn vec2(max(x, z), delta);\n//\treturn delta>.5 ? max(x, z)*.5 : 1.-.5*max(x, z); \n\t// XXX original\n//\treturn abs(max(x, z) + delta) / 2.;\n}\n\n\nvec2 pov_tiling_octa_square (in vec2 p)\n{\n\t/*\n\t ** Tiling with a square and an octagon\n\t */\n\tvec2 x = p;\n\tx -= (POV_SQRT2+1.0) * floor(x/(POV_SQRT2+1.0));\n\tx -= POV_SQRT2_2 + 0.5;\n\tx = abs(x);\n\tif (x.y > x.x)\n\t\tx = x.yx;\n\tif ((x.x+x.y) < POV_SQRT2_2)\n\t{\n\t\t/* Square tile */\n\t\treturn vec2((x.x+x.y) / POV_SQRT2, 0.);\n\t}\n\tfloat dist1 = 1.0-x.y;\n\tfloat dist2 = (POV_SQRT2 + POV_SQRT2_2-(x.x+x.y))/POV_SQRT2;\n\treturn vec2(max(0., 0.19+.81*max(dist1,dist2)), 1.); \n}\n\nvec2 pov_tiling_square_triangle(in vec2 p)\n{\n\tfloat x = p.x, z = p.y, delta = 0.;\n\tx -= floor(x);\n\tz -= (2.0+POV_SQRT3)*floor(z/(POV_SQRT3+2.0));\n\t/* x,z is in { [0.0, 1.0 [, [0.0, 2+SQRT3 [ } \n\t ** but there is some symmetry to simplify the testing\n\t */\n\tif (z > POV_SQRT3_2+1.0 )\n\t{\n\t\tz -= POV_SQRT3_2+1.0;\n\t\tx += (x>0.5)?-0.5:0.5;\n\t}\n\tif (x > 0.5)\n\t{\n\t\tx = 1.0 - x; /* mirror */\n\t}\n\tz -= 1.0;\n\tif (z > 0.0)\n\t{ /* triangle */\n\t\tif (x != 0.0)\n\t\t{\n\t\t\tif (z/x > POV_SQRT3)\n\t\t\t{\n\t\t\t\tz = POV_SQRT3_2 - z;\n\t\t\t\tx = 0.5 - x;\n\t\t\t\tdelta = 1. - delta;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tz = POV_SQRT3_2 - z;\n\t\t\tx = 0.5;\n\t\t\tdelta = 1. - delta;\n\t\t}\n\t\tfloat dist1 = 1.0 - (2. * z * POV_SQRT3);\n\t\tfloat dist2 = 1.0 - ((POV_SQRT3 * x - z) * POV_SQRT3);\n\t\treturn vec2(max(dist1, dist2), delta);\n\t}\n\telse\n\t{ /* square */\n\t\tif (z < -0.5)\n\t\t{\n\t\t\tz = -1.0 - z;\n\t\t}\n\t\tif (x > 0.5)\n\t\t{\n\t\t\tx = 1.0 - x;\n\t\t}\n\t\treturn vec2((1.000000-2.*min(abs(x),abs(z))), 2.);\n\t}\n}\n\nvec2 pov_tiling_hexa_triangle(in vec2 p)\n{\n\t/* \n\t ** Tiling with a hexagon and 2 triangles\n\t */\n\tfloat x = p.x, z = p.y, delta = 0.;\n\tx -= 2.0*floor(x/2.0);\n\tz -= 2.0*POV_SQRT3*floor(z/(POV_SQRT3*2.0));\n\t/* x,z is in { [0.0, 2.0 [, [0.0, 2*SQRT3 [ } \n\t ** but there is some symmetry to simplify the testing\n\t */\n\tif (z > POV_SQRT3)\n\t{\n\t\tz -= POV_SQRT3;\n\t\tx += (x<1.0)?1.0:-1.0;\n\t}\n\t/* \n\t ** Now only [0,2[,[0,SQRT3[\n\t */\n\tif (z > POV_SQRT3_2)\n\t{\n\t\tz = POV_SQRT3 - z; /* mirror */\n\t\tdelta = 1. - delta;\n\t}\n\n\tif (x > 1.0)\n\t{\n\t\tx = 2.0 - x; /* mirror */\n\t}\n\t/*\n\t ** And now, it is even simpler :  [0,1],[0,SQRT3/2]\n\t ** on the bottom left corner, part of the triangle\n\t ** on the top right corner, center of the hexagon\n\t */\n\tif ((POV_SQRT3*x+z)<POV_SQRT3_2)\n\t{\n\t\t/* Triangle */\n\t\tfloat dist1 = 1.0 - (z * 2. * POV_SQRT3);\n\t\tfloat dist2 = 1.0 + ((POV_SQRT3 * x + z) - POV_SQRT3_2) * POV_SQRT3; \n\t\t\t/*< really substracting */\n\t\treturn vec2(max(dist1,dist2), delta);\n\t}\n\telse\n\t{\n\t\t/* Hexagon */\n\t\tfloat dist1 = 2. + 2. * (z * POV_SQRT3);\n\t\tfloat dist2 = 2. + 2. * ((POV_SQRT3 * x + z - POV_SQRT3_2) ) * POV_SQRT3_2;\n\t\treturn vec2((5.0-min(dist1,dist2)) / 3., 2.);\n\t\t// TODO FIXME - magic number! Should use nextafter()\n\t}\n}\n\nvec2 pov_tiling_square_offset(in vec2 p)\n{\n\t/*\n\t ** Tiling with a square, offset of half size\n\t ** Reduce to rectangle [0,1][0,2]\n\t ** move x,[1,2] to [0,1][0,1] with new x = x+1/2\n\t */\n\tvec2 x = vec2(p.x, p.y - 2.*floor(p.y/2.));\n\tif (x.y > 1.0)\n\t{\n\t\tx.x += 0.5;\n\t\tx.y -= 1.;\n\t}\n\tx.x -= floor(x.x);\n\tx = 2.*abs(x-0.5);\n\treturn vec2(max(x.x, x.y), 0.);\n}\n\n// #################################################################\n\n\n\nfloat hash1(in vec2 p) { return fract(sin(p.x+p.y)*(73481.+p.x*1.3-p.y*1.7)); }\n\nvec3 tiling_color(in vec2 uv, in vec2 seed, in float time)\n{\n    int   pattern = int(hash1(seed++)*9.99);\n    float soft = hash1(seed++); soft *= soft * soft;\n    float thick = 0.01 + .1*hash1(seed++);\n    float scale = 2. + 5. * hash1(seed++);\n            \n    uv += 0.2*time*vec2(hash1(seed++)-.5, hash1(seed++)-.5);\n    vec2 tile = pov_tiling(uv*scale, pattern);\n    \n    vec3 col = vec3(1.);//.5+.5*cos(hash1(seed++)*vec3(1.7+uv.y,1.1+uv.x,2.1)*6.*hash1(seed++));\n\n    float rep = .2 + (1.-thick) * .8 * hash1(seed++ + tile.y);\n    tile.x = mod(tile.x+.5*rep, rep)-.5*rep;\n    col *= smoothstep(soft+0.015*scale, .0, abs(tile.x)-thick);\n        \n    if (hash1(seed) > .6)\n    \tcol = 1. - col;\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    \n    float ti = iTime*1.3; // change multiplier for animation speed\n    float mti = mod(ti, 1.);\n    \n    vec3 col1 = tiling_color(uv, vec2(1., 1.1) * floor(ti), ti),\n    \t col2 = tiling_color(uv, vec2(1., 1.1) * floor(ti+1.), ti),\n    \t col = mix(col1, col2, mti*mti*(3.-2.*mti));    \n    \n    col *= pow(1.-.707*length(suv*2.-1.), .2);\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVSRd.jpg", "access": "shaders20k", "license": "agpl-3.0", "functions": [[2292, 2337, 2381, 2381, 2921], [2924, 3295, 3330, 3330, 3428], [3430, 3430, 3466, 3466, 4354], [4356, 4356, 4393, 4393, 5216], [5218, 5218, 5254, 5254, 5896], [5898, 5898, 5934, 5934, 7641], [7643, 7643, 7682, 7954, 8859], [8862, 8862, 8903, 8953, 9323], [9325, 9325, 9369, 9369, 10255], [10257, 10257, 10299, 10352, 11475], [11477, 11477, 11519, 11662, 11831], [11833, 11905, 11929, 11929, 11984], [11986, 11986, 12046, 12046, 12701], [12704, 12704, 12761, 12761, 13248]], "test": "valid"}
{"id": "4sVXWw", "name": "hjyShaderTest01", "author": "hongjeongyun", "description": "test01", "tags": ["hjy"], "likes": 0, "viewed": 391, "published": "Public API", "date": "1464751473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float aspectRatio = iResolution.x / iResolution.y; // ë¹„ìœ¨ ê³„ì‚°ê°’\n    \n    uv -= vec2(0.5,0.5); // ì›ì ì„ ì¤‘ì•™ìœ¼ë¡œ\n    uv.x *= aspectRatio; // ë¹„ìœ¨ì„¤ì •\n    \n    \n    float L = length(uv);\n    \n    float theta = atan(uv.y, uv.x);\n    \n    vec3 color;\n    \n    float r = 0.5 + 0.1 * sin(iTime);\n    \n    //float r = 0.5 + 0.1 * cos(iTime) * sin((theta * iTime) * 8.0);\n    \n    if(L > r)\n    {\n        color = vec3(1.0,0.0,0.0);\n    }\n    else\n    {\n        color = vec3(0.0,1.0,0.0);\n    }\n    \n    fragColor = vec4(color,1.0);\n    \n    //fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 766]], "test": "valid"}
{"id": "4sVXzK", "name": "Space Monolith", "author": "zackpudil", "description": "My God, it's full of fractals.", "tags": ["raymarching", "fractal", "distancefields"], "likes": 12, "viewed": 286, "published": "Public", "date": "1465414489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float tmax = 20.0;\n\nfloat map(vec3 p) {\n\tp.xy = mod(p.xy + 1.0, 2.0) - 1.0;\n\tp.z = abs(p.z) - 0.75;\n\tvec4 q = vec4(p, 1.0);\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tq.xyz = abs(q.xyz) - vec3(0.3, 1.0, -0.0);\n\t\tq = 2.0*q/clamp(dot(q.xyz, q.xyz), 0.5, 1.0) - vec4(1.0, 0.0, 0.3, 0.0);\n\t}\n\t\n\treturn abs(q.x + q.y + q.z)/q.w;\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n\tfloat d = 1.0;\n\tfloat e, t = 0.0;\n    float g = 0.0;\n\t\n\tfor(int i = 0; i < 200; i++) {\n\t\tif(abs(d) < e || t >= tmax) break;\n\t\td = map(ro + rd*t);\n\t\te = 0.001*(1.0 + t*4.0);\n\t\tt += d*(0.55 + 0.05*t);\n        \n        g = 1.0;\n\t}\n\t\n\treturn vec2(t, t >= tmax ? 0.0 :clamp(g*0.9, 0.0, 1.0));\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.01, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nmat3 camera(vec3 eye, vec3 lat) {\n\tvec3 ww = normalize(lat - eye);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\t\n\treturn mat3(uu, vv, ww);\n}\n\nfloat hash2(vec2 n) {\n\treturn fract(sin(dot(n, vec2(27.233, 71.989)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 col = vec3(1)*step(0.997, hash2(uv));\n\t\n\tvec3 ro = vec3(iTime*0.5, 1.0*sin(iTime*0.3), 0.25*cos(iTime*0.2));\n\tvec3 rd = normalize(camera(ro, ro + vec3(3.0, 0, 4.0*sin(iTime*0.5)))*vec3(uv, 1.97));\n    \n    vec3 pos;\n\t\n\tvec2 i = march(ro, rd);\n\tif(i.x < tmax) {\n\t\tpos = ro + rd*i.x;\n\t\tvec3 nor = normal(pos);\n\n\t\tcol = vec3(0.0);\n\n\t\tcol += 0.1*pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0)*smoothstep(-8.0, -6.0, -i.x);\n\t}\n\n\tfloat y = mod(pos.y + iTime, 2.0);\n    col += pow(abs(i.y), 0.3)\n        *vec3(1.0, 0, 0)\n        *smoothstep(0.0, 0.2, y)\n\t\t*smoothstep(-0.2, 0.0, -y);\n\tcol = pow(col, vec3(.454545));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 46, 46, 324], [326, 326, 356, 356, 647], [649, 649, 670, 670, 845], [847, 847, 880, 880, 1028], [1030, 1030, 1051, 1051, 1114], [1116, 1116, 1173, 1173, 1911]], "test": "valid"}
{"id": "4sySRG", "name": "Worley-Voronoi-Whatever... :D", "author": "jviedma", "description": "Just learning, understanding and training with Voronoi distance and celular map creation. It's just a draft. Experimenting\n\nReferences: Iquilez http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n", "tags": ["pgatrcelularworleyvoronoi"], "likes": 4, "viewed": 641, "published": "Public API", "date": "1465146676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//References: Iquilez http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n//https://www.shadertoy.com/view/ldl3W8\n//http://www.iquilezles.org/www/articles/distance/distance.htm\n//Learning a little bit about voronoi\n\n\n#define ANIMATE\nconst int DISTANCE = 1; // Different border Calculation \n\t\t\t\t\t\t//4 is worley without borders, no second loop\nconst float BorderThickness = 0.1;\nconst bool ShowPoint = false;\n\nconst vec3 red = vec3(1.0,0.0,0.0);\nconst vec3 black = vec3(0.0,0.0,0.0);\nconst vec3 white = vec3(1.0,1.0,1.0);\nconst vec3 yellow = vec3(1.0,1.0,0.0);\nconst vec3 blue = vec3(0.0,0.0,1.0);\nconst vec3 green = vec3(0.0,1.0,0.0);\nconst vec3 purple = vec3(1.0,0.0,1.0);\nconst vec3 orange = vec3(1.0,5.0,0.0);\n\n\n\nvec2 Hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\nfloat DistanceBetweenARectAndaPoint2D(vec2 p, vec2 rp, vec2 v)\n{\n   \n    vec2 v1 = rp - p;\n    \n    vec3 cp = cross(vec3(v,0),vec3(v1,0));\n    \n    return length(cp)/length(v);\n}\n\nvoid BisectionRect2D(vec2 p1, vec2 p2, out vec2 rp, out vec2 v)\n{\n\tv = p1-p2;\n    \n    v = vec2(v.y,v.x);\n    \n    if(v.x != 0.0){v.x = -v.x;}\n    else{v.y = -v.y;}\n    \n    rp = 0.5*(p1+p2);\n}\n\nvec2 IntersectionPoint(vec2 rp1, vec2 v1, vec2 rp2, vec2 v2)\n{\n    vec2 rpp = (rp2 -rp1) / v1;\n    vec2 vpp = v2 / v1;\n    \n    float sol1 = vpp.x - vpp.y;\n    float sol2 = rpp.y - rpp.x;\n    \n    \n    return rp2 + v2 *(sol2/sol1);\n}\n\nfloat iQuilezDistance(vec2 a, vec2 b)\n{\n    float quilez = dot( 0.5*(a+b), normalize(b-a));\n    \n    return quilez;\n}\n\nfloat distance4(vec2 p, vec2 rp, vec2 v)\n{\n    float e = 2.0/iResolution.y;\n    float f = DistanceBetweenARectAndaPoint2D(p, rp, v);\n    \n    float g = length( vec2(DistanceBetweenARectAndaPoint2D(p+vec2(e,0.0), rp, v)-DistanceBetweenARectAndaPoint2D(p-vec2(e,0.0), rp, v),\n                          DistanceBetweenARectAndaPoint2D(p+vec2(0.0,e), rp, v)- DistanceBetweenARectAndaPoint2D(p-vec2(0.0,e), rp, v))/(2.0*e));\n    return f/ g;\n}\n\n\nvec4 Worley(vec2 p, out float dist)\n{\n    vec2 integer = floor(p);\n\t\n    vec2 relativeSquarePoint;    \n        \n    vec2 closestpoint;\n    vec2 ndClosestPoint;\n    vec2 trdClosesPoint;\n    float MinDistance = 1000.0;\n    float NdMinDistance = 1000.0;\n\tfloat TrdMinDistance = 1000.0;\n    \n    float linedistance =10000.0;\n    \n    for(int i = -1; i <= 1; i++)\n    {\n    \tfor(int j = -1; j <= 1; j++)\n        {\n            vec2 relativeSquarePoint1 = integer + vec2(i,j);\n\t\t\tvec2 offset = Hash2(relativeSquarePoint1);\n            #ifdef ANIMATE\n        \toffset.x = 0.5 + 0.5*cos( iTime + 6.2831*offset.x );\n            offset.y = 0.5 + 0.5*sin( iTime + 6.2831*offset.y );\n        \t#endif\t\n           \tvec2 squarepoint = relativeSquarePoint1 +offset;\n            \n            float CurrentDistance = distance(squarepoint, p);\n            \n            \n            if(MinDistance > CurrentDistance)\n            {    \n            \tMinDistance = CurrentDistance;\n                closestpoint = squarepoint;\n                relativeSquarePoint = relativeSquarePoint1;\n            }\n            /*\n\t\t\telse if(NdMinDistance > CurrentDistance)\n            {\n                NdMinDistance = CurrentDistance;\n                ndClosestPoint = squarepoint ;\n            }\n            /*\n            else if(TrdMinDistance > CurrentDistance)\n            {\n                TrdMinDistance = CurrentDistance;\n                trdClosesPoint = squarepoint ;\n            }\n\t\t\t*/\n        }\n    }\n    \n    \n    vec2 CurrentDecimal = fract(closestpoint);\n    vec2 CurrentInteger = floor(closestpoint);\n    \n    vec2 spc1 = closestpoint - p;\n   \tif(DISTANCE!=4)\n    {\n        for(int i=-2; i<=2; i++)\n        {\n            for(int j =-2;j<=2;j++)\n            {\n                vec2 relativeSquarePoint2 = relativeSquarePoint+vec2(i,j);\n                vec2 offset = Hash2(relativeSquarePoint2);\n                #ifdef ANIMATE\n                offset.x = 0.5 + 0.5*cos( iTime + 6.2831*offset.x );\n                offset.y = 0.5 + 0.5*sin( iTime + 6.2831*offset.y );\n                #endif\t\n                vec2 SquarePoint2 = relativeSquarePoint2 +offset;\n                float CurrentDistance = distance(SquarePoint2, p);\n\n                vec2 spc2 = SquarePoint2 -p;      \t\n\n                if( !(i==0 && j==0 ))\n                {\t//La distamcia mÃ­nima no es solo con la bisectriz con el segundo punto mÃ¡s cercano\n                    //Sino con muchos otros puntos, por eso el cÃ¡lculo de la distancia debe venir aquÃ­\n\n                    if(DISTANCE == 1)\n                    {\n                        vec2 v1;\n                        vec2 rp1;\n                        BisectionRect2D(closestpoint, SquarePoint2, rp1, v1);\n                        linedistance = min(linedistance,DistanceBetweenARectAndaPoint2D(p,rp1 ,v1));\n                    }\n                    if(DISTANCE == 2)\n                        linedistance = min(linedistance,(0.5*(MinDistance + CurrentDistance) - MinDistance) /(MinDistance + CurrentDistance));\n                    if(DISTANCE == 3)\n                    {\n                        linedistance = min(linedistance,iQuilezDistance(closestpoint-p, SquarePoint2-p));\n                    }\n                }\n            }\n        }\n    }\n\n   \tdist = linedistance;\n    linedistance = smoothstep(0.00,BorderThickness,linedistance);\n    \n       \n    return vec4(MinDistance,linedistance,relativeSquarePoint.x,relativeSquarePoint.y);\n}\n\nvec3 SelectColor(float i, float j)\n{\n    float a = mod((i * i + i +j), 6.0);\n    if(a==0.0){return red;}\n    if(a==1.0){return yellow;}\n    if(a==2.0){return green;}\n    if(a==3.0){return blue;}\n    if(a==4.0){return orange;}\n    return purple;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p =  2.0*vec2(gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float dd;\n    \n    vec4 d = Worley(4.0*p,dd);\n     \n    vec3 col = SelectColor(floor(d[2]+1.0*sin(iTime + 6.2)),floor(d[3]+1.0*cos(iTime)));\n    \n    \n    col = mix( col, col*0.5, smoothstep( 0.01, 1.0, 0.5*sin(32.0*d.x-p.y)*cos(32.0*(d.x-p.y)) ) );\n    col = mix( col, white, smoothstep( 0.1, 1.0, 0.6*sin(32.0*d.x-p.y+10.0)*cos(32.0*(d.x-p.y+10.0)) ) );\n    \n    if(ShowPoint)\n    \tcol = mix( col, yellow, 1.0 - smoothstep( 0.000, 0.5, d.x ));\n    \n    \n    col = mix( col, col*0.2, 1.0 - smoothstep( 0.01, 0.5, dd ) );\n    col = mix( col, black, (1.0 - smoothstep( 0.999, 1.0, d.y )));\n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sySRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 732, 752, 752, 864], [866, 866, 930, 930, 1044], [1046, 1046, 1111, 1111, 1239], [1241, 1241, 1303, 1303, 1474], [1476, 1476, 1515, 1515, 1593], [1595, 1595, 1637, 1637, 2033], [2036, 2036, 2073, 2073, 5479], [5481, 5481, 5517, 5517, 5727], [5729, 5729, 5786, 5786, 6498]], "test": "valid"}
{"id": "4syXRt", "name": "My heart beating", "author": "Uriopass", "description": "My heart goes at 100 bpm, I wanted to show the world what it felt like.", "tags": ["beat", "circle", "heart"], "likes": 5, "viewed": 259, "published": "Public", "date": "1465896346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 hsv(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 circle(float radius, in float lengthA)\n{\n    float distance = min(1., .01/abs(radius-lengthA));\n\treturn distance*hsv(vec3(radius, 1, 1.-radius));\n}\n\n\nvec3 specialCenter(float radius, in float time)\n{\n    float distance = min(1., time*(.01/radius));\n\treturn distance*vec3(1.-radius, 0., 0.);\n}\n\nfloat bpm = 100.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    float r = length(uv);\n    vec3 color = vec3(0, 0, 0);\n    float time = fract(iTime*(bpm/60.));\n    for(int i = 0 ; i < 12 ; i++)\n    {\n    \t   color += circle(r, (float(i)+time)/10.);\n    }\n    color += specialCenter(r, time);\n    color.x = (color.x+1.-time)/2.;\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 19, 19, 182], [184, 184, 229, 229, 336], [339, 339, 388, 388, 481], [502, 502, 559, 559, 907]], "test": "valid"}
{"id": "4syXRV", "name": "Teacups", "author": "jackdavenport", "description": "We were studying Tea cup ballet by Olive Cotton in a photography class. So I decided to create a similar looking image as a shader.\n\nImage: https://en.wikipedia.org/wiki/Tea_cup_ballet", "tags": ["raymarcher", "distance", "teacup"], "likes": 10, "viewed": 1549, "published": "Public API", "date": "1465267462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 256\n#define MIN_DISTANCE  .001\n\nconst vec3 lightCol = vec3(1.,.8,.8);\n\t  vec3 lightPos = vec3(0.,1.,3.);\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Dst { float dst; int id;  };\nstruct Hit { vec3 p; int id; \t };\n    \n// Distance Field Source:\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n  \nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nDst dstTeacup(vec3 p) {\n \t\n    float rot = iTime * 45.;\n    if(iMouse.z > 0.) rot = -90.+180.*(iMouse.x/iResolution.x);\n    p.xz = mod(p.xz, vec2(2.))-1.;\n    p.xz = rot2D(p.xz, rot);\n    \n    float dst = sdCappedCylinder(-p, vec2(.5,.45));\n    dst = max(-sdCappedCylinder(vec3(0.,0.2,0.)-p, vec2(.4,.35)), dst);\n    //dst = min(dst, sdCappedCylinder(vec3(0.,0.2,0.)-p, vec2(.4,.35)));\n    \n    p.yz = rot2D(p.yz, 90.);\n    dst = smin(dst, sdTorus(vec3(0.6,0.,0.)-p,vec2(.2,.05)), .1);\n    \n    return Dst(dst,0);\n    \n}\n\nDst dstFloor(vec3 p) {\n \n    float h = -.45;\n    return Dst(p.y - h, 1);\n    \n}\n\nDst dstUnion(Dst a, Dst b) {\n \n    if(a.dst < b.dst) return a;\n    return b;\n    \n}\n\nDst dstScene(vec3 p) {\n \n    Dst dst = dstTeacup(p);\n    dst = dstUnion(dst, dstFloor(p));\n    \n    return dst;\n    \n}\n\nHit raymarch(Ray ray, int maxIter, float maxDst) {\n    \n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        if(i >= maxIter || distance(p,ray.ori) >= maxDst) {\n         \n            id = -1;\n            break;\n            \n        }\n        \n        Dst scn = dstScene(p);\n        p += ray.dir * scn.dst * .75;\n        \n        if(scn.dst < MIN_DISTANCE) {\n         \n            id = scn.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n\n// Shadows by iq\n// Source: https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = dstScene( ro + rd*t ).dst;\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001,0.);\n    vec3 n   = vec3(dstScene(p+eps.xyy).dst-dstScene(p-eps.xyy).dst,\n                    dstScene(p+eps.yxy).dst-dstScene(p-eps.yxy).dst,\n                    dstScene(p+eps.yyx).dst-dstScene(p-eps.yyx).dst);\n    return normalize(n);\n    \n}\n\nvec3 calcLighting(vec3 col, Ray ray, vec3 p, vec3 n, vec3 r, float shine) {\n    \n    vec3 lv = lightPos - p;\n    vec3 ld = normalize(lv);\n    \n    float d = max(dot(ld,n),0.);\n    float s = 0.;\n    if(shine > 0.) {\n\n        s = max(pow(dot(ld,r),shine),0.);\n        \n    }\n    \n    d *= 1.-smoothstep(0., 25., length(lv));\n    d *= softshadow(p+ld*.01,ld,0.,length(lv));\n    s *= d;\n    \n    return (col * lightCol * d) + (s * lightCol);\n    \n}\n\nvec3 shadeTeacup(Ray ray, Hit scn, vec3 n, vec3 r) {\n \n    return calcLighting(vec3(1.),ray,scn.p,n,r,60.);\n    \n}\n\nvec3 shadeFloor(Ray ray, Hit scn, vec3 n, vec3 r) {\n \n    vec3 tex = texture(iChannel0, mod(scn.p.xz, 1.)).xyz;\n    return calcLighting(tex,ray,scn.p,n,r,25.);\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scn  = raymarch(ray, MAX_ITERATIONS, 256.);\n    vec3 col = vec3(0.);\n    \n    if(scn.id == 0) {\n        \n        vec3 n = calcNormal(scn.p);\n        vec3 r = normalize(reflect(ray.dir, n));\n        \n        col = shadeTeacup(ray,scn,n,r);\n        \n        Ray rr  = Ray(scn.p+r*.01,r);\n        Hit rh  = raymarch(rr,32,256.);\n        vec3 rc = vec3(0.);\n        if(rh.id == 0) {\n           vec3 rn = calcNormal(rh.p);\n           vec3 rd = normalize(reflect(rr.dir,rn));\n           rc = shadeTeacup(rr,rh,rn,rd);\n        } else if(rh.id == 1) {\n           vec3 rn = calcNormal(rh.p);\n           vec3 rd = normalize(reflect(rr.dir,rn));\n           rc = shadeFloor(rr,rh,rn,rd);\n        }\n        \n        float fresnel = mix(.01,.9,1.-max(pow(-dot(ray.dir,n),.7),0.));\n        col = mix(col, rc, fresnel);\n        \n    } else if(scn.id == 1) {\n     \n        vec3 n = calcNormal(scn.p);\n        vec3 r = normalize(reflect(ray.dir,n));\n        \n        col = shadeFloor(ray,scn,n,r);\n        \n        Ray rr  = Ray(scn.p+r*.01,r);\n        Hit rh  = raymarch(rr,32,256.);\n        vec3 rc = vec3(0.);\n        if(rh.id == 0) {\n        vec3 rn = calcNormal(rh.p);\n        vec3 rd = normalize(reflect(rr.dir,rn));\n        rc = shadeTeacup(rr,rh,rn,rd);\n        }\n        \n    }\n    \n    col = mix(col, vec3(0.), smoothstep(2.,56.,distance(scn.p,ray.ori)));\n    \n    float flare = max(pow(dot(normalize(lightPos-ray.ori),ray.dir), 50.), 0.);\n    col += lightCol * flare;\n\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(2.5*cos(iTime*.1),2.,-3.+iTime);\n    vec3 dir = vec3(uv, 1.);\n    dir.yz   = rot2D(dir.yz, -25.);\n    Ray  ray = Ray(ori, normalize(dir));\n    \n    lightPos  = ori+vec3(4.5*sin(iTime),.5+.5*sin(iTime),5.+1.5*cos(iTime*5.));\n    fragColor = vec4(shade(ray),1.);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 340, 382, 382, 481], [482, 482, 515, 515, 580], [581, 581, 622, 622, 715], [719, 719, 752, 752, 877], [879, 879, 902, 902, 1399], [1401, 1401, 1423, 1423, 1480], [1482, 1482, 1510, 1510, 1565], [1567, 1567, 1589, 1589, 1685], [1687, 1687, 1737, 1737, 2221], [2223, 2289, 2363, 2363, 2632], [2634, 2634, 2659, 2659, 2931], [2933, 2933, 3008, 3008, 3377], [3379, 3379, 3431, 3431, 3493], [3495, 3495, 3546, 3546, 3661], [3663, 3663, 3684, 3684, 5179], [5181, 5181, 5238, 5238, 5588]], "test": "error"}
{"id": "4syXWG", "name": "golden pie", "author": "dello32", "description": "a simple test of how get normal from sinus function and use true reflection raytrace.", "tags": ["goldraytracesinusnormal"], "likes": 2, "viewed": 128, "published": "Public", "date": "1466172175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RAYCASTSTEPS 0.1\n#define MAXDISTANCE 20.0\n\n#define MAXDREFL 10.0\n#define STEPREFL 0.2\n\n#define SPEED 1.0\n#define FOCAL 1.5\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43.5453);\n}\n\nvec4 map2(vec3 p, vec3 ro, vec3 lPos ){\n    // light map\n    if(distance(p,lPos)<0.1){\n    \treturn vec4(1.,1.,1.,1.);\n    }\n    \n    // wall map\n    float dens = sin(p.x)+sin(p.y)+sin(p.z);\n    if( dens>= 0.9 ){\n    \tvec3 n = normalize( vec3(-cos(p.x),-cos(p.y),-cos(p.z) ));\n        vec3 lDir = normalize(lPos-p);\n        float d = max(dot(lDir,n),0.0)*( (10.0-min(distance(lPos,p),10.0))/10.0);\n        vec3 camDir = normalize(ro-p);\n        vec3 r = cross(camDir, cross(n,camDir));\n        float s = pow(max(dot(lDir, r),0.0),1.0);\n        return vec4(vec3(d*1.,d*1.,d*.6) + vec3(s,s*s,s*s*s),1.);\n        \n    }\n    return vec4(0.0,0.0,0.0,0.0);\n}\n\nvec4 trace2(vec3 ro, vec3 rd){\n    float time = iTime*SPEED;\n    vec3 p;\n    vec4 col;\n\tfor( float i=1.0; i<MAXDREFL; i+=STEPREFL )\t{\n\t\tp = ro + rd*float(i) + rd;\n        vec3 lPos =ro + vec3(sin(time*2.),0.0,2.0+cos(time*2.));\n        col = map2(p, ro, lPos);\n        if( col.w>=0.5) break;\n    }\n    return col;\n}\n\nvec4 map(vec3 p, vec3 ro, vec3 lPos ){\n    // light map\n    if(distance(p,lPos)<0.1){\n    \treturn vec4(1.,1.,1.,1.);\n    }\n    \n    // Erratic world\n    p += vec3(cos(p.x*7.475),sin(p.y*10.457),cos(p.z*8.14))*0.1;\n    \n    // wall map\n    float dens = sin(p.x)+sin(p.y)+sin(p.z);\n    if( dens>= 0.9 ){\n    \tvec3 n = normalize( vec3(-cos(p.x),-cos(p.y),-cos(p.z) ));\n        vec3 lDir = normalize(lPos-p);\n        float d = max(dot(lDir,n),0.0)*( (10.0-min(distance(lPos,p),10.0))/10.0);\n        vec3 camDir = normalize(ro-p);\n        vec3 r = cross(camDir, cross(n,camDir));\n        float s = pow(max(dot(lDir, r),0.0),1.0);\n        vec4 ref = trace2(p, n);\n        vec4 col = vec4(vec3(d*1.,d*1.,d*.6) + vec3(s,s*s,s*s*s),1.);\n        return(col+ref);\n        \n    }\n    \n    return vec4(0.0,0.0,0.0,0.0);\n}\n\nvec4 trace(vec3 ro, vec3 rd){\n    float time = iTime*SPEED;\n    vec3 p;\n    vec4 col;\n\tfor( float i=1.0; i<MAXDISTANCE; i+=RAYCASTSTEPS )\t{\n        float spread = hash(rd.x+rd.y);\n\t\tp = ro + rd*float(i-1.0)+rd*spread;\n        vec3 lPos =ro + vec3(sin(time*2.),0.0,2.0+cos(time*2.));\n        col = map(p, ro, lPos);\n        if( col.w>=0.5) break;\n    }\n\n    float z =  1.-(20.0-min(distance(p,ro),20.0))/20.0;\n    vec4 fog = vec4(vec3(0.2,0.15,0.1)*z,1.0);\n    return mix(col,fog,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime*SPEED;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// camera\t\n    vec3 ro =  vec3(sin(time)-1.5,-2.0,time );\n\tvec3 ta =  ro + vec3(cos(time*0.2),0.0,2.0 );\n\tfloat roll = -0.15*sin(0.5*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 rd = normalize( p.x*cu + p.y*cp + cw*FOCAL );\n\t\n    fragColor = trace(ro, rd);\n}\n  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 156, 156, 192], [194, 194, 233, 250, 845], [847, 847, 877, 877, 1162], [1164, 1164, 1202, 1219, 1972], [1974, 1974, 2003, 2003, 2458], [2460, 2460, 2517, 2517, 3005]], "test": "valid"}
{"id": "ld3SDn", "name": "wave of balls", "author": "bitek", "description": "calculating intersections with spheres using dot products of view port rays and a sphere centre", "tags": ["raytracinganalytical"], "likes": 1, "viewed": 100, "published": "Public", "date": "1465392378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// A textured spheres scene.\n// (c) 2016, Viktor Korsun.\n//\n// The shader is provided \"as is\", with no warranty of any kind, uner MIT license.\n// https://opensource.org/licenses/MIT.\n//\n\nconst float spheresCount = 40.0;\nconst float spread = 6.0;\n\nconst float initialDistance = 300.0;\nconst float aureole = 2.5;\nconst float speed = 0.05;\nconst float initialSize = 0.5;\n\n\nvec4 getSphere(float sphereNo, float time)\n{\n\tfloat lifetimedelta = sphereNo / spheresCount;\n    \n    time *= speed;\n\n    float lifetimeDiv = floor(time + lifetimedelta);\n    float lifetimeFrac = time + lifetimedelta - lifetimeDiv;\n\n\tsphereNo = sphereNo + lifetimeDiv * spheresCount;\n    \n    if (sin(sphereNo * 3.141) > 0.0) {sphereNo += spheresCount;};\n    \n    float x = sin(sphereNo/6.0)*spread;\n    float y = sin(sphereNo/7.0)*spread;\n    return vec4(x, y, initialDistance - lifetimeFrac * initialDistance, abs(sin(sphereNo*3.0))*initialSize + initialSize);\n}\n\nvec3 intersects(vec3 src, vec3 direction, float globalTime)\n{   \n    float alpha = sin(iTime * speed * 2.0) * 0.1;\n\tmat2 rotation = mat2(cos(alpha), -sin(alpha), sin(alpha), cos(alpha));\n    \n    float z = 0.0;\n    \n\tfloat minDistance = initialDistance;\n    vec4 final_sphere;\n    vec3 final_point;\n    \n \tvec3 normDirection = normalize(direction);\n    float aura = 0.0;\n\n    for (float sphereNo = 0.0; sphereNo < spheresCount; sphereNo++) {\n\t    vec4 sphere = getSphere(sphereNo, globalTime);\n        vec4 oldSphere = sphere;\n        \n        sphere.xz = sphere.xz * rotation;\n        \n        sphere.x += sin(iTime*4.2*speed) * 8.0;\n        sphere.y += sin(iTime*3.0*speed) * 7.0;\n        \n        vec3 tcenter = sphere.xyz - src;\n                \n\t\tfloat centerProjectionLength = dot(tcenter, normDirection);\n\t\tvec3 projectionPoint = centerProjectionLength * normDirection;\n        vec3 projection = sphere.xyz - projectionPoint;\n\t    float l = length(projection);\n        if (l < sphere.a)\n        {\n\t\t\tfloat deltaToIntersection = sqrt(sphere.a*sphere.a - l*l);\n\t\t\tvec3 intersection = projectionPoint - deltaToIntersection * normDirection;\n\t\t\tif (minDistance > length(intersection))\n            {\n                minDistance = length(intersection);\n\t            final_sphere = oldSphere;\n    \t        final_point = sphere.xyz - intersection;\n                z = final_sphere.z;\n            }\n            \n        } else {\n            if (l < aureole)\n\t\t\t\taura += pow(((aureole - l) / aureole), 3.0) * (1.0 - smoothstep(0.0, initialDistance, oldSphere.z) / 4.0);\n        }\n    }\n\n    vec3 result = vec3(0,0,0);\n    vec3 light = vec3(0,0,1);\n    light.xz = light.xz * rotation;\n        \n    vec3 mapped = final_point;\n    vec3 compSphere = vec3(\n            pow(sin(sin(mapped.x*30.0) * sin(final_sphere.x*100.0)*20.0 + sin(mapped.y*20.0)*2.0 + sin((mapped.x + mapped.y)*20.0) * 3.0), 4.0),\n            pow(abs(sin(mapped.y * (4.0 + sin(final_sphere.y * 10.0) * 10.0) + mapped.x * 4.0 + sin(mapped.x * 5.0 + mapped.y) * 1.0)), 50.0) / 2.0,\n            pow(abs(sin(mapped.x + sin(mapped.y*4.0 + final_sphere.a * 100.0) * 2.0)), 40.0)\n        );\n    \n    compSphere *= 50.0;\n    compSphere += sin(mapped.z);\n    \n    vec3 aureole = vec3(aura, aura / 2.0,aura / 4.0) / 3.0;\n\n    float space = (pow(abs(dot(normalize(direction), normalize(light))), 12.0));\n    vec3 compSpace = vec3(space, space, space);\n    float blend = smoothstep(0.0, initialDistance, z);\n    \n    if (minDistance < initialDistance) {\n        result = (1.0 -  blend) * compSphere;\n      \tresult += compSpace * blend;\n    } else {\n        result = compSpace;\n        result += aureole * (1.0 - blend);\n    }\n\n    return result;\n}\n\nvec4 ray(vec3 src, vec3 direction, float globalTime)\n{\n\treturn vec4(intersects(src, direction, globalTime), 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv_n = vec2(uv.x, uv.y / ratio);\n\n\tvec3 initialPosition = vec3(uv_n, 0);\n    vec3 direction = initialPosition+vec3(uv_n, 5.0 - length(uv_n.xy));\n\t    \n    fragColor = ray(initialPosition, direction, iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3SDn.jpg", "access": "shaders20k", "license": "warranty-disclaimer", "functions": [[0, 373, 417, 417, 937], [939, 939, 1000, 1000, 3636], [3638, 3638, 3692, 3692, 3751], [3753, 3753, 3810, 3810, 4125]], "test": "valid"}
{"id": "ldd3Rn", "name": "march learning: 2 shapes!", "author": "vsnchips", "description": "Getting somewhere", "tags": ["wip"], "likes": 3, "viewed": 434, "published": "Public API", "date": "1466051047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//# CLOCK : iTime\n\nfloat scope=1.0;\nfloat radius = 0.2;\nfloat pulsespeed = 0.2;\n\nvec3 origincam = vec3 (0.5,1.5,2.2);\nfloat camrotx = 0.;\nfloat camroty = 0.;\n\n//sphere\nfloat sphere (vec3 p,float rad)\n{\n    //return length (p) - rad;\n //  return length(frp) - rad *1.;\n return length(fract((2.*(p+.5))-1.)  -.5) - rad;\n}\n\n\n//cubeything\n\nfloat cubish (vec3 p, float size, float pw)\n{\n    vec3 ftbish= vec3(pow(fract(p.x)*2.-1.,2.),pow(fract(p.y)*2.-1.,2.),pow(fract(p.z)*2.-1.,2.));\n    vec3 bish= vec3(pow(p.x,pw),pow(p.y,pw),pow(p.z,pw));\n    return length (ftbish) - size;\n}\n\n\n\n// trace function finds surface\nfloat trace (vec3 o, vec3 r, float rad){ \n\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 32; ++i) {\n        \n    \tvec3 newpoint= o + r * t;\n    \n        //shaping function:\n        float d= min (sphere(newpoint, 0.2-rad),cubish(newpoint, rad, 2.));    \n    \t//float d = sphere(newpoint, rad);\n        //float d = cubish(newpoint, 0.5 -rad, 2.);\n        \n    t += d * (0.5 + sin(iTime*10.)*0.01);\n         }\nreturn t;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    //update camera, size, transforms\n    float ti = iTime;\n    radius = sin(ti*pulsespeed*10.)*0.2+0.21;\n    //camrotx = ti*10.8;\n    //camroty = ti*10.2;\n    if (iMouse.z > 0.) \n    {\n        origincam += (vec3(iMouse.xy/ iResolution.xy * 2. , 1.));\n    }\n    else {camroty = sin(ti)*-0.8; camrotx = 3.; \n          origincam = vec3 (0.5*sin(ti)+0.,0.5*sin(ti*2.3)+0.,1.2);}\n    \n       \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 -1.0; \n\n    vec3 ray= normalize(vec3( uv,scope));\n   ray.xz *= mat2 (cos (camrotx),-sin (camrotx),sin (camrotx),cos (camrotx));\n   ray.yz *= mat2 (cos (camroty),-sin (camroty),sin (camroty),cos (camroty));\n    \n    \n    float t=(trace(origincam,ray,radius));\n    float thisT=1./1.0+pow(t,3.)*1.0;\n  \n    \n    fragColor = vec4(t*0.1,thisT*0.001,uv.y*sin(iTime),1.0);\n   \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldd3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 168, 201, 267, 319], [322, 336, 381, 381, 575], [579, 611, 651, 651, 1020], [1025, 1025, 1082, 1126, 1900]], "test": "valid"}
{"id": "ldGSWV", "name": "Mellow rainbow", "author": "bwestlin", "description": "Just messing around with some sinus functions", "tags": ["2d", "sound", "sinus", "soundcloud"], "likes": 10, "viewed": 360, "published": "Public", "date": "1466615879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r iResolution\n#define t iTime\n#define ic0 iChannel0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / r.x;\n    float s1 = .5 + .5 * min(texture(ic0, vec2(.1, 0.) ).x * 1.5, 1.);\n    float s2 = .5 + .5 * min(texture(ic0, vec2(.4, 0.) ).x * 1.5, 1.);\n    float s3 = .5 + .5 * min(texture(ic0, vec2(.6, 0.) ).x * 1.5, 1.);\n    float s4 = .5 + .5 * min(texture(ic0, vec2(.9, 0.) ).x * 1.5, 1.);\n    \n    vec2 p1 = vec2(0., 0.);\n    vec2 p2 = vec2(0., r.y / r.x);\n    vec2 p3 = vec2(1., r.y / r.x);\n    vec2 p4 = vec2(1., 0.);\n       \n    float c1 = .5 + .5 * sin(distance(uv, p1) * 10. * s1 + t + s1 / 4.);\n    float c2 = .5 + .5 * sin(distance(uv, p2) * 10. * s2 + t + s2 / 4.);\n    float c3 = .5 + .5 * sin(distance(uv, p3) * 10. * s3 + t + s3 / 4.);\n    float c4 = .5 + .5 * sin(distance(uv, p4) * 25. * s4 + t * 3. + s4 / 4.);\n           \n\tfragColor = vec4(c1 + c4 * .33, c2 + c4 * .33, c3 + c4 * .33, 1.);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 116, 116, 949]], "test": "error"}
{"id": "ldKSRt", "name": "tuto: continuous varying pattern", "author": "FabriceNeyret2", "description": "For procedural patterns and sound there is a classical trap: a space (or time) varying parameter can gives ugly fast changes (top) instead of what you expect. Indeed, you need to integrate the \"phase\" to get the right thing  (bottom). \n( mouse.x = time )", "tags": ["procedural", "noise", "sound", "pattern", "interpolation", "trap", "tuto", "smartblend"], "likes": 11, "viewed": 797, "published": "Public API", "date": "1466092387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// For procedural patterns and sound there is a classical trap: \n// a space (or time) varying parameter can gives ugly fast changes (top)\n// instead of what you expect. \n// Indeed, you need to integrate the \"phase\" to get the right thing  (bottom). \n// see also https://www.desmos.com/calculator/7dbitjcfrf\n//      and https://www.shadertoy.com/view/ldGXWc\n\n#define f(x) ( 6.  + 4.*sin(x/5.)    )   // space varying frequency. is also phase derivative\n#define F(x) ( 6.*x -4.*cos(x/5.)*5. )   // its integration (i.e. absolute phase).\n                                         // noise (or sin for sound) is then just a post LUT.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tvec2 R = iResolution.xy;\n    U = (U+U-R)/R.y; \n    float M = length(iMouse.xy/R)<.01 ? 8.*iTime \n                                      : iMouse.x;\n    O -= O; if (abs(U.y)<.01) return;\n    float x = 20.*U.x + M;\n    \n                            // draw pattern\n\tO = sin( U.y>0. ? f(x)*x     // wrong intuition: varying frequency * x\n                    : F(x)       // good solution: real phase = int (Dphase). Dphase = freq\n           ) +O-O;\n/*\n    O = .2/abs(             // draw function\n        sin( U.y>0. ? f(x)*x     // wrong intuition: varying frequency * x\n                    : F(x)       // good solution: real phase = int (Dphase). Dphase = freq\n           ) - (2.*fract(U.y)-1.)/.6) +O-O;\n*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKSRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 630, 668, 668, 1377]], "test": "valid"}
{"id": "ldKXWG", "name": " hexagonal tiling 7", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "pattern", "tiling", "hexagonal", "short"], "likes": 25, "viewed": 937, "published": "Public API", "date": "1466412159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// relying on hexagonal tiling tutos            https://www.shadertoy.com/view/4dKXR3\n//    https://www.shadertoy.com/view/XdKXz3 and https://www.shadertoy.com/view/lsKSRt\n\nvoid mainImage( out vec4 O, vec2 uv )\n{ \n    vec2 R = iResolution.xy,\n         U = uv = (uv-R/2.)/R.y * 5. *  1.73/2.;          // centered coords\n    \n    U *= mat2(1,-1./1.73, 0,2./1.73);                     // conversion to\n    vec3 g = vec3(U, 1.-U.x-U.y), g2,                     // hexagonal coordinates\n         id = floor(g);                                   // cell id\n    \n    g = fract(g); g.z = 1.-g.x-g.y;                       // triangle coords     \n    g2 = abs(2.*g-1.);                                    // distance to borders\n\n    U = id.xy * mat2(1,.5, 0,1.73/2.);\n    float l00 = length(U-uv),                    // screenspace distance to nodes\n          l10 = length(U+vec2(1,0)-uv), \n          l01 = length(U+vec2(.5,1.73/2.)-uv),\n          l11 = length(U+vec2(1.5,1.73/2.)-uv),\n            l = min(min(l00, l10), min( l01, l11)); // closest node: l=dist, C=coord\n    vec2 C = U+ ( l==l00 ? vec2(0) : l==l10 ? vec2(1,0) : l==l01 ? vec2(.5,1.73/2.) : vec2(1.5,1.73/2.) );\n    U = uv-C;\n    float  s = 2.*mod(ceil(C.x+C.y),2.)-1.,\n           r = length(U)/(1.73/2.)*3.,\n           a = atan(U.y,U.x) - 3.*iTime;\n            //  spiral                   // fade with radius   // rainbow color scheme\n    O = pow(.5+.5*s*sin(8.*log(r)+a),1.) * exp(-.3*r*r) * sin(r+vec4(1,2.1,-2.1,0));\n    // variant:  .5*(    ...      s*a\n\n    \n/*\n    U = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);   // screenspace local coords (centered)\n          r = length(U)/(1.73/2.)*3., // discs r=1 in contact     // to polar coords\n          a = atan(U.y,U.x) - iTime*sign(g.z); \n\n    O = pow(.5+.5*sign(g.z)*sin(4.*log(r)+a),10.) +O-O;\n*/\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 173, 212, 212, 1818]], "test": "valid"}
{"id": "ldKXzy", "name": "Test_3_rgb_hsv", "author": "qufangliu", "description": "//Try to convert RGB to HSV\n//Try to convert HSV to RGB", "tags": ["rgb", "hsv"], "likes": 1, "viewed": 95, "published": "Public", "date": "1465212814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//RGB:Red Green Blue -> çº¢ç»¿è“\n//HSV:Hue Saturation Value -> è‰²ç›¸ é¥±å’Œåº¦ è‰²è°ƒ\n\n//Try to convert RGB to HSV\nvec3 RGBToHSV(vec3 rgb)\n{\n\tvec3 HSV = vec3(0.0, 0.0, 0.0);\n    float RGB_Max = max(rgb.x, max(rgb.y, rgb.z));\n    float RGB_Min = min(rgb.x, min(rgb.y, rgb.z));\n    \n    if (rgb.x == RGB_Max)\n    {\n        HSV.x = (rgb.y - rgb.z)/(RGB_Max - RGB_Min);\n    }\n    if (rgb.y == RGB_Max)\n    {\n        HSV.x = 2.0 + (rgb.z - rgb.x)/(RGB_Max - RGB_Min);\n    }\n    if (rgb.z == RGB_Max)\n    {\n        HSV.x = 4.0 + (rgb.x - rgb.y)/(RGB_Max - RGB_Min);\n    }\n    HSV.x = HSV.x * 60.0;\n    if (HSV.x < 0.0)\n    {\n        HSV.x = HSV.x + 360.0;\n    }\n    HSV.z = RGB_Max;\n    HSV.y = (RGB_Max - RGB_Min) / RGB_Max;\n    \n    return HSV;\n}\n\n//Try to convert HSV to RGB\nvec3 HSVToRGB(vec3 hsv)\n{\n    vec3 RGB = vec3(0.0, 0.0, 0.0);\n    if (hsv.y == 0.0)\n    {\n        RGB.x = hsv.z;\n        RGB.y = hsv.z;\n        RGB.z = hsv.z;\n    }\n    else {\n        hsv.x = hsv.x / 60.0;\n        int i = int(hsv.x);\n        float f = hsv.x - float(i);\n        float a = hsv.z * (1.0 - hsv.y);\n        float b = hsv.z * (1.0 - hsv.y * f);\n        float c = hsv.z * (1.0 - hsv.y * (1.0 - f));\n        \n        if (i == 0)\n        {\n            RGB.x = hsv.z;\n            RGB.y = c;\n            RGB.z = a;\n        }\n        else if (i == 1)\n        {\n            RGB.x = b;\n            RGB.y = hsv.z;\n            RGB.z = a;\n        }\n        else if (i == 2)\n        {\n            RGB.x = a;\n            RGB.y = hsv.z;\n            RGB.z = c;\n        }\n        else if (i == 3)\n        {\n            RGB.x = a;\n            RGB.y = b;\n            RGB.z = hsv.z;\n        }\n        else if (i == 4)\n        {\n            RGB.x = c;\n            RGB.y = a;\n            RGB.z = hsv.z;\n        }\n        else\n        {\n            RGB.x = hsv.z;\n            RGB.y = a;\n            RGB.z = b;\n        }\n    }\n    return RGB;\n}\n\n//Test convert\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    if (fragCoord.x > 260.0)\n    {\n        vec3 rgb1 = vec3(fragColor.x, fragColor.y, fragColor.z);\n    \tvec3 hsv = RGBToHSV(rgb1);\n    \thsv.z *= 1.1;\n    \tvec3 rgb2 = HSVToRGB(hsv);\n    \tfragColor = vec4(rgb2, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 152, 177, 177, 779], [781, 809, 834, 834, 1941], [1943, 1958, 2015, 2015, 2333]], "test": "valid"}
{"id": "ldySzt", "name": "My First Raymarch Shader", "author": "gunnarclovis", "description": "My second day tinkering with shaders at all and my first raymarching shader. Change definitions to affect effect. Mouse position to control. I suggest vanilla settings and the mouse on the left side of the screen when beginning.", "tags": ["3d", "mouse", "raymarch"], "likes": 1, "viewed": 630, "published": "Public API", "date": "1465975269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// change MODE to 0, 1\n// suggest changing ROT_SPEED to 0 when using MODE 1\n#define MODE 0\n// rotation speed\n// make negative to reverse direction\n// may cause stuttering/skipping if abs(ROT_SPEED) > 1\n#define ROT_SPEED 0.25\n\n// active movement axises\n#define MOVE_X false\n#define MOVE_Y true\n#define MOVE_Z true\n\n// increase RANGE for new hidden effects to find with mouse\n#define RANGE 1.0\n// marching iterations\n// depends on complexity of the scene\n// 16, 32 good values\n#define ITERATIONS 32\n// z-value\n// make negative to reverse direction\n#define Z 1.0\n// whether or not to tint with RGB color values over time\n// play with values at bottom of mainImage function\n#define RGB_TINT false\n\n// map function return a scalar from a point\nfloat map(vec3 point)\n{\n    if(MODE == 0)\n    {\n        // instancing\n        // transform the space into repeating coordinate system\n    \tvec3 q = fract(point) * 2.0 - RANGE * (1.0 - smoothstep(0.0, iResolution.x, iMouse.x));\n        // length of point minus radius\n        return length(q) - RANGE * (1.0 - smoothstep(0.0, iResolution.y, iMouse.y));\n    }\n    // Basic sphere\n    else\n    {\n        return length(point) - 5.0 * smoothstep(0.0, iResolution.x, iMouse.x);\n    }\n}\n\n// numerical marching algorithm\n// march along ray from origin\nfloat trace(vec3 origin, vec3 ray)\n{\n    float intersection = 0.0;\n    \n    for(int i = 0; i < ITERATIONS; ++i)\n    {\n        // calculate position on the array\n        // gradually converge to the intersection\n        vec3 point = origin + ray * intersection;\n        \n        float d = map(point);\n        // accumulate\n        intersection += d * 0.5;\n    }\n    \n    return intersection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate uv coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Transform the coordinates to go from -1.0 to 1.0 instead of default 0.0 to 1.0 pixel shader coordinates\n    uv = uv * 2.0 - 1.0;\n    \n    // aspect ratio correction to create sphere instead of ovoid\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // create normalized ray with z value to project uv into 3D space\n    vec3 ray = normalize(vec3(uv, Z));\n    \n    // basic rotation\n    float rotation = iTime * ROT_SPEED;\n    ray.xz *= mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n    \n    // origin z-value iTime sets back from the sphere\n    vec3 origin;\n    if(MODE == 0)\n    {\n        origin = vec3(0.0);\n        \n        if(MOVE_X) origin.x = iTime;\n        if(MOVE_Y) origin.y = iTime;\n        if(MOVE_Z) origin.z = iTime;\n    }\n    // set z to -3.0 if sphere to be visible\n    else\n    {\n        origin = vec3(0.0, 0.0, -3.0);\n    }\n    \n    \n    // trace ray from origin\n    float t = trace(origin, ray);\n    \n    // simple fogging function to render\n    // the further away something is the darker it gets\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n    // RGB tint\n    if(RGB_TINT)\n    {\n        fc.r += 0.0 + 0.1 * sin(iTime * 1.0);\n        fc.g += 0.0 + 0.1 * cos(iTime * 1.0);\n        fc.b += 0.0 + 0.1 * cos(iTime * 1.5);\n    }\n    \n    // Set fragColor output\n\tfragColor = vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldySzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[694, 739, 762, 762, 1218], [1220, 1283, 1319, 1319, 1675], [1677, 1677, 1734, 1766, 3182]], "test": "valid"}
{"id": "ldyXD3", "name": "Lasers", "author": "Kali", "description": "lasers", "tags": ["lasers"], "likes": 16, "viewed": 571, "published": "Public", "date": "1466980380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t=iTime*.1;\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy-.5;\n\tvec2 ouv=uv;\n\tuv.x*=iResolution.x/iResolution.y;\n\tvec3 rd=normalize(vec3(uv,2.));\n\trd.xy*=mat2(cos(t),sin(t),-sin(t),cos(t));\n\tvec3 ro=vec3(t+sin(t*6.53583)*.05,.01+sin(t*352.4855)*.0015,-t*3.);\n\tvec3 p=ro;\n\tfloat v=0., td=-mod(ro.z,.005);\n\tfor (int r=0; r<150; r++) {\n\t\tv+=pow(max(0.,.01-length(abs(.01-mod(p,.02))))/.01,10.)*exp(-2.*pow((1.+td),2.));\n\t\tp=ro+rd*td;\n\t\ttd+=.005;\n\t}\n\tfragColor = vec4(v,v*v,v*v*v,0.)*8.*max(0.,1.-length(ouv*ouv)*2.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 578]], "test": "valid"}
{"id": "ldyXWy", "name": "Smooth lighting", "author": "MajortomVR", "description": "Smooth lighting.", "tags": ["lighting", "smoothlighting"], "likes": 8, "viewed": 172, "published": "Public", "date": "1466271421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 lightPosition = vec3(sin(iTime) + 0.5, 0.5, 0.0);\n    vec3 testPosition  = vec3(uv.x, uv.y, 1.2);\n    \n    float lightDistance = length(testPosition - lightPosition);\n    \n    vec3 surfaceToLightVector = normalize(testPosition - lightPosition);\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n    \n    float cosTheta = clamp(dot(normal, surfaceToLightVector), 0.0, 1.0);\n    \n    vec3 materialColor \t= vec3(0.5 + sin(iTime * 0.3) * 0.5, 0.5 + sin(iTime * 0.2 ) * 0.5, 1.0);\n    vec3 color \t\t\t= vec3(1.0, 1.0, 1.0) * cosTheta / (lightDistance * lightDistance);\n        \n\tfragColor = vec4(materialColor * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 722]], "test": "valid"}
{"id": "lsGSDK", "name": "VCI Logo", "author": "jsb", "description": "bla", "tags": ["stfu"], "likes": 12, "viewed": 614, "published": "Public API", "date": "1466607551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float det(in vec2 a, in vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat inCircle(in vec2 fragCoord, in vec2 center, in float radius)\n{\n    return smoothstep(-0.5, 0.5, radius - length(fragCoord - center));\n}\n\nfloat inCenteredCircle(in vec2 fragCoord, in float radius)\n{\n    vec2 screenCenter = iResolution.xy / 2.0;\n    return inCircle(fragCoord, screenCenter, radius);\n}\n\nfloat inCenteredRing(in vec2 fragCoord, in float innerRadius, in float outerRadius)\n{\n    return min(inCenteredCircle(fragCoord, outerRadius), 1.0 - inCenteredCircle(fragCoord, innerRadius));\n}\n\nfloat inCenteredSector(in vec2 fragCoord, in vec2 startDir, in vec2 endDir)\n{\n    vec2 screenCenter = iResolution.xy / 2.0;\n    vec2 dir = (fragCoord - screenCenter);\n    float startDist = det(startDir, dir);\n    float endDist = det(dir, endDir);\n    if (det(startDir, endDir) > 0.0) {\n        return smoothstep(-0.5, 0.5, min(startDist, endDist));\n    }\n    else {\n        return smoothstep(-0.5, 0.5, max(startDist, endDist));\n    }\n}\n\nfloat inCenteredRingSector(in vec2 fragCoord, in vec2 startDir, in vec2 endDir, in float innerRadius, in float outerRadius)\n{\n    return min(inCenteredRing(fragCoord, innerRadius, outerRadius), inCenteredSector(fragCoord, startDir, endDir));\n}\n\nfloat inCenteredWorm(in vec2 fragCoord, in vec2 startDir, in vec2 endDir, in float innerRadius, in float outerRadius)\n{\n    float wormRadius = (outerRadius - innerRadius) / 2.0;\n    vec2 screenCenter = iResolution.xy / 2.0;\n    vec2 wormStart = screenCenter + startDir * ((outerRadius + innerRadius) / 2.0);\n    vec2 wormEnd   = screenCenter + endDir   * ((outerRadius + innerRadius) / 2.0);\n    return max(\n        max(inCircle(fragCoord, wormStart, wormRadius), inCircle(fragCoord, wormEnd, wormRadius)),\n        inCenteredRingSector(fragCoord, startDir, endDir, innerRadius, outerRadius)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const int numRings = 6;\n    float screenScale = iResolution.y / 1024.0;\n    float scale = screenScale * 4.0 * (1.0 - cos(9.0 * iTime) * exp(-3.0 * iTime));\n    float initialRadius = 19.750  * scale;\n    float ringWidth     = 12.125 * scale;\n    \n\tvec3 color = vec3(1.0);\n    fragColor = vec4(color, 1.0);\n    \n    vec2 center = iResolution.xy / 2.0;\n    if (length(fragCoord - center) > initialRadius + float(numRings + 2) * ringWidth) {\n        return;\n    }\n    \n    vec3 colors[6];\n    colors[0] = vec3(255.0/255.0, 237.0/255.0,   0.0/255.0); // yellow\n    colors[1] = vec3(246.0/255.0, 168.0/255.0,   0.0/255.0); // orange\n    colors[2] = vec3(216.0/255.0,  92.0/255.0,  65.0/255.0); // red\n    colors[3] = vec3(122.0/255.0, 111.0/255.0, 172.0/255.0); // purple\n    colors[4] = vec3(142.0/255.0, 186.0/255.0, 229.0/255.0); // blue\n    colors[5] = vec3( 87.0/255.0, 171.0/255.0,  39.0/255.0); // green\n    \n    float outerRadius = initialRadius;\n    for (int i = 0; i < numRings; ++i) {\n        float innerRadius = outerRadius;\n        outerRadius = innerRadius + ringWidth * (1.0 - cos(float(8 - i) * iTime) * exp(-1.0 * iTime));\n        \n        float seed1 = texture(iChannel0, vec2((float(i) + 0.5) / 64.0, 0.5 / 64.0)).r * 2.0 - 0.5;\n        float seed2 = texture(iChannel0, vec2((float(i) + 0.5) / 64.0, 1.5 / 64.0)).r * 2.0 - 0.5;\n        float seed3 = texture(iChannel0, vec2((float(i) + 0.5) / 64.0, 2.5 / 64.0)).r * 2.0 - 0.5;\n        float seed4 = texture(iChannel0, vec2((float(i) + 0.5) / 64.0, 3.5 / 64.0)).r * 2.0 - 0.5;\n        \n        float startAngle1 = sin(0.1 * iTime * seed1 + seed2 * 3.1415) * 3.1415 * 2.0;\n    \tfloat endAngle1   = startAngle1 + 0.5 * 3.1415 * 2.0;\n        float startAngle2 = startAngle1 + 0.4 * sin(0.1 * iTime * seed3 + seed4 * 3.1415) * 3.1415 * 2.0;\n    \tfloat endAngle2   = startAngle2 + 0.5 * 3.1415 * 2.0;\n        \n        vec2 startDir1 = vec2(cos(startAngle1), sin(startAngle1));\n        vec2 endDir1   = vec2(cos(endAngle1),   sin(endAngle1));\n        vec2 startDir2 = vec2(cos(startAngle2), sin(startAngle2));\n        vec2 endDir2   = vec2(cos(endAngle2),   sin(endAngle2));\n        \n        float intensity = 0.5 * inCenteredWorm(fragCoord, startDir1, endDir1, innerRadius, outerRadius)\n                        + 0.5 * inCenteredWorm(fragCoord, startDir2, endDir2, innerRadius, outerRadius);\n    \tcolor = mix(color, colors[i], intensity);\n    }\n    color = mix(color, vec3(0.0), inCenteredCircle(fragCoord, initialRadius));\n    \n    // eye glint\n    float glintInnerRadius = initialRadius * 0.4;\n    float glintOuterRadius = initialRadius * 0.62;\n    vec2 glintStart1 = normalize(vec2(3,1));\n    vec2 glintEnd1   = normalize(vec2(5,4));\n    vec2 glintStart2 = normalize(vec2(4,5));\n    vec2 glintEnd2   = normalize(vec2(0,1));\n    color = mix(color, vec3(1.0), inCenteredRingSector(fragCoord, glintStart1, glintEnd1, glintInnerRadius, glintOuterRadius));\n    color = mix(color, vec3(1.0), inCenteredRingSector(fragCoord, glintStart2, glintEnd2, glintInnerRadius, glintOuterRadius));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 69], [71, 71, 139, 139, 212], [214, 214, 274, 274, 376], [378, 378, 463, 463, 571], [573, 573, 650, 650, 1009], [1011, 1011, 1136, 1136, 1254], [1256, 1256, 1375, 1375, 1855], [1857, 1857, 1912, 1912, 4997]], "test": "error"}
{"id": "lsGXRK", "name": "test line", "author": "jpweiyi", "description": "\ntest line\n", "tags": ["testline"], "likes": 1, "viewed": 103, "published": "Public", "date": "1465310577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float n)\n{\n   \treturn fract(sin(n)*43758.5453);\n}\n\nfloat mod289(float x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(float p){\n    float fl = floor(p);\n  \tfloat fc = fract(p);\n    fc = fc * fc * (3.0 - 2.0 * fc);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix( mix(rand(b), \t\trand(b + d.yx), f.x), \n                mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n     vec2 a2b = b - a;\n     vec2 a2p = p - a;     \n     \n     // å› ä¸ºæŠ•å½± proj(a2p,a2b) ç­‰äºŽ dot(a2p,a2b) / length(a2b)\n     // åœ¨æŠŠæŠ•å½±çš„å€¼å’Œa2bå‘é‡åšæ¯”ä¾‹å…³ç³»ã€‚\n     // æ‰€ä»¥proj(a2p,a2b)/length(a2b) ç­‰äºŽ dot(a2p,a2b)/dot(a2b,a2b)\n     \n     float h = clamp( dot(a2p,a2b)/dot(a2b,a2b), 0.0, 1.0 );\n     vec2 p1 = mix( a, b, h );\n     return length( p1 - p );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    //uv.y += noise(uv.x*40.0+iTime*5.) * 0.02;\n    uv += noise(uv*40.0+iTime*5.) * 0.02;\n    \n    float t = line(uv, vec2(0.02,0.5),vec2(1.75,0.5));\n    //float t = line(uv, vec2(0.5,0.02),vec2(0.5,1.0));\n\tfragColor = vec4(0.05, 0.15, 1.0, 1.0)*.015/t;\n    \n    //fragColor = vec4(vec3(noise(uv*50.)), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 60], [62, 62, 85, 85, 136], [139, 139, 159, 159, 229], [231, 231, 252, 252, 386], [388, 388, 409, 409, 634], [637, 637, 673, 673, 1151], [1153, 1153, 1210, 1210, 1621]], "test": "valid"}
{"id": "lsKSD3", "name": "L1 - Gr", "author": "bradleygriffith", "description": "L1", "tags": ["shader"], "likes": 0, "viewed": 74, "published": "Public", "date": "1467170990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime / 1.0;\n    float heatDistanceScale = 6.5; // Larger equates to smaller spread\n\n    \n    // Create heat points\n    // --------------------------------\n    \n    // Define 3 heat points\n    float heatPoint1X = (0.5 + sin(time * 1.05) / 4.0);\n    float heatPoint1Y = (0.5 - cos(time * 2.5) / 4.0);\n    vec2 heatPoint1Uv = vec2(heatPoint1X, heatPoint1Y);\n    \n    float heatPoint2X = (0.5 + sin(time * 1.0) / 4.0);\n    float heatPoint2Y = (0.5 - cos(time * 2.0) / 4.0);\n    vec2 heatPoint2Uv = vec2(heatPoint2X, heatPoint2Y);\n    \n    float heatPoint3X = (0.5 + sin(time * 3.0) / 4.0);\n    float heatPoint3Y = (0.5 - cos(time * 0.5) / 4.0);\n    vec2 heatPoint3Uv = vec2(heatPoint3X, heatPoint3Y);\n    \n    // Calculate distances from current UV and combine\n    float heatPoint1Dist = distance(uv, heatPoint1Uv);\n    float heatPoint2Dist = distance(uv, heatPoint2Uv);\n    float heatPoint3Dist = distance(uv, heatPoint3Uv);\n    float combinedDist = (heatPoint1Dist) * (heatPoint2Dist) * (heatPoint3Dist);\n\t\n    // Invert and scale\n    float amount = 1.0 - smoothstep(0.05, 0.295, combinedDist * heatDistanceScale);\n\n    \n    fragColor = vec4(vec3(amount), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1284]], "test": "valid"}
{"id": "lsKXDK", "name": "Bernstein", "author": "zlnimda", "description": "Evaluation of the bernstein polynomial", "tags": ["polynomial"], "likes": 6, "viewed": 485, "published": "Public API", "date": "1466776232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Define the degree of the polynomial\n#define M 16\n#define PI 3.141592\n\n// Approximation factorial\nfloat fact(float x)\n{\n   x = max(x, 1.0);\n   return sqrt(2.*PI*x)*pow(x/exp(1.), x)*exp(1./(12.*x)-1./(360.*pow(x,3.)));\n}\n\n// eval of the binomial coef\nfloat binomial(float n, float k)\n{\n    return fact(n) / (fact(k) * fact(n-k));\n}\n\n// eval of bernstein polynomial, following this formula :\n//  bern(m,i) (u) = C(m,i) * u^i * (1-u)^(m-i)\n//  - with C(m,i) a binomial coef following this formula :\n//    C(n,k) = n!/(k!(n-k)!)\nfloat bern(float u, float i, float m)\n{\n    return binomial(m, i) * pow(u, i) * pow(1. - u, m - i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord.x *= 1.5;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat d = 100.;\n    \n    float m = float(M);\n    for (int i = 0; i <= M; i++)\n    {\n        vec2 ev = vec2(uv.x, bern(uv.x, float(i), m));\n        d = min(d, distance(ev * 100., uv * 100.));\n    }\n    \n    vec2 ev = vec2(uv.x, bern(uv.x, abs(mod(iTime * 3.0, m * 2.) - m), m));\n    vec3 color = vec3(1. - d);\n    d = min(1. - distance(ev * 100., uv * 100.), 0.);\n    color += vec3(d, d, 0.);\n    fragColor = vec4(color, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKXDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 100, 121, 121, 222], [224, 253, 287, 287, 333], [335, 528, 567, 567, 629], [631, 631, 688, 714, 1184]], "test": "valid"}
{"id": "lsKXWc", "name": "metalNoise", "author": "glkt", "description": "testing noise", "tags": ["noise"], "likes": 12, "viewed": 319, "published": "Public", "date": "1467205498", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    p.y /= iResolution.x / iResolution.y ; // ratio - independent noise\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n    float v = mix( mix( hash( i + vec2(0.,0.) ), \n                     hash( i + vec2(1.,0.) ), u.x),\n                mix( hash( i + vec2(0.,1.) ), \n                     hash( i + vec2(1.,1.) ), u.x), u.y);\n    return pow(abs(cos(v)),10.);\n}\n\nfloat noiseLayer(vec2 uv) {\n    float freq = 10.; // noise base frequency / size\n    const int iter = 14; // noise iteration / depth\n    float lacunarity = 0.7; // lacunarity: relative \"importance\" of smaller octaves\n    float v = 0.;\n    float sum = 0.;\n    for(int i = 0; i < iter; i++) {\n        float layerUp = 1. / pow(freq,lacunarity);\n    \tv += noise(uv*freq) * layerUp;\n        sum += layerUp;\n\t\tfreq *= 2.0896;\n    }\n    v /= sum;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x += noiseLayer(uv*0.1+iTime/800.);    \n    uv.y += noiseLayer(uv*0.1+iTime/900.);\n    \n    float v = noiseLayer(uv-vec2(iMouse.x,iMouse.y)/200.+iTime/800.);\n        \n    v = v*v*2.;\n    \n    fragColor = vec4(v);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 102], [104, 104, 130, 130, 533], [535, 535, 562, 562, 990], [992, 992, 1049, 1049, 1319]], "test": "valid"}
{"id": "lsKXzy", "name": "2D Sheap Cellular Tile Layers", "author": "aiekick", "description": "2D Sheap Cellular Tile based on the shane version [url=https://www.shadertoy.com/view/MdKXDD]One Tweet Cellular Pattern[/url]", "tags": ["2d", "cellular", "tile", "sheap"], "likes": 5, "viewed": 667, "published": "Public API", "date": "1465213910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(vec2 p, float t)\n{\n\tp = fract(p/70.+vec2(cos(t), sin(t)))-0.5;\n\treturn  min(abs(p.x), abs(p.y)) + 0.2;\n}\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p /= 3.; \n    \n    o -= o;\n    \n    mat2 m = mat2(10., -5.4, 5.4, 10.) * 0.09;\n    \n\tfloat t = iTime * 0.1;\n\n\tconst float iter = 3.;\n\tfloat lay = 0., olay;\n\tfor (float i = 0.; i < iter; i++)\n\t{\n\t\tlay = f(p, t * 10. * i / iter);\n\t\tif (i > 0.)\tlay = min(olay, lay); olay = lay;\n\t\tp *= m;\n\t}\n    o += lay;\n\t\n\to /= 0.53;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 112], [114, 114, 155, 155, 478]], "test": "valid"}
{"id": "lsVSDK", "name": "My first ray marching shader :D", "author": "Jespertheend", "description": ":D\nThanks to cabbio for his nice tutorial! https://www.shadertoy.com/view/Xl2XWt", "tags": ["3d", "raymarching", "simple"], "likes": 5, "viewed": 651, "published": "Public API", "date": "1466769472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FAR_CLIPPING = 10.0;\nconst float HIT_PRECISION = 0.001;\nconst int MAX_RAY_STEPS = 100;\n\nfloat sdSphere(vec3 p, float s){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU(vec2 d1, vec2 d2){\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 pos){\n    float bigColor = (cos(pos.x*40.)*.5)*10.;\n    bigColor = min(1.,max(0.,bigColor));\n    bigColor *= .3-pos.y*.5;\n    vec2 res = vec2( sdSphere(pos, 1.), bigColor);\n    for(int i=0; i<60; i++){\n        float rot = float(i);\n        const float dist = 1.4;\n        vec3 spherePos = vec3(cos(rot)*dist, cos(rot*87.), sin(rot)*dist);\n        res = opU(res, vec2( sdSphere(pos - spherePos, .1), pos.y*.5+.5));\n    }\n    return res;\n}\n\nvec2 checkRayHit(in vec3 pos, in vec3 dir){\n    float h = HIT_PRECISION*2.;\n    float t = 0.;\n    float res = -1.;\n    float id = -1.;\n    \n    for(int i=0; i<MAX_RAY_STEPS; i++){\n        if(h < HIT_PRECISION || t > FAR_CLIPPING) break;\n        vec2 m = map(pos+dir*t);\n        t += m.x;\n        id = m.y;\n    }\n    \n    if(t<FAR_CLIPPING) res = t;\n    if(t>FAR_CLIPPING) id = -1.;\n    \n    return vec2(res,id);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ){\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nconst float CAM_DIST = 3.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    float camRot = iTime + iMouse.x*.01;\n    \n    vec3 camPos = vec3(cos(camRot)*CAM_DIST, 0., sin(camRot)*CAM_DIST);\n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0.,0.,0.), 0.);\n    vec3 ray = normalize(camMat * vec3(uv.xy,2.));\n    vec2 res = checkRayHit(camPos, ray);\n    vec3 color = vec3(res.y);\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 132, 132, 158], [160, 160, 191, 191, 278], [280, 280, 307, 307, 343], [345, 345, 364, 364, 796], [798, 798, 841, 841, 1211], [1213, 1213, 1276, 1276, 1454], [1484, 1484, 1538, 1538, 1948]], "test": "valid"}
{"id": "lsVSDy", "name": "cheap geometry based outlines.", "author": "pyrite", "description": "This demo shows how to implement a cheap geometry based outline. Details on lines 26, 38.\nThe outline information simply tracks the nearest approach to an object in the scene, if the ray passes closely, it is colored black.", "tags": ["cellshading", "outlines", "ssaa", "outline"], "likes": 10, "viewed": 1260, "published": "Public", "date": "1466458019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Austin Kootz - pyrite/2015\n// SSAA implentation created by iq/2013. (Many thanks!)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Four spheres colored by surface location. For\n// reference and fun.\n\n\n\n// antialias level (try 1, 2, 3, ...)\n#define AA 1\n\n// exponential smooth min (k = 32);\nfloat esmin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// power smooth min (k = 8);\nfloat psmin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n\nfloat sphere(in vec3 ro, in vec3 sp, in float sr){\n    return length(ro-sp)-sr;\n}\n\nfloat rcylinder( in vec3 ro, in vec3 sp, in float sr)\n{\n  vec2 h = sr*vec2(1.0,0.5);\n  vec3 p = ro-sp;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-0.5;\n}\n\n\n        \n        \n\nfloat map(in vec3 ro){\n    \n    return min(sphere(ro, vec3(0.0,0.0,0.0), 1.5),\n               min(sphere(ro,vec3(-2,0.5,0.5),1.0), \n                   min(sphere(ro,vec3(0.5,-2,0.5),1.0),sphere(ro,vec3(0.5,0.5,-2),1.0))));\n}\n\nvec3 scene(in vec3 ro,in vec3 rd){\n    vec3 col = vec3(0);\t\t// initialize color return value\n    float rv = map(ro);\t\t//ray value\n    float rm = rv; \t\t\t//tracker for minimum ray value\n    float ow = 0.1; \t\t//outline width\n    for (int s =0; s<50; s++){\n       \trm = min(rv,rm);\n       \tro += rd*rv*0.9;\n        rv = max(map(ro),0.009);\n        if (rv<0.01){\n            float edge = map(ro);\n            //color based on suface location\n            col = vec3(ro.x,ro.y,ro.z);\n            break;\n        }\n        //check if a ray has passed through an outline region\n        if (rv > rm && rm < ow){\n            col = vec3(0); //outline\n            break;\n        }\n    }\n    if (rm > ow && rm < rv){\n        col += 0.9; //bright background to simulate additional scene information.\n    }\n\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    // camera\n    float an = 0.5*iTime - 5.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(6.0*sin(3.0*an),6.0*cos(2.0*an),6.0*cos(3.0*an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {   \n        //create p for ray based on AA settings\n        vec3 p = vec3((-iResolution.xy + 2.0*(fragCoord.xy-0.5+(vec2(float(m),float(n))+0.5)/float(AA))) / iResolution.y,2.0);\n    \t\n        \n        //create view ray from vector p\n        vec3 rd = normalize( p.x*uu + p.y*vv + p.z*ww );\n        \n        //render scene\n        vec3 col = scene(ro,rd);\n        \n        //vignette\n        col -= 0.2*length(p.xy);\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVSDy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[312, 348, 390, 390, 461], [462, 498, 539, 539, 632], [633, 662, 704, 704, 782], [785, 785, 835, 835, 866], [868, 868, 923, 923, 1073], [1095, 1095, 1117, 1117, 1319], [1321, 1321, 1355, 1355, 2134], [2137, 2137, 2194, 2194, 3136]], "test": "valid"}
{"id": "lsVXz3", "name": "Blue berry", "author": "gigatron", "description": "This is a mixed fx from zavie and optimus fx number 4", "tags": ["wobble", "deform", "skew"], "likes": 3, "viewed": 174, "published": "Public", "date": "1465838992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float h00(float x) { return 2.*x*x*x - 3.*x*x + 1.; }\nfloat h10(float x) { return x*x*x - 2.*x*x + x; }\nfloat h01(float x) { return 3.*x*x - 2.*x*x*x; }\nfloat h11(float x) { return x*x*x - x*x; }\n\nfloat Hermite(float p0, float p1, float m0, float m1, float x)\n{\n\treturn p0*h00(x) + m0*h10(x) + p1*h01(x) + m1*h11(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tfloat a = sin(iTime * 1.0)*0.5 + 0.5;\n\tfloat b = sin(iTime * 1.5)*0.5 + 0.5;\n\tfloat c = sin(iTime * 2.0)*0.5 + 0.5;\n\tfloat d = sin(iTime * 2.5)*0.5 + 0.5;\n\t\n\tfloat y0 = mix(a, b, uv.x);\n\tfloat y1 = mix(c, d, uv.x);\n\tfloat x0 = mix(a, c, uv.y);\n\tfloat x1 = mix(b, d, uv.y);\n\n\tuv.x = Hermite(0., 1., 3.*x0, 3.*x1, uv.x);\n\tuv.y = Hermite(0., 1., 3.*y0, 3.*y1, uv.y);\n\n\t\n\t vec3 color;\n\t \n\tvec3 tc=texture(iChannel0,uv).xyz;\n   \n    float gradient,angle,fade = 0.0;\n\t \n // Thx to Zavie, Optimus !\n \n    \n    \n    float u,v;\n\tfloat z;\n \n    vec2 coord = mod(uv,1.0);\n    \n\tvec2 centered_coord = coord - vec2(0.5);\n\n\tfloat dist_from_center = length(centered_coord);\n\tfloat angle_from_center = atan(centered_coord.y, centered_coord.x);\n    \n    \n    float dist_from_center_y = length(centered_coord.y);\n\t\t\tu = 8.0/dist_from_center_y + 16.0*iTime;\n\t\t\tv = (16.0/dist_from_center_y)* centered_coord.x + sin(iTime) * 8.0;\n\t \n\t\t\tfade = dist_from_center_y * 2.0;\n\t\t\tgradient = ((1.0 - pow(sin(u) + 1.0, 0.1)) + (1.0 - pow(sin(v) + 0.0, 0.2))) * fade;\n\t\t\tcolor = vec3(tc+gradient);\n    \n    \n      fragColor = vec4(color,1.0);\n    \n\n    \n    \n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 53], [54, 54, 74, 74, 103], [104, 104, 124, 124, 152], [153, 153, 173, 173, 195], [197, 197, 261, 261, 318], [320, 320, 377, 377, 1551]], "test": "error"}
{"id": "lsySWw", "name": "Lunar Debris", "author": "Shane", "description": "Running a camera through a random debris field.", "tags": ["field", "cellular", "tile", "flythrough", "debris"], "likes": 59, "viewed": 1819, "published": "Public API", "date": "1464788076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tLunar Debris\n\t------------\n\n\tJust playing around a little more with 3D cellular tiling to create some random rocks floating\n\taround in space. The distance field is analogous to raymarched, mutated Voronoi. \n\n\tCompared to genuine raymarched Voronoi, the framerate isn't too bad, but I think it can be\n\timproved upon. I'll take a closer look at it to see if I can increase it a bit.\n\n\tThe trickiest thing to deal with was not the rocky field itself, but rather negotiating through\n\tit in a way that gives the appearance that the camera is naturally avoiding obstacles. I tried\n\ta few different things but smoothly negating space with a squashed diamond tube seemed to \n\tproduce the desired result. Anyway, the process is simple and is contained in the distance \n\tfunction.\n\n\n\tOther examples:\n\n\t// Very stylish.\n\tDusty Thing - kuvkar\n    https://www.shadertoy.com/view/XlBXRt\n\n\t// Love the way this is done.\n\tMoon Rock - foxes\n\thttps://www.shadertoy.com/view/4s33RX\n\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Uses smooth combinations (smin, smax, etc) to smooth the rock joins.\n#define SMOOTHING \n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// IQ's smooth minium function. \nvec2 sminP(vec2 a, vec2 b , float s){\n    \n    vec2 h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// IQ's smooth minium function. \nfloat sminP(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-.5;\n    return dot(p, p);\n    \n}\n\n   \nfloat cellTile(in vec3 p){\n\n   \n    vec4 v, d; \n    \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.12, .62, .64));\n\n\t// Obtaining the minimum distance.\n    #ifdef SMOOTHING\n    v.xy = sminP(d.xz, d.yw, .05); \n    #else\n    v.xy = min(d.xz, d.yw);\n    #endif\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    #ifdef SMOOTHING\n    return  sminP(v.x, v.y, .05)*2.5; \n    #else\n    return  min(v.x, v.y)*2.5; \n    #endif    \n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    \n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// The debris field. I'll tidy it up later. In general, this is a terrible \n// distance field to hone in on. I'm come back to it later and rework it.\nfloat map(vec3 p){\n    \n    // Warping the whole field around the path.\n    p.xy -= path(p.z);\n    \n    p/=2.;\n    \n    // Mutated, first order cellular object... the rocks.\n    vec3 q = p + (cos(p*2.52 - sin(p.zxy*3.5)))*.2;\n    float sf = max(cellTile(q/5.), 0.); \n    \n    // Mutated squashed diamond tube. Used to run the camera through.\n    p += (cos(p*.945 + sin(p.zxy*2.625)))*.2;\n    #ifdef SMOOTHING\n    float t = .1 - abs(p.x*.05) - abs(p.y);\n    #else\n    float t = .05 - abs(p.x*.05) - abs(p.y);\n    #endif  \n    \n    // Smoothly combine the negative tube space with the rocky field.\n    //p = sin(p*4.+cos(p.yzx*4.));\n    float n = smaxP(t, (.68 - (1.-sqrt(sf)))*2., 1.);// + abs(p.x*p.y*p.z)*.05;\n   \n    // A bit hacky... OK, very hacky. :)\n    return n*3.;\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    return (cellTile(p/2.))*.8 + (cellTile(p*1.5))*.2;\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.0025*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0, 0, iTime*8. + 0.1);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(0, 7, 35.);\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n    /*    \n    // Mouse controls, as per TambakoJaguar's suggestion.\n    // Works better if the line above is commented out.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/ \n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);    \n\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.1);\n        vec3 tsp =  sp;// + vec3(0, 0, iTime/8.);// + vec3(path(sp.z), 0.)\n\n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(tsp, sn, .5);\n        \n       \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);//*.75 + .25;\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    \n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.007); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light, due to light bouncing around the field, I guess.\n\t    float ambience = 0.25;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\n        // Object texturing, coloring and shading.\n\t    vec3 texCol = vec3(.8, .9, 1.);\n\t    texCol *= min(tex3D(iChannel0, sp*tSize0, sn)*3.5, 1.);\n        texCol *= bumpSurf3D(sp, sn)*.5 + .5;\n        \n        // Shadows.\n        float shading = shadows(sp + sn*.005, ld, .05, lDist, 8.);\n\n        // Final color. Pretty simple.\n        sceneCol = texCol*(diff + spec + ambience);\n        \n        // Adding a touch of Fresnel for a bit of space glow... I'm not so\n        // sure if that's a thing, but it looks interesting. :)\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 1.)*.5;\n\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n\n        \n\t   \n\t\n\t}\n       \n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fog = vec3(.6, .8, 1)/2.*(rd.y*.5 + .5);    \n    sceneCol = mix(sceneCol, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsySWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1178, 1330, 1351, 1351, 1417], [1419, 1485, 1535, 1535, 1744], [1746, 1795, 1834, 1834, 1929], [1931, 1964, 2001, 2001, 2096], [2098, 2131, 2171, 2171, 2267], [2269, 2395, 2423, 2423, 2476], [2482, 2482, 2508, 2508, 3121], [3124, 3224, 3246, 3291, 3492], [3495, 3563, 3581, 3581, 3922], [3924, 4074, 4092, 4145, 4853], [4857, 4975, 5015, 5015, 5082], [5084, 5134, 5191, 5191, 5593], [5595, 5782, 5844, 5844, 6354], [6357, 6378, 6414, 6414, 6851], [6853, 7211, 7254, 7254, 7599], [7602, 7795, 7822, 7931, 8091], [8324, 8336, 8416, 8416, 9024], [9027, 9027, 9083, 9109, 14658]], "test": "error"}
{"id": "lsySzd", "name": "Volumetric explosion", "author": "Duke", "description": "Attempt to add animation to the [url=https://www.shadertoy.com/view/MdKXzc]Supernova remnant[/url] shader led to this result.\nPress 1-2-3 to zoom in and zoom out.", "tags": ["cloud", "explosion", "volumetric", "nebula", "supernova"], "likes": 434, "viewed": 34416, "published": "Public API", "date": "1466012454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Volumetric explosion\" by Duke\n// https://www.shadertoy.com/view/lsySzd\n//-------------------------------------------------------------------------------------\n// Based on \"Supernova remnant\" (https://www.shadertoy.com/view/MdKXzc) \n// and other previous shaders \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n// comment this string to see each part in full screen\n#define BOTH\n// uncomment this string to see left part\n//#define LEFT\n\n//#define LOW_QUALITY\n\n#define DITHERING\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat Sphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 4.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = -mod(iTime * 0.2,-2.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricExplosion(vec3 p)\n{\n    float final = Sphere(p,4.);\n    #ifdef LOW_QUALITY\n    final += noise(p*12.5)*.2;\n    #else\n    final += fbm(p*50.);\n    #endif\n    final += SpiralNoiseC(p.zxy*0.4132+333.)*3.0; //1.25;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\n\tfloat VolExplosion = VolumetricExplosion(p/0.5)*0.5; // scale\n    \n\treturn VolExplosion;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n    #ifdef LOW_QUALITY\n\tfor (int i=0; i<56; i++)\n    #else\n    for (int i=0; i<86; i++)\n    #endif\n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.12*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n        \n        #ifdef BOTH\n        /*\n        if (uv.x<0.5)\n        {\n            d = abs(d)+0.07;\n        }\n        */\n        //split screen variant\n        //d = uv.x < 0.5 ? abs(d)+0.07 : d;\n        \n        d = cos(iTime)*uv.x < 0.1 ? abs(d)+0.07 : d;\n        #else\n        #ifdef LEFT\n        d = abs(d)+0.07;\n        #endif\n\t\t#endif\n        \n\t\t// change this string to control density \n\t\td = max(d,0.03);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        \n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2 / lDist;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        // idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uvd = uv;\n        uvd.y*=120.;\n        uvd.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uvd.y,-uvd.x+0.5*sin(4.*iTime+uvd.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size\n        #ifdef LOW_QUALITY\n        t += max(d*0.25,0.01);\n        #else\n        t += max(d * 0.08 * max(min(length(ldst),d),2.0), 0.01);\n        #endif\n        \n        \n\t}\n    \n    // simple scattering\n    #ifdef LOW_QUALITY    \n    sum *= 1. / exp( ld * 0.2 ) * 0.9;\n    #else\n    sum *= 1. / exp( ld * 0.2 ) * 0.8;\n    #endif\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsySzd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[991, 1005, 1031, 1031, 1250], [1252, 1252, 1273, 1273, 1362], [1364, 1364, 1397, 1397, 1423], [1425, 2085, 2113, 2113, 2680], [2682, 2682, 2717, 2717, 2928], [2930, 2930, 2950, 2950, 3082], [3149, 3178, 3228, 3313, 3583], [3585, 3585, 3661, 3661, 3877], [3879, 3994, 4030, 4030, 4194], [4196, 4196, 4253, 4253, 7577]], "test": "error"}
{"id": "lsyXDK", "name": "Type 2 Supernova", "author": "Duke", "description": "Finally I found the time to finish this shader. It is a combination of [url=https://www.shadertoy.com/view/MdKXzc]Supernova remnant[/url] and [url=https://www.shadertoy.com/view/lsySzd]Volumetric explosion[/url] shaders.", "tags": ["cloud", "explosion", "volumetric", "nebula", "supernova", "dust", "remnant", "filament"], "likes": 101, "viewed": 5754, "published": "Public API", "date": "1466613445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Type 2 Supernova\" by Duke\n// https://www.shadertoy.com/view/lsyXDK\n// VR ready version of this shader is here https://www.shadertoy.com/view/XdKSDV (thanks RavenWorks for help)\n//-------------------------------------------------------------------------------------\n// Based on \"Supernova remnant\" (https://www.shadertoy.com/view/MdKXzc)\n// \"Volumetric explosion\" (https://www.shadertoy.com/view/lsySzd)\n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat Sphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 4.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 1.-mod(iTime * 0.1,-1.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricExplosion(vec3 p)\n{\n    float final = Sphere(p,4.);\n    final += noise(p*20.)*.4;\n    final += SpiralNoiseC(p.zxy*fbm(p*10.))*2.5; //1.25;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\n\tfloat VolExplosion = VolumetricExplosion(p/(1.+mod(iTime * 0.1,-1.)))*(1.+mod(iTime * 0.1,-1.)); // scale\n    \n\treturn abs(VolExplosion)+0.07;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn pow(_color, vec3(2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n    for (int i=0; i<86; i++)\n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.11*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        \n        sum.rgb+=(vec3(0.67,0.75,1.00)/(lDist*lDist*15.)/100.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2 / lDist;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        // idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uvd = uv;\n        uvd.y*=120.;\n        uvd.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uvd.y,-uvd.x+0.5*sin(4.*iTime+uvd.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),0.1), 0.01);\n\n\t}\n    \n    // simple scattering\n    sum *= 1. / exp( ld * 0.2 ) * 0.8;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n    \n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyXDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[997, 1011, 1037, 1037, 1256], [1258, 1258, 1279, 1279, 1368], [1370, 1370, 1403, 1403, 1429], [1431, 2091, 2119, 2119, 2688], [2690, 2690, 2725, 2725, 2865], [2867, 2867, 2887, 2887, 3073], [3140, 3169, 3219, 3304, 3574], [3576, 3576, 3652, 3652, 3868], [3870, 3985, 4021, 4021, 4201], [4203, 4203, 4260, 4260, 7350]], "test": "error"}
{"id": "Mdd3D7", "name": "Spiral 222222", "author": "Ultraviolet", "description": "spiral", "tags": ["spiral"], "likes": 8, "viewed": 137, "published": "Public", "date": "1465920302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.0);\n    for(float aaX=.0; aaX < AA; aaX++)\n    {\n    \tfor(float aaY=.0; aaY < AA; aaY++)\n        {\n            vec2 uv = (fragCoord.xy + vec2(aaX, aaY)/AA) / iResolution.y;\n            uv = uv - 0.5*vec2(iResolution.x/iResolution.y, 1.0);\n    \n            float N0 = 7.0;\n            float N1 = 5.0;\n\n            float r = length(uv);\n            float theta = atan(uv.y, uv.x);\n\n            float t0 = log(r) - theta + 0.25*iTime;\n            t0 = t0 / 2.0 / 3.14 + 0.5;\n            t0 = N0*mod(t0, 1.0/N0);\n\n            float t1 = log(r) + theta + 1.0*iTime;\n            t1 = t1 / 2.0 / 3.14 + 0.5;\n            t1 = N1*mod(t1, 1.0/N1);  \n\n            float t=0.0;\n            if(t0 > 0.5)\n                t = 1.0;\n            if(t1 > 0.5)\n                t = 1.0-t;\n            \n\t\t\tfragColor += vec4(vec3(t),1.0);\n        }\n    }\n    \n\tfragColor = fragColor / AA / AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdd3D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 73, 974]], "test": "valid"}
{"id": "MdGSWy", "name": "Musk's Lens Flare v2.", "author": "SolarLiner", "description": "This is an update to Musk's and Icecool's Lens Flare shader. This new one allows for easier customization, with brightness and size control.\n\nUpdate: Barrel distortion for flares", "tags": ["2d", "lens", "flare", "flare2d"], "likes": 34, "viewed": 1975, "published": "Public API", "date": "1466265657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// musk's lense flare, modified by icecool.\n// \"Modularized\" by SolarLiner, with improvements\n// See the original at: https://www.shadertoy.com/view/4sX3Rs \n\n#define ORB_FLARE_COUNT\t6\n#define DISTORTION_BARREL\t\t1.0\n\nvec2 GetDistOffset(vec2 uv, vec2 pxoffset)\n{\n    vec2 tocenter = uv.xy;\n    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));\n    \n    float angle = length(tocenter.xy)*2.221*DISTORTION_BARREL;\n    vec3 oldoffset = vec3(pxoffset,0.0);\n    \n    vec3 rotated = oldoffset * cos(angle) + cross(prep, oldoffset) * sin(angle) + prep * dot(prep, oldoffset) * (1.0-cos(angle));\n    \n    return rotated.xy;\n}\n\nfloat noise(float t)\n{\n\treturn texture(iChannel0,vec2(t, 0.0) / iChannelResolution[0].xy).x;\n}\nfloat noise(vec2 t)\n{\n\treturn texture(iChannel0,(t + vec2(iTime)) / iChannelResolution[0].xy).x;\n}\n\nfloat glare(vec2 uv, vec2 pos, float size)\n{\n    vec2 main = uv-pos;\n\t\n\tfloat ang = atan(main.y, main.x);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\t\n\tfloat f0 = 1.0/(length(uv-pos)*(1.0/size*16.0)+1.0);\n    \n    return f0+f0*(sin((ang)*8.0)*.2+dist*.1+.9);\n}\n\nvec3 flare(vec2 uv, vec2 pos, float dist, float size)\n{\n    pos = GetDistOffset(uv, pos);\n    \n    float r = max(0.01-pow(length(uv+(dist-.05)*pos),2.4)*(1./(size*2.)),.0)*6.0;\n\tfloat g = max(0.01-pow(length(uv+ dist     *pos),2.4)*(1./(size*2.)),.0)*6.0;\n\tfloat b = max(0.01-pow(length(uv+(dist+.05)*pos),2.4)*(1./(size*2.)),.0)*6.0;\n    \n    return vec3(r,g,b);\n}\nvec3 flare(vec2 uv, vec2 pos, float dist, float size, vec3 color)\n{\n    return flare(uv, pos, dist, size)*color;\n}\n\nvec3 orb(vec2 uv, vec2 pos, float dist, float size)\n{\n    vec3 c = vec3(0.0);\n    /*c += flare(uv,pos,dist      ,3.0*size,vec3(1.0,0.8,0.5));\n    c += flare(uv,pos,dist+.1   ,2.0*size,vec3(1.0,0.9,0.8));\n    c += flare(uv,pos,dist+.15  ,1.5*size);\n    c += flare(uv,pos,dist+.155 ,1.25*size,vec3(0.8,0.9,1.0));\n    c += flare(uv,pos,dist+.1555,1.125*size,vec3(0.5,0.8,1.0));*/\n    \n    for(int i=0; i<ORB_FLARE_COUNT; i++)\n    {\n        float j = float(i+1);\n        float offset = j/(j+1.);\n        float colOffset = j/float(ORB_FLARE_COUNT*2);\n        \n        c += flare(uv,pos,dist+offset, size/(j+.1), vec3(1.0-colOffset, 1.0, 0.5+colOffset));\n    }\n    \n    c += flare(uv,pos,dist+.5, 4.0*size, vec3(1.0))*4.0;\n    \n    return c/4.0;\n}\nvec3 orb(vec2 uv, vec2 pos, float dist, float size, vec3 color)\n{\n    return orb(uv,pos,dist,size)*color;\n}\n\nvec3 ring(vec2 uv, vec2 pos, float dist)\n{\n    vec2 uvd = uv*(length(uv));\n    \n    float r = max(1.0/(1.0+32.0*pow(length(uvd+(dist-.05)*pos),2.0)),.0)*00.25;\n\tfloat g = max(1.0/(1.0+32.0*pow(length(uvd+ dist     *pos),2.0)),.0)*00.23;\n\tfloat b = max(1.0/(1.0+32.0*pow(length(uvd+(dist+.05)*pos),2.0)),.0)*00.21;\n    \n    return vec3(r,g,b);\n}\n\nvec3 lensflare(vec2 uv,vec2 pos, float brightness, float size)\n{\n\t/*vec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(main.y, main.x);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\tfloat n = noise(vec2((ang-iTime/9.0)*16.0,dist*32.0));\n\t\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\n\t\n\tf0 = f0+f0*(sin((ang+iTime/18.0 + noise(abs(ang)+n/2.0)*2.0)*12.0)*.1+dist*.1+.8);\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n\tc+=vec3(f0);\n    c.r=f2;c.g=f22;c.b=f23;\n\t\n\treturn c;*/\n    \n    vec3 c = vec3(glare(uv,pos,size));\n    c += flare(uv,pos,-3.,3.*size);\n    c += flare(uv,pos, -1.,size)*3.;\n    c += flare(uv,pos, .5,.8*size);\n    c += flare(uv,pos,-.4,.8*size);\n    \n    c += orb(uv,pos, 0., .5*size);\n    \n    c += ring(uv,pos,-1.)*.5*size;\n    c += ring(uv,pos, 1.)*.5*size;\n    \n    return c*brightness;\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\t/*if (iMouse.z<.5)\n\t{\n\t\tmouse.x=sin(iTime)*.6;\n\t\tmouse.y=cos(iTime*.913)*.6;\n\t}*/\n\t\n\tvec3 color = /*vec3(1.4,1.2,1.0)*/lensflare(uv,mouse.xy,1.,1.+sin(iTime*.6)*.5);\n\t//color = cc(color,.5,.1);\n\tfragColor = vec4(pow(color, vec3(1.5)),1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 216, 260, 260, 624], [626, 626, 648, 648, 720], [721, 721, 742, 742, 819], [821, 821, 865, 865, 1085], [1087, 1087, 1142, 1142, 1452], [1453, 1453, 1520, 1520, 1567], [1569, 1569, 1622, 1622, 2310], [2311, 2311, 2376, 2376, 2418], [2420, 2420, 2462, 2462, 2764], [2766, 2766, 2830, 4146, 4482], [4484, 4484, 4551, 4551, 4634], [4636, 4636, 4693, 4693, 5165]], "test": "error"}
{"id": "MdGSzt", "name": "Worley-Perlin noise", "author": "w450468524", "description": "combine perlin and worley noise in order to get cauliflower shape in cloud, as decribed in the article: https://www.guerrilla-games.com/read/the-real-time-volumetric-cloudscapes-of-horizon-zero-dawn", "tags": ["2d", "noise", "procedual"], "likes": 51, "viewed": 4058, "published": "Public API", "date": "1466142680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// copy from https://www.shadertoy.com/view/4l2GzW\nfloat r(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); \n}\nfloat worley(vec2 n,float s)\n{\n    float dis = 2.0;\n    for(int x = -1;x<=1;x++)\n    {\n        for(int y = -1;y<=1;y++)\n        {\n            vec2 p = floor(n/s)+vec2(x,y);\n            float d = length(r(p)+vec2(x,y)-fract(n/s));\n            if (dis>d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    return 1.0 - dis;\n\t\n}\n\n// copy from https://www.shadertoy.com/view/4sc3z2\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float dis = (1.0+perlin_noise(vec3(fragCoord.xy/iResolution.xy, iTime*0.05)*8.0)) \n        * (1.0+(worley(fragCoord.xy, 32.0)+\n        0.5*worley(2.0*fragCoord.xy,32.0) +\n        0.25*worley(4.0*fragCoord.xy,32.0) ));\n\tfragColor = vec4(vec3(dis/4.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 69, 69, 108], [109, 109, 125, 125, 202], [203, 203, 233, 233, 551], [553, 645, 667, 667, 819], [820, 820, 848, 848, 1787], [1788, 1788, 1845, 1845, 2112]], "test": "valid"}
{"id": "MdGXWG", "name": "Voxel Flythrough", "author": "Shane", "description": "A simple voxel flythrough. Based on fb39ca4's, IQ's, Reinder's, etc, voxel framework.", "tags": ["raymarching", "voxel", "flythrough"], "likes": 48, "viewed": 1935, "published": "Public API", "date": "1466341313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tVoxel Flythrough\n\t----------------\n\n\tThe cliche voxel flythrough - Everyone should do at least one. :) I've been meaning to put one \n\tof these up for ages, ever since admiring Reinder's Minecraft Blocks port. Other inspiration \n\tcame from IQ's Voxel Edges and just about every flythrough voxel scene in every demo. :)\n\n\tI had originally intended to make it look like some kind of alien space port, but then realized\n\tthat would require actual work, so went with the abstract, naive version. :) I also wanted the\n\tto keep the code readable enough for anyone who might want to try one of these themselves.\n\n\tThe voxel setup is reasonably straight forward, and so is the distance function, which is\n\tdescribed below.\n\n\tMainly based on the following:\n\n\tVoxel Ambient Occlusion - fb39ca4\n    https://www.shadertoy.com/view/ldl3DS\n\n\tMinecraft Blocks - Reinder\n    https://www.shadertoy.com/view/MdlGz4\n    Based on: http://jsfiddle.net/uzMPU/ - Markus Persson\n\n\tVoxel Edges - IQ\n\thttps://www.shadertoy.com/view/4dfGzs\n\n\tVoxel Corridor - Shane\n\thttps://www.shadertoy.com/view/MdVSDh\n\n*/\n\n#define FAR 60.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001);// etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    // Rough sRGB to RGB conversion to account for the gamma correction we're doing before presenting\n    // the final value to the screen... or something like that.... but filtering is done in sRGB... \n    // I think? Sigh! Why does it always have to be so complicated? :)\n    return p*p; \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){    \n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Random cloud-shaped structures. Since the distance field is voxelized, you don't need real clouds, just\n// something that approximates it, so some pseudo-random 3D sinusoidal shapes will do. The sinudoidal \n// function has been arranged in such a way as to provide an open area for the camera to fly through.\n// In turn, the open area is wrapped around a path. By the way, if you were doing this with something like \n// 3d value noise, you could could carve a path through it with a cylinder and no one would be the wiser.\nfloat map(vec3 p){\n    \n    p.xy -= path(p.z); // Perturb an object around a path.\n   \n\tp = cos(p*.1575 + sin(p.zxy*.4375)); // 3D sinusoidal mutation.\n    \n    // Spherize. The result is some mutated, spherical blob-like shapes.\n    float n = dot(p, p); \n    \n    p = sin(p*3. + cos(p.yzx*3.)); // Finer bumps. Subtle, and almost not necessary with voxelization.\n    \n    return n - p.x*p.y*p.z*.35 - .9; // Combine, and we're done.\n    \n}\n\n// The brick groove pattern. Thrown together too quickly.\n// Needs some tidy up, but it's quick enough for now.\n//\nconst float w2h = 1.; // Width to height ratio.\nconst float mortW = .05; // Morter width.\n\nfloat brickShade(vec2 p){\n    \n    p = fract(p);\n    return pow(16.*p.x*p.y*(1.-p.x)*(1.-p.y), 0.25);\n    \n}\n\nfloat brickMorter(vec2 p){\n    \n    p.x -= .5;\n    \n    p = abs(fract(p + vec2(0, .5)) - .5)*2.;\n    \n    // Smooth grooves. Better for bump mapping.\n    return smoothstep(0., mortW, p.x)*smoothstep(0., mortW*w2h, p.y);\n    \n}\n\nfloat brick(vec2 p){\n    \n\tp = fract(p*vec2(0.5/w2h, 0.5))*2.;\n\n    return brickMorter(p)*(brickShade(p)*.5 + .5);\n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf( in vec3 p, in vec3 n){\n\n    n = abs(n);\n    \n    if (n.x>0.5) p.xy = p.zy;\n    else if (n.y>0.5) p.xy = p.zx;\n    \n    return brick(p.xy);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf(p, nor);                 \n    vec3 grad = (vec3(bumpSurf(p - e.xyy, nor),\n                      bumpSurf(p - e.yxy, nor),\n                      bumpSurf(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// This is just a slightly modified version of fb39ca4's code, with some\n// elements from IQ and Reinder's examples. They all work the same way:\n// Obtain the current voxel, then test the distance field for a hit. If\n// the ray has moved into the voxelized isosurface, break. Otherwise, move\n// to the next voxel. That involves a bit of decision making - due to the\n// nature of voxel boundaries - and the \"mask,\" \"side,\" etc, variable are\n// an evolution of that. If you're not familiar with the process, it's \n// pretty straight forward, and there are a lot of examples on Shadertoy, \n// plus a lot more articles online.\n//\nvec3 voxelTrace(vec3 ro, vec3 rd, out vec3 mask){\n    \n    vec3 p = floor(ro) + .5;\n\n\tvec3 dRd = 1./abs(rd); // 1./max(abs(rd), vec3(.0001));\n\trd = sign(rd);\n    vec3 side = dRd*(rd * (p - ro) + 0.5);\n    \n    mask = vec3(0);\n\t\n\tfor (int i = 0; i < 80; i++) {\n\t\t\n        if (map(p)<0.) break;\n        \n        // Note that I've put in the messy reverse step to accomodate\n        // the \"less than or equals\" logic, rather than just the \"less than.\"\n        // Without it, annoying seam lines can appear... Feel free to correct\n        // me on that, if my logic isn't up to par. It often isn't. :)\n        mask = step(side, side.yzx)*(1.-step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask * rd;\n\t}\n    \n    return p;    \n}\n\n\n// Voxel shadows. They kind of work like regular hard-edged shadows. They\n// didn't present too many problems, but it was still nice to have Reinder's\n// Minecraft shadow example as a reference. Fantastic example, if you've\n// never seen it:\n//\n// Minecraft - Reinder\n// https://www.shadertoy.com/view/4ds3WS\n//\nfloat voxShadow(vec3 ro, vec3 rd, float end){\n\n    float shade = 1.0;\n    vec3 p = floor(ro) + .5;\n\n\tvec3 dRd = 1./abs(rd);//1./max(abs(rd), vec3(.0001));\n\trd = sign(rd);\n    vec3 side = dRd*(rd * (p - ro) + 0.5);\n    \n    vec3 mask = vec3(0);\n    \n    float d = 1.;\n\t\n\tfor (int i = 0; i < 16; i++) {\n\t\t\n        d = map(p);\n        \n        if (d<0. || length(p-ro)>end) break;\n        \n        mask = step(side, side.yzx)*(1.-step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask * rd;                \n\t}\n\n    // Shadow value. If in shadow, return a dark value.\n    return shade = step(0., d)*.7 + .3;\n    \n}\n\n///////////\n//\n// This is a trimmed down version of fb39ca4's voxel ambient occlusion code with some \n// minor tweaks and adjustments here and there. The idea behind voxelized AO is simple. \n// The execution, not so much. :) So damn fiddly. Thankfully, fb39ca4, IQ, and a few \n// others have done all the hard work, so it's just a case of convincing yourself that \n// it works and using it.\n//\n// Refer to: Voxel Ambient Occlusion - fb39ca4\n// https://www.shadertoy.com/view/ldl3DS\n//\nvec4 voxelAO(vec3 p, vec3 d1, vec3 d2) {\n   \n    // Take the four side and corner readings... at the correct positions...\n    // That's the annoying bit that I'm glad others have worked out. :)\n\tvec4 side = vec4(map(p + d1), map(p + d2), map(p - d1), map(p - d2));\n\tvec4 corner = vec4(map(p + d1 + d2), map(p - d1 + d2), map(p - d1 - d2), map(p + d1 - d2));\n\t\n    // Quantize them. It's either occluded, or it's not, so to speak.\n    side = step(side, vec4(0));\n    corner = step(corner, vec4(0));\n    \n    // Use the side and corner values to produce a more honed in value... kind of.\n    return 1. - (side + side.yzwx + max(corner, side*side.yzwx))/3.;    \n\t\n}\n\nfloat calcVoxAO(vec3 vp, vec3 sp, vec3 rd, vec3 mask) {\n    \n    // Obtain four AO values at the appropriate quantized positions.\n\tvec4 vAO = voxelAO(vp - sign(rd)*mask, mask.zxy, mask.yzx);\n    \n    // Use the fractional voxel postion and and the proximate AO values\n    // to return the interpolated AO value for the surface position.\n    sp = fract(sp);\n    vec2 uv = sp.yz*mask.x + sp.zx*mask.y + sp.xy*mask.z;\n    return mix(mix(vAO.z, vAO.w, uv.x), mix(vAO.y, vAO.x, uv.x), uv.y);\n\n}\n///////////\n\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 envMap(vec3 rd, vec3 sn){\n    \n    float c = n3D(rd*3.)*.66 + n3D(rd*6.)*.34;\n    c = smoothstep(0.4, 1., c);\n    return vec3(min(c*1.5, 1.), pow(c, 3.), pow(c, 16.));\n    //vec3 col = tex3D(iChannel1, rd/4., sn);\n    //return smoothstep(.0, 1., col*col*2.);//col*col*2.;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 camPos = vec3(0, 0, iTime*8.); // Camera position, doubling as the ray origin.\n\tvec3 lookAt = camPos + vec3(0, 0, .25);  // \"Look At\" position.\n\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, 1, 5);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector along the path. The \"path\" function is \n\t// synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Distorted version.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/24. )*rd.xy;\n\n    \n    // Raymarch the voxel grid.\n    vec3 mask;\n\tvec3 vPos = voxelTrace(camPos, rd, mask);\n\t\n    // Using the voxel position to determine the distance from the camera to the hit point.\n    // I'm assuming IQ is responsible for this clean piece of logic.\n\tvec3 tCube = (vPos-camPos - .5*sign(rd))/rd;\n    float t = max(max(tCube.x, tCube.y), tCube.z);\n\n\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        vec3 sn = -(mask * sign( rd ));\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./4.;\n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.01);\n\n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .1);\n        \n       \n\t    // Ambient occlusion.\n\t    float ao = calcVoxAO(vPos, sp, rd, mask);\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.2 + lDist*.1); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.25;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n  \n        // Object texturing.\n\t    //vec3 texCol = vec3(1, .75, .5);//vec3(1, .05, .15);//vec3(1, .5, .15);//vec3(1, .6, .4) + step(abs(snNoBump.y), .5)*vec3(0,.4, .6);\n\t    vec3 texCol = vec3(.55, .7, 1.3);\n    \n        //float rnd = fract(sin(dot(vPos, vec3(7, 157, 113)))*43758.5453);\n        //texCol *= rnd*.5+.5;\n        //if(rnd>.5) texCol = vec3(1);\n        \n        // Multiplying by the texture color.\n\t    texCol *= tex3D(iChannel0, sp*tSize0, sn)*4.;\n        \n        texCol *= bumpSurf( sp, sn)*.5 + .5; // Enhance the bump.\n        \n        \n        /////////   \n        // Translucency, courtesy of XT95. See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        float th = thickness( sp, sn, 1., 1. );\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 1.), 1.);\n        float trans = (tdiff + .0)*th;  \n        trans = pow(trans, 4.);        \n    \t////////  \n\n        \n        // Shadows... I was having all sorts of trouble trying the move the ray off off the\n        // block. Thanks to Reinder's \"Minecraft\" example for showing me the ray needs to \n        // be bumped off by the normal, not the unit direction ray. :)\n        float shading = voxShadow(sp + snNoBump*.01, ld, lDist);\n    \t\n    \t// Combining the above terms to produce the final color.\n        sceneCol = texCol*(diff + ambience) + vec3(.7, .9, 1.)*spec;// + vec3(.5, .8, 1)*spec2;\n        sceneCol += vec3(1, 0.05, .15)*trans*2.;\n        sceneCol += envMap(reflect(rd, sn), sn);\n        \n        //vec3 rfCol = texture(iChannel2, reflect(rd, sn)).xyz; // Forest scene.\n        //sceneCol += rfCol*rfCol*.5;\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n        \n        // \"fb39ca4\" did such a good job with the AO, that it's worth a look on its own. :)\n        //sceneCol = vec3(ao); \n\n\t   \n\t\n\t}\n       \n    // Blend in a bit of fog for atmospheric effect.\n    vec3 fog = mix(vec3(.96, .48, .36), vec3(.24, .32, .64), -rd.y*.5 + .5); //.zyx\n    //vec3 fog = mix(vec3(.32, .28, .16)*3., vec3(.32, .04, .08)*2., -rd.y*.5 + .5);\n    \n    // I'll tidy this up later.\n    sceneCol = mix(sceneCol, fog*sqrt(fog)*1.2, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n\n    // Clamp and present the roughly gamma corrected pixel to the screen. :)\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1103, 1255, 1276, 1276, 1342], [1344, 1424, 1474, 1474, 1958], [1960, 2060, 2082, 2125, 2326], [2331, 2399, 2417, 2417, 2763], [2765, 3291, 3309, 3309, 3731], [3733, 3939, 3964, 3964, 4047], [4049, 4049, 4075, 4075, 4275], [4277, 4277, 4297, 4297, 4393], [4396, 4460, 4498, 4498, 4621], [4623, 4673, 4730, 4730, 5124], [5126, 5313, 5375, 5375, 5885], [5888, 6514, 6563, 6563, 7241], [7244, 7556, 7601, 7601, 8166], [8168, 8653, 8693, 8846, 9315], [9317, 9317, 9372, 9446, 9806], [9820, 10057, 10128, 10128, 10415], [10417, 10672, 10702, 10702, 10955], [10957, 10957, 11013, 11039, 16851]], "test": "error"}
{"id": "MdKSWm", "name": "Post-mortem Death Star", "author": "s23b", "description": "Use the mouse to rotate\n\nI will try to improve the performance later...", "tags": ["raymarching", "starwars", "deathstar"], "likes": 19, "viewed": 1141, "published": "Public API", "date": "1465315384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SPHERES 6\n#define REFLECTIONS 0\n\n#define saturate(x) clamp(x, 0., 1.)\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\nfloat hash(vec3 uv) {\n  float f = fract(cos(sin(dot(uv ,vec3(.009123898,.00231233, .00532234))) * 480.512353) * 11111.5452313);\n    return f;\n}\n\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 8; ++i) {\n        f += noise((uv + 10.) * vec3(r, r, r)) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// distance function\nfloat map(vec3 p) {\n    float sphere = length(p) - 1.;\n    float f = fbm(p * vec3(1,3,3));\n    sphere = max(f - p.x / 3.  - .6, sphere);\n    sphere = max(-length(p - vec3(1.)) + .85, sphere);\n    sphere = max(sphere, -abs(p.y) + .01);\n    sphere = min(sphere, -length(p) + 5.);\n    return sphere;\n}\n\n// raymarching function\nfloat trace(vec3 o, vec3 r, int steps) {\n    float t = 0.;\n    for (int i = 0; i < 100; ++i) {\n        float d = map(o + r * t);\n        t += d;\n        if (d < .0001 || t > 10. || i > steps) break;\n    }\n    return t;\n}\n\n\nvec3 tex(vec2 uv) {\n    vec3 c = vec3(0);\n    if (abs(abs(uv.y - .5) - .22) > .2 || fract(uv.y * 10.) < .1) {\n        c = vec3(.25);\n    } else {\n        float l = floor(uv.y * 10.);\n        c = vec3(\n            smoothstep(.6, .7, noise(vec3(uv.x * 300.,1, l))) / 8. + .125\n        );\n    }\n    return c;\n}\n\n// apply texture ( fbm + stripes )\nvec3 texSphere(vec3 p) {\n    float l = length(p);\n    float ratio = smoothstep(.99, 1.01, l);\n    p = normalize(p);\n    vec2 uv = vec2(.5 + atan(p.z, p.x) / PI / 2., .5 - asin(p.y) / PI);\n    vec3 c = mix(vec3(fbm(p * 20.) / 10. + .125), tex(uv), ratio);\n    return c * (.5 + smoothstep(0., .002, abs(l - .89)) / 4. + smoothstep(0., .005, abs(l - .99)) / 4.);\n}\n\n// rendering function: o - ray origin, r - ray vector, dist - distance traveled, steps - raymarching iterations\nvec3 render(inout vec3 o, inout vec3 r, inout float dist, in int steps) {\n    \n    // march to first object\n    float f = trace(o, r, steps);\n    \n    // get intersection point\n    vec3 p = o + f * r;\n    \n    // get normal vector\n    vec2 eps = vec2(0, .0001);\n    vec3 normal = normalize(vec3(\n    \tmap(p + eps.yxx) - map(p - eps.yxx),\n    \tmap(p + eps.xyx) - map(p - eps.xyx),\n    \tmap(p + eps.xxy) - map(p - eps.xxy)\n\t));\n    \n    // light source\n    vec3 ls = vec3(0, 0, 2);\n    ls.xz *= rot(iTime * .1);\n    ls.xy *= rot(.3);\n    vec3 light = normalize(ls);\n    \n    // reflection point\n    vec3 ref = reflect(r,normal);\n    \n    vec3 color = vec3(0);\n    \n    if (length(p) < 2.) {\n        // add ambient light (hue from angle)\n        color += saturate(texSphere(p) * dot(p,p));\n\n        // calculate shadow\n        float s = trace(p + light * .01, light, steps);\n\n        if (s > 1.) {\n\t\n            // add diffuse light\n            color += vec3(dot(normal, light)) * .5;\n\n            // add specular light\n            //color += saturate(vec3(pow(saturate(dot(light, ref)), 8.)) / 2.);\n            \n        }\n    } else {\n        vec3 np = p;\n        np.xz *= rot(-iTime* .1);\n        np.xy *= rot(-.3);\n        color = smoothstep(.9, 1., vec3(noise(np * 10.)));\n        color += vec3(pow(saturate(dot(normal, -light)), 100.));\n    }\n        \n    // new origin becomes the point hit\n    o = p;\n    \n    // new ray vector becomes the reflection vector\n    r = normalize(ref);\n    \n    // go a bit further on the ray, so we don't hit the same surface\n    o += r * .1;\n    \n    // add marched distance to distance traveled\n    f = max(0., f);\n    dist += f;\n    \n    // return divided by the fog\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // transform viewport coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // ray from screen coordinates\n    vec3 r = normalize(vec3(uv, 3.));\n    \n    // eye for origin\n    vec3 o = vec3(0, 0, -4);\n    \n    // transform mouse coordinates\n    vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n\n    mouse *= PI * 2.;\n    \n    // rotate camera around the center\n    float a = (iMouse.z > 0.) ? -mouse.y : .3;\n    o.yz *= rot(a);\n    r.yz *= rot(a);\n    a = (iMouse.z > 0.) ? -mouse.x : 3.2;// + iTime * .5;\n    o.xz *= rot(a);\n    r.xz *= rot(a);\n    \n    float f = 0.;\n    int steps = 100;\n    \n    // render scene\n    vec3 c = render(o, r, f, steps);\n    \n    // render reflections\n    for (int i = 0; i < REFLECTIONS; ++i) {\n        steps /= 2;\n    \tc += c * render(o, r, f, steps);\n    }\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 178, 178, 300], [302, 302, 324, 324, 947], [949, 949, 969, 969, 1137], [1139, 1160, 1179, 1179, 1458], [1460, 1484, 1524, 1524, 1704], [1707, 1707, 1726, 1726, 2014], [2016, 2051, 2075, 2075, 2412], [2414, 2526, 2599, 2633, 4249], [4251, 4251, 4308, 4346, 5201]], "test": "valid"}
{"id": "MdKXzc", "name": "Supernova remnant", "author": "Duke", "description": "Based on [url=https://www.shadertoy.com/view/MsVXWW]Dusty nebula 4[/url] Added emission light to the filaments. I continue to think about how to animate this shader.", "tags": ["cloud", "star", "space", "nebula", "supernova", "dust", "remnant", "filament"], "likes": 251, "viewed": 12948, "published": "Public API", "date": "1465856564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Supernova remnant\" by Duke\n// https://www.shadertoy.com/view/MdKXzc\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 4\" (https://www.shadertoy.com/view/MsVXWW) \n// and \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(vec3 p)\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.9;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n    float final = Disk(p.xzy,vec3(2.0,1.8,1.25));\n    final += fbm(p*90.);\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*3.0;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.07;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<64; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t// change this string to control density \n\t\td = max(d,0.0);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        \n        sum.rgb+=(vec3(0.67,0.75,1.00)/(lDist*lDist*10.)/80.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        //idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.y*=120.;\n        uv.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uv.y,-uv.x+0.5*sin(4.*iTime+uv.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.01);\n        \n\t}\n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKXzc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[894, 908, 934, 934, 1153], [1155, 1155, 1174, 1174, 1263], [1265, 1265, 1290, 1290, 1327], [1329, 1329, 1354, 1354, 1419], [1422, 1422, 1452, 1452, 1548], [1550, 2211, 2239, 2239, 2788], [2790, 2790, 2817, 2817, 2964], [2966, 2966, 2986, 2986, 3103], [3170, 3199, 3249, 3334, 3604], [3606, 3606, 3682, 3682, 3898], [3900, 4015, 4051, 4051, 4215], [4217, 4217, 4274, 4274, 7446]], "test": "error"}
{"id": "MdVSD3", "name": "bumped brick texture", "author": "KukaTails", "description": "use procedural method to generate brick texture", "tags": ["procedural", "placementmapping"], "likes": 3, "viewed": 187, "published": "Public", "date": "1467171403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BRICK_WIDTH  0.25\n#define BRICK_HEIGHT 0.08\n#define MORTAR_THICKNESS 0.01\n#define BM_WIDTH  (BRICK_WIDTH + MORTAR_THICKNESS)\n#define BM_HEIGHT (BRICK_HEIGHT + MORTAR_THICKNESS)\n#define MWF (MORTAR_THICKNESS * 0.5 / BM_WIDTH)\n#define MHF (MORTAR_THICKNESS * 0.5 / BM_HEIGHT)\n#define BRICK_COLOR vec3(0.5, 0.15, 0.14)\n#define MORTAR_COLOR vec3(0.5, 0.5, 0.5)\n#define PI 3.141592654\n\n\nvec3 LIGHT_POS = vec3(0.0, 0.0, -100.0);\nconst vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\nconst vec3 AMBIENT_COLOR = vec3(0.15, 0.0, 0.0);\n\nvec3 CalculatePos(vec3 pos, vec3 normal, vec2 uv);\nvec3 CalculateNormal(vec3 pos, vec3 normal);\nvec3 Shader(vec3 pos, vec3 normal, vec3 diffuse_color);\nfloat Hash(vec2 p);\nfloat Noise(vec2 p);\nfloat FractalSum(vec2 uv);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos_xy = fragCoord.xy / 1.0;\n    vec3 pos = vec3(pos_xy , 0.0);\n    vec3 normal = vec3(0.0, 0.0, -1.0);\n    \n    float light_x = sin(mod(iTime, 10.0) / 10.0 * PI) * iResolution.x;\n    float light_y = sin(mod(iTime, 10.0) / 10.0 * PI) * iResolution.y;\n    LIGHT_POS += vec3(light_x, light_y, 0.0);\n        \n    \n    float brick_u = uv.x / BM_WIDTH;\n    float brick_v = uv.y / BM_HEIGHT;\n    \n    if (mod(brick_v, 2.0) > 1.0)\n        brick_u += 0.5;\n    \n    brick_u -= floor(brick_u);\n    brick_v -= floor(brick_v);\n    brick_u += FractalSum(uv) * 0.005;\n    brick_v += FractalSum(vec2(brick_u, brick_v)) * 0.005;\n\n    float w = step(MWF, brick_u) - step(1.0-MWF, brick_u);\n    float th = step(MHF, brick_v) - step(1.0-MHF, brick_v);\n    vec3 color = mix(MORTAR_COLOR, BRICK_COLOR, w * th);\n    \n    vec3 replacement_pos = CalculatePos(pos, normal, vec2(brick_u, brick_v));\n    vec3 replacement_normal = CalculateNormal(replacement_pos, normal);\n    //fragColor = vec4(Shader(pos, normal, color), 1.0);\n    fragColor = vec4(Shader(replacement_pos, replacement_normal, color), 1.0);\n}\n\nvec3 CalculatePos(vec3 pos, vec3 normal, vec2 uv)\n{\n    float s = uv.x;\n    float t = uv.y;\n    float sbump = smoothstep(0.0, MWF, s) - smoothstep(1.0-MWF, 1.0, s);\n    float tbump = smoothstep(0.0, MHF, t) - smoothstep(1.0-MHF, 1.0, t);\n    float stbump = sbump * tbump;\n    return pos + normal * stbump + stbump * normal * FractalSum(uv) * 0.25;\n}\n\n\nvec3 CalculateNormal(vec3 pos, vec3 normal)\n{\n    vec3 dx = dFdx(pos);\n    vec3 dy = dFdy(pos);\n    return normalize(cross(dx, dy));\n}\n\nvec3 Shader(vec3 pos, vec3 normal, vec3 diffuse_color)\n{\n    vec3 dir = normalize(LIGHT_POS - pos);\n    vec3 diffuse = abs(dot(dir, normal)) * LIGHT_COLOR * diffuse_color;\n    vec3 color = AMBIENT_COLOR + diffuse;\n    return color * 1.5;\n}\n\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return -1.0 + 2.0 * fract(sin(h) * 4358.5453);\n}\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\nfloat FractalSum(vec2 uv)\n{\n    const int octaves = 1;\n    float amplitude = 1.0;\n    float f = 0.0;\n    \n    uv *= 25.0;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    for (int i = 0; i < octaves; ++ i) {\n        f += abs(amplitude * Noise(uv));\n        uv = m * uv;\n        amplitude *= 0.5;\n    }\n    return f;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[749, 749, 804, 804, 1938], [1940, 1940, 1991, 1991, 2289], [2292, 2292, 2337, 2337, 2426], [2428, 2428, 2484, 2484, 2667], [2669, 2669, 2689, 2689, 2783], [2785, 2785, 2806, 2806, 3097], [3099, 3099, 3126, 3126, 3411]], "test": "error"}
{"id": "MdVXzy", "name": "RGB Ball Bounce-150 chars", "author": "GregRostami", "description": "This is a modification of my previous shader [url]https://www.shadertoy.com/view/lsVXRw[/url]\nPlease help me make this shorter.", "tags": ["ball", "bounce", "short", "2tc"], "likes": 3, "viewed": 620, "published": "Public API", "date": "1465220016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 150 chars - Thanks to Xor and Fabrice, this shader is a LOT ligher!\n\n#define b length(u/iResolution.y-.1-abs(vec2( mod(o=o*.1-iTime,3.2).x -1.6,.6*sin(o*5.)))) < .1\n\nvoid mainImage(out vec4 o, vec2 u) {\n    o.r = 1.;\n    o = vec4(b,b,b,1); }     /*\n\n// 149 chars - Fabrice helped me reduce this shader.\n\n#define b length(u/iResolution.y-.1-abs(vec2(mod(a=a*.1-iTime,3.2)-1.6,.6*sin(a*5.)))) < .1\n\nvoid mainImage(out vec4 o, vec2 U) {\n    float a=1.; vec2 u=U;\n    o = vec4(b,b,b,1); }\n\n\n// 152 chars - LaBodilsen, reduced the shader again and kept the motion of the original.\n\n#define b length(u/iResolution.y-.1-abs(vec2(mod(o=o.a*.1-iDate,3.2).w-1.6,.6*sin(o.a*5.))))<.1\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o-=o;\n    o = vec4(b,b,b,1);\n}\n\n\n// 157 chars - Original version\n\n#define b length(u/iResolution.y-.1-abs(1.6*vec2(mod(o=(o.a*=.1)-iDate,2.).w-1.,.4*sin(o.a*5.))))<.1\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o-=o;\n    o = vec4(b,b,b,1);\n}\n\n\n// 149 chars - LaBodilsen, reduced the shader by changing the motion of the balls\n\n#define b length(u/iResolution.y-.1-abs(vec2(mod(o=o.a-iDate,6.4).w-3.2, sin(o.a*2.)))/2.) <.1\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o-=o;\n    o = vec4(b,b,b,1);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 169, 205, 205, 244]], "test": "valid"}
{"id": "MdySWy", "name": "Two methods of squares. ", "author": "barakooda", "description": "I just practice,comments are welcome.\nwhy the green box behave loop differently... ? ", "tags": ["shapeslearn"], "likes": 3, "viewed": 641, "published": "Public API", "date": "1466365492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat time = iTime; \n\tfloat ratio = min(iResolution.x,iResolution.y) / max(iResolution.x,iResolution.y);\n\tfloat aspect = max(iResolution.x,iResolution.y) / min(iResolution.x,iResolution.y);\n\n/////////////////////// Smooth Step Version (green) /////////////////////////////////////////\t\n\t\n\tfloat color1 = 0.0;\n\tfloat s = 0.6;\n\t \t\n\tfloat sx = 1.0 - (0.5 + (s * ratio) * 0.5) ;\n\tfloat sy = 1.0 - (0.5 + s * 0.5) ;   \n\t\n\tfloat tx = -0.3 * (-1.0);\n\tfloat ty = (-1.0 + (mod(time*0.4,2.0))) * (-1.0);\n\n    vec2 lb = smoothstep(vec2(sx,sy),vec2(sx,sy),uv + vec2(tx,ty) );\n \t\n\tvec2 rt = smoothstep(vec2(sx,sy), vec2(sx,sy),1.0 - (uv+vec2(tx,ty))  );\n    \n    color1 = lb.x * lb.y * rt.x * rt.y;\n\t\n\n\n\n///////////////////////////floor method Red///////////////////////////////\n   \n    float color2 = 0.0;\n    s = 0.6;\n\t\n\ttx = 0.3 * (-1.0);\n\tty = (-1.0 + (mod(time*0.4,2.0))) * (-1.0);\n    \t\n\tsx = 1.0 - (0.5 + (s * ratio) * 0.5)  ;\n\tsy = 1.0 - (0.5 + s * 0.5)  ;\n    \n\tlb = floor (vec2( sx + (uv.x + tx),sy + (uv.y + ty) ));\n\trt = floor (vec2( sx + (1.0 - (uv.x + tx)),sy + 1.0-(uv.y + ty) ));\n    \n    \n\tcolor2 = 1.0-(lb.x + lb.y + rt.x + rt.y);\n    \n\t\n\tfragColor.ra = vec2(color2,color2);\n    fragColor.ga = vec2(color1,color1);\n\t\n\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdySWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1333]], "test": "valid"}
{"id": "MdySzc", "name": "Server Room", "author": "zackpudil", "description": "What I imagine the Google server room looks like.\n\nVoronoi Fractal material from (https://www.shadertoy.com/view/4sl3Dr)\nApollonian Fractal from (https://www.shadertoy.com/view/4ds3zn)\nTunnel from (https://www.shadertoy.com/view/MlXSWX)", "tags": ["raymarching", "fractal", "voronoi", "distancefields"], "likes": 99, "viewed": 4389, "published": "Public", "date": "1465682331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float tmax = 20.0;\n\nfloat hash(float n) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nvec3 hash(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat noise(float g) {\n\tfloat p = floor(g);\n\tfloat f = fract(g);\n\n\treturn mix(hash(p), hash(p + 1.0), f);\n}\n\nfloat voronoi(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tvec2 res = vec2(8.0);\n\n\tfor(int i = -1; i <= 1; i++)\n\tfor(int j = -1; j <= 1; j++)\n\tfor(int k = -1; k <= 1; k++) {\n\t\tvec3 g = vec3(float(i), float(j), float(k));\n\t\tvec3 r = g + hash(p + g) - f;\n\n\t\tfloat d = max(abs(r.x), max(abs(r.y), abs(r.z)));\n\n\t\tif(d < res.x) {\n\t\t\tres.y = res.x;\n\t\t\tres.x = d;\n\t\t} else if(d < res.y) {\n\t\t\tres.y = d;\n\t\t}\n\t}\n\n\treturn res.y - res.x;\n}\n\nvec2 path(float z) {\n\treturn vec2(cos(z/8.0)*sin(z/12.0)*12.0, 0.0);\n}\n\nfloat map(vec3 p) {\n\tvec4 q = vec4(p, 1.0);\n\tq.x += 1.0;\n\n\tfor(int i = 0; i < 6; i++) {\n\t\tq.xyz = -1.0 + 2.0*fract(0.5 + 0.5*q.xyz);\n\t\tq = 1.2*q/max(dot(q.xyz, q.xyz), 0.1);\n\t}\n\n\tvec2 tun = abs(p.xy - path(p.z))*vec2(0.6, 0.5);\n\n\treturn min(0.25*abs(q.y)/q.w, 1.0 - max(tun.x, tun.y));\n}\n\nfloat march(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = map(ro + rd*t);\n\t\tif(d < 0.001 || t >= mx) break;\n\t\tt += d*0.75;\n\t}\n\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float o = 0.0, s = 0.005;\n    for(int i = 0; i< 15; i++) {\n        float d = map(p + n*s);\n        o += (s - d);\n        s += s/float(i + 1);\n    }\n    \n    return 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec3 material(vec3 p) {\n\tfloat v = 0.0;\n\tfloat a = 0.7, f = 1.0;\n\n\tfor(int i = 0; i < 4; i++) {\n\t\tfloat v1 = voronoi(p*f + 5.0);\n\t\tfloat v2 = 0.0;\n\n\t\tif(i > 0) {\n\t\t\tv2 = voronoi(p*f*0.1 + 50.0 + 0.15*iTime);\n\n\t\t\tfloat va = 0.0, vb = 0.0;\n\t\t\tva = 1.0 - smoothstep(0.0, 0.1, v1);\n\t\t\tvb = 1.0 - smoothstep(0.0, 0.08, v2);\n\t\t\tv += a*pow(va*(0.5 + vb), 4.0);\n\t\t}\n\n\t\tv1 = 1.0 - smoothstep(0.0, 0.3, v1);\n\t\tv2 =  a*noise(v1*5.5 + 0.1);\n\n\t\tv += v2;\n\n\t\tf *= 3.0;\n\t\ta *= 0.5;\n\t}\n\n\treturn vec3(pow(v, 6.0), pow(v, 4.0), pow(v, 2.0))*2.0;\n}\n\nmat3 camera(vec3 eye, vec3 lat) {\n\tvec3 ww = normalize(lat - eye);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\n\treturn mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tvec3 col = vec3(0);\n\n\tvec3 ro = vec3(0.63*cos(iTime*0.1), 0.67, iTime*0.5);\n\tvec3 la = ro + vec3(0, 0, 0.3);\n\n\tro.xy += path(ro.z);\n\tla.xy += path(la.z);\n\tvec3 rd = normalize(camera(ro, la)*vec3(uv, 1.97));\n\n\tfloat i = march(ro, rd, tmax);\n\tif(i < tmax) {\n\t\tvec3 pos = ro + rd*i;\n\t\tvec3 nor = normal(pos);\n\n\t\tvec3 rig = ro + vec3(0, 0, 3);\n\t\trig.xy += path(rig.z);\n\t\tvec3 key = normalize(pos - rig);\n\n\t\tcol  = 0.1*vec3(0, 0, 1);\n\t\tcol += 0.9*clamp(dot(key, nor), 0.0, 1.0)*vec3(1.0/max(1.0, i), 1, 1);\n\t\tcol += 0.4*clamp(dot(-key, nor), 0.0, 1.0)*vec3(1.0/max(1.0, i), 1, 1);\n\n\t\tcol *= material(pos);\n\t}\n\n\tcol = mix(col, vec3(0), 1.0 - exp(-0.6*i));\n    \n    col = 1.0 - exp(-0.5*col);\n    col = pow(abs(col), vec3(1.0/2.2));\n\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdySzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 47, 47, 83], [85, 85, 103, 103, 212], [214, 214, 236, 236, 321], [323, 323, 346, 346, 758], [760, 760, 780, 780, 830], [832, 832, 851, 851, 1119], [1121, 1121, 1162, 1162, 1305], [1307, 1307, 1328, 1328, 1504], [1506, 1506, 1532, 1532, 1728], [1730, 1730, 1753, 1753, 2258], [2260, 2260, 2293, 2293, 2440], [2442, 2442, 2499, 2499, 3348]], "test": "valid"}
{"id": "MsGSDG", "name": "Waffleball", "author": "bwestlin", "description": "Just an idea that turned out looking like some kind of waffleball.", "tags": ["2d", "sound", "soundcloud"], "likes": 4, "viewed": 238, "published": "Public", "date": "1466258179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Used to have https://soundcloud.com/socionode/younger-brother-psychic-gibbon but not working anymore\n#define M_PI 3.1415926535897932384626433832795\n#define r iResolution\n#define t iTime\n#define lw 0.001 * s3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / r.x;\n    vec2 m = vec2(1., r.y / r.x) / 2.;\n    float s1 = texture( iChannel0, vec2( .2, 0. ) ).x;\n    float s2 = texture( iChannel0, vec2( .5, 0. ) ).x;\n    float s3 = .3 + .8 * texture( iChannel0, vec2( .8, 0. ) ).x;\n\n    \n   \tfloat c = .0;\n    \n\tconst int MAX_N = 16;\n    int N = 3 + int(s1 * 13.);\n    float r1 = (m.x / 6.) + s1 / 10.;\n    float r2 = (m.x / 6.) + s2 / 3.;\n    float as = M_PI * 2. / float(N);\n    for(int i = 0; i < MAX_N; i++)\n    {\n        float a = (M_PI * 2. + sin(t) * M_PI) + float(i) * as - t / 2.;\n    \tvec2 xy = m + vec2(cos(a) * r1, sin(a) * r1);\n    \tfloat d = distance(uv, xy);\n        float ad = abs(d - r2);\n        c += (.5 + .5 * sin(t * 4. + s3)) * clamp((1. - (ad / 10. - lw) / lw), 0., 1.);\n        c = max(c, clamp(1. - (ad * 10. / s3), 0., 1.));\n        if (i >= N - 1) break;\n    }\n\n    fragColor = vec4(\n        c * (.5 + .5 * sin(t)),\n        c * (.5 + .5 * cos(t / 2.)),\n        c * (.5 + .5 * sin(t / 3.)),\n        1.);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 212, 269, 269, 1264]], "test": "error"}
{"id": "MsGSRV", "name": "skytest_tendril", "author": "Penthiusx", "description": "rip and mod of Galaxy shader \nhttps://www.shadertoy.com/view/MslGWN", "tags": ["grandexpanse"], "likes": 1, "viewed": 270, "published": "Public", "date": "1465330017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float field2(in vec3 p, float s) {\n\n    float strength = 4.3 + .03 * log(1.e-6 + fract(/*sin(iTime)*/1. * 4373.11));\n\n    float accum = s/4.;\n\n    float prev = 0.;\n\n    float tw = 0.;\n\n   for (int i = 0; i < 20; ++i) {\n\n        float mag = dot(p, p);\n\n        p = abs(p) / mag + vec3(-.1, -.4, -1.5);\n\n        float w = exp(-float(i) / 7.);\n\n        accum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\n        tw += w;\n\n        prev = mag;\n\n    }\n\n   return ( 5.0 * accum / tw - 0.8);\n\n}\n\nvec3 nrand3( vec2 co ) {\n\n   vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\n    vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\n    vec3 c = mix(a, b, 0.5);\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    vec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\n    vec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\n    float freqs[4];\n\n    freqs[0]=1.2;\n\n    freqs[1]=-0.01;\n\n    freqs[2]=-0.3;\n\n    freqs[3]=0.01;\n\n    float v = (1.0 - exp((abs(uv.x) - 1.) * 1.)) * (1. - exp((abs(uv.y) - 1.0) * 1.0));\n\n    vec3 p2 = vec3(uvs / (2.+sin(iTime * 0.11) * 0.2 + 0.2 + sin(iTime * 0.15) * 0.3 + 0.4), 1.5) + vec3(1.98, -1.3, -1.0);\n  //---------------------------------------------Range---mean----------------------------Range---mean-----------------------------Range---mean----\n    p2 += 0.4 * vec3((sin(iTime / 50.0) * 0.1) + 1.0 , (sin(iTime / 100.0) * 0.3) - 0.2,  (sin(iTime * 0.25) * 0.07) + 0.875);\n\n    float t2 = field2(p2 ,freqs[3]);\n\n     vec4 c2 = mix(.7, 1., v) * vec4(2.3 * t2 * t2  ,1.1 * t2 * t2 , t2 * freqs[0], t2);\n\n    vec2 seed = p.xy * 30.;\n\n    seed = floor(seed * iResolution.x);\n\n    vec3 rnd = nrand3( seed );\n\n    vec4 starcolor1 = vec4(pow(rnd.y,80.0));\n\n    vec2 seed2 = p2.xy * 0.95;\n\n    seed2 = floor(seed2 * iResolution.x);\n\n    vec3 rnd2 = nrand3( seed2 );\n\n    vec4 starcolor2 = vec4(pow(rnd2.y,200.0));\n\n    //------------------------------------------------------------------------------------------------------------------col intensity------------col intensity--------col intensity\n    fragColor = ((mix(freqs[3],0.1,v) * mix(freqs[1],-3.1,v) * vec4(1.5*freqs[2],freqs[1],freqs[3],1.0) + ((c2 * 0.7)*0.9)) * 1.2) + ((starcolor1) * 1.3) + (starcolor2 * 0.7) ;\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 493], [495, 495, 519, 519, 717], [719, 719, 776, 776, 2342]], "test": "valid"}
{"id": "MsGXWy", "name": "Slowstars", "author": "danb", "description": "Simple star shader, but not too fast.", "tags": ["stars", "iterative", "rendering", "starfield", "slow"], "likes": 10, "viewed": 508, "published": "Public", "date": "1466270651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rnd(r) fract(4579.0 * sin(1957.0 * (r)))\n\nvoid mainImage(out vec4 col, in vec2 pos)\n{\n    float t = iTime;\n\tpos /= iResolution.x;\n    col = vec4(0.0);\n    \n    for (float i = 0.0; i < 200.0; i += 1.0)\n    {\n        float r = (0.5 + 0.5 * rnd(i)) * 0.003;\n        vec2 point = rnd(i + vec2(1.0, 2.0));\n        vec2 veloc =  rnd(i + vec2(3.0, 4.0)) - 0.5;\n        \n        vec2 point_real = fract(point + veloc * t * 0.05);\n        float dist = length(point_real - pos) / r;\n\n        if (dist < 1.0)\n        {\n            col += 1.0 - dist;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 93, 93, 564]], "test": "valid"}
{"id": "MsKSDG", "name": "KaliTrace+Light", "author": "bergi", "description": "Mod of [url]https://www.shadertoy.com/view/4sKXWG[/url]\nEnjoy :D\n", "tags": ["raymarching", "fractal", "lighting", "kaliset", "trippy"], "likes": 14, "viewed": 841, "published": "Public API", "date": "1466428225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** KaliTrace+Light\n\thttps://www.shadertoy.com/view/MsKSDG\n\n\t(cc) 2016, stefan berke\n\n\tMore or less the same as \t\n\thttps://www.shadertoy.com/view/4sKXWG\n\t\n\tAdded implicit lighting and light-reflection\n\tand some parameter morphing\n\n*/\n\n\n// minimum distance to axis-aligned planes in kali-space\n// uses eiffie's mod (/p.w) https://www.shadertoy.com/view/XtlGRj\n// to keep the result close to a true distance function\nvec3 kali_set(in vec3 pos, in vec3 param)\n{\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        d = min(d, p.xyz/p.w);\n        p.xyz -= param;\n    }\n    return d;\n}\n\n// same thing as above but also gathers\n// distance to light 'bulbs' \nvec4 light;\nvec3 kali_set_with_light(in vec3 pos, in vec3 param)\n{\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        vec3 s = p.xyz/p.w;\n        d = min(d, s);\n        if (i == 3)\n            light = vec4(.5+.5*sin(pos.xzx*vec3(8,9,19)), \n                         length(s.xz)-0.003);\n        p.xyz -= param;\n    }\n    return d;\n}\n\n\n// scene distance\nfloat DE(in vec3 p, in vec3 param)\n{\n    // floor and ceiling\n    float d = min(p.y, -p.y+.2);\n\n    // displaced by kaliset\n\td -= kali_set(p*vec3(1,2,1), param).x;\n    \n    return d;\n}\n\n// scene distant with light gathering\nfloat DE_with_light(in vec3 p, in vec3 param)\n{\n    // floor and ceiling\n    float d = min(p.y, -p.y+.2);\n\n    // displaced by kaliset\n\td -= kali_set_with_light(p*vec3(1,2,1), param).x;\n    \n    return d;\n}\n\nvec3 DE_norm(in vec3 p, in vec3 param)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(\n        DE(p+e.xyy, param) - DE(p-e.xyy, param),\n        DE(p+e.yxy, param) - DE(p-e.yxy, param),\n        DE(p+e.yyx, param) - DE(p-e.yyx, param)));\n}\n\n\nconst float max_t = 1.;\n\n// common sphere tracing\n// note the check against abs(d) to get closer to surface\n// in case of overstepping\nvec3 light_accum;\nfloat trace(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    light_accum = vec3(0.);\n    float t = 0.001, d = max_t;\n    for (int i=0; i<50; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE_with_light(p, param);\n        if (abs(d) <= 0.0001 || t >= max_t)\n            break;\n        // light accumulation is after break\n        // (we are not so much interested in the light's surfaces)\n        light_accum += (.2+.4*light.xyz) * max(0., .3 - 6.*light.w) / 3.;\n        d = min(d, light.w*.5); // extra fudge for light bulbs\n        t += d * .5; // fudge for kali geometry\n    }\n    return t;\n}\n\n// common ambient occlusion\nfloat traceAO(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float a = 0., t = 0.01;\n    for (int i=0; i<5; ++i)\n    {\n        float d = DE(ro+t*rd, param);\n        a += d / t;\n        t += d;\n    }\n    return min(1., a / 5.);\n}\n\n// environment map, \n// background is drawn from kaliset\nvec3 skyColor(in vec3 ro, in vec3 rd)\n{\n    //vec3 par = vec3(0.075, 0.565, .03);\n    vec3 par = vec3(1.2, 1.01, .71);\n    \n    vec3 c = kali_set(rd*2., par);\n    c = vec3(.9*c.x,.7,1.)*pow(vec3(c.x),vec3(.7,.5,.5));\n\tc *= .6;\n    \n    // some quick tracing of reflected lights\n    vec3 lc = vec3(0.);\n    float t = 0.001, d = max_t;\n    for (int i=0; i<15; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE_with_light(p, vec3(1.));\n        if (abs(d) <= 0.0001 || t >= max_t)\n            break;\n        lc += light.xyz * max(0., .4 - 9.*light.w);\n        d = min(d, light.w);\n        t += d; // no fudging, artifacts are okay here\n    }\n    c += .7*min(vec3(1.), lc / (max_t - t));\n\n    return clamp(c, 0., 1.);\n}\n\n// trace and color\nvec3 rayColor(in vec3 ro, in vec3 rd, in float ti)\n{\n    // magic params for kali-set\n    vec3 par1 = vec3(1.,.7+.6*sin(ti/39.),1.),\t\t// scene geometry \n         par2 = vec3(.63, .55, .73);\t\t\t// normal/bump map\n    \n    float t = trace(ro, rd, par1);\n\n    vec3 p = ro + t * rd;\n    float d = DE(p, par1);\n    \n    vec3 col = vec3(0.);\n\n    // did ray hit?\n    if (d < 0.03) \n    // note, we always find a surface in this scene except for rays parallel to the \n\t// two enclosing planes. The 0.03 is quite large, just to remove the blackness\n    // close to edges\n    {\n        // surface normal\n        vec3 n = DE_norm(p, par1);\n        // normal displacement\n        n = normalize(n + min(p.y+0.05,.02)*DE_norm(p+.1*n, par2));\n        n = normalize(n + 0.04*DE_norm(sin(p*30.+n*10.), par2)); // micro-bumps\n        // reflected ray\n        vec3 rrd = reflect(rd,n);\n\t\t// normal towards light\n        vec3 ln = normalize(vec3(0.7,0.2,0) - p);\n\t\t// 1. - occlusion\n        float ao = traceAO(p, n, par1);\n        // surface color\n        vec3 surf = .1*mix(vec3(1,1.4,1), vec3(3,3,3), ao);\n\n        // lighting\n        surf += .25 * ao * max(0., dot(n, ln));\n        float d = max(0., dot(rrd, ln));\n        surf += ao * (.5 * d + .7 * pow(d, 8.));\n\n        // environment map\n        surf += ao * skyColor(ro+0.01*n, rrd);\n    \n        // distance fog\n    \tcol = surf * (1.-t / max_t);\n    }\n    \n    col += light_accum;\n    \n    return col;\n}\n\n// camera path\nvec3 path(in float ti)\n{\n    ti /= 7.;\n    vec3 p = vec3(sin(ti)*.5+.5, \n                  .07+.06*sin(ti*3.16), \n                  -.5*cos(ti));\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n        \n    float ti = iTime+99.;\n    \n    vec3 ro = path(ti);\n    vec3 look = path(ti+1.+.5*sin(ti/2.3))+vec3(0,.02+.03*sin(ti/5.3),0);\n    float turn = sin(ti/6.1); \n        \n    // lazily copied from Shane\n    // (except the hacky turn param)\n    float FOV = 1.6; // FOV - Field of view.\n    vec3 fwd = normalize(look-ro);\n    vec3 rgt = normalize(vec3(fwd.z, turn, -fwd.x));\n    vec3 up = cross(fwd, rgt);\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    \n    \n    //vec3 col = kali_set(vec3(uv, 0.), vec3(1.));\n    vec3 col = rayColor(ro, rd, ti);\n    \n    \n    col *= pow(1.-dot(suv-.5,suv-.5)/.5, .6);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 415, 458, 458, 661], [663, 745, 799, 799, 1147], [1150, 1168, 1204, 1229, 1352], [1354, 1392, 1439, 1464, 1598], [1600, 1600, 1640, 1640, 1849], [1877, 2005, 2057, 2057, 2601], [2603, 2631, 2685, 2685, 2857], [2859, 2916, 2955, 2997, 3636], [3638, 3657, 3709, 3742, 5099], [5101, 5116, 5140, 5140, 5277], [5279, 5279, 5336, 5336, 6114]], "test": "valid"}
{"id": "MsKSWw", "name": "HUD Practice", "author": "Yusef28", "description": "more design, shape, and color practice.", "tags": ["2d", "display", "hud"], "likes": 16, "viewed": 366, "published": "Public", "date": "1464839005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat inner (float a, float l){\n    \n    float j = l*2.3;\n    //j = pow(j, 4.0);\n    float f = 1.0- smoothstep(1., 1.04, j) - (1.0-smoothstep(0.5, .002, j));\n    \n    return f;\n}\n\nfloat rimlight(float a, float l){\n    \n    float j = l*1.5;\n    //j = pow(j, 4.0);\n    float f = 1.0- smoothstep(0.5, 1.4, j) - (1.0-smoothstep(0.5, .92, j));\n    \n    return f;\n}\n\nfloat rim(float a, float l){\n    \n    float j = l;\n        j = l+sin(iTime);\n    //j = pow(j, 4.0);\n    float g = 1.0-smoothstep(0.7, .72, j);\n    \n    float f = smoothstep(0.8, 1., j);\n    f = f-g;\n    f = 1.0-smoothstep(f-0.009, f+0.009, j);\n    \n    return f;\n}\n\nfloat darkrim(float a, float l){\n    \n    float j = l*2.5;\n    float f = pow(1.0- smoothstep(1., 1.09, j) - (1.0-smoothstep(.92, .9995, j)), 9.);\n\tf = f * abs(fract(a/5.)*2.0-1.)*2.;\n    \n    return f;\n}\n\nfloat threeline(float a, float l){\n    \n    float f = (smoothstep(-0., 0.03, cos((a)*5.))*.1+0.31) ;\n    float g = (1.0 - smoothstep(0.0, 1.0, l*2.30391));\n    f = f-g;\n    f = 1.0-smoothstep(f,f+0.008, l) ;\n    return f*100.0;\n}\n\nfloat spiral(float a, float l){\n    float f = smoothstep(.0, -.2, cos(a*15.0 + iTime*10.0))*.341;\n\n \tfloat g = 1.0-smoothstep(0.0, 1.0, l*3.0);\n\n    f = f-g;\n    f = 1.0-smoothstep(f, f+0.008, l);\n    return f;\n}\n\nfloat innerspiral(float a, float l){\n    float f = smoothstep(-.5, 1.0, cos(a*50.0+l*20.*sin(iTime)*10.0 ))*.21;\n\n \tfloat g = 1.0-smoothstep(0.0, 1.0, l*5.);\n\n    f = f-g;\n    f = 1.0-smoothstep(f, f+0.03, l);\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    float a = atan(uv.y,uv.x);\n    float l = length(uv) - 0.2;\n    l = l/1.05;\n    vec3 color = vec3(.0, 0., 0.);\n    \n   \tvec3 blue = vec3(0.0,0.0,1.0);\n    vec3 green = vec3(0.0,1.0,0.0);\n    vec3 grey = vec3(0.0, 0.0, 0.0);\n    \n    \n   \n    color = mix(color, grey, smoothstep(0., 1., 1.));\n    \n    color = mix(color, vec3(0.0,0.5,0.9),rim(a, l));\n    color = mix(color, vec3(0.0,0.5,0.9),rim(a, l*1.5));\n    color = mix(color, vec3(0.0,0.5,0.9),rim(a, l*1.2));\n    \n    color = mix(color, vec3(0.05,0.05,0.05),darkrim(a, l));\n    color = mix(color, vec3(0.0,0.4,0.9), threeline(a, l));\n    \n    color = mix(color, vec3(1. ,1., 1.), spiral(a, l*1.1));\n    color = mix(color, vec3(1. ,1., 1.), spiral(a, l/2.4));\n    \n    color = mix(color, vec3(0.0, 0.3, 0.6), innerspiral(a, l));\n    color = mix(color, vec3(0.0, 0.3, 0.6), inner(a, l));\n    \n    color = mix(color, vec3(0.0, 0.3, 0.6), rimlight(a, l));\n    color = mix(color, vec3(0.0, 0.3, 0.6), rimlight(a, l*1.3));\n    \n    \n    \n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 179], [181, 181, 214, 214, 360], [362, 362, 390, 390, 626], [628, 628, 660, 660, 831], [833, 833, 867, 867, 1062], [1064, 1064, 1095, 1095, 1276], [1278, 1278, 1314, 1314, 1503], [1505, 1505, 1562, 1562, 2698]], "test": "valid"}
{"id": "MsKXDc", "name": "Cave of infinity", "author": "stduhpf", "description": "a test for raymarching 3D noise.\nThe normals seems broken.", "tags": ["procedural", "3d", "raymarching"], "likes": 5, "viewed": 255, "published": "Public", "date": "1467228200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float seed=0.; // seed used for the pseudo random number generator\n\nfloat interpol(float val){return smoothstep(0.,1.,val);}\n\n\nfloat rand01(vec2 co)\n{\n    return fract(seed+sin(seed+co.y*co.x*seed+dot(co,vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat rand55(vec2 co){return rand01(co)-.5;}\n\nvec3 getGrad(vec3 co){\n    return vec3(rand55(vec2(co.y*co.z,co.x)),rand55(vec2(co.y,co.x*co.z)),rand55(vec2(co.z,co.x*co.y)));}\n\nfloat perlin3D(vec3 uv)\n{\n             vec3 relco = fract(uv);\n         vec3 chco = floor(uv);\n        \n        vec3 grad1 = getGrad(chco);\n        vec3 grad2 = getGrad(chco+vec3(1,0,0));\n        vec3 grad3 = getGrad(chco+vec3(1,1,0));\n        vec3 grad4 = getGrad(chco+vec3(0,1,0));\n     \t\n    \tvec3 grad1t = getGrad(chco+vec3(0,0,1));\n        vec3 grad2t = getGrad(chco+vec3(1,0,1));\n        vec3 grad3t = getGrad(chco+vec3(1,1,1));\n        vec3 grad4t = getGrad(chco+vec3(0,1,1));\n        \n    \tfloat a = dot(grad1,relco);\n        float b = dot(grad2,relco-vec3(1,0,0));\n        float c = dot(grad3,relco-vec3(1,1,0));\n        float d = dot(grad4,relco-vec3(0,1,0));\n    \n    \tfloat a2 = dot(grad1t,relco-vec3(0,0,1));\n        float b2 = dot(grad2t,relco-vec3(1,0,1));\n        float c2 = dot(grad3t,relco-1.);\n        float d2 = dot(grad4t,relco-vec3(0,1,1));\n    \n            float noisea = mix(a,b,interpol(relco.x));\n        float noiseb = mix(d,c,interpol(relco.x));\n    float noise1 = mix(noisea,noiseb,interpol(relco.y));\n     \t\tfloat noiseat = mix(a2,b2,interpol(relco.x));\n        float noisebt = mix(d2,c2,interpol(relco.x));\n    float noise2 = mix(noiseat,noisebt,interpol(relco.y));\n        return  mix(noise1,noise2,interpol(relco.z));\n}\n\nvec2 map(vec3 p)\n{\n    float n = perlin3D(p)+.25*perlin3D(4.*p)+.1*perlin3D(15.*p);\n    return vec2(n*min(1.,length(p.xy))+.05,1);\n}\n\n\n\nvec2 intersect(vec3 ro, vec3 rd,float n)\n{\n    float f=0.;\n    for(int i = 0; i <200; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<0.01)\n                return vec2(f,h.y);\n               \tif(f > n)\n           break;\n        \n            f+=.8*h.x;\n    }\n    return vec2(0);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.0001,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x- vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    \n       vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    mse*=8.;\n    if(iMouse.xy==vec2(0))\n        mse*=0.;\n    mat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\n    mat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n    #define bg vec4(.12,.1,.15,.1)\n    vec3 ro = vec3(0,0,iTime*.5);\n    vec3 rd = normalize(vec3(2.*(uv),1.)*rdroty*rdrotx);\n    vec3 ld=normalize(vec3(0,.3,1));\n    vec2 i = intersect(ro,rd,10.);\n    vec4 col = bg;\n    if(i.y>0.)\n    {\n        col*=0.;\n        vec3 pos = i.x*rd+ro;\n        vec3 nor = normal(pos);\n        col+=.6+dot(nor,rd)/2.;\n        //col.rgb*=nor;\n        col*=texture(iChannel0,vec2(atan(pos.x,pos.y),pos.z));\n        col=mix(bg,col,min(1.,1./exp(.5*i.x)));\n    }\n    \n    \n\tfragColor = col;\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 68, 94, 94, 124], [127, 127, 150, 150, 241], [243, 243, 265, 265, 287], [289, 289, 311, 311, 417], [419, 419, 444, 444, 1671], [1673, 1673, 1691, 1691, 1805], [1809, 1809, 1851, 1851, 2101], [2103, 2103, 2124, 2124, 2290], [2293, 2293, 2350, 2350, 3298]], "test": "error"}
{"id": "MsVSRK", "name": "Apollonian Babel", "author": "soma_arc", "description": "Kissing Schottky Group (Apollonian Packing) + Terrain Raymarching", "tags": ["3d", "fractal", "kissingschottky"], "likes": 2, "viewed": 132, "published": "Public", "date": "1465537836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\nconst float PI = 3.14159265;\nconst vec2 c1Pos = vec2(0, 1);\nconst vec2 c2Pos = vec2(4, 4);\nconst vec2 c3Pos = vec2(-4, 4);\nconst float c1R = 1.;\nconst float c2R = 4.;\nconst float c3R = 4.;\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n    float d = distance(pos, circlePos);\n\treturn ((pos - circlePos) * circleR * circleR)/(d*d) + circlePos;\n}\n\nfloat loopNum = 0.;\nconst int ITERATIONS = 6;\nfloat IIS(vec2 pos){\n    loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tcont = false;\n\t\tif(distance(pos,c1Pos) < c1R){\n\t\t\tpos = circleInverse(pos, c1Pos, c1R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c2Pos) < c2R){\n\t\t\tpos = circleInverse(pos, c2Pos, c2R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c3Pos) < c3R){\n\t\t\tpos = circleInverse(pos, c3Pos, c3R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(pos.y < 0.){\n\t\t\tpos = vec2(pos.x, -pos.y);\n            cont = true;\n            loopNum++;\n\t\t}\n\t\tif(cont == false) break;\n\t}\n\tif(length(pos) < 3.5)\n        return float(ITERATIONS) + abs(loopNum - float(ITERATIONS));\n\treturn loopNum;\n}\n\n\nfloat calcHeight(vec2 p){\n    return IIS(p) * .8;\n}\n\nconst vec3 BLACK = vec3(0);\nfloat march(vec3 rayOrigin, vec3 rayDir){\n    const float delt = 0.02;\n    const float mint = .01;\n    const float maxt = 50.;\n    for( float t = mint; t < maxt; t += delt ) {\n        vec3 p = rayOrigin + rayDir * t;\n        if(p.y < calcHeight(p.xz)) {\n            return t - 0.5 * delt;\n        }\n    }\n    return -1.;\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 calcNormal(const vec3 p){\n  return normalize(vec3(calcHeight(p.xz - d.xy) - calcHeight(p.xz + d.xy),\n                     \t2. * d.x,\n                     \tcalcHeight(p.xz - d.yx) - calcHeight(p.xz + d.yx)));\n}\n\nconst float PI_4 = 12.566368;\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. ) ?\n    \t(lightPower * (d / (PI_4 * r * r))) * diffuseColor\n    \t: vec3(0.);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst vec3 lightPos = vec3(0, 100, 0);\nconst vec3 lightPower = vec3(50000.);\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \tfloat coeff = 1.;\n    float t = march(eye, ray);\n  \t\n    //if(t > 0.){\n        vec3 intersection = eye + ray * t;\n        vec3 normal = calcNormal(intersection);\n        vec3 matColor = intersection.y <= 0.1 ? vec3(0):vec3(hsv2rgb(vec3((loopNum -.5)/ 7. ,1., 1.)));\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n    //}\n  \treturn l;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 xaxis = normalize(cross(v, up));\n  \tvec3 yaxis =  normalize(cross(v, xaxis));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  \treturn normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = iTime;\n    t -= 2.9;\n    vec3 target = vec3(0., 0, 0);\n    vec3 eye;\n    target = vec3(sin(t), 0., 0.);\n    eye = vec3(cos(t) + sin(t) * cos(t),\n               6.5 + 9. * abs(cos(t)),\n               1. + 5. * sin(t));\n    const vec2 coordOffset = vec2(0.5);\n  \tvec3 ray = calcRay(eye, target, up, fov,\n    \t               iResolution.x, iResolution.y,\n        \t           gl_FragCoord.xy + coordOffset);\n\n  \tfragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVSRK.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[0, 320, 380, 380, 489], [537, 537, 557, 557, 1251], [1254, 1254, 1279, 1279, 1305], [1335, 1335, 1376, 1376, 1657], [1690, 1690, 1720, 1720, 1904], [1936, 1936, 2075, 2075, 2257], [2259, 2259, 2280, 2280, 2449], [2528, 2528, 2563, 2563, 2955], [2957, 2957, 3109, 3109, 3473], [3519, 3519, 3548, 3548, 3728], [3787, 3787, 3843, 3843, 4325]], "test": "valid"}
{"id": "MsVXDV", "name": "Bloom of Doom", "author": "Egomeh", "description": "A result of trying out stuff I don't know about : D", "tags": ["raymarch"], "likes": 3, "viewed": 162, "published": "Public", "date": "1466833984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    defines and consts\n*/\n# define PI           3.14159265358979323846  /* pi */\n\nconst float EPS = 0.001;\nconst int ITERATIONS = 255;\nconst float FAR = 50.0;\n\nconst vec3 lightPos = vec3(10., 10., 0.);\nconst vec3 lightColor = vec3(1., 1., 1.);\nconst float lightIntensity = 0.2;\n\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nvec3 rotateX(in vec3 p, float ang)\n{\n\tvec3 rotated = p;\n\trotated.y = p.y * cos(ang) - p.z * sin(ang);\n\trotated.z = p.y * sin(ang) + p.z * cos(ang);\n\treturn rotated;\n}\n\nvec3 rotateY(in vec3 p, float ang)\n{\n\tvec3 rotated = p;\n\trotated.x = p.x * cos(ang) + p.z * sin(ang);\n\trotated.z = p.x * -sin(ang) + p.z * cos(ang);\n\treturn rotated;\n}\n\nvec3 rotateZ(in vec3 p, float ang)\n{\n    vec3 rotated = p;\n    rotated.x = p.x * cos(ang) - p.z * sin(ang);\n    rotated.y = p.x * sin(ang) + p.z * cos(ang);\n    return rotated;\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdSphere(in vec3 p, in float r)\n{\n\treturn length(p) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat uni(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\n\nfloat query(vec3 p)\n{\n    vec3 p3, p2, p4, p5;\n    p5 = p4 = p3 = p2 = p;\n\n    float ang = sin(iTime) + p.y;\n    float ang2 = sin(iTime);\n\n\n    p2.x = mix(mod(p2.x,12.) - 6., p.x, step(20., abs(p.x)));\n    p2.z = mix(mod(p2.z,12.) - 6., p.z, step(20., abs(p.z)));\n\n    vec2 stepVar = floor(p.xz / 12.);\n\n    float steppedBlah = ( (sin(iTime * stepVar.x * .7) * sin(iTime*1.2 + stepVar.x * 3.) ) + 1.) * 2.;\n    steppedBlah += ( (sin(iTime*0.7 * stepVar.y * 4.) * sin(iTime*0.45 + stepVar.y * 4.) ) + 1.) * 2.;\n    float clampedSteppedBlah = clamp(steppedBlah, -5., 5.);\n\n    ang += steppedBlah / 10.;\n\n    p3 = rotateY(p2, ang);\n\n    float bdown = ((sin(iTime)) + 1.) * 0.5;\n    bdown *= 8.;\n\n    p4 = p3 - vec3(0., clampedSteppedBlah - bdown, 0.);\n\n\tp4.x += sin(p.y) * 2.;\n\n    p5 = p3 - vec3(0, clampedSteppedBlah + 6. - bdown, 0.);\n\n    ang2 += steppedBlah / 10.;\n    p5.x = p2.x * cos(ang2) + p2.z * sin(ang2);\n    p5.z = p2.x * -sin(ang2) + p2.z * cos(ang2);\n    \n    \n\n    float d1 = length(p4) - 1.0;\n    float d3 = sdBox(p4, 0.75 * vec3(1.,8.,0.2));\n    //d1 = smin(max(d1, d3), d3, 2.);\n    d1 = d3;\n\n    float d2 = p.y + (sin(p.x + iTime) + 1.) * 0.2\n                + (sin(p.x * 2. + iTime) + 1.) * 0.1\n                + (sin(p.x * 4. + iTime * 1.2) + 1.) * 0.1\n                + (sin(p.z * 2. + iTime) + 1.) * 0.1\n                + (sin(p.z * 4. + iTime * 2.1) + 1.) * 0.1;\n    float res = smin(d1, d2, 1.8);\n\n    float s = sdSphere(p5, exp(p.y / 10.0) - 1.) + sin(p.y * 3.);\n\n\tres = smin(s, res, 1.);\n\n    return res;\n}\n\nfloat intersect(vec3 o, vec3 r, out int iterations, out vec3 p, out bool hit)\n{\n    hit = false;\n\tfloat t = 0.0;\n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n\t\tp = o + r * t;\n        float d = query(p);\n        t += d * (0.2 + rand(p.xy) * EPS);\n        ++iterations;\n        if (d < EPS)\n        {\n            hit = true;\n        \tbreak;\n        }\n\n        if (t > FAR)\n        {\n            break;\n        }\n    }\n    return t;\n}\n\n\nvec3 gradient(vec3 p)\n{\n    vec3 px = p;\n    px.x += EPS;\n\n    vec3 py = p;\n    py.y += EPS;\n\n    vec3 pz = p;\n    pz.z += EPS;\n\n    return normalize(vec3(\n        \t\t\tquery(px) - query(p),\n        \t\t\tquery(py) - query(p),\n                    query(pz) - query(p) )\n    );\n}\n\nvec3 phong (in vec3 p, in vec3 normal, in vec3 viewDir, in vec3 matCol)\n{\n    vec3 pointToLight = ( lightPos - p );\n    vec3 lightDir = normalize(pointToLight);\n    vec3 diffuseComponent = matCol * max(0.0, dot(normal, lightDir));\n    vec3 specularComponent = vec3(1., 0., 1.) * pow(max(0.0, dot(reflect(lightDir, normal), viewDir)), 8.);\n    return diffuseComponent + specularComponent * step(0.001, dot(normal, lightDir)) + vec3(0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    float theta = iTime * 0.1;\n    float add_angle = PI / 2.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    uv = uv * 2.0 - 1.0;\n    uv.y = -uv.y;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y *= -1.;\n    \n    vec3 rs = normalize(vec3(uv, 1.5) - vec3(0., 0.5, 0.));\n    vec3 r = vec3(cos( (theta + add_angle) ) * rs.x - sin( (theta + add_angle) ) * rs.z,\n                      rs.y,\n                      sin( (theta + add_angle) ) * rs.x + cos( (theta + add_angle) ) * rs.z);\n    r = normalize(r);\n\n    float x = cos(theta);\n    float y = sin(theta);\n    vec3 o = vec3(x, 0.75, y) * 15.;\n    //o = vec3(0,1., -10.);\n    vec3 pos = vec3(0.);\n    bool hit = false;\n    int iterations = 0;\n\n    float t = intersect(o, r, iterations, pos, hit);\n\n    vec3 grad = gradient(pos);\n\n    float hitCol = 1. - step (FAR, t);\n\n    vec3 atmoColor = vec3(0.2,0.32,0.95);\n\n    vec3 viewDir = rs;\n\n    vec3 matCol = mix(vec3(0.25, 0.25, 0.80), vec3(0.87, 0.67, 0.2), pos.y * 0.1);\n    vec3 col = phong(pos, grad, viewDir, matCol);\n\n    col = mix(col, atmoColor, (t / FAR)) * hitCol;\n    col += max(0., (exp(float(iterations)/float(ITERATIONS)))) * vec3(0.2, 0.4, 0.7);\n\n\n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 283, 303, 303, 373], [375, 375, 412, 412, 452], [454, 454, 490, 490, 620], [622, 622, 658, 658, 789], [791, 791, 827, 827, 969], [971, 971, 1008, 1008, 1046], [1048, 1048, 1084, 1084, 1168], [1170, 1170, 1209, 1209, 1234], [1236, 1236, 1277, 1277, 1348], [1350, 1350, 1381, 1381, 1407], [1410, 1410, 1431, 1431, 2942], [2944, 2944, 3023, 3023, 3377], [3380, 3380, 3403, 3403, 3653], [3655, 3655, 3728, 3728, 4093], [4095, 4095, 4150, 4150, 5361]], "test": "valid"}
{"id": "MsVXzd", "name": "SSS Bondage Ball", "author": "aiekick", "description": "SSS Bondage Ball", "tags": ["sss", "ball", "bondage"], "likes": 2, "viewed": 468, "published": "Public API", "date": "1466164255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotX(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\t// get rotation matrix near x\nmat3 RotY(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\t// get rotation matrix near y\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\t// get rotation matrix near z\n\nmat3 m;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// matrice sx * y * z\n\nconst vec3 mat = vec3(1,0.52,0);\t\t\t\t\t\t\t\t\t// color material\n\nfloat pattern(vec3 p)\n{\n\tp = fract(p) - 0.5;\t\t\t\t\t\t\t\t\t\t\t\t// 2d repeat\n\treturn min(min(abs(p.x), abs(p.y)), abs(p.z)) + 0.56;\t\t\t// quad pattern\n}\n\nfloat effect(vec3 p) \n{\n\tp *= m;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// rotation xyz of p for one time here to reduce the calculation \n    float d = min(\t\t\t\t\t\t\t\t\t\t\t\t\t// min quad pattern with rotationnal layer\n\t\t\t\t\tmin(\n\t\t\t\t\t\tpattern(p), \t\t\t\t\t\t\t\t// pattern rotate near xyz one time\n\t\t\t\t\t\tpattern(p*m)), \t\t\t\t\t\t\t\t// pattern rotate near xyz two time\n\t\t\t\t\t\tpattern(p*m*m));\t\t\t\t\t\t\t// pattern rotate near xyz three time\n    return d/0.94; \t\t\t\t\t\t\t\t\t\t\t\t\t// reduce weight value with factor\n}\n\nvec4 df(vec3 p)\n{\n\tfloat dist = 1.-effect(p*0.2);\t\t\t\t\t\t\t\t\t// 3d pattern\n\tfloat lsp = length(p) - 5.;\t\t\t\t\t\t\t\t\t\t// sphere\n\tfloat sp = max(-lsp - 2.5, lsp) + dist * 3.;\t\t\t\t\t// empty sphere + pattern\n    return vec4(sp, vec3(step(dist, 0.4)));\t\t\t\t\t\t\t// df, df color strip\n}\n\nvec3 nor( vec3 p , vec3 e)\n{\n\treturn normalize(vec3(\t\t\t\t\t\t\t\t\t\t\t// normalized differenciate value along x, y and z for get normal at surf point\n\t    df(p+e.xyy).x - df(p-e.xyy).x,\t\t\t\t\t\t\t\t// diffenrencial over x fo surf point\n\t    df(p+e.yxy).x - df(p-e.yxy).x,\t\t\t\t\t\t\t\t// diffenrencial over y fo surf point\n\t    df(p+e.yyx).x - df(p-e.yyx).x ));\t\t\t\t\t\t\t// diffenrencial over z fo surf point\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,\tvec3( 0.0001, 0, 0)); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x/s;\t\t\t\t\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvec2 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, vec3( 0.0001, 0, 0));\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.6; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 0.5); \t\t\t\t\t\t\t// sub density of df\n\treturn vec2(\n        (diff + fre + spe) * amb * li, \t\t\t\t\t\t\t\t// ambiant diffuse + fresenl + specular => out\n        (diff + fre + sss) * amb * li + spe \t\t\t\t\t\t// ambient diffuse + fresnel + subsurface => in\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.05;\t\t\t\t\t\t\t\t\t\t// time for rotation matrices used by pattern in line 24\n    mat3 mx = RotX(-7.*(sin(time*2.)*.5+.5));\t\t\t\t\t \t\t// rotation matrice near axis x\n    mat3 my = RotY(-5.*(sin(time*1.5)*.5+.5));\t\t\t\t\t\t\t// rotation matrice near axis y\n    mat3 mz = RotZ(-3.*(sin(time)*.5+.5));\t\t\t\t\t\t\t\t// rotation matrice near axis z\n    m = mx*my*mz;\t\n    \n    vec2 g = fragCoord.xy;\t\t\t\t\t\t\t\t\t\t\t// pixel coord\n    vec2 si = iResolution.xy;\t\t\t\t\t\t\t\t\t\t// size of the creen\n\n\ttime = iTime * 0.5;\t\t\t\t\t\t\t\t\t\t// time for cam\n\t\n    float cam_e = 1.52; \t\t\t\t\t\t\t\t\t\t\t// cam elevation\n    float cam_d = 4.88; \t\t\t\t\t\t\t\t\t\t\t// cam distance to origin\n    \n    if (iMouse.z > 0.) \t\t\t\t\t\t\t\t\t\t\t\t// if mouse click on sreen\n    {\n        cam_d = 10. * iMouse.x/si.x;\t\t\t\t\t\t\t\t// cam distance range 0 to 10\n        cam_e = 5. * iMouse.y/si.y;\t\t\t\t\t\t\t\t\t// cam elevation range 0 to 5\n    }\n    \n    vec3 cu = vec3(0,1,0);\t\t\t\t\t\t\t\t\t\t\t// cam up\n  \tvec3 cv = vec3(0,0,0); \t\t\t\t\t\t\t\t\t\t\t// cam center view located on the center of the ball\n    \t\n    vec3 col = vec3(0.); \t\t\t\t\t\t\t\t\t\t\t// pixel color to out\n    \n    vec3 ro = vec3(-sin(0.), sin(cam_e), cos(0.))*cam_d; \t\t\t// ray origin\n\tvec3 lpi = vec3(-sin(time), sin(cam_e), cos(time))*0.3;\t\t\t// light point in ball\n\n  \tvec3 rov = normalize(cv-ro);\t\t\t\t\t\t\t\t\t// dir from ray origin to cam view center => axis z\n    vec3 u = normalize(cross(cu,rov));\t\t\t\t\t\t\t\t// perpendicular dir to plane fromed by cam up and rov => axis x\n  \tvec3 v = cross(rov,u);\t\t\t\t\t\t\t\t\t\t\t// perpendicular dir to plane fromed by u and rov => axis y\n  \tvec2 uv = (g+g-si)/si.y;\t\t\t\t\t\t\t\t\t\t// pixel coord in centered into the screen with screen ratio ( range -si.x/s.y to si.x/si.y for the x)\n    vec3 rd = normalize(rov + uv.x*u + uv.y*v);\t\t\t\t\t\t// ray dir of the current pixel in 3d\n    \n\tfloat md = 10.;\t\t\t\t\t\t\t\t\t\t\t\t\t// mas distance\n    float s = 1.;\t\t\t\t\t\t\t\t\t\t\t\t\t// ray marching step value ( radius of each sphere from df alogn ray marching)\n    float d = 0.;\t\t\t\t\t\t\t\t\t\t\t\t\t// distance from df to cam origine substepped by ray marching algo \n    for(int i=0;i<250;i++)\t\t\t\t\t\t\t\t\t\t\t// 250 iterations\n    {      \n        if (s<0.025*log(d*d/s/500.)||s>md) break;\t\t\t\t\t// one break condition when we are close df or when we are far of the df\n        s = df(ro+rd*d).x;\t\t\t\t\t\t\t\t\t\t\t// radius of the sphere to df from ray point ( ro + rd *d => ray origin + ray direction * distance ) \n        d += s * 0.2;\t\t\t\t\t\t\t\t\t\t\t\t// sub stepping of the df for improved the float precision of the df on pc with double its not necessary\n    }\n    \n    if (d<md)\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if distance ot the df is less than max distance, so ray dir is on df\n    {\n\t\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t// surf point\n\t\tfor (float i = 0.; i < 1.; i+=0.1)\t\t\t\t\t\t\t// sub surface iteration \n\t\t\tcol = mix(col, shade(p, rd, i, lpi, i).y * mat, i);\t\t// sub shade a dfiferent level of trnsparance with i\n        col = mix(col, shade(ro, rd, d, ro, 1.).x * (mat+0.3), 0.7);// add shade for external reflectivity\n       \tcol = min(col, df(p).yzw);\t\t\t\t\t\t\t\t\t// add pattern strip\n    }\n    \n\tfragColor.rgb = col;\t\t\t\t\t\t\t\t\t\t\t// write pixel color to the gpu buffer\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVXzd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 196, 215, 215, 273], [274, 304, 323, 323, 381], [382, 412, 431, 431, 489], [608, 627, 650, 650, 770], [772, 772, 795, 795, 1231], [1233, 1233, 1250, 1250, 1502], [1504, 1504, 1532, 1532, 1893], [1895, 1895, 1931, 1931, 2091], [2093, 2093, 2151, 2151, 2931], [2933, 2933, 2990, 2990, 6084]], "test": "valid"}
{"id": "MsySWK", "name": "Raymarched 2D Sierpinski", "author": "Shane", "description": "Raymarching a 2D Sierpinski Carpet pattern.", "tags": ["raymarch", "heightmap", "environment", "sierpinski"], "likes": 60, "viewed": 4088, "published": "Public API", "date": "1466948852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tRaymarched 2D Sierpinski\n\t------------------------\n\n\tRaymarching a 2D Sierpinski Carpet pattern. The raymarching process is pretty straight\n\tforward. Basically, Sierpinski height values are added to a plane. Height maps with \n\tsharp edges don't raymarch particularly well, so a little edge smoothing was necessary,\n\tbut that's about it.\n\n\tThe rest is just lighting. Most of it is made up. A bit of diffuse, specular, fake \n\tenvironment mapping, etc.\n\t\n\n*/\n\n#define FAR 5.\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Sierpinski Carpet heightmap - Essentially, space is divided into 3 each iteration, \n// and a shape of some kind is rendered. In this case, it's a smooth edged rectangle (w)\n// with a bit of curvature (l) around the sides.\n//\n// There are some opportunites to optimize, but I'll leave it partly readable for now.\n//\nfloat heightMap(vec2 p){\n    \n    p /= 2.; // Extra scaling.\n    \n    float  h = 0., a = 1., sum = 0.; // Height, amplitude, sum.\n    \n    for(int i=0; i<4; i++){\n    \n        p = fract(p)*3.; // Subdividing space.\n        // Far more interesting, mutated subdivision, courtesy of Aiekick.\n        //p = fract(p+sin(p.yx*9.)*0.025 + cos(p.yx*9.)*0.025)*3.; \n        // Another one with a time component.\n        //p = fract(p + sin(p*9. + cos(p.yx*13. + iTime*2.))*0.02)*3.;\n        \n        vec2 w = .5 - abs(p - 1.5); // Prepare to make a square. Other shapes are also possible.\n        float l = sqrt( max(16.0*w.x*w.y*(1.0-w.x)*(1.0-w.y), 0.))*.5+.5; // Edge shaping.\n        w = smoothstep(0., .05, w); // Smooth edge stepping.\n        h = max(h, w.x*w.y*a*l); // Producing the smooth edged, shaped square.\n        //h += w.x*w.y*a*l;\n        //h = max(h, abs(abs(w.x)-abs(w.y))*a*l);\n        sum += a; // Keep a total... This could be hardcoded to save cycles.\n        a *= .4; // Lower the amplitude for the next subdivision, just because it looks tidier.\n        //if(i==2)a*=.75;\n    }\n    \n    return h/sum;\n    \n}\n\n// Raymarching a heightmap on an XY-plane. Pretty standard.\nfloat map(vec3 p){\n\n    // Cheap, lame distortion, if you wanted it.\n    //p.xy += sin(p.xy*7. + cos(p.yx*13. + iTime))*.01;\n    \n    // Back plane, placed at vec3(0, 0, 1), with plane normal vec3(0., 0., -1).\n    // Adding some height to the plane from the heightmap. Not much else to it.\n    return 1. - p.z - heightMap(p.xy)*.125;\n    \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Standard normal function.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 3., occ = 0.;\n    for(int i=0; i<5; i++){\n    \n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    // Note that the ray is starting just above the raised plane, since nothing is\n    // in the way. It's normal practice to start at zero.\n    float d, t = 0.75; \n    for(int j=0;j<32;j++){\n      \n        d = map(ro + rd*t); // distance to the function.\n        // The plane \"is\" the far plane, so no far=plane break is needed.\n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n\n        t += d*.7; // Total distance from the camera to the surface.\n    \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// It gives you a scalar curvature value for an object's signed distance function, which \n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n// calculations, I'm assuming. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = 0.02, amp = 8., ampInit = 0.6;\n\n    vec2 e = vec2(-1., 1.)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 envMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit directional ray with no divide, courtesy of Coyote.\n    vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n    \n    // Rotating the XY-plane back and forth, for a bit of variance.\n    // 2D rotation with fewer instructions, courtesy of Fabrice Neyret.\n    vec2 a = sin(vec2(1.570796, 0) - sin(iTime/4.)*.3);\n    rd.xy = rd.xy*mat2(a, -a.y, a.x);\n    \n    \n    // Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(iTime, cos(iTime/4.), 0.);\n    \n    \n    // Light position, hovering around camera.\n    vec3 lp = ro + vec3(cos(iTime/2.)*.5, sin(iTime/2.)*.5, -.5);\n    \n    // Standard raymarching segment. Because of the straight forward setup, not many \n    // iterations are needed.\n \tfloat t = trace(ro, rd);\n    \n   \n    // Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp);\n    \n    \n\t// Texture scale factor.\n    const float tSize0 = 1./2.;\n    // Texture-based bump mapping.\n\tsn = doBumpMap(iChannel0, sp*tSize0, sn, 0.002);    \n    \n    \n    // Point light.\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light distance.\n    float atten = 1./(1. + lDist*lDist*.125); // Light attenuation.\n    ld /= lDist; // Normalizing the light direction vector.\n    \n   // Obtaining the surface texel, then ramping up the contrast a bit.\n    vec3 oC = smoothstep(0., 1., tex3D(iChannel0, sp*tSize0, sn));\n    // Using the height map to highlight the raised squares. Not for any particular reason.\n    oC *= smoothstep(0., .125, heightMap(sp.xy))*1.5 + .5;\n\n    \n    float diff = max(dot(ld, sn), 0.); // Diffuse.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.); // Specular.\n    float fre = clamp(dot(sn, rd) + 1., .0, 1.); // Fake fresnel, for the glow.\n    \n    // Shading. Note, there are no actual shadows. The camera is front on, so the following\n    // two functions are enough to give a shadowy appearance.\n    float crv = curve(sp); // Curve value, to darken the crevices.\n    float ao = calculateAO(sp, sn); // Ambient occlusion, for self shadowing.\n \n    \n    // Combining the terms above to light the texel.\n    vec3 col = (oC*(diff + .25) + vec3(1, .7, .3)*spec) + vec3(.1, .3, 1)*pow(fre, 4.)*4.;\n    \n    col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.; // Fake environment mapping.\n    //col += envMap(reflect(rd, sn), sn)*4.;\n    \n    // Applying the shades.\n    col *= (atten*crv*ao);\n    \n    // Vignette.\n    vec2 uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125);\n\n    \n    // Presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsySWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[478, 636, 686, 686, 871], [873, 941, 959, 959, 1305], [1307, 1625, 1649, 1649, 2749], [2751, 2811, 2829, 3100, 3151], [3153, 3340, 3402, 3402, 3912], [3915, 3944, 3971, 3971, 4130], [4132, 4284, 4329, 4329, 4577], [4579, 4600, 4636, 4782, 5139], [5141, 5777, 5800, 5800, 6121], [6124, 6379, 6409, 6409, 7023], [7025, 7025, 7081, 7155, 9777]], "test": "error"}
{"id": "MsySzG", "name": "Galeria de Cupido", "author": "hecLu", "description": "Autores:\nLucia Cubel\nHector Suarez\n\nPractica 1 de PGATR \nShader de San Valentin 2016: La Galeria de Cupido (shader2 comentado por no ser igual al del video)\nVideo completo del shader en el enlace\nhttps://youtu.be/7ChTuGi6pWc", "tags": ["heart", "valentine", "pgatr", "love", "migjrv"], "likes": 0, "viewed": 429, "published": "Public API", "date": "1464956534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*****************************************************************************************\n*Shader realizado para la asignatura Procesadores Graficos y Aplicaciones en Tiempo Real\n*\n* Autores:\n* LucÃ­a Cubel\n* HÃ©ctor SuÃ¡rez\n*\n*Shader de san valentin \"La GalerÃ­a de Cupido\"\n*\n*Video completo del shader en el enlace https://www.youtube.com/watch?v=7ChTuGi6pWc\n******************************************************************************************/\n\n#define PI 3.14159265359\n#define zoom .45\n#define offset vec2(1.,1.1)\n\n#define iterations 9\n#define scale 1.3+iMouse.y/iResolution.y\n#define minscale .4\n#define trans .75-iMouse.x/iResolution.x\n\n#define orbittraps vec3(3.,2.,1.)\n#define trapswidths vec3(1.5,1.,.5)\n\n#define trap1color vec3(1.00,0.40,0.10)\n#define trap2color vec3(0.35,0.25,1.00)\n#define trap3color vec3(1.,1.,0.05)\n\n#define trapsbright vec3(1.2,1.5,1.)\n#define trapscontrast vec3(10.)\n\n#define rotspeed .2\n\n#define saturation .5\n#define brightness 2.\n#define contrast 1.5\n\n#define antialias 4. //max 4\n\n#define numRadios 7\n#define numCapas 3\n#define numCapas2 20\nvec2 fragCoord2;\n\nvec2 animatePos(vec2 pos){\n\tfloat tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + pos.y*0.5)*exp(-tt*4.0);\n    pos *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\treturn pos;\n}\n\n/*****************************************************************************************\nCodigo obtenido del sahder \"Â¨Heart\" iq\n******************************************************************************************/\n\n//funcion para pintar un corazon\n//pide origen del corazon, fragmento con el que se trabaja, un factor de forma\n//que afectara al tamaÃ±o del corazon y el color de fondo\nvoid corazon(vec2 origen, vec2 posicion,float tamanio,inout vec3 color){\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\n\t// color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    color = mix( color, hcol, smoothstep( -0.01, 0.01, d-r) );\n}\n\n//funcion para pintar un corazon\n//pide origen del corazon, fragmento con el que se trabaja, un factor de escalado\n//que afectara al tamaÃ±o del corazon, el color de fondo y el color del corazon\nvec3 corazon2(vec2 origen, vec2 posicion,float tamanio,vec3 color,vec3 colorCorazon){\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\t\n    vec3 result = mix( color, colorCorazon, smoothstep( -0.01, 0.01, d-r) );\n\treturn result;\n}\nvec3 corazon3(vec2 origen, vec2 posicion,float tamanio,vec3 color){\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\n\t// color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    color = mix( color, hcol, smoothstep( -0.01, 0.01, d-r) );\n\treturn color;\n}\nvoid corazon4(vec2 origen, vec2 posicion,float tamanio,inout vec3 color){\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\n\t// color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    color = mix( color, hcol, -0.1-smoothstep( -0.06, 0.001, d-r) );\n}\nfloat rand(vec2 n) \n{\n\treturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 );\n}\nfloat noise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) \n{\n\tfloat total = 0.0, amplitude = 0.5;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= .5;\n\t}\n\t\n\treturn total;\n}\nvec3 getColor(){\n\tvec2 p = vec2(fragCoord2.xy / iResolution.xy);\n\tvec2 r =  3.0*vec2(fragCoord2.xy + 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\tret = vec3(sin(v+0.5*PI)*0.1, sin(v)*0.3+0.2, 1.0);\n\t\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n\treturn ret;\n}\nvoid corazonFbm(vec2 origen, vec2 posicion,float tamanio,inout vec3 color){\n\t//Centrar el cÃ­rculo\n\tvec2 v =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 w = v*v;\n\tfloat centerCirculito = w.x+w.y;\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\n\t//Color original + modificado aniadiendo \"Fractional Brownian Motion\"\n\tfloat q = fbm(p);\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(2.0*q*1.0,4.0*q*0.5*r-1.0,3.0*q*0.3-2.0)*s;\n\t\n\t//RatÃ³n\n\tvec2 center;\n\tvec3 col1 = vec3(0,0,0); //Color del cursor\n\tvec3 col4 = vec3(0,0,0); // P!nk\t\n\t\n\tvec3 bgCol = vec3(iMouse.x / iResolution.x,clamp(iMouse.y / iResolution.y,0.0,1.0),(cos(iMouse.x / iMouse.y)+1.0)*0.5);\n\tvec3 ret = bgCol;\n\t//Forma del cursor.\tPodrÃ­a estar dentro de una funciÃ³n.\t\n\t\n\tvec2 m = (fragCoord2.xy-iMouse.xy)/min(iMouse.y,iMouse.x);\n\t\n\tfloat am = (atan(m.x,m.y)/3.141593);\n    float rm = length(m);\n    float hm = abs(am);\n    float dm = (13.0*hm - 22.0*hm*hm + 10.0*hm*hm*hm)/(6.0-5.0*hm)*1.0/4.0;\t\n\t\n    vec3 col2 = mix( color, hcol, -0.9*smoothstep( -0.2, 0.001, dm-rm) );\t\n\t\n    vec3 col= mix( bgCol, hcol, smoothstep( -0.8, 0.1, d-r) );\n\tcol += ret+col2;\t\n\tif (centerCirculito < 0.00004)//pequeÃ±o para que no se vea\n\t{\n\t col = hcol;\n\t}\n\tcolor=col;\n}\nvec2 rotate(vec2 p, float angle) {\nreturn p*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\nvec3 caleidoscopio(vec2 uv){\n\tvec3 aacolor=vec3(0.);\n\t\n\tfloat aspect=iResolution.x/iResolution.y;\n\tvec2 pos=uv;\n\tpos.x*=aspect;\n\tfloat zoo=1./zoom;\n\tpos*=offset;\n\tpos*=zoo; \n\tvec2 pixsize=1./iResolution.xy*zoo;\n\tpixsize.x*=aspect;\n\tfloat av=0.;\n\tvec3 its=vec3(0.);\n\tfloat t=iTime*rotspeed;\n\tfor (float aa=0.; aa<16.; aa++) {\n\t\tvec3 otrap=vec3(1000.);\n\t\tif (aa<antialias*antialias) {\n\t\t\tvec2 aacoord=floor(vec2(aa/antialias,mod(aa,antialias)));\n\t\t\tvec2 z=pos+aacoord*pixsize/antialias;\n\t\t\tfor (int i=0; i<iterations; i++) {\n\t\t\t\tz=abs(z)-aspect*trans;\n\t\t\t\tz=rotate(z,-t+3.3);\n\t\t\t\tfloat l=dot(z,z);\n\t\t\t\tz/=clamp(l,minscale,1.);\n\t\t\t\tz=z*scale-1.;\n\t\t\t\tvec3 ot=abs(vec3(l)-orbittraps);\n\t\t\t\tif (ot.x<otrap.x) {\n\t\t\t\t\totrap.x=ot.x;\n\t\t\t\t\tits.x=float(iterations-i);\t\n\t\t\t\t}\n\t\t\t\tif (ot.y<otrap.y) {\n\t\t\t\t\totrap.y=ot.y;\n\t\t\t\t\tits.y=float(iterations-i);\t\n\t\t\t\t}\n\t\t\t\tif (ot.z<otrap.z) {\n\t\t\t\t\totrap.z=ot.z;\n\t\t\t\t\tits.z=float(iterations-i);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\totrap=pow(max(vec3(0.),trapswidths-otrap)/trapswidths,trapscontrast);\n\t\tits=its/float(iterations);\n\t\tvec3 otcol1=otrap.x*pow(trap1color,3.5-vec3(its.x*3.))*trapsbright.x;\n\t\tvec3 otcol2=otrap.y*pow(trap2color,3.5-vec3(its.y*3.))*trapsbright.y;\n\t\tvec3 otcol3=otrap.z*pow(trap3color,3.5-vec3(its.z*3.))*trapsbright.z;\n\t\taacolor+=(otcol1+otcol2+otcol3)/3.;\n\t}\n\taacolor=aacolor/(antialias*antialias);\n\tvec3 color=mix(vec3(length(aacolor)),aacolor,saturation)*brightness;\n\tcolor=pow(color,vec3(contrast));\t\t\n\tcolor*=vec3(1.2,1.15,1.);\n\tcolor*=1.-pow(max(0.,max(abs(uv.x),abs(uv.y))-.4)/.1,8.);\n\treturn color;\n}\n//funcion que dibuja un rombo rojo\nvoid rombo(vec2 r,vec2 centro,float factorD,float xMax,inout vec3 pixel){\n\t//comprobamos que el punto se encuentra dentro de unos valores maximos\n\tvec2 punto=vec2(abs(r.x-centro.x),abs(r.y-centro.y));\n\tfloat pinta=step(punto.x,xMax)*step(punto.y,(xMax/factorD));\n\t//Si el punto no esta dentro de las cotas, pinta vale 0\n\t//y se devuelve el color original del pixel\n\t\n\t//evaluamos si el punto esta dentro del rombo. Para ello se divide el area\n\t//del rombo en cuadrantes, y se evalua solo aquellos puntos contenidos en la\n\t//zona comprendida por las x e y positivas. Se aplica valor absoluto al punto\n\t//r para evaluar simultaneamente si el valor se encuentra dentro de uno de los\n\t//cuadrantes\n\tfloat valorX=xMax-(factorD*punto.y);\n\t//Para hacer la evaluacion se traza una recta cuya ecuacion es la siguiente:\n\t//x=xMax-factorD*y\n\t//Se obtine la x tomando la y del punto introducido. Si la x resultante es\n\t//mayor o igual que la x del punto pasado entonces el punto pertenece al rombo\n\tif(valorX>=punto.x){\n\t\tpixel=(pixel*abs(pinta-1.0))+(vec3(1.0,0.0,0.0)*pinta);\n\t}\n}\n//pinta un circulo. Fragmento de codigo extraido de los tutoriales\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tfloat m=1.0 - smoothstep( radius-0.02, radius+0.02, length(r-center));\n\tpixel=mix(pixel,color,m);\n}\n//funcion que evalua el estado de la luna\nvoid estadoLuna(vec2 r,vec2 centroEstatico,vec2 centroDinamico,float radio,inout vec3 luna,inout vec3 pixel){\n\tluna=vec3(1,1,0.5);\n\t//se toman dos centros el de la luna que es estatico, un que se mueve de\n\t//acuerdo trancurre el tiempo. Si el punto se encuentra a una distancia menro\n\t//que el radio introducido se cambia el color de la luna en ese punto\n\t//por otro que simula que la luna esta desapareciendo\n\tif( (length(r-centroEstatico) < radio+0.02)&&(length(r-centroDinamico) < radio+0.02)) {\n\t\tluna=vec3(0,0,0.05);\n\t}\n}\n//funcion que pinta una luna\nvoid luna(vec2 r, float t, inout vec3 pixel){\n\tvec3 colorLuna;\n\tvec2 centroLuna=vec2(-7.0, 5.3);\n\tfloat radio=1.9;\n\tfloat y=centroLuna.y;\n\tfloat x=t;\n\tx =\t(0.0-mod(x,41.0)-15.0)*0.2;\n\tvec2 cicloLuna=vec2(x,y);\n\testadoLuna(r,centroLuna,cicloLuna,radio,colorLuna,pixel);\n\tdisk(r, centroLuna, radio, colorLuna, pixel);\n}\n//Worley+plasma azul\nvec3 water(){\n\tvec2 pos = gl_FragCoord.xy / iResolution.yy;\n\tpos += vec2(sin(pos.x * 12.0 + iTime) * 0.017 + sin(pos.y * 27.0 + 2.0 * iTime) * 0.015);\n\n\tfloat numTiles = 10.0;\n\t\n\tvec2 curretTile = floor(pos * numTiles);\n\tpos = fract(pos * numTiles) + 1.0;\n\t\n\tfloat minDist = 2.0;\n\t\n\tfor(float y = -1.0; y < 2.0; y++) {\n\n\t\tfor(float x = -1.0; x < 2.0; x++) {\n\t\t\tfloat po = rand( vec2(curretTile.x + x, curretTile.y + y) );\n            //Animacion basada en un shader de iq (https://www.shadertoy.com/view/ldl3W8)\n            //con nuestro pequeÃ±o toque personal\n\t\t\tpo=0.5 + 0.4*cos( iTime + 6.2831*po );\n\t\t\tvec2 point = vec2( (1.0 + x) + po , (1.0 + y) + (1.0 - po) );\n\t\t\t\n\t\t\tfloat dist = distance(pos, point);\n\t\t\tfloat cond=float(minDist > dist);\n\t\t\tminDist =minDist*(1.0-cond)+dist*cond;\n\t\t}\n\n\t}\n\tvec3 color=mix(getColor()*0.4,getColor(),smoothstep(0.0,1.0,clamp(minDist*0.9,0.0,1.0)));\n\treturn color;\n}\n////////////////////////////////////////////////////////////////////////////////////////////\nfloat lineas(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\t}\n\treturn ret;\n}\nfloat lineas2(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret -= 2.-smoothstep(0.01, 0.015, abs(r.x));\n\t}\n\treturn ret;\n}\nfloat lineasB(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret -= 2.-smoothstep(0.001, 0.015, abs(r.x));\n\t}\n\treturn ret;\n}\nvec3 parteB(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\tvec3 color1 = vec3(0.8, 0.8, 0.8); // \n\tfloat incrementoAngulo=(2.0/float(7))*PI;\n\tfor(int i=0;i<numRadios;i++){\n\t\tfloat angle=mod((float(i)*incrementoAngulo+t),2.0*PI);\n\t\tvec2 q=vec2(0.0,0.0);\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\tq=-q;\n\t\tcolorFondo = mix(colorFondo, color1, lineasB(q) );\n\t}\n\t\n\tfloat tamanioMax=1.1;\n\tfloat tamanioMin=0.4;\n\tfloat escalaHilo=0.25;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.15);\n\tfor(int i=0;i<numCapas;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tcorazon(posicion,p,tamanioMin,colorFondo);\n\treturn colorFondo;\n}\nfloat lineasC(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret += 1.+smoothstep(0.001, 0.101, abs(r.x));\n\t}\n\treturn ret;\n}\nvec3 parteC(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\tvec3 color1 = vec3(0.8, 0.8, 0.8); \n\tfloat incrementoAngulo=(2.0/float(7))*PI;\n\tfor(int i=0;i<numRadios;i++){\n\t\tfloat angle=float(i)*incrementoAngulo-mod(t,2.0*PI);\n\t\tvec2 q=vec2(0.0,0.0);\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\tq=-q;\n\t\tcolorFondo = mix(colorFondo, color1, lineasC(q) );\n\t}\n\t\n\tfloat tamanioMax=1.1;\n\tfloat tamanioMin=0.4;\n\tfloat escalaHilo=0.25;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.15);\n\tfor(int i=0;i<numCapas;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tcorazon(posicion,p,tamanioMin,colorFondo);\n\treturn colorFondo;\n}\nfloat lineasD(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret -= 1.-smoothstep(0.001, 0.503, abs(r.x));//cambio grosor y smooth de lineas de telaraÃ±a\n\t}\n\treturn ret;\n}\nvec3 parteD(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\tvec3 color1 = vec3(0.8, 0.8, 0.8); \n\tfloat incrementoAngulo=(2.0/float(7))*PI;\n\tfor(int i=0;i<numRadios;i++){\n\t\tfloat angle=float(i)*incrementoAngulo+mod(t,2.0*PI);\n\t\tvec2 q=vec2(0.0,0.0);\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\tq=-q;\n\t\tcolorFondo = mix(colorFondo, color1, lineasD(q) );\n\t}\n\t\n\tfloat tamanioMax=1.1;\n\tfloat tamanioMin=0.4;\n\tfloat escalaHilo=0.25;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.15);\n\tfor(int i=0;i<numCapas;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tcorazon(posicion,p,tamanioMin,colorFondo);\n\treturn colorFondo;\n}\nvec3 shader1(){\n\tfloat t=iTime;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec2 p2=p;\n\t\n\tp.y /= 0.25;\n\tp.x/=0.25;\n\t\n\t\n\tvec3 color = vec3(2.0,0.8,0.3-1.07*p.y)*(1.0-0.25*length(p));\t//cambia valores de fondo y hace gradiente\n\t\n\n\n\n\tfloat y=0.5;\n\tfloat x=t*0.5;\n\tx =\t(-mod(x,4.5)+2.1);\n\tvec2 origen1=vec2(x,y);\n\tx=t*0.5;\n\tx =\t(mod(x,4.5)-2.1);\n\tvec2 origen2=vec2(x,y);\n\t//para trabajar mejor con la operacion modulo, se multiplica la coordenada\n\t// actual ,comprendiada entre -1 y 1, por un entero y se desacha la parte \n\t//decimal\n\t//pintado por franjas\n\tint posY= int(floor(p.y*4.0));\n\t\n\t//la segunda entrada del modulo indicara la division del espacio\n\tif(int(mod(float(posY),2.0))==0){\n\t\tcorazon(origen1,p,1.00,color);\n\t}else{\n\t\tcorazon(origen2,p,1.0,color);\n\t}\n\treturn color;\n}\n/*\nvec3 shader2(){\n\tvec2 p = vec2(fragCoord2.xy / iResolution.xy);\n\tvec2 p2 = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n\tr = r * 8.0;\n\tvec3 ret;\n\t//pintamos el cielo\n\tret = texture(iChannel0, p).xyz*vec3(0.5,0.5,0.7);\n\tif(p.y < 1./3.){\n\t// Plasma de color rosa. \n\t//Simula amor(Fragmento de codigo extraido de los tutoriales)\n\t\tvec3 colorCielo=ret;\n\t\tfloat v1 = sin(r.x +t);\n\t\tfloat v2 = sin(r.y +t);\n\t\tfloat v3 = sin(r.x+r.y +t);\n\t\tfloat v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);\n\t\tfloat v = v1+v2+v3+v4;\n\t\tv *= 1.0;\n\t\tret = vec3(1.0, clamp(sin(v+0.5*PI),0.0,0.7), 1.0);\n\t\tret = 0.3+ 0.7*ret;\n\t\tfloat m = smoothstep(0.15, 0.3, p.y);\n\t\tret = mix(ret, colorCielo, m);\n\t}\n\tvec3 pixel = ret;\n\t//pintamos la luna\n\tluna(r,t,pixel);\n\tfloat intervaloTiempo=2.0;\n\t//evaluamos si hay que pintar rombos\n\tint mostrar=1;\n\tif(mod(floor(t),intervaloTiempo)==0.0){\n\t\tmostrar=int(abs(float(mostrar-1)));\n\t}\n\t//pintamos 2 rombos(+18 anios) parpadeantes\n\tif(mostrar==1){\n\t\trombo(r, vec2(8.0,6),0.5,0.5,pixel);\n\t\trombo(r, vec2(9.0,6),0.5,0.5,pixel);\n\t}\n\tfloat escala=0.2;\n\tfloat y=mod(t,2.0)-1.0;\n\tvec2 pos1=vec2(sin(y*8.0)*0.2-0.8,y);\n\tpixel=mix(corazon3(pos1,p2,escala,pixel),pixel,smoothstep(-1.0,2.0,y));\n\t\n\ty=mod(t,1.5)-1.0;\n\tvec2 pos2=vec2(sin(y*8.0)*0.3-0.6,y);\n\tpixel=mix(corazon3(pos2,p2,escala,pixel),pixel,smoothstep(-1.0,1.0,y));\n\t\n\ty=mod(t,4.0)-1.0;\n\tvec2 pos3=vec2(sin(y*8.0)*0.1-0.5,y);\n\tpixel=mix(corazon3(pos3,p2,escala,pixel),pixel,smoothstep(-1.0,3.0,y));\n\t\n\ty=mod(t,2.0*PI)-1.0;\n\tvec2 pos4=vec2(sin(y*8.0)*0.2-0.3,y);\n\tpixel=mix(corazon3(pos4,p2,escala,pixel),pixel,smoothstep(-1.0,2.0*PI-1.0,y));\n\t\n\ty=mod(t,2.5)-1.0;\n\tvec2 pos5=vec2(sin(y*8.0)*0.2+0.1,y);\n\tpixel=mix(corazon3(pos5,p2,escala,pixel),pixel,smoothstep(-1.0,1.5,y));\n\t\n\ty=mod(t,PI)-1.0;\n\tvec2 pos6=vec2(sin(y*8.0)*0.2+0.5,y);\n\tpixel=mix(corazon3(pos6,p2,escala,pixel),pixel,smoothstep(-1.0,PI-1.0,y));\n\t\n\ty=mod(t,3.0)-1.0;\n\tvec2 pos7=vec2(sin(y*8.0)*0.2+0.7,y);\n\tpixel=mix(corazon3(pos7,p2,escala,pixel),pixel,smoothstep(-1.0,2.0,y));\n\t\n\treturn pixel;\n}*/\nvec3 shader3(){\n\tvec3 color=(parteB()+parteC()+parteD())/1.5;\n\treturn color;\n}\nvec3 shader4(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = water();\n\tr=animatePos(r);\n\tp=animatePos(p);\n\t\n\tvec3 color1 = vec3(0.8, 0.8, 0.8); \n\tfloat incrementoAngulo=(2.0/float(7))*PI;\n\tfor(int i=0;i<numRadios;i++){\n\t\tfloat angle=float(i)*incrementoAngulo;\n\t\tvec2 q=vec2(0.0,0.0);\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\tq=-q;\n\t\tcolorFondo = mix(colorFondo, color1, lineas(q) );\n\t}\n\t\n\tfloat tamanioMax=1.1;\n\tfloat tamanioMin=0.4;\n\tfloat escalaHilo=0.25;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.15);\n\tfor(int i=0;i<numCapas;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tcorazon4(posicion,p,tamanioMin,colorFondo);\n\treturn colorFondo;\n}\n\nvec3 shader5(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*gl_FragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = vec3(1.050*p.y,0.8-0.2*p.y*0.5,0.7-0.57*p.y)*(1.05-0.25*length(p)); //cambiar valores vec3 //primer valor de vec3 //segundo valor\n\tvec3 color1 = vec3(0.78, 0.8, 0.7); // 0.7 mas rosita\n\tfloat t2=mod(t,14.0);\n //cambiando el num de radios hace una especie de superposicion, en este caso de 6 parece que salen rayos y vienen hacia tÃ­\n\tfloat incrementoAngulo=(2.0/float(7))*PI; //cambiando el angulo salen cosas\n\tfor(int i=0;i<numRadios;i++){\n\t\tif(i<(int(clamp(t2,0.0,7.0))-int(t2/7.0)*int(mod(t2,7.0)))){\n\t\t\tfloat angle=float(i)*incrementoAngulo;\n\t\t\tvec2 q=vec2(0.0,0.0);\n\t\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\t\tq=-q;\n\t\t\tcolorFondo = mix(colorFondo, color1, lineas2(q) );\n\t\t}\n\t}\n\t\n\tfloat tamanioMax=3.5; //\n\tfloat tamanioMin=0.082; //mas pequeÃ±o el corazon\n\tfloat escalaHilo=0.15;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas2);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.01);//ajustar el corazon al centro\n\tfor(int i=0;i<numCapas2;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tvec2 pos=(2.0*iMouse.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tfloat escalaMax=1.2;\n\tcorazon(posicion,p,escalaMax-clamp(length(pos),0.0,escalaMax),colorFondo);\n\treturn colorFondo;\n}\nvec3 shader6(){\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec2 uv=fragCoord2.xy / iResolution.xy - 0.5;\n\t\n\tvec3 color=caleidoscopio(uv);\n\tvec2 centerHeart;\n\tcenterHeart = vec2(iResolution.x/2., iResolution.y/2.);\n\tfloat radius = 20.0;\t\n\t\n\t//Si el cursor esta dentro de la circunferencia, el corazÃ³n se anima.\n\tif( length(iMouse.xy-centerHeart)<radius ) {\t\t\n\t\tfloat tt = mod(iTime,1.5)/1.5;\n\t\tfloat ss = pow(tt,.2)*0.5 + 0.5;\n\t\tss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n\t\tp *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\t}\n\tvec2 posicion=vec2(0.0,0.2);\n\tfloat escala=1.0;\n\tcorazonFbm(posicion,p,escala,color);\n\treturn color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=iTime;\n\tfloat momento=float(mod(t,120.0));\n    fragCoord2=fragCoord;\n\tvec3 color=vec3(0.0);\n    \n\tif(momento<=15.0){\n\t\tcolor=shader1();\n\t}else if(momento>15.0&&momento<22.0){\n\t\tcolor=mix(shader1(),shader3(),smoothstep( 15.0, 22.0, momento));\n\t\t\n\t}else if(momento>=22.0&&momento<=37.0){\n\t\tcolor=shader3();\n\t\t\n\t}else if(momento>37.0&&momento<44.0){\n\t\tcolor=mix(shader3(),shader4(),smoothstep( 37.0, 44.0, momento));\n\t\t\n\t}else if(momento>=44.0&&momento<=59.0){\n\t\tcolor=shader4();\n\t\t\n\t}else if(momento>59.0&&momento<66.0){\n\t\tcolor=mix(shader4(),shader5(),smoothstep( 59.0, 66.0, momento));\n\t\t\n\t}else if(momento>=66.0&&momento<=81.0){\n\t\tcolor=shader5();\n\t\t\n\t}else if(momento>81.0&&momento<88.0){\n\t\tcolor=mix(shader5(),shader6(),smoothstep( 81.0, 88.0, momento));\n\t}else if(momento>=88.0&&momento<=103.0){\n\t\tcolor=shader6();\n\t\t\n\t}else if(momento>103.0&&momento<120.0){\n\t\tcolor=mix(shader6(),shader1(),smoothstep( 103.0, 120.0, momento));\n\t}\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsySzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1111, 1137, 1137, 1334], [1562, 1734, 1806, 1806, 2292], [2294, 2491, 2576, 2576, 2895], [2896, 2896, 2963, 2963, 3464], [3465, 3465, 3538, 3538, 4030], [4031, 4031, 4052, 4052, 4118], [4119, 4119, 4140, 4140, 4213], [4214, 4214, 4236, 4236, 4435], [4437, 4437, 4457, 4457, 4611], [4612, 4612, 4628, 4628, 5056], [5057, 5057, 5132, 5157, 6603], [6604, 6604, 6638, 6638, 6701], [6702, 6702, 6730, 6730, 8243], [8244, 8279, 8352, 8424, 9349], [9350, 9417, 9493, 9493, 9594], [9595, 9637, 9746, 9746, 10163], [10164, 10193, 10238, 10238, 10510], [10511, 10532, 10545, 10545, 11439], [11440, 11533, 11555, 11555, 11670], [11671, 11671, 11694, 11694, 11808], [11809, 11809, 11832, 11832, 11947], [11948, 11948, 11962, 11962, 13043], [13044, 13044, 13067, 13067, 13182], [13183, 13183, 13197, 13197, 14273], [14274, 14274, 14297, 14297, 14461], [14462, 14462, 14476, 14476, 15552], [15553, 15553, 15568, 15568, 16369], [16370, 18505, 18520, 18520, 18583], [18584, 18584, 18599, 18599, 19659], [19661, 19661, 19676, 19676, 21292], [21293, 21293, 21308, 21308, 21970], [21971, 21971, 22027, 22027, 23003]], "test": "valid"}
{"id": "MsyXDV", "name": "Mandelbrot-Zoom", "author": "SparkX120", "description": "Zooming into the Mandelbrot Set using the escape time algorithm as a fragment shader.\nNote the math breaks down around 20 seconds which is at a zoom factor of 2^20.\nI have some baked in Offsets on the Complex Plane that are zoomed into.", "tags": ["2d", "fractal", "mandelbrot"], "likes": 4, "viewed": 858, "published": "Public API", "date": "1466656206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Adapted from my Mandelbrot-JS Project\n * http://sparkx120.github.io/mandelbrot.html\n * https://github.com/Sparkx120/mandelbrot-js\n * \n * By: James Wake (SparkX120)\n * Copyright (c) 2016 James Wake\n * \n * MIT\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *  \n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float iterations = 512.;\n    const float maxZoom    = 20.;\n    \n    vec2  R      = iResolution.xy;                              // Resolution Variable\n    float scale  = 0.5*exp2(mod(iTime, maxZoom));         // Set Scale to 2^time and Loop at MaxZoom\n    vec2  scalar = vec2(3.5,3.5*R.y/R.x)/scale;                 // Always fit width\n    vec2  aspect = vec2(1.4,2.0);                               // Old Coord Compatibility\n    \n    vec2     offset  = vec2(0);                                 // Hacky solution for multiple coordinates\n    float    modTime = mod(iTime/maxZoom, 3.0);\n    offset = modTime < 1. ? vec2(21.30899,-5.33795) :\n             modTime < 2. ? vec2(5.39307,-41.7374)  :\n                            vec2(48.895,0)          ;\n    \n    vec2 T  = fragCoord-R*offset*scale/100.;                    // Mandelbrot Space Transform\n    vec2 z0 = scalar/R*T - scalar/aspect;                       // Scaling and Aspect Correction\n    vec2 z  = vec2(0);\n    \n    float iteration = iterations;\n    \n    for (float i=0.0; i < iterations; i++) {                    // Escape Time Computation\n        //z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + z0;\n        z = mat2(z,-z.y,z.x)*z + z0;\n        if(dot(z, z) > 4.){ iteration = i; break; }\n    }\n    \n    // Custom Color Shader based on log functions\n    float intensity = iteration == iterations ? 0.0 : iteration/iterations;\n    float redGreen  = intensity*((-1./4.)*log((-1.0/11.112347)*intensity+0.09)-0.25);\n    float blue      = (intensity*(1.-2.4*log(intensity+0.0000000001)));\n\tfragColor       = vec4(redGreen,redGreen, blue, 1);\n}\n\n/* Old Shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float iterations = 512.0;                             // Iterations to compute over\n    const float maxZoom    = 20.0;                              // Max Zoom Time\n    float scale  = 0.5*pow(2.0, mod(iTime, maxZoom));     // Set Scale to 2^time and Loop at MaxZoomTime\n    \n\tfloat width  = iResolution[0];                              // Width Height\n\tfloat height = iResolution[1];                              //\n      \n    float widthScalar  = 3.5/scale;                             // Always fit width\n    float heightScalar = 3.5*height/width/scale;                // scale height\n        \n    float Px = fragCoord.x;                                     // Set Pixel Position\n    float Py = fragCoord.y;                                     //\n    \n    vec2 offset   = vec2(0.0, 0.0);                             // Hacky solution for multiple coordinates\n    float modTime = mod(iTime/maxZoom, 3.0);\n    if(modTime >= 0.0 && modTime < 1.0){\n      offset = vec2(21.30899, -5.33795);                        // Coordinate 1\n    }\n    if(modTime >= 1.0 && modTime < 2.0){\n      offset = vec2(5.39307,-41.7374);                          // Coordinate 2\n    }\n    if(modTime >= 2.0 && modTime < 3.0){\n      offset = vec2(48.895,0.0);                                // Coordinate 3\n    }\n    \n    float xDelta = iResolution.x/100.0*offset.x;                // Mandelbrot space offset\n    float yDelta = iResolution.y/100.0*offset.y;                //\n    \n    float Tx = Px-xDelta*scale;                                 // X-Y Translation\n    float Ty = Py-yDelta*scale;\n    float x0 = widthScalar/width*Tx - widthScalar/1.4;          // Scaling and Aspect Correction\n    float y0 = heightScalar/height*Ty - heightScalar/2.0;       //\n    float x  = 0.0;\n\tfloat y  = 0.0;\n    \n    float iteration = iterations;\n    int end = 0;\n    \n    for (float i=0.0; i < iterations; i++) {                    // Escape Time Computation\n        float xtemp = x*x-y*y+x0;\n        y = 2.0*x*y+y0;\n        x = xtemp;\n        if(x*x+y*y > 4.0){\n            iteration = i;\n            break;\n        }\n    }\n    \n    float intensity = iteration == iterations ? 0.0 : iteration/iterations;\n    \n    // Custom Color Shader based on log functions\n    float redGreen = intensity*((-1.0/4.0)*log((-1.0/11.112347)*intensity+0.09)-0.25);\n    float blue = (intensity*(1.0-2.4*log(intensity+0.0000000001)));\n    \n\tfragColor = vec4(redGreen,redGreen, blue, 1.0);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyXDV.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1289, 1346, 1346, 2956]], "test": "valid"}
{"id": "MsyXDw", "name": "Gear Designs 2", "author": "Yusef28", "description": "Style practice. based on http://patriciogonzalezvivo.com/2015/thebookofshaders/07/ ", "tags": ["2d", "gears", "smoothstep", "variation"], "likes": 36, "viewed": 1889, "published": "Public", "date": "1464734529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 gear1(vec2 p){\n\n        float a = atan(p.y, p.x)+ iTime;\n        float l = length(p)*1.0;\n        \n        float g = smoothstep(-.5, 1.0, cos(a*10.0))*0.13+0.5;\n            \n            float gear = 1.0-smoothstep(g,g+0.03, l);   //takes waveform as bounds\n            float midgear = 1.0-smoothstep(g-0.02,g+0.03, l*1.1);\n            float biggear = 1.0-smoothstep(g,g+0.03, l*1.05);\n            float xshole = 1.0-smoothstep(g,g+0.03, l*2.0);//or3\n                \n            float outline = 1.0-smoothstep(g-0.2, g-0.1, l) - smoothstep(g-0.1, 0.4,  l); \n            float outline2 = 1.0-smoothstep(g-0.2, g-0.1, l) - smoothstep(g-0.1, 0.4,  l); \n\n    float h = smoothstep(-2.5,1.1, cos(a*10.0+3.1))*.25+0.02;\n    \tfloat spokes = 1.0-smoothstep(h-0.09,h+0.03, l);\n    \n    \n    \n    vec3 fullgear = vec3(gear-biggear+midgear-xshole+spokes)*vec3(1.0,1.0,1.0);\n    vec3 mainplates = vec3(midgear-xshole)*vec3(1.0,1.0,1.0);\n    vec3 rims = vec3(gear-biggear)*vec3(0.3,0.0,1.0) ;\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes;  \n    vec3 outcolor =  mainplates + rims + spokes3;\n    \n    return outcolor;\n \n    }\n\nvec3 gear2(vec2 p, vec3 s, float spikenum, float thickness){\n\n        float a = atan(p.y, p.x)+ iTime;\n        float l = length(p)*2.0;\n        float g = smoothstep(-.95, -.5, cos(a*spikenum))*0.06+0.5;\n            \n            float gear = 1.0-smoothstep(g,g+0.03, l);   //takes waveform as bounds\n            float midgear = 1.0-smoothstep(g-0.02,g+0.03, l*1.1);\n            float biggear = 1.0-smoothstep(g,g+0.0003, l);\n            float xshole = 1.0-smoothstep(g,g+0.03, l*thickness);//or3\n                \n          \n    \n    vec3 mainplates = vec3(midgear-xshole)*vec3(1.0,1.0,1.0);\n    vec3 rims = vec3(gear-biggear)*vec3(0.3,0.0,1.0) ;\n    vec3 spokes3 = s;// vec3(.0,0.2,0.9)*spokes;  \n    vec3 outcolor =  mainplates  + spokes3;\n    \n    return outcolor;\n \n    }\n\nvec3 spokes1(vec2 p, float spokenum){\n    float a = atan(p.y, p.x)+ iTime;\n    float l = length(p)*2.0;\n    \n    float h = (abs(fract(a*spokenum+l*4.)*2.-1.)-0.240)*0.456+0.1828;\n    float spokes = 1.0-smoothstep(h-0.09,h+0.03, l);\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes; \n    \n    return spokes3; \n}\nvec3 spokes2(vec2 p, float spokenum){\n    float a = atan(p.y, p.x)+ iTime;\n    float l = length(p)*2.0;\n    \n    float h =  pow(abs(fract(a*spokenum)*2.-0.848),-0.136)/5.992;\n    float spokes = 1.0-smoothstep(h-0.09,h+0.03, l);\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes; \n    \n    return spokes3; \n}\nvec3 spokes3(vec2 p, float spokenum){\n    float a = atan(p.y, p.x)+ iTime;\n    float l = length(p)*2.0;\n    \n    float h = pow(abs(fract(a*spokenum)*2.000-1.000)+0.236,3.976)/6.976+.128;\n    float spokes = 1.0-smoothstep(h-0.09,h+0.03, l);\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes; \n    \n    return spokes3; \n}\n/*\nvec3 makespokes(float h){\n    float a = atan(p.y, p.x)+ iTime;\n    float l = length(p)*1.0;\n\tfloat spokes = 1.0-smoothstep(h-0.09,h+0.03, l);\n    vec3 spokes3 = vec3(.0,0.2,0.9)*spokes;\n    return 1.;\n    \n}*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    vec2 pos = uv;\n    \n    vec3 white = vec3(1.0,1.0,1.0);\n    vec3 grey = vec3(0.5,0.5,0.5);\n    vec3 lightgrey = vec3(0.8,0.8,0.8);\n    vec3 darkgrey = vec3(0.2,0.2,0.2);\n    \n    vec3 color = darkgrey;\n    \n    //float g = gear(pos);\n    //color = vec3(g);\n\n    \n    //float  i = floor((uv.x*uv.x+uv.y*uv.y)*3.14*20.);\n     //color += gear(vec2(pos.x+cos(i),pos.y+sin(i)));\n    \n    //1.752 for 1\n    //2.208 for2\n    //1.752 for 3\n    color+=gear2(vec2(pos.x + 1.2, pos.y+ 0.6), spokes1(vec2(pos.x + 1.2, pos.y+ 0.6),2.10/4.0), 10.0, 1.8);\n    color+=gear2(vec2(pos.x + 0.0, pos.y+ 0.6), spokes2(vec2(pos.x + 0.0, pos.y+ 0.6),2.208), 20.0, 1.0);\n    color+=gear2(vec2(pos.x - 1.2, pos.y+ 0.6), spokes3(vec2(pos.x - 1.2, pos.y+ 0.6),0.632), 40.0, 1.3);\n    color+=gear2(vec2(pos.x + 1.2, pos.y+ 0.0), spokes1(vec2(pos.x + 1.2, pos.y+ 0.0),2.208*2.0), 20.0, 1.4);\n    color+=gear2(vec2(pos.x + 0.0, pos.y+ 0.0), spokes2(vec2(pos.x + 0.0, pos.y+ 0.0),2.208), 5.0, 2.4);\n    color+=gear2(vec2(pos.x - 1.2, pos.y+ 0.0), spokes3(vec2(pos.x - 1.2, pos.y+ 0.0),0.632), 25.0, 1.9);\n    color+=gear2(vec2(pos.x + 1.2, pos.y- 0.6), spokes1(vec2(pos.x + 1.2, pos.y- 0.6),2.208), 35.0, 1.1);\n    color+=gear2(vec2(pos.x + 0.0, pos.y- 0.6), spokes2(vec2(pos.x + 0.0, pos.y- 0.6),2.208), 15.0, 1.7);\n    color+=gear2(vec2(pos.x - 1.2, pos.y- 0.6), spokes3(vec2(pos.x - 1.2, pos.y- 0.6),0.632), 3.0, 1.4);\n   \n    \n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 1113], [1115, 1115, 1175, 1175, 1888], [1890, 1890, 1927, 1927, 2194], [2195, 2195, 2232, 2232, 2495], [2496, 2496, 2533, 2533, 2808], [2809, 3024, 3081, 3081, 4637]], "test": "valid"}
{"id": "XdGSWd", "name": "2D Graphics", "author": "dche", "description": "2D signed distance field functions and simple API for drawing 2D graphics. ", "tags": ["2d"], "likes": 4, "viewed": 549, "published": "Public API", "date": "1467278125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SQRT_2      1.4142135623730951\n#define RECIP_3  \t0.3333333333333333\n\t\nvec2 rotate(vec2 p, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    mat2 rm = mat2(c, s, -s, c);\n    return rm * p;\n}\n\n// Anti-alias step function\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2( dFdx(value), dFdy(value)));\n    return smoothstep(threshold - afwidth, threshold + afwidth, value);\n}\n\n// union\nfloat opU(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// intersection\nfloat opI(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// substrction\nfloat opS(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n// repeatition\nvec2 opRep(vec2 p, vec2 c) {\n    return mod(p, c) - c * 0.5;\n}\n\n// circle: (center.x, center.y, radius)\nfloat sdCircle(vec2 p, vec3 circle) {\n    return length(p - circle.xy) - circle.z;\n}\n\n// ellipse: (center.x, center.y, a, b)\nfloat sdEllipse(vec2 p2d, vec4 ellipse) {\n    vec2 z = p2d - ellipse.xy;\n    vec2 ab = ellipse.zw;\n\n    // Created by inigo quilez - iq/2013\n    // License Creative Commons\n    // Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    vec2 p = abs( z ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\nfloat sdHalfPlane(vec2 p, vec2 plane) {\n    return dot(p, normalize(plane));\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 np = p - a;\n    vec2 ns = b - a;\n    float proj = dot(np, ns) / length(ns);\n    float d = sdHalfPlane(np, vec2(ns.y, -ns.x));\n    float s = sign(d);\n    if (proj < 0.) return s * length(np);\n    if (proj > length(ns)) return s * length(np - ns);\n    else return d;\n}\n\nfloat dSegment(vec2 p, vec2 a, vec2 b) {\n    return abs(sdSegment(p, a, b));\n}\n\nfloat opISeg(float d0, float d1) {\n    if (d0 * d1 > 0.) return min(d0, d1);\n    return max(d0, d1);\n}\n\nfloat sdTriangle(in vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    float d0 = sdSegment(p, p0, p1);\n    float d1 = sdSegment(p, p1, p2);\n    float d2 = sdSegment(p, p2, p0);\n    return opISeg(d0, opISeg(d1, d2));\n}\n\n// star: (center.x, center.y, radius)\nfloat sdStar(vec2 p, vec3 star) {\n    vec2 np = p - star.xy;\n\n    float d = sdTriangle(np, vec2(0., star.z), vec2(-RECIP_3, 0.) * star.z, vec2(vec2(RECIP_3, 0.) * star.z));\n    for (int i = 1; i < 5; i++) {\n        np = rotate(np, radians(72.));\n        d = opU(d, sdTriangle(np, vec2(0., star.z), vec2(-RECIP_3, 0.) * star.z, vec2(vec2(RECIP_3, 0.) * star.z)));\n    }\n    return d;\n}\n\n// box: (center.x, center.y, half width, half height)\nfloat sdBox(vec2 p, vec4 box) {\n    vec2 np = p - box.xy;\n    vec2 d = abs(np) - box.zw;\n    float de = length(max(d, 0.));\n    float di = max(d.x, d.y);\n    float f = step(0., di);\n    return di * (1. - f) + de * f;\n}\n\n// box: (center.x, center.y, half width, half height)\n// r: corner radius.\nfloat sdRoundedCornerBox(vec2 p, vec4 box, float r) {\n    return sdBox(p, vec4(box.xy, box.zw - r)) - r;\n}\n\n// diamond: (center.x, center.y, helf width, helf height)\nfloat sdDiamond(vec2 p, vec4 diamond) {\n    // rotation 45Âº.\n    vec2 np = vec2(p.x, p.y * diamond.z / diamond.w) - diamond.xy;\n    float x = SQRT_2 * 0.5 * (np.x - np.y);\n    float y = SQRT_2 * 0.5 * (np.x + np.y);\n    vec2 s = vec2(diamond.z) / SQRT_2;\n    return sdBox(vec2(x, y), vec4(vec2(0.), s));\n}\n\n// heart: (center.x, center.y, half size)\nfloat sdHeart(vec2 p, vec3 heart) {\n    vec2 c = vec2(heart.z) * 0.5;\n    float r = heart.z * 0.5 * SQRT_2;\n    float dd = sdDiamond(vec2(p.x, p.y + r * 0.62), vec4(heart, heart.z));\n    vec2 np = p - heart.xy;\n    float dc = sdCircle(vec2(abs(np.x), np.y + r * 0.62), vec3(c, r));\n    return opU(dd, dc);\n}\n\nvec4 fill(float shape, vec4 color) {\n    return vec4(color.rgb, color.a * (1. - smoothstep(0., 1.5, shape)));\n}\n\nvec4 stroke(float shape, vec4 color, float width) {\n    float w = 1. - aastep(width * 0.5, abs(shape));\n    float a = min(w, 1.);\n    return vec4(color.rgb, color.a * a);\n}\n\nvec3 blend(vec4 fg, vec3 bg) {\n    return mix(bg, fg.rgb, fg.a);\n}\n\n// examples.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy - iResolution.xy * 0.5;\n    vec3 col = vec3(0.1, 0.3, 0.5);\n\n    float d = 0.;\n    \n    // star\n    d = sdStar(p, vec3(150., 30., 100.));\n    col = blend(fill(d, vec4(1., 0.9, 0., 1.)), col);\n\n    // hearts\n    d = sdHeart(opRep(p, vec2(60., 60.)), vec3(0., 0., 12. + 6. * abs(cos(iTime * 4.))));\n    col = blend(fill(d, vec4(0., 0.5, 0., 1.)), col);\n    col = blend(stroke(d, vec4(1., 0.4, 0.6, 1.), 2.), col);\n\n    // transparent box\n    d = sdBox(p, vec4(-120., 10., 40., 60.));\n    col = blend(fill(d, vec4(0.5, 0., 0., 0.7)), col);\n    col = blend(stroke(d, vec4(1.), 5.), col);\n\n    // composition\n    d = sdDiamond(p, vec4(0., 0., 20., 30.)) - 2.;\n    d = opS(d, sdHeart(p, vec3(0., 0., 10.)));\n    col = blend(fill(d, vec4(0., 0.7, 0.8, 1.)), col);\n    col = blend(stroke(d, vec4(1., 0.4, 0.6, 1.), 2.), col);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGSWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 113, 113, 219], [221, 249, 293, 293, 434], [436, 445, 476, 476, 502], [504, 520, 551, 551, 577], [579, 594, 625, 625, 652], [654, 669, 697, 697, 731], [733, 773, 810, 810, 857], [859, 898, 939, 939, 2267], [2269, 2269, 2308, 2308, 2347], [2349, 2349, 2390, 2390, 2666], [2668, 2668, 2708, 2708, 2746], [2748, 2748, 2782, 2782, 2850], [2852, 2852, 2908, 2908, 3060], [3062, 3100, 3133, 3133, 3484], [3486, 3540, 3571, 3571, 3758], [3760, 3835, 3888, 3888, 3941], [3943, 4001, 4040, 4064, 4309], [4311, 4353, 4388, 4388, 4660], [4662, 4662, 4698, 4698, 4773], [4775, 4775, 4826, 4826, 4947], [4949, 4949, 4979, 4979, 5015], [5017, 5030, 5087, 5087, 5965]], "test": "valid"}
{"id": "XdGXD3", "name": "Cave Quest", "author": "bergi", "description": "Lot's of finetuning to get a nice cave fly-through. \nGreetings to Kali and Shane :)", "tags": ["procedural", "3d", "fractal", "raymarch", "texture", "kali", "stone", "dirt", "bumpmap"], "likes": 28, "viewed": 1233, "published": "Public API", "date": "1466882671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** Cave Quest \n\thttps://www.shadertoy.com/view/XdGXD3\n\n\t(cc) 2016, stefan berke\n\n\tBased on \"Kali Trace\" https://www.shadertoy.com/view/4sKXWG\n\n\tInteresting things here might be:\n\t- the distance formula in itself\n\t- wrapping 3d-space using sin() for endless kali-set patterns\n\t- kali-set used for normals, micro-normals and texturing\n\t- epsilon in normal estimation for artistic tuning\n\n*/\n\n\n// minimum distance to axis-aligned planes in kali-space\n// uses eiffie's mod (/p.w) https://www.shadertoy.com/view/XtlGRj\n// to keep the result close to a true distance function\nvec3 kali_set(in vec3 pos, in vec3 param)\n{\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        d = min(d, p.xyz/p.w);\n        p.xyz = p.zxy - param;\n    }\n    return d;\n}\n\n// average of all iterations in kali-set\nvec3 kali_set_av(in vec3 p, in vec3 param)\n{\n    vec3 d = vec3(0.);\n    for (int i=0; i<13; ++i)\n    {\n        p = abs(p) / dot(p,p);\n        d += exp(-p*8.);\n        p.xyz = p.zxy - param;\n    }\n    return d / 8.;\n}\n\n// endless texture  \nvec3 kali_tex(in vec3 p, in vec3 par)\n{\n    vec3 k = kali_set_av(sin(p*3.)*.3, par);\n    return 3.*k;\n}\n\n// endless texture normal\nvec3 kali_tex_norm(in vec3 p, in vec3 param, vec3 mask, float eps)\n{\n    vec2 e = vec2(eps, 0.);\n    return normalize(vec3(\n        dot(kali_tex(p+e.xyy, param),mask) - dot(kali_tex(p-e.xyy, param),mask),\n        dot(kali_tex(p+e.yxy, param),mask) - dot(kali_tex(p-e.yxy, param),mask),\n        dot(kali_tex(p+e.yyx, param),mask) - dot(kali_tex(p-e.yyx, param),mask)));\n}\n\n\n\n// camera path\nvec3 path(in float z)\n{\n    float t = z;\n    vec3 p = vec3(sin(t)*.5, \n                  .26*sin(t*3.16), \n                  z);\n    return p;\n}\n\n\nfloat DE(in vec3 p, in vec3 param)\n{\n    // tube around path\n    float r = .13+.1*sin(p.z*.89);\n    vec3 pp = p - path(p.z); float d = r-max(abs(pp.x), abs(pp.y));\n    \n    // displacement\n    vec3 k = kali_set(sin(p), param);\n    d += k.x+k.y+k.z;\n    //d += max(k.x,max(k.y,k.z));\n    //d += min(k.x,min(k.y,k.z));\n    return d;\n}\n\nvec3 DE_norm(in vec3 p, in vec3 param, in float eps)\n{\n    vec2 e = vec2(eps, 0.);\n    return normalize(vec3(\n        DE(p+e.xyy, param) - DE(p-e.xyy, param),\n        DE(p+e.yxy, param) - DE(p-e.yxy, param),\n        DE(p+e.yyx, param) - DE(p-e.yyx, param)));\n}\n\n\n// lighting/shading currently depends on this beeing 1.\nconst float max_t = 1.;\n\n// common sphere tracing\n// note the check against abs(d) to get closer to surface\n// in case of overstepping\nfloat trace(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float t = 0.001, d = max_t;\n    for (int i=0; i<50; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE(p, param);\n        if (abs(d) <= 0.00001 || t >= max_t)\n            break;\n        t += d * .5; // above kali-distance still needs a lot of fudging\n    }\n    return t;\n}\n\n// \"Enhanced Sphere Tracing\"\n// Benjamin Keinert(1) Henry SchÃ¤fer(1) Johann KorndÃ¶rfer Urs Ganse(2) Marc Stamminger(1)\n// 1 University of Erlangen-Nuremberg, 2 University of Helsinki\n// \n// It was a try... disabled by default (see rayColor() below)\n// Just here for experimentation\n// Obviously the algorithm does not like \"fudging\" which is needed for my distance field..\n// It renders more stuff close to edges but creates a lot of artifacts elsewhere\nfloat trace_enhanced(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float omega = 1.2; // overstepping\n    float t = 0.001;\n    float candidate_error = 100000.;\n    float candidate_t = t;\n    float previousRadius = 0.;\n    float stepLength = .0;\n    float signedRadius;\n    float pixelRadius = .012;\n    float fudge = 0.6;\n    for (int i = 0; i < 50; ++i) \n    {\n        signedRadius = DE(rd*t + ro, param);\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. && (radius + previousRadius) < stepLength;\n        if (sorFail) \n        {\n        \tstepLength -= omega * stepLength;\n        \tomega = 1.;\n        } \n        else \n        {\n        \tstepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) \n        {\n        \tcandidate_t = t;\n        \tcandidate_error = error;\n    \t}\n    \tif (!sorFail && error < pixelRadius || t > max_t)\n    \t\tbreak;\n    \tt += stepLength * fudge;\n    }\n    return (t > max_t || candidate_error > pixelRadius)\n        ? max_t : candidate_t;\n}\n\n// common ambient occlusion\nfloat traceAO(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float a = 0., t = 0.01;\n    for (int i=0; i<5; ++i)\n    {\n        float d = DE(ro+t*rd, param);\n       \ta += d / t;\n        t += abs(d);\n    }\n    return clamp(a / 8., 0., 1.);\n}\n\n// environment map, also drawn from kaliset\nvec3 skyColor(in vec3 rd)\n{\n    //vec3 par = vec3(0.075, 0.565, .03);\n    vec3 par = vec3(.9, .81, .71);\n    \n    vec3 c = kali_set(sin(rd*6.), par);\n    c = pow(min(vec3(1.), c*2.+vec3(1.,.86,.6)), 1.+114.*c);\n    \n    return clamp(c, 0., 1.);\n}\n\n\n// trace and color\nvec3 rayColor(in vec3 ro, in vec3 rd)\n{\n    // magic params for kali-set\n    vec3 par1 = vec3(.9, .6+.5*sin(ro.z/50.), 1.),\t// scene geometry \n         par2 = vec3(.63, .55, .73),\t\t\t\t// normal/bump map\n         par3 = vec3(1.02, 0.82, 0.77); \t\t\t// normal/texture\n    \n#if 1\n    float t = trace(ro, rd, par1);\n#else    \n    float t = trace_enhanced(ro, rd, par1);\n#endif    \n    vec3 p = ro + t * rd;\n    float d = DE(p, par1);\n    \n    vec3 col = vec3(0.);\n\n    // did ray hit?\n    if (d < 0.03) \n    {\n        float scr_eps = max(0.001, (t-0.1)*0.025);\n        // \"some\" texture values\n        vec3 kt = kali_tex(p, par3);\n        // surface normal\n        vec3 n = DE_norm(p, par1, 0.5*scr_eps), nn = n;\n        // normal displacement\n        n = normalize(n + 0.3*kali_tex_norm(p, par3+0.1*n, vec3(1), scr_eps));\n        n = normalize(n + 0.3*DE_norm(sin(n*3.+kt), par2, 2.*scr_eps)); // micro-bumps\n        // reflected ray\n        vec3 rrd = reflect(rd,n);\n\t\t// normal towards light\n        vec3 ln = normalize(path(p.z+.1) - p);\n\t\t// 1. - occlusion\n        float ao = pow(traceAO(p, n, par1), 1.+3.*t);\n        // surface color\n        vec3 col1 = .45 * (vec3(.7,1.,.4) + kali_tex(p, par3));\n        vec3 col2 = vec3(1.,.8,.6) + .3 * vec3(1.,.7,-.6) * kali_tex(p, par3);\n        vec3 k = kali_set_av(sin(p*(1.+3.*ao))*.3, par3);\n        vec3 surf = (.1 + .9 * ao) \n            \t\t//* vec3(1.);\n            \t\t* mix(col1, col2, min(1., pow(ao*2.2-.8*kt.x,5.)));\n\t\t// desaturate\n        surf += .24 * (dot(surf,vec3(.3,.6,.1)) - surf);\n\n        // -- lighting --\n        \n        float fres = pow(max(0., 1.-dot(rrd, n)), 1.) / (1.+2.*t);\n\n        // phong\n        surf += .25 * ao * max(0., dot(n, ln));\n        // spec\n        float d = max(0., dot(rrd, ln));\n        surf += .4 * pow(ao*1.2,5.) * (.5 * d + .7 * pow(d, 8.));\n\n        // fresnel highlight\n        surf += clamp((t-.06)*8., 0.,1.6) * \n            \t(.2+.8*ao) * vec3(.7,.8,1.) * fres;\n        \n        // environment map\n        surf += .2 * (1.-fres) * ao * skyColor(rrd);\n    \n        // distance fog\n    \tcol = surf * pow(1.-t / max_t, 1.3);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n        \n    float ti = (iTime-14.)/8.;\n    \n    vec3 ro = path(ti);\n    vec3 look = path(ti+.5);\n    float turn = (ro.x-look.x)*1.; \n        \n    // lazily copied from Shane\n    // (except the hacky turn param)\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(look-ro);\n    vec3 rgt = normalize(vec3(fwd.z, turn, -fwd.x));\n    vec3 up = cross(fwd, rgt);\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    \n    vec3 col = rayColor(ro, rd);\n    //col = skyColor(rd);\n    \n    col *= pow(1.-dot(suv-.5,suv-.5)/.5, .6);\n    \n\tfragColor = vec4(pow(col,vec3(.8)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 571, 614, 614, 824], [826, 867, 911, 911, 1083], [1085, 1106, 1145, 1145, 1209], [1211, 1237, 1305, 1305, 1607], [1611, 1626, 1649, 1649, 1770], [1773, 1773, 1809, 1833, 2105], [2107, 2107, 2161, 2161, 2367], [2451, 2561, 2613, 2613, 2895], [2897, 3357, 3418, 3418, 4453], [4455, 4483, 4537, 4537, 4720], [4722, 4766, 4793, 4835, 5012], [5015, 5034, 5073, 5106, 7176], [7179, 7179, 7236, 7236, 7953]], "test": "valid"}
{"id": "XdGXRV", "name": "Gold Fractal", "author": "zackpudil", "description": "My first rendering of a fractal.  Basically it's a bastardized version of Kali's Generators (https://www.shadertoy.com/view/Xtf3Rn).", "tags": ["raymarching", "fractal"], "likes": 7, "viewed": 300, "published": "Public", "date": "1465258834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float tmax = 20.0;\n\nfloat map(vec3 p) {\n\tp.xz = mod(p.xz + 1.0, 2.0) - 1.0;\n\tvec4 q = vec4(p, 1);\n\tfor(int i = 0; i < 15; i++) {\n\t\tq.xyz = abs(q.xyz) - vec3(-0.02, 1.07, -0.02);\n\t\tq = 2.0*q/clamp(dot(q.xyz, q.xyz), 0.4, 1.0) - vec4(1.0, 0.0, 0.6, 0.0);\n\t}\n\n\treturn length(q.xyz)/q.w;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat d = 1.0, e = 0.0, t = 0.0;\n\n\tfor(int i = 0; i < 70; i++) {\n\t\tif(d < e || t >= tmax) break;\n\t\td = map(ro + rd*t);\n\t\te = 0.0001*(1.0 + t*0.8);\n\t\tt += d;\n\t}\n\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float o = 0.0, s = 0.004;\n    \n    for(int i = 0; i < 15; i++) {\n        float d = map(p + n*s);\n        o += s - d;\n        s += s/(float(i) + 1.0);\n    }\n    \n    return 1.0 - clamp(o, 0.0, 1.0);\n}\n\nmat3 camera(vec3 eye, vec3 lat) {\n\tvec3 ww = normalize(lat - eye);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\n\treturn mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tvec3 col = vec3(0.0);\n\n\tvec3 ro = vec3(-(iTime + 1.0)*0.05, sin((iTime + 1.0)*0.05), -0.6);\n\tvec3 rd = normalize(camera(ro, ro + vec3(0, 0, 1))*vec3(uv, 1.97));\n\n\tfloat i = march(ro, rd);\n\tif(i < tmax) {\n\t\tvec3 pos = ro + rd*i;\n\t\tvec3 nor = normal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\tvec3 lig = normalize(vec3(0.8, 0.7, -0.6));\n\n        col = clamp(dot(lig, nor), 0.0, 1.0)*vec3(1.00, 0.97, 0.40);\n\t\tcol += 0.25*pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0)*vec3(1.00, 0.97, 0.40)/(0.5*i);\n        \n        col *= ao(pos, nor);\n\t}\n\n\tcol = mix(col, vec3(1.0), 1.0 - exp(-0.8*i));\n\tcol = pow(col, vec3(.454545));\n\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 45, 45, 291], [293, 293, 324, 324, 499], [501, 501, 522, 522, 698], [700, 700, 726, 726, 930], [932, 932, 965, 965, 1112], [1114, 1114, 1171, 1171, 1908]], "test": "valid"}
{"id": "XdKSDV", "name": "Type 2 Supernova VR", "author": "Duke", "description": "VR ready version of [url=https://www.shadertoy.com/view/lsyXDK]Type 2 Supernova[/url] shader.\nPress 1-2-3 to zoom in and zoom out.", "tags": ["supernova"], "likes": 12, "viewed": 1587, "published": "Public API", "date": "1466701611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Type 2 Supernova\" by Duke\n// https://www.shadertoy.com/view/lsyXDK\n//-------------------------------------------------------------------------------------\n// Based on \"Supernova remnant\" (https://www.shadertoy.com/view/MdKXzc)\n// \"Volumetric explosion\" (https://www.shadertoy.com/view/lsySzd)\n// and other previous shaders \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define DITHERING\n//#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat Sphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 4.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 1.-mod(iTime * 0.1,-1.); //-mod(iTime * 0.1,-2.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricExplosion(vec3 p)\n{\n    float final = Sphere(p,4.);\n    final += noise(p*20.)*.4;\n    final += SpiralNoiseC(p.zxy*fbm(p*10.))*2.5; //1.25;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\n\tfloat VolExplosion = VolumetricExplosion(p/(1.+mod(iTime * 0.1,-1.)))*(1.+mod(iTime * 0.1,-1.)); // scale\n    \n\treturn abs(VolExplosion)+0.07;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn pow(_color, vec3(2.2));\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n    \n    ro.z += 6.0 - key*1.6;\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n    for (int i=0; i<86; i++)\n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.11*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        \n        sum.rgb+=(vec3(0.67,0.75,1.00)/(lDist*lDist*15.)/100.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2 / lDist;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        // idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uvd = uv;\n        uvd.y*=120.;\n        uvd.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uvd.y,-uvd.x+0.5*sin(4.*iTime+uvd.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),0.1), 0.01);\n\n\t}\n    \n    // simple scattering  \n    #ifdef TONEMAPPING\n    sum *= 1. / exp( ld * 0.2 ) * 0.5;\n\t#else\n    sum *= 1. / exp( ld * 0.2 ) * 0.8;\n\t#endif        \n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n    \n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, -1.));\n\t//vec3 ro = vec3(0., 0., -6.+key*1.6);\n    vec3 ro = vec3(0.0);\n    \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(render( ro, rd, uv ).rgb*3.2),1.0);\n\t#else\n    fragColor = vec4(render( ro, rd, uv ).rgb,1.0);\n\t#endif\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    //fragColor = render( fragRayOri, fragRayDir, uv );\n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(render( fragRayOri, fragRayDir, uv ).rgb*3.2),1.0);\n\t#else\n    fragColor = render( fragRayOri, fragRayDir, uv );\n\t#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKSDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[924, 938, 964, 964, 1183], [1185, 1185, 1206, 1206, 1295], [1297, 1297, 1330, 1330, 1356], [1358, 2018, 2046, 2046, 2640], [2642, 2642, 2677, 2677, 2817], [2819, 2819, 2839, 2839, 3025], [3092, 3121, 3171, 3256, 3526], [3528, 3528, 3604, 3604, 3820], [3822, 3937, 3973, 3973, 4153], [4155, 4155, 4206, 4206, 7091], [7093, 7093, 7150, 7150, 7563], [7565, 7565, 7659, 7659, 7943]], "test": "error"}
{"id": "XdKSWV", "name": "QLOC-logo", "author": "Sieciech", "description": "Logo design", "tags": ["qloc"], "likes": 1, "viewed": 136, "published": "Public", "date": "1466685648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Quake Logo\n// by Krzysztof Narkowicz @knarkowicz\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n    float distanceFromCenter = max( abs(p.x), abs(p.z) );\n\tfloat d = (distanceFromCenter - r);\n\td = max( d, abs( p.y ) - height );\n    \n\treturn d;\n}\nfloat Cylinder2( vec3 p, float r, float height ) \n{\n    float distanceFromCenter = max( abs(p.x), abs(p.z) );\n\tfloat d = (distanceFromCenter - r);\n\td = max( d, abs( p.y ) - height );\n    \n\treturn d;\n}\n\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, vec3 h )\n{        \n    vec3 q = abs( p );\n    \n    float res = max( q.y - h.y, max( q.z + p.x * h.z, -p.x ) - h.x * 0.5 );\n    return res;\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    // ring\n    float a = Cylinder( p, 0.9, 0.2 );\n    float b = Cylinder( p , 0.45, 0.21 ); \n    float ring = Substract( a, b );\n    \n    // nail\n    float c = Box( p + vec3( -1.1, 0.0, 0.0 ), vec3( 0.2, 0.2, 0.21 ) );\n    //float d = Box( p + vec3( -0.4, 0.0, 0.0 ), vec3( 0.02, 0.1, 0.25 ) );\n    //float e = \n    float nail = c;\n    \n    // dents\n    //float f = TriPrism( p + vec3( +0.20, -0.0, -0.85 ), vec3( 0.3, 0.4, 0.1 ) );\n//    float g = TriPrism( p + vec3( -0.45, 0.0, -0.4 ), vec3( 0.1, 0.2, 0.16 ) );\n//    float h = TriPrism( p + vec3( -0.8, 0.0, -0.65 ), vec3( 0.08, 0.2, 0.16 ) );\n//    float i = TriPrism( p + vec3( -0.9, 0.0, 0.3 ), vec3( 0.04, 0.2, 0.16 ) );\n//    float j = TriPrism( p + vec3( +0.3, 0.0, 0.68 ), vec3( 0.28, 0.2, 0.16 ) );\n//    float k = TriPrism( p + vec3( -0.45, 0.0, -0.94 ), vec3( 0.07, 0.2, 0.5 ) );\n//    float l = TriPrism( p + vec3( 0.0, 0.0, 1.06 ), vec3( 0.1, 0.2, 0.5 ) );\n\n    vec3 q = vec3(p.z, p.y, p.x);\n    float cyl = TriPrism( q + vec3( 0.0, 0.0, -0.45 ), vec3( 0.43, 0.2, 1 ) );\n    //oat cyl = Cylinder2( p - vec3(0.5, 0.0, 0.0), 0.2, 0.2);\n    \n  ring = SubstractRound( ring, cyl, 0.03 );\n    \n  //  float ret = Union(Union( ring, nail ), cyl);\n  float ret = Union( ring, nail);\n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 rayOrigin \t= vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = 0.75 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.0 * iTime + -0.5 * MATH_PI;    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    float phi2 = 1.0 * iTime;    \n    mat3 rotZ = mat3(\n        vec3( 0.0, 1.0, 0.0 ),\n        vec3( cos( phi2 ), 0.0, sin( phi2 ) ),\n        vec3( -sin( phi2 ), 0.0, cos( phi2 ) )\n        );\n    \n    \n    mat3 localToWorld = rotZ * rotX * rotY;    \n\n\n\tvec3 color = vec3(1.0, 1.0, 1.0);\n    \n\tfloat t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n        \n        vec3 textureX = vec3(116.0/255.0, 179.0/255.0, 31.0/255.0);\n        vec3 textureY = vec3(116.0/255.0, 179.0/255.0, 31.0/255.0);\n        vec3 textureZ = vec3(116.0/255.0, 179.0/255.0, 31.0/255.0);\n        \n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n\t\tweights /= weights.x + weights.y + weights.z;\n        \n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n        \n        float rustMask = clamp( texture.x * 3.0 - 0.5, 0.0, 1.0 );\n                \n        //vec3 diffuseColor = mix( vec3( 0.0 ), texture, rustMask );\n        vec3 diffuseColor = mix( vec3( 0.0 ), texture, rustMask );\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor = mix( texture, vec3( 0.04 ), rustMask );\n        float roughness = mix( 0.2, 0.6, rustMask );\n     \n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 167, 167, 381], [383, 383, 439, 439, 560], [562, 562, 615, 615, 765], [767, 767, 885, 885, 1432], [1434, 1434, 1484, 1484, 1633], [1634, 1634, 1685, 1685, 1834], [1837, 1837, 1870, 1870, 1897], [1899, 1899, 1928, 1928, 2029], [2031, 2031, 2068, 2068, 2095], [2097, 2097, 2149, 2149, 2255], [2257, 2257, 2290, 2290, 2316], [2318, 2318, 2365, 2365, 2476], [2478, 2478, 2512, 2512, 2642], [2644, 2644, 2686, 2686, 3972], [3974, 3974, 4034, 4034, 4369], [4371, 4371, 4423, 4423, 4755], [4757, 4757, 4814, 4814, 7362]], "test": "valid"}
{"id": "XdKXDc", "name": "fluid jazz", "author": "RavenWorks", "description": "Sketch on the 'jazz' solo cup design, in the style of an Earthbound battle background. :P", "tags": ["earthbound", "solo", "jazz", "cup"], "likes": 9, "viewed": 986, "published": "Public API", "date": "1467171120", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nfloat noiseSource(vec2 uv, float t){\n    \n    float waveA = sin(\n        uv.x*150.0 +\n        sin(uv.x*15.1)*(1.5+sin(uv.y*1.1)*0.3) +\n        t*(1.0+sin(t*0.25)*0.005) +\n        sin(uv.y*100.0 + sin(uv.x*110.0) + t*5.0) +\n        sin(uv.y*8.0 + t*0.2)*15.0 +\n        sin(uv.y* (150.0+sin(uv.y*20.0)*4.0+sin(uv.x*10.0)*3.5) + t*1.0)\n    );\n    \n    float waveB = sin(\n        uv.y*140.0 +\n        sin(uv.y*15.1)*(1.5+sin(uv.x*1.1)*0.3) +\n        t*(1.1+sin(t*0.2)*0.004) +\n        sin(uv.x*110.0 + sin(uv.y*120.0) + t*4.0) +\n        sin(uv.x*9.0 + t*0.1)*14.0 +\n        sin(uv.x* (160.0+sin(uv.x*25.0)*5.0+sin(uv.y*12.0)*2.5) + t*2.0 )\n    );\n    \n    return pow((waveA*0.5+0.5)*(waveB*0.5+0.5),0.5);\n    \n}\n\nfloat blur(vec2 uv, float t){\n    float col = 0.0;\n    const float offAmt = 0.005;\n    const float samps = 5.0;\n    for(float i=0.0; i<samps; i++){\n        float ang = i/samps*6.28;\n        col += noiseSource(uv+vec2(cos(ang),sin(ang))*offAmt,t);\n    }\n    col += noiseSource(uv,t);\n    col /= (samps+1.0);\n    return col;\n}\n\nfloat noise(vec2 uv, float t){\n    return pow(blur(uv,t),2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tfloat extent = min(iResolution.x,iResolution.y);\n\tvec2 uv = fragCoord.xy / extent;\n\tuv *= 2.0;\n\tuv -= 1.0;\n\tuv -= ((iResolution.xy/extent)-1.0);\n\t\n\tvec3 col = vec3(1.0);\n    \n    float t = iTime;\n    \n    \n    const vec3 purple = vec3(0.8,0.1,0.9);\n    vec2 uvP = uv;\n    uvP.x -= sin(uvP.y*-2.0)*0.8;\n    uvP.x += sin(uvP.x)*0.2;\n    uvP.x -= sin(uvP.y*-2.0)*0.2;\n    uvP.y += sin(uvP.x*0.5+t*1.1)*0.25;\n    uvP.y += sin(uvP.x*3.8)*0.1;\n    uvP.y += sin(uvP.x*11.0-t*1.0)*(0.2+0.05*sin(uvP.x*2.0+t*2.0));\n    \n    float pAmt = abs(uvP.y) / 0.15;\n    pAmt = pow(pAmt,1.5);\n    pAmt += (noise(uv*1.9,t))*0.7;\n    pAmt = pow(pAmt,20.0);\n    pAmt = min(pAmt,1.0);\n    pAmt = max(pAmt,0.0);\n    col *= 1.0-((1.0-purple)*(1.0-pAmt));\n    \n    \n    const vec3 blue = vec3(0.4,0.95,0.95);\n    float majorSpdB = 6.0;\n    vec2 uvB = uv;\n    uvB.x -= sin(uvB.y*-2.0)*0.6;\n    uvB.x += sin(uvB.x)*0.2;\n    uvB.y += sin(uvB.x*0.5)*0.3;\n    uvB.y += sin(uvB.x*3.8-t*0.25)*0.2;\n    uvB.y += sin(uvB.x*majorSpdB+t)*0.4;\n    \n    float bAmt = abs(uvB.y) / 0.6;\n    bAmt = pow(bAmt,0.5);\n    float bEdge = sin((uvB.x+(uvB.y>0.0?0.0:pi*0.5)+pi*0.25)*majorSpdB)*0.5+0.5;\n    bEdge = bEdge*0.7 + 0.3;\n    bAmt += noise(uv*1.6,t*2.0)*bEdge;\n    bAmt = pow(bAmt,50.0);\n    bAmt = min(bAmt,1.0);\n    bAmt = max(bAmt,0.0);\n    col *= 1.0-((1.0-blue)*(1.0-bAmt));\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 63, 63, 734], [736, 736, 765, 765, 1060], [1062, 1062, 1092, 1092, 1126], [1128, 1128, 1185, 1185, 2570]], "test": "valid"}
{"id": "XdKXRG", "name": "Waves Practice", "author": "Yusef28", "description": "more line practice. Code has a lot of stuff left over from other things. ", "tags": ["2d", "waves", "lines"], "likes": 19, "viewed": 459, "published": "Public", "date": "1465012352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat waves(vec2 p){\n    float g = sin(p.x*10.0)/2.0+0.5;\n    float f = smoothstep(g-0.003, g, p.y) - smoothstep(g, g+0.003, p.y);\n    //f = smoothstep(0.0, 1.0, p.x);\n    //f = smoothstep(f-0.03, f, p.x) - smoothstep(f, f+0.03, p.x);\n    return f;\n    //float f = smoothstep(0.0, 1.0, pow(abs(fract(p.x)*2.0-1.0), 1.0));\n    \n    //return 1.0-pow(f, 1.0/20.0);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\n\nfloat linesold(vec2 p, float a){\n    //p.x +=a/2.-0.5;\n    //p.y += a*1.-1.;\n    \n    p = p*rotate2d(a+iTime*a);\n    ///float g = step(p.x,  0.1);\n    float f = smoothstep(-0.008,0.0, p.y) - smoothstep(0.0, 0.0+0.010, p.y);\n    float g = smoothstep(-1.2, 0.0, p.x) - smoothstep(0.696, 1., p.x);\n    return f*g;\n}\n\nfloat lines(vec2 p, float a, float length){\n    //p.x +=a/2.-0.5;\n   // p.x+=cos(0.556);\n    //p.y += sin(0.028);\n    \n     ///p.y += sin(p.x*5.-u_time)/10.0; //very cool\n     //p.x += cos(p.y*5.-u_time)/1.0; //very cool\n    \n    \n\t//p.y += sin(p.x+-u_time);  very cool\n    \n    \n    \n    //p.y += a-0.020;\n    //p.x -=length;\n    //p.y -= length;\n    //so I will need a bunch of line functions for this.\n    \n    p = p*rotate2d(3.660);//a+u_time*a);\n    p.y += sin(p.x*4.376+0.592)/10.; //HAVE to do rotation before this function stuff\n    ///float g = step(p.x,  0.1);\n    float f = smoothstep(-0.008,0.0, p.y) - smoothstep(0.0, 0.0+0.010, p.y);\n    float g = smoothstep(-1.000 + length, 0.0, p.x) - smoothstep(0.0, 0.984-length, p.x);\n    return f*g;\n}\n\nfloat straightlines(vec2 p, float a, float length){\n   \tlength +=sin((2.492-6.744)*-0.568)-0.192;\n    //a+u_time*a);\n    //p.y += sin(p.x*4.376+0.592)/10.;\n    ///float g = step(p.x,  0.1);\n    \n    //p.y+=sin(a+0.336);\n    //p.x+=1.264;\n    //p.x+=cos(a+4.440);\n    p.x += a+0.988;\n    p.y-=length+sin(iTime+p.x*19.560)/19.536+-0.576;\n    p = p*rotate2d(3.999);\n    p = p*rotate2d(a+20.628);\n    \n    float f = smoothstep(-0.008,0.0, p.y) - smoothstep(0.0, 0.0+0.010, p.y);\n    float g = smoothstep(-1.000 + length, 0.0, p.x) - smoothstep(0.0, 0.984-length, p.x);\n    return f*g;\n}\n\nfloat curvelines(vec2 p, float a, float length){\n  \n    p = p*rotate2d(1.692);//a+u_time*a);\n    p.y += 0.976-pow(abs(p.x/1.944), 1.932)-0.7;\n    ///float g = step(p.x,  0.1);\n    float f = smoothstep(-0.008,0.0, p.y) - smoothstep(0.0, 0.0+0.010, p.y);\n    float g = smoothstep(-1.000 + length, 0.0, p.x) - smoothstep(0.0, 0.984-length, p.x);\n    return f*g;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st*2.0-1.0;\n    st.x *= iResolution.x/iResolution.y;\n    \n\t//float a = atan(st.y, st.x);\n    //float a = 0.;\n    \n    float l = length(st);\n    st = st;\n    \n    ///st += vec2(.0);\n    \n    //st.y += sin(u_time);\n   // st.x += cos(u_time);\n    vec3 color = vec3(1.);\n    \n   // color = vec3(waves(st), 0.,0.);\n\t//st.y += (1.0*sin(st.x*u_time/1000.-u_time*10.)/10.0-0.7)*sin(u_time)/4.;\n    \n    //color = vec3(curvelines(st, 0.2,  0.416));\n   \t//color += vec3(lines(st, 0.4,  0.104));\n    \n    float a = atan(st.y, st.x); \n    \t\t\t\t\t\t//number of lines and phase?\n    \n    \n    color = vec3(straightlines(st, -.232,  0.060));\n    \n    \n    \n    color += vec3(straightlines(st, -0.696,  0.080));\n    color += vec3(straightlines(st, -0.624,  0.080));\n    color += vec3(straightlines(st, -0.560,  0.080));\n    color += vec3(straightlines(st, -0.464,  0.080));\n    color += vec3(straightlines(st, -0.360,  0.080));\n    color += vec3(straightlines(st, -0.296,  0.080));\n    color += vec3(straightlines(st, -0.792,  0.080));\n    color += vec3(straightlines(st, -0.992,  0.080));\n    color += vec3(straightlines(st, -0.888,  0.080));\n    \n    \n    color += vec3(straightlines(st, -1.696,  0.080));\n    color += vec3(straightlines(st, -1.624,  0.080));\n    color += vec3(straightlines(st, -1.560,  0.080));\n    color += vec3(straightlines(st, -1.464,  0.080));\n    color += vec3(straightlines(st, -1.360,  0.080));\n    color += vec3(straightlines(st, -1.296,  0.080));\n    color += vec3(straightlines(st, -1.792,  0.080));\n    color += vec3(straightlines(st, -1.216,  0.080));\n    color += vec3(straightlines(st, -1.112,  0.080));\n    //color += vec3(lines(st, 0.8,  0.456));\n    //color += vec3(lines(st, 1.,  0.328));\n   //color += vec3(lines(st, 1.2, 0.088));\n   \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 22, 22, 365], [367, 367, 395, 395, 481], [485, 485, 517, 561, 797], [799, 799, 842, 1203, 1554], [1556, 1556, 1607, 1607, 2138], [2140, 2140, 2188, 2188, 2500], [2501, 2501, 2558, 2558, 4407]], "test": "valid"}
{"id": "XdVSWG", "name": "Animated Polar Gradient", "author": "kgn", "description": "Example of an animated polar gradient", "tags": ["gradient", "radialgradient", "polargradient"], "likes": 9, "viewed": 790, "published": "Public API", "date": "1466320932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 center = iResolution.xy/2.0;\n\tvec2 uv = fragCoord.xy - center;\n    \n    float angle = atan(uv.y, uv.x);\n    float color = fract(iTime+0.5*(angle/pi));\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 280]], "test": "valid"}
{"id": "XdVXWc", "name": "Type II-A Supernova", "author": "KylBlz", "description": "Lightly modified supernova from Duke, all I did was change the color and expansion rate", "tags": ["fractal", "supernova"], "likes": 44, "viewed": 1310, "published": "Public API", "date": "1467117865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Type 2 Supernova\" by Duke\n//-------------------------------------------------------------------------------------\n// Based on \"Supernova remnant\" (https://www.shadertoy.com/view/MdKXzc)\n// \"Volumetric explosion\" (https://www.shadertoy.com/view/lsySzd)\n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define tex(a,b) textureLod(a,b,0.)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = tex( iChannel0, (uv+ 0.5)/256.0).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat Sphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 4.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 1.-mod((iTime - 1.) * 0.1,-1.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricExplosion(vec3 p)\n{\n    float final = Sphere(p,4.);\n    final += noise(p*20.)*.4;\n    final += SpiralNoiseC(p.zxy*fbm(p*10.))*2.5; //1.25;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, iMouse.x*0.008*pi+(iTime - 1.)*0.05);\n\tfloat igt = 2.0*sqrt(1.0 + mod((iTime - 1.)*0.1,-1.));\n\tfloat VolExplosion = VolumetricExplosion(p/igt)*igt; // scale\n\treturn abs(VolExplosion) + 0.05 + igt * 0.0175;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(0.25, 0.5, 1.0), vec3(1.0, 0.5, 0.25), density);\n\t\n\t// color added to the media\n\tvec3 colCenter = 2.0 * vec3(0.1, 0.1, 4.0);\n\tvec3 colEdge = 2.0 * vec3(0.6, 0.1, 0.1);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*tex(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*tex(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*tex(iChannel1, vec2(KEY_3,0.25)).x;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -5.+key*1.6);\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n    for (int i=0; i<64; i++)\n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.11*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(0.5,0.5,0.5);\n        \n        sum.rgb+=(vec3(0.67,0.75,1.00)/(lDist*lDist*15.)/100.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2 / lDist;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        // idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uvd = uv;\n        uvd.y*=120.;\n        uvd.x*=280.;\n        d=abs(d)*(.8+0.08*tex(iChannel0,vec2(uvd.y,-uvd.x+0.5*sin(4.*(iTime - 1.)+uvd.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),0.1), 0.01);\n\n\t}\n    \n    // simple scattering\n    sum *= 1. / exp( ld * 0.2 ) * 0.8;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n    \n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    float tm = mod((iTime - 1.), 10.);\n\tfragColor = vec4(sum.xyz,1.0) + (0.1/tm);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVXWc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[882, 896, 922, 922, 1128], [1130, 1130, 1151, 1151, 1240], [1242, 1242, 1275, 1275, 1301], [1303, 1963, 1991, 1991, 2567], [2569, 2569, 2604, 2604, 2744], [2746, 2746, 2766, 2766, 2983], [3050, 3079, 3129, 3214, 3495], [3497, 3497, 3573, 3573, 3789], [3791, 3791, 3848, 3848, 6884]], "test": "error"}
{"id": "XdyXD3", "name": "Log Moebius Transfo psychedelic", "author": "FabriceNeyret2", "description": "variant of https://www.shadertoy.com/view/4sGXDK\ncompact version of https://www.shadertoy.com/view/4dcSWs", "tags": ["zoom", "spiral", "mobius", "bug", "transform", "logarithm"], "likes": 34, "viewed": 1725, "published": "Public API", "date": "1466879576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://www.shadertoy.com/view/4sGXDK\n// compact version of https://www.shadertoy.com/view/4dcSWs\n\nvoid mainImage(out vec4 O,  vec2 U){\n\n    vec2 z = iResolution.xy;                                // normalized coordinates\n         U = (U+U - z) / z.y;\n    \n\tz = U - vec2(-1,0);  U.x -= .5;                         // Moebius transform\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n    U+=.5;  // offset. not included as length(U+=.5) because of an ATI bug\n    \n                     //  spiral, zoom       phase     // spiraling\n    U =   log(length(U))*vec2(.5, -.5) + iTime/8.\n        + atan(U.y, U.x)/6.3 * vec2(5, 1);        \n\t                                 // n  \n  //O += length(fract(U*3.)) -O;\n  //O  = texture(iChannel0, fract(U*3.));  // U*1. is also nice\n  //O += length(sin(U*30.)) -O;\n    O = .5+.5*sin(6.*3.14159*U.y+vec4(0,2.1,-2.1,0));\n                 // try also U.x\n  //O /= max(O.x,max(O.y,O.z)); // saturates the rainbow\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 113, 149, 149, 951]], "test": "valid"}
{"id": "XdyXW3", "name": "Shiny waves b", "author": "gambhiro", "description": "Shiny Waves by etd\n\nLicense Creative Commons Zero\n\nhttps://www.shadertoy.com/view/XdyXW3\n\nWave idea from http://glslsandbox.com/e#33565.1\n\nSee a variation by cubby208 https://www.shadertoy.com/view/lsKSDt\n", "tags": ["2d", "waves"], "likes": 15, "viewed": 654, "published": "Public API", "date": "1466872751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Shiny Waves by etd\n\n   License Creative Commons Zero\n\n   https://www.shadertoy.com/view/XdyXW3\n\n   Wave idea from http://glslsandbox.com/e#33565.1\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define global_speed 0.5\n\nvec4 wave (vec4 w_base, vec2 res, float time, float x_offset, float y_offset, float x_amp, float y_amp, float speed) {\n  vec2 p = ( gl_FragCoord.xy / (res.xy*4.) ) - vec2(0.25, 0.02) + y_offset;\n\n  float sx = y_amp * 0.1 * (p.x*2.0 + 2.15) * sin( x_offset + x_amp * 60. * p.x - time * speed); // varying amplitude sine value along x axis\n\n  float dy = 1. / ( 10. * abs(p.y - sx)); // greater values when y position matches sine value\n\n  vec4 col = vec4(w_base.xyz*dy, w_base.w);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime * global_speed;\n  vec2 res = iResolution.xy;\n\n  // gradients along x and y\n  vec2 p = ( gl_FragCoord.xy / res.xy ) - 0.5; // normalize coordinates to -0.5/+0.5\n  vec4 w_base = vec4(p.x + 0.5, (p.y + 0.5) * 0.8, 0.3, 1.0);\n\n  vec4 w1 = wave(w_base, res, time, 0.0, -0.1, 1.0, 0.9, 3.0);\n  vec4 w2 = wave(w_base, res, time, 5., -0.2, 0.5, 0.5 + sin(time/3.0)*0.4, 1.0);\n  vec4 w3 = wave(w_base, res, time, -5., -0.05, 0.5, 0.5 + sin(time+5.0)*0.3, 3.0);\n\n  vec4 bg = vec4(0., 0., .2, 1.0);\n\n  fragColor = bg + w1 * w2 * w3;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyXW3.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 226, 344, 344, 721], [723, 723, 780, 780, 1325]], "test": "valid"}
{"id": "XdyXWd", "name": "raymarching is gross", "author": "alexerrington", "description": "it breathes..", "tags": ["raymarch"], "likes": 1, "viewed": 102, "published": "Public", "date": "1467295487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform vec2 resolution;\n\nfloat unite( float a, float b){return min(a, b);}\nfloat subtract( float a, float b ){ return max(-a, b); }\nfloat intersect( float a, float b ){ return max(a, b); }\n\nfloat sphere( vec3 pos, vec3 center, float radius )\n{\n    return length( pos - center ) - radius;\n}\n \nfloat box( vec3 pos, vec3 center, vec3 size, float corner )\n{\n    return length( max( abs( pos-center )-size, 0.0 ) )-corner;\n}\n\nfloat sdf(vec3 p)\n{\n    float s = sphere( p, vec3( 0. ), 1.25 ) * sin(iTime) / 2.0;\n \n    float b = box( p, vec3( 0. ), vec3( 1. ), .0 );\n \n    return subtract( s,b  );\n}\n\n\n/*float sdf(vec3 p)\n{\n\treturn length(p) - 1.0;\n}*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    //uv.x *= (resolution.x / resolution.y) / 10.0;\n    \n    vec3 pos = vec3(0., 0., -2.);\n    vec3 dir = normalize(vec3(uv, 1.));\n    \n    vec3 ip;\n    \n    float t = 0.0;\n    for(int i = 0; i < 32; i++){\n        ip = pos + dir * t;\n        \n        float temp = sdf(ip);\n        //if(temp < 0.01) break;\n        \n        t += temp;\n        \n        \n    }\n    fragColor = vec4(ip, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 57, 57, 75], [76, 76, 111, 111, 132], [133, 133, 169, 169, 189], [191, 191, 244, 244, 290], [293, 293, 354, 354, 420], [422, 422, 441, 441, 592], [595, 646, 703, 703, 1155]], "test": "error"}
{"id": "XdyXWG", "name": "SSS Blob", "author": "aiekick", "description": "SSS Blob", "tags": ["sss", "blob"], "likes": 4, "viewed": 482, "published": "Public API", "date": "1466169806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotX(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\t// get rotation matrix near x\nmat3 RotY(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\t// get rotation matrix near y\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\t// get rotation matrix near z\n\nmat3 m;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// matrice sx * y * z\n\nconst vec3 mat = vec3(1,0.52,0);\t\t\t\t\t\t\t\t\t// color material\n\nfloat pattern(vec3 p)\n{\n\tp = fract(p) - 0.5;\t\t\t\t\t\t\t\t\t\t\t\t// 2d repeat\n\treturn length(vec4(p,1));\t\t\t\t\t\t\t\t\t\t// sphere \n}\n\nfloat effect(vec3 p) \n{\n\tp *= m;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// rotation xyz of p for one time here to reduce the calculation \n    float d = min(\t\t\t\t\t\t\t\t\t\t\t\t\t// min quad pattern with rotationnal layer\n\t\t\t\t\tmin(\n\t\t\t\t\t\tpattern(p), \t\t\t\t\t\t\t\t// pattern rotate near xyz one time\n\t\t\t\t\t\tpattern(p*m)), \t\t\t\t\t\t\t\t// pattern rotate near xyz two time\n\t\t\t\t\t\tpattern(p*m*m));\t\t\t\t\t\t\t// pattern rotate near xyz three time\n    return d/0.94; \t\t\t\t\t\t\t\t\t\t\t\t\t// reduce weight value with factor\n}\n\nvec4 df(vec3 p)\n{\n\tfloat dist = 1.-effect(p*0.2);\t\t\t\t\t\t\t\t\t// 3d pattern\n\tfloat lsp = length(p) - 5.;\t\t\t\t\t\t\t\t\t\t// sphere\n\tfloat sp = max(-lsp - -1.26, lsp) + dist * 5.;\t\t\t\t\t// empty sphere + pattern\n    return vec4(sp, vec3(step(dist, 0.54)));\t\t\t\t\t\t// df, df color strip\n}\n\nvec3 nor( vec3 p , vec3 e)\n{\n\treturn normalize(vec3(\t\t\t\t\t\t\t\t\t\t\t// normalized differenciate value along x, y and z for get normal at surf point\n\t    df(p+e.xyy).x - df(p-e.xyy).x,\t\t\t\t\t\t\t\t// diffenrencial over x fo surf point\n\t    df(p+e.yxy).x - df(p-e.yxy).x,\t\t\t\t\t\t\t\t// diffenrencial over y fo surf point\n\t    df(p+e.yyx).x - df(p-e.yyx).x ));\t\t\t\t\t\t\t// diffenrencial over z fo surf point\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,\tvec3( 0.0001, 0, 0)); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x/s;\t\t\t\t\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvec2 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, vec3( 0.0001, 0, 0));\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.6; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 0.5); \t\t\t\t\t\t\t// sub density of df\n\treturn vec2(\n        (diff + fre + spe) * amb * li, \t\t\t\t\t\t\t\t// ambiant diffuse + fresenl + specular => out\n        (diff + fre + sss) * amb * li + spe \t\t\t\t\t\t// ambient diffuse + fresnel + subsurface => in\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.05;\t\t\t\t\t\t\t\t\t// time for rotation matrices used by pattern in line 24\n    mat3 mx = RotX(-7.*(sin(time*2.)*.5+.5));\t\t\t\t\t \t// rotation matrice near axis x\n    mat3 my = RotY(-5.*(sin(time*1.5)*.5+.5));\t\t\t\t\t\t// rotation matrice near axis y\n    mat3 mz = RotZ(-3.*(sin(time)*.5+.5));\t\t\t\t\t\t\t// rotation matrice near axis z\n    m = mx*my*mz;\t\t\t\t\t\t\t\t\t\t\t\t\t// matrice sx * y * z\n    \n    vec2 g = fragCoord.xy;\t\t\t\t\t\t\t\t\t\t\t// pixel coord\n    vec2 si = iResolution.xy;\t\t\t\t\t\t\t\t\t\t// size of the creen\n\n\ttime = iTime * 0.5;\t\t\t\t\t\t\t\t\t\t// time for cam\n\t\n    float cam_e = 1.52; \t\t\t\t\t\t\t\t\t\t\t// cam elevation\n    float cam_d = 6.6; \t\t\t\t\t\t\t\t\t\t\t\t// cam distance to origin\n    \n    if (iMouse.z > 0.) \t\t\t\t\t\t\t\t\t\t\t\t// if mouse click on sreen\n    {\n        cam_d = 10. * iMouse.x/si.x;\t\t\t\t\t\t\t\t// cam distance range 0 to 10\n        cam_e = 5. * iMouse.y/si.y;\t\t\t\t\t\t\t\t\t// cam elevation range 0 to 5\n    }\n    \n    vec3 cu = vec3(0,1,0);\t\t\t\t\t\t\t\t\t\t\t// cam up\n  \tvec3 cv = vec3(0,0,0); \t\t\t\t\t\t\t\t\t\t\t// cam center view located on the center of the ball\n    \t\n    vec3 col = vec3(0.); \t\t\t\t\t\t\t\t\t\t\t// pixel color to out\n    \n    vec3 ro = vec3(-sin(0.), sin(cam_e), cos(0.))*cam_d; \t\t\t// ray origin\n\tvec3 lpi = vec3(-sin(time), sin(cam_e), cos(time))*0.3;\t\t\t// light point in ball\n\n  \tvec3 rov = normalize(cv-ro);\t\t\t\t\t\t\t\t\t// dir from ray origin to cam view center => axis z\n    vec3 u = normalize(cross(cu,rov));\t\t\t\t\t\t\t\t// perpendicular dir to plane fromed by cam up and rov => axis x\n  \tvec3 v = cross(rov,u);\t\t\t\t\t\t\t\t\t\t\t// perpendicular dir to plane fromed by u and rov => axis y\n  \tvec2 uv = (g+g-si)/si.y;\t\t\t\t\t\t\t\t\t\t// pixel coord in centered into the screen with screen ratio ( range -si.x/s.y to si.x/si.y for the x)\n    vec3 rd = normalize(rov + uv.x*u + uv.y*v);\t\t\t\t\t\t// ray dir of the current pixel in 3d\n    \n\tfloat md = 20.;\t\t\t\t\t\t\t\t\t\t\t\t\t// mas distance\n    float s = 1.;\t\t\t\t\t\t\t\t\t\t\t\t\t// ray marching step value ( radius of each sphere from df alogn ray marching)\n    float d = 0.;\t\t\t\t\t\t\t\t\t\t\t\t\t// distance from df to cam origine substepped by ray marching algo \n    for(int i=0;i<250;i++)\t\t\t\t\t\t\t\t\t\t\t// 250 iterations\n    {      \n        if (s<0.025*log(d*d/s/500.)||s>md) break;\t\t\t\t\t// one break condition when we are close df or when we are far of the df\n        s = df(ro+rd*d).x;\t\t\t\t\t\t\t\t\t\t\t// radius of the sphere to df from ray point ( ro + rd *d => ray origin + ray direction * distance ) \n        d += s * 0.2;\t\t\t\t\t\t\t\t\t\t\t\t// sub stepping of the df for improved the float precision of the df on pc with double its not necessary\n    }\n    \n    if (d<md)\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if distance ot the df is less than max distance, so ray dir is on df\n    {\n\t\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t// surf point\n\t\tfor (float i = 0.; i < 1.; i+=0.1)\t\t\t\t\t\t\t// sub surface iteration \n\t\t\tcol = mix(col, shade(p, rd, i, lpi, i).y * mat, i);\t\t// sub shade a dfiferent level of trnsparance with i\n        col = mix(col, shade(ro, rd, d, ro, 1.).x * (mat+0.3), 0.7);// add shade for external reflectivity\n       \tcol = min(col, df(p).yzw);\t\t\t\t\t\t\t\t\t// add pattern strip\n    }\n    \n\tfragColor.rgb = col;\t\t\t\t\t\t\t\t\t\t\t// write pixel color to the gpu buffer\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyXWG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 196, 215, 215, 273], [274, 304, 323, 323, 381], [382, 412, 431, 431, 489], [608, 627, 650, 650, 744], [746, 746, 769, 769, 1205], [1207, 1207, 1224, 1224, 1478], [1480, 1480, 1508, 1508, 1869], [1871, 1871, 1907, 1907, 2067], [2069, 2069, 2127, 2127, 2907], [2909, 2909, 2966, 2966, 6089]], "test": "valid"}
{"id": "XsGXDV", "name": "Mobius Sierpinski", "author": "Shane", "description": "Performing a Mobius transform and spiral zoom on a regular 2D Sierpinski pattern.", "tags": ["mobius", "sierpinski"], "likes": 43, "viewed": 1355, "published": "Public API", "date": "1466777379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tMobius Sierpinski\n\t-----------------\n\n\tApplying a Mobius transform and spiral zoom to a Sierpinski Carpet pattern.\n\n\n\tRelated examples:\n\n\t// Nice and simple.\n\tSierpinskiCarpet - jt\n\thttps://www.shadertoy.com/view/ldc3WH\n\t\n\tMobius Eggs - Shane\n\thttps://www.shadertoy.com/view/ldVXDG\n\n*/\n\n// Standard Mobius transform: f(z) = (az + b)/(cz + d). Slightly obfuscated.\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2){\n\n\tz1 = p - z1; p -= z2;\n\treturn vec2(dot(z1, p), z1.y*p.x - z1.x*p.y)/dot(p, p);\n}\n\n// Standard spiral zoom.\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase){\n\t\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 - iTime*.25;\n\tfloat d = log(length(p));\n\treturn vec2(a*n + d*spiral, a - d*zoom) + phase;\n}\n\n// Mobius, spiral zoomed, Sierpinski Carpet pattern.\nvec3 pattern(vec2 uv){\n    \n    // A subtlely spot-lit background. Performed on uv prior to tranformation,\n    float bg = max(1. - length(uv), 0.)*.025; \n    \n    // Transform the screen coordinates. Comment out the following two lines and \n    // you'll be left with a standard Sierpinski pattern.\n    uv = Mobius(uv, vec2(-.75, cos(iTime)*.25), vec2(.5, sin(iTime)*.25));\n    uv = spiralZoom(uv, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.25);\n    \n     \n    vec3 col = vec3(bg); // Set the canvas to the background.\n    \n    // Sierpinski Carpet - Essentially, space is divided into 3 each iteration, and a \n    // shape of some kind is rendered. In this case, it's a smooth rectangle\n    // with a bit of shading around the side.\n    //\n    // There's some extra steps in there (the \"l\" and \"mod\" bits) due to the \n    // shading and coloring, but it's pretty simple.\n    //\n    // By the way, there are other combinations you could use.\n    //\n    for(float i=0.; i<4.; i++){\n        \n        uv = fract(uv)*3.; // Subdividing space.\n        \n        vec2 w = .5 - abs(uv - 1.5); // Prepare to make a square. Other shapes are also possible.\n        \n        float l = sqrt(max(16.0*w.x*w.y*(1.0-w.x)*(1.0-w.y), 0.)); // Vignetting (edge shading).\n        \n        w = smoothstep(0., length(fwidth(w)), w); // Smooth edge stepping.\n        \n        vec3 lCol = vec3(1)*w.x*w.y*l; // White shaded square with smooth edges.\n        \n        if(mod(i, 3.)<.5) lCol *= vec3(0.1, 0.8, 1); // Color layers zero and three blue.\n        \n        col = max(col, lCol); // Taking the max of the four layers.\n        \n    } \n    \n    return col;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){ // my attempt to code-golf it (137chars)\n\n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Transformed Sierpinski pattern.\n    vec3 col = pattern(uv);\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(col), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 369, 407, 407, 490], [492, 517, 599, 599, 737], [739, 792, 814, 898, 2444], [2447, 2447, 2501, 2570, 2777]], "test": "valid"}
{"id": "XsGXWc", "name": "Kaliset", "author": "zackpudil", "description": "A pretty cheap render of a 3D Kaliset fractal.", "tags": ["raymarching", "fractal", "glow"], "likes": 14, "viewed": 362, "published": "Public", "date": "1466914440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float tmax = 100.0;\n\nfloat orb;\nfloat de(vec3 p) {\n\n\tp.x = mod(p.x + 1.2, 2.4) - 1.2;\n\tvec4 q = vec4(p, 1);\n\torb = 10000.0;\n\tfor(int i = 0; i < 15; i++) {\n        // 3D Kaliset formula\n\t\tq = 5.0*abs(q)/dot(q.xyz, q.xyz) - vec4(2.4, 0.9, 2.4, 0);\n        \n        // some random orbit trap.  Based on sqaure cosine.\n\t\torb = min(orb, sin(abs(q.x*q.y)));\n\t}\n\t\n\treturn (length(q.xyz))/q.w - 0.01;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    \n    // frag coords\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    // camera.\n\tvec3 ro = vec3(iTime, 0, -3);\n\tvec3 ww = normalize(vec3(iTime - 3.0*sin(iTime), 2.0*smoothstep(-0.5, 0.5, cos(iTime))*sign(cos(iTime*0.5)), 0) - ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(uu*uv.x + vv*uv.y + ww*1.97);\n\t\n    // ray march and glow.\n\tfloat t = 0.0;\n\tfloat g = 0.0;\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\t\n\t\tif(d < 0.0001*(1.0 + 80.0*t) || t >= 10.0) break;\n\t\tt += d*(0.1 + 0.01*t);\n\t\t\n\t\tg += 0.05*(1.0 - d);\n\t}\n\t\n\tg = clamp(g, 0.0, 1.0);\n\t\n    \n\tvec3 col = vec3(0);\n    vec3 mat = vec3(0);\n        \n\tif(t < 10.0) {\n        // geometry\n\t\tvec3 pos = ro + rd*t;\n\t\tvec2 h = vec2(0.001, 0.0);\n\t\tvec3 nor =  normalize(vec3(\n\t\tde(pos + h.xyy) - de(pos - h.xyy),\n\t\tde(pos + h.yxy) - de(pos - h.yxy),\n\t\tde(pos + h.yyx) - de(pos - h.yyx)));\n\t\t\n        // two lights, key and ground light.\n\t\tvec3 key = normalize(vec3(0.8, 0.7, -0.6));\n\t\tvec3 gro = vec3(0, -1, 0);\n\t\t\n        // apply lighting (ambient, key diffuse, bac diffuse, gr diffuse)\n\t\tcol = 0.2*vec3(1);\n\t\tcol += 0.7*clamp(dot(key, nor), 0.0, 1.0);\n\t\tcol += 0.5*clamp(0.2 + 0.8*dot(-key, nor), 0.0, 1.0);\n\t\tcol += 0.3*clamp(dot(gro, nor), 0.0, 1.0);\n\t\t\n        // material based on orbit trap.\n        mat = mix(vec3(0, 0.3, 1), vec3(1, 0.2, 0.2), 4.0*orb);\n\t\tcol *= mat;\n\t}\n\t\n\tcol += g*mat; // glow.\n\tcol = mix(col, vec3(1), 1.0 - exp(-0.1*t)); // distance fog.\n\tcol = sqrt(col); // gamma correction.\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 56, 56, 400], [402, 402, 455, 479, 2073]], "test": "valid"}
{"id": "XsKSDK", "name": "Judgment Day", "author": "Passion", "description": "Combining some terrain with tunnels and atmospheric scattering. Use the mouse to move the sun around. Lots of the comments in the code are from users Shane and Hamneggs.", "tags": ["noise", "tunnel", "scattering", "bumpmap"], "likes": 29, "viewed": 638, "published": "Public", "date": "1466676055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Sky Scattering taken from Round Rock Island by 'Hamneggs' */\n//https://www.shadertoy.com/view/4d3GRX\n\n/* Bump mapping and tunnel distance function taken from user Shane's raymarch site */\n//view-source:raymarching.com/WebGL/WebGL_TextureBumpedTunnel.htm\n\n#define NUM_STEPS 64\n#define PI   3.141593\n#define EPS 0.001\n#define CINEMATIC\n//#define SNOW\n//#define JAGGED\n\n// Frequencies and amplitudes of tunnel \"A\" and \"B\". See then \"path\" function.\nconst float freqA = 0.05;\nconst float freqB = 0.09;\nconst float ampA = 6.4;\nconst float ampB = -2.7;\n\n/***** -Begin Atmospheric Scattering- *****/\n/* \n\tOkay this is not my atmospheric scattering solution, and for the\n\tlife of me I can't find the shader that I'm borrowing it from.\n\tIt's an implementation of the method discussed in this paper:\n\thttp://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n\n\tThe nice thing is that it's not the usual Scratchapixel solution.\n*/\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat X = Yxy.g * ( Yxy.r / Yxy.b );\n\tfloat Z = ( 1.0 - Yxy.g - Yxy.b ) * ( Yxy.r / Yxy.b );\n\n\treturn vec3(X,Yxy.r,Z);\n}\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\treturn XYZ * mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n}\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, \n                                 in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * \n           ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\treturn YxyToRGB( Yp );\n}\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\n\n/*\n\tCombines the sky radiance from the magic above with a specular \n\thighl^H^H^H^H^H^Hsun.\n*/\nvec3 sky( in vec3 d, in vec3 ld )\n{\n    // Get the sky color.\n    vec3 sky = calculateSkyLuminanceRGB(ld, d, 3.0);\n    \n    // How night time is it? This variable will tell you.\n    float night = smoothstep(-0.0, -0.5, clamp(dot(ld, UP),-0.5, -0.0));\n    // Set a general brightness level so we don't just have a white screen,\n    // and artificially darken stuff at night so it looks good.\n    sky *= .040-.035*night;\n    \n    // Create a spot for the sun. This version gives us some nice edges\n    // without having a pow(x,VERY_LARGE_NUMBER) call.\n    \n    \n   \t// Mix the sky with the sun.\n    //sky = sky*(1.0+sunspot);\n    \n    // Also add in the stars.\n    return sky;\n}\n\n/***** -End Atmospheric Scattering- *****/\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, -c, c,  s);\n}\n\n//Random function\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n//Noise function\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB)); }\nvec2 path2(in float z){ return vec2(ampB*sin(z * freqB*1.5), ampA*cos(z * freqA*1.3)); }\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\nvec3 triSmooth(in vec3 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\nfloat surfFunc(in vec3 p){\n        \n   \n    float n = dot(tri(p*0.48 + tri(p*0.24).yzx), vec3(0.444));\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 0.7071;\n    return dot(tri(p*0.72 + tri(p*0.36).yzx), vec3(0.222)) + n; // Range [0, 1]\n    \n    \n    // Other variations to try. All have range: [0, 1]\n    \n    /*\n\treturn dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.666));\n\t*/\n    \n    /*\n    return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.333)) + \n           sin(p.x*1.5+sin(p.y*2.+sin(p.z*2.5)))*0.25+0.25;\n\t*/\n    \n    /*\n    return dot(tri(p*0.6 + tri(p*0.3).yzx), vec3(0.333)) + \n           sin(p.x*1.75+sin(p.y*2.+sin(p.z*2.25)))*0.25+0.25; // Range [0, 1]\n    */\n    \n    /*\n    p *= 0.5;\n    float n = dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.66));\n    p *= 1.5;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\n    n += dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.34));\n    return n;\n    */\n    \n    /*\n    p *= 1.5;\n    float n = sin(p.x+sin(p.y+sin(p.z)))*0.57;\n    p *= 1.5773;\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.28;\n    p *= 1.5773;\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.15;\n    return n*0.4+0.6;\n    */\n\n}\n// Cheap...ish smooth minimum function.\nfloat smoothMinP( float a, float b, float smoothing ){\n    float h = clamp((b-a)*0.5/smoothing + 0.5, 0.0, 1.0 );\n    return mix(b, a, h) - smoothing*h*(1.0-h);\n}\n// Smooth maximum, based on the function above.\nfloat smoothMaxP(float a, float b, float smoothing){\n    float h = clamp((a - b)*0.5/smoothing + 0.5, 0.0, 1.0);\n    return mix(b, a, h) + h*(1.0 - h)*smoothing;\n}\nfloat map(vec3 p){\n    vec2 tun = p.xy - path(p.z);\n    vec2 tun2 = p.xy - path2(p.z);\n    float d = 1.- smoothMinP(length(tun), length(tun2), 4.) + (0.5-surfFunc(p));\n    float dd = (sin(p.x/2.)+cos(p.z/1.5));\n\n#ifdef JAGGED\n    return max(d, noise(p.zx/2.)+p.y+noise(p.xz/3.)+dd+surfFunc(p/2.));\n#endif    \n    return smoothMaxP(d, (noise(p.zx/2.)+p.y+noise(p.xz/3.)+dd+surfFunc(p/2.)), .5);\n}\n\nfloat trace(vec3 r, vec3 o){\n    float t, d = 0.0;\n    \n    for(int i = 0; i < NUM_STEPS; i++){\n        vec3 p = o + t*r;\n        d = map(p);\n        if(d < EPS) break;\n        t += d *.5;\n    }\n    return t;\n}\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\nvec3 getNormal2(vec3 p)\n{\n    const float d = EPS;\n    return normalize(vec3(map(p+vec3(d,0.0,0.0))-map(p+vec3(-d,0.0,0.0)),\n                          map(p+vec3(0.0,d,0.0))-map(p+vec3(0.0,-d,0.0)),\n                          map(p+vec3(0.0,0.0,d))-map(p+vec3(0.0,0.0,-d))));\n}\nvec3 getNormal(vec3 p) {\n\tvec2 e = vec2(EPS, 0.0);\n\treturn normalize((vec3(map(p+e.xyy), map(p+e.yxy), map(p+e.yyx)) - map(p)) / e.x);\n}\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime;\n    vec2 mm = iMouse.xy/iResolution.xy;\n    mm.xy -= .5;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * .15));\n    if(iMouse.z < 1.0)\n        mm = (vec2(.0, .2));\n        \n    vec3 l = normalize(vec3(mm, .2));\n    //l.xz *= r2(t);\n    // Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, t*4.);  // \"Look At\" position.\n\tvec3 o = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\to.xy += path2(o.z);\n\t\n    r.yx*=r2(noise(vec2(t/3.))+1.);\n    r.zy*=r2(noise(vec2(t/2.))+1.3);\n    \n    vec3 s = sky(r, l);\n    \n    float sunspot = smoothstep(.99935, .99965, max(dot(r,l),0.0));\n    sunspot += smoothstep(.98000, 1.0, max(dot(r,l),0.0))*.05; // Corona.\n    \n    float hit = trace(r, o);\n    vec3 sp = (o+hit*r);\n    float d = map(sp);\n    vec3 norm = getNormal(sp);   \n    norm = doBumpMap(iChannel0, (sp)*(1.0/3.0), norm, 0.05);\n\n    fragColor.a = 1.0; \n    vec4 tex = vec4(tex3D(iChannel0,(sp)*(1.0/3.0), norm), 1.0);\n\tfloat c = .0;\n    c = max(c + dot(hash33(vec3(r))*2.-1., vec3(0.025)), 0.);\n    float diffuse = clamp(dot(norm, l), 0.1, 1.0);\n\n#ifdef SNOW\n    if(dot(norm,UP) > .93)\n        tex.rgb +=1.; \n#endif\n    \n    if(d < .5){\n        float fog = smoothstep(0.4, 0.8 ,hit*.03);\n        fragColor = mix(vec4(tex*diffuse), vec4(s, 1.0), fog);\n    }\n    else{\n        fragColor.rgb = s * (1.0 + sunspot);\n    }\n    \n#ifdef CINEMATIC\n    if(uv.y > .75 || uv.y < -.75)\n        fragColor=vec4(0.0);\n    \n    fragColor+=-c;\n#endif\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[551, 922, 966, 966, 1004], [1005, 1005, 1035, 1035, 1157], [1158, 1158, 1188, 1198, 1340], [1341, 1341, 1371, 1371, 1444], [1445, 1445, 1552, 1552, 1949], [1950, 1950, 2015, 2015, 2809], [2810, 2810, 2966, 2966, 3094], [3095, 3095, 3162, 3162, 3682], [3743, 3837, 3872, 3898, 4514], [4516, 4560, 4577, 4577, 4654], [4656, 4674, 4694, 4694, 4761], [4762, 4779, 4800, 4800, 4997], [4999, 5099, 5121, 5121, 5178], [5179, 5179, 5202, 5202, 5267], [5268, 5466, 5486, 5486, 5513], [5514, 5536, 5562, 5562, 5597], [5598, 5633, 5659, 5659, 6853], [6854, 6894, 6948, 6948, 7056], [7057, 7105, 7157, 7157, 7268], [7269, 7269, 7287, 7287, 7664], [7666, 7666, 7694, 7694, 7876], [7877, 7943, 7993, 7993, 8189], [8191, 8378, 8440, 8440, 8945], [8946, 8946, 8971, 8971, 9222], [9223, 9223, 9247, 9247, 9359], [9360, 9360, 9380, 9380, 9488], [9489, 9489, 9546, 9546, 11418]], "test": "error"}
{"id": "XsKSWm", "name": "Complex exponentiation map color", "author": "ale93111", "description": "Iteration on the complex plane of the function f(z)=z^z^z^z^z^z...ecc for complex numbers with various methods of coloring ", "tags": ["2d", "fractal", "orbit", "dynamics", "complex", "exponentiation"], "likes": 7, "viewed": 212, "published": "Public", "date": "1464780950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Alessandro Marzo - ale93111/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// same as my other shader: https://www.shadertoy.com/view/ldVXD1 \n// but with different methods of coloring taken from:\n// iq - https://www.shadertoy.com/view/4dfGRn\n// gtoledo3 - https://www.shadertoy.com/view/Xt2SDw\n\n//supersampling\n#define  AA 2\n\nconst int max_iterations = 10;\n\nfloat izoom = 1.0/3.0; //increase denominator to increase zoom\nvec2 ioffset = vec2( 0.0, -0.11); //offset to center the picture\nvec3 color = vec3(0.0);  //RGB\n\n//Complex Exponentiation - Source: http://mathworld.wolfram.com/ComplexExponentiation.html\nvec2 powC( vec2 Z, vec2 W)\n{\n    float arg = atan(Z.y / Z.x);\n    //press mouse to remove scale animation\n    //float a = exp( -W.y*arg )*pow( dot(Z,Z), W.x/(3.0 + ((iMouse.w>0.0)? -1.0 :cos(0.2*iTime)))); \n    float a = exp( -W.y*arg )*pow( dot(Z,Z), W.x/4.0 ); //wihtout scaling animation\n    float b = W.x*arg + 0.5*W.y*log( dot(Z,Z) );\n    \n    return a*vec2(cos(b), sin(b));    \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )  \n\t{\n        vec2 p = (((fragCoord.yx - iResolution.xy*0.3 + vec2(float(ii),float(jj))/float(AA)) / iResolution.x) * izoom) + ioffset;\n        vec2 Z = (((fragCoord.yx - iResolution.xy*0.3 + vec2(float(ii),float(jj))/float(AA)) / iResolution.x) * izoom) + ioffset;\n    \n\t\tvec3 col = vec3(0.0);\n    \n    \tfloat k = 1.0-abs(cos(0.2*iTime));\n    \t//float k = 1.0; //wihtout exponentiation animation\n        //float k = 1.6180339887;\n    \tvec4 dmin = vec4(1000.0);\n        \n   \t\tfor(int i=0; i<max_iterations; i++) \n    \t{\n      \n        \t// Z^Z^Z...20-21 times animated between odd and even exponentiation\n        \tZ = powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,k*powC(Z,powC(Z,powC(Z,Z))))))))))))))))))));\n        \n        \t// Z^Z^Z...64-65 times animated between odd and even exponentiation\n        \t//Z = powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,powC(Z,k*powC(Z,Z))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));\n        \n            dmin=min(dmin, vec4(abs(0.0+Z.y + 0.5*sin(Z.x)), \n\t\t\t\t\t\t\t\tabs(1.0+Z.x + 0.5*sin(Z.y)), \n\t\t\t\t\t\t\t\tdot(Z,Z),\n\t\t\t\t\t\t\t    length( fract(Z)-0.5) ) );\n            \n        \tif( dot(Z,Z)> 0.1) break;\n    \t}\n    \n        vec3 color1 = vec3( dmin.w );\n\t\t\n\n\t\tcolor1 = color1*color1*color1*color1;\n\t\n\t\t//color *= 0.5 + 0.5*pow(abs(16.0*p.x*(1.0-p.x)*p.y*(1.0-p.y)),0.15);\n        \n    \t\n        col = vec3(smoothstep( 0.0, sqrt(3.0), float(sqrt(abs(dot(Z,Z))))),\n                   smoothstep( 0.0, sqrt(50.0), float(sqrt(abs(dot(Z,Z))))),\n                   smoothstep( 0.0, sqrt(5e20), float(sqrt(abs(dot(Z,Z))))));\n        \n        Z.x+=sin(Z.y*2.);\n\t\tZ.y+=sin(Z.x*20.)*.1;\n\t\tZ.x+=sin(Z.y*3.);\n\t\tZ.y+=sin(Z.x*5.);\n\t\n\t\tfloat rand = mod(fract(sin(dot(2.5*p,vec2(12.9898,100.233+iTime)))*43758.5453),.35);\n\t\tfloat v = 0.4; \n        float depthCull=0.1;\n\t\tvec3 col2;\n        float shade=0.1;\n  \n\t\tv +=sin(Z.x*20.0) *0.01;\n\t\tv +=sin(Z.y*120.0)*0.02;\n\t\tv +=sin(Z.y*20.0) *0.01; \n\t\tv +=sin(Z.x*4.0)  *0.2;\n\t\tv +=sin(Z.x*7.0)  *0.2;\n\t\tv=clamp(v,0.0,1.0);\n\t\tcol2 = vec3((rand*.75)+vec3(pow(v+0.2,-0.95)))*vec3(0.4, 0.2, 0.2);\n        \n        col = mix( col, vec3(0.00,0.20,0.40), 1.0-min(1.0,pow(dmin.x*0.25,0.50)) );\n   \t \tcol = mix( col, vec3(0.72,0.20,0.20), 1.0-min(1.0,pow(dmin.y*0.50,0.30)) );\n\t\tcol = mix( col, vec3(0.70,0.20,0.20), 1.0-min(1.0,pow(dmin.z*1.00,0.35) ));\n        \n        color += col*col2*col; \n    }\n    color /= float(AA*AA);\n\tfragColor = vec4( color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKSWm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[578, 669, 697, 697, 1054], [1057, 1057, 1114, 1114, 4069]], "test": "timedout"}
{"id": "XsKXzc", "name": "KIFS Flythrough", "author": "Shane", "description": "Constructing a basic fractal object with Knighty's Kaleidoscopic IFS procedure.", "tags": ["fractal", "kifs", "environment", "mapped"], "likes": 75, "viewed": 4114, "published": "Public API", "date": "1465911595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    KIFS Flythrough\n    ---------------\n\n    After looking at Zackpudil's recent fractal shaders, I thought I'd put together something \n\tfractal in nature. It's nothing exciting, just the standard IFS stuff you see here and there. \n\tLike many examples, this particular one is based on Syntopia and Knighty's work.\n\n    The construction is pretty similar to that of an infinite sponge, but it has a bit of rotating, \n\tfolding, stretching, etc, thrown into the mix.\n\n    The blueish environmental lighting is experimental, and based on XT95s environment mapping in \n\this UI example. The idea is very simple: Instead of passing a reflective ray into a cubic \n\ttexture in cartesian form, convert it to its polar angles, then index into a 2D texture. The \n\tresults are abstract, and no substitute for the real thing, but not too bad, all things \n\tconsidered.\n\n\tThe comments are a little rushed, but I'll tidy them up later.\n\n\tExamples and references:\n\n    Menger Journey - Syntopia\n    https://www.shadertoy.com/view/Mdf3z7\n\n    // Explains the process in more detail.\n    Kaleidoscopic (escape time) IFS - Knighty\n    http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-(escape-time-ifs)/\n\n    Ancient Generators - Zackpudil\n    https://www.shadertoy.com/view/4sGXzV\n\n*/\n\n#define FAR 40.\n\n// Wireframe version.\n//#define WIREFRAME\n\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// IFS, or KIFS in particular. The following explains the process in more detail.\n//\n// Kaleidoscopic (escape time) IFS - Knighty\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-(escape-time-ifs)/\n//\n// Here's a quick, rushed expanation. Take an input point, and repeat it. After that, rotate\n// it, fold it, stretch and translate it about an offset point. Form an object with it and compare\n// it to the object formed in the repeat layer. Repeat ad infinitum...\n//\n// OK, that was a little vague, but it really is a pretty simple process. Playing around with the \n// code will give it more meaning. Change the rotation angles, iteration number, comment some\n// things out, etc. I'd also recommend reading Syntopia's blog. He explains things really well...\n// and there's so many pretty pictures. :)\n//\n// Syntopia - http://blog.hvidtfeldts.net/\n//\nfloat map(vec3 p){\n    \n    // I'm never sure whether I should take constant stuff like the following outside the function, \n    // or not. My 1990s CPU brain tells me outside, but it doesn't seem to make a difference to frame \n    // rate in this environment one way or the other, so I'll keep it where it looks tidy. If a GPU\n    // architecture\\compiler expert is out there, feel free to let me know.\n    \n    const vec3 offs = vec3(1, .75, .5); // Offset point.\n    const vec2 a = sin(vec2(0, 1.57079632) + 1.57/2.);\n    const mat2 m = mat2(a.y, -a.x, a);\n    const vec2 a2 = sin(vec2(0, 1.57079632) + 1.57/4.);\n    const mat2 m2 = mat2(a2.y, -a2.x, a2);\n    \n    const float s = 5.; // Scale factor.\n    \n    const float sz = .0355; // Box size.\n    #ifdef WIREFRAME\n    const float ew = .015; // Wireframe box edge width.\n    #endif\n    \n    float d = 1e5; // Distance.\n    \n    \n    p  = abs(fract(p*.5)*2. - 1.); // Standard spacial repetition.\n     \n    \n    float amp = 1./s; // Analogous to layer amplitude.\n    \n   \n    // With only two iterations, you could unroll this for more speed,\n    // but I'm leaving it this way for anyone who wants to try more\n    // iterations.\n    for(int i=0; i<2; i++){\n        \n        // Rotating.\n        p.xy = m*p.xy;\n        p.yz = m2*p.yz;\n        \n        p = abs(p);\n        //p = sqrt(p*p + .03);\n        //p = smin(p, -p, -.5); // Etc.\n        \n  \t\t// Folding about tetrahedral planes of symmetry... I think, or is it octahedral? \n        // I should know this stuff, but topology was many years ago for me. In fact, \n        // everything was years ago. :)\n\t\t// Branchless equivalent to: if (p.x<p.y) p.xy = p.yx;\n        p.xy += step(p.x, p.y)*(p.yx - p.xy);\n        p.xz += step(p.x, p.z)*(p.zx - p.xz);\n        p.yz += step(p.y, p.z)*(p.zy - p.yz);\n \n        // Stretching about an offset.\n\t\tp = p*s + offs*(1. - s);\n        \n\t\t// Branchless equivalent to:\n        // if( p.z < offs.z*(1. - s)*.5)  p.z -= offs.z*(1. - s);\n        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\n        \n        // Loosely speaking, construct an object, and combine it with\n        // the object from the previous iteration. The object and\n        // comparison are a cube and minimum, but all kinds of \n        // combinations are possible.\n        p = abs(p);\n        vec3 q = p*amp;\n        //d = min(d, max(max(p.x, p.y), p.z)*amp - .035);\n        \n        // The object you draw is up to you. There are countless options.\n        float box = max(max(q.x, q.y), q.z) - sz;\n        //box = min(box, max(max(q.y, q.z) - sz*.33, q.x - sz*1.1));\n        //float box = max(length(q.yz) - sz*1.2, q.x - sz);\n        //float box = length(q) - sz; // A very spherical box. :)\n        #ifdef WIREFRAME\n        box = max(box, -(min(min(max(q.x, q.y), max(q.x, q.z)), max(q.y, q.z)) - sz + ew));\n        //box = max(box, -max(length(q.yz) - ew, q.x - sz - ew));\n        //box = max(box, -(max(length(q.yz - sz*.5) - ew*.35, q.x - sz - ew*.5)));\n        //box = max(box, -(max(q.y, q.z) - sz + ew));\n        #endif\n        // Vertices, of sorts.\n        //q = abs(q) - sz;\n        //box = min(box, length(q) - sz/3.);\n        d = min(d, box);\n        \n        \n        amp /= s; // Decrease the amplitude by the scaling factor.\n        \n    }\n \n \treturn d; // Return the distance.\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    // Gradient vector, constructed with offset greyscale texture values.\n    //vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m;\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n// Very basic raymarching equation.\nfloat trace(vec3 ro, vec3 rd){\n\n    \n    float t = 0.;//hash(dot(rd, vec3(7, 157, 113)))*0.01;\n    for(int i=0; i< 64; i++){\n        \n        float d = map(ro + rd*t);\n        if (d < 0.0025*(1. + t*.125) || t>FAR) break;\n        t += d*.75;\n    } \n    return t;\n}\n\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n// Apart from being faster, it can produce a subtley different aesthetic to the 6 tap version, which I sometimes prefer.\nvec3 normal(in vec3 p){\n    \n    #ifdef WIREFRAME\n    // Sharper corners on the wireframe version.\n    vec2 e = vec2(0.002, -0.002); \n    #else\n    // Note the slightly increased sampling distance, to round off the edges a bit\n    // and to  alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005);\n    #endif\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor){\n\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.02, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.25, 1.0); \n}\n\n\n\n\n\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\nfloat drawObject(in vec3 p){\n  \n    p = fract(p) - .5;    \n    return dot(p, p);\n}\n\n\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y);\n        \n    return d.x*2.66; // Normalize... roughly.\n    \n}\n\n// Four layers of cheap cell tile noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t/64.; // Edge the ray a little forward to begin.\n    \n    for (int i = 0; i<8; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = min(1./(1. + sDi*0.25 + sDi*sDi*0.25), 1.);\n\t    // Noise layer.\n        //float n = trigNoise3D(ro/2.);//noise3D(ro/2.)*.66 + noise3D(ro/1.)*.34;\n        float n = cellTile(ro/1.);\n        mist += n*sAtt;//trigNoise3D\n        // Advance the starting point towards the hit point.\n        ro += rd*t/8.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/4. + hash31(ro)*0.2-0.1, 0., 1.);\n\n}\n\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected ray at the surface hit point, \n// convert the 3D ray coordinates (rd) to polar coordinates (the angular components) and \n// index into a repeat texture. It can be pretty convincing (in an abstract way) and\n// facilitates environment mapping without the need for a cube map, or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 rd, vec3 n){\n    \n    //vec3 col2 = tex3D(iChannel1, rd/4., n).zyx;//*(1.-lod*.8)\n    //return smoothstep(.0, 1., col2*2.);\n    \n\n    // I got myself a little turned around here, but I think texture size\n    // manipulation has to be performed at this level, if you want the angular\n    // polar coordinates to wrap... Not sure though... It'll do. :)\n    rd /= 4.; \n    \n    vec2 uv = vec2(atan(rd.y, rd.x)/6.283, acos(rd.z)/3.14159);\n    uv = fract(uv);\n   \n    vec3 col = texture(iChannel1, uv).zyx;//*(1.-lod*.8)\n    return smoothstep(.1, 1., col*col*2.);\n    \n}\n\n\n/*\n// Pseudo environment mapping. Simlilar to above, but using tri-planar texturing for a more \n// even spread.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tex3D(iChannel1, rd/4., n).zyx;\n    return smoothstep(.1, 1., col*2.);\n}\n*/\n//////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty happy with this.\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n    \n    // Barrel distortion;\n    rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z - dot(rd.xy, rd.xy)*0.2)));\n\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(1.57079632, 0) + iTime/4.);\n    rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);\n    \n    \n    // Ray origin, set off in the YZ direction. Note the \"0.5.\" It's an old lattice trick.\n    vec3 ro = vec3(0, 0, iTime);\n    vec3 lp = ro + vec3(0, .25, .65); // Light, near the ray origin.\n\n    // Set the scene color to black.\n    vec3 col = vec3(0);\n\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Surface hit, so light it up.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n\n\n        const float sz = 1.5; // Texture size, or scale, if you prefer.\n\n        sn = db(iChannel0, sp*sz, sn, .004/(1. + t/FAR*.5)); // Texture bump.\n\n     \n\n        vec3 oCol = tex3D(iChannel0, sp*sz, sn); // Texture color at the surface point.\n        oCol = smoothstep(.0, .8, oCol);\n\n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calculateAO(sp, sn)*.5 + .5; // Self shadows. Not too much.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n\n        float atten = 1./(1. + lDist*.25 + lDist*lDist*.075); // Attenuation.\n\n        // Combining the elements above to light and color the scene. The\n        // specular component is exaggerated to give yellowy highlights.\n        // None of this mimicks real life. :)\n        col = oCol*(diff + vec3(.4, .25, .2) + vec3(1., .6, .2)*spec*8.);\n        \n        // Faux environmental mapping. Passing in the reflected ray.\n        col += (col*1. + .5)*envMap(reflect(rd, sn), sn);\n        \n        // Environment mapping with a cubic texture, for comparison.\n        //vec3 rfCol = texture(iChannel2, reflect(rd, sn)).xyz; // Forest scene.\n        //col += rfCol*rfCol*.5;\n\n\n        // Shading the scene color, clamping, and we're done.\n        col = min(col*atten*sh*ao, 1.);\n        \n        \n\n        //col = clamp(col + hash(dot(rd, vec3(7, 157, 113)))*0.1 - 0.05, 0., 1.);\n        \n    }\n    \n    \n    // Blend the scene and the background with some very basic, 8-layered smokey haze.\n    float mist = getMist(ro, rd, lp, t);\n    vec3 sky = mix(vec3(1, .75, .5), vec3(.35, .6, 1), dot(rd.yz, vec2(.5))*.5 + .5)*mix(1., .75, mist);\n    \n    // Mix the smokey haze with the object.\n    col = mix(sky, col, 1./(t*t/FAR/FAR*128. + 1.));\n\n    // Statistically unlikely 2.0 gamma correction, but it'll do. :)\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1310, 1354, 1376, 1376, 1411], [1413, 1567, 1617, 1919, 2828], [2832, 3709, 3727, 4112, 7032], [7035, 7117, 7172, 7172, 7722], [7725, 7761, 7791, 7791, 8025], [8029, 8222, 8245, 8245, 8682], [8906, 9058, 9102, 9102, 9362], [9365, 9580, 9624, 9741, 10856], [11157, 11208, 11229, 11229, 11295], [11297, 11297, 11325, 11325, 11379], [11382, 11382, 11408, 11516, 12151], [12153, 12441, 12503, 12503, 13221], [13224, 13886, 13915, 14253, 14468], [14471, 14718, 14774, 14951, 17969]], "test": "error"}
{"id": "XsVSDc", "name": "Hex Space", "author": "gleurop", "description": "zooming into (sqrt 2, sqrt 2)", "tags": ["procedural", "fractal", "hex"], "likes": 16, "viewed": 787, "published": "Public API", "date": "1467136599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// thanks FabriceNeyret2 for simplification\n\nfloat hex( vec2 p, float h )\n{\n    vec2 q = abs(p);\n    return max((q.x*.866025 + q.y*.5),q.y) - h;\n}\n\n#define rot(t) mat2(cos(t), sin(t), -sin(t),cos(t))\n\nfloat samp(vec2 U)\n{\n    float t = iTime;\n    vec2 R = iResolution.xy,\n\t\t uv = (U+U - R) / R.x * .01 / exp(mod(t,3.52)) * rot(t*.3) + sqrt(2.);\n    \n\tfloat orb = 1.;\n\tfor(int i = 0; i < 13; i++) {\n\t\tuv = abs(uv-1.);\n\t\tuv = abs(uv/dot(uv,uv) - 1.);\n\t\tuv = 2.*fract(abs(uv-.5));\n\t\torb = min(orb, hex(uv, .3));\n\t}\n    \n    return step(orb,0.) + fract(t/3.52)*.2;\n\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O = vec4( samp(U) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 75, 75, 146], [201, 201, 221, 221, 563], [565, 565, 606, 606, 633]], "test": "valid"}
{"id": "XsVSWG", "name": "Slowstars 2  ( 197 chars )", "author": "FabriceNeyret2", "description": "from compaction of danb's slowstar shader [url]https://www.shadertoy.com/view/MsGXWy[/url]", "tags": ["starfield", "2tweets", "short"], "likes": 32, "viewed": 1403, "published": "Public API", "date": "1466321356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired from https://www.shadertoy.com/view/MsGXWy\n\n\n/**/     // 197 chars\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O -= O;\n    \n    for (float i = 0.; i < 2e2; i ++)\n        O += R(i)/ 1e3         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n               / length( fract( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * iTime/20. ) \n                         - U/iResolution.x );\n    // --- colors\n  //O *= vec4(1,.6,.4,1);\n  //O *= vec4(1,O.x,O.x*O.x,1);\n  //O = sin(40./O); // just for fun\n}\n/**/\n\n\n\n\n/**      // 208 chars\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )\n\nvoid mainImage(out vec4 O, vec2 U )\n{\n    O -= O;\n    \n    for (float i = 0.; i < 2e2; i ++)\n        O += max( 0., \n                  1.- length( fract( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * iTime/20. ) \n                              - U/iResolution.x\n                            ) / R(i) * 2e2\n                );\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 148, 186, 186, 584]], "test": "valid"}
{"id": "XsVXDV", "name": "2D Rotating Gears", "author": "jaburns", "description": "Some interlocking gears rotating.", "tags": ["2d", "animation"], "likes": 8, "viewed": 270, "published": "Public API", "date": "1466798782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n#define BORDER     0.04\n#define BORDER_ANG 0.16\n#define TEETH      5.00\n#define RING0      0.25\n#define RING1      0.40\n#define RING2      0.43\n#define BAR        0.07\n#define GEAR_SIZE  0.61\n#define SMOOTH     5.00\n\nconst vec4 COLOR_0 = vec4(0.2000,0.2471,0.2667,1.0);\nconst vec4 COLOR_1 = vec4(0.2157,0.6667,0.6118,1.0);\nconst vec4 COLOR_2 = vec4(0.5804,0.9529,0.8941,1.0);\n\nvec2 roto( in vec2 p, in float theta )\n{\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * p;\n}\n\nfloat gear( in vec2 p, in float angle )\n{\n    float theta = atan(p.y, p.x) - angle;\n    float tooth = mod(theta, PI/TEETH) / (PI/TEETH);\n    float len = length(p);\n    \n    if (len < RING0) {\n        vec2 p1 = roto(p, angle);\n        return max(\n            smoothstep(RING0 - BORDER, RING0, len),\n            smoothstep(BAR, BAR-BORDER, min(abs(p1.x), abs(p1.y)))\n        );\n    }\n    \n    if (len < RING1) {\n        if (len < RING1 - BORDER) return 1.0;\n        \n        float innerBorder = smoothstep(RING1, RING1 - BORDER, len);\n        if (tooth < BORDER_ANG) {\n            return max(innerBorder, smoothstep(BORDER_ANG, 0.0, tooth));\n        }\n        if (tooth > GEAR_SIZE && tooth <= GEAR_SIZE + BORDER_ANG) {\n            return max(innerBorder, smoothstep(GEAR_SIZE, GEAR_SIZE + BORDER_ANG, tooth));\n        }\n        if (tooth < GEAR_SIZE) {\n\t\t\treturn innerBorder;\n        }\n    }\n    \n    float toothBorder = smoothstep(RING2 + BORDER, RING2, len);\n    if (len > RING2 && tooth > GEAR_SIZE + BORDER_ANG) return toothBorder;\n    if (tooth < BORDER_ANG) {\n        return min(toothBorder, smoothstep(BORDER_ANG, 0.0, tooth));\n    }\n    if (tooth > GEAR_SIZE && tooth <= GEAR_SIZE + BORDER_ANG) {\n        return min(toothBorder, smoothstep(GEAR_SIZE, GEAR_SIZE + BORDER_ANG, tooth));\n    }\n    \n    return tooth > GEAR_SIZE ? 1.0 : 0.0;\n}\n\nvec2 texToWorld( in vec2 coord )\n{\n    return (coord.xy / iResolution.yy)\n        - vec2(0.5*iResolution.x/iResolution.y, 0.5);   \n}\n\nvoid placeGear( inout vec4 fragColor, in vec2 p, in float x, in float angle, in float aa )\n{\n    float g = gear(p + vec2(x, 0.0), angle);\n    \n    fragColor = mix(fragColor, COLOR_1, smoothstep(0.00,      aa, g));\n    fragColor = mix(fragColor, COLOR_2, smoothstep(1.00-aa, 1.00, g));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = texToWorld(fragCoord) * 1.1;\n    float t = 4.0*cos(0.25*iTime);\n    float aa = SMOOTH * (abs(dFdx(p.x)) + abs(dFdy(p.y)));\n    \n    fragColor = COLOR_0;\n    placeGear(fragColor, p,  0.42,  t-0.17, aa);\n    placeGear(fragColor, p, -0.42, -t,      aa);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[397, 397, 437, 437, 509], [511, 511, 552, 552, 1856], [1858, 1858, 1892, 1892, 1990], [1992, 1992, 2084, 2084, 2278], [2280, 2280, 2337, 2337, 2603]], "test": "valid"}
{"id": "XsVXWG", "name": "Shootout in Red Canyon", "author": "dr2", "description": "X-Fighter practice (mouse enabled)", "tags": ["raymarching", "flight"], "likes": 17, "viewed": 1018, "published": "Public API", "date": "1466333724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Shootout in Red Canyon\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 AxToRMat (vec3 vz, vec3 vy);\nvec2 Rot2D (vec2 q, float a);\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\n#define N_FLYER 2\n\nint idObj, idFlmGrp, idLsrGrp;\nmat3 flyerMat[N_FLYER], flMat;\nvec3 flyerPos[N_FLYER], flPos, qHit, qHitFlm, qHitLsr, sunDir, flmCylPos, lsrCylPos,\n   trkF, trkA;\nfloat dstFar, tCur, fusLen, flmCylRad, flmCylLen, lsrCylRad, lsrCylLen, vFly;\nconst int idFus = 11, idEngO = 12, idEngI = 13, idWng = 14, idCan = 15;\nconst float pi = 3.14159;\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.5, 0.2, 0.1) + vec3 (0.3, 0.2, 0.2) * pow (1. - max (rd.y, 0.), 8.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, skyHt, f;\n  cloudFac = 0.;\n  skyHt = 200.;\n  if (rd.y > 0.) {\n    ro.x += 10. * tCur;\n    f = Fbm2 (0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz));\n    cloudFac = clamp (3. * (f - 0.5) * rd.y - 0.1, 0., 1.);\n  }\n  col = SkyBg (rd) + vec3 (0.5, 0.3, 0.3) * pow (max (dot (rd, sunDir), 0.), 6.);\n  return mix (col, vec3 (0.15), cloudFac);\n}\n\nfloat GrndDf (vec3 p)\n{\n  float d, s;\n  s = p.y - 3.;\n  d = SmoothMin (12. + 4. * sin (0.019 * p.z) -\n     abs (p.x - dot (trkA, sin (trkF * p.z))) +\n     s * (0.3 - 0.05 * s), 3. + p.y, 2.);\n  d = SmoothMax (d, - (8. + 1.1 * sin (0.022 * p.z) - p.y), 1.);\n  d += 2.3 * Noisefv2 (0.2 * p.xz) + 1.1 * Noisefv2 (0.6 * p.xz) +\n     0.3 * Noisefv2 (1.1 * p.xz);\n  return d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += 0.5 * h + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 4; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., GrndDf (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec3 e;\n  float s;\n  e = vec3 (0.01, 0., 0.);\n  s = GrndDf (p);\n  return normalize (vec3 (GrndDf (p + e.xyy) - s, e.x,\n     GrndDf (p + e.yyx) - s));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  vec3 col, wCol, bCol;\n  float cSpec;\n  wCol = mix (vec3 (0.3, 0.2, 0.2), vec3 (0.15, 0.1, 0.1),\n     clamp (1.4 * (Noisefv2 (p.xy +\n     vec2 (0., 0.3 * sin (0.14 * p.z)) *\n     vec2 (2., 7.3)) + Noisefv2 (p.zy * vec2 (3., 6.3))) - 1., 0., 1.));\n  bCol = mix (vec3 (0.4, 0.25, 0.1), vec3 (0.2, 0.1, 0.1),\n     clamp (0.7 * Noisefv2 (3. * p.xz) - 0.4, 0., 1.));\n  col = mix (wCol, bCol, smoothstep (0.6, 0.8, n.y));\n  cSpec = clamp (0.3 - 0.1 * n.y, 0., 1.);\n  return vec4 (col, cSpec);\n}\n\nfloat FlmDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dMin, r, s;\n  dMin = dstFar;\n  s = (0.55 / sqrt (2.)) * fusLen;\n  for (int k = 0; k < N_FLYER; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]) - flmCylPos;\n    r = flmCylRad * (0.6 + 0.4 * q.z / flmCylLen);\n    qq = q + vec3 (s, s, 0.);\n    d = PrCylDf (qq, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = qq;  idFlmGrp = k; }\n    qq = q + vec3 (s, - s, 0.);\n    d = PrCylDf (qq, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = qq;  idFlmGrp = k; }\n    qq = q + vec3 (- s, - s, 0.);\n    d = PrCylDf (qq, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = qq;  idFlmGrp = k; }\n    qq = q + vec3 (- s, s, 0.);\n    d = PrCylDf (qq, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = qq;  idFlmGrp = k; }\n  }\n  return dMin;\n}\n\nfloat FlmRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = FlmDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat LsrDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  for (int k = 0; k < N_FLYER; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]);\n    q -= lsrCylPos;\n    d = PrCylDf (q, lsrCylRad, lsrCylLen);\n    if (d < dMin) { dMin = d;  qHitLsr = q;  idLsrGrp = 0; }\n    q.x += 2. * lsrCylPos.x;\n    d = PrCylDf (q, lsrCylRad, lsrCylLen);\n    if (d < dMin) { dMin = d;  qHitLsr = q;  idLsrGrp = 1; }\n  }\n  return dMin;\n}\n\nfloat LsrRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = LsrDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, wr, ws;\n  p.z -= 0.4 * fusLen;\n  q = p;\n  q.xy = Rot2D (q.xy, pi / 4.);\n  wr = 0.6 + q.z / fusLen;\n  wr = (0.14 - 0.1 * wr * wr) * fusLen;\n  q.z -= 0.3 * fusLen;\n  d = min (PrCapsDf (q * vec3 (0.7, 1., 0.7), wr, fusLen),\n     PrCapsDf (q * vec3 (1., 0.7, 0.7), wr, fusLen));\n  q.z += 0.3 * fusLen;\n  d = SmoothMin (d, PrCapsDf (q, 0.1 * fusLen, 0.5 * fusLen), 0.01 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idFus;  qHit = q; }\n  q = p;\n  q.xy = Rot2D (q.xy, 2. * pi *\n     (floor (4. * atan (q.y, - q.x) / (2. * pi)) + 0.5) / 4.);\n  q.xz -= vec2 (-0.55, -0.8) * fusLen;\n  ws = q.z / (0.4 * fusLen);\n  wr = ws - 0.1;\n  d = max (PrCylDf (q, (0.09 - 0.05 * wr * wr) * fusLen, 0.35 * fusLen),\n     - PrCylDf (q, 0.05 * fusLen, 0.36 * fusLen));\n  if (d < dMin) { dMin = d;  idObj = idEngO;  qHit = q; }\n  d = min (PrCylDf (q, (0.04 - 0.038 * ws * ws) * fusLen, 0.38 * fusLen),\n     PrCylDf (q - vec3 (0., 0., 0.03 * fusLen), 0.05 * fusLen, 0.28 * fusLen));\n  if (d < dMin) { dMin = d;  idObj = idEngI;  qHit = q; }\n  q.xz -= vec2 (0.3, -0.05) * fusLen;\n  q.xz = Rot2D (q.xz, 0.05 * pi);\n  d = PrFlatCylDf (q.zyx, 0.2, 0.01, 0.27) * fusLen;\n  if (d < dMin) { dMin = d;  idObj = idWng;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q.xz -= fusLen * vec2 (0.1, 0.2);\n  d = PrFlatCylDf (q.zyx, 0.03 * fusLen, 0.01 * fusLen, 0.1 * fusLen);\n  q.x -= 0.1 * fusLen;\n  d = min (d, PrCapsDf (q, 0.02 * fusLen, 0.1 * fusLen));\n  if (d < dMin) { dMin = d;  idObj = idCan;  qHit = q; }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar;\n  for (int k = 0; k < N_FLYER; k ++) {\n    dMin = FlyerDf (flyerMat[k] * (p - flyerPos[k]), dMin);\n  }\n  dMin *= 0.8;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 FlyerCol ()\n{\n  vec3 qq, col;\n  float spec, br;\n  spec = 1.;\n  qq = qHit / fusLen;\n  br = 0.4 + 0.6 * abs (cos (3. * tCur));\n  col = vec3 (0.9);\n  if (idObj == idFus) {\n    qq.xy = Rot2D (qq.xy, - pi / 4.);\n    if (qq.y > 0.) col *= 0.7;\n  } else if (idObj == idWng) {\n    if (abs (qq.x + 0.05) < 0.115)\n       col *= 1. - SmoothBump (-0.005, 0.005, 0.001, qq.z + 0.17);\n    if (qq.z < -0.17)\n       col *= 1. - SmoothBump (- 0.005, 0.005, 0.001,\n       abs (abs (qq.x + 0.05) - 0.26) - 0.15);\n\n  } else if (idObj == idEngO) {\n    if (qq.z > 0.34) {\n      col = vec3 (0.8, 0.8, 1.);\n    } else if (qq.z < -0.2 && length (qq.xy) < 0.05) {\n      col = vec3 (1., 0.3, 0.);\n      spec = 0.1;\n    }\n  } else if (idObj == idEngI) {\n    if (qq.z > 0.36) col = vec3 (1., 0., 0.);\n    else if (qq.z < 0.) {\n      col = vec3 (1., 0.3, 0.);\n      spec = 0.1;\n    } else {\n      col = vec3 (0.01);\n    }\n  } else if (idObj == idCan) {\n    col *= 0.5;\n  }\n  if (idObj == idFus) {\n    if (qq.z > 0.5) {\n      if (length (qq.xy) < 0.01) {\n        col = vec3 (0., 1., 0.) * br;\n        spec = -1.;\n      } else if (min (abs (qq.x), abs (qq.y)) > 0.01 && abs (qq.z - 0.52) > 0.007) {\n        col = vec3 (0.4, 0.2, 0.1);\n        spec = 0.2;\n      }\n    } else if (qq.z < -1.2 && length (qq.xy) < 0.03) {\n      col = vec3 (1., 0., 0.) * br;\n      spec = -1.;\n    }\n  }\n  return vec4 (col, spec);\n}\n\nfloat FlmAmp (vec3 p, vec3 rd)\n{\n  vec3 dp, q;\n  float g, s, fr, fz;\n  dp = (2. * flmCylRad / 30.) * rd;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    s = length (p.xy);\n    if (s > flmCylRad || g > 10.) break;\n    fr = max (1. - s / flmCylRad, 0.);\n    fz = 0.6 + 0.4 * p.z / flmCylLen;\n    q = 5. * p / fusLen;\n    g += fr * fz * Noisefv3 (vec3 (q.xy, q.z +\n       50. * (1. - 0.5 * fr) * (100. + tCur)));\n  }\n  return min (0.15 * g, 1.);\n}\n\nfloat LsrAmp (vec3 p, vec3 rd)\n{\n  float g;\n  g = smoothstep (0., 0.2, abs (dot (normalize (p.xy), - rd.xy))) *\n     smoothstep (0.3, 0.4, mod (23. * p.z / fusLen - 10. * tCur, 1.)) *\n     step (0.2, mod (0.7 * tCur, 1.));\n  return g;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, vn;\n  float dstHit, dstGrnd, dstFlm, aFlm, dstLsr, aLsr;\n  int idObjT;\n  bool isGrnd;\n  flmCylRad = 0.051 * fusLen;\n  flmCylLen = 0.4 * fusLen;\n  flmCylPos = vec3 (0., 0., -0.55 * fusLen - flmCylLen);\n  lsrCylRad = 0.005 * fusLen;\n  lsrCylLen = 5. * fusLen;\n  lsrCylPos = vec3 (0.2 * fusLen, 0., 1.12 * lsrCylLen);\n  dstFlm = FlmRay (ro, rd);\n  dstLsr = LsrRay (ro, rd);\n  dstHit = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  if (dstHit < dstFlm) dstFlm = dstFar;\n  if (dstHit < dstLsr) dstLsr = dstFar;\n  isGrnd = false;\n  if (dstHit < dstGrnd) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = FlyerCol ();\n    if (objCol.a >= 0.) {\n      objCol.rgb = 0.7 * objCol.rgb + 0.3 * SkyCol (ro, reflect (rd, vn));\n      col = objCol.rgb * (0.2 + 0.8 * (max (dot (vn, sunDir), 0.) +\n         objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n    } else col = objCol.rgb;\n  } else {\n    dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro += dstGrnd * rd;\n      isGrnd = true;\n    } else col = SkyCol (ro, rd);\n  }\n  if (isGrnd) {\n    vn = VaryNf (5. * ro, GrndNf (ro), 2.);\n    objCol = GrndCol (ro, vn);\n    col = objCol.rgb * (0.2 +\n       0.2 * max (dot (vn, vec3 (- sunDir.x, 0., - sunDir.z)), 0.) +\n       0.8 * max (dot (vn, sunDir), 0.) +\n       objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n  }\n  if (dstFlm < min (dstFar, dstHit)) {\n    aFlm = FlmAmp (qHitFlm, ((idFlmGrp == 0) ? flyerMat[0] : flyerMat[1]) * rd);\n    col = mix (col, mix (vec3 (1., 0.2, 0.2),\n       vec3 (1., 1., 0.7), 0.8 * aFlm), aFlm);\n  }\n  if (dstLsr < min (dstFar, dstHit)) {\n    aLsr = LsrAmp (qHitLsr, ((idLsrGrp == 0) ? flyerMat[0] : flyerMat[1]) * rd);\n    col = mix (col, vec3 (1., 1., 0.5), aLsr);\n  }\n  if (dstHit < dstFar)\n     col = mix (col, 0.7 * SkyBg (rd), clamp (pow (dstGrnd / dstFar, 4.), 0., 1.));\n   col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 g, w;\n  float f, c, s;\n  v = normalize (v);\n  g = cross (v, vec3 (0., 1., 0.));\n  if (g.y != 0.) {\n    g.y = 0.;\n    w = normalize (cross (g, v));\n  } else w = vec3 (0., 1., 0.);\n  f = v.z * a.x - v.x * a.z;\n  f = - clamp (30. * f, -0.3 * pi, 0.3 * pi);\n  c = cos (f);\n  s = sin (f);\n  return mat3 (c, - s, 0., s, c, 0., 0., 0., 1.) * AxToRMat (v, w);\n}\n\nvoid FlyerPM (float t, float vu)\n{\n  vec3 v, s;\n  t *= vFly;\n  s = sin (trkF * t);\n  flPos = vec3 (dot (trkA, s), 0., t);\n  v = vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n  if (vu > 0.) v.xz *= -1.;\n  flMat = EvalOri (v, vec3 (- dot (trkF * trkF * trkA, s), 0., 0.));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float tGap, el, az, zmFac, vuPeriod, dVu, lookDir, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 50.;\n  sunDir = normalize (vec3 (cos (0.031 * tCur), 2., sin (0.031 * tCur)));\n  trkF = vec3 (0.029, 0.021, 0.016);\n  trkA = vec3 (15., 23., 34.);\n  fusLen = 1.;\n  vuPeriod = 30.;\n  vFly = 15.;\n  tGap = 16. / vFly;\n  FlyerPM (tCur + 0.5 * tGap, 0.);  flyerPos[0] = flPos;  flyerMat[0] = flMat;\n  FlyerPM (tCur + 1.5 * tGap, 0.);  flyerPos[1] = flPos;  flyerMat[1] = flMat;\n  t = mod (tCur / vuPeriod, 1.);\n  lookDir = 2. * floor (2. * t) - 1.;\n  dVu = 2. * SmoothBump (0.25, 0.75, 0.1, t) - 1.;\n  FlyerPM (tCur + tGap * (1. + 0.7 * dVu), lookDir);\n  ro = flPos;\n  ro.y += 0.8 * fusLen;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {   \n    az = 2. * pi * mPtr.x;\n    el = pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 1.5;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  rd = rd * flMat;\n  dstFar = 250.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y),\n     vec3 (vx.z, vy.z, vz.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVXWG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 452, 495, 495, 568], [570, 570, 612, 612, 663], [665, 665, 724, 724, 828], [1188, 1188, 1210, 1210, 1298], [1300, 1300, 1332, 1332, 1712], [1714, 1714, 1737, 1737, 2085], [2087, 2087, 2121, 2121, 2628], [2630, 2630, 2652, 2652, 2806], [2808, 2808, 2839, 2839, 3329], [3331, 3331, 3353, 3353, 4126], [4128, 4128, 4161, 4161, 4370], [4372, 4372, 4394, 4394, 4796], [4798, 4798, 4831, 4831, 5040], [5042, 5042, 5078, 5078, 6593], [6595, 6595, 6617, 6617, 6793], [6795, 6795, 6828, 6828, 7037], [7039, 7039, 7060, 7060, 7273], [7275, 7275, 7293, 7293, 8658], [8660, 8660, 8692, 8692, 9117], [9119, 9119, 9151, 9151, 9355], [9357, 9357, 9392, 9392, 11367], [11369, 11369, 11400, 11400, 11761], [11763, 11763, 11797, 11797, 12039], [12041, 12041, 12097, 12097, 13418], [13541, 13541, 13565, 13565, 13612], [13614, 13614, 13639, 13639, 13838], [13840, 13840, 13865, 13865, 14209], [14211, 14211, 14232, 14232, 14371], [14373, 14373, 14402, 14402, 14614], [14616, 14616, 14655, 14655, 14878], [14880, 14880, 14914, 14914, 15081], [15083, 15083, 15113, 15113, 15171], [15173, 15173, 15218, 15218, 15321], [15323, 15323, 15368, 15368, 15406], [15408, 15408, 15465, 15465, 15548]], "test": "error"}
{"id": "XsyXzt", "name": "Circularly Inversed Tiling", "author": "Ultraviolet", "description": "inspired from http://images.math.cnrs.fr/Sur-l-inversion-conique.html\n", "tags": ["2d", "geometry", "tiling", "inversion"], "likes": 8, "viewed": 187, "published": "Public", "date": "1465920515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AA 4.0\n\nvec2 circularInvert(in vec2 p, in vec2 omega, in float k)\n{\n    vec2 diff = p-omega;\n    return k*diff/dot(diff, diff);\n}\n\nfloat checkerTexture(in vec2 pos)\n{\n    pos = .5-fract(pos);\n    return .5 + .5*sign(pos.x*pos.y);\n}\n\nfloat triTexture(in vec2 pos)\n{\n    vec2 pos2 = pos;\n    pos2.x = pos.x  - pos.y * 0.5;\n    pos2.y = pos.y / sqrt(3.0) / 0.5;\n    \n    float ind = 1.0;\n    \n    if(mod(pos2.x, 1.0) > 0.5)\n        ind *= -1.0;\n    \n    if(mod(pos2.y, 1.0) > 0.5)\n        ind *= -1.0;\n    \n    if(mod(pos2.y, 1.0) > 1.0 - mod(pos2.x, 1.0))\n        ind *= -1.0;\n    \n    ind = max(ind, 0.0);\n    \n    return ind;\n}\n\n\nfloat hexaTexture(vec2 uv)\n{\n    float t = 1.0;\n    \n    uv.y = uv.y * 0.866 + uv.x*0.5;\n    uv = mod(uv, vec2(3.0));\n    \n    if(uv.y>0.0 && uv.x > 0.0 && uv.y < uv.x+1.0 && uv.y > uv.x-1.0 && uv.y<2.0 && uv.x < 2.0)\n        t=0.0;\n    else if(uv.y > 1.0 && (uv.y < uv.x || uv.x < 1.0))\n        t = 0.5;\n    \n    return t;\n}\n\n\n\nfloat perlinTexture(in vec2 pos)\n{\n    const float N = 5.0;\n    \n    vec2 pos2 = pos;\n    \n    float ind = 0.0;\n    float ampl = 1.0;\n    \n    for(float n = 0.0; n < N; n ++)\n    {\n    \tind += texture(iChannel0, pos / iChannelResolution[0].x).x * ampl;\n    \n        ampl *= 0.5;\n        pos *= 2.0;\n    }\n    \n    return ind / (1.0 - pow(0.5, N+1.0)) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    for(float aaX=.0; aaX < AA; aaX++)\n    {\n    \tfor(float aaY=.0; aaY < AA; aaY++)\n        {\n            vec2 uv = (fragCoord.xy + vec2(aaX, aaY)/AA) / iResolution.y;\n            uv = uv - 0.5*vec2(iResolution.x/iResolution.y, 1.0);\n            //uv = uv * 10.0;\n\n            //vec2 omega = vec2(0.5)+0.5*vec2(cos(iTime), sin(iTime));\n            vec2 omega = iMouse.xy / iResolution.y;\n            omega = omega - 0.5*vec2(iResolution.x/iResolution.y, 1.0);\n            \n            if(any(lessThan(iMouse.xy, vec2(0.1))))\n            {\n                omega = 0.5*vec2(cos(0.5*iTime), 0.5*sin(iTime));\n            }\n\n            float k = 1.0;\n\n            uv = circularInvert(uv-omega, vec2(0.0), k);\n\t\t\tfragColor += vec4(vec3(checkerTexture(uv+omega*5.0)),1.0);\n\t\t\t//fragColor += vec4(vec3(triTexture(uv+omega*5.0)),1.0);\n\t\t\t//fragColor += vec4(vec3(perlinTexture(uv+omega*5.0)),1.0);\n\t\t\t//fragColor += vec4(vec3(hexaTexture(uv+omega*5.0)),1.0);\n\t\t\t//fragColor += texture( iChannel1, uv+omega*5.0);\n        }\n    }\n\tfragColor = fragColor / AA / AA;\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 76, 76, 138], [140, 140, 175, 175, 240], [242, 242, 273, 273, 636], [639, 639, 667, 667, 964], [968, 968, 1002, 1002, 1327], [1329, 1329, 1386, 1386, 2470]], "test": "error"}
