{"id": "4l2BWy", "name": "Raymarch Planets", "author": "shemit", "description": "planet marcher", "tags": ["raymarchplanet"], "likes": 0, "viewed": 82, "published": "Public", "date": "1517070969", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define marches 80\n\nvec4 sphereSDF(vec3 point) {\n    vec3 position[4];\n    position[0] = vec3(0.0, 0.0, 10.0);\n    position[1] = vec3(\n        sin(0.58 *(iTime + PI)) * 7.0, \n        0.23 * sin(iTime), \n        cos(0.58 *(iTime + PI)) * 7.0) + \n        vec3(0.0, 0.0, 10.0);\n    position[2] = vec3(sin(iTime + PI * 0.25) * 3.0, 0.0, cos(iTime + PI + 0.25) * 3.0) + \n        vec3(0.0, 0.0, 10.0);\n    position[3] = vec3(\n            sin(iTime + PI * 1.25) * 9.0, \n        \t2.0 * sin(iTime), \n            cos(iTime + PI + 1.25) * 9.0\n    \t) + vec3(0.0, 0.0, 10.0);\n        \n    \n    float radius[4];\n    radius[0] = 2.0;\n    radius[1] = 0.5;\n    radius[2] = 0.25;\n    radius[3] = 0.6;\n    \n    vec3 color[4];\n    color[0] = vec3(1.0, 0.0, 0.0);\n    color[1] = vec3(0.3, 0.8, 0.0);\n    color[2] = vec3(0.2, 0.7, 0.3);\n    color[3] = vec3(0.1, 0.3, 0.8);\n    \n    for (int i = 0; i < 4; i++) {\n        vec3 normal = point - position[i];\n        vec3 lightDirection = normalize(vec3(sin(iTime), 0.5, cos(iTime)));\n        if (length(normal) < radius[i]) {\n            float light = dot(normalize(normal), lightDirection);\n            return vec4(light * color[i], 1.0);\n            //return vec4(color[i], 1.0);\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 getRay(float fov, vec2 uv) {\n    vec2 offset = uv - vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    vec3 direction = normalize(vec3(offset, 0.0) + vec3(0.0, 0.0, 1.0));\n    return direction;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec3 direction = getRay(PI / 2.0, uv);\n    \n    //int marches = 200;\n    float marchDistance = 0.15;\n    float totalDistance = 0.0;\n    vec3 position = vec3(0.0, 1.0, 0.0);\n    \n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < marches; i++) {\n        totalDistance += marchDistance;\n        vec3 pt =  totalDistance * direction + position;\n        vec4 color = sphereSDF(pt);\n        if (color.w > 0.5) {\n            finalColor = color.xyz;\n            break;\n        }\n    }\n    \n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2BWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 67, 67, 1280], [1282, 1282, 1302, 1302, 1374], [1376, 1376, 1409, 1409, 1577], [1579, 1579, 1636, 1636, 2218]], "test": "untested"}
{"id": "4l2BzK", "name": "First shader: raytracer", "author": "Axioplase", "description": "Basic raytracer. Next step will be reflections, I guess?", "tags": ["raytracer"], "likes": 0, "viewed": 70, "published": "Public", "date": "1516515125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct sphere_t {\n    int id;\n    vec3 center;\n    float radius;\n    vec3 colour;\n};\n\nstruct hit_t {\n    vec3 hitPos;\n    int sphere_id;\n};\n\nvec3 r = vec3(.5,0.,0.);\nvec3 g = vec3(0.,.5,0.);\nvec3 b = vec3(0.,0.,.5);\nsphere_t spheres[4];\nfloat pi = 3.14159265;\n\nvec3 showLightSource(in vec3 orig, in vec3 direction, in vec3 source) {\n    return vec3(smoothstep(0.2, .9, 0.051/length(cross(source-orig, direction))/length(direction)));\n}\n\nvec3 normalAtHitPoint(in hit_t hit) {\n\tsphere_t s = spheres[hit.sphere_id];\n\treturn normalize(hit.hitPos - s.center);\n}\n\nbool inSphere(in vec3 pos, in int sphere_id) {\n    sphere_t sphere = spheres[sphere_id];\n    return (length(pos - sphere.center) <= sphere.radius);\n}\n\nvoid castRay(in vec3 orig, in vec3 direction, in int sphere_id, inout hit_t store) {\n    sphere_t sphere = spheres[sphere_id];\n    \n    vec3 l = sphere.center - orig;\n    float ta = dot(l, direction);\n    \n    if (ta <= 0.) { //sphere.radius) {\n        return; // we're inside the sphere, or it's behind us. Let's ignore.\n    }\n    \n    float d = sqrt(dot(l,l) - ta*ta);\n        \n    if (d >= sphere.radius) {\n        return; // no intersection\n    }\n    \n    vec3 proj = orig + direction*ta; // This is the projection of center on ray.\n    \n    float distFromProjSoThatOnSphere = sqrt(sphere.radius * sphere.radius - d*d);\n    vec3 vectorsToIntersections = direction*distFromProjSoThatOnSphere;\n    vec3 intersection1 = proj - vectorsToIntersections; // closer\n    vec3 intersection2 = proj + vectorsToIntersections;\n    vec3 bestHit;\n    // just in case\n    if(length(intersection1 - orig) <= length(intersection2 - orig)) {\n    \tbestHit = intersection1;\n    } else {\n        bestHit = intersection2;\n    }\n\n    float distanceToOrigin = length(bestHit - orig);\n    if (distanceToOrigin < length(store.hitPos - orig)) {\n        store.sphere_id = sphere_id;\n        store.hitPos = bestHit;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5; // center\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor.w = 1.;\n    \n    vec3 lightSource = vec3(1.5*cos(iTime/3. + pi/3.), 1.5*sin(iTime/2. + pi/3.),10.+4.*sin(iTime));\n    vec3 camera = vec3(4.*cos(iTime), 0., 4.*sin(iTime));\n    vec3 lookAt = vec3(1.2*cos(iTime/3. + pi/3.), 1.2*sin(iTime/2. + pi/3.), 10.+3.5*sin(iTime));\n    vec3 f = normalize(lookAt - camera);\n    vec3 r = cross(vec3(0.,1.,0.), f);\n    vec3 u = cross(f, r);\n    //vec3 direction = normalize(vec3(uv.x, uv.y, 0.) - camera);\n    float zoom = 2.0;\n    vec3 center = camera + f * zoom;\n    vec3 i = center + uv.x*r + uv.y*u;\n    vec3 direction = normalize(i - camera);\n\n    // Show a light. It'll be masked if behind a sphere.\n    fragColor.xyz = showLightSource(camera, direction, lightSource);\n\n    spheres[0].radius=.5;\n    spheres[0].colour=r;\n    spheres[0].center=vec3(cos(iTime), sin(iTime), 10.0);\n    spheres[0].id = 0;\n\n    spheres[1].radius=.4;\n    spheres[1].colour=g;\n    spheres[1].center=vec3(cos(iTime + 2.*pi/3.), sin(iTime + 2.*pi/3.), 11.0);\n    spheres[1].id = 1;\n    \n    spheres[2].radius=.6;\n    spheres[2].colour=b;\n    spheres[2].center=vec3(cos(iTime + 4.*pi/3.), sin(iTime + 4.*pi/3.), 12.0);\n    spheres[2].id = 2;\n\n    spheres[3].radius=5.;\n    spheres[3].colour=vec3(1.);\n    spheres[3].center=vec3(0., 0., 24.5);\n    spheres[3].id = 3;\n\n\n    // If the light is in another sphere, then all is dark\n    for (int i = 0; i < 4; i++) {\n        if (inSphere(lightSource, i)) {\n            fragColor = vec4(0.);\n        }\n    }\n    \n    // render all spheres\n    hit_t closest;\n    closest.hitPos = vec3(1e3); // far away\n    closest.sphere_id = -1; // not_found\n    for (int i = 0; i < 4; i++) {\n        castRay(camera, direction, i, closest);\n    }\n    \n    // there was no hit, so return the backgroud\n    if (closest.sphere_id == -1) {\n       return;\n    }\n\n    // there was a hit\n    sphere_t s = spheres[closest.sphere_id];\n    vec3 hitPos = closest.hitPos;\n    vec3 normal = normalAtHitPoint(closest);\n\n    // add lighting\n    // We'll cast a ray from the intersection point to the light.\n    vec3 newDirection = normalize(lightSource - hitPos);\n    hit_t lightHit;\n    lightHit.hitPos = vec3(1e3); // there's no null value to initialize with\n    lightHit.sphere_id = -1; // idem\n    \n    for (int i = 0; i < 4; i++) {\n   \n        // avoid hitting yourself\n        if (i == s.id) {\n            continue;\n        }\n        \n        // If the light is in another sphere, then all is dark\n        if (inSphere(lightSource, i)) {\n            fragColor = vec4(0.);\n            return;\n        }\n\n        castRay(hitPos, newDirection, i, lightHit);\n    }\n\n    float dist = length(hitPos - lightSource);\n    vec3 coul = 2.*dot(newDirection, normal)*s.colour/(dist);\n    // if there was nothing between the intersection and the light source, add some light!\n        if (lightHit.sphere_id == -1) {\n\t    fragColor.xyz += coul;\n    } else {\n        // we hit something in front.\n        if (dot(lightSource - hitPos, lightHit.hitPos - hitPos) >= 0. ) {\n            // light is closer than new hit point\n            if (length(lightSource - hitPos) < length(lightHit.hitPos - hitPos)) {\n                fragColor.xyz = coul;    \n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2BzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 332, 332, 435], [437, 437, 474, 474, 556], [558, 558, 604, 604, 707], [709, 709, 793, 793, 1906], [1908, 1908, 1965, 1965, 5288]], "test": "untested"}
{"id": "4l2fDy", "name": "EYE", "author": "Hoyong", "description": "A simple eye", "tags": ["2d", "beginner", "eye"], "likes": 1, "viewed": 134, "published": "Public", "date": "1517062071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653\n\nvec4 rect(vec2 uv, vec2 leftBottom, vec2 rightTop, vec3 col)\n{\n    if(uv.x <= rightTop.x && uv.y <= rightTop.y)\n    {\n    \tif(uv.x >= leftBottom.x && uv.y >= leftBottom.y)\n    \t{\n        \treturn vec4(col,1.0);\n        }\n    }else{return vec4(.0);}\n}\n\nvec4 Circle( vec2 uv, vec2 pos, float radius, vec3 col)\n{\n    return vec4(col,step(length(uv - pos), radius)); // 1~0\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float xMax = iResolution.x / iResolution.y;\n\n    vec4 final;\n    final = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n    float eyelid_spd = 4.5;\n    float eyeballDir = PI * 2.0 * sin(iTime*0.25);\n    vec2 eye_center = vec2(xMax*0.5,0.5);\n    vec2 eyeballPos = vec2(cos(eyeballDir), sin(eyeballDir)) * 0.1;\n    \n    float LightRad = 0.8;\n    vec4 Light = Circle( uv, eye_center, LightRad, vec3(1.0));\n    Light.a *= 1.0 - length( uv - eye_center )/LightRad;\n    \n    final.xyz = mix(final.xyz, Light.xyz, Light.a);\n    \n    float detail = xMax/30.0;\n    for ( float i = 0.0; i <= xMax; i += detail )\n    {\n        float WIDTH = detail;\n        float HEIGHT = sin( iTime*eyelid_spd + abs(eye_center.x-i))* 0.25*(eye_center.x-abs((eye_center.x)-i));\n        \n        vec2 Pos = vec2(i,0.5);\n        vec2 LB = Pos - vec2(WIDTH,HEIGHT);\n        vec2 RT = Pos + vec2(WIDTH,HEIGHT);\n        \n        vec4 rectangle = rect(uv,LB,RT,vec3(1.0));\n        vec4 circle = Circle(uv,eye_center+eyeballPos,0.25,vec3(0.5));\n\t\tvec4 inner_circle = Circle(uv,eye_center+eyeballPos*1.25,0.08+clamp( (1.0 + cos(iTime*0.75)) * 0.5, 0.0, 1.0 )*0.1,vec3(0.3));\n        \n        circle.xyz = mix(circle.xyz,inner_circle.xyz,inner_circle.a);\n       \trectangle.xyz = mix(rectangle.xyz,circle.xyz,circle.a);\n        final.xyz = mix(final.xyz,rectangle.xyz,rectangle.a);\n    }\n    \n\tfragColor = final;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2fDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 86, 86, 273], [275, 275, 332, 332, 394], [396, 396, 453, 453, 1862]], "test": "untested"}
{"id": "4l2fRW", "name": "graydrago_raytracer", "author": "graydrago", "description": "My first ray tracer =)", "tags": ["raytracer"], "likes": 1, "viewed": 96, "published": "Public", "date": "1515178911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* My first raytracer =)\n * \n * TODO\n * - add shadows\n * - add anti-aliasing\n * - add good sky\n * - add good ground\n */\nprecision mediump int;\nprecision mediump float;\nprecision lowp sampler2D;\nprecision lowp samplerCube;\n\nconst float EPS = 0.000001;\nconst vec3 LIGHT_POS = vec3(1000, 1000, 1000);\nconst vec3 LIGHT_COLOR = vec3(1, 1, 1);\nconst float gamma = 2.2;\nvec3 nearest_hit;\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n    \n    \nstruct Plane {\n    vec3 p;\n    vec3 n;\n};\n    \n\nstruct Sphere {\n    vec3 c;\n    float r;\n};\n    \n\nstruct Light {\n    vec3 Ka;\n    vec3 Kd;\n    vec3 Ks;\n};\n    \n\nmat4 look_at(vec3 pos, vec3 target) {\n    vec3 tmp_up = vec3(0, 1, 0);\n    vec3 forward = normalize(pos - target);\n    vec3 right = normalize(cross(tmp_up, forward));\n    vec3 up = normalize(cross(forward, right));\n    return mat4(vec4(right, 0.0), vec4(up, 0.0), vec4(forward, 0.0), vec4(pos, 1.0));\n}\n\nmat3 normal_matrix(mat4 eye) {\n    mat3 normal_m = mat3(eye);\n    normal_m = inverse(normal_m);\n    normal_m = transpose(normal_m);\n    return normal_m;\n}\n\nbool quadratic(float a, float b, float c, out float x0, out float x1) {\n    float d = b*b - 4.0 * a * c;\n    if (d < 0.0) return false;\n    if (d >= 0.0 && d < EPS) {\n        x0 = x1 = -b / (2.0 * a);\n    } else {\n        float den = 2.0 * a;\n        x0 = (-b + sqrt(d)) / den;\n        x1 = (-b - sqrt(d)) / den;\n    }\n    return true;\n}\n    \n    \nbool hit_ray_plane(Ray r, Plane p, out vec3 hit) {\n    float denom = dot(p.n, r.d);\n    if (abs(denom) > EPS) {\n        float t = dot(p.p - r.o, p.n) / denom;\n        if (t >= EPS) {\n            hit = r.o + r.d * t;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool hit_ray_plane(Ray r, Plane p) {\n    vec3 hit;\n    return hit_ray_plane(r, p, hit);\n}\n\n\nbool hit_sphere(Ray r, Sphere s, out vec3 hit, out vec3 n) {\n    vec3 L = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(r.d, L);\n    float c = dot(L, L) - s.r * s.r;\n    float t0;\n    float t1;\n    if (quadratic(a, b, c, t0, t1)) {\n        if (t1 < t0) t0 = t1;\n        \n        if (t0 > 0.0) {\n            hit = r.o + t0 * r.d;\n            n = normalize(hit - s.c);\n            return true;\n        }\n    }\n    return false;\n}\n\n\nvec3 ads_lighting(Light l, Ray r, vec3 hit, vec3 normal) {\n\tfloat d = max(dot(normalize(LIGHT_POS - hit), normal), 0.0);\n\tfloat s = 0.0;\n\tif (d > 0.0) {\n\t\tvec3 refl = reflect(normalize(LIGHT_POS - hit), normal);\n\t\ts = pow(max(dot(refl, normalize(hit - r.o)), 0.0), 32.0);\n\t}\n\treturn l.Ka + d*l.Kd + s*l.Ks;\n}\n\n\nvoid save_nearest_hit(Ray r, vec3 hit) {\n    if (distance(r.o, hit) < distance(r.o, nearest_hit)) {\n        nearest_hit = hit;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init\n    // I should add relative coordinates support, but I like absolute coordinates for this scene.\n    const float cam_speed = 100.0;\n    float cam_offset = iTime * cam_speed;\n    float screen_x = fragCoord.x - iResolution.x * 0.5;\n    float screen_y = fragCoord.y - iResolution.y * 0.5;\n    vec3 ray_o = vec3(0, 300, -700);\n    vec3 ray_d = normalize(vec3(screen_x, screen_y + 250.0, 0) - ray_o);\n    mat4 eye = look_at(vec3(cos(iTime * 0.2), 0.0, sin(iTime * 0.2)), vec3(0.0, 0.0, 0.0));\n    mat3 normal_m = normal_matrix(eye);\n    \n    // Ray\n    Ray r = Ray(ray_o, ray_d);\n    r.o = vec3(eye * vec4(r.o, 1.0));\n    r.d = normalize(normal_m * r.d);\n    \n    // Ground\n    Plane p = Plane(vec3(0, 0, 0), normalize(vec3(0, 1, 0)));\n    vec2 t_size = vec2(textureSize(iChannel0, 0));\n    vec3 hit;\n    if (hit_ray_plane(r, p, hit)) {\n        save_nearest_hit(r, hit);\n        fragColor = vec4(pow(\n            texture(\n            \tiChannel0,\n            \tvec2(hit.x/float(t_size.x), hit.z/float(t_size.y))\n        \t).rgb,\n        \tvec3(gamma)\n        ), 1.0);\n    }\n    \n    // Sky\n    p = Plane(vec3(0, 1000, 0), normalize(vec3(0, -1, 0)));\n    t_size = vec2(textureSize(iChannel1, 0));\n    if (hit_ray_plane(r, p, hit)) {\n\t\tsave_nearest_hit(r, hit);\n        fragColor = vec4(pow(\n            texture(\n                iChannel1,\n                vec2(hit.x/(t_size.x*500.0), hit.z/(t_size.y*500.0))\n            ).rgb,\n            vec3(gamma)\n        ), 1.0);\n        fragColor = vec4(fragColor.xxx + 1.0, 1.0) * vec4(0.5, 0.5, 1, 1);\n    }\n    \n    // Spheres\n    Sphere s;\n    vec3 normal;\n    float dist = 2000.0;\n    Light l = Light(\n\t\tvec3(0.01, 0.0, 0.0),\n\t\tvec3(0.7, 0.0, 0.0),\n\t\tvec3(1.0, 1.0, 1.0)\n    );\n    for (int i = -2; i <= 2; i++) {\n\t\tfor (int j = -2; j <= 2; j++) {\n        \ts = Sphere(vec3(float(i) * 250.0, 250.0, float(j) * 250.0), 40.0);\n    \t\tif (hit_sphere(r, s, hit, normal)) {\n            \tfloat tmp_dist = distance(r.o, hit);\n            \tif (tmp_dist > dist) continue;\n            \tdist = tmp_dist;\n        \t\tfragColor = vec4(ads_lighting(l, r, hit, normal) , 1);\n\t\t\t\tsave_nearest_hit(r, hit);\n    \t\t}\n    \t}\n    }\n    \n    // Fog (a try to implement aerial perspective)\n    //if (fragCoord.x > iResolution.x/2.0) {\n    \tfloat fog_factor = (900.0 - distance(nearest_hit, r.o)) / 200.0;\n    \tfog_factor = clamp(fog_factor, 0.0, 1.0);\n        vec3 color = mix(vec3(0.2, 0.2, 0.3), fragColor.rgb, fog_factor);\n    \tfragColor = vec4(pow(color, vec3(1.0/gamma)), 1.0);\n    //}\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2fRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 593, 630, 630, 895], [897, 897, 927, 927, 1051], [1053, 1053, 1124, 1124, 1390], [1401, 1401, 1451, 1451, 1677], [1680, 1680, 1716, 1716, 1769], [1772, 1772, 1832, 1832, 2217], [2220, 2220, 2278, 2278, 2528], [2531, 2531, 2571, 2571, 2665], [2668, 2668, 2725, 2835, 5238]], "test": "untested"}
{"id": "4l2fRy", "name": "Counting Visualization", "author": "Muninn", "description": "A visualization of counting in any base.\n\nA generalization of https://www.shadertoy.com/view/lssXDs", "tags": ["2d", "fractal"], "likes": 1, "viewed": 104, "published": "Public", "date": "1516319062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// the size of each dot, in UV space\n#define BIT_SIZE 0.0125\n\n// used when controlling scale with the mouse\n#define SCALE_MIN BIT_SIZE / 2.0\n#define SCALE_MAX 0.0625\n\n// Base for number system\n#define BASE 5.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 R = iResolution.xy;\n    float scale = BIT_SIZE;\n    \n    if( iMouse.z > 0. ) scale = iMouse.y / R.y * (SCALE_MAX - SCALE_MIN) + SCALE_MIN;\n \n    fragCoord /= R.y;\n\n    fragCoord.x = max(0., fragCoord.x + iTime - R.x / R.y);\n    fragCoord.y -= 0.5;\n    \n    fragCoord /= scale;\n\tvec2 F = floor(fragCoord), \n         r = fract(fragCoord) - .5;\n    \n    fragColor = vec4((mod(floor(F.x/floor(pow(BASE, F.y))), BASE) / (BASE-1.))\n              * smoothstep(.6,.3,length(r))\n             );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2fRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 211, 268, 268, 764]], "test": "untested"}
{"id": "4l2fz1", "name": "Thinking with curvature, pt2", "author": "mmerchante", "description": "In contrast with pt1, if we just use curvature for the normal estimation, we lose interesting silhouettes but can make shading more interesting. Note that the normal estimation epsilon is bigger to smooth the result a bit.", "tags": ["raymarching", "modeling", "curvature", "crystal"], "likes": 8, "viewed": 344, "published": "Public", "date": "1514783684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Uncomment these defines to switch implementation\n\n//#define NORMAL_CURVATURE_NONE\n\n// BASIC CURVATURE: We only add the curvature to the sdf when evaluating the normal\n#define NORMAL_CURVATURE_BASIC\n\n// NORMAL OFFSETTED CURVATURE: Before evaluating the curvature, we move outside a bit on the direction of the normal\n//#define NORMAL_CURVATURE_NORMAL_OFFSET\n\n// SDF WIDTH: Same as CURVATURE, but the width of the curvature evaluation depends on the sdf of the scene\n//#define NORMAL_CURVATURE_SDF_WIDTH\n\n// Curvature is just \"added\" to the resulting normal. This is independent of the previous defines\n#define NORMAL_CURVATURE_ADD\n\n\n// If you don't like the rendering, uncomment this\n//#define DIFFUSE_ONLY\n\n// How vertical/horizontal the crystal is :)\n#define CRYSTAL_SCALE .75\n#define CRYSTAL_VERTICAL_ANISOTROPY 1.2\n\n// ---------------------------------------------------------\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define MAX_STEPS 75\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define MAX_DISTANCE 15.0\n#define MIN_DISTANCE .5\n#define EPSILON .01\n\n#define MATERIAL_NONE -1\n#define MATERIAL_CRYSTAL 1\n\n// ---------------------------------------------------------\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n} \n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// hg\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\n// iq\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return saturate(a + b * cos(6.28318 * (c * t + d)));\n}\n\n// iq\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// iq\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// iq\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\n// iq\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.yz)-t.x,p.x);\n  return length8(q)-t.y;\n}\n\n// iq\nvec2 opU(vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// iq\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\n// iq\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\n// iq\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n// iq\nmat3x3 rotationAxisAngle( const vec3 v, float a )\n{\n    float si = sin( a );\n    float co = cos( a );\n    float ic = 1.0f - co;\n\n    return mat3x3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,\n                   v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,\n                   v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );\n}\n\n// iq\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat longTailImpulse(float k, float x, float c)\n{\n    return mix(impulse(k, x), impulse(k, (x+1.0/k) * c), step(1.0/k, x));\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random(inout uint seed)\n{\n\tseed = hash(seed);\n\treturn floatConstruct(seed);\n}\n\nfloat hash31(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\n// ---------------------------------------------------------\n\nfloat sdf_simple(vec3 p)\n{\n    float d = 0.0;\n\tuint seed = uint(14041956 + int(iTime * .5));\n    \n    float sides = 8.0;\n    float sideAmpl = 1.0 / sides;\n\n    // Side planes\n\tfor(float i = 0.0; i < sides; i++)\n\t{\n        float angle = mix(i, i+1.0, random(seed)) * sideAmpl * PI * 2.0;\n        float verticalOffset = random(seed) * 2.0 - 1.0;\n        vec3 offset = vec3(cos(angle), verticalOffset * .25, sin(angle));\n\t\t\n\t\td = max(d, dot(p - offset * CRYSTAL_SCALE / CRYSTAL_VERTICAL_ANISOTROPY, normalize(offset)));\n\t}\n    \n    // Cap planes\n\tfor(float i = 0.0; i < sides; i++)\n\t{\n        float angle = mix(i, i+1.0, random(seed)) * sideAmpl * PI * 2.0;\n        float verticalOffset = random(seed) * 2.0 - 1.0;\n        vec3 offset = vec3(cos(angle), verticalOffset * 3.0, sin(angle));\n\t\t\n\t\td = max(d, dot(p - offset * CRYSTAL_SCALE * CRYSTAL_VERTICAL_ANISOTROPY, normalize(offset)));\n\t}\n    \n\treturn d;\n}\n\nfloat curv_modifier(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;   \n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return (.25/e.y) * (t1 + t2 + t3 + t4 - 4.0 * sdf_simple(p));\n}\n\nvec3 sdfNormal_simple(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_simple(p + eps.xzz) - sdf_simple(p + eps.yzz);\n\tfloat dY = sdf_simple(p + eps.zxz) - sdf_simple(p + eps.zyz);\n\tfloat dZ = sdf_simple(p + eps.zzx) - sdf_simple(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nfloat sdf_modifier(vec3 p)\n{\n#ifdef NORMAL_CURVATURE_BASIC\n    float d = curv_modifier(p, .15) * .2;\n#elif defined(NORMAL_CURVATURE_NONE)\n    float d = 0.0;\n#elif defined(NORMAL_CURVATURE_NORMAL_OFFSET)\n    vec3 normal = sdfNormal_simple(p, EPSILON * 4.0);\n    float d = curv_modifier(p + normal * .1, .15) * .2;\n#elif defined(NORMAL_CURVATURE_SDF_WIDTH)\n   \tfloat w = sdf_simple(p);\n    vec3 normal = sdfNormal_simple(p, EPSILON * 4.0);\n   \tfloat d = curv_modifier(p + normal * .1, .15 + w) * .2; \n#endif\n    \n    return d * -.95;\n}\n\nfloat sdf_complex(vec3 p)\n{\n    return sdf_simple(p) + sdf_modifier(p);\n}\n\n// https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;\n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return .25/e.y*(t1 + t2 + t3 + t4 - 4.0 * sdf_simple(p));\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_complex(p + eps.xzz) - sdf_complex(p + eps.yzz);\n\tfloat dY = sdf_complex(p + eps.zxz) - sdf_complex(p + eps.zyz);\n\tfloat dZ = sdf_complex(p + eps.zzx) - sdf_complex(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nint SampleMaterial(vec3 p)\n{\n    // We only have one material\n    return MATERIAL_CRYSTAL;\n}\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 3.0 / zoom;\n    float time = iTime;\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 1.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward + left * uv.x * zoom - up * uv.y * zoom);\n        \n    return cam;\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.materialID = MATERIAL_NONE;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; j++)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf_simple(p) * .9;\n        //outData.density += sdfDensity(p);\n        \n\t\tif(outData.sdf < EPSILON)\n            break;        \n\n\t\toutData.totalDistance += outData.sdf;\n        \n        if(outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    if(outData.sdf < EPSILON)\n\t\toutData.materialID = SampleMaterial(camera.origin + camera.direction * outData.totalDistance);\n    \n    return outData;\n}\n\nvec3 gradient(float factor)\n{\n\tvec3 a = vec3(0.478, 0.500, 0.500);\n\tvec3 b = vec3(0.500);\n\tvec3 c = vec3(0.688, 0.748, 0.748);\n\tvec3 d = vec3(0.318, 0.588, 0.908);\n\n\treturn palette(factor, a, b, c, d);\n}\n\nvec3 Render(Camera camera, Intersection isect)\n{\n    if(isect.materialID > 0)\n    {        \n        vec3 p = camera.origin + camera.direction * isect.totalDistance;\n        vec3 normal = sdfNormal(p, EPSILON * 10.0);\n        \n#ifdef NORMAL_CURVATURE_ADD\n        float c = curv(p, .15);\n        normal = normalize(normal - vec3(c));\n#endif\n        \n        float diffuse = dot(normal, -camera.direction);\n        \n#ifdef DIFFUSE_ONLY\n        return vec3(diffuse * .5 + .5);\n#else\n        return gradient(diffuse);\n#endif\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n        \n    Camera camera = GetCamera(uv, .5);\n    Intersection isect = Raymarch(camera);    \n    vec3 color = Render(camera, isect);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2fz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1241, 1247, 1279, 1279, 1321], [1323, 1329, 1349, 1349, 1384], [1386, 1392, 1420, 1420, 1501], [1504, 1510, 1530, 1530, 1555], [1557, 1563, 1597, 1597, 1623], [1625, 1625, 1654, 1654, 1735], [1737, 1743, 1785, 1785, 1879], [1881, 1887, 1942, 1942, 2028], [2030, 2036, 2092, 2092, 2151], [2153, 2159, 2184, 2184, 2221], [2223, 2229, 2254, 2254, 2312], [2314, 2320, 2345, 2345, 2410], [2412, 2418, 2451, 2451, 2516], [2518, 2524, 2559, 2559, 2626], [2628, 2634, 2663, 2663, 2699], [2701, 2707, 2743, 2743, 2841], [2843, 2849, 2885, 2885, 2983], [2985, 2991, 3027, 3027, 3125], [3127, 3133, 3184, 3184, 3522], [3524, 3530, 3565, 3565, 3611], [3613, 3613, 3663, 3663, 3739], [3741, 3812, 3833, 3833, 3964], [3966, 4124, 4156, 4156, 4576], [4578, 4578, 4609, 4609, 4661], [4663, 4663, 4686, 4686, 4780], [5007, 5069, 5095, 5095, 5974], [5976, 5976, 6020, 6020, 6265], [6267, 6267, 6313, 6313, 6591], [6593, 6593, 6621, 6621, 7126], [7128, 7128, 7155, 7155, 7201], [7203, 7244, 7279, 7279, 7517], [7519, 7519, 7558, 7558, 7842], [7844, 7844, 7872, 7905, 7936], [7938, 7938, 7977, 7977, 8458], [8460, 8460, 8498, 8498, 9207], [9209, 9209, 9238, 9238, 9412], [9414, 9414, 9462, 9462, 9968], [9970, 9970, 10027, 10027, 10264]], "test": "untested"}
{"id": "4l2fz3", "name": "newbie needs help...", "author": "jcyuan", "description": "I'm new on shader writing, I need basic tutorials to improve my skill e.g. to understand how this effect works, I can't figure out the main theories of the code of this effect, can anyone help to comment out?", "tags": ["wave", "effect"], "likes": 13, "viewed": 417, "published": "Public", "date": "1516724756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// original author: Dave_Hoskins, https://www.shadertoy.com/view/MdlXz8\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5 + 23.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 p = mod(uv * TAU, TAU) - 250.0;\n    vec2 i = vec2(p);\n    float c = 1.0;\n    float inten = 0.005;\n\n    for (int n = 0; n < MAX_ITER; n++) {\n        float t = time * (1.0 - (3.5 / float(n + 1)));\n        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n        c += 1.0 / length(vec2(p.x / (sin(i.x + t) / inten), p.y / (cos(i.y + t) / inten)));\n    }\n\n    c /= float(MAX_ITER);\n    c = 1.17-pow(c, 1.4);\n    vec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n\n    fragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2fz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 119, 176, 176, 836]], "test": "untested"}
{"id": "4lBBDc", "name": "Fractal (z^p+c)", "author": "Txoka", "description": "You can find some beautifull points with your mouse.\nChange p value for other powers.\nIn some points you can see cool raimbow spirals.", "tags": ["fractal", "complex", "power"], "likes": 6, "viewed": 570, "published": "Public API", "date": "1517348567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//##### power #####\n#define p -2.\n//try with: -10,-14,2,10,-1.9,-1\n\n\n//##### zoom options #####\n#define center vec2(0)\n//vec2(.6114385,0)\n#define zoom 1.\n//iTime*iTime*iTime*10.\n\n\n//##### palette options #####\n#define palette\n#define palettefunc vec3(cos(t*2.)/2.+0.5,sin(t*2.)/2.+0.5,1.-cos(t*2.)/2.-0.5)\n\n\n//##### animation options #####\n#define animate\n#define animation sin(t)/600.+1.\n\n\n\nfloat animation_(float t){\n\t#ifdef animate\n    return animation;\n    #else\n    return 1.;\n    #endif\n}\n\nvec3 palette_(float t){\n\t#ifdef palette\n    t=1.-t;\n    t*=10.;\n\treturn palettefunc;\n    #else\n    return vec3(t);\n    #endif\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    const float mi = 256.;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 c = vec2((mouse.x - .5) * 3., 5.*pow(1.5*(mouse.y - .5), 3.));\n    \n\tif(iMouse.z<0.||iMouse.x+iMouse.y==0.)c = vec2((2.41/17.*(animation_(iTime*1.1)) - .5) * 3., 5.*pow(1.5*(7.2/10.*(animation_(iTime)) - .5), 3.));\n\n    float lim = 8.0;\n    \n    vec2 z = fragCoord.xy / iResolution.xy*2.-1.;\n\tz.x*=iResolution.x/iResolution.y;\n\tz*=1./(zoom);\n    z+=center;\n    \n\t\n\tfloat i;\n    for(i=0.;i<mi;i++){\n\t\tfloat l=sqrt(z.y*z.y+z.x*z.x);\n\t\tl=pow(l,p);\n\t\tfloat ang=atan(z.y,z.x);\n      \tz=vec2(cos(ang*(p))*l,sin(ang*(p))*l)+c;\n        \n        if(dot(z,z)>lim)break;\n    }\n    \n\tfragColor = vec4(palette_(i/mi),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 392, 418, 418, 494], [496, 496, 519, 519, 623], [624, 624, 680, 680, 1380]], "test": "untested"}
{"id": "4lBBWw", "name": "Road01", "author": "nslottow", "description": "Had the urge to make a little road. Hacked this off of my previous raymarching experiment & iq's tutorial.", "tags": ["raymarching", "road"], "likes": 5, "viewed": 517, "published": "Public API", "date": "1515914803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float speed = 7.0;\n\n\n\n\nfloat map_z(float z)\n{\n    return z + iTime * speed;\n}\nfloat get_x(vec3 p)\n{\n    return p.x + 1.2 * cos(map_z(p.z) * 0.1);\n}\n\nfloat f(float x, float z)\n{\n    return 0.5 * sin(map_z(z) * 0.2);\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 0.001;\n    const float maxt = 50.0;\n    const float dt = 1.0;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        float h = f(p.x, p.z);\n        if (p.y < h)\n        {\n            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n    }\n    \n    return false;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = 0.02;\n    vec3 n = vec3(\n        f(p.x - eps, p.z) - f(p.x + eps, p.z),\n        2.0 * eps,\n        f(p.x, p.z - eps) - f(p.x, p.z + eps));\n    return normalize(n);  \n}\n\nvec3 getShading(vec3 p, vec3 n)\n{\n    return dot(n, vec3(0.0, 1.0, 0.0)) * vec3(0.2, 0.7, 0.3);\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro + rd * t;\n    vec3 p1 = vec3(p.xy, map_z(p.z));\n    float z = p1.z;\n    \n    vec3 n = getNormal(p1);\n    vec3 s = getShading(p1, n);\n    \n    float waver = abs(get_x(p));\n    float midline = step(0.7, waver);\n    float mix_road = 1.0 - midline;\n    float mix_line = (1.0 - smoothstep(0.0, 0.0025, pow(waver, 2.5))) * step(0.7, mod(z, 1.5));\n    s = mix(s, vec3(0.2, -0.1, 0.2), mix_road * 0.7);\n    s = mix(s, vec3(0.7, 0.7, 0.7), mix_line * 0.7);\n    return s;\n}\n\nvec3 skyColor(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    return vec3(0.4, 0.6, 0.9 * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    const float hfov = radians(30.0);\n    const float tanhfov = tan(hfov);\n    const float near = 0.1;\n    const float far = 1.0;\n    \n    vec2 uv = fragCoord.xy / (iResolution.xy * 0.5) - vec2(1.0, 1.0);\n    float dx = tanhfov * uv.x / aspect;\n    float dy = tanhfov * uv.y;\n    \n    vec3 viewRayDir = normalize(vec3(dx, dy, 1.0) * (far - near));\n    \n    float z = map_z(0.0);\n    float bob = -0.3 + 0.025 * cos(z * 0.2);\n    float swivel = 0.05 * sin(z * 0.1);\n    mat4 inverseViewMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        swivel, bob, 1.0, 0.0,\n        0.0, 0.0, 0.0, 0.0\n        );\n    \n    float x = get_x(vec3(0.0, 0.0, 0.0));\n    vec3 ro = vec3(-x, 2.0, 0.0);\n    vec3 rd = (inverseViewMatrix * vec4(viewRayDir, 0.0)).xyz;\n    float resT;\n    \n    if (castRay(ro, rd, resT))\n    {\n        fragColor = vec4(terrainColor(ro, rd, resT), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(skyColor(fragCoord), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBBWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 52, 52, 84], [85, 85, 106, 106, 154], [156, 156, 183, 183, 223], [225, 225, 273, 273, 736], [738, 738, 762, 762, 952], [954, 954, 987, 987, 1051], [1053, 1053, 1099, 1099, 1579], [1581, 1581, 1612, 1612, 1698], [1700, 1700, 1757, 1757, 2773]], "test": "untested"}
{"id": "4lBfRV", "name": "Pathtrace Randomization", "author": "shemit", "description": "still breaking things up for future reference. now demonstrating randomization of bounce vectors.", "tags": ["pathtrace"], "likes": 0, "viewed": 94, "published": "Public", "date": "1516511679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SAMPLES 1\n#define PI 3.141592653589793\n\n// type:\n// 0: DIFFUSE\n// 1: EMISSIVE\nstruct Sphere {\n    float radius;\n    vec3 position;\n    float emission;\n    vec3 color;\n    int type;\n};\n\nstruct Camera {\n\tvec3 position;\n    vec3 direction;\n    vec3 up;\n    float fov;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec2 gridify(vec2 uv, float split) {\n    return ceil(uv * split) / split;\n}\n\nRay makeRay(vec2 uv, Camera camera) {\n    // simplify the sensor width to be res.x / res.y\n    // simplify the sensor height to be 1.0\n    \n    // first solve for near clip plane:\n    // tan(FOV / 2.0) = midx / adj\n    // adj = (uv.x / 2.0) / tan(FOV / 2.0)\n    \n    float midx = 0.5 * iResolution.x / iResolution.y;\n    float midy = 0.5;\n    float clipDistance = midx / tan(camera.fov / 2.0);\n    \n    // origin of ray at clipDistance location will be:\n    // (clipDistance, 0.0, 0.0)\n    // i.e.\n    // f(midx, midy) = Ray(origin: 0.0, direction: 1.0)\n    \n    // 1. tackle the origin of the ray\n    // we make the assumption that up is orthogonal to \n    // diretion (should add in a check for this later)\n    // we are left to find the remaining basis, which is\n    // the cross product of the two\n    vec3 xbasis = normalize(cross(camera.direction, camera.up));\n    vec3 ybasis = camera.up;\n    vec3 zbasis = camera.direction;\n    \n    // multiply sensor dimensions by basis to get position of pixel\n    // in world space\n    vec3 x = (uv.x - midx) * xbasis;\n    vec3 y = (uv.y - midy) * ybasis;\n    vec3 z = clipDistance * zbasis;\n   \n    // add these all together\n    vec3 position = x + y + z;\n    \n    // normalize to get a unit vector from the position\n    vec3 direction = normalize(position);\n    \n    // then, add the camera position\n    vec3 origin = position + camera.position;\n    \n    \n    Ray ray = Ray(origin, direction);\n    return ray;\n}\n\nfloat intersect(Ray ray, Sphere sphere) {\n    float eps = 0.0000001;\n    float t = 0.0;\n\n    vec3 offset = sphere.position - ray.origin;\n    vec3 direction = ray.direction;\n    float dist = dot(offset, ray.direction);\n    \n    // Quadratic equation to solve for hit distance\n    float discriminant = dist * dist - \n        dot(offset, offset) + \n        sphere.radius * sphere.radius;\n    \n    if (discriminant < 0.0) {\n        return 99999999999.0;\n    } else {\n        discriminant = sqrt(discriminant);\n        t = dist - discriminant;\n        if (t > eps) {\n        \treturn t;   \n        } else {\n         \tt = dist + discriminant;\n            if (t > eps) {\n             \treturn t;   \n            }\n        }\n    }\n    \n    return 99999999999.0;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvec3 radiance(Ray ray, Sphere spheres[8], vec2 uv) {\n    \n    vec3 bounce = vec3(0.0, 0.0, 0.0);\n    \n    for (int j = 0; j < 5; j++) {\n        float minDistance = 999999999999999.0;\n        int closestIdx = -1;\n        vec3 hitLocation = vec3(0.0, 0.0, 0.0);\n        vec3 normal = vec3(0.0, 0.0, 0.0);\n        vec3 radiance = vec3(0.0, 0.0, 0.0);\n\n\n        for (int i = 0; i < 8; i++) {\n            Sphere sphere = spheres[i];\n            float d = intersect(ray, sphere);\n            if (d < minDistance) {\n                minDistance = d;\n                closestIdx = i;\n                hitLocation = ray.origin + (ray.direction * minDistance);\n                normal = normalize(hitLocation - sphere.position);\n\n                // Flip normals if we are inside of the sphere\n                if (length(sphere.position - ray.origin) < sphere.radius) {\n                    normal = normal * -1.0;\n                }\n\n                vec3 sphereColor = vec3(1.0, 1.0, 1.0);\n                float randVal = rand(vec2(0.0, 0.0));\n\n                if (sphere.type == 0) {\n\n                    // Ray scatter randomize\n                    // Get a random angle from 0 to 2 * PI\n                    float rand1 = rand(\n                        vec2(\n                            uv.x * iTime * 1.32, \n                            uv.y * iTime * 1.14\n                        )) * 2.0 * PI;\n\n                    // Get a random distance from 0 to 1\n                    float rand2 = rand(vec2(uv.x * 1.932, uv.y * 2.789));\n\n                    float rand2sqrt = sqrt(rand2);\n\n                    // Coordinate system of bounce\n                    // we let \"z\" (which we call w for this coordinate system)\n                    // be the normal off of the sphere\n                    vec3 w = normal;\n\n                    // We choose some generic vector to be \"x\".\n                    // Make sure that it will not create a zero vector when crossed\n                    // with \"z\".\n                    vec3 u = abs(w.x) > 0.000001 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n                    u = normalize(cross(u, w));\n                    vec3 v = cross(w, u);\n\n                    vec3 ubounce = normalize(cos(rand1) * rand2sqrt) * u;\n                    vec3 vbounce = (sin(rand1) * rand2sqrt) * v;\n                    vec3 wbounce = normalize(sin(1.0 - rand2) * w);\n\n                    bounce = normalize(ubounce + vbounce + wbounce);\n                    \n\n                }\n\n            }\n\n        }\n        \n    }\n    \n    \n    return bounce;\n}\n\nvec3 pathtrace(vec2 uv, Camera camera, Sphere spheres[8]) {\n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    // TODO: Loop through this by samples/pixel\n    Ray ray = makeRay(uv, camera);\n    \n    // begin firing rays\n    vec3 color = radiance(ray, spheres, uv);\n   \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord / res.y;\n    \n    float split = 100.0;\n    \n    vec3 position = vec3(0.0, 0.0, 0.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // We set the FOV to be 90 degrees\n    Camera camera = Camera(position, direction, up, PI / 2.0);\n    \n    // Scene setup\n    Sphere ceiling = Sphere(\n    \t1000.0,\n        vec3(0.0, -997.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere left = Sphere(\n    \t1000.0,\n        vec3(-995.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere right = Sphere(\n    \t1000.0,\n        vec3(995.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere bottom = Sphere(\n    \t1000.0,\n        vec3(0.0, 997.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere back = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, -990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere front = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, 990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere middle = Sphere(\n    \t1.0,\n        vec3(0.0, 2.0 * sin(1.5 * iTime), 8.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere light = Sphere(\n    \t1.0,\n        vec3(3.0, 0.0, 8.0),\n        1000.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere spheres[8];\n    spheres[0] = middle;\n    spheres[1] = back;\n    spheres[2] = left;\n    spheres[3] = right;\n    spheres[4] = ceiling;\n    spheres[5] = bottom;\n    spheres[6] = front;\n    spheres[7] = light;\n    \n    vec2 grid = gridify(uv, split);\n    vec3 result = pathtrace(grid, camera, spheres);\n    \n    fragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBfRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 335, 371, 371, 410], [412, 412, 449, 669, 1870], [1872, 1872, 1913, 1913, 2624], [2626, 2626, 2646, 2646, 2718], [2722, 2722, 2774, 2774, 5265], [5267, 5267, 5326, 5326, 5620], [5623, 5623, 5680, 5680, 7439]], "test": "untested"}
{"id": "4lBfWR", "name": "Ray-marching with phong shading", "author": "Brendan", "description": "A ray-marcher with phong shading. I'm not quite sure I got the phong shading right (the wikipedia article was super confusing) but i tried my best. Please like and it will make my day :)", "tags": ["3d", "raymarching", "phong"], "likes": 9, "viewed": 486, "published": "Public", "date": "1515215804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst float EPSILON = 0.001;\nconst float limit = 100.0;\n\n\n//material parameters\nconst float ks = 3.0;\nconst float kd = 3.0;\nconst float ka = 1.0;\nconst float al = 20.0;\n//light parameters\nconst float ia = 1.0;\nconst vec3 lm = normalize(vec3(5,3,-1));\nconst float id = 1.0;\nconst float is = 1.0;\n\nfloat map(vec3 p){\n\t\n\t// Repeat cubic grid. \n\t// Equivalent to the following: p = mod(p, 3.) - 1.5;\n\tp = fract(p/3.)*3. - 1.5; // Note the division by 3.\n\n\treturn length(p) - .5;\n}\n\nfloat march(vec3 o, vec3 r){\n \t\n    float t = 0., d;\n    \n    for(int i=0;i<64;++i){\n       \n        d = map(o+r*t);\n        \n        if(d<EPSILON || t>limit) break;\n        \n        t+=d;\n    }\n    \n    return min(t, limit);\n}\n\nvec3 phong(vec3 n, vec3 v){\n    \n    vec3 rm = 2.0*dot(lm,n)*n-lm;\n    \n    float ip = ka*ia+(kd*clamp(dot(lm,n),0.0,1.1)*id + ks*pow(clamp(dot(rm,v),0.0,1.0),al)*is);\n    \n    return ip*vec3(0.1,0.2,0.5);\n        \n   }\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x+EPSILON,p.y,p.z))-map(vec3(p.x-EPSILON,p.y,p.z)),\n        map(vec3(p.x,p.y+EPSILON,p.z))-map(vec3(p.x,p.y-EPSILON,p.z)),\n        map(vec3(p.x,p.y,p.z+EPSILON))-map(vec3(p.x,p.y,p.z-EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n\n    uv.x*= iResolution.x/iResolution.y;\n    \n    float theta = iTime/20.0;\n    \n    //took me forever to figure out this\n    mat3 rotate = mat3(\n        cos(theta),sin(theta),0,\n        -sin(theta),cos(theta),0,\n        0,0,1\n        );\n\n    vec3 r = normalize(vec3(uv,2))*rotate;\n\n    vec3 o = vec3(iTime/2.0,0,iTime/2.0);\n\n    float t = march(o,r);\n\n    if((t == limit) || map(t * r + o)>EPSILON){\n        fragColor = vec4(0,0,0,1);\n    }else{\n        \n    vec3 fc = pow(phong(getNormal(t*r+o),-r),vec3(1));\n\n\tfragColor = vec4(fc, 1);\n\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBfWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 298, 316, 397, 478], [480, 480, 508, 508, 707], [709, 709, 736, 736, 928], [930, 930, 954, 954, 1203], [1205, 1205, 1262, 1262, 1877]], "test": "untested"}
{"id": "4lBfzG", "name": "graprog_ilas_act2", "author": "ilaschino", "description": "activity 2", "tags": ["graprogact1"], "likes": 1, "viewed": 63, "published": "Public", "date": "1516158219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float  valueX = step(0.0 + (sin(iTime) + 1.0)* 0.45 ,uv.x) - step(0.1 + (sin(iTime)+1.0)* 0.45,uv.x);\n    float  valueY = step(0.0 + (sin(iTime) + 1.0)* 0.45 ,uv.y) - step(0.1 + (sin(iTime)+1.0)* 0.45,uv.y);\n\t//float  valueY = step(abs(sin(iTime +11.0)),uv.y);\n\tfragColor = vec4(valueX * sin(iTime),valueY,0.45,0.5);\n    \n    //vec2 mouse = iMouse.xy / iResolution.xy;\n    //float pos = step(0.5,mouse.x);\n    //fragColor = vec4(pos);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBfzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 540]], "test": "untested"}
{"id": "4lBfzK", "name": "Water flowing", "author": "noob", "description": "This is my first shader. Hope you guys like it.", "tags": ["water", "flow"], "likes": 5, "viewed": 616, "published": "Public API", "date": "1516413817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm(in vec2 p ) {\n    return 0.5*noise(p) + 0.25*noise(2.0*p)+0.125*noise(4.0*p)+0.0625*noise(8.0*p)\n        +0.03125*noise(16.0*p)+0.015625*noise(32.0*p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 * 2.0 * uv;\n    p+=fbm(4.0*p+vec2(iTime, 0));\n    p = p * 4.0;\n    float f1 = fbm(p), f2=fbm(p + 100.0), f3=fbm(p + 200.0);\n\tfragColor = vec4(0.3, f2, 0.9*f3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBfzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 65], [67, 67, 93, 93, 299], [301, 301, 324, 324, 464], [466, 466, 523, 523, 749]], "test": "untested"}
{"id": "4lBfzt", "name": "Volumetric Machine", "author": "PrzemyslawZaworski", "description": "Just simple shader which I use for debug purposes.", "tags": ["raymarching", "abstract", "map", "spheretracing"], "likes": 6, "viewed": 227, "published": "Public", "date": "1516795979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime\n\nvoid r(inout vec2 p) \n{\n\tfloat a = mod(atan(p.y, p.x) + .1963495,.39269908) - .1963495;\n\tp = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat c(vec3 p, vec3 a, vec3 b, float r)\n{  \n\treturn length(((b - a)*clamp(dot(p - a, b - a) / dot(b - a, b - a),0.,1.) + a) - p) -r ;\n}\n\nfloat map (vec3 p)\n{\n\tp.y = mod(p.y + 1., 2.) - 1.;\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(.7,10.);\n\tfloat a = min(max(d.x,d.y),0.0) + length(max(d,0.)); \n    a=min(a,length(vec2(length(p.xz)-1.2,p.y))-.35);\n    r(p.xz);\n    float b = c(p,vec3(.6,3,0),vec3(.6,-3,0),.2);\n    a=max(a,-b);\n    p=vec3(cos(T)*p.x-sin(T)*p.z,p.y,sin(T)*p.x+cos(T)*p.z);\n    r(p.xz);    \n    float g = c(p,vec3(2,-.5,0),vec3(2,.5,0),.2);\n    float e = c(p,vec3(2,-.5,0),vec3(1,-.5,0),.2);\n    float f = c(p,vec3(2,.5,0),vec3(1,.5,0),.2);\n    return min(a,min(min(g,e),f));\n}\n\nvec4 raymarch (vec3 p, vec3 rd)\n{\n    for (int i=0;i<128;i++)\n    {\n      float t = map (p);\n      if (t<0.001)  return vec4(pow(1.-float(i)/float(128),2.));         \n      p+=t*rd;\n    }\n    return vec4(1.0-(pow(length(rd.x),2.)*2.),0,0,1);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n\tvec2 uv = (2. * f.xy - iResolution.xy) / iResolution.y;\n\to = raymarch(vec3 (0,T,-5.),normalize(vec3(uv,2.)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBfzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 40, 40, 142], [144, 144, 186, 186, 280], [282, 282, 302, 302, 840], [842, 842, 875, 875, 1085], [1087, 1087, 1128, 1128, 1241]], "test": "untested"}
{"id": "4ljBDG", "name": "24/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Have some Friday night tunnel!", "tags": ["pathtracing", "dailyshader"], "likes": 2, "viewed": 106, "published": "Public", "date": "1517014019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 30\n#define FAR 40.0\n#define PIXELR 0.5/iResolution.x\n\n#define BOUNCES 3\n#define SAMPLES 4.0\n\n//Hash methods from https://www.shadertoy.com/view/4djSRW\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//Distance functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Maximum/minumum elements of a vector\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nvec2 dist(vec3 p){\n    pR(p.xy, iTime*0.2);\n    float tunnel = -fBox(p, vec3(2.0, 2.0, 2.0*FAR));\n    return vec2(tunnel, 0.0);\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(PIXELR, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy).x-dist(p-eps.xyy).x,\n        dist(p+eps.yxy).x-dist(p-eps.yxy).x,\n        dist(p+eps.yyx).x-dist(p-eps.yyx).x\n    ));\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 2.0;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(dist(ro).x);\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*dist(p).x;\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*dist(p).x);\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n    \n    p = ro+rd*t;\n    float id = dist(p).y;\n    \n\treturn vec2(t, id);\n}\n\n//returns material of the object hit\n// emissive color is xyz, and reflectance w\nvec4 getMaterial(float obj, vec3 p){\n    vec3 base = vec3(0.0);\n    float reflectance = 0.0;\n    float m = mod(p.z-(iTime*8.0), 8.0) - 4.0;\n\n    vec3 col = vec3(0.4, 0.3, 0.8);\n\n    if(m > 0.0 && m > 2.0){\n        base = col;\n    }\n    else if( m < 0.0 && m > -2.0){\n        base = col.bgb;\n    }\n    reflectance = m > 0.0 ? 0.2 : 0.5;\n    return vec4(base, reflectance);\n}\n\nvec3 render(vec3 o, vec3 d, vec2 uv){\n    \n    vec3 ro = o;\n    vec3 rd = d;\n    \n    vec3 pixel_color = vec3(0.0);\n    vec3 absorption_factor = vec3(1.0);\n    \n    for(int i = 0; i < BOUNCES; ++i){\n        vec2 t = march(ro, rd);\n        vec3 p = ro+rd*t.x;\n        \n        if(t.y < 0.0 || t.x > FAR){\n            break;\n        }\n        \n        //material.xyz == emissive\n        //material.w == reflectance\n        vec4 material = getMaterial(t.y, p);\n        pixel_color += material.xyz * absorption_factor;\n        absorption_factor *= material.w;\n        \n        vec3 n = normals(p);\n        ro = p+(n*0.02);\n        if(t.y == 0.0){\n            rd = reflect(rd,n);\n            //Thanks to fizzer to introducing this skew thing! :)\n            rd = normalize(rd + (hash33(vec3(uv, float(i))) - 0.5)*0.1); \n        }\n        \n    }\n    \n    return pixel_color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rt = vec3(0.0, 0.0, -FAR);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    \n    vec3 color = vec3(0.0);\n    \n    for(float i = 0.0; i < SAMPLES; ++i){\n    \tvec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(60.0)));\n    \tcolor += render(ro, rd, uv);\n    }\n    color /= SAMPLES;\n    \n    color = pow(color, 1.0/vec3(2.2));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 263, 284, 284, 394], [475, 515, 536, 536, 571], [573, 609, 637, 637, 719], [721, 959, 991, 991, 1033], [1036, 1036, 1054, 1054, 1165], [1167, 1167, 1188, 1188, 1398], [1459, 1498, 1518, 1518, 1548], [1550, 1550, 1579, 1579, 2816], [2818, 2899, 2935, 2935, 3272], [3274, 3274, 3311, 3311, 4144], [4147, 4147, 4203, 4203, 4798]], "test": "untested"}
{"id": "4ljBDz", "name": "[1] Hello Circle", "author": "emr4378", "description": "First attempt at writing a shader; a 2D circle.", "tags": ["basic", "circle"], "likes": 0, "viewed": 255, "published": "Public API", "date": "1515376347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMOOTHING 2.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 center = (iResolution.xy * 0.5);\n    float r = min(iResolution.x, iResolution.y) / 2.0;\n    float coordDist = length(fragCoord - center);  \n   \tfloat stepValue = smoothstep(r, r - SMOOTHING, coordDist);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(vec3(uv, 0.5+0.5*sin(iTime)) * stepValue, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljBDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 78, 78, 413]], "test": "untested"}
{"id": "4ljBzK", "name": "Pathtrace Final", "author": "shemit", "description": "final iteration.", "tags": ["finaliterationpathtrace"], "likes": 0, "viewed": 122, "published": "Public", "date": "1516514760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SAMPLES 3\n#define PI 3.141592653589793\n#define SPHERES 9\n\n// type:\n// 0: DIFFUSE\n// 1: EMISSIVE\nstruct Sphere {\n    float radius;\n    vec3 position;\n    float emission;\n    vec3 color;\n    int type;\n};\n\nstruct Camera {\n\tvec3 position;\n    vec3 direction;\n    vec3 up;\n    float fov;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct HitData {\n    Sphere sphere;\n    vec3 hitLocation;\n    vec3 normal;\n};\n\nvec2 gridify(vec2 uv, float split) {\n    return ceil(uv * split) / split;\n}\n\nRay makeRay(vec2 uv, Camera camera) {\n    // simplify the sensor width to be res.x / res.y\n    // simplify the sensor height to be 1.0\n    \n    // first solve for near clip plane:\n    // tan(FOV / 2.0) = midx / adj\n    // adj = (uv.x / 2.0) / tan(FOV / 2.0)\n    \n    float midx = 0.5 * iResolution.x / iResolution.y;\n    float midy = 0.5;\n    float clipDistance = midx / tan(camera.fov / 2.0);\n    \n    // origin of ray at clipDistance location will be:\n    // (clipDistance, 0.0, 0.0)\n    // i.e.\n    // f(midx, midy) = Ray(origin: 0.0, direction: 1.0)\n    \n    // 1. tackle the origin of the ray\n    // we make the assumption that up is orthogonal to \n    // diretion (should add in a check for this later)\n    // we are left to find the remaining basis, which is\n    // the cross product of the two\n    vec3 xbasis = normalize(cross(camera.direction, camera.up));\n    vec3 ybasis = camera.up;\n    vec3 zbasis = camera.direction;\n    \n    // multiply sensor dimensions by basis to get position of pixel\n    // in world space\n    vec3 x = (uv.x - midx) * xbasis;\n    vec3 y = (uv.y - midy) * ybasis;\n    vec3 z = clipDistance * zbasis;\n   \n    // add these all together\n    vec3 position = x + y + z;\n    \n    // normalize to get a unit vector from the position\n    vec3 direction = normalize(position);\n    \n    // then, add the camera position\n    vec3 origin = position + camera.position;\n    \n    \n    Ray ray = Ray(origin, direction);\n    return ray;\n}\n\nfloat intersect(Ray ray, Sphere sphere) {\n    float eps = 0.0000001;\n    float t = 0.0;\n\n    vec3 offset = sphere.position - ray.origin;\n    vec3 direction = ray.direction;\n    float dist = dot(offset, ray.direction);\n    \n    // Quadratic equation to solve for hit distance\n    float discriminant = dist * dist - \n        dot(offset, offset) + \n        sphere.radius * sphere.radius;\n    \n    if (discriminant < 0.0) {\n        return 99999999999.0;\n    } else {\n        discriminant = sqrt(discriminant);\n        t = dist - discriminant;\n        if (t > eps) {\n        \treturn t;   \n        } else {\n         \tt = dist + discriminant;\n            if (t > eps) {\n             \treturn t;   \n            }\n        }\n    }\n    \n    return 99999999999.0;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nHitData getHitData(Ray ray, Sphere spheres[SPHERES], vec2 uv) {\n    float minDistance = 999999999999999.0;\n    vec3 hitLocation = vec3(0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    \n    Sphere closestSphere = spheres[0];\n\n    for (int i = 0; i < SPHERES; i++) {\n        Sphere sphere = spheres[i];\n        float d = intersect(ray, sphere);\n        if (d < minDistance) {\n            minDistance = d;\n            hitLocation = ray.origin + (ray.direction * minDistance);\n            normal = normalize(hitLocation - sphere.position);\n            closestSphere = sphere;\n\n            // Flip normals if we are inside of the sphere\n            if (length(sphere.position - ray.origin) < sphere.radius) {\n                normal = normal * -1.0;\n            }\n        }\n    }\n    \n    HitData hitData = HitData(closestSphere, hitLocation, normal);\n\treturn hitData;\n}\n\nvec3 processHitData(HitData hitData, vec2 uv, int idx) {\n    \n    vec3 bounce = vec3(0.0, 0.0, 0.0);\n    \n    if (hitData.sphere.type == 0) {\n\n        // Ray scatter randomize\n        // Get a random angle from 0 to 2 * PI\n        float rand1 = rand(\n            vec2(\n                uv.x * 1.32, \n                uv.y * 1.14\n            )) * 2.0 * PI;\n\n        // Get a random distance from 0 to 1\n        float rand2 = rand(\n            vec2(\n                uv.x * 1.932, \n                uv.y * 2.789\n            )\n        );\n\n        float rand2sqrt = sqrt(rand2);\n\n        // Coordinate system of bounce\n        // we let \"z\" (which we call w for this coordinate system)\n        // be the normal off of the sphere\n        \n        vec3 w = hitData.normal;\n\n        // We choose some generic vector to be \"x\".\n        // Make sure that it will not create a zero vector when crossed\n        // with \"z\".\n        vec3 u = abs(w.x) > 0.000001 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n        u = normalize(cross(u, w));\n        vec3 v = cross(w, u);\n\n        vec3 ubounce = cos(rand1) * rand2sqrt * u;\n        vec3 vbounce = sin(rand1) * rand2sqrt * v;\n        vec3 wbounce = normalize(sin(1.0 - rand2) * w);\n\n        bounce = normalize(ubounce + vbounce + wbounce);\n        //return vec3(rand1, 0.0, 0.0);\n\t\t\n    }\n    return bounce;\n}\n\nvec3 radiance(Ray ray, Sphere spheres[SPHERES], vec2 uv) {\n    HitData hitDatas[SAMPLES];\n    Ray original = ray;\n    \n    HitData hitData = getHitData(ray, spheres, uv);\n    vec3 color = hitData.sphere.color;\n    vec3 rad = hitData.sphere.emission * hitData.sphere.color;\n    \n    float maxReflectance = max(\n        max(hitData.sphere.color.x, hitData.sphere.color.y),\n        hitData.sphere.color.z\n    );\n    \n    if (hitData.sphere.emission > 0.999) {\n        return rad;\n    }\n    HitData prevHitData = hitData;\n    \n    for (int j = 0; j < SAMPLES; j++) {\n\t    vec3 bounce = processHitData(prevHitData, uv, j);\n        Ray newRay = Ray(prevHitData.hitLocation, bounce);\n        HitData hitData2 = getHitData(newRay, spheres, uv);\n        \n        vec3 newColor = hitData2.sphere.color;\n        color += (newColor / float(SAMPLES));\n        rad += hitData2.sphere.emission * hitData2.sphere.color;\n        \n        prevHitData = hitData2;\n    }\n    \n    //color = color / float(SAMPLES + 1);\n    return rad * color / float(SAMPLES + 1);\n    //return color;\n\n}\n\nvec3 pathtrace(vec2 uv, Camera camera, Sphere spheres[SPHERES]) {\n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    // TODO: Loop through this by samples/pixel\n    Ray ray = makeRay(uv, camera);\n    \n    // begin firing rays\n    vec3 color = radiance(ray, spheres, uv);\n   \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord / res.y;\n    \n    float split = 10000.0;\n    \n    vec3 position = vec3(0.0, 0.0, 0.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // We set the FOV to be 90 degrees\n    Camera camera = Camera(position, direction, up, PI / 2.0);\n    \n    // Scene setup\n    Sphere ceiling = Sphere(\n    \t1000.0,\n        vec3(0.0, 1003.0, 0.0),\n        0.0,\n        vec3(1.0, 0.0, 0.0),\n        0\n    );\n    Sphere left = Sphere(\n    \t1000.0,\n        vec3(1005.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere right = Sphere(\n    \t1000.0,\n        vec3(-1005.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere bottom = Sphere(\n    \t1000.0,\n        vec3(0.0, -1003.0, 0.0),\n        0.0,\n        vec3(0.0, 1.0, 1.0),\n        0\n    );\n    Sphere back = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, 1015.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere front = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, 990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere middle = Sphere(\n    \t1.0,\n        vec3(0.0, 2.0 * sin(1.5 * iTime), 8.0),\n        0.0,\n        vec3(0.0, 1.0, 0.0),\n        0\n    );\n    Sphere light = Sphere(\n    \t2.0,\n        vec3(0.0, 0.0, 11.5),\n        1.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere light2 = Sphere(\n    \t1.0,\n        vec3(-1.0, 0.0, 5.0),\n        1.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere spheres[SPHERES];\n    spheres[0] = middle;\n    spheres[1] = back;\n    spheres[2] = left;\n    spheres[3] = right;\n    spheres[4] = ceiling;\n    spheres[5] = bottom;\n    spheres[6] = front;\n    spheres[7] = light;\n    //spheres[8] = light2;\n    \n    vec2 grid = gridify(uv, split);\n    vec3 result = pathtrace(grid, camera, spheres);\n    \n    fragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 436, 472, 472, 511], [513, 513, 550, 770, 1971], [1973, 1973, 2014, 2014, 2725], [2727, 2727, 2747, 2747, 2819], [2821, 2821, 2884, 2884, 3695], [3697, 3697, 3753, 3753, 5040], [5042, 5042, 5100, 5100, 6107], [6109, 6109, 6174, 6174, 6468], [6471, 6471, 6528, 6528, 8451]], "test": "untested"}
{"id": "4ljfWV", "name": "Tissueue", "author": "TinyTexel", "description": "shader", "tags": ["shader"], "likes": 1, "viewed": 87, "published": "Public", "date": "1517252447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nleft:   standard cell noise\nmiddle: smooth cell noise | using 1/pow(d, e) as edge weight\nright:  smooth cell noise | using 1/(exp2(d * s) - 1) as edge weight\ntop:    difference between standard and smooth\nbottom: iso lines\n\nThe exp2-based variant produces more consistently smooth iso lines. \n*/\n\n//smoothness settings (middle E, right S):\n#define E 8.0\n#define S 22.0 \n\n\n#define Time iTime\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\n\nconst float Pi = 3.14159265359;\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n\nfloat FwdPot_RcpExp(float d, float s)\n{\n\treturn 1.0 / (exp2(d * s) - 1.0);\n}\n\nfloat InvPot_RcpExp(float d, float s)\n{\n\treturn log2(1.0 / d + 1.0) / s;\n}\n\n\nfloat FwdPot_RcpPowExp(float d, float e, float s)\n{\n\ts /= e;\n\treturn pow(exp2(d * s) - 1.0, -e);\n}\n\nfloat InvPot_RcpPowExp(float d, float e, float s)\n{\n\ts /= e;\n\treturn log2(pow(d, -1.0 / e) + 1.0) / s;\n}\n\n\nfloat FwdPot_RcpPow(float d, float e)\n{\n\treturn pow(d, -e);\n}\n\nfloat InvPot_RcpPow(float d, float e)\n{\n\treturn pow(d, -1.0 / e);\n}\n\n\nvec3 CellTex(vec2 p, float seed, vec2 cells)\n{\n\tfloat d1;\n\tvec2 p1;\n\tvec2 cv1;\n\t\n\tvec2 p_i = floor(p);\n\t\n\td1 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < d1)\n\t\t{\n\t\t\td1 = d;\n\t\t\tp1 = fp;\n\t\t\tcv1 = cv;\n\t\t}\n\t}\n\t\n    float e = E;\n    float s = S;\n    \n    e = 2.0;\n    s = 8.0;\n    \n\tfloat dd1 = 64.0;\n\tfloat dd2 = 0.0;\n    float dd3 = 0.0;\n    \n    const float n = 2.0;\n\tfor(float i = -n; i <= n; ++i)\n\tfor(float j = -n; j <= n; ++j)\n\tif(i != cv1.x || j != cv1.y)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t    float d = dot(p - (p1 + fp) * 0.5, normalize(p1 - fp));\n\t\td *= 1.48;// empirically normalized\n\n\t\tdd1 = min(dd1, d);\n        dd2 += FwdPot_RcpPow(d, e);\n\t\tdd3 += FwdPot_RcpExp(d, s);\n\t}\n\t\n    //return InvPot_RcpExp(dd3, s);    \n    //return InvPot_RcpPow(dd2, e);\n\treturn vec3(dd1, InvPot_RcpPow(dd2, e), InvPot_RcpExp(dd3, s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 tex = uv / iResolution.xy;\n    \n    //uv.x = mod(uv.x, iResolution.x / 3.0);\n    \n    vec2 cells = vec2(0.0);\n    //cells = vec2(5.0);// 5 cells per tile\n    \n    vec2 pos = uv * 0.02 + Time * 0.;\n    \n    vec2 off = vec2(CellTex(pos, 0.1, cells).y, \n                    CellTex(pos, 0.2, cells).y) - vec2(0.25);\n    \n    float s = 0.2;\n    vec3 r = CellTex(pos + vec2(1.0)*Time*s, 0.0, cells);\n    vec3 rB = CellTex((pos + vec2(1.05)*Time*s)*0.8, 0.41, cells);\n    vec3 rC = CellTex((pos + vec2(1.1)*Time*s)*0.6, 0.73, cells);\n    \n    \n\n   // r *= r2;\n    \n    //r *= r;\n    //r -= 0.1;\n    //r.x /= length(vec2(dFdx(r.x), dFdy(r.x)));\n    //r.y /= length(vec2(dFdx(r.y), dFdy(r.y)));\n    //r.z /= length(vec2(dFdx(r.z), dFdy(r.z)));\n    //r = abs(mod(r * 0.125, 1.0) * 2.0 - 1.0) * 2.0 - 1.0;\n    \n    float r0 = tex.x < 1.0/3.0 ? r.x : \n               tex.x < 2.0/3.0 ? r.y : r.z;\n    \n    float r0B = tex.x < 1.0/3.0 ? rB.x : \n                tex.x < 2.0/3.0 ? rB.y : rB.z;\n    \n    r0 = r.z; r0B = rB.z;\n    \n    float o = 8.0;\n    //r0 = 1.0-InvPot_RcpExp(FwdPot_RcpExp(1.0-r0, o) + FwdPot_RcpExp(1.0-r0B, o), o);\n    r0 = InvPot_RcpExp(FwdPot_RcpExp(r.z, o) + FwdPot_RcpExp(rB.z, o) + FwdPot_RcpExp(rC.z, o*1.0), o);\n    //if(tex.y > 0.5) r0 = r.x - r0;\n    \n    //r0 = 1.0-r0*1.5;\n    r0 -= 0.06;\n    r0 *= 48.0;\n    r0 = clamp01(r0);\n    r0 = r0*r0*(3.0-2.0*r0);\n    //r0 /= length(vec2(dFdx(r0), dFdy(r0)))*2.0;\n    \n    vec3 col = vec3(r0-0.0)*1.0;\n    \n    #if 0\n    if(tex.y < 0.25)\n    {\n    \tfloat stripes = abs(fract(r0 * 8.0) * 2.0 - 1.0) * 2.0 - 1.0;\n        col = vec3(1.0-clamp01(r0 * 8.0), stripes, clamp01(r0 * 8.0-4.0));\n    }\n    #endif\n    \n    fragColor = vec4(pow(clamp01(col), vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 596, 622, 622, 659], [661, 661, 684, 684, 698], [699, 699, 722, 722, 740], [741, 741, 764, 764, 782], [783, 783, 806, 806, 824], [826, 826, 852, 852, 905], [907, 907, 932, 932, 974], [977, 977, 1016, 1016, 1053], [1055, 1055, 1094, 1094, 1129], [1132, 1132, 1183, 1183, 1230], [1232, 1232, 1283, 1283, 1336], [1339, 1339, 1378, 1378, 1400], [1402, 1402, 1441, 1441, 1469], [1472, 1472, 1518, 1518, 2772], [2774, 2774, 2831, 2831, 4595]], "test": "untested"}
{"id": "4ljfzw", "name": "Ship of Mirrors", "author": "dr2", "description": "Lots of reflection (mouseable)", "tags": ["reflection", "ship", "sail"], "likes": 7, "viewed": 568, "published": "Public API", "date": "1515081999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ship of Mirrors\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MORE_REFL  0  // set =1 for extra level of reflection\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEVCapsDf (vec3 p, vec4 u, float r);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec3 HexGrid (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 vum[4], vur[5];\nvec3 vim[4], vir[5];\nvec3 sunDir, shipConf, bDeck, qHit, vnCylOut;\nfloat tCur, dstFar, szFac, bCylRad, bCylHt, dCylOut;\nint idObj;\nconst int idHull = 1, idRud = 2, idStruc = 3, idMast = 4, idSparT = 5, idSparL = 6, idSailT = 7,\n   idSailA = 8, idSailF = 9, idFlag = 10, idRig = 11;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ShipHullDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, fy, fz, gz;\n  q = p;\n  d = abs (p.z) - 4.5;\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  q.yz -= vec2 (-3.4, -0.4);\n  d = max (d, PrBoxDf (q, vec3 (0.3, 0.1, 0.5)));\n  DMINQ (idStruc);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (-3.8, 0.5);\n  fz = q.z / 5. + 0.3;\n  fz *= fz;\n  fy = 1. - smoothstep (-1.3, -0.1, q.y);\n  gz = smoothstep (2., 5., q.z);\n  bDeck = vec3 ((1. - 0.45 * fz * fz) * (1.1 - 0.5 * fy * fy) *\n     (1. - 0.5 * smoothstep (-5., -2., q.y) * smoothstep (2., 5., q.z)),\n     0.78 - 0.8 * gz * gz - 0.2 * (1. - smoothstep (-5.2, -4., q.z)), 5. * (1. + 0. * 0.02 * q.y));\n  d = min (PrBoxDf (vec3 (q.x, q.y + bDeck.y - 0.6, q.z), bDeck),\n     max (PrBoxDf (q - vec3 (0., 0.72, -4.6), vec3 (bDeck.x, 0.12, 0.4)),\n     - PrBox2Df (vec2 (abs (q.x) - 0.4, q.y - 0.65), vec2 (0.2, 0.08))));\n  d = max (d, - PrBoxDf (vec3 (q.x, q.y - 0.58 - 0.1 * fz, q.z), vec3 (bDeck.x - 0.07, 0.3, bDeck.z - 0.1)));\n  q = p;\n  d = max (d, - max (PrBox2Df (vec2 (q.y + 3.35, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.08, 0.1)),\n     abs (q.z + 0.5) - 3.75));\n  DMINQ (idHull);\n  q = p;\n  d = PrBoxDf (q + vec3 (0., 4.4, 4.05), vec3 (0.03, 0.35, 0.5));\n  DMINQ (idRud);\n  return dMin;\n}\n\nfloat ShipMastDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, fy, fz, s, rSpar, yLim, zLim;\n  rSpar = 0.05;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  zLim = abs (p.z) - 4.5;\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.2;\n  d = max (d, PrCapsDf ((q - vec3 (0., 3.7 * (fz - 1.), 0.)).xzy, 0.1 * fy, 3.7 * fz));\n  DMINQ (idMast);\n  q = p;\n  yLim = abs (q.y - 0.2 * fz) - 3. * fz;\n  qq = q;\n  qq.y = mod (qq.y - 3.3 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.1 * fz;\n  d = max (max (min (d, PrCylDf (vec3 (qq - vec3 (0., 0.05 * fy * fz, 0.1 * fz - 0.23)).xzy,\n     0.15 * fy, 0.11 * fy * fz)), yLim), zLim);\n  DMINQ (idMast);\n  d = max (max (PrCapsDf (qq.yzx, 0.05, 1.23 * fy * fz), yLim), zLim);\n  DMINQ (idSparT);\n  q = p;\n  d = min (d, min (PrEVCapsDf (q - vim[0], vum[0], rSpar), PrEVCapsDf (q - vim[1], vum[1], rSpar)));\n  d = min (d, min (PrEVCapsDf (q - vim[2], vum[2], rSpar), PrEVCapsDf (q - vim[3], vum[3], rSpar)));\n  DMINQ (idSparL);\n  return dMin;\n}\n\nfloat ShipSailDf (vec3 p, float dMin)\n{\n  vec3 q, qq, w;\n  float d, fy, fz;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  qq = q;\n  qq.y = mod (qq.y - 3.1 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.2 * (fz - abs (qq.y)) * (fz - abs (qq.y)) - 0.1 * fz;\n  d = max (max (max (PrBoxDf (qq, vec3 ((1.2 - 0.07 * q.y) * fz, fz, 0.01)),\n     min (qq.y, 1.5 * fy * fz - length (vec2 (qq.x, qq.y + 0.9 * fy * fz)))),\n     abs (q.y - 3. * (fz - 1.)) - 2.95 * fz), - PrBox2Df (qq.yz, vec2 (0.01 * fz)));\n  d = max (d, abs (p.z) - 4.5);\n  DMINQ (idSailT);\n  q = p;\n  q.z -= -3.8;  q.y -= -1.75 - 0.2 * q.z;\n  d = PrBoxDf (q, vec3 (0.01, 0.9 - 0.2 * q.z, 0.6));\n  DMINQ (idSailA);\n  q = p;\n  q.yz -= vec2 (-1., 4.5);\n  w = vec3 (1., q.yz);\n  d = max (max (max (abs (q.x) - 0.01, - dot (w, vec3 (2.3, 1., -0.35))),\n     - dot (w, vec3 (0.68, -0.74, -1.))), - dot (w, vec3 (0.41, 0.4, 1.)));\n  DMINQ (idSailF);\n  q = p;\n  q.yz -= vec2 (3.4, 0.18);\n  d = PrBoxDf (q, vec3 (0.01, 0.2, 0.3));\n  DMINQ (idFlag);\n  return dMin;\n}\n\nfloat ShipRigDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rRig, d, fz, gz, s;\n  rRig = 0.02;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  d = abs (p.z) - 4.5;\n  gz = (q.z - 0.5) / 5. + 0.3;\n  gz *= gz;\n  gz = 1.05 * (1. - 0.45 * gz * gz);\n  q.x = abs (q.x);\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  d = max (d, min (PrEECapsDf (q, vec3 (1.05 * gz, -3.25, -0.5), vec3 (1.4 * fz, -2.95, -0.05), 0.7 * rRig),\n     PrEECapsDf (vec3 (q.xy, abs (q.z + 0.2) - 0.01 * (0.3 - 2. * q.y)), vec3 (gz, -3.2, 0.),\n     vec3 (0.05, -0.9 + 2. * (fz - 1.), 0.), rRig)));\n  q = p;\n  d = min (d, PrEVCapsDf (q - vir[0], vur[0], 0.8 * rRig));\n  d = min (min (d, min (PrEVCapsDf (q - vir[1], vur[1], rRig),\n     PrEVCapsDf (q - vir[2], vur[2], rRig))), PrEVCapsDf (q - vir[3], vur[3], rRig));\n  q.x = abs (q.x);\n  d = min (d, PrEVCapsDf (q - vir[4], vur[4], rRig));\n  s = step (1.8, q.y) - step (q.y, -0.2);\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0.95, 0.4, 2.7) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 1.1, -0.15) + vec3 (0., 2., 0.) * s, rRig),\n     PrEECapsDf (q, vec3 (1.05, 1., -0.1) + vec3 (-0.1, 2., 0.) * s,\n     vec3 (0.05, 0.5, -2.95) + vec3 (0., 1.7, 0.) * s, rRig))),\n     PrEECapsDf (q, vec3 (0.95, 0.4, -2.9) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 0.9, -0.25) + vec3 (0., 2., 0.) * s, rRig));\n  DMINQ (idRig);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  q = p;\n  q.y -= -1.25 + shipConf.x;\n  q /= szFac;\n  dMin = dstFar / szFac;\n  dMin = ShipHullDf (q, dMin);\n  dMin = ShipMastDf (q, dMin);\n  dMin = ShipSailDf (q, dMin);\n  dMin = ShipRigDf (q, dMin);\n  dMin *= 0.7 * szFac;\n  return dMin;\n}\n\nvoid EvalShipConf ()\n{\n  vec3 vd;\n  shipConf = vec3 (4.8 * szFac, 0., 0.);\n  vim[0] = vec3 (0., -3.5, 4.3);   vd = vec3 (0., -2.6, 6.7) - vim[0];   vum[0] = vec4 (normalize (vd), length (vd));\n  vim[1] = vec3 (0., -4., 4.1);    vd = vec3 (0., -2.9, 6.) - vim[1];    vum[1] = vec4 (normalize (vd), length (vd));\n  vim[2] = vec3 (0., -1.2, -3.);   vd = vec3 (0., -0.5, -4.5) - vim[2];  vum[2] = vec4 (normalize (vd), length (vd));\n  vim[3] = vec3 (0., -2.7, -3.);   vd = vec3 (0., -2.7, -4.5) - vim[3];  vum[3] = vec4 (normalize (vd), length (vd));\n  vir[0] = vec3 (0., -3., -4.45);  vd = vec3 (0., -2.7, -4.5) - vir[0];  vur[0] = vec4 (normalize (vd), length (vd));\n  vir[1] = vec3 (0., 2.45, 2.65);  vd = vec3 (0., -2.7, 6.5) - vir[1];   vur[1] = vec4 (normalize (vd), length (vd));\n  vir[2] = vec3 (0., 2.5, 2.65);   vd = vec3 (0., -3.2, 4.9) - vir[2];   vur[2] = vec4 (normalize (vd), length (vd));\n  vir[3] = vec3 (0., 2.6, -3.);    vd = vec3 (0., -0.5, -4.5) - vir[3];  vur[3] = vec4 (normalize (vd), length (vd));\n  vir[4] = vec3 (0.65, -3.5, 3.5); vd = vec3 (0.05, -2.7, 6.4) - vir[4]; vur[4] = vec4 (normalize (vd), length (vd));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += 0.1;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec4 ShipCol ()\n{\n  vec4 col4;\n  vec2 cg;\n  if (idObj == idHull) {\n    if (abs (qHit.x) < bDeck.x - 0.08 && qHit.y > -3.6 && qHit.z > - bDeck.z + 0.62) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.1 + 0.9 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.x, 1.)));\n    } else if (qHit.y > -4.) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.1);\n      if (abs (qHit.z - 4.) < 0.25 && abs (qHit.y + 3.55) < 0.05) col4 *= 1.2;\n      else if (qHit.z < -4. && abs (qHit.x) < 0.84 && abs (qHit.y + 3.62) < 0.125) {\n        cg = step (0.1, abs (fract (vec2 (6. * qHit.x, 8. * (qHit.y + 3.62)) + 0.5) - 0.5));\n        if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n        else col4 *= 0.8;\n      } else {\n        col4 *= 0.1 + 0.9 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.y, 1.));\n      } \n    } else if (qHit.y > -4.05) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    } else {\n      col4 = vec4 (0.3, 0.2, 0.1, 0.);\n    }\n  } else if (idObj == idRud) {\n    col4 = vec4 (0.5, 0.3, 0., 0.);\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.4, 0.3, 0.1, 0.1);\n    if (max (abs (qHit.x), abs (qHit.z + 0.22)) < 0.2) {\n      cg = step (0.1, abs (fract (vec2 (10. * vec2 (qHit.x, qHit.z + 0.22)) + 0.5) - 0.5));\n      if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n    }\n  } else if (idObj == idSailT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (1., 1., 1., 0.) * (0.1 + 0.9 * SmoothBump (0.05, 0.95, 0.02, mod (4. * qHit.x, 1.)));\n    if (abs (qHit.z) < 0.2 && abs (abs (length (qHit.xy - vec2 (0., 0.3)) - 0.35) - 0.15) < 0.07)\n       col4 *= vec4 (1., 0.2, 0.2, 1.);\n  } else if (idObj == idSailA) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.1 + 0.9 * SmoothBump (0.05, 0.95, 0.02, mod (5. * qHit.z, 1.)));\n  } else if (idObj == idSailF) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.1 + 0.9 * SmoothBump (0.05, 0.95, 0.02,\n       mod (2.95 * qHit.y + 4. * qHit.z - 0.5, 1.)));\n  } else if (idObj == idFlag) {\n    col4 = vec4 (1., 1., 0.5, 0.1);\n    if (abs (abs (length (qHit.yz) - 0.1) - 0.04) < 0.02) col4 *= vec4 (1., 0.2, 0.2, 1.);\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (length (qHit.xz) < 0.16 * (1. - 0.07 * qHit.y))\n       col4 *= 0.6 + 0.4 * SmoothBump (0.03, 0.97, 0.01, mod (2. * qHit.y / (1. + 0.14 * step (1., abs (qHit.z))), 1.));\n    if (qHit.y > 3.65) col4 = vec4 (1., 0., 0., -1.);\n  } else if (idObj == idSparT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (0.7, 0.4, 0., 0.1) *  (0.6 + 0.4 * SmoothBump (0.08, 0.92, 0.01, mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSparL) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (qHit.z > 6.65) col4 = vec4 (1., 1., 0.3, -1.);\n  } else if (idObj == idRig) {\n    col4 = vec4 (0.2, 0.15, 0.1, 0.);\n  }\n  return col4;\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd;\n  rd = normalize (vec3 (rd.x, max (0.001, rd.y), rd.z));\n  ro.xz += tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  return mix (vec3 (0.2, 0.3, 0.65) + 0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.), vec3 (0.9),\n     clamp (3. * (Fbm2 (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz)) - 0.5) * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, qh, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV;\n  InCylHit (ro + vec3 (0., - bCylHt + 1.25, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = (ro.y - 1.75) / bCylHt;\n    hhy = abs (hy) - 0.43;\n    aa = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (64. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else col = vec3 (0.5, 0.5, 0.3) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.8, 0.7, 0.5);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        qw = 16. * vec2 (12. * aa, hy);\n        rg = ShStagGrid (qw);\n        col *= rg.y * (1. - 0.3 * Noisefv2 (8. * qw));\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.4 + 0.6 * max (dot (vn, sunDir), 0.)) +\n         0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n    qh = HexGrid (4. * ro.zx);\n    f = max (length (qh.xy) - 0.5, 0.) * b;\n    vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vn = VaryNf (64. * ro, vn, 0.2 * b);\n    col = vec3 (0.72, 0.75, 0.72) * (1. - 0.1 * b * Noisefv2 (128. * ro.xz)) *\n       (1. - min (0.2 * b * (1. - smoothstep (0.03, 0.06, qh.z)), 0.1));\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n       0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    col *= 0.7 + 0.3 * ObjSShadow (ro, sunDir);\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  float dstObj, reflAtn;\n#if MORE_REFL\n  const int nRef = 4;\n#else\n  const int nRef = 3;\n#endif\n  bCylRad = 16.;\n  bCylHt = 3.;\n  szFac = 0.5;\n  EvalShipConf ();\n  reflAtn = 1.;\n  for (int nr = 0; nr < nRef; nr ++) {\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      col4 = ShipCol ();\n      reflAtn *= 0.7 + 0.2 * smoothstep (0.1, 0.2, max (col4.r, max (col4.g, col4.b)));\n      if (nr == nRef - 1) break;\n      ro += rd * dstObj;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.01 * rd;\n    } else break;\n  }\n  return clamp (reflAtn * BgCol (ro, rd), 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 20.;\n  bCylRad = 16.;\n  bCylHt = 3.;\n  az = -0.75 * pi + (1.2/16.) * pi * (floor (0.2 * tCur) + smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  el = 0.04 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.015 * pi, 0.35 * pi);\n  rd = normalize (vec3 (uv, 4.));\n  ro = vec3 (0., 0., -0.75 * bCylRad);\n  ro.yz = Rot2D (ro.yz, el);\n  rd.yz = Rot2D (rd.yz, el);\n  ro.xz = Rot2D (ro.xz, az);\n  rd.xz = Rot2D (rd.xz, az);\n  ro.y += 0.5;\n  sunDir = normalize (vec3 (-1., 2., -1.));\n  sunDir.yz = Rot2D (sunDir.yz, el);\n  sunDir.xz = Rot2D (sunDir.xz, az);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  return PrEVCapsDf (p - v1, vec4 (normalize (v2 - v1), length (v2 - v1)), r);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljfzw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1093, 1132, 1132, 2324], [2326, 2326, 2365, 2365, 3348], [3350, 3350, 3389, 3389, 4414], [4416, 4416, 4454, 4454, 5755], [5757, 5757, 5779, 5779, 6043], [6045, 6045, 6067, 6067, 7183], [7185, 7185, 7218, 7218, 7394], [7396, 7396, 7417, 7417, 7617], [7619, 7619, 7656, 7656, 7867], [7869, 7869, 7886, 7886, 10683], [10685, 10685, 10719, 10719, 11240], [11242, 11242, 11274, 11274, 11593], [11595, 11595, 11621, 11621, 11971], [11973, 11973, 12004, 12004, 14832], [14834, 14834, 14869, 14869, 15462], [15464, 15464, 15520, 15520, 16413], [16415, 16415, 16447, 16447, 16547], [16549, 16549, 16582, 16582, 16671], [16673, 16673, 16716, 16716, 16780], [16782, 16782, 16826, 16826, 16895], [16897, 16897, 16951, 16951, 17032], [17034, 17034, 17076, 17076, 17127], [17129, 17129, 17153, 17153, 17383], [17385, 17385, 17409, 17409, 17469], [17471, 17471, 17494, 17494, 17627], [17629, 17629, 17674, 17674, 17777], [17779, 17779, 17836, 17836, 17919], [17921, 17921, 17951, 17951, 18009], [18043, 18043, 18067, 18067, 18197], [18199, 18199, 18224, 18224, 18410], [18412, 18412, 18433, 18433, 18588], [18590, 18590, 18619, 18619, 18831], [18833, 18833, 18872, 18872, 19056]], "test": "untested"}
{"id": "4ljyWW", "name": "Triwave", "author": "Vovosunt", "description": "...", "tags": ["triangles"], "likes": 10, "viewed": 202, "published": "Public", "date": "1515262449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define c30     (1.0 / 0.86602540378)\t\n#define thick   1.\n#define PI      3.14159265359\n#define grid    20.0\n#define timeScale 0.25\n#define rt (timeScale * iTime)\n#define shadSt  0.6\n#define smooth (20./iResolution.x)\n\nfloat rand(vec3 v){\n    return fract(cos(dot(v,vec3(13.46543,67.1132,123.546123)))*43758.5453);\n}\nfloat rand(vec2 v){\n    return fract(sin(dot(v,vec2(5.11543,71.3132)))*43758.5453);\n}\n\nfloat triGrid(vec2 p, float scale, float sm, float toff){\n    float sc = abs(fract((length(p) + rt + toff*rt))-0.5)*2.0;\n    float th = thick * sc/2.0;//sin(rt)*sc;\n    float stx = (p.x +  c30 / 2.0 * p.y) * scale;\n    stx = abs(fract( stx) - 0.5);\n   \t\n    float sty = (p.x -  c30 / 2.0 * p.y) * scale;\n    sty = abs(fract( sty) - 0.5);\n    float sth = abs(fract(p.y * scale * c30) - 0.5);\n    \n    float col = smoothstep(sm, -sm,stx - 0.5 + th);\n\tcol *= smoothstep(sm, -sm,sty - 0.5  + th);\n\tcol *= smoothstep(sm, -sm,sth - 0.5  + th);\n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (gl_FragCoord.xy - 0.5 * iResolution.xy)/iResolution.x;\n    \n    vec3 finCol = vec3(triGrid(st,grid,smooth,0.03),\n                      triGrid(st,grid,smooth,0.11),\n                      triGrid(st,grid,smooth,0.17)\n                      );\n    \n    fragColor = vec4(finCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljyWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 238, 238, 316], [317, 317, 336, 336, 402], [404, 404, 461, 461, 969], [972, 972, 1028, 1028, 1325]], "test": "untested"}
{"id": "4lSBDK", "name": "Water Floor", "author": "domvalles", "description": "Water Floor shader, cut off top part of fbm with some domain distortion. Might switch to voronoi. Undecided.", "tags": ["simple", "water"], "likes": 2, "viewed": 153, "published": "Public", "date": "1517158461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1457\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    float value = mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n    return value;\n}\n\n#define NUM_ITERATIONS 3\n\nfloat fbm(in vec2 uv){\n \n float amplitude = .5;\n float gain = .5;\n float lacunarity = 2.;\n float frequency = 1.;\n    \n float res = 0.;\n for (int x = 0; x < NUM_ITERATIONS; x++){\n\tres += amplitude * noise(frequency*uv);\n\tfrequency *= lacunarity;\n\tamplitude *= gain;\n }\n return res;\n}\n\n#define EPS 1.e-1\n#define NORMAL(UV,FUNC)\tvec2 dx = vec2(EPS,0.); vec3 t = vec3(EPS, FUNC(uv+dx),0.); vec3 s = vec3(-EPS, FUNC(uv-dx),0.); vec3 uv_dx = normalize((t - s)); vec2 dz = vec2(0.,EPS);t = vec3(0., FUNC(uv+dz),EPS);s = vec3(0.,FUNC(uv-dz),-EPS); vec3 uv_dz = normalize((t - s)); vec3 normal = cross(uv_dx, uv_dz); \n\nvec2 getGradient(in vec2 uv)\n{\n vec2 uv_dx2 = vec2(uv.x + EPS, uv.y);\n vec2 uv_dx1 = vec2(uv.x - EPS, uv.y);\n vec2 uv_dy2 = vec2(uv.x, uv.y + EPS);\n vec2 uv_dy1 = vec2(uv.x, uv.y - EPS);\n float dx = (fbm(uv_dx2) - fbm(uv_dx1))/2.*EPS;\n float dy = (fbm(uv_dy2) - fbm(uv_dy1))/2.*EPS;\n return vec2(dx,dy)*100.;\n}\n\nvec3 getNormal(in vec2 uv)\n{\n    //dx\n    vec2 dx = vec2(EPS,0.);\n    vec3 t = vec3(EPS,fbm(uv+dx),0.);\n    vec3 s = vec3(-EPS, fbm(uv-dx),0.);\n    vec3 uv_dx = normalize((t - s));\n    \n    //dy\n    vec2 dz = vec2(0.,EPS);\n    t = vec3(0.,fbm(uv+dz),EPS);\n    s = vec3(0.,fbm(uv-dz),-EPS);\n    vec3 uv_dz = normalize((t - s));\n    return cross(uv_dx, uv_dz);\n}\n\nvec3 blue = vec3(40.,134.,150.)/255.*.8;\nvec3 sunDir = normalize(vec3(1.,1.,1.));\n\nvec2 rotateOrigin(in vec2 uv, float rotation)\n{\n    mat2 rotate = mat2(cos(rotation),-sin(rotation),\n        \tsin(rotation),cos(rotation));\n    return rotate*uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 10.;\n    //uv += vec2(1.,0.)*iTime;\n    vec2 gradient = getGradient(uv);\n    float fbm = abs(-.5 + fbm(uv + .12*fbm( uv + vec2(1.,1.)*iTime)));\n    float gLength = length(gradient);\n    float st = smoothstep(0.,1., ((.041 - fbm)/gLength)/((.041-.02)));\n    //float st = step(fbm, .04);\n    //vec3 normal = -getNormal(uv);\n    //vec3 refrac = refract(vec3(0.,1.,0.), normal, 1.33/1.);\n    //float sn = clamp(dot(sunDir, refrac), 0., 1.);\n    //float res = step(sn, .001);\n    vec3 col;\n    col = mix(blue, vec3(1.), st);\n    vec4 color = vec4(col, 1.);\n\tfragColor = color;\n   // fragColor = vec4(gradient, 0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSBDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 46, 46, 163], [165, 165, 191, 191, 733], [761, 761, 783, 783, 1043], [1371, 1371, 1401, 1401, 1681], [1683, 1683, 1711, 1720, 2043], [2128, 2128, 2175, 2175, 2291], [2293, 2293, 2350, 2350, 3017]], "test": "untested"}
{"id": "4lSBDR", "name": "Exit routine", "author": "w23", "description": "Simplest, dumbest and slowest naive path tracer, coded in 2.5 hours live (mostly in Russian): https://www.youtube.com/watch?v=QDeR9vFKL8s", "tags": ["pathtracer"], "likes": 16, "viewed": 415, "published": "Public", "date": "1515229623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 e = vec3(0., .001, 1.);\nvec4 noise2x4(in vec2 v) { return texture(iChannel0, v/256.); }\nfloat noise2x1l(in vec2 v) {\n    vec2 V = floor(v); v = fract(v);\n    //v *= (3. - 2.*v) * v;\n    return mix(\n        mix(noise2x4(V     ).x, noise2x4(V+e.zx).x, v.x),\n        mix(noise2x4(V+e.xz).x, noise2x4(V+e.zz).x, v.x), v.y);\n}\n\nfloat fbm(in vec2 v) {\n    return .5 * noise2x1l(v)\n        + .25 * noise2x1l(v*2.)\n        + .125 * noise2x1l(v*4.)\n        + .0625 * noise2x1l(v*8.);\n}\n\nvec3 P = vec3(0.);\nvec3 N = vec3(1.);\nvec3 E = vec3(0.);\nvec4 A = vec4(vec3(1.),1.);\n\n#define INF 1e6\n\nconst vec3 BOX_SIZE = vec3(2.5, 3., 3.) / 2.;\n\nvoid raytrace(in vec3 o, in vec3 d) {\n    P = vec3(0.);\n\tN = vec3(1.);\n\tE = vec3(0.);\n    \n    vec4 defA = vec4(vec3(.6),.9+.099*sin(iTime*1.7));\n\n    float dist = INF, cd = INF;\n    if (abs(d.y) > 1e-6) {\n        cd = (-BOX_SIZE.y - o.y) / d.y;\n        if (cd > .0 && cd < dist) {\n            dist = cd;\n            P = o + d * dist;\n            N = vec3(0., 1., 0.);\n            A = vec4(vec3(.2), 0.);\n        }\n        cd = (BOX_SIZE.y - o.y) / d.y;\n        if (cd > 0. && cd < dist) {\n            dist = cd;\n            P = o + d * dist;\n            N = vec3(0., -1., 0.);\n            A = vec4(vec3(.2), 0.);\n        }\n    }\n    \n    if (abs(d.x) > 1e-6) {\n        cd = (BOX_SIZE.x - o.x) / d.x;\n        if (cd > .0 && cd < dist) {\n            dist = cd;\n            P = o + d * dist;\n            A.xyz = vec3(.3)*smoothstep(.95,.94,mod(P.z*3.,1.));\n            A.w = .7;// + .1*fbm(P.yz*8.);\n            N = normalize(vec3(-1., 0., .1*(pow(fbm(P.yz*3.*vec2(1.,3.)),2.)*2. - 1.)));\n        }\n        cd = (-BOX_SIZE.x - o.x) / d.x;\n        if (cd > 0. && cd < dist) {\n            dist = cd;\n            P = o + d * dist;\n            A.xyz = vec3(.3)*smoothstep(.95,.94,mod(P.z*3.,1.));\n            A.w = .7;// + .1*fbm(P.yz*8.);\n            //N = normalize(vec3(1., 0., .05*(pow(fbm(P.yz*19.),1.)*2. - 1.)));\n            N = normalize(vec3(1., 0., .1*(pow(fbm(P.yz*3.*vec2(1.,3.)),2.)*2. - 1.)));\n        }\n    }\n    \n    if (abs(d.z) > 1e-6) {\n        cd = (BOX_SIZE.z - o.z) / d.z;\n        if (cd > .0 && cd < dist) {\n            dist = cd;\n            P = o + d * dist;\n            N = vec3(0., 0., -1.);\n            A = defA;\n        }\n        cd = (-BOX_SIZE.z - o.z) / d.z;\n        if (cd > 0. && cd < dist) {\n\t        A = vec4(0.);\n            dist = cd;\n            P = o + d * dist;\n            N = vec3(0., 0., 1.);\n            const float pixel_size = BOX_SIZE.x / 32.;\n            vec2 nc = P.xy/pixel_size+floor(iTime*.5)*32.;\n            E = 4.*vec3(\n                smoothstep(.8,.82,noise2x4(nc).w),\n                smoothstep(.8,.82,noise2x4(nc+e.xz*.5).w),\n                smoothstep(.8,.82,noise2x4(nc+e.xz).w)\n            );\n        }\n    }\n}\n\nvec3 colorSample(in vec3 O, in vec3 D, in float hash) {\n    vec3 albedo = vec3(1.);\n    vec3 color = vec3(0.);\n    for (int i = 0; i < 3; ++i) {\n    \traytrace(O, D);\n        color += albedo * E;\n        albedo *= A.xyz;\n        \n        O = P + N * .001;\n        vec2 s = 110. * (vec2(dot(O, vec3(1.,3.,5.))+ hash, hash + dot(O, vec3(17.,53.,119.))) + iTime);\n        vec3 nD = normalize(noise2x4(s).xyz*2. - 1.);\n        D = mix(nD, reflect(D, N), A.w);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n   \tvec3 O = vec3(cos(iTime*.1)*.8, sin(iTime*.23)*.6, 0. + sin(iTime*.47)*.8);\n    vec3 D = normalize(vec3(uv, -1.));\n    \n    vec3 color = vec3(0.);\n    const int SAMPLES = 16;\n    for (int i = 0; i < SAMPLES; ++i)\n        color += colorSample(O, D, float(i));\n    \n    color /= float(SAMPLES);    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSBDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 55, 55, 92], [93, 93, 121, 121, 326], [328, 328, 350, 350, 481], [633, 633, 670, 670, 2800], [2802, 2802, 2857, 2857, 3287], [3289, 3289, 3346, 3346, 3801]], "test": "untested"}
{"id": "4lSBWm", "name": "omega beats", "author": "sunilpro", "description": "Idle mode beats sync", "tags": ["beatwave"], "likes": 2, "viewed": 160, "published": "Public", "date": "1515953777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    \n    float beat = texture( iChannel0, vec2( 0.001, 0.25 ) ).x / 2.0;\n    float dt = 1.5;//fract(iTime/5.)*2.;\n    float time = PI*dt*2.;\n   \n\tfloat cLength = length(uv)/(1.-beat);\n    float offset = (uv.y/(cLength))*sin(cLength*PI*2.*4.-time)*4.;\n \n    if(cLength <= (0.115+(dt*1.)/(PI*1.25)) && cLength >= (dt/(PI*1.75)))\n    \tfragColor = vec4(0.96, 0.96, 0.96, 1.0) + offset/32.;\n    else\n        fragColor = vec4(0.96, 0.96, 0.96, 1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 587]], "test": "untested"}
{"id": "4lSBzm", "name": "Weaved 3D Truchet", "author": "Shane", "description": "Mapping a square Truchet pattern onto an overlapping, interwoven hexagonal Truchet object.", "tags": ["3d", "raymarching", "truchet", "bump", "weave"], "likes": 133, "viewed": 2878, "published": "Public API", "date": "1515157386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tWeaved 3D Truchet\n\t-----------------\n\t\n\tMapping a square Truchet pattern onto an overlapping, interwoven hexagonal Truchet object... \n\tor if you prefer a more lively description, it's an abstract representation of pythons. :) \n\tI can thank BigWIngs's \"Hexagonal Truchet Weaving\" example for the idea to do this.\n\n\tI produced a relatively simple scene, just to give people an idea, but it's possible to\n\tcreate some really cool organic structures this way.\n\n\tCoding the main object wasn't particularly difficult, but bump mapping the square Truchet\n\tpattern onto it was a little tiresome. I originally applied the pattern directly to the \n\tobject via the distance field equation, but I don't think slower machines would have\n\tenjoyed running it. Therefore, I took the surface pattern outside the raymarching loop and \n\tbump mapped it.\tThat, of course, added to the complexity, but sped things up considerably. \n\tMy fast machine\tcan run it in fullscreen fine, but the example was targetted toward the \n\t800 by 450 canvas -- which I'm hoping average systems will be able to run it in.\n \n\tProcedurally speaking, this is just a 3D application of a standard hexagonal weave, which \n\tI explained in my \"Arbitrary Weave\" example. For anyone interested in producing one, I'd \n\tsuggest starting with a 2D pattern, then taking it from there. Feel free to use this as a \n\tguide, but I doubt it'll be needed.\n\n\tThe comments, code and logic were a little rushed, so I'll get in and tidy it up in due \n\tcourse.\n\n\n\t2D Weaved Truchet examples:\n\n\t// The original: Much less code, so if you're trying to get a handle on how to make\n\t// a random hexagonal weave pattern, this is the one you should be looking at.\n\tBigWIngs - Hexagonal Truchet Weaving \n\thttps://www.shadertoy.com/view/llByzz\n\n\t// My version of BigWIngs's example above. The code in this particular example was\n\t// based on it.\n\tArbitrary Weave - Shane\n\thttps://www.shadertoy.com/view/MtlBDs\n\n\n*/\n\n#define FAR 15.\n\n// Just a regular hexagonal Truchet tile consisting of three small arcs.\n//#define NO_WEAVE\n\n// A geometric hack to show the hexagonal grid.\n//#define SHOW_GRID\n\nfloat objID = 0.; // Object ID - Ground: 0; Truchet: 1.\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0);\n    \n    //return vec2(sin(z * 0.15)*1.2, cos(z * 0.25)*.85); \n    \n    return vec2(sin(z * 0.15)*2.4, 0);\n}\n\n// Standard float to float hash -- Based on IQ's original.\nfloat hash(float n){ return fract(sin(n)*43758.5453); }\n\n\n// Standard vec2 to float hash -- Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.187, 289.973)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n); \n    \n    /*\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime )*.5 + .5; \n\t*/\n    \n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + vec4(.5, .5, 1, 1.5);\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + vec2(0, -.5))*s );\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw);\n    \n}\n\n\n// Very basic square Truchet routine.\nfloat sTruchet(vec2 p){\n    \n    // Unique coordinate.\n    vec2 ip = floor(p);\n    \n    float rnd = hash21(ip); // Random ID.\n\n    // Square grid. Equivalent to: p = fract(p) - .5;\n    p -= ip + .5;\n    \n    // Random tile flipping.\n    p.y *= (rnd >.5)? -1. : 1.;\n    \n    // Repeat space trick - to save rendering two arcs.\n    // I explained it in detail in my \"Square Truchet Flow\" example.\n    p = p.x>-p.y ? p : -p; \n    \n\n    // Arc(s) of thickness \".15.\"\n    float d = abs(length(p - .5) - .5) - .15;\n    \n    // Shaping it to suit individual needs.\n    return mix(max(-d, 0.)*.35, smoothstep(0., .125, d), .5);\n    \n}\n\n\n// Poloidal distance function -- The cross section of the torus. It can be cylindrical,\n// square, hexagonal, octagonal, etc. To save calculations, some of these are distance\n// bounds, rather than proper fields, so they can potentially interfere with things like \n// shadows, and so forth.\nfloat polDist(vec2 p){\n\n    return length(p);\n    \n    /*\n    // Square cross section.\n    p = abs(p);\n    return max(p.x, p.y);\n\t*/\n    \n    /*\n    // Hexagonal cross section.\n    //p = abs(p);\n    //return max(p.x*.8660254 + p.y*.5, p.y);\n\t*/\n\n    /*\n    // Octagonal cross section.\n    p = abs(p);\n    return max(max(p.x, p.y), (p.x + p.y)*.7071);\n    */\n    \n    /*\n    // Dodecahedral cross section.\n    p = abs(p);\n    vec2 p2 = p.xy*.8660254 + p.yx*.5;\n    return max(max(p2.x, p2.y), max(p.y, p.x));\n    */\n}\n\n// Toroidal distance function -- The sweeping section of the torus. It can be cylindrical,\n// square, hexagonal, octagonal, etc.\nfloat torDist(vec2 p){\n    \n    return length(p);\n    \n    /*\n    // Hexagon arcs.\n    p = abs(p);\n    return max(p.x*.8660254 + p.y*.5, p.y);\n    */\n    \n    /*\n    // Dodecahedral arcs.\n    p = abs(p);\n    vec2 p2 = p.xy*.8660254 + p.yx*.5;\n    return max(max(p2.x, p2.y), max(p.y, p.x));\n    */\n\n      \n    \n}\n\n// Shade, pattern and random ID globals. Hacked in along the way. I might tidy these up later.\nvec4 gHgt, gA, gA2, gD;\n//vec4 gRnd;\n\nvec4 Truchet(vec2 p){\n    \n    // Initialize the height vector to zero.\n    gHgt = vec4(0);\n    \n    // Scaling, translating, then converting the input to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    vec4 h = getHex(p);\n    \n    \n    #ifdef SHOW_GRID\n    // Offset hexagonal variable -- used to render the joins. You could render them using the\n    // value above, but sometimes, pixelated seem lines can appear at the hexagonal boundaries\n    // when trying to perform offset diffuse calculations... It's a long story, but creating\n    // an offset grid ensures no artefacts.\n    vec4 h2 = getHex(p - vec2(0, .8660254*2./3.));\n    #endif\n    \n    // Using the idetifying coordinate -- stored in \"h.zw,\" to produce some unique random numbers\n    // for the hexagonal grid cell.\n    vec2 rnd = hash22(h.zw + .673);\n     \n    // Store the hexagonal coordinates in \"p\" to save some writing. \"p\" tends to be the universal\n    // shader variable for \"point,\" so it reads a little better too.\n    p = h.xy;\n    \n\n    \n    // Constants used for the Truchet pattern. The arc thickness, the small are radius and the large\n    // arc radius.\n    //const float th = 0.;//.1; // Applying tube thickness outside the function.\n    const float rSm = .8660254/3.;\n    const float rLg = .8660254;\n    \n    float a; // Storage for the arc angle, which is used for height, etc.\n    \n    \n    // Randomly rotate the tile.\n    float rFactor = floor(rnd.x*6.)*3.14159265/3.;\n    p = r2(rFactor)*p;\n    \n    float hDir = rnd.y>.5? -1.: 1.;\n    \n \n    // Distance field variable, and a hacky flag to turn off pattern rendering -- Basically, to stop the \n    // portals being rendered under the joins.\n    vec4 d;\n    \n    // Utils for point storage and the UV coordinates for each of the shapes.\n    vec2 p1, p2, p3;\n    \n    \n    // DISTANCE FIELD, ID, AND TEXTURE CALCULATIONS\n    \n    // If one of the random variables is above a certain threshold, render one of the\n    // tiles. The thresholds are distributed according to how much weighting you'd like\n    // to give a certain kind of tile. For instance, I wanted more curves, so gave more\n    // weighting to the arc tiles than the straight line ones.\n    \n    \n    #ifdef NO_WEAVE\n     \n    // Small arc one.        \n    p1 = p - vec2(.5, .8660254/3.);\n    d.x = torDist(p1) - rSm;        \n\n    d.x = abs(d.x);\n    a = atan(p1.y, p1.x);\n    gA.x = a;\n    // One dot per small arc segment. Three make up a circle.\n    //gRnd.x = hash21(h.zw + floor(a/6.283*3.));\n    //a = mod(a/3.14159265, 2.) - 1.;\n\n    // Small arc two.\n    p2 = p - vec2(-.5, .8660254/3.);\n    d.y = torDist(p2) - rSm;\n\n    d.y = abs(d.y);\n    a = atan(p2.y, p2.x);\n    gA.y = a;\n    //gRnd.y = hash21(h.zw + floor(a/6.283*3.) + 7.45);\n    //a = mod(a/3.14159265, 2.) - 1.;\n\n    // Small arc three.\n    p3 = p - vec2(0, -.8660254*2./3.);\n    d.z = torDist(p3) - rSm;\n\n    d.z = abs(d.z);\n    a = atan(p3.y, p3.x);\n    gA.z = a;\n    //gRnd.z = hash21(h.zw + floor(a/6.283*3.) + 9.23);\n    //a = mod(a/3.14159265, 2.) - 1.;\n    \n    //d.xyz -= th;\n         \n         \n\t#else\n \n    // Large arc one.\n    p1 = p - vec2(1, 0); \n    a = atan(p1.y, p1.x); // Longer arc.\n    gA.x = a*3.;\n    d.x = torDist(p1) - rLg;\n    d.x = abs(d.x);\n    //gRnd.x = hash21(h.zw + floor(a/6.283*6.) + 8.71);\n    gHgt.x = (cos(a*6.) + 1.)*.05*hDir;\n    //a = mod(a/3.14159265, 2.) - 1.;\n    //hgt.x = (1. - abs(a*6.));\n    //hgt.x = smoothstep(.0, .95, hgt.x)*hDir*.1;\n\n\n\n    // Large arc two.\n    p2 = p - r2(3.14159265/3.)*vec2(1, 0);\n    a = atan(p2.y, p2.x); // Longer arc.\n    gA.y = a*3.;\n    d.y = torDist(p2) - rLg;\n    d.y = abs(d.y);\n    //gRnd.y = hash21(h.zw + floor(a/6.283*6.) + 3.87);\n    gHgt.y = -(cos(a*6.) + 1.)*.05*hDir;\n    //a = mod(a/3.14159265, 2.) - 1.;\n    //hgt.y = (1. - abs(a*6. + 2.));\n    //hgt.y = -smoothstep(.0, .95, hgt.y)*hDir*.1;\n\n\n    // Small arc.\n    p3 = p - r2(-3.14159265/3.)*vec2(0, .57735);\n    a = atan(p3.y, p3.x); // Smaller arc.\n    gA.z = a;\n    d.z = torDist(p3) - rSm;\n    d.z = abs(d.z);\n    //gRnd.z = hash21(h.zw + floor(a/6.283*3.) + 5.54);\n    //a = mod(a/3.14159265, 2.) - 1.;\n    \n    //d.xyz -= th;\n\n    \n    #endif\n    \n    \n/////\n    \n    #ifdef SHOW_GRID\n    \n    // JOINER BLOCKS\n    //\n    // The joins need to be rendered seperately using an offset hexagonal grid, due to pixelated \n    // mismatching at the hexagonal boundaries when highlighting... It's a long story... :)\n    //\n    // Three blocks, arranged in a tri blade propellor scheme. \n    //     \n    vec2 q = h2.xy;\n    float blc = abs(length(q) - .8660254/3.);// - th;\n    \n    q = r2(3.14159/6.)*q;\n    a = atan(q.y, q.x);\n    float ia = floor(a/6.283*3.) + .5;\n    q = r2(ia*6.283/3.)*q;\n    q.x -= .8660254/3.;\n        \n    q = abs(q);// - vec2(th, .04);\n    // q.x = abs(q.x - .08);// - .2;\n    \n    // Holding the joiner block distance field value in a global variable to be \n    // used elsewhere.\n    // The weird mix function gives the joins a slight pinch at the ends to feed the illusion a little more.\n    //d.w = mix(length(q) - .04, max(q.x - .15, q.y - .04), .9);\n    d.w = max(q.x - .2, q.y - .02);//\n    //d.w = length(q.xy) - .2;//.06333;//\n    //float blocks = mix(length(q) - .04, min(max(q.x - .15, q.y - .04), 0.) + length(max(q - vec2(.15, .04), 0.)), .9);\n    // The shade value (used for highlighting) has been tweaked in an unnatural way to give the reflected\n    // look I was after, but I wouldn't put too much stock in it.\n    \n    #endif\n    \n    return d;\n    \n    \n}\n\n\n\n\n// Distance field function.\nfloat m(vec3 p){\n    \n    \n    //p.xy -= path(p.z);\n    \n    //float sf = .5;//dot(sin(p*3. - cos(p.yzx*3.)), vec3(.333));\n    \n    // Moving the scene down a bit... I should probably move the camera up. :)\n    p.y += 1.5;\n    \n    \n    // The floor plane. Set roughly at the bottom of the Truchet object.\n    float fl = .25 + p.y;// + (.5 - sf)*.5;\n    \n    \n    // The hexagonal Truchet object -- weaved or otherwise.\n    const float sc = 1.;\n    vec4 d = Truchet(p.xz*sc);\n \n\t// The Truchet function above retuns the toroidal arc distances, which have the poloidal\n    // function applied to produce the torus like arcs. There are three arcs in all.\n    d.x = polDist(vec2(d.x/sc, p.y + gHgt.x));\n    d.y = polDist(vec2(d.y/sc, p.y + gHgt.y));    \n    d.z = polDist(vec2(d.z/sc, p.y + gHgt.z));  \n    \n    d.xyz -= .16/sc; // Give the torus-like arcs some thickness.\n    \n    \n    gD = d; // Storing all three distance functions above into a global to be used elsewhere.\n    \n    \n    // The Truchet object distance, which is the minimum of the three arcs.\n    float ob = min(min(d.x, d.y), d.z);\n \n    // Smoothly imprinting the Truchet object into the floor a bit. Not sure why, but it seemed\n    // like a good idea at the time. :)\n    fl = smax(fl, -ob*2., .5) - .2;\n    \n    // Hacky hexagonal grid display.\n    #ifdef SHOW_GRID\n    d.w = max(d.w/sc, p.y - .25);\n    fl = min(fl, d.w);\n    #endif\n \n    // Object ID: Either the floor or the Truchet object.\n    objID = fl<ob? 0. : 1.;\n    \n    // Return the minimum distance.\n    return min(fl, ob);\n    \n}\n\n\n// This is an exact duplicate of the distance function with some \"atan\" calculations thrown in. It's a bit\n// of a waste of code, but worth it to take the three \"atan\" calculations out of the distance function\n// loop... but such a character waste. I'll try to amalgamate some things later.\nfloat m2(vec3 p){\n    \n    \n    //p.xy -= path(p.z);\n    \n    //float sf = .5;//dot(sin(p*3. - cos(p.yzx*3.)), vec3(.333));\n    \n    // Moving the scene down a bit... I should probably move the camera up. :)\n    p.y += 1.5;\n    \n    \n    // The floor plane. Set roughly at the bottom of the Truchet object.\n    float fl = .25 + p.y;// + (.5 - sf)*.5;\n    \n    \n    // The hexagonal Truchet object - weaved or otherwise.\n    const float sc = 1.;\n    vec4 d = Truchet(p.xz*sc);\n    \n    \n    gA2.x = atan(p.y + gHgt.x, d.x/sc);\n    gA2.y = atan(p.y + gHgt.y, d.y/sc);\n    gA2.z = atan(p.y + gHgt.z, d.z/sc);\n\n\t\n\t// The Truchet function above retuns the toroidal arc distances, which have the poloidal\n    // function applied to produce the torus like arcs. There are three arcs in all.\n    d.x = polDist(vec2(d.x/sc, p.y + gHgt.x));\n    d.y = polDist(vec2(d.y/sc, p.y + gHgt.y));    \n    d.z = polDist(vec2(d.z/sc, p.y + gHgt.z));  \n    \n    d.xyz -= .16/sc; // Give the torus-like arcs some thickness.\n    \n    \n    gD = d; // Storing all three distance functions above into a global to be used elsewhere.\n    \n    \n    // The Truchet object distance, which is the minimum of the three arcs.\n    float ob = min(min(d.x, d.y), d.z);\n \n    // Smoothly imprinting the Truchet object into the floor a bit. Not sure why, but it seemed\n    // like a good idea at the time. :)\n    fl = smax(fl, -ob*2., .5) - .2;\n    \n    // Hacky hexagonal grid display.\n    #ifdef SHOW_GRID\n    d.w = max(d.w/sc, p.y - .25);\n    fl = min(fl, d.w);\n    #endif\n \n    // Object ID: Either the floor or the Truchet object.\n    objID = fl<ob? 0. : 1.;\n    \n    // Return the minimum distance.\n    return min(fl, ob);\n    \n}\n\n\n/////////\n// The bump function.\nfloat bumpFunc(vec3 p, vec3 n){\n    \n    // Place a square Truchet pattern on the ground, or the wrap it around\n    // the snake-like Truchet object.\n\n \n    \n    float d = m2(p);\n    \n    float c = 0.;\n    \n    if(objID<.5) {     \n        \n        c =  sTruchet(p.xz*6.);//*.95 +  sTruchet(p.xz*12.)*.05;\n         \n    }\n    else {\n    \n        // Obtain the nearest toroidal and poloidal angles, convert them to cylindrical\n        // coordinates, then pass them to a wrappable function. In this case, it's a simple\n        // square Truchet function.\n        float a;\n        float a2;\n\n        if(gD.x<gD.y && gD.x<gD.z){\n            a = gA.x;\n            a2 = gA2.x;\n        }\n        else if(gD.y<gD.z){\n            a = gA.y;\n            a2 = gA2.y;\n        }\n        else {\n            a = gA.z;\n            a2 = gA2.z;\n\n        }\n\n        // \"a2\" represents the toroidal axis, and \"a\" the poloidal axis. Due to the nature of the hexagonal\n        // Truchet geometry, \"a\" needs to be a multiple of 12, in most cases. \"a2\" is more flexible, but needs\n        // to be a multiple of 4, in this particular case... 6 might work with an offset.\n\n        c = sTruchet(vec2(a2*8., a*12.)/6.283);\n        //c = sTruchet(vec2(a2*12., a*24.)/6.283); // More detailed, but a little too busy.\n        \n\n        // More interesting, but a little too busy for this example.\n        //c = sTruchet(vec2(a2*8., a*12.)/6.283)*.975 + sTruchet(vec2(a2*16., a*24.)/6.283)*.025;\n\n        // For testing purposes.\n        //c = (cos(a*12.) + cos(a2*8.))*.05 + .1;\n        \n        \n    }\n   \n   \n    \n    //float c = min(min(svGd.x, svGd.y), svGd.z);\n    // Note that I could perform two returns and dispense with the float declaration,\n    // but some graphics cards used to complain. I think all of them should be\n    // fine now, but just in case.\n    return c;//*.998 + n3D(p*192.)*.002; \n\n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(1./iResolution.y, 0); \n    \n    float f = bumpFunc(p, n); // Hit point function sample.\n    \n    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.\n    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.\n    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.\n    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x*2.);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .5, 0., 2.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n\n\n////////\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 nr(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * m(p + e.xyy) + e.yyx * m(p + e.yyx) + e.yxy * m(p + e.yxy) + e.xxx * m(p + e.xxx));\n}\n*/\n\n\n// Standard normal function -- for comparison with the one below.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\tm(p + e.yyx) - m(p - e.yyx)));\n}\n\n\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing -- in a setting like this -- with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat shad(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = m(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)\n    return min(max(shade, 0.), 1.); \n}\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = m(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n\n// Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    vec3 col = pow(vec3(1.5, 1, 1)*c, vec3(1, 2.5, 12)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25 + .25); \n    \n}\n\nvoid mainImage(out vec4 fCol, vec2 fCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fCoord - iResolution.xy*.5) / iResolution.y;\n    \n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, iTime*1.);  // \"Look At\" position.\n\tvec3 o = lk + vec3(0, .3, -.25); // Camera position, doubling as the ray origin.\n\n   \n    // Light position. Set in the vicinity the ray origin.\n    vec3 l = o + vec3(0, .5, 2.);\n    \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlk.xy += path(lk.z);\n\to.xy += path(o.z);\n\tl.xy += path(l.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-o);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // r - Ray direction.\n    vec3 r = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    /////////\n    \n    // Standard raymarching routine.\n    float d, t = 0.;\n    \n    for(int i=0; i<96;i++){\n        \n        d = m(o + r*t);\n        // There isn't really a far plane to go beyond, but it's there anyway.\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n\n    }\n    \n    t = min(t, FAR);\n    \n    // Save the object ID right after the final distance function call.\n    float svID = objID;\n    \n    \n    // Set the initial scene color to black.\n    vec3 col = vec3(0);\n    \n     \n    if(t<FAR){\n    \n        // Hit point and normal at the hit point.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Bump mapping with bumped edging and curvature -- The latter isn't used here.\n        float edge2 = 0., crv2 = 1., bf = .25; \n        //if(svID<.5) bf = .5;\n        n = doBumpMap(p, n, bf, edge2, crv2); ///(1. + t/FAR*.125)\n        \n        \n        // Shadows and ambient occlusion.\n        float sh = shad(p + n*.002, l, 16., t);\n        float ao = cAO(p, n);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n \n        \n        // Texture value at the surface. Use the heighmap value above to distort the\n        // texture a bit.\n        float txSc = .5;\n        vec3 tx = tex3D(iChannel0, (p*txSc), n);\n        tx = smoothstep(.0, .5, tx);\n\n       \n        col = tx; //vec3(1)*fBm; // Initializing to the texture color.\n         \n        // Addind a sprinking of noise. The scene looks a little too clean without it.\n        float fBm = n3D(p*128.)*.66 + n3D(p*256.)*.34;\n        col *= mix(vec3(0), vec3(1), fBm*2.*.5 + .5);\n        \n \n        // Golden coloring for the Truchet and greyish coloring for the ground.\n        if(svID>.5){\n            //col *= max(1. - bumpFunc(p, n)*1.5, 0.);\n        \tcol *= mix(vec3(2, 1, .3), vec3(.1, 0, 0), bumpFunc(p, n)*1.5);\n            //col *= vec3(1, .1, .2)*1.5;\n                 \n        }\n        else {\n            //col *= max(1. - bumpFunc(p, n)*1.5, 0.);\n            col *= vec3(.8, .6, .4);\n        }\n        \n        \n        // Diffuse and specular.        \n        float df = max(dot(l, n), 0.); // Diffuse.\n        df = pow(df, 4.)*2.;\n        float sp = pow(max(dot(reflect(-l, n), -r), 0.), 32.); // Specular.\n        \n        \n\t\t// Applying some diffuse and specular lighting to the surface.\n        col = col*(df + .5*ao) + vec3(1, .97, .92)*sp*2.;\n        \n        // Add the fake environmapping. Not as good as a reflective pass, but it gives that\n        // impresssion for just a fraction of the cost.\n        vec3 em = eMap(reflect(r, n), n); // Fake environment mapping.\n        col += em*1.5;\n        \n        // Edges.\n        col *= 1. - edge2*.65; // Bump mapped edgingy.  \n        \n        // Attenuation, based on light to surface distance.    \n        col *= 1./(1. + d*d*.1);\n        \n        // Shadows and AO application.\n        col *= (sh + ao*.3)*ao;\n        \n\n        \n    }\n    \n    \n    // APPLYING FOG\n    // Blend in a bit of light fog for atmospheric effect.\n    vec3 fogCol = vec3(0);//vec3(.7, .8, 1.)*(rd.y*.5 + .5)*2.5;\n    col = mix(col, fogCol, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc.\n    \n    \n    // Vignette.\n    u = fCoord/iResolution.xy;\n    col = mix(col, vec3(0), (1. - pow(16.*u.x*u.y*(1.-u.x)*(1.-u.y), 0.25))*.5);\n    \n    // Apply some statistically unlikely (but close enough) 2.0 gamma correction. :)\n    fCol = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSBzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2183, 2216, 2236, 2236, 2294], [2297, 2455, 2502, 2502, 3010], [3013, 3156, 3174, 3174, 3520], [3523, 3623, 3645, 3732, 3778], [3780, 3839, 3859, 3859, 3894], [3897, 3955, 3976, 3976, 4040], [4043, 4065, 4086, 4435, 4946], [4948, 4997, 5035, 5035, 5130], [5349, 6041, 6061, 6441, 7272], [7275, 7313, 7336, 7367, 7939], [7942, 8233, 8255, 8255, 8749], [8751, 8880, 8902, 8902, 9192], [9313, 9327, 9348, 9398, 14986], [14991, 15019, 15035, 15225, 16583], [16586, 16877, 16894, 17084, 18572], [18575, 18607, 18638, 18756, 20487], [20489, 20576, 20666, 20849, 22598], [22971, 23037, 23057, 23057, 23203], [23208, 23511, 23558, 23675, 24965], [24970, 25122, 25155, 25155, 25394], [25398, 25456, 25485, 25485, 25855], [25858, 26235, 26263, 26263, 27067], [27069, 27069, 27112, 27140, 31677]], "test": "untested"}
{"id": "4lSfRw", "name": "Spiral of conflict.", "author": "jpupper", "description": "so, ive started using shaders like a month ago. Tryng to perfectionate my powers, this one is one that i like a lot. ", "tags": ["spiralsincosbeginner"], "likes": 1, "viewed": 91, "published": "Public", "date": "1514949322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.14159265358979323846\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = vec2(0.5)-uv;\n    \n    float angle = atan(pos.x,pos.y);\n    float radius = length(pos)*2.0;\n    \n    float r =   sin(angle*10.0+sin(radius*PI*5.0)*10.0+\n      iTime+sin(cos(sin(angle*30.0+iTime)*PI)*sin(cos(radius*20.0*PI)*PI)*0.4)\n      *sin(radius*20.0+iTime)*PI*3.0)*1.0;\n    \n    \n    \n    float g = r*radius*0.5+sin(angle*10.0+sin(radius*PI*5.0)*10.0+iTime+sin(cos(sin(angle*30.0+iTime)*PI)*sin(cos(radius*20.0*PI)*PI)*0.4)*sin(radius*20.0+iTime)*PI*3.0)*0.5\n    +cos(angle*10.0+sin(radius*PI*5.0)*10.0+iTime+sin(cos(sin(angle*30.0+iTime)*PI)*sin(cos(radius*20.0*PI)*PI)*0.4)*sin(radius*20.0+iTime)*PI*3.0)*0.5;\n    float b = cos(angle*10.0+sin(radius*PI*5.0)*10.0+iTime+sin(cos(sin(angle*30.0+iTime)*PI)*sin(cos(radius*20.0*PI)*PI)*0.4)*sin(radius*20.0+iTime)*PI*3.0);\n    \n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSfRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 93, 965]], "test": "untested"}
{"id": "4t2BDD", "name": "Distance estimation fun", "author": "dathor", "description": "distance estimation fractals - mandel-bulb and menger-sponge fly through thingy. Music by Bjorn Lynne", "tags": ["fractal", "raymarch", "mandelbulb", "de"], "likes": 8, "viewed": 466, "published": "Public", "date": "1515847655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 lightdir = normalize(vec3(-1., 1, -0.5));\n\nconst float detail = .00002;\nfloat det = 0.;\n\nfloat de2(vec3 p) {\n    vec3 op = p;\n    p = abs(1.0 - mod(p, 2.));\n    float r = 0., power = 8., dr = 1.;\n    vec3 z = p;\n    for (int i = 0; i < 7; i++) {\n        op = -1.0 + 2.0 * fract(0.5 * op + 0.5);\n        float r2 = dot(op, op);\n        r = length(z);\n\n\n        if (r > 1.616) break;\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return (.5 * log(r) * r / dr);\n}\n\nfloat de1(vec3 p) {\n    float s = 1.;\n    float d = 0.;\n    vec3 r = p, q = r;\n    for (int j = 0; j < 6; j++) {\n\t   \n        r = max(r = abs(mod(q * s + 1., 2.) - 1.), r.yzx);\n\t    \n        d = max(d, (.3 - length(r * 0.95) * .3) / s);\n\t    \n\ts *= 2.;\n    }\n    return d;\n}\n\n\nfloat map(vec3 p) {\n    return min(de1(p), de2(p));;\n}\n\nvec3 normal( in vec3 p) {\n    //vec2 e = vec2(0.005, -0.005);\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nfloat shadow( in vec3 ro, in vec3 rd){\n\tfloat res = .0;\n    \tfloat t = 0.05;\n\tfloat h;\t\n    \tfor (int i = 0; i < 4; i++)\n\t{\n\t\th = map( ro + rd*t );\n\t\tres = min(6.0*h / t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\nfloat calcAO(const vec3 pos,const vec3 nor) {\n    float aodet = detail * 80.;\n    float totao = 0.0;\n    float sca = 10.0;\n    for (int aoi = 0; aoi < 5; aoi++) {\n        float hr = aodet + aodet * float(aoi * aoi);\n        vec3 aopos = nor * hr + pos;\n        float dd = map(aopos);\n        totao += -(dd - hr) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - 5.0 * totao, 0.0, 1.0);\n}\n\n\nfloat kset(vec3 p) {\n\t    p = abs(.5 - fract(p * 80.));\n    float es, l = es = 0.;\n    for (int i = 0; i < 13; i++) {\n        float pl = l;\n        l = length(p);\n        p = abs(p) / dot(p, p) - .5;\n        es += exp(-1. / abs(l - pl));\n    }\n    return es;\n}\n\nvec3 light( in vec3 p, in vec3 dir) {\n\n    vec3 n = normal(p);\n    float sh = min(5., shadow(p, lightdir));\n\n    float ao = calcAO(p, n);\n\n    float diff = max(0., dot(lightdir, -n)) * sh * 1.3;\n    float amb = max(0.2, dot(dir, -n)) * .4;\n    vec3 r = reflect(lightdir, n);\n    float spec = pow(max(0., dot(dir, -r)) * sh, 10.) * (.5 + ao * .5);\n    float k = kset(p) * .18;\n    vec3 col = mix(vec3(k * 1.1, k * k * 1.3, k * k * k), vec3(k), .45) * 2.;\n    col = col * ao * (amb * vec3(.9, .85, 1.) + diff * vec3(1., .9, .9)) + spec * vec3(1, .9, .5) * .7;\n    return col;\n}\n\n\n\n\nvec3 raymarch( in vec3 from, in vec3 dir) {\n    vec3 color, pos;\n    float t = 0.;\n    float td = 0.;\n    float d = 0.;\n    for (int i = 0; i < 128; i++) {\n        pos = from + t * dir;\n        float precis = 0.001 * t;\n        d = map(from + dir * t);\n\tdet=detail*(1.+t*55.);\n   \n        if (d < 0.0002) break;\n\t        t += d;\n    }\n    vec3 backg = vec3(.5);\n\n    color = light(pos - det * dir * 1.5, dir);\n    color *= vec3(1., .85, .8) * .9;\n    color = mix(color, backg, 1.0 - exp(-1.3 * pow(t, 1.3)));\n\n    return color;\n}\n\nvec3 camPath(float time) {\n    vec2 p = 600.0 * vec2(cos(1.4 + 0.37 * time),cos(3.2 + 0.31 * time));\n    return vec3(p.x, 0.0, p.y);\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\nvec3 postprocess(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(0.57));\n\t#define CONTRAST 1.4\n\t#define SATURATION 1.4\n\t#define BRIGHTNESS 1.2\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t//rgb = clamp(rgb+hash(xy*time)*.1, 0.0, 1.0);\n\treturn rgb;\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n    float t = iTime * 0.5;\n    vec2 s = uv * vec2(1.75, 1.0);\n\n\n    vec3 campos = camPath(t * 0.001);\n    vec3 camtar = camPath(t + 2.0);\n    //float roll = 15.0*sin(t*.5+.4);\n\t\n    float roll = 0.4 * cos(0.4 * t);\n    vec3 cw = normalize(camtar - campos);\n    vec3 cp = vec3(sin(roll), cos(roll), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(s.x * cu + s.y * cv + .6 * cw);\n\n    vec3 col = raymarch(campos, rd);\n\tcol = postprocess(col,s);\n    fragColor  = vec4(col, 0.0);\n\n\n}", "image_inputs": [{"id": "4sSXzm", "previewfilepath": "https://soundcloud.com/bjorn-lynne/eastern-promise-lo-fi-preview", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bjorn-lynne/eastern-promise-lo-fi-preview", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2BDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 113, 113, 743], [745, 745, 764, 764, 1019], [1022, 1022, 1041, 1041, 1076], [1078, 1078, 1103, 1139, 1305], [1307, 1307, 1345, 1345, 1524], [1526, 1526, 1571, 1571, 1920], [1923, 1923, 1943, 1943, 2183], [2185, 2185, 2222, 2222, 2760], [2765, 2765, 2808, 2808, 3294], [3296, 3296, 3322, 3322, 3430], [3432, 3432, 3452, 3452, 3521], [3524, 3524, 3561, 3561, 3842], [3850, 3850, 3906, 3906, 4501]], "test": "untested"}
{"id": "4t2BRt", "name": "planar warp pattern", "author": "public_int_i", "description": "planar warp", "tags": ["2d", "warp", "pattern", "planar"], "likes": 0, "viewed": 381, "published": "Public API", "date": "1516995479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2018\nmat2 rot2d(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,s,-s,c);\n}\nfloat twave(float t) {\n    t = fract(t);\n   \treturn t*2.-max(0.,t*4.-2.); \n}\nvoid mainImage(out vec4 o, in vec2 u)\n{\n\tvec2 uv = u/iResolution.y*(.5+twave(iTime*.04)*1.5);\n    for (float s = 1.; s < 6.; s+=s) uv = 1.-abs(vec2(uv.x,uv.y)*rot2d(uv.x*s+iTime*.2)/(1.-abs(uv.y)));\n    o = cos(texture(iChannel0,uv*.01)*6.28+cos((iTime)*.07*vec4(.3,.9,4,4))*4.)*0.5+0.5;\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2BRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 31, 52, 52, 115], [116, 116, 138, 138, 192], [193, 193, 232, 232, 482]], "test": "untested"}
{"id": "4t2fW1", "name": "Alpine Express", "author": "dr2", "description": "The complete experience - train, viaduct, tunnel, snow .. (mouse: horizontal selects view)", "tags": ["tunnel", "snow", "train", "mountain", "bridge"], "likes": 20, "viewed": 620, "published": "Public API", "date": "1515603097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Alpine Express\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsAnDf (vec3 p, float r, float w, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2s (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_CAR 6\n\nvec4 carStat[N_CAR];\nvec3 qHit, sunDir;\nfloat dstFar, tCur, trCyc, trMov, szFac, trkWid, trkRad, rlWid, rlHt, tunRad, tunUp, vuMode, tunWl;\nint idObj;\nbool doShad;\nconst float pi = 3.14159;\nconst int idRail = 1, idRbase = 2, idSlp = 3, idVia = 4, idTun = 5, idGrnd = 6,\n   idCar = 11, idCon = 12, idWhl = 13, idFLamp = 14, idBLamp = 15;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GroundDf (vec3 p, float r, float dMin)\n{\n  vec3 q;\n  float d, dt, s;\n  q = p;  q.y -= tunUp;\n  dt = length (vec2 (r - trkRad, q.y)) - tunRad;\n  q = p;\n  s = 0.5 * Fbm2s (0.75 * q.xz);\n  q.y -= -1.7 + 0.4 * q.z;\n  d = max (r - 1.6 * trkRad, max (q.y - 0.1 - s, - q.y - 0.1));\n  q = p;  q.yz -= vec2 (7., -0.7 * trkRad);\n  d = SmoothMin (d, PrCapsAnDf (q.xzy, 1.7 * trkRad + 0.5 * q.y - s, 0.1 + s, 4.), 3.);\n  if (vuMode == 0.) d = max (d, - 0.5 * trkRad - q.z);\n  d = max (max (0.7 * d, - dt), q.y - 30.);\n  DMIN (idGrnd);\n  return dMin;\n}\n\nfloat CarDf (vec3 p, float dir, float dMin)\n{\n  vec3 q;\n  float d, dy;\n  p /= szFac;\n  q = p;\n  dy = -0.25 * max (q.z * dir - 0.5, 0.);\n  d = PrRoundBoxDf (q - vec3 (0., dy, 0.), vec3 (0.3, 0.25 + dy, 1.55), 0.4);\n  DMINQ (idCar);\n  q = p;  q.xz = abs (q.xz);  q.z = abs (q.z - 0.9);\n  q -= vec3 (0.35, -0.6, 0.2);\n  d = PrCylDf (q.yzx, 0.16, 0.08);\n  DMINQ (idWhl);\n  q = p;  q.z = (dir == 0.) ? abs (q.z) - 1.8 : q.z + 1.8 * dir;\n  d = PrCylDf (q.xzy, 0.3, 0.5);\n  DMINQ (idCon);\n  if (dir > 0.) {\n    q = p;  q.yz -= vec2 (-0.25, 1.9);\n    d = PrCylDf (q, 0.1, 0.1);\n    DMINQ (idFLamp);\n  } else if (dir < 0.) {\n    q = p;  q.x = abs (q.x) - 0.2;  q.yz -= vec2 (-0.25, -1.9);\n    d = PrCylDf (q, 0.08, 0.1);\n    DMINQ (idBLamp);\n  }\n  return dMin;\n}\n\nfloat TrackDf (vec3 p, float r, float dMin)\n{\n  vec3 q;\n  float d, a;\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  q = p;  q.xz = Rot2D (q.xz, 2. * pi * (floor (80. * a + 0.5) / 80.));\n  q.y -= -5. - 0.6 * rlHt;\n  d = max (max (abs (r - trkRad) - 2. * trkWid, abs (q.y) - 5.),\n     - max (abs (r - trkRad) - 0.7 * trkWid, abs (q.y) - 4.));\n  d = max (d, - min (PrBox2Df (q.zy - vec2 (0., -1.), vec2 (0.5, 5.)),\n     length (q.zy - vec2 (0., 4.)) - 0.5));\n  DMIN (idVia);\n  dMin = max (dMin, - p.y + 0.4 * p.z - 2.5);\n  q = p;  q.y -= tunUp;\n  d = max (abs (length (vec2 (r - trkRad, q.y)) - tunRad) - 0.4 * trkWid,\n     - (p.z - 0.3 * p.y - 2.));\n  DMIN (idTun);\n  q = p;  q.xz = Rot2D (q.xz, 2. * pi * (floor (256. * a + 0.5) / 256.));\n  q.xy -= vec2 (- trkRad, -0.2 * rlHt);\n  d = PrBoxDf (q, vec3 (1.4 * trkWid, 0.5 * rlHt, 0.3 * trkWid));\n  DMIN (idSlp);\n  q = vec3 (r - trkRad, p.yz);  q.y -= -0.4 * rlHt;\n  d = PrBox2Df (q.xy, vec2 (1.6 * trkWid, 0.2 * rlHt));\n  DMIN (idRbase);\n  q = vec3 (abs (r - trkRad) - trkWid, p.yz);  q.y -= 0.7 * rlHt;\n  d = PrRoundBox2Df (q.xy, vec2 (rlWid, rlHt), 0.8 * rlWid);\n  DMIN (idRail);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, r;\n  dMin = dstFar;\n  r = length (p.xz);\n  if (! doShad) dMin = GroundDf (p, r, dMin);\n  dMin = TrackDf (p, r, dMin);\n  dMin /= szFac;\n  for (int k = 0; k < N_CAR; k ++) {\n    q = p - carStat[k].xyz;\n    q.xz = Rot2D (q.xz, carStat[k].w);\n    dMin = CarDf (q, ((k == 0) ? 1. : ((k == N_CAR - 1) ? -1. : 0.)), dMin);\n  }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 SceneCol (vec3 ro)\n{\n  vec4 objCol, carCol;\n  float a, r;\n  r = length (ro.xz);\n  a = (r > 0.) ? atan (ro.z, - ro.x) / (2. * pi) : 0.;\n  carCol = vec4 (0.8, 0.1, 0.1, 0.3);\n  if (idObj == idGrnd) {\n    objCol = vec4 (0.9, 0.9, 0.95, 0.1) * (1. - 0.1 * Fbm2 (4. * ro.xz));\n  } else if (idObj == idVia) {\n    objCol = vec4 (0.7, 0.5, 0.3, 0.1) * (0.6 +\n       0.6 * SmoothBump (0.05, 0.95, 0.02, mod (4. * ro.y, 1.)));\n  } else if (idObj == idTun) {\n    if (tunWl == 0.) {\n      if (abs (r - trkRad) < 0.1 * trkWid && mod (64. * a + 0.5, 1.) < 0.3)\n         objCol = vec4 (0.8, 0.8, 0.4, -1.);\n      else if (length (vec2 (abs (ro.y - tunUp + 0.5 * tunRad),\n         2. * (mod (16. * a + 0.5, 1.) - 0.5))) < 0.02) objCol = vec4 (0., 0.3, 0., -1.);\n      else objCol = vec4 (0.2, 0.15, 0.05, 0.) * (0.5 + 0.5 * SmoothBump (0.02, 0.98, 0.005,\n         mod (128. * a, 1.))) * (0.5 + 0.5 * smoothstep (0.002, 0.003,  abs (ro.y - tunUp +\n         tunRad * (floor (mod (128. * a, 2.)) - 0.5))));\n    } else {\n      if (length (vec2 (abs (r - trkRad) - 0.4 * trkWid, ro.y - tunUp - 1.02 * tunRad)) <\n         0.15 * trkWid) objCol = (ro.x > 0.) ? vec4 (0., 1., 0., -1.) : vec4 (1., 0., 0., -1.);\n      else objCol = mix (vec4 (0.5, 0.35, 0.2, 0.1), vec4 (0.8, 0.8, 0.85, 0.1),\n         step (2.05, ro.z - 0.3 * ro.y) * smoothstep (0., 0.1, ro.y - tunUp -\n         0.3 * tunRad * Fbm1 (8. * ro.z)));\n    }\n  } else if (idObj == idRail) {\n    objCol = vec4 (0.7, 0.7, 0.75, 0.5);\n  } else if (idObj == idRbase) {\n    objCol = vec4 (0.6, 0.4, 0.3, 0.) * (1. - 0.5 * Noisefv2 (128. * ro.xz));\n  } else if (idObj == idSlp) {\n    objCol = vec4 (0.6, 0.6, 0.7, 0.) * (1. - 0.7 * step (abs (abs (r - trkRad) - trkWid),\n       2.5 * rlWid) * step (abs (mod (256. * a + 0.5, 1.) - 0.5), 0.03));\n  } else if (idObj == idCar) {\n    objCol = (abs (qHit.y - 0.22) < 0.26) ? vec4 (0.3, 0.3, 0.5, 0.3) :\n       ((abs (abs (qHit.y - 0.22) - 0.28) < 0.02) ? vec4 (0.5, 0.8, 0.5, 0.3) : carCol);\n  } else if (idObj == idCon) {\n    objCol = carCol;\n  } else if (idObj == idWhl) {\n    objCol = (length (qHit.yz) < 0.07) ? vec4 (0.2, 0.2, 0.2, 0.1) : vec4 (0.6, 0.6, 0.6, 0.5);\n  } else if (idObj == idFLamp) {\n    objCol = (length (qHit.xy) < 0.09) ? vec4 (1., 1., 0.8, -1.) : carCol;\n  } else if (idObj == idBLamp) {\n    objCol = (length (qHit.xy) < 0.07) ? vec4 (1., 0.2, 0., -1.) : carCol;\n  }\n  return objCol;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.2;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.08 * d, h));\n    d += 0.3;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y < 0.02 * Fbm1 (256. * atan (rd.z, rd.x) / pi)) col = vec3 (0.5);\n  else {\n    rd.y = abs (rd.y);\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.05, 0.1, 0.25) + 0.2 * pow (1. - rd.y, 8.) +\n       0.2 * pow (sd, 8.) + 0.4 * min (pow (sd, 256.), 0.3);\n    f = 2. * Fbm2 (0.05 * (ro + rd * (100. - ro.y) / rd.y).xz);\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  }\n  return col;\n}\n\nvec2 TrackPath (float t)\n{\n  return trkRad * vec2 (sin (t), - cos (t));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, vn, ltVec;\n  vec2 rq;\n  float dstObj, d, reflFac, sh, f;\n  doShad = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    tunWl = (idObj == idTun) ? step (tunRad - 0.2 * trkWid,\n       length (vec2 (length (ro.xz) - trkRad, ro.y - tunUp))) : 0.;\n    objCol = SceneCol (ro);\n    if (idObj == idGrnd) vn = VaryNf (vec3 (4., 2., 4.) * ro, vn, 1.);\n    else if (idObj == idRbase || idObj == idSlp || idObj == idVia) vn = VaryNf (64. * ro, vn, 2.);\n    else if (idObj == idTun) vn = VaryNf (8. * ro, vn, 1.);\n    col = objCol.rgb;\n    if (objCol.a >= 0.) {\n      if (ro.z - 0.3 * ro.y > 2. && tunWl == 0. && idObj != idGrnd && idObj != idVia) {\n        if (idObj != idTun && idObj != idCar) col *= 0.4 + 0.3 * max (vn.y, 0.);\n        if (idObj != idCar) {\n          ltVec = vec3 (TrackPath (trMov + 0.3 * szFac), 0.3 * szFac).xzy - ro;\n          f = length (ltVec);\n          col *= 0.3 + (0.7 + 0.5 * max (dot (vn, ltVec), 0.) / f) / (1. + pow (f, 1.5));\n        } else {\n          col *= 0.1 + (0.1 + 0.1 * max (vn.y, 0.)) * (1. - smoothstep (4., 6., dstObj));\n          if (vn.y > 0.85) {\n            rq = ro.xz + (tunRad - 0.1 * trkWid - ro.y) * reflect (rd, vn).xz;\n            if (abs (length (rq) - trkRad) < 0.1 * trkWid && mod (32. *\n               atan (rq.y, rq.x) / pi + 0.5, 1.) < 0.3) col = mix (col, vec3 (0.8, 0.8, 0.4), 0.2);\n          }\n        }\n      } else {\n        reflFac = 0.;\n        if (idObj == idCar) reflFac = (abs (qHit.y - 0.22) < 0.26) ? 0.6 : 0.2;\n        if (idObj == idFLamp || idObj == idBLamp || idObj == idRail) reflFac = 0.2;\n        doShad = true;\n        sh = ObjSShadow (ro, sunDir);\n        doShad = false;\n        col = col * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.) +\n           sh * objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n        if (reflFac > 0.) col = mix (col, 0.7 * BgCol (ro, reflect (rd, vn)), reflFac);\n      }\n      if (idObj == idGrnd) col +=\n         256. * pow (clamp (0.5 + 0.5 * dot (sunDir, reflect (rd, vn)), 0., 1.), 16.) *\n         pow (1. - 0.6 * abs (dot (normalize (sunDir - rd), VaryNf (1024. * ro, vn, 2.))), 8.);\n    }\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd;\n  vec2 mMid[4], ut[4], mSize, canvas, uv, p1, p2, ori, ca, sa;\n  float el, az, zmFac, t1, t2, r, cGap, vuCorn;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = 0.;\n  az = 0.;\n  mSize = 0.23 * vec2 (canvas.x / canvas.y, 1.);\n  mMid[0] = (1. / mSize.y - 1.) * mSize;\n  mMid[1] = mMid[0] * vec2 (1., -1.);\n  mMid[2] = mMid[0] * vec2 (-1., -1.);\n  mMid[3] = mMid[0] * vec2 (-1., 1.);\n  for (int k = 0; k < 4; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  vuCorn = 0.;\n  for (int k = 0; k < 4; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuCorn = float (k + 1);\n      break;\n    }\n  }\n  vuMode = mod (vuCorn + floor (mod (0.2 * tCur, 5.)), 5.);\n  if (mPtr.z > 0.) vuMode = mod (vuCorn + floor (5. * clamp (mPtr.x + 0.5, 0., 0.99)), 5.);\n  dstFar = 100.;\n  szFac = 0.4;\n  trkRad = 20.;\n  trkWid = 0.15;\n  tunRad = 3.3 * trkWid;\n  tunUp = 2.4 * trkWid;\n  rlWid = 0.012;\n  rlHt = 0.025;\n  trMov = 0.2 * tCur;\n  cGap = 0.206 * szFac;\n  for (int n = 0; n < N_CAR; n ++) {\n    p1 = TrackPath (trMov - float (n) * cGap + 0.3 * cGap);\n    p2 = TrackPath (trMov - float (n) * cGap - 0.3 * cGap);\n    carStat[n].xz = 0.5 * (p1 + p2);\n    carStat[n].y = 2.7 * rlHt + 0.75 * szFac;\n    p1 -= p2;\n    carStat[n].w = atan (p1.x, p1.y);\n  }\n  if (vuMode == 0.) {\n    el += 0.05 * pi;\n    zmFac = 4.2;\n  } else if (vuMode == 1. || vuMode == 2. || vuMode == 3.) {\n     if (vuMode == 1.) {\n      t1 = trMov + 0.5 * cGap;\n      t2 = t1 + 1. * cGap;\n    } else if (vuMode == 2.) {\n      t1 = trMov + 1.8 * cGap;\n      t2 = t1 - 1.3 * cGap;\n    } else if (vuMode == 3.) {\n      t1 = trMov - (float (N_CAR - 1) + 1.8) * cGap;\n      t2 = t1 + 1.3 * cGap;\n    }\n    r = 1.;\n    if (vuMode == 2. || vuMode == 3.) r += (1. + 1.2 * sin (0.3 * pi * tCur)) * trkWid / trkRad;\n    ro.xz = r * TrackPath (t1);\n    ro.y = 0.55 + 0.03 * sin (0.1 * pi * tCur);\n    el += 0.02 * pi;\n    vd.xz = TrackPath (t2) - ro.xz;\n    az -= atan (vd.x, vd.z);\n    zmFac = 3.5;\n  }\n  if (vuMode == 4.) {\n    ro = vec3 (0., 2., -30.);\n    vd = normalize (carStat[2].xyz - ro);\n    vd.xz = Rot2D (vd.xz, az);\n    vd.yz = Rot2D (vd.yz, el);\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n       vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n    zmFac = 7. * (atan (length (vd.xz), vd.y) / pi);\n  } else {\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., sa.y, 0., 1., 0., - sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, sa.x, 0., - sa.x, ca.x);\n    if (vuMode == 0.) ro = vuMat * vec3 (0., 0., -60.);\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (1., 3., -1.));\n  col = ShowScene (ro, rd);\n  for (int k = 0; k < 4; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n       col = vec3 (0.1, 0.1, 0.8);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsAnDf (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z) - h;\n  return max (length (vec3 (p.xy, max (0., p.z - w))) - r,\n     - length (vec3 (p.xy, max (0., p.z + w))) + r) - w;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2s (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.75);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2fW1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1122, 1168, 1168, 1667], [1669, 1669, 1714, 1714, 2422], [2424, 2424, 2469, 2469, 3579], [3581, 3581, 3603, 3603, 3981], [3983, 3983, 4016, 4016, 4227], [4229, 4229, 4250, 4250, 4450], [4452, 4452, 4477, 4477, 6842], [6844, 6844, 6881, 6881, 7104], [7106, 7106, 7137, 7137, 7587], [7589, 7589, 7615, 7615, 7662], [7664, 7664, 7699, 7699, 9957], [9959, 9959, 10015, 10015, 13113], [13115, 13115, 13147, 13147, 13247], [13249, 13249, 13295, 13295, 13342], [13344, 13344, 13377, 13377, 13466], [13468, 13468, 13515, 13515, 13562], [13564, 13564, 13606, 13606, 13657], [13659, 13659, 13713, 13713, 13854], [13856, 13856, 13901, 13901, 14004], [14006, 14006, 14063, 14063, 14146], [14148, 14148, 14178, 14178, 14236], [14270, 14270, 14294, 14294, 14347], [14349, 14349, 14373, 14373, 14503], [14505, 14505, 14530, 14530, 14676], [14678, 14678, 14703, 14703, 14889], [14891, 14891, 14913, 14913, 15067], [15069, 15069, 15091, 15091, 15244], [15246, 15246, 15267, 15267, 15422], [15424, 15424, 15453, 15453, 15665], [15667, 15667, 15706, 15706, 15890]], "test": "untested"}
{"id": "4t2fWm", "name": "Pathtrace Normals", "author": "shemit", "description": "Getting normals to begin path tracing, saving separately to keep for future reference.", "tags": ["pathtracingnormals"], "likes": 0, "viewed": 177, "published": "Public", "date": "1516434055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SAMPLES 1\n#define PI 3.141592653589793\n\nstruct Sphere {\n    float radius;\n    vec3 position;\n    float emission;\n    vec3 color;\n};\n\nstruct Camera {\n\tvec3 position;\n    vec3 direction;\n    vec3 up;\n    float fov;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec2 gridify(vec2 uv, float split) {\n    return ceil(uv * split) / split;\n}\n\nvec3 getNormal(Ray ray) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nRay makeRay(vec2 uv, Camera camera) {\n    // simplify the sensor width to be res.x / res.y\n    // simplify the sensor height to be 1.0\n    \n    // first solve for near clip plane:\n    // tan(FOV / 2.0) = midx / adj\n    // adj = (uv.x / 2.0) / tan(FOV / 2.0)\n    \n    float midx = 0.5 * iResolution.x / iResolution.y;\n    float midy = 0.5;\n    float clipDistance = midx / tan(camera.fov / 2.0);\n    \n    // origin of ray at clipDistance location will be:\n    // (clipDistance, 0.0, 0.0)\n    // i.e.\n    // f(midx, midy) = Ray(origin: 0.0, direction: 1.0)\n    \n    // 1. tackle the origin of the ray\n    // we make the assumption that up is orthogonal to \n    // diretion (should add in a check for this later)\n    // we are left to find the remaining basis, which is\n    // the cross product of the two\n    vec3 xbasis = normalize(cross(camera.direction, camera.up));\n    vec3 ybasis = camera.up;\n    vec3 zbasis = camera.direction;\n    \n    // multiply sensor dimensions by basis to get position of pixel\n    // in world space\n    vec3 x = (uv.x - midx) * xbasis;\n    vec3 y = (uv.y - midy) * ybasis;\n    vec3 z = clipDistance * zbasis;\n   \n    // add these all together\n    vec3 position = x + y + z;\n    \n    // normalize to get a unit vector from the position\n    vec3 direction = normalize(position);\n    \n    // then, add the camera position\n    vec3 origin = position + camera.position;\n    \n    \n    Ray ray = Ray(origin, direction);\n    return ray;\n}\n\nfloat intersect(Ray ray, Sphere sphere) {\n    float eps = 0.0000001;\n    float t = 0.0;\n\n    vec3 offset = sphere.position - ray.origin;\n    vec3 direction = ray.direction;\n    float dist = dot(offset, ray.direction);\n    \n    // Quadratic equation to solve for hit distance\n    float discriminant = dist * dist - \n        dot(offset, offset) + \n        sphere.radius * sphere.radius;\n    \n    if (discriminant < 0.0) {\n        return 99999999999.0;\n    } else {\n        discriminant = sqrt(discriminant);\n        t = dist - discriminant;\n        if (t > eps) {\n        \treturn t;   \n        } else {\n         \tt = dist + discriminant;\n            if (t > eps) {\n             \treturn t;   \n            }\n        }\n    }\n    \n    return 99999999999.0;\n}\n\nvec3 pathtrace(vec2 uv, Camera camera, Sphere spheres[6]) {\n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    // TODO: Loop through this by samples/pixel\n    Ray ray = makeRay(uv, camera);\n    \n    // begin firing rays\n    \n    float minDistance = 999999999999999.0;\n    int closestIdx = -1;\n    vec3 hitLocation = vec3(0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 6; i++) {\n        Sphere sphere = spheres[i];\n        float d = intersect(ray, sphere);\n        if (d < minDistance) {\n            minDistance = d;\n            closestIdx = i;\n            hitLocation = ray.origin + (ray.direction * minDistance);\n    \t\tnormal = normalize(hitLocation - sphere.position);\n            \n            // Flip normals if we are inside of the sphere\n            if (length(sphere.position - ray.origin) < sphere.radius) {\n                normal = normal * -1.0;\n            }\n        }\n    }\n    \n    \n    vec3 color = normal;\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord / res.y;\n    \n    float split = 40.0;\n    \n    vec3 position = vec3(0.0, 0.0, 0.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // We set the FOV to be 90 degrees\n    Camera camera = Camera(position, direction, up, PI / 2.0);\n    \n    // Scene setup\n    Sphere ceiling = Sphere(\n    \t1000.0,\n        vec3(0.0, -997.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere left = Sphere(\n    \t1000.0,\n        vec3(-995.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere right = Sphere(\n    \t1000.0,\n        vec3(995.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere bottom = Sphere(\n    \t1000.0,\n        vec3(0.0, 997.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere back = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, -990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere front = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, -990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere middle = Sphere(\n    \t0.5,\n        vec3(0.0, 0.0 + sin(3.0 * iTime), 3.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere spheres[6];\n    spheres[0] = middle;\n    spheres[1] = back;\n    spheres[2] = left;\n    spheres[3] = right;\n    spheres[4] = ceiling;\n    spheres[5] = bottom;\n    \n    \n    \n    \n    vec2 grid = gridify(uv, split);\n    vec3 result = pathtrace(grid, camera, spheres);\n    \n    \n\tfragColor = vec4(result, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2fWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 319, 319, 358], [360, 360, 385, 385, 419], [421, 421, 458, 678, 1879], [1881, 1881, 1922, 1922, 2633], [2635, 2635, 2694, 2694, 3671], [3674, 3674, 3731, 3731, 5259]], "test": "untested"}
{"id": "4t2fzt", "name": "growing pulsating circle", "author": "bhavesh", "description": "blah", "tags": ["growingcircle"], "likes": 1, "viewed": 413, "published": "Public API", "date": "1516850774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 circle_center = iResolution.xy/2.0; //pixels\n    float circle_radius = iTime * 80.0;\n    \n    //while(circle_radius> 200.0)\n        //circle_radius -=200.0;\n    circle_radius = mod(circle_radius, 200.0);\n    \n    float pixel_to_center_distance = sqrt(\n       pow(circle_center.x- fragCoord.x, 2.0) +\n        pow(circle_center.y - fragCoord.y, 2.0));\n    \n    if( abs(pixel_to_center_distance - circle_radius) < 5.0 ) // abs(...)\n        fragColor = vec4(1,0,0,1.0);\n    else\n        fragColor = vec4(0,0,0,1.0);\n    \n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2fzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 101, 636]], "test": "untested"}
{"id": "4tBBRw", "name": "mandalas of perfection", "author": "jes5199", "description": "https://www.shadertoy.com/view/Xt2BzD but zoomed way out", "tags": ["2d", "moire"], "likes": 2, "viewed": 114, "published": "Public", "date": "1514942207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 15000.0 * ((fragCoord.xy - iResolution.xy/2.)/ iResolution.y) + vec2(0, 0);\n    \n    float d = 1.0;// + sqrt(length(uv)) / 109.0;\n    float t = 10. + iTime;\n    float value = d * t + (t * 0.125) * cos(uv.x) * cos(uv.y);\n    float color = sin(value) * 3.0;\n    \n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    \n    vec4 lifeColor;\n        \n    if(color > 0.) {\n      lifeColor = vec4(high, high, med,1.0);\n    } else {\n      lifeColor = vec4(med, high, high,1.0);\n    }\n        \n    fragColor = lifeColor * 1.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBBRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 634]], "test": "untested"}
{"id": "4tBBzm", "name": "Knot Ray", "author": "gaz", "description": "like billbord", "tags": ["3d"], "likes": 4, "viewed": 214, "published": "Public", "date": "1514989506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 lookat(vec3 d, vec3 up)\n{\n\tvec3 w = normalize(d),u = normalize(cross(w,up));\n    return (mat3(u,cross(u,w),w));\n}\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nvec2 planeUv(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 up)\n{\n\tfloat z = dot(pos-ro,nor)/dot(rd,nor);\n    vec3 p=ro+rd*z, a=p-pos, u=normalize(cross(nor,up)), v=normalize(cross(u,nor));\n    return vec2(dot(a,u),dot(a,v));\n}\n\nvec3 hsv(float h, float s, float v)\n{\n    return mix(vec3(1),clamp((abs(fract(h+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 knot(float t)\n{\n    t *= radians(360.);\n    return vec3(sin(t)+2.*sin(2.*t),cos(t)-2.*cos(2.*t),-sin(3.*t));\n}\n\nfloat de(vec2 p)\n{\n    return min(\n        abs(abs(p.x)+abs(p.y)-0.6),\n        mix(\n            max(abs(p.x)-0.6,abs(p.y)),\n            abs(p.y),\n            step(0.9,sin(iTime+sin(iTime*3.)))\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,7);\n    ro.xz *= rotate(iTime*0.3);\n    ro.xy *= rotate(iTime*1.5);\n    vec3 rd = lookat(-ro,vec3(0,1,0))*normalize(vec3(p,2));\t\n    vec3 col = vec3(0.3,0.3,0.5)*length(p*0.25);\n    float s = 100.;\n    for(float i=0.;i<s;i++)\n    {\n        float t = iTime*0.05+i/s;\n        vec3 d = normalize(knot(t-0.001)-knot(t+0.001));\n        vec2 b = planeUv(ro,rd,knot(t),d,d.yzx);\n        col = mix(col,hsv(i/s,0.7,1.0),smoothstep(0.07,0.0,de(b)));\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBBzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 118], [120, 120, 142, 142, 192], [194, 194, 255, 255, 417], [419, 419, 456, 456, 540], [542, 542, 562, 562, 657], [659, 659, 677, 677, 870], [872, 872, 929, 929, 1490]], "test": "untested"}
{"id": "4tBfRy", "name": "Thing_2", "author": "balkhan", "description": "Flaming thing.", "tags": ["thing"], "likes": 10, "viewed": 116, "published": "Public", "date": "1516170927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n#define LPOS vec3(cos(t)*.8, sin(t)*.8, -t-1.5)\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec2\trot_t;\nvec3\th;\nvec3\tbase;\nvec3\tlight_pos;\nvec3\tlight_green = vec3(.5,.7,.4);\nvec3\tlight_blue = vec3(.1,.5,.7);\nvec3\tlight_red = vec3(.7,.2,.1);\nvec3\tuglob;\nfloat \tt;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    uglob*=0.;\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 1.0-iTime*.5);\n    t = iTime;\n\n    dir=normalize(dir);\n    vec4\tinter = (march(pos, dir));\n\n    col.xyz = vec3(.99, .9, .7)*((inter.w*.1051)+(1.-inter.x*.1)*.06125);\n    col.xyz += -h*.0053061251;\n    c_out =  vec4(1.-col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n\n    p.xy += .5;\n    p.z += .52*t;\n    light_pos.xy = vec2(cos(p.z*4. ),sin(p.z*4. ))*.15;\n    p.xy = fract(p.xy)-.5;\n    p.z += .52*t;\n    rotate(p.xy, iTime*1.+p.z*.75);\n    p.xy = abs(p.xy)-.25;\n    rotate(p.xy, iTime*4.+p.z*2.);\n    light_pos.z = p.z;\n\n    p.xy = abs(p.xy)-.06125-sin(p.z)*.051-light_pos.xy*.251;\n    \n    mind = min(mind, \n              length(p.xy)+.0012501\n              );\n\n    h+= 1.-vec3(.01, .1, .31)*1./(mind*mind +.1);\n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\ts = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            s.y = 1.;\n            break;\n        }\n        s.x++;\n    }\n    s.w = dist.y+dist.x;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBfRy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 445, 488, 488, 884], [886, 886, 907, 907, 1398], [1401, 1401, 1433, 1433, 1814], [1816, 1830, 1870, 1870, 1945], [1947, 1947, 1975, 1975, 2083], [2086, 2086, 2136, 2136, 2396], [2398, 2398, 2420, 2420, 2626]], "test": "untested"}
{"id": "4tBfWR", "name": " Worley noise", "author": "smkgames", "description": " Worley noise 2x2x2\nI'm trying to make this http://c8.alamy.com/comp/H9348Y/chaotic-pointillist-half-tone-circle-pattern-random-dots-H9348Y.jpg", "tags": ["noise", "worley", "worleynoise"], "likes": 12, "viewed": 1356, "published": "Public API", "date": "1515214039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Stefan Gustavson\n// Title: Worley noise 2x2x2\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n\t#define K 0.142857142857 // 1/7\n\t#define Ko 0.428571428571 // 1/2-K/2\n\t#define K2 0.020408163265306 // 1/(7*7)\n\t#define Kz 0.166666666667 // 1/6\n\t#define Kzo 0.416666666667 // 1/2-1/6*2\n\t#define jitter 0.8 // smaller jitter gives less errors in F2\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\n\tvec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 p1 = permute(p + Pi.z); // z+0\n\tvec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\n\tvec4 ox1 = fract(p1*K) - Ko;\n\tvec4 oy1 = mod(floor(p1*K), 7.0)*K - Ko;\n\tvec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract(p2*K) - Ko;\n\tvec4 oy2 = mod(floor(p2*K), 7.0)*K - Ko;\n\tvec4 oz2 = floor(p2*K2)*Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter*ox1;\n\tvec4 dy1 = Pfy + jitter*oy1;\n\tvec4 dz1 = Pf.z + jitter*oz1;\n\tvec4 dx2 = Pfx + jitter*ox2;\n\tvec4 dy2 = Pfy + jitter*oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter*oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\td1 = min(d1, d2);\n\td1.xy = min(d1.xy, d1.wz);\n\td1.x = min(d1.x, d1.y);\n\treturn sqrt(d1.xx);\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec4 d = min(d1,d2); // F1 is now in d\n\td2 = max(d1,d2); // Make sure we keep all candidates for F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw\n\td.y = min(d.y, d.z); // nor in d.z\n\td.y = min(d.y, d.w); // nor in d.w\n\td.y = min(d.y, d2.x); // F2 is now in d.y\n\treturn sqrt(d.xy); // F1 and F2\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nvec2 st = (2.*fragCoord -iResolution.xy ) / iResolution.y; \n\n\tst *= 10.;\n\tvec2 F = cellular2x2x2(vec3(st,iTime));\n\tfloat n = smoothstep(0.4, 0.5, F.x);\n\tfragColor = vec4(n, n, n, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBfWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[371, 418, 440, 440, 485], [486, 486, 508, 508, 553], [555, 819, 847, 847, 2655], [2657, 2657, 2712, 2712, 2899]], "test": "untested"}
{"id": "4tjBDD", "name": "Adaptive Distance Estimation", "author": "dust", "description": "See comment.", "tags": ["procedural", "julia", "raymarched", "fractals", "quaternion", "distanceestimator"], "likes": 0, "viewed": 162, "published": "Public", "date": "1515844085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modified Julia DE starts from line 51\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\n// Assumes unit quaternion (rotation only)\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\n// Rigorous quaternion product, works for any length\n// (DE-friendly)\n// Taken from MacSlow's shader here: \n// https://www.shadertoy.com/view/lttSzX\n// Thanks :)\nvec4 QtnProduct2(vec4 qtnA, vec4 qtnB)\n{\n    float x = qtnA.x * qtnB.x - dot (qtnA.yzw, qtnB.yzw);\n    vec3 yzw = (qtnA.x * qtnB.yzw) + \n               (qtnB.x * qtnA.yzw) + cross(qtnA.yzw, qtnB.yzw);\n    return vec4(x, yzw);\n}\n\nstruct JParams\n{\n\tint iter;\n    vec4 z;\n    vec4 dz;\n};\n\n#define W_FRAME 0.0\n#define BAILOUT 16.0\nJParams Julia(vec3 coord,\n           \t  int maxIter)\n{\n    vec4 z = vec4(coord, W_FRAME);\n    vec4 dz = vec4(1, 0, 0, 0);\n    vec4 c = vec4(-0.5,-0.5, -0.5, W_FRAME);\n    int i = 0;\n    while (i < maxIter &&\n           length(z) < BAILOUT)\n    {\n        dz = (2.0 + length(coord) / 10.0) * QtnProduct2(z, dz);\n        z = QtnProduct2(z, z) + c;\n        i += 1;\n    }\n    return JParams(i, z, dz);\n}\n\nfloat MakinBuddhi(vec3 coord, \n                  float r, \n                  int maxIter)\n{\n    float eps = 0.0001;\n    return length((vec3(length(Julia(coord + vec3(1, 0, 0) * eps, maxIter).z), \n                 \t    length(Julia(coord + vec3(0, 1, 0) * eps, maxIter).z), \n                 \t    length(Julia(coord + vec3(0, 0, 1) * eps, maxIter).z)) - r) / eps);\n}\n\n#define ITERATIONS 8\nfloat JuliaDE(vec3 coord)\n{\n    // [0.5 * log(r) * r/dr]\n    // |f^2[n-1](c) + d, f[0] = c|\n    JParams julia = Julia(coord, \n                          ITERATIONS);\n    float r = length(julia.z);\n    float dr = length(julia.dz);\n    return (0.5 * log(r) * r / dr);\n}\n\nfloat map(vec3 coord)\n{\n    return JuliaDE(coord);\n}\n\nvec3 grad(vec3 samplePoint, float eps)\n{\n\tfloat normXA = map(vec3(samplePoint.x + eps, samplePoint.y, samplePoint.z));\n    float normXB = map(vec3(samplePoint.x - eps, samplePoint.y, samplePoint.z));\n\n    float normYA = map(vec3(samplePoint.x, samplePoint.y + eps, samplePoint.z));\n    float normYB = map(vec3(samplePoint.x, samplePoint.y - eps, samplePoint.z));\n\n    float normZA = map(vec3(samplePoint.x, samplePoint.y, samplePoint.z + eps));\n    float normZB = map(vec3(samplePoint.x, samplePoint.y, samplePoint.z - eps));\n\n    vec3 norm = vec3(normXA - normXB,\n                     normYA - normYB,\n                     normZA - normZB);\n    float len = length(norm);\n    return vec3(norm / len);    \n}\n\nvec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)\n{\n    vec2 xy = pixID - (viewSizes / 2.0);\n    float z = viewSizes.y / tan(fovRads / 2.0);\n    return normalize(vec3(xy, z));\n}\n\n#define EYE_DIST 7.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float eps = 0.0001;\n    float currRayDist = 0.0;\n\tvec3 rayDir = RayDir(3.14 / 2.0, iResolution.xy, fragCoord);\n    vec3 sphPos = vec3(0.0, 0.0, 4.0);\n    vec4 rgba = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 dRGBA = vec4(0.02, 0.06, 0.04, 0.0) / EYE_DIST;\n    for (int i = 0; i < 255; i += 1)\n    {\n        vec3 eyePos = vec3(0.0, 0.0, EYE_DIST * -1.0);\n    \tvec3 rayVec = QtnRotate(eyePos + (rayDir * currRayDist), vec4(vec3(0.0, 1.0, 0.0) * sin(iTime / 20.0), cos(iTime / 20.0)));\n        float qtnDist = map(rayVec);\n        rgba += dRGBA;\n        if (qtnDist < eps)\n        {   \n            vec3 baseLightPos = vec3(0.0, 1.0, -1.0);\n            vec3 lightPos = QtnRotate(baseLightPos,\n                                      vec4(vec3(0.0, 1.0, 0.0) * sin(iTime / 20.0), cos(iTime / 20.0)));\n            float nDL = dot(grad(rayVec, eps).xyz, \n                            normalize(lightPos));\n            \n            fragColor = rgba * nDL;\n            fragColor.w = 1.0;\n            return;\n        }\n        \n        currRayDist += qtnDist;\n    }\n\n    fragColor = rgba;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 88, 115, 115, 157], [159, 244, 283, 283, 506], [508, 584, 620, 620, 717], [719, 881, 921, 921, 1108], [1208, 1208, 1262, 1262, 1606], [1608, 1608, 1699, 1699, 1973], [1996, 1996, 2023, 2087, 2262], [2264, 2264, 2287, 2287, 2316], [2318, 2318, 2358, 2358, 3024], [3026, 3026, 3082, 3082, 3208], [3231, 3231, 3288, 3288, 4367]], "test": "untested"}
{"id": "4tjBRc", "name": "AUCS Playground - Circular", "author": "ilmikko", "description": "test", "tags": ["test"], "likes": 0, "viewed": 64, "published": "Public", "date": "1516822165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897\n\nvec3 circle(vec2 uv,vec2 position)\n{\n    float len = clamp(1.-length(uv-position)/1.5,-0.1,1.);\n\treturn vec3(len);\n}\nvec3 circle(vec2 uv,vec2 position, vec3 color)\n{\n\treturn circle(uv,position)*color;\n}\n\nvec3 noise(vec3 vec)\n{\n   \tvec.x+=sin(iTime)*0.1;\n    vec.y+=cos(iTime)*0.324;\n    vec.z+=sin(iTime)*0.4;\n    return vec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 color = vec3(0);\n    \n    float circles=11.;\n    \n    for (float i; i<circles; i++)\n    {\n        float p=i/circles;\n        \n        float r=sin(cos(p+iTime/3.12));\n        float g=cos(sin(r+0.5+iTime/2.));\n        float b=sin(g+0.5+iTime);\n        \n        vec2 pos;\n        \n        float angle=iTime/2.;\n        float radius=1.5+cos(iTime/4.)/10.;\n            \n        pos.x=sin(2.*PI*p+angle)*radius;\n        pos.y=cos(2.*PI*p+angle)*radius;\n        \n    \tvec3 circ = circle(uv,pos,vec3(r,g,b));\n    \n    \tcolor += circ;\n    }\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjBRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 64, 64, 144], [145, 145, 193, 193, 230], [232, 232, 254, 254, 355], [357, 357, 414, 414, 1060]], "test": "untested"}
{"id": "4tjBRK", "name": "18/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I needed to get my shadow calculus back up. I had there a small bug with self collision that I hunted down for more than an hour not realizing what the issue was. I felt so stupid :D", "tags": ["shadows"], "likes": 1, "viewed": 87, "published": "Public", "date": "1516495844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64\n#define FAR 80.0\n#define EPSILON 0.5/iResolution.x\n\n#define FOG_COLOR vec3(0.55, 0.6, 0.75)\n#define SUN_COLOR vec3(0.8, 0.75, 0.7)\n\n\n//Distance functions and helpper functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat dist(vec3 p){\n    float plane = fPlane(p, vec3(0.0, 1.0, 0.0), 1.0);\n    float sphere = fSphere(p-vec3(-3.0, 1.0, 0.0), 1.5);\n    sphere = min(sphere, fSphere(p-vec3(3.0, 1.0, 0.0), 1.5));\n    return min(plane, sphere);\n}\n\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(EPSILON, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy)-dist(p-eps.xyy),\n        dist(p+eps.yxy)-dist(p-eps.yxy),\n        dist(p+eps.yyx)-dist(p-eps.yyx)\n    ));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.0;\n    vec3 p = ro;\n    for(int i = 0; i < STEPS; ++i){\n        float d = dist(p);\n        p += rd*d;\n        t += d;\n        \n        if(d < EPSILON || t >= FAR){\n            break;\n        }\n    }\n    return t;\n}\n\nfloat marchShadow(vec3 ro, vec3 rd){\n    float t = 0.0;\n    vec3 p = ro;\n    float s = 1.0;\n    for(int i = 0; i < 32; ++i){\n        float d = dist(p);\n        p += rd*d;\n        t += d;\n        \n        if(d < 0.01){\n            s = 0.0;\n            break;\n        }\n    }\n    return s;\n}\n\n\n//Fog introduced in http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot( rd, ld ), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.06);\n\tvec3  fogColor = mix(FOG_COLOR, SUN_COLOR, pow(sunAmount, 1.0));\n    return mix(col, fogColor, fogAmount);\n}\n\nvec3 objColor(vec3 p, vec3 rd, vec3 ld){\n    vec3 n = normals(p);\n    float lambertian = max(dot(n, ld), 0.0);\n    float angle = max(dot(reflect(-ld, n), rd), 0.0);\n    float specular = pow(angle, 40.0);\n   \n    float shadow = marchShadow(p+n*0.02, ld);\n    \n    vec3 color = vec3(0.8, 0.4, 0.65)+lambertian*FOG_COLOR+specular*SUN_COLOR;\n    \n    return color*shadow;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(7.0*sin(iTime*0.5), 0.0, 7.0*cos(iTime*0.5));\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    \n    vec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    vec3 ld = normalize(vec3(0.5, 2.0, 0.0));\n    \n    vec3 color = FOG_COLOR;\n    float t = march(ro, rd);\n    vec3 p = ro+rd*t;\n    if(t < FAR){\n        color = objColor(p, rd, ld);\n    }\n    color = fog(color, p, ro, rd, ld);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjBRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 290, 310, 310, 340], [342, 416, 472, 472, 514], [516, 516, 548, 548, 573], [575, 575, 594, 594, 802], [805, 805, 826, 826, 1025], [1027, 1027, 1057, 1057, 1288], [1290, 1290, 1326, 1326, 1579], [1582, 1653, 1707, 1707, 1937], [1939, 1939, 1979, 1979, 2308], [2311, 2311, 2368, 2368, 3047]], "test": "untested"}
{"id": "4tjBWc", "name": "rainbow cubes", "author": "unnick", "description": "i got inspiration from http://www.pouet.net/topic.php?which=7920&page=2#c364528 to recreate this in glsl.", "tags": ["3d", "rainbow"], "likes": 6, "viewed": 239, "published": "Public", "date": "1517409562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.283\n#define rand(v) fract( sin( dot( v, vec2(12.9898,78.233 )) ) * 43758.5453 )\n\n#define raymul 0.75\n#define near 0.01\n#define far 75.0\n#define use22tap\n\n#define maxheight 1.5\n\n//copy pasted code from https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n//end of copy pasted code\n\nfloat primitive(vec3 pos, vec2 txy){\n    return length(max(abs(pos)-vec3(0.5, rand(txy)*maxheight, 0.5), 0.0));\n}\n\nvec3 hue(float ang){\n    return vec3(\n        sin(ang),\n        sin(ang+tau/3.0),\n        sin(ang-tau/3.0)\n    )*0.5+0.5;\n}\n\nvec4 color(vec2 txy, float depth){\n    return vec4(hue(dot(txy, vec2(1.0, 0.5))*tau/12.0)*pow(depth/maxheight, 0.9), 1.0);\n}\n\nfloat map(vec3 pos, vec3 ray){\n    #ifdef use22tap\n    float dist = 1e8;\n    for(int y = (ray.z<0.0?-1:0); y <= (ray.z<0.0?0:1); y++){\n        for(int x = (ray.x<0.0?-1:0); x <= (ray.x<0.0?0:1); x++){\n            ivec2 txy = ivec2(x+int(round(pos.x)), y+int(round(pos.z)));\n            dist = min(dist, primitive(pos - vec3(txy.x, 0.0, txy.y), vec2(txy)));\n        }\n    }\n    return dist;\n    #else\n    float dist = 1e8;\n    for(int y = (ray.z<0.0?-1:0); y <= (ray.z<0.0?0:1); y++){\n        for(int x = (ray.x<0.0?-1:0); x <= (ray.x<0.0?0:1); x++){\n            ivec2 txy = ivec2(x+int(round(pos.x)), y+int(round(pos.z)));\n            dist = min(dist, primitive(pos - vec3(txy.x, 0.0, txy.y), vec2(txy)));\n        }\n    }\n    return dist;\n    #endif\n}\n\nfloat map(vec3 pos){\n    float dist = 1e8;\n    for(int y = 0; y <= 1; y++){\n        for(int x = -1; x <= 0; x++){\n            ivec2 txy = ivec2(x+int(round(pos.x)), y+int(round(pos.z)));\n            dist = min(dist, primitive(pos - vec3(txy.x, 0.0, txy.y), vec2(txy)));\n        }\n    }\n    return dist;\n}\n\nvec3 getnormal(vec3 pos){\n    //basically computes the gradient and then normalizes it.\n    float d = 0.0005;\n    float dx = (map(pos+vec3(d, 0.0, 0.0)) - map(pos-vec3(d, 0.0, 0.0)));\n    float dy = (map(pos+vec3(0.0, d, 0.0)) - map(pos-vec3(0.0, d, 0.0)));\n    float dz = (map(pos+vec3(0.0, 0.0, d)) - map(pos-vec3(0.0, 0.0, d)));\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 intersect(vec3 cam, vec3 ray, out bool collided){\n    collided = false;\n    float tdist = 0.0;\n    for(int i = 0; i < 256; i++){\n        float cdist = map(cam, ray);\n        if(cdist < near){\n            collided = true;\n            return cam;\n        }\n        if(tdist > far){\n            return vec3(0.0);\n        }\n        cam += ray * cdist * raymul;\n        tdist += cdist * raymul;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1, square aspect ratio)\n\tvec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    \n    //cam pos and ray\n    vec3 cam = vec3(0.0, 5.0, iTime*5.0);\n    vec3 ray = normalize(vec3(pos, 1.0));\n    ray = rotate(ray, vec3(1.0, 0.0, 0.0), -tau/8.0);\n    ray = rotate(ray, vec3(0.0, 1.0, 0.0), 1.0);\n    \n    //find intersection\n    bool collided;\n    vec3 intr = intersect(cam, ray, collided);\n    \n    //if we didnt find a collision, draw the sky color, else draw the object.\n    if(!collided){\n        fragColor = vec4(0.0, 0.5, 1.0, 1.0);\n    }else{\n        fragColor =\n            (vec4(dot(getnormal(intr), -normalize(intr - cam)))            //lambertian model\n            / dot(length(intr - cam), length(intr - cam)) * 20.0           //power decay\n            + vec4(dot(getnormal(intr), normalize(vec3(0.25, 0.5, -1.0)))) //sun\n            + (vec4(0.25, 0.75, 1.0, 1.0)/3.0))                            //sky\n            * color(round(intr.xz), intr.y);                               //color\n        //nonlinear light sensitivity\n        fragColor = normalize(fragColor)*clamp(exp(length(fragColor)-1.0), 0.0, 1.5);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjBWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 279, 324, 324, 952], [954, 954, 999, 999, 1072], [1073, 1100, 1136, 1136, 1213], [1215, 1215, 1235, 1235, 1338], [1340, 1340, 1374, 1374, 1464], [1466, 1466, 1496, 1496, 2217], [2219, 2219, 2239, 2239, 2523], [2525, 2525, 2550, 2612, 2898], [2900, 2900, 2954, 2954, 3302], [3304, 3304, 3361, 3433, 4574]], "test": "untested"}
{"id": "4tjBzd", "name": "Skull head", "author": "lsdlive", "description": "My second attempt to model with sphere tracing.", "tags": ["raymarching", "modelling", "skull"], "likes": 8, "viewed": 204, "published": "Public", "date": "1516879061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Skull head\n// @lsdlive\n\nmat2 r2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// iq via leon/koltes\nfloat smoo(float a, float b, float r) { return clamp(.5 + .5*(b - a) / r, 0., 1.); }\nfloat smin(float a, float b, float r) { float h = smoo(a, b, r); return mix(b, a, h) - r*h*(1. - h); }\nfloat smax(float a, float b, float r) { float h = smoo(a, b, r); return mix(a, b, h) + r*h*(1. - h); }\n\n// iq's primitives\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max((q.x*0.866025 + q.y*0.5), q.y) - h.x);\n}\n\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max(q.x*0.866025 + p.y*0.5, -p.y) - h.x*0.5);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat map(vec3 p) {\n\tmat2 r = r2d(iTime);\n\n\tp.xz *= r2d(cos(iTime)*.2);\n\tp.xy *= r2d(cos(iTime)*.2);\n\n    // \"push/pop\" transforms\n\tvec3 q = p;\n\n\n\t// Head\n\tp.y *= 1.08;\n\tfloat head1 = sphere(p, .7);\n\n\n\t// Eyes\n\tp.x = abs(p.x);\n\tp.y += .1;\n\tp.xy *= r2d(.2);\n\tp.x *= .7;\n\tp.z -= .5;\n\tp.x -= .18;\n\tfloat s2 = sdBox(p, vec3(.07, .05, .1)) - .09;\n\n\t// Face\n\tp = q;\n\tp.y += .25;\n\tp.z -= .4;\n\tfloat hex1 = sdHexPrism(p, vec2(.4, .1));\n\n\t// Nose\n\tp = q;\n\tp.y += .3;\n\tp.z -= .7;\n\tfloat tri1 = sdTriPrism(p, vec2(.15, .2));\n\tp.z += .2;\n\tp.y += .1;\n\tfloat tri2 = sdTriPrism(p, vec2(.15, .2) * .33);\n\n\n\t// Teeth\n\t// big mess of fine tuning during 30 minutes\n    // til I smin everything & give up as it is.\n\tp = q;\n\tp.x = abs(p.x);\n\tp.y += .6;\n\tp.z -= .53;\n\tp.x -= .28;\n\tp.xy *= r2d(.05);\n\tfloat b1 = sdBox(p, vec3(.024, .03, .026)*1.2) - .002;\n\tp.x += .1;\n\tp.y += .12;\n\tfloat b2 = sdBox(p, vec3(.039*p.y*10., .12, .039)*1.2);// - .02;\n\tp.y -= .12;\n\tp.x += .125;\n\tfloat b3 = sdBox(p, vec3(.04, .06, .04)*1.2) - .002;\n\t//p.x += .088;\n\t//float b4 = sdBox(p, vec3(.044));// - .02;\n\t//p.x += .088;\n\t//float b5 = sdBox(p, vec3(.048));// - .02;\n\n\tp = q;\n\tfloat d;\n\n\t// head / maw\n\td = smin(head1, hex1, .3);\n\td = max(d, -p.y - .59);\n\n\t// eye\n\td = max(d, -s2);\n\n\t// nose\n\td = smax(d, -tri1, .08);\n\td = smin(d, tri2, .03);\n\n\t// teeth\n\td = smin(d, b1, .08);\n\td = smin(d, b2, .08);\n\td = smin(d, b3, .09);\n\t//d = min(d, b4);\n\treturn d;\n\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec2 e = vec2(1., -1.)*.5773*.0005;\n\treturn normalize(e.xyy*map(pos + e.xyy) +\n\t\te.yyx*map(pos + e.yyx) +\n\t\te.yxy*map(pos + e.yxy) +\n\t\te.xxx*map(pos + e.xxx));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\tvec3 ro = vec3(0, -.1, 2.3), p;\n\tvec3 rd = normalize(vec3(uv, -1.));\n\tp = ro;\n\n\tfloat ri;\n\tfloat d;\n\tfloat t;\n\tfloat maxt = 10.;\n\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\td = map(p);\n\t\tif (d < .001 || t > maxt) break;\n\t\tt += d;\n\t}\n\n\tri /= .5;\n\n\tvec3 c = vec3(.17, .1, .1);\n\n\tif (t < maxt) {\n\t\tc = mix(c, vec3(.9, .8, .7), 1. + (ri)*p.y*8.);\n\t\tc = smoothstep(0.1, 1., c);\n\t\t//c = normal(p);\n\t}\n\n\t// centered light\n\tc = c * sqrt(1. - length(uv));\n\n\tfragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjBzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 46, 46, 113], [115, 115, 146, 146, 171], [173, 195, 234, 234, 279], [280, 280, 319, 319, 382], [383, 383, 422, 422, 485], [487, 506, 540, 540, 626], [628, 628, 662, 662, 751], [753, 753, 782, 782, 871], [873, 873, 892, 892, 2288], [2290, 2290, 2316, 2316, 2479], [2481, 2481, 2536, 2536, 3101]], "test": "untested"}
{"id": "4tjfDw", "name": "pattern01152018", "author": "edapx", "description": "flower, patterns", "tags": ["patterns", "flower"], "likes": 0, "viewed": 59, "published": "Public", "date": "1516054074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n\n// Utilities\nfloat strokeSmoot(float x, float pos, float width){\n  return smoothstep(pos, pos+0.01,x+ width*0.5) -\n         smoothstep(pos, pos+0.01,x- width*0.5);\n}\n\nfloat circle(vec2 st, float diameter){\n  return length(st - 0.5) * diameter;\n}\n\nfloat flip(float v, float pct){\n  return mix(v, 1. - v, pct);\n}\n\nfloat fill(float sdfVal, float size){\n  return smoothstep(size, size+0.02,sdfVal);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat quadrifoglio (vec2 st, float diameter, float utime, float speed, float tickness){\n  float time = utime * speed;\n  float offset = .25;\n  float cross = 2.1;\n  float petalsDist = .24;\n  float petalsThickA = -.019 + abs(cos(time * 9.) * tickness);// .5\n  float petalsThickB = -.019 + abs(sin(time * 4.5) * tickness);// .5\n  \n  float center = circle(st, diameter);\n\n  vec2 petAcen = st-vec2(offset, offset);\n  float radiusA = length(petAcen);\n  float petA = circle(petAcen,radiusA*cross);\n\n  vec2 petBcen = rotate2d(TWO_PI/4.) * petAcen;\n  petBcen -= vec2(0., -.5);\n  float radiusB = length(petBcen);\n  float petB = circle(petBcen,radiusB*cross);\n\n  float petals = strokeSmoot(petA, petalsDist,petalsThickA);\n  petals += strokeSmoot(petB, petalsDist,petalsThickB);\n\n  float color = flip(petals,\n                fill(center, .155));\n  return color;\n}\n\n\n// Example\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 bgCol = vec3(0.049,0.398,0.905);\n    vec3 fCol = vec3(0.905,0.283,0.046);\n    float timeFreq = 0.7;\n    float timeAmp = 1.2; // 4.\n    float zoom = 3.;\n    float thick =0.1; // 0.1, 0.7\n    vec2 st = fragCoord.xy/iResolution.xy;\n    // tiling\n    st.x *= iResolution.x/iResolution.y;\n    st *=zoom;\n    // offset\n    st.x += step(1.0, mod(st.y,2.0)) * 0.5;\n    st = fract(st);\n    \n    // Movement\n    //float mov = sin(mod(st.x*st.y, 2.7));\n    //float mov = sin(mod(st.y, 2.7));\n    float mov = sin(mod(st.x, 2.7));\n    float ampMov = 4.; // 24.\n\n    float draw = quadrifoglio(\n      st, 1.9,\n      sin(iTime*timeFreq)*timeAmp,\n      (mov*ampMov),\n      thick);\n    vec3 col = mix(fCol, bgCol, draw);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 43, 94, 94, 195], [197, 197, 235, 235, 275], [277, 277, 308, 308, 340], [342, 342, 379, 379, 426], [428, 428, 456, 456, 542], [544, 544, 631, 631, 1394], [1397, 1408, 1464, 1464, 2209]], "test": "untested"}
{"id": "4tjfRV", "name": "Devil Rorschach", "author": "Flopine", "description": "Still experimenting to find great effects :) ", "tags": ["3d", "raymarching", "twisting"], "likes": 8, "viewed": 189, "published": "Public", "date": "1516534563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind and Leon for teaching me!\n\n#define ITER 100\n#define PI 3.141592\n#define TAU 2.*PI\n\n\n// UTILITIES ////////////////////////\nmat2 rot (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2 (c,s,-s,c);\n}\n\nvec2 moda (vec2 p, float per)\n{\n\tfloat angle = atan(p.y,p.x);\n    float l = length(p);\n    angle = mod(angle-per/2.,per)-per/2.;\n    return vec2 (cos(angle),sin(angle))*l;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// PRIMITIVES ////////////////////////\nfloat cylY (vec3 p, float r)\n{\n    return length(p.xz)-r;\n}\n\n\n// MAPS ////////////////////////\nfloat twist (vec3 p, float r)\n{\n    p.xz *= rot(iTime+p.y*1.7);\n    p.xz = moda(p.xz, TAU/3.);  \n    p.x -= 0.5;\n\n    return cylY(p,r);\n}\n\n\nfloat crossy (vec3 p)\n{\n    float t1 = twist(p, 0.1);\n    p.xy *= rot(PI/4.);\n    float t2 = twist(p,0.2);\n    p.xy *= rot(PI/4.);\n    float t3 = twist(p,0.1);\n    \n    return smin(smin(t1,t2, 0.3),t3, 0.3);\n}\n\nfloat sdf(vec3 p)\n{\n    p.xz = abs(p.xz);\n    p.xy *= rot (iTime);\n    p.xz *= rot (sin(iTime));\n    return crossy(p);\n}\n\n\n// MAIN ////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy)-1.;\n    uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 p = vec3 (0.001, 0.001, -3.);\n    vec3 dir = normalize(vec3(uv,1.));\n    \n    float shad = 0.;\n    vec3 color = vec3 (0.);\n    \n    for (int i=0;i<ITER;i++)\n    {\n        float d = sdf(p);\n        if (d<0.001)\n        {\n            shad = float(i)/float(ITER);\n            break;\n        }\n        else shad = 1.;\n        p+=d*dir;\n    }\n    \n\tfragColor = vec4(vec3(shad),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjfRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 161, 185, 185, 267], [269, 269, 300, 300, 442], [444, 444, 483, 483, 576], [578, 617, 647, 647, 676], [679, 712, 743, 743, 849], [852, 852, 875, 875, 1061], [1063, 1063, 1082, 1082, 1183], [1186, 1219, 1276, 1276, 1765]], "test": "untested"}
{"id": "4tjfW1", "name": "Mystery of Space", "author": "PrzemyslawZaworski", "description": "Simple shader which I developed for checking capabilities of old Raspberry Pi 1 model B.\nSee: [url] https://www.youtube.com/watch?v=IxM3vKrs1PI[/url]", "tags": ["2d", "colors", "effect", "pattern"], "likes": 3, "viewed": 124, "published": "Public", "date": "1515664157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy -iResolution.xy)/iResolution.y;\n\tfloat L = length(uv)*4.0;\n    float K = atan (uv.y,uv.x)+iTime;\n    float X = (mod(sin(K*3.0),cos(K*3.0)));\n    float Y = (mod(cos(K*3.0),sin(K*3.0)));\n    vec3 A = vec3(X,X,1.0-X);\n    vec3 B = vec3(Y+1.0,Y+2.0,Y+5.0);\n    vec3 T = 1.0-vec3(sin(iTime)*L,cos(iTime)*L,cos(iTime)*L);\n    vec3 color = vec3(0.9-smoothstep(A,B,T));\n\tfragColor = vec4(vec3(0.9,0.9,0.5)*color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjfW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 498]], "test": "untested"}
{"id": "4tjfWV", "name": "Smooth Cell Noise Domain Distort", "author": "TinyTexel", "description": "Smooth Cell Noise:            https://www.shadertoy.com/view/MdByzD\nCellTex Domain Distortion: https://www.shadertoy.com/view/4sBcRm\n", "tags": ["shader"], "likes": 3, "viewed": 105, "published": "Public", "date": "1517250531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n*/\n\n//smoothness settings (middle E, right S):\n#define E 8.0\n#define S 22.0 \n\n\n#define Time iTime\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define clamp(x) clamp(x, 0.0, 1.0)\n\n\nconst float Pi = 3.14159265359;\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n\nfloat FwdPot_RcpExp(float d, float s)\n{\n\treturn 1.0 / (exp2(d * s) - 1.0);\n}\n\nfloat InvPot_RcpExp(float d, float s)\n{\n\treturn log2(1.0 / d + 1.0) / s;\n}\n\n\nfloat FwdPot_RcpPowExp(float d, float e, float s)\n{\n\ts /= e;\n\treturn pow(exp2(d * s) - 1.0, -e);\n}\n\nfloat InvPot_RcpPowExp(float d, float e, float s)\n{\n\ts /= e;\n\treturn log2(pow(d, -1.0 / e) + 1.0) / s;\n}\n\n\nfloat FwdPot_RcpPow(float d, float e)\n{\n\treturn pow(d, -e);\n}\n\nfloat InvPot_RcpPow(float d, float e)\n{\n\treturn pow(d, -1.0 / e);\n}\n\n\nvec3 CellTex(vec2 p, float seed, vec2 cells)\n{\n\tfloat d1;\n\tvec2 p1;\n\tvec2 cv1;\n\t\n\tvec2 p_i = floor(p);\n\t\n\td1 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < d1)\n\t\t{\n\t\t\td1 = d;\n\t\t\tp1 = fp;\n\t\t\tcv1 = cv;\n\t\t}\n\t}\n\t\n    float e = E;\n    float s = S;\n    \n    e = 4.0;\n    s = 12.0;\n    \n\tfloat dd1 = 64.0;\n\tfloat dd2 = 0.0;\n    float dd3 = 0.0;\n    \n    const float n = 2.0;\n\tfor(float i = -n; i <= n; ++i)\n\tfor(float j = -n; j <= n; ++j)\n\tif(i != cv1.x || j != cv1.y)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t    float d = dot(p - (p1 + fp) * 0.5, normalize(p1 - fp));\n\t\td *= 1.48;// empirically normalized\n\n\t\tdd1 = min(dd1, d);\n        dd2 += FwdPot_RcpPow(d, e);\n\t\tdd3 += FwdPot_RcpExp(d, s);\n\t}\n\t\n    //return InvPot_RcpExp(dd3, s);    \n    //return InvPot_RcpPow(dd2, e);\n\treturn vec3(dd1, InvPot_RcpPow(dd2, e), InvPot_RcpExp(dd3, s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 tex = uv / iResolution.xy;\n    \n    uv.x = mod(uv.x, iResolution.x / 3.0);\n    \n    vec2 cells = vec2(0.0);\n    //cells = vec2(5.0);// 5 cells per tile\n    \n    vec2 pos = uv * 0.02 + Time * 0.2;\n    \n    vec2 off = vec2(CellTex(pos, 0.1, cells).y, \n                    CellTex(pos, 0.2, cells).y) - vec2(0.25);\n    \n    vec3 r = CellTex(pos + off*0.4, 0.0, cells);\n    r *= r;\n    //r -= 0.1;\n    //r.x /= length(vec2(dFdx(r.x), dFdy(r.x)));\n    //r.y /= length(vec2(dFdx(r.y), dFdy(r.y)));\n    //r.z /= length(vec2(dFdx(r.z), dFdy(r.z)));\n    //r = abs(mod(r * 0.125, 1.0) * 2.0 - 1.0) * 2.0 - 1.0;\n    \n    float r0 = tex.x < 1.0/3.0 ? r.x : \n               tex.x < 2.0/3.0 ? r.y : r.z;\n    \n    if(tex.y > 0.5)\n    r0 = r.x - r0;\n    \n    vec3 col = vec3(r0-0.0)*1.0;\n    \n    #if 0\n    if(tex.y < 0.25)\n    {\n    \tfloat stripes = abs(fract(r0 * 8.0) * 2.0 - 1.0) * 2.0 - 1.0;\n        col = vec3(1.0-clamp(r0 * 8.0), stripes, clamp(r0 * 8.0-4.0));\n    }\n    #endif\n    \n    fragColor = vec4(pow(clamp(col), vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 302, 328, 328, 365], [367, 367, 390, 390, 404], [405, 405, 428, 428, 446], [447, 447, 470, 470, 488], [489, 489, 512, 512, 530], [532, 532, 558, 558, 611], [613, 613, 638, 638, 680], [683, 683, 722, 722, 759], [761, 761, 800, 800, 835], [838, 838, 889, 889, 936], [938, 938, 989, 989, 1042], [1045, 1045, 1084, 1084, 1106], [1108, 1108, 1147, 1147, 1175], [1178, 1178, 1224, 1224, 2479], [2481, 2481, 2538, 2538, 3607]], "test": "untested"}
{"id": "4tjfWz", "name": "Sin Terrain", "author": "Brendan", "description": "A ray-marched terrain based on a sin wave with shadows and \"phong shading\" (in quotes coz there's no specular shading). ", "tags": ["raymarching", "terrain"], "likes": 8, "viewed": 140, "published": "Public", "date": "1515371156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//material parameters\nconst float ks = 0.0;\nconst float kd = 1.0;\nconst float ka = 1.0;\nconst float al = 20.0;\n//light parameters\nconst float ia = 0.2;\nconst vec3 lm = normalize(vec3(3,1,0));\nconst float id = 0.6;\nconst float is = 1.0;\n\nfloat t = 0.0;\n\nfloat rand2 (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand2(i);\n    float b = rand2(i + vec2(1.0, 0.0));\n    float c = rand2(i + vec2(0.0, 1.0));\n    float d = rand2(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p){\n\tfloat f = 0.0;\n    f+=0.5*noise(p); p*=2.03;\n    f+=0.25*noise(p); p*=2.03;\n    f+=0.125*noise(p); p*=2.03;\n    f+=0.0625*noise(p); p*=2.03;\n    f+=0.03125*noise(p); p*=2.03;\n    f+=0.015625*noise(p); p*=2.03;\n    f/=0.984325;\n    return f;\n}\n\nmat2 rotate(float p){\n\treturn mat2(\n    \tcos(p),sin(p),\n        -sin(p),cos(p)\n    );\n}\n\n\nfloat f(float x, float z){\n\treturn sin(x)*sin(z);\n}\n\nfloat castRay(vec3 o, vec3 r, float mint, float maxt, float delt){\n    float lh = 0.0;\n    float ly = 0.0;\n    for(t = mint; t<maxt; t+=delt){\n    \tvec3 p = o+r*t;\n        float h = f(p.x,p.z);\n        if(p.y<h){\n        \treturn t-delt + delt*(lh-ly)/(p.y-ly-h+lh);\n        }\n        lh = h;\n        ly=p.y;\n    }\n    return t;\n}\n\nvec3 sky(vec2 p){\n\tmat2 m=rotate(fbm(p+iTime));\n    \n    p*=m;\n    \n    float n=fbm(p);\n    \n    n=abs(n);\n    \n    //n = pow(n,2.0);\n    \n    vec3 fc = vec3(n);\n    \n    fc*=vec3(0.1,0.6,0.8);\n    \n    return fc;\n}\n\n/*vec3 getNormal( vec3 p )\n{\n    float eps = 0.01;\n    vec3 n = vec3( f(p.x-eps,p.z) - f(p.x+eps,p.z),\n                         2.0f*eps,\n                         f(p.x,p.z-eps) - f(p.x,p.z+eps) );\n    return normalize( n );\n}\n*/\nvec3 phong(vec3 n, vec3 v){\n    \n    vec3 rm = 2.0*dot(lm,n)*n-lm;\n    \n    float a = ka*ia;\n    float d = kd*clamp(dot(lm,n),0.0,1.1)*id;\n    float s = 0.0; //(no specular in this scene)ks*pow(clamp(dot(rm,v),0.0,1.0),al)*is;\n    \n    return vec3(a,d,s);\n        \n   }\n\nvec3 calcNormal(vec3 p){\n\tfloat dx=sin(p.z)*cos(p.x);\n    float dz=sin(p.x)*cos(p.z);\n    \n    vec3 n = vec3(dx,1,dz);\n    return normalize(n);\n}\n/*\nfloat calcShadow(vec3 o){\n    float maxt=10.0;\n    float delt=0.4;\n    vec3 r = lm;\n    r.x*=-1.0;\n    for(float t=0.1; t<maxt;t+=delt){\n    \tvec3 p = o+r*t;\n        float h = f(p.x,p.z);\n        if(p.y<h){\n        \treturn 0.0;\n        }\n    }\n    return 1.0;\n}\n*/\n\nvec3 terrain(vec3 p,vec3 r){\n\tvec3 n = calcNormal(p);\n    \n    vec3 sh = phong(n,r);\n    \n    //float s = calcShadow(p);\n    //No shadows because the lighting is soft\n    \n    sh*=vec3(1,1,1);\n    \n    float ip = dot(sh,vec3(1));\n    \n    return (ip*texture(iChannel0,p.xz)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n\n    uv.x*= iResolution.x/iResolution.y;\n    \n    vec3 r = normalize(vec3(uv,2));\n    \n    vec3 o = vec3(1.0,f(1.0,iTime)+0.6,iTime);\n    \n    vec3 fc;\n    \n    float t = castRay(o,r,0.1,20.0,0.2);\n    \n    vec3 pos = o+r*t;\n    \n    if(!(t>20.0)){\n    \t\n        fc = terrain(pos,r);\n    }else{\n        \n        fc = sky(uv);\n    \n    }\n    \n    float f = length(uv);\n    \n    f=smoothstep(2.5,0.8,f);\n    \n    fc*=f;\n    \n    fc*=1.3;\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjfWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 253, 279, 279, 396], [398, 398, 424, 424, 859], [861, 861, 879, 879, 1123], [1125, 1125, 1146, 1146, 1212], [1215, 1215, 1241, 1241, 1266], [1268, 1268, 1334, 1334, 1597], [1599, 1599, 1616, 1616, 1814], [1816, 2046, 2073, 2073, 2315], [2317, 2317, 2341, 2341, 2462], [2463, 2732, 2760, 2760, 3013], [3015, 3015, 3072, 3072, 3614]], "test": "untested"}
{"id": "4tjfzy", "name": "xanders mandelbrot set", "author": "darthxander", "description": "mandelbrot test", "tags": ["fractal"], "likes": 0, "viewed": 67, "published": "Public", "date": "1516324904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //vec2 bottomleft = vec2(-.1, .7);\n    //vec2 topright = vec2(.1, .9);\n  \t\n    vec2 center = vec2(-.03, .72);\n    \n    vec2 diagonal = vec2(1, 1);\n    \n    float scale = iTime*iTime;\n    \n    vec2 bottomleft = center - diagonal/scale;\n    vec2 topright = center + diagonal/scale;\n\n    vec2 range = topright - bottomleft;\n    uv = uv*range + bottomleft;\n    \n    vec2 z = vec2(0.0, 0.0);\n    vec2 c = uv;\n    \n    bool in_set = true;\n    for (int i = 0; i < int(100); i++) {\n        if (length(z) > 2.0) {\n        \tin_set = false;   \n            break;\n        }\n        vec2 zsquared = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n        z = zsquared + c;\n    }\n    \n    \n    fragColor = vec4(vec3(in_set ? 1.0 : 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjfzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 829]], "test": "untested"}
{"id": "4tlyDH", "name": "Rings and Dots", "author": "Vovosunt", "description": "...", "tags": ["dots"], "likes": 9, "viewed": 219, "published": "Public", "date": "1515262323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define c30 0.86602540378\n#define hm  (4.0/3.0)\n#define grid 50.0\n#define constRes 900.0\n#define smooth (1.0 / constRes * grid)\n#define timeScale 1.0\n#define lThick 0.01\n#define lKnob 0.1\n#define rt (iTime * timeScale)\n#define SM(v) smoothstep(smooth,-smooth, v)\n\n\nvec2 hex(vec2 v){\n\tfloat yc = abs(fract((v.x + floor((v.y*hm + 0.5))*(c30 / 2.0))/c30) - 0.5);\n\tfloat y = floor(v.y*hm + yc);\n\tfloat x = floor(v.x/c30 + 0.5 + fract(y / 2.0))- fract(y / 2.0);\n\treturn vec2(x*c30,y /hm + 1.0/(hm * 4.0));\n}\n\nfloat rand(vec2 v){\n    return fract(sin(dot(v,vec2(5.11543,71.3132)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy  / constRes;\n    \n    vec2 c = hex(uv * grid);\n    float dist = length(uv*grid - c);\n    float nos = rand(c);\n    float nx = (nos + 0.6) * .2;\n    float line = SM(abs(dist - nx) - lThick);\n    float rrt = rt * (rand(vec2(nos)) + 1.0) + nos * 300.0;\n    float knob = length(uv * grid - c + nx * vec2(cos(rrt),sin(rrt)));\n    knob = SM(knob - lKnob);\n    float finCol = 1.0 - (knob + line);\n\tfragColor = vec4(finCol);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlyDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 282, 282, 502], [504, 504, 523, 523, 589], [591, 591, 648, 648, 1090]], "test": "untested"}
{"id": "4tSBD3", "name": "gradient basics", "author": "ShadowX", "description": "gradients draft", "tags": ["gradients"], "likes": 1, "viewed": 76, "published": "Public", "date": "1517330683", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TPI 6.28318530718\n#define minF(a) min(fract(a), fract(1.-a))\n#define sat(a) clamp(a, 0., 1.)\n\n\n//horizontal ramp\nfloat gr_x(vec2 xy, float cycles, float speed)\n{ \n    return smoothstep(0.0,1.0,fract(xy.x*cycles-iTime*speed));\n}\n\n//vertical ramp\nfloat gr_y(vec2 xy, float cycles, float speed)\n{ \n    return smoothstep(0.0,1.0,fract(xy.y*cycles-iTime*speed));\n}\n\n//circular ramp\nfloat gr_x_rad(vec2 xy, float cycles, float speed)\n{ \n    return smoothstep(0.0,1.0,fract(atan(xy.y, xy.x)*cycles/TPI-iTime*speed));\n}\n\n//radial ramp\nfloat gr_y_rad(vec2 xy, float cycles, float speed)\n{ \n    return smoothstep(0.0,1.0,fract(length(xy)*cycles/TPI-iTime*speed));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.* fragCoord.xy - iResolution.xy)/iResolution.y;\n    float c;\n    \n    \n    c = gr_x(uv, 5., .25);\n   // c = gr_y(uv, 5., .25);\n   // c= gr_x_rad(uv, 5., .25);\n    c= gr_y_rad(uv, 25., .25);\n\n\tfragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 146, 194, 194, 260], [262, 278, 326, 326, 392], [394, 410, 462, 462, 544], [546, 560, 612, 612, 688], [690, 690, 747, 747, 986]], "test": "untested"}
{"id": "4tSBDc", "name": "trippy shape", "author": "laserdog", "description": "I made a psychedelic pinwheel thing. I couldn't figure out how to get the polygon function to do rounded corners... anyone have ideas?", "tags": ["simple", "trippy"], "likes": 9, "viewed": 216, "published": "Public", "date": "1517356126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.2831\n#define steps 8.\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a)) // col1a col1b col2a col2b\n#define p0 0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  1.0, 1.0, 1.0,  0.0, 0.33, 0.67\t\n\nvec3 palette( in float t, in float a0, in float a1, in float a2, in float b0, in float b1, in float b2,\n              in float c0, in float c1, in float c2,in float d0, in float d1, in float d2)\n{\n    return vec3(a0,a1,a2) + vec3(b0,b1,b2)*cos( tau*(vec3(c0,c1,c2)*t+vec3(d0,d1,d2)) );\n}\n\nfloat polygon(vec2 p, float vertices, float size) \n{\n    float a = atan(p.x, p.y);\n    float b = tau / vertices;\n    return cos(round(a / b) * b - a) * length(p) - size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 1.4 * (uv * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    float len = length(uv);\n    uv *= rot(iTime + 2. *  sin(len + iTime * 2.));\n    float val = 1. - polygon(uv, 6., -.2 + .6 * sin(iTime));\n    \n    vec3 col = palette((ceil(val * steps) / steps * 2.), p0);\n    \n    fragColor.rgb = smoothstep(-.01, .01, val) * col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 389, 389, 480], [482, 482, 534, 534, 653], [655, 655, 712, 712, 1097]], "test": "untested"}
{"id": "4tSBWD", "name": "desmarkie_glsl_st_001", "author": "desmarkie", "description": "Learning ShaderToy shader 001\nMouse position controls center of fading area and speed of movement", "tags": ["basic", "learning", "checks"], "likes": 1, "viewed": 63, "published": "Public", "date": "1515714107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat checkSize = 25.0;\nfloat spotRadius = 256.0;\nvec2 center;\nfloat sinVal = 0.0;\nvec2 offset = vec2( 0.0, 0.0 );\n\nvec2 getGridReference( vec2 coord )\n{\n    \n    return vec2( coord.x / checkSize, coord.y / checkSize );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \tspotRadius = 64.0 + pow( abs( 128.0 * cos( iTime * 0.35 ) ), 1.3 );\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    offset.x += ( iTime * 60.0 ) * ( ( iMouse.x / iResolution.x ) * 3.0 );\n    offset.y += ( iTime * 60.0 ) * ( ( iMouse.y / iResolution.y ) * 3.0 );\n    \n    vec2 gridRef = getGridReference( fragCoord.xy + offset );\n\t\n    int x = int(round(gridRef.x));\n    int y = int(round(gridRef.y));\n    center = iResolution.xy / 2.0;\n    float divAmt = 360.0 / 720.0;\n    float dist = 1.0 - ( round( length( fragCoord.xy - iMouse.xy ) / divAmt ) / ( spotRadius / divAmt )  );\n    vec4 col = vec4( uv.x, dist, uv.y, 1.0 );\n    if( ( x % 2 == 0 && y % 2 == 0 ) || ( x % 2 == 1 && y % 2 == 1 ) ) col.xyz *= vec3( 1.0 - dist, max( dist, 1.0 ), ( dist + 1.0 ) / 2.0 );\n\telse col.xyz *= vec3( 0.2 * dist, 0.4 - dist, 0.2 * dist );\n    \n    fragColor = col;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSBWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 154, 154, 227], [229, 229, 286, 286, 1161]], "test": "untested"}
{"id": "4tSfRc", "name": "RGB strobe", "author": "vladstorm", "description": "best shader ever. use fullscreen", "tags": ["rgb", "strobe"], "likes": 3, "viewed": 249, "published": "Public", "date": "1516815711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t\n   float f = 3.0; //frequency\n   float s = 20.; //speed    \n   vec3 sh = vec3(0.,2.,4.);\n    \n   vec3 c = sin(f * t * s + sh) * .5 + .5;\n    \n   fragColor = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSfRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 289]], "test": "untested"}
{"id": "4tSfzW", "name": "Raymarching + CSG", "author": "PGrad", "description": "CSG means \"Constructive Solid Geometry\": https://en.wikipedia.org/wiki/Constructive_solid_geometry\nSigned Distance Functions from here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nRaymarching algorithm from here: http://jamie-wo", "tags": ["raymarching", "csg", "dreidel", "paul"], "likes": 1, "viewed": 91, "published": "Public", "date": "1514773283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float SPHERE_RADIUS = 1.;\n\n//For each of the CSG logic functions, it is helpful to\n//think about a Venn Diagram and calculating the sdf of points\n//inside each circle.\n\n//Also known as \"nearest\". Chooses the closest shape,\n//i.e. the most negative/interior of two intersecting shapes.\nvec2 csg_union(vec2 shape1, vec2 shape2) {\n\tvec2 res;\n    if(shape1.x < shape2.x)\n        res = shape1;\n    else\n        res = shape2;\n    return res;\n}\n\n//Chooses the shape with the farthest sdf. This gives the \n//intersection because given 2 intersecting objects and a ray,\n//we always choose the furthest away (least negative).\nvec2 intersect(vec2 shape1, vec2 shape2) {\n\tvec2 res;\n    if(shape1.x > shape2.x)\n        res = shape1;\n    else\n        res = shape2;\n    return res;\n}\n\n//A - B is A intersect (negate B)\nvec2 diff(vec2 shape1, vec2 shape2) {\n    return intersect(shape1, vec2(-shape2.x, 0.));\n    \n}\n\nfloat yCylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat xCylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.yz-c.xy)-c.z;\n}\n\nfloat zCylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.xy-c.xy)-c.z;\n}\n\n//Signed distance function for a box centered at origin.\nfloat boxSDF(vec3 samplePoint, vec3 rt_corner, vec3 c) {\n\tvec3 dist = abs(samplePoint - c) - rt_corner;\n    return min(\n        \t   max(dist.x, max(dist.y, dist.z)),\n               0.\n       \t   ) \n           + length(max(dist, 0.));\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint, float s, vec3 c) {\n    return length(samplePoint - c) - s;\n}\n\nfloat coneSDF( vec3 p, vec3 c ) {\n    // c must be normalized\n    float q = length(p.xz);\n    return dot(c.xy,vec2(q,p.y - c.z));\n}\n\nfloat ellipsoidSDF( in vec3 p, in vec3 r, vec3 c)\n{\n    return (length( (p - c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec2 idShape(float dist, float id) {\n\treturn vec2(dist, id); \n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec2 sceneSDF(vec3 samplePoint) {\n    float id = 1.;\n    vec2 ground = idShape(boxSDF(samplePoint, vec3(50., 0., 50.), vec3(0., -1.1, 0.)), id++);\n    vec2 sd_box = idShape(boxSDF(samplePoint, vec3(.5, .3, .5), vec3(0., 0., 0.)), id++);\n    vec2 sd_cyl = idShape(yCylinderSDF(samplePoint, vec3(0., .0, .1)), id++);\n    vec2 sd_cyl_z = idShape(zCylinderSDF(samplePoint, vec3(0., .2, .718)), id++);\n    vec2 sd_cyl_x = idShape(xCylinderSDF(samplePoint, vec3(.2, 0, .718)), id++);\n    vec2 cyl_bounded = intersect(sd_cyl,\n                       \t\tidShape(sphereSDF(samplePoint, .6, vec3(0., .7, 0.)), id++));\n    vec2 cyl_bounded_z = intersect(sd_cyl_z, \n                        \tidShape(boxSDF(samplePoint, vec3(.5, 1., .5), vec3(0., -.8, 0.)), id++));\n    vec2 cyl_bounded_x = intersect(sd_cyl_x, \n                        \tidShape(boxSDF(samplePoint, vec3(.5, 1., .5), vec3(0., -.8, 0.)), id++));\n    vec2 ellip = idShape(ellipsoidSDF(samplePoint, vec3(.87, 1.5, .87), vec3(0., 0.4, 0.)), id++);\n    vec2 bottom_bound = idShape(boxSDF(samplePoint, vec3(.5, .6,.5), vec3(0., -.95, 0.)), id++);\n    vec2 bottom = intersect(ellip, bottom_bound);\n    return csg_union(ground,\n               csg_union(cyl_bounded,\n                         csg_union(\n                                   csg_union(cyl_bounded_x,\n                                             csg_union(sd_box, cyl_bounded_z)),\n                         bottom)\n               )\n           );\n}\n\nvec3 estimateNormal(vec3 p) {\n\treturn normalize(\n        \t\tvec3(\n                    sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - \n                    sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n                    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - \n                    sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n                    sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).x - \n                    sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n               \t)\n           );\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 sd = sceneSDF(eye + depth * marchingDirection);\n        if (sd.x < EPSILON) {\n\t\t\treturn vec2(depth, sd.y);\n        }\n        depth += sd.x;\n        if (depth >= end) {\n            return vec2(end, 0.);\n        }\n    }\n    return vec2(end, 0.);\n}\n            \nfloat lambert(vec3 n, vec3 l) {\n\treturn clamp(dot(n, l), 0., 1.);\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 rotate(vec3 p, float angle) {\n\treturn vec3(\n        \t\tdot(p.xz, vec2(cos(angle), -sin(angle))),\n        \t\tp.y,\n        \t\tdot(p.xz, vec2(sin(angle), cos(angle)))\n           );\n}\n\nmat4 lookAt(vec3 p, vec3 center, vec3 up) {\n    vec3 fwd = normalize(center - p);\n    \n    vec3 strafe = normalize(cross(fwd, up));\n    \n    vec3 new_up = cross(strafe, fwd);\n    \n    return mat4(vec4(strafe, 0.),\n               \tvec4(new_up, 0.),\n                vec4(-fwd, 0.),\n                vec4(vec3(0.), 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(90.0, iResolution.xy, fragCoord);\n    float freq = 5.;\n    vec3 eye = vec3(0., 1., 0.) + 3. * vec3(cos(iTime * freq), 0., sin(iTime * freq));\n    dir = (lookAt(eye, vec3(0.), vec3(0., 1., 0.)) * vec4(dir, 1.)).xyz; \n    vec2 sd = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    float dist = sd.x;\n    float type = sd.y;\n    vec3 iXPos = eye + dist * dir;\n    \n    vec3 light = eye;\n    vec3 lightDir = normalize(light - iXPos);\n    vec3 normal = estimateNormal(iXPos);\n    float lambert = lambert(normal, lightDir);\n    float ambient = 0.1;\n    vec3 color;\n    \n    // Didn't hit anything\n    color = ((dist > MAX_DIST - EPSILON) ? vec3(0.) :\n               (type > .5 && type < 1.5) ? vec3(.8, .4, 0.) :\n \t\t\t\t\t\t\t\t\t\t   vec3(0., 0., .9)) * (lambert + ambient);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSfzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 415, 457, 457, 567], [569, 746, 788, 788, 898], [900, 934, 971, 971, 1029], [1031, 1031, 1069, 1069, 1103], [1105, 1105, 1143, 1143, 1177], [1179, 1179, 1217, 1217, 1251], [1253, 1310, 1366, 1366, 1545], [1547, 1636, 1688, 1688, 1730], [1732, 1732, 1765, 1793, 1863], [1865, 1865, 1916, 1916, 1982], [1984, 1984, 2020, 2020, 2047], [2049, 2289, 2322, 2322, 3739], [3741, 3741, 3770, 3770, 4222], [4224, 4645, 4735, 4735, 5070], [5084, 5084, 5115, 5115, 5151], [5153, 5407, 5472, 5472, 5604], [5606, 5606, 5640, 5640, 5787], [5789, 5789, 5832, 5832, 6107], [6109, 6109, 6166, 6166, 7010]], "test": "untested"}
{"id": "ll2BRK", "name": "Dabbling with reflection", "author": "Axioplase", "description": "Raytracer with reflections.\nI'm not sure why there's noise on the sphere when I increase the number of times my ray bounces.\nI also unsuccessfully tried to make the reflection go away as the ball was far away from the plane.", "tags": ["raytracer", "reflections"], "likes": 1, "viewed": 92, "published": "Public", "date": "1516585892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPHERE 0\n#define PLANE 1\n    \nstruct sphere_t {\n    // int id;\n    vec3 center;\n    float radius;\n    vec3 colour;\n    float reflectivity;\n};\n\nstruct plane_t {\n    vec3 p0;\n    vec3 normal;\n    vec3 colour;\n    float reflectivity;\n\n};\n\nstruct hit_t {\n    vec3 hitPos;\n    vec3 normal;\n    int hitKind; // SPHERE or PLANE\n};\n\nsphere_t sphere;\nplane_t plane;\nfloat pi = 3.14159265;\n\nvoid castRay(in vec3 orig, in vec3 direction, in plane_t plane, inout hit_t store) {  \n    float distanceFromOrigin = dot((plane.p0 - orig), plane.normal) / dot(direction, plane.normal);\n    if (distanceFromOrigin > 0.) {\n        if (distanceFromOrigin < length(store.hitPos - orig)) {\n            store.hitKind = PLANE;\n            store.hitPos = orig + direction*distanceFromOrigin;\n            store.normal = plane.normal;\n        }\n    }\n}\n\nvoid castRay(in vec3 orig, in vec3 direction, in sphere_t sphere, inout hit_t store) {  \n    vec3 l = sphere.center - orig;\n    float ta = dot(l, direction);\n    \n    if (ta <= 0.) { //sphere.radius) {\n        return; // we're inside the sphere, or it's behind us. Let's ignore.\n    }\n    \n    float d = sqrt(dot(l,l) - ta*ta);\n        \n    if (d >= sphere.radius) {\n        return; // no intersection\n    }\n    \n    vec3 proj = orig + direction*ta; // This is the projection of center on ray.\n    \n    float distFromProjSoThatOnSphere = sqrt(sphere.radius * sphere.radius - d*d);\n    vec3 vectorsToIntersections = direction*distFromProjSoThatOnSphere;\n    vec3 intersection1 = proj - vectorsToIntersections; // closer\n    vec3 intersection2 = proj + vectorsToIntersections;\n    vec3 bestHit;\n  \tbestHit = intersection1;\n    \n    float distanceToOrigin = length(bestHit - orig);\n    if (distanceToOrigin < length(store.hitPos - orig)) {\n        store.hitKind = SPHERE;\n        store.hitPos = bestHit;\n        store.normal = normalize(bestHit - sphere.center);\n    }\n}\n\nvec3 colourAt(in vec3 direction, in hit_t hit) {\n    switch (hit.hitKind) {\n        case SPHERE:\n        // return sphere.colour * exp(dot(direction, hit.normal)); // cool too.\n        return sphere.colour * -min(0., dot(direction, hit.normal));\n        case PLANE:\n        return texture(iChannel0,vec2(sin(iTime)+hit.hitPos.z/10., cos(iTime)+hit.hitPos.x/10.)).rgb;\n    }\n}\n\nfloat lerp(float a, float b, float x) {\n    return (1.-x)*a + x*b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5; // center\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = vec4(0.);\n    fragColor.w = 1.;\n    \n    vec3 camera = vec3(2.*sin(iTime), 10.+4.*sin(iTime), 8.+2.*cos(iTime));\n    vec3 lookAt = vec3(0., 2., 2.);\n    vec3 f = normalize(lookAt - camera);\n    vec3 r = cross(vec3(0.,1.,0.), f);\n    vec3 u = cross(f, r);\n    float zoom = 2.0;\n    vec3 center = camera + f * zoom;\n    vec3 i = center + uv.x*r + uv.y*u;\n    vec3 direction = normalize(i - camera);\n\n    ///////////////////////////\n    sphere.radius=1.;\n     sphere.colour=vec3(lerp(0.3, 0.5, (1.+cos(iTime/2.))), lerp(0.2,0.7, 0.6*(1.+sin(iTime))), lerp(0.3, .8, 0.4*(1.+sin(iTime))));\n    //sphere.colour=vec3(.7);\n    sphere.center=vec3(0., sin(iTime*2.)+1.+sphere.radius, 1.0);\n    sphere.reflectivity=.7;\n\n    plane.p0 = vec3(0., 0., 0.);\n    plane.normal = vec3(0., 1., 0.);\n    plane.colour=vec3(0., 0., 1.);\n    plane.reflectivity=.4;\n\n    ///////////////////////////\n    \n    hit_t closest;\n    closest.hitPos = vec3(1e3); // far away    \n    castRay(camera, direction, plane, closest);\n    castRay(camera, direction, sphere, closest);\n    \n    // there was no hit, so return the backgroud\n    if (closest.hitPos == vec3(1e3)) {\n        return;\n    }\n\n    // there was a hit\n    vec3 hitPos = closest.hitPos;\n    vec3 normal = closest.normal;\n    \n    // ambient?\n    fragColor.xyz = colourAt(direction, closest);\n    \n    // add a reflection. Light can bounce 'bounce' times!\n    hit_t origin = closest;\n    vec3 lastDirection = direction;\n    vec3 lastNormal = normal;\n    float runningDistance = length(hitPos - camera);\n    \n    int bounce;\n    for (bounce = 0; bounce < 4; bounce++) {\n    \n        hit_t refHit;\n        refHit.hitPos=vec3(1e3);\n        vec3 reflection = lastDirection - 2.*dot(lastDirection, lastNormal) * lastNormal;\n        if (closest.hitKind == SPHERE) {\n            castRay(origin.hitPos, reflection, plane, refHit);\n        } else {\n            castRay(origin.hitPos, reflection, sphere, refHit);\n        }\n\n        // there was no hit, so return the background\n        if (refHit.hitPos == vec3(1e3)) {\n            return;\n        }\n\n        vec3 colourAt1 = colourAt(reflection, refHit);\n        runningDistance += length(refHit.hitPos - origin.hitPos);\n        colourAt1 *= 22./runningDistance;\n\n        // There must be a way to reduce reflection of stuff that's far, but I couldn't get that to work...\n        vec3 addition = (origin.hitKind == SPHERE ? sphere.reflectivity : plane.reflectivity) *\n            .2 * colourAt1 ;\n        // float dist = length(refHit.hitPos - origin.hitPos);\n        fragColor.xyz += addition/float((bounce+1)*(bounce+1));     \n        \n        origin = refHit;\n        lastDirection = reflection;\n        lastNormal = refHit.normal;\n    }    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2BRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 389, 473, 473, 832], [834, 834, 920, 920, 1901], [1903, 1903, 1951, 1951, 2278], [2280, 2280, 2319, 2319, 2348], [2350, 2350, 2407, 2407, 5254]], "test": "untested"}
{"id": "ll2BRW", "name": "eye eye", "author": "krwq", "description": "eye eye", "tags": ["eyeeye"], "likes": 2, "viewed": 151, "published": "Public", "date": "1514892589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    float dist = length(uv);\n    float angle = atan(uv.y, uv.x);\n    float t = iTime;\n    float s = mix(0.03, 0.15, abs(sin(t)));\n    float n = 15.;\n    float len = n * s;\n    \n    vec3 x;\n    for (int i = 0; i < 3; i++)\n    {\n        float r = len / 2.0 / pi + float(i) * 0.02;\n\n        uv = vec2(angle * len / 2.0 / pi + mix(-dist * 3., 0., tanh((dist * 3.0 + 1.) / 2.)), dist - r);\n        uv.x = abs(mod(uv.x, s) - s / 2.0);\n\n        x[i] = smoothstep(1., 0., pow(length(uv / 0.1), 0.8));\n    }\n\tfragColor = vec4(x, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2BRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 679]], "test": "untested"}
{"id": "ll2Bzd", "name": "polar 4 ( 211 chars )", "author": "FabriceNeyret2", "description": "( finally, I prefer the square tiles to disks )", "tags": ["2tweets", "short", "golfing"], "likes": 9, "viewed": 1840, "published": "Public API", "date": "1516916753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/lt2Bzd\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 U = u+u - iResolution.xy;\n    float T = 6.2832, l = length(U) / 30.,  n = floor(l),\n          a = fract( ( atan(U.x,U.y) - iTime *(n-5.1) ) /T ) *n*7.;\n    O = ( .6 + .4* cos( n + floor(a) + vec4(0,23,21,0) ) )\n          * min(1., 3.-6.*length(fract(vec2(l,a))-.5) ); }\n              \n              \n      \n              \n              \n/** // 211 char, with color discontinuity at bottom \n\n#define mainImage(O,u)                                      \\\n    vec2 U = u+u - iResolution.xy;                          \\\n    float T = 6.2832, l = length(U) / 30.,  n = floor(l),   \\\n          a = ( atan(U.x,U.y) - iTime *(n-5.1) ) * n *7./T;  \\\n    O = ( .6 + .4* cos(n+floor(a)+vec4(0,23,21,0)) )        \\\n         * min(1., 3.-6.*length(fract(vec2(l,a))-.5) )\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2Bzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 85, 85, 364]], "test": "untested"}
{"id": "ll2Bzy", "name": "Worm sun", "author": "skaplun", "description": "Tryin to reproduce Dave Whyte's animation.\nOriginal: https://dribbble.com/shots/3868342-Worm-Sun", "tags": ["2d", "wave", "animation", "sine"], "likes": 8, "viewed": 320, "published": "Public", "date": "1516377615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define MAGENTA vec3(.24, .1, .35)\n#define WHITE vec3(1.)\n#define REPETITIONS 5\n#define DELTA PI/float(REPETITIONS)\n#define THICKNESS .025\n#define ES (6./iResolution.y)\n#define rMat(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\nfloat rm(float value, float min, float max) {\n    return clamp((value - min) / (max - min), 0., 1.);\n}\n\nfloat makeSignWave(vec2 st, float waveCenter, float waveLength, float addWave){\n    float xSign = sign(st.x);\n    float s = sin(st.x * 7. + iTime * 2. * xSign + addWave) * (.05 + pow(rm(length(st), waveCenter - waveLength, waveCenter + waveLength), 1.5) * .2);\n    float curWidth = pow(1. - rm(abs(waveCenter - abs(st.x)), 0., waveLength), 1.5) * THICKNESS;\n    \n    return smoothstep(ES, 0., abs(st.y - s) - curWidth)\n         * smoothstep(ES, 0., abs(abs(st.x)-waveCenter)-waveLength);\n}\n\nfloat clr(vec2 st){\n    float color = 0.;\n    for(int i=0; i<3; i++)\n        color += makeSignWave(st, .5 + .1 * float(i), .3, PI/2.*float(i));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = ( fragCoord * 2. - iResolution.xy ) / iResolution.y;\n    st *= 1.2;\n    float color = clr(st);\n    for(int i=0; i<REPETITIONS; i++, st *= rMat(DELTA))\n        color += clr(st);\n    fragColor = vec4(mix(MAGENTA, WHITE, color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2Bzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 294, 294, 351], [353, 353, 432, 432, 842], [844, 844, 863, 863, 1007], [1009, 1009, 1066, 1066, 1310]], "test": "untested"}
{"id": "ll2fWD", "name": "simple ripple 2", "author": "lhog", "description": "ripple", "tags": ["ripple"], "likes": 1, "viewed": 66, "published": "Public", "date": "1515886776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define nsin(x) sin(x) + 0.5f\n\nvec2 getRippleLinearFallCoord(in vec2 uv, in vec2 point, float mag, float waveFreq, float waveSpeed, float waveDist, in float time)\n{\n\tvec2 dir = uv - point;    \n    float dist = distance(uv, point);\n    float magMult = (1.0 - smoothstep(0.0f, waveDist, dist));\n    vec2 offset = dir * (nsin(dist * waveFreq - iTime * waveSpeed)) * mag * magMult;\n    return offset;\n}\n\nvec2 getRippleCoord(in vec2 uv, in vec2 point, float mag, float waveFreq, float waveSpeed, in float time)\n{\n\tvec2 dir = uv - point;    \n    float dist = distance(uv, point);\n    vec2 offset = dir * (nsin(dist * waveFreq - iTime * waveSpeed)) * mag ;\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;   \n    \n    vec2 offset = vec2(0.0);\n    \n    offset += getRippleCoord(uv, vec2(0.5, 0.5), 0.01, 15.0, 10.0, iTime);    \n    //offset += getRippleCoord(uv, vec2(0.1, 0.1), 0.01, 15.0, 10.0, iTime);\n    //offset += getRippleCoord(uv, vec2(0.1, 0.1), 0.025, 25.0, 20.0, iTime);\n    offset += getRippleLinearFallCoord(uv, vec2(0.05, 0.05), 0.5, 35.0, 30.0, 0.2, iTime);\n    offset += getRippleLinearFallCoord(uv, vec2(0.05, 0.95), 0.5, 35.0, -30.0, 0.2, iTime);\n    \n    vec2 texCoord = uv + offset;\n    vec4 diffuse = texture(iChannel0, texCoord);    \n    \n    //if (offset.x!=0.0 || offset.y!=0.0){\n        diffuse.rgb += 15.0 * length(offset);\n    //}\n    \n    \n    fragColor = diffuse;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2fWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 164, 164, 398], [400, 400, 507, 507, 670], [672, 672, 729, 729, 1463]], "test": "untested"}
{"id": "llBBDG", "name": "Moving Arrow", "author": "frZ", "description": "da hood, and some persistence.\nand a strange pixelate bug. wtf ?", "tags": ["simple", "arrow", "graphic"], "likes": 1, "viewed": 5651, "published": "Public", "date": "1516988071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float C = 0.;\n    float spped = floor((cos(iTime+3.435)+1.)*4000.)+0.1;\n    if(iTime < 0.1)uv.x -= 0.75;\n    float t = iTime*spped;\n    if(floor(mod((t*0.1),2.)) == 0.0){\n        t *= -1.;\n    uv.x += t;\n    uv.xy *= -1.;\n    uv.y = fract(uv.y);\n    }else{\n       uv.x += t;      \n    }   \n    \n    float F = 1.0 -step( (fract(uv.x+0.5) + 1.0-uv.y),1.);\n\tfloat G = 1.0 -step( (fract(uv.x+0.5) + uv.y),1.0);\n\tC = G*F;\n    \n\tfragColor = vec4(vec3(C),1.0);\n}\n\n/// strange bug : it gets pixelated", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 564]], "test": "untested"}
{"id": "llBBW3", "name": "Harmonic_Fourier", "author": "PGrad", "description": "Fourier transform with the cycle of the fourier frequency being harmonic fractions of the wave frequency.\nCode by me.\nCritiques are welcome!", "tags": ["fourier", "fouriertransform"], "likes": 1, "viewed": 79, "published": "Public", "date": "1517354573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-6\nfloat periodic(float x, float amp, float freq, float phase, float shift) {\n\treturn cos((x + phase) * freq) * amp + shift;\n}\nfloat make01(float x, float waves, float low, float high) {\n\treturn clamp(((x + waves) / (2. * waves)) * high, low, high);\n}\nfloat over(float a, float b) {\n    return 1. - (1. - a) * (1. - b);\n}\nvec2 fourier(float g, float f, float t) {\n    float exponent = -2. * PI * f * t;\n\treturn g * vec2(cos(exponent), sin(exponent));\n}\nint getInts(float c, float mult, int range) {\n\treturn int(c * mult) % range;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= .4;\n    vec3 prevColor = vec3(0.);\n    float T = 10.;\n    float f = 60. / T;\n    vec3 color;\n    int slices = 300;\n    float ival = (360. / float(slices));\n    float t, g, fourier_r, uv_r, angle, diff, max_angle = .05, mix_val;\n    float width = .1;\n    float freq_ratio = 1. / float(getInts(make01(periodic(iTime, 1., .4, 0., 0.), 1., 0., 1.), 10. - EPSILON, 10) + 1);\n    vec2 c, uv_unit;\n    vec3 base = vec3(1., 1., 1.);\n    vec3 mixcol = vec3(0., 1., 0.);\n    for(int i = 0; i < slices; ++i) {\n        t = radians(iTime + ival * float(i));\n        g = clamp((cos(2. * PI * f * t) + 1.) / 4., 0., .5);\n        c = fourier(g, f * freq_ratio, t);\n        fourier_r = length(c);\n        uv_unit = uv - vec2(.5);\n        uv_r = length(uv_unit);\n        angle = acos(dot(uv_unit, c) / (fourier_r * uv_r));\n        diff = distance(fourier_r, uv_r);\n        mix_val = smoothstep(0., width, diff);\n        color = clamp( max( prevColor, base - over( smoothstep(0., max_angle, angle), mix_val ) ), 0., 1.) * mixcol;\n    \tprevColor = color;\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBBW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 120, 120, 169], [170, 170, 229, 229, 294], [295, 295, 325, 325, 364], [365, 365, 406, 406, 495], [496, 496, 541, 541, 574], [575, 575, 632, 632, 1805]], "test": "untested"}
{"id": "llBBWG", "name": "Controlled truchet tiles", "author": "Daedelus", "description": "Attempt at controlling truchet tiles into a designed shape without the infinity aspect to it.", "tags": ["2d", "sdf", "truchet"], "likes": 6, "viewed": 135, "published": "Public", "date": "1516982691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tiling space by this many cells\n#define WIDTH 6\n#define HEIGHT 6\n\n// look up tables\n// -1 is invisible\n// numbers 0,1,2,3 define rotation angle (steps of 90 degrees, clockwise)\n// 4 is mirrored arcs (tiles 0 and 2 added together), 5 is the 90 degree rotated version of that\nint LUT[WIDTH*HEIGHT] = int[](\n-1, 2, 1, 2, 1, -1,\n 2, 4, 5, 4, 5,  1,\n 3, 4, 4, 4, 4,  0,\n 2, 4, 5, 5, 0, -1,\n 3, 4, 4, 5, 1, -1,\n-1, 3, 0, 3, 0, -1\n);\n// to be able to move through the generated path we need to know the order of the tiles & arcs\n// this look up table tells us what tile we're on\nint OFFSET[WIDTH*HEIGHT] = int[](\n0,1,44,41,40,0,\n3,2,7,42,31,38,\n4,5,8,29,32,37,\n11,10,15,26,35,0,\n12,13,16,21,24,0,\n0,18,19,22,23,0\n);\n// this look up table is a fallback for mirrored tiles so the two arcs have their own offset\nint MIRROR_OFFSET[WIDTH*HEIGHT] = int[](\n0,0,0,0,0,0,\n0,6,43,30,39,0,\n0,9,28,33,36,0,\n0,14,27,34,0,0,\n0,17,20,25,0,0,\n0,0,0,0,0,0\n);\n// flip animation direction\nbool FLIP[WIDTH*HEIGHT] = bool[](\n    false,false,false,false,false,false,\n    false, true, true, true, true,false,\n    false,false, true,false, true,false,\n    false, true, true,false,false,false,\n    false,false, true, true,false,false,\n    false,false,false,false,false,false\n);\n// used for looping\nconst int MAX_OFFSET = 44;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get zoomed out UVs\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    uv *= 2.5;\n    \n    vec2 gUv = uv; // cache unaltered uvs\n    \n    // compute bounding box of the tiled region\n    float bounds = max(abs(uv.x)-float(WIDTH/2),abs(uv.y)-float(HEIGHT/2));\n    \n    // divide UVs into cells\n    vec2 cell = floor(uv);\n    cell = clamp(cell, vec2(-WIDTH/2, -HEIGHT/2), vec2(WIDTH/2 - 1, HEIGHT/2 - 1));\n    uv -= cell;\n    // offset UVs so 0,0 is in the center of each cell\n    uv -= 0.5;\n    \n    // get look up table index from cell\n    int idx = clamp(int(cell.x)+WIDTH/2+WIDTH*(int(cell.y)+HEIGHT/2), 0, 48);\n    // which tile?\n    int state = LUT[idx];\n    // arc color (colorized to visualize the offset lookup tables)\n    vec3 cl=vec3(0);\n    // resulting distance\n    float d;\n    if(state<0) // -1 tiles are empty\n    {\n        d = max(bounds,0.75-max(abs(uv.x),abs(uv.y)));\n    }\n    else\n    {\n        // track offset for coloring\n       \tint offset = OFFSET[idx] - 1;\n        \n        // decompose tile state to mirror and rotation\n        bool mirror = (state & 4) != 0;\n        bool flip = FLIP[idx];\n        int rotate = state & ~4;\n        if(rotate==1) // rotate 90\n            uv = vec2(-uv.y, uv.x);\n        else if(rotate==2) // rotate 180\n            uv = -uv;\n        else if(rotate==3) // rotate 270\n            uv = vec2(uv.y, -uv.x);\n        if(mirror)\n        {\n            if(uv.x>-uv.y) // mirror tile along diagonal\n            {\n                uv = -uv;\n                offset = MIRROR_OFFSET[idx] - 1; // update offset\n            }\n        }\n        \n        // put arc in corner\n        uv += 0.5;\n\t\t// circle distance field\n        // d=abs(abs(length(uv)-0.5))-0.07;\n            \n        // warp the space\n        float parameter = atan(uv.x, uv.y) / (3.14159265359 * 0.5);\n        if(flip)\n        \tparameter = 1.0 - parameter;\n        float radius = length(uv) - 0.5;\n        uv = vec2(radius * 1.3, (parameter + float(offset)));\n        uv.y = mod(uv.y, float(MAX_OFFSET));\n        \n        d = abs(uv.x) - 0.04;\n        \n        // colorize by offset\n        cl = fract(vec3(0.2, 0.05, 0.01) * float(offset));\n        \n        // slide a dot over the curve\n        float r = length(uv - vec2(0.0, mod(iTime * 4.0, float(MAX_OFFSET)))) - 0.06;\n        if(r < 0.06)\n        {\n            cl = vec3(1.0, 0.0, 0.0);\n        \td = r;\n        }\n        \n        d /= 1.3;\n    }\n    \n    float a = smoothstep(0.0, 0.04, d);\n\tfragColor = mix(vec4(cl, 1.0), \n                    0.2 * vec4(fract(d * 0.2) * 0.4 + fract(d * 0.5) * 0.3 + fract(d) * 0.2 + fract(d * 3.0) * 0.1), \n                    a);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1248, 1296, 1353, 1379, 4011]], "test": "untested"}
{"id": "llBfDD", "name": "11/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I tried out something simple: tiling.", "tags": ["tiling", "dailyshader"], "likes": 1, "viewed": 89, "published": "Public", "date": "1515793433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64\n#define PIXELR 0.5/iResolution.x\n#define FAR 80.0\n\nconst vec3 FOG_COLOR = vec3(0.5, 0.45, 0.55);\n\n//Distance functions and helpper functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0.0))) + vmax3(min(d, vec3(0.0)));\n}\n\nfloat sdf(vec3 p){\n    return fBox(p, vec3(1.0));\n}\n\n//calculate normals for objects\nvec3 normals(vec3 p){\n\tvec3 eps = vec3(PIXELR, 0.0, 0.0 );\n    return normalize(vec3(\n        sdf(p+eps.xyy) - sdf(p-eps.xyy),\n        sdf(p+eps.yxy) - sdf(p-eps.yxy),\n        sdf(p+eps.yyx) - sdf(p-eps.yyx)\n    ));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.0;\n    vec3 p = ro;\n    for(int i = 0; i < STEPS; ++i){\n        float d = sdf(p);\n        p += rd*d;\n        t += d;\n        \n        if(d < PIXELR || t >= FAR){\n            break;\n        }\n    }\n    \n\treturn t;\n}\n\n//http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot( rd, ld ), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.06);\n\tvec3  fogColor = mix(vec3(0.2), vec3(0.8, 0.7, 0.2), pow(sunAmount, 3.0));\n    return mix(col, fogColor, fogAmount);\n}\n\nvec3 color(vec3 p, vec3 ld, vec3 rd){\n    vec3 n = normals(p);\n\n    float lambertian = max(dot(n, ld), 0.0);\n\n    float angle = max(dot(reflect(-ld, n), rd), 0.0);\n    float specular = pow(angle, 10.0);\n    \n   \tvec3 col = vec3(0.7, 0.6, 0.2)+\n        lambertian*vec3(0.2) +\n        specular*vec3(0.7, 0.6, 0.7);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Tiling space..\n    vec2 q = uv *3.0;\n    q = fract(q);\n    q = -1.0+2.0*q;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(3.0*cos(iTime*0.5), 0.0, 3.0*sin(iTime*0.5));\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(50.0)));\n    \n    float t = march(ro, rd);\n    vec3 p = ro+rd*t;\n    \n    vec3 ld = (rt-ro)/distance(ro,rt);\n    \n    vec3 col = vec3(0.0);\n    if(t <= FAR){\n        col = color(p, rd, ld);\n    }\n    col = fog(col, p, ro, rd, ld);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBfDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 255, 275, 275, 305], [307, 347, 368, 368, 403], [405, 441, 469, 469, 555], [557, 557, 575, 575, 608], [610, 642, 663, 663, 859], [861, 861, 891, 891, 1122], [1124, 1177, 1231, 1231, 1471], [1473, 1473, 1510, 1510, 1803], [1806, 1806, 1863, 1863, 2584]], "test": "untested"}
{"id": "llBfRG", "name": "Learning shaders - metaballs", "author": "KebabuTurka", "description": "My second one ;)\n\nNaive approach for metaballs.", "tags": ["metaballs", "learning"], "likes": 2, "viewed": 172, "published": "Public", "date": "1516207921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 blobs[3];\nfloat thresh = 1.0;\n\nbool blobFunc(in vec2 point)\n{\n    float result = 0.0;\n \tfor(int i=0;i<blobs.length();i++)\n    {\n\t\tresult += pow(blobs[i].z,2.0) / (pow(point.x - blobs[i].x,2.0) + pow(point.y - blobs[i].y,2.0));;\n    }\n    \n    return result >= thresh;\n}\n\nfloat properSin(in float val)\n{\n    return (sin(val) + 1.0) / 2.0;\n}\n\nfloat properCos(in float val)\n{\n    return (cos(val) + 1.0) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    blobs[0] = vec3(properSin(iTime*1.5),0.5,0.1);\n    blobs[1] = vec3(0.5,properSin(iTime),0.1);\n    blobs[2] = vec3(properCos(iTime) * 0.6 + 0.2,properSin(iTime) * 0.6 + 0.2,0.05);\n    \n    fragColor = vec4(blobFunc(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBfRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 66, 66, 274], [276, 276, 307, 307, 344], [346, 346, 377, 377, 414], [416, 416, 473, 473, 746]], "test": "untested"}
{"id": "lljBRz", "name": "RayMarching problems with twist", "author": "demicuz", "description": "Problems with non-rigid transformations.", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 51, "published": "Public", "date": "1517260015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Move the mouse to bend the cube\n// Green - how many steps it took to render a pixel\n\n// comment this line to see the correct image\n#define problem  \n\n// see lines 91-95\n\nprecision highp float;\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON  = 1e-4;\n\nconst float PI = atan(1.) * 4.;\n\nvec2 m;  // normalized mouse coords, assigned in mainImage\nvec3 light = normalize(vec3(-1., -2., -4.));\n\nmat3 rotateY(float angle) {\n    float c = cos(angle),\n          s = sin(angle);\n    \n    vec3 i = vec3(c, .0,  -s);\n    vec3 j = vec3(.0, 1., .0);\n    vec3 k = vec3(s, .0, c);\n    \n    return transpose(mat3(i, j, k));\n}\n\nmat3 rotateX(float angle) {\n    float c = cos(angle),\n          s = sin(angle);\n    \n    vec3 i = vec3(1., .0, .0),\n         j = vec3(.0,  c,  s),\n         k = vec3(.0, -s,  c);\n    \n    return transpose(mat3(i, j, k));\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat weirdBoxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size / 2.;\n    \n    float mx = max(max(d.x, d.y), d.z);\n    float mn = min(min(d.y, d.y), d.z);\n    \n    float inDist  = min(mx, 0.);\n    float outDist = length(min(d, .0));\n    \n    return inDist + outDist;\n}\n\nfloat sdBox(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size / 2.;\n    \n    float mx = max(max(d.x, d.y), d.z);\n    \n    float inDist  = min(mx, 0.);\n    float outDist = length(max(d, .0));\n    \n    return inDist + outDist;\n}\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(m.x*10.0*p.y);\n    float s = sin(m.x*10.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdBox(q, vec3(1.));\n}\n\n// t.x - radius\n// t.y - thickness\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdScene(vec3 p) {\n    p = rotateX(sin(iTime/2.) * PI / 2.) * p;\n    \n    float s = m.x;\n    \n    # ifdef problem\n    \treturn opTwist(p);\n    # else\n    \treturn opTwist(p) / max((m.x*10.), 1.);\n    # endif\n}\n\n\nvec3 getNormal(vec3 p) {\n    const float eps = 3.0 * EPSILON;\n    return normalize(vec3(\n        sdScene(vec3(p.x + eps, p.y, p.z)) - sdScene(vec3(p.x - eps, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + eps, p.z)) - sdScene(vec3(p.x, p.y - eps, p.z)),\n        sdScene(vec3(p.x, p.y, p.z + eps)) - sdScene(vec3(p.x, p.y, p.z - eps))\n    ));\n}\n\n\nvec2 march(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sdScene(eye + depth * dir);\n        \n        if (dist < EPSILON) {\n            return vec2(depth, i);\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) return vec2(end, i);\n    }\n    \n    return vec2(end, MAX_MARCHING_STEPS);\n}\n\n\n// fov - in degrees\nvec3 getRayDirection(float fov, vec2 resolution, vec2 fragCoord) {\n    fragCoord -= resolution / 2.;\n    \n    float y = resolution.y / 2.;\n    float z = y / tan(radians(fov / 2.));\n    \n    return normalize(vec3(fragCoord, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tm = iMouse.xy / iResolution.xy;\n    \n    vec3 eye = vec3(.0, .0, 4.);\n    vec3 viewDir = getRayDirection(45., iResolution.xy, fragCoord);\n    \n    vec2 marched = march(eye, viewDir, MIN_DIST, MAX_DIST);\n    float dist = marched.x;\n    float st_norm = marched.y / float(MAX_MARCHING_STEPS);\n    \n    vec3 col = vec3(.0);\n    \n    if (dist > MAX_DIST - EPSILON) { // didn't hit anything\n        col = vec3(.0, st_norm, .0);\n    } else {\n        vec3 n = getNormal(eye + dist * viewDir);\n        \n        float li = dot(n, -light); // light intensity\n        \n        col = vec3(max(.1, li), st_norm, .0);\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljBRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 458, 485, 485, 677], [679, 679, 706, 706, 900], [902, 902, 935, 935, 960], [962, 962, 1000, 1000, 1232], [1234, 1234, 1266, 1266, 1458], [1460, 1460, 1485, 1485, 1646], [1648, 1683, 1716, 1716, 1781], [1783, 1783, 1806, 1806, 1995], [1998, 1998, 2022, 2022, 2338], [2341, 2341, 2397, 2397, 2754], [2757, 2777, 2843, 2843, 3007], [3010, 3010, 3067, 3067, 3715]], "test": "untested"}
{"id": "lljBWG", "name": "LessWrongUnormBoxFilter", "author": "TimothyLottes", "description": "less wrong unorm box filter", "tags": ["filter", "box"], "likes": 3, "viewed": 593, "published": "Public", "date": "1517063867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// EXAMPLE OF LESS-BAD UNORM BOX FILTER (AKA STANDARD MSAA RESOLVE)\n//\n// Usage case\n//  - Having traditional LDR RGB output for MSAA into RGBA8 UNORM surface\n//  - Want a 4xMSAA or 8xMSAA box filter (say because users want the traditional \"look\")\n//  - Want to avoid the worst non-linear average artifacts (false extra edge)\n//  - While preserving the perceptual 4 or 8 step edge gradient\n//\n// Left side is \"less-bad\" box resolve\n//  - Read from an sRGB view of the RGBA8 UNORM surface\n//  - Write to an sRGB view of the RGBA8 UNORM output\n//  - Use a custom resolve kernel\n//  - Which darkens the linear box average to something similar to the perceptual box average\n//  - While maintaining the linear box average's correct color\n//\n// Right side is standard MSAA resolve for RGBA8 UNORM data (non-linear average)\n//  - See artifact of dark line where red and green meet\n//\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n//--------------------------------------------------------------\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\n\n#define XX 64.0\n#define YY (XX*(iResolution.y/iResolution.x))\n\n// Raster one sample with output in linear color-space.\nF3 Raster(F2 uv2){\n // Rotate\n F1 ang=(iTime*(1.0/75.0))*2.0*3.14159;\n uv2.xy=F2(dot(uv2.xy,F2(cos(ang), sin(ang))),\n           dot(uv2.xy,F2(sin(ang),-cos(ang))));\n // Edge\n F1 scale=8.0;\n F1 which=fract(iTime*(1.0/4.0));\n // Switch colors over time\n F3 color0=F3(1.0,0.0,0.0);\n F3 color1=F3(0.0,1.0,0.0);\n if(which<0.25){\n  color0=F3(0.0,0.0,0.0);\n  color1=F3(1.0,1.0,1.0);}\n else if(which<0.5){\n  color0=F3(1.0,1.0,0.0);\n  color1=F3(0.0,0.0,1.0);}\n else if(which>0.75){\n  color0=F3(1.0,0.5,0.25);\n  color1=F3(0.124,0.25,0.5);}\n return fract(uv2.x*scale)>0.5?color0:color1;}\n\n// 4xMSAA box filter done the wrong way (standard MSAA resolve)\nF3 RasterP(F2 uv2){\n // Samples as generated in linear-space\n F3 c0=Raster(uv2+(F2(-2.0,-6.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c1=Raster(uv2+(F2( 6.0,-2.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c2=Raster(uv2+(F2(-6.0, 2.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c3=Raster(uv2+(F2( 2.0, 6.0)/F2(16.0,16.0))/F2(XX,YY));\n // As stored to sRGB render target\n c0=Srgb3(c0);\n c1=Srgb3(c1);\n c2=Srgb3(c2);\n c3=Srgb3(c3);\n // Return box filter average of non-linear\n return c0*0.25+c1*0.25+c2*0.25+c3*0.25;}\n \n    \n    \n// 4xSGSSAA box filter done the \"less wrong\" way\nF3 RasterP2(F2 uv2){\n // Samples as generated in linear-space\n // Stored to sRGB target then loaded from sRGB target\n // Meaning getting back linear data from LoadSample\n F3 c0=Raster(uv2+(F2(-2.0,-6.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c1=Raster(uv2+(F2( 6.0,-2.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c2=Raster(uv2+(F2(-6.0, 2.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c3=Raster(uv2+(F2( 2.0, 6.0)/F2(16.0,16.0))/F2(XX,YY));\n // Get luma\n // Using a quick approximation here {0.5,0.25,0.25}\n // Can also use a proper metric\n F1 l0=c0.g*0.5+c0.r*0.25+c0.b*0.25;   \n F1 l1=c1.g*0.5+c1.r*0.25+c1.b*0.25;   \n F1 l2=c2.g*0.5+c2.r*0.25+c2.b*0.25;   \n F1 l3=c3.g*0.5+c3.r*0.25+c3.b*0.25;\n // Linear box of luma * 4 (removes a 0.25 scale factor later)\n F1 ll=l0+l1+l2+l3;\n // Convert sample luma's to perceptual   \n // Using gamma 2.0 here because it is fast\n // Can also use the proper color space transform (slower)\n l0=sqrt(l0);\n l1=sqrt(l1);\n l2=sqrt(l2);\n l3=sqrt(l3);\n // Get perceptual box\n F1 lb=l0*0.25+l1*0.25+l2*0.25+l3*0.25;\n // Convert back to linear (undo prior gamma 2.0 conversion)\n lb*=lb;\n // Scale output linear box average by adjustment factor (0.25 scale factored prior)\n F1 s=lb/ll;\n F3 cc=c0*s+c1*s+c2*s+c3*s;\n // Shadertoy is RGBA8UNORM (instead of sRGB format) so do conversion.\n return Srgb3(cc);}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n fragColor.a=1.0;\n F2 uv=fragCoord.xy/iResolution.xy;\n // Make \"low res\"\n F2 uv2=uv;\n uv2.x*=XX;\n uv2.y*=YY;\n uv2.x=floor(uv2.x)+0.25;\n uv2.y=floor(uv2.y)+0.25;\n uv2.x/=XX;\n uv2.y/=YY;\n // Line\n if(abs(uv.x-0.5)<0.01){fragColor.rgba=F4(0.0,0.0,0.0,1.0);}\n // Split screen\n else if(uv.x<0.5){\n  fragColor.rgb=RasterP2(uv2);  \n }else{\n  fragColor.rgb=RasterP(uv2);}}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[946, 1011, 1028, 1028, 1081], [1082, 1082, 1099, 1099, 1150], [1151, 1151, 1166, 1166, 1222], [1223, 1223, 1238, 1238, 1283], [1349, 1405, 1423, 1434, 1981], [1983, 2047, 2066, 2107, 2529], [2542, 2591, 2611, 2760, 3891], [3894, 3894, 3948, 3948, 4313]], "test": "untested"}
{"id": "lljBzK", "name": "Fake volumetric clouds", "author": "vchizhov", "description": "My first shader posted on here. Some fake (in the sense of not physically realistic in terms of the mathematics/physics) volumetric clouds. The sum = sum*(1-d)+d is from the paper Volume Rendering by Drebin.", "tags": ["raymarching", "fbm", "volumetricclouds"], "likes": 12, "viewed": 956, "published": "Public", "date": "1516834433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec3 sunDir = normalize(vec3(-0.6f, 0.4f, 0.6f));\n\n// hash and noise by iq\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return 2.0f*mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z)-1.0f;\n}\n\nfloat fbm(in vec3 pos, int layers, float AM, float FM)\n{\n    float sum = 0.0f;\n    float amplitude = 1.0f;\n    for(int i=0;i<layers;++i)\n    {\n        sum += amplitude*noise(pos);\n        amplitude *= AM;\n        pos *= FM;\n    }\n    return sum;\n}\n\nfloat cloud(in vec3 p)\n{\n \t//return 0.01f*noise(10.0f*p);  \n    return 0.01f*fbm(0.9f*vec3(0.2f, 0.2f, 0.3f)*(p+vec3(0.0f, 0.0f, 3.0f*iTime)), 7, 0.5f, 4.0f);\n}\n\nvec2 renderNoise(in vec3 ro, in vec3 rd)\n{\n    float tmin=10.0f;\n    float tmax = 20.0f;\n    float delta = 0.1f;\n    float sum = 0.0f;\n    float t = tmin;\n    for(;t<tmax;t+=delta)\n    {\n        vec3 pos = ro + t*rd;\n        //if(pos.y<-10.0f || pos.y>-1.0f || pos.x>5.0f || pos.x<-5.0f) return vec2(sum, -1.0f);\n        \n        float d = max(0.0f,cloud(pos));\n        sum = sum*(1.0-d)+d;\n        if(sum>0.99f) break;\n    }\n    return vec2(sum, t);\n}\n\nfloat shadeClouds(in vec3 ro, in vec3 rd)\n{\n    float sum =0.0f;\n    float t = 0.0f;\n    float delta = 0.1f;\n    for(int i=0;i<5;++i)\n    {\n        vec3 pos = ro + rd*t;\n        float d = max(0.0f,cloud(pos));\n        sum = sum*(1.0-d)+d;\n        if(sum>0.99f) break;\n        t += delta;\n    }\n    return sum;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    const vec3 sky = vec3(0.4, 0.6, 1.0);\n    vec3 att = vec3(0.2f, 0.5f, 0.9f);\n    vec2 ns = renderNoise(ro, rd);\n    vec3 pos = ro+rd*ns.y;\n    float shad = 1.0f;//0.9f*(1.0f-shadeClouds(pos+sunDir*0.1f, sunDir));\n    float density = ns.x;\n    float inv = (1.0f-density);\n    \n    float w = 1.8f*(0.5f*rd.y+0.5f);\n    vec3 cl = shad*w*1.0f*mix(vec3(1.0f), inv*att, sqrt(density));\n    if(density<0.1f) return mix(sky, cl, max(0.0f, density)*10.0f);\n    //vec3 col = mix(sky, cl, 1.0f-exp(-0.0003*ns.y*ns.y) );\n    //if(ns.y<0.0f) return sky;\n\treturn cl; \n}\n\n#define PI 3.14159265359f\nvec3 render(vec2 ndc, float aspectRatio)\n{\n\t// camera origin\n    vec3 o = vec3(0.0f, 0.0f, 0.0f);\n\t// camera horizontal field of view\n    const float fov = 2.0f*PI / 3.0f;\n    const float scaleX = tan(fov / 2.0f);\n\t// camera right vector\n    vec3 right = vec3(1.0f, 0.0f, 0.0f)*scaleX;\n\t// camera forward vector\n    vec3 forward = vec3(0.0f, 0.0f, 1.0f);\n\t// camera up vector\n    vec3 up = vec3(0.0f, 1.0f, 0.0f)*scaleX*aspectRatio;\n\t// ray direction\n    vec3 rd = normalize(forward + ndc.x*right + ndc.y*up);\n    return render(o, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ndc = 2.0f*fragCoord.xy / iResolution.xy-1.0f;\n    vec3 col = render(ndc, iResolution.y/iResolution.x);\n    // approximate gamma correction\n    col = sqrt(col);\n\tfragColor = vec4(col,1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 82, 105, 105, 143], [145, 145, 171, 171, 550], [552, 552, 608, 608, 799], [801, 801, 825, 860, 961], [963, 963, 1005, 1005, 1415], [1417, 1417, 1460, 1460, 1728], [1730, 1730, 1767, 1767, 2327], [2355, 2355, 2397, 2415, 2892], [2894, 2894, 2951, 2951, 3149]], "test": "untested"}
{"id": "lljfD1", "name": "The green hikers duo", "author": "zproxy", "description": "fork of https://www.shadertoy.com/view/Xl2BRR\n4fps", "tags": ["walkman"], "likes": 6, "viewed": 147, "published": "Public", "date": "1515679398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------\n// Created by sebastien durand - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n\n// Change this to improve quality (3 is good)\n#define ANTIALIASING 1\n\n//#define WITH_SHADOW\n//#define WITH_AO\n\n// Isosurface Renderer\n// less makes edges glitch\n#define g_traceLimit 80\n#define g_traceSize .004\n\n#define STAR_VOXEL_STEPS 20\n#define STAR_VOXEL_STEP_SIZE 3.\n#define STAR_RADIUS .02\n\n\nfloat gTime;\n\n//---------------------------------------------------------------------\n//    Animation\n//---------------------------------------------------------------------\n\n//                       Contact           Down               Pass               Up      \nconst float ep = 16.;\nvec3[9] HEAD = vec3[9](  vec3(50,24,0),    vec3(73,30,0),     vec3(94,20,0),     vec3(117,15,0), //vec3(138,29,0), \n                         vec3(85+50,24,0), vec3(85+73,30,0),  vec3(85+94,20,0),  vec3(85+117,15,0), /*vec3(85+138,29,0),*/ vec3(168+50,24,0));\n\nvec3[9] SHOULDER = vec3[9](vec3(44,47,ep),   vec3(66,53,ep),    vec3(91,43,ep),    vec3(115,38,ep), /*vec3(140,50,15),*/ \n                         vec3(85+51,50,ep),vec3(85+73,55,ep), vec3(85+91,43,ep), vec3(85+111,37,ep), vec3(168+44,47,ep));\n\nvec3[9] ELBOW = vec3[9]( vec3(25,68,25),   vec3(46,71,25),    vec3(88,74,25),    vec3(120,69,25), //vec3(148,75,15),\n                         vec3(85+54,66,25),vec3(85+87,71,25), vec3(85+91,75,25), vec3(85+92,65,25), vec3(168+25,68,25));\n\nvec3[9] WRIST = vec3[9](vec3(20,90,15),   vec3(35,81,20),    vec3(88,106,25),   vec3(128,94,25), \n                         vec3(164,85,15),  vec3(85+102,86,20),vec3(85+88,104,25),vec3(85+82,86,20), vec3(168+20,90,15));\n\nvec3[9] HIP = vec3[9](vec3(42,90,10.),  vec3(62,95,10.),   vec3(83,88,10.),   vec3(107,83,10.),  \n                         vec3(127,92,10.), vec3(147,94,10.),  vec3(168,91,10.),  vec3(192,85,10.), vec3(42+168,90,10));\n\nvec3[9] KNEE = vec3[9]( vec3(29,118,7.),  vec3(48,120,8.),   vec3(97,117,10.),  vec3(130,107,10.), \n                         vec3(144,120,7.), vec3(167,118,7.),  vec3(167,118,7.),  vec3(181,111,7.), vec3(168+29,118,7));\n\nvec3[9] ANKLE=vec3[9](vec3(5,134,5.),   vec3(22,132,6.),   vec3(71,122,10.),  vec3(113,127,10.), \n                         vec3(162,146,5.), vec3(164,146,5.),  vec3(164,146,5.),  vec3(168,137,5.), vec3(168+5,134,5));\n\nvec3[9] FOOT = vec3[9](  vec3(14,150,10.), vec3(16,150,10.),  vec3(63,139,10.),  vec3(119,143,10.), \n                         vec3(178,139,10.),vec3(182,150,10.), vec3(182,150,10.), vec3(182,150,10.), vec3(168+14,150,10));\n\n\nvec3 shoulder1, elbow1, wrist1, head,\n     shoulder2, elbow2, wrist2;\nvec3 foot1, ankle1, knee1, hip1,\n     foot2, ankle2, knee2, hip2;\n\nmat2 rot, rot2;\n\n// Interpolate pos of articulations\nvec3 getPos(vec3 arr[9], int it, float kt, float z) {\n    it = it%8;\n    vec3 p = mix(arr[it], arr[it+1], kt);\n\treturn .02*vec3(p.x+floor(gTime/8.)*168., 150.-p.y, p.z*z);\n}\n\n\n//---------------------------------------------------------------------\n//    HASH functions (iq)\n//---------------------------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nvec3 hash33( const in vec3 p) {\n    return fract(vec3(\n        sin( dot(p,    vec3(127.1,311.7,758.5453123))),\n        sin( dot(p.zyx,vec3(127.1,311.7,758.5453123))),\n        sin( dot(p.yxz,vec3(127.1,311.7,758.5453123))))*43758.5453123);\n}\n\n\n//---------------------------------------------------------------------\n//    Palette\n// https://www.shadertoy.com/view/4dsSzr\n//---------------------------------------------------------------------\nvec3 heatmapGradient(float t) {\n\treturn clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\n\n//---------------------------------------------------------------------\n//    Geometry\n//---------------------------------------------------------------------\n\n// Distance from ray to point\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n    //return length(cross(p-ro,rd));\n}\n\n// Distance line / line (must exist simplest way to do this)\nfloat distanceLineLine(vec3 ro, vec3 u, vec3 ro2, vec3 v) {\n    vec3 w = ro - ro2;\n    float a = dot(u,u); \n    float b = dot(u,v);\n    float c = dot(v,v);\n    float d = dot(u,w);\n    float e = dot(v,w);\n    float D = a*c - b*b;\n    float sc = (b*e - c*d) / D;\n    float tc = (a*e - b*d) / D;\n    // get the difference of the two closest points\n    vec3 dP = w + (sc * u) - (tc * v);\n    return sc>0. ? length(dP):1e3;   // return the closest distance\n}\n\n\n//---------------------------------------------------------------------\n//      Start field (iterate in a 3d grid)\n//---------------------------------------------------------------------\n\nvec4 renderStarField(in vec3 ro, in vec3 rd, in float tmax) { \n    vec3 ros = ro;\n    ros /= STAR_VOXEL_STEP_SIZE;\n\tvec3 pos = floor(ros),\n\t     mm, ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ros + .5 + rs*.5) * ri;\n    float dint, d = 0.;\n\tvec3 offset, id;\n    vec4 col = vec4(0);\n    vec4 sum = vec4(0);\n    \n\tfor( int i=0; i<STAR_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id+.1*cos(id+(id.x)*iTime),STAR_RADIUS, 1.-STAR_RADIUS);\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint>0.&& dint*STAR_VOXEL_STEP_SIZE<tmax) {\n            col.rgb = heatmapGradient(.4+id.x*.6);\n            col = (vec4(.6+.4*col.rgb, 1.)*(1.-smoothstep(STAR_RADIUS*.5,STAR_RADIUS,d)));\n            col.a *= smoothstep(float(STAR_VOXEL_STEPS),0.,dint);\n            col.rgb *= col.a/dint;\t\t\t\t                                \n            sum += (1.0-sum.a)*col;\n            if (sum.a>.99) break;\n        }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\treturn sum;\n}\n\n\n//---------------------------------------------------------------------\n//   Modeling Primitives\n//   [Inigo Quilez] http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------------------\n\nbool cube(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) { //, out vec3 n) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n//\tn = -sign(rd)*step(a.yzx,a)*step(b.zxy,b);\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn>0. && tn<tf;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule2( vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat sdPlane( vec3 p, vec3 n) {\n  // n must be normalized\n  return dot(p,n);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n\n//---------------------------------------------------------------------\n//    Man + Ground distance field \n//---------------------------------------------------------------------\n\nfloat map0(vec3 pos);\n\nfloat map(vec3 pos0)\n   {\n       // 3fps\n   return min( map0(  vec3(pos0.x + 1., pos0.y, pos0.z - 0.5)),\n               map0(vec3(pos0.x - 1., pos0.y, pos0.z + 0.5))\n              );\n       \n   }\n    \nfloat map0(vec3 pos){\n    // this cuts the man in half\n//    vec3 pos = vec3(mod(pos0.x -1., 200.), pos0.y, pos0.z);\n   // vec3 pos = vec3(mod(pos0.x +1., 2.), pos0.y, pos0.z);\n    \n    //vec3 pos = vec3(pos0.x + 1., pos0.y, pos0.z) * 0.999;\n    \n    \n    const float r1= .15, r2 = .1, r3= .1;\n    float d = 200.;\n    \n    // Leg 1\n    d = min(d, sdCapsule2(pos, foot1, ankle1, r2,r1));\n    d = min(d, sdCapsule(pos, ankle1, knee1, r1));\n    d = min(d, sdCapsule2(pos, knee1, hip1, r1,r2));\n \n    // Foot1 flat part - vector base linked to leg 1\n    vec3 v2 = normalize(knee1 - ankle1);\n    vec3 v1 = normalize(ankle1 - foot1-v2*.1);\n    vec3 v3 = cross(v1,v2);\n    d = max(d, -sdPlane(pos-ankle1+v2*.1, -cross(v1,v3))); \n    \n    // Leg 2\n    float d2 = sdCapsule2(pos, foot2, ankle2, r2,r1);\n    d2 = min(d2, sdCapsule(pos, ankle2, knee2, r1));\n    d2 = min(d2, sdCapsule2(pos, knee2, hip2, r1,r2));\n\n    // Foot2 flat part - vector base linked to leg 2\n    v2 = normalize(knee2 - ankle2);\n    v1 = normalize(ankle2 - foot2-v2*.1);\n    v3 = cross(v1,v2);\n    d2 = max(d2, -sdPlane(pos-ankle2+v2*.1, -cross(v1,v3))); \n\n    d = min(d, d2);\n    \n    vec3 ep0 = mix(shoulder1,shoulder2,.5);\n    vec3 ha0 = mix(hip1,hip2,.5);\n\n    // Head\n    d = min(d, sdCapsule2(pos, head - vec3(0,.17,0), head + vec3(-.02,.11,0),.13,.16));\n    \n    // Arm 1\n    v1 = normalize(wrist1-elbow1);\n    d = min(d, sdCapsule(pos, shoulder1, elbow1, r2));\n    d = min(d, sdCapsule2(pos, elbow1, wrist1-.05*v1, r2,r3));\n\n    // Hand1 - fix vector base to harm 1\n    v3 = -normalize(cross(v1,normalize(wrist1-shoulder1)));\n    v2 = -cross(v1,v3);\n    vec3 c = wrist1-v3*.06-v1*.12;\n    \n\t// Finders 1\n    d2 = sdCapsule2(pos, c, wrist1+.1*(v2+v1+v3), .013,.033);\n    d2 = min(d2, sdCapsule2(pos, c, wrist1+.18*(v1+v2*.2), .01,.03));\n    d2 = min(d2, sdCapsule2(pos, c, wrist1+.2*(v1-v2*.2), .01,.03));\n    d2 = min(d2, sdCapsule2(pos, c, wrist1+.15*(v1-v2*.6), .01,.026));\n    \n    // Arm 2\n    v1 = normalize(wrist2-elbow2);\n    d = min(d, sdCapsule(pos, shoulder2, elbow2, r2));\n    d = min(d, sdCapsule2(pos, elbow2, wrist2-.05*v1, r2,r3));\n    \n    // Hand2 - fix vector base to harm 2\n    v3 = normalize(cross(v1,normalize(wrist2-shoulder2)));\n    v2 = cross(v1,v3);\n    c = wrist2-v3*.06-v1*.12;\n    \n\t// Finders 2     \n    d2 = min(d2, sdCapsule2(pos, c, wrist2+.1*(v2+v1+v3), .013,.033));\n    d2 = min(d2, sdCapsule2(pos, c, wrist2+.18*(v1+v2*.2), .01,.03));\n    d2 = min(d2, sdCapsule2(pos, c, wrist2+.2*(v1-v2*.2), .01,.03));\n    d2 = min(d2, sdCapsule2(pos, c, wrist2+.15*(v1-v2*.6), .01,.026));\n\n    d = min(d, sdCapsule(pos, shoulder1, shoulder2, r2));\n   \td = smin(d2, d, .08);\n    \n    // Torso\n    vec3 a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.78);\n    \n    // Neck\n    d = smin(d, sdCapsule(pos, mix(shoulder1,shoulder2,.5)-vec3(.1,0,0), head-vec3(.11,.1,0), r2*.5),.06);\n    d = smin(d, sdCapsule2(pos, a, b, .2,.26),.18);\n\n    // Ground\n    vec3 te = textureLod(iChannel0, pos.xz*.1,1.).rgb;\n    d = min(d, pos.y+.3*length(te));\n    \n    // Belt\n    vec3 pos2 = pos-ha0+vec3(0,-.13,.02);\n    pos2.yz *= rot2;\n    d = min(d,mix(d,sdCappedCylinder(pos2, vec2(.28,.08)),.4)); \n \n    // Backpack\n    pos -= ep0;\n    \n    // can we modulate the backback atleast?\n    d2 = udRoundBox(\n        \n        vec3(\n            // whats one hop size? // there seems to be a cutoff space?\n            //pos.x+.43 - 1.5,\n            pos.x+.43 - mod(iTime * 100., 600.0) *0.01 + 2.0,\n            \n            pos.y-.2,\n            pos.z+0.), \n        \n        vec3(.1,.2,.2), \n        \n        .25); \n    \n    float d2x =    udRoundBox(\n        \n        vec3(\n            // whats one hop size? // there seems to be a cutoff space?\n            //pos.x+.43 - 1.5,\n            pos.x+.43 - mod(-iTime * 100., 600.0) *0.01 + 2.0,\n            \n            pos.y+.5,\n            pos.z+0.), \n        \n        vec3(.1,.2,.2), \n        \n        .25); \n    \n    \n   // d2 += .005*(smoothstep(.1,.6,cos(51.*(.2*pos.z+.4*pos.x*pos.x+pos.y)))+smoothstep(.4,.9,sin(51.*(.8*cos(1.+pos.z)+.4*pos.x+.2*pos.y))));\n    pos.yz *= rot;\n    //d2 = smin(d2,mix(d,sdCappedCylinder(pos.yzx+vec3(.13,.04,.1), vec2(.37,.05)),.75),.05); \n    \n//    return -1.;\n    //return d2;\n    \n    \n    // demo animatio space?\n    //return min(min(d2, d2x),d);\n    if (float(iTime) == 0.)\n        return -1.;\n    \n    return d;\n}\n\n\n//---------------------------------------------------------------------\n//   Ray marching scene if ray intersect bbox\n//---------------------------------------------------------------------\nconst float aspacex = 4.0;\nconst float aspacez = 4.0;\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd ) {\n    // Trace if in bbox (TODO: return intersection with ground otherwise)\n    float dx = gTime*168.*.02/8.+.85;\n    float tn, tf;\n    if (\n        cube(\n            \n            pos-vec3(dx,1.35,0), \n            ray, \n            \n            // this makes animation space bigger\n            vec3(aspacex, 1.7 * 2.,aspacez),  \n            \n            tn, tf)) \n    {\n        \n        traceEnd = min(tf, traceEnd);\n        float t = max(tn, traceStart);\n        float h;\n        for( int i=0; i < g_traceLimit; i++) {\n            h = map( pos+t*ray );\n            if (h < g_traceSize || t > traceEnd)\n                return t>traceEnd?100.:t;\n            t = t+h+.002;\n        }\n    }\n\treturn 100.0;\n}\n\n\n//---------------------------------------------------------------------\n//   Soft shadows\n//---------------------------------------------------------------------\n\n#ifdef WITH_SHADOW\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.05, 0.20 );\n        if( h<0.01 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Ambiant occlusion\n//---------------------------------------------------------------------\n\n#ifdef WITH_AO\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, totao = 0.0;\n    float sca = 1.0;\n    vec3 aopos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = 0.01 + 0.05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(map( aopos )-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Shading\n//   Adapted from Shane / Iq\n//---------------------------------------------------------------------\n\nvec3 doColor( in vec3 pos, in vec3 rd, in vec3 nor, in vec3 lp, in vec3 col){\n    vec3 ref = reflect( rd, nor );\n\n    // lighitng   \n#ifdef WITH_AO\n    float occ = calcAO( pos, nor );\n#else\n    float occ = 1.;\n#endif\n    vec3  lig = normalize( vec3(0.4, 0.7, 0.6) );\n    vec3  hal = normalize( lig-rd );\n    float amb = .4;//clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n#ifdef WITH_SHADOW\n    dif *= calcSoftshadow( pos, lig, 0.2, 2.5 );\n#endif\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),106.0)*\n        dif *\n        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 50.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += .80*dif*vec3(1.00,0.80,0.55)*(.3+.7*occ);\n    lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n    lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n    lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n    col += 10.00*spe*vec3(1.00,0.90,0.70);\n    return col;\n}\n\n\n//---------------------------------------------------------------------\n//   Calculate normal\n//   From TekF \n//---------------------------------------------------------------------\nvec3 Normal( vec3 pos, vec3 ray, float t) {\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, // tetrahedral offsets\n\t     p1 = pos+d.xyy,\n\t     p2 = pos+d.yxy,\n\t     p3 = pos+d.yyx;\n\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2),\tf3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n//---------------------------------------------------------------------\n//   Camera\n//---------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//---------------------------------------------------------------------\n//   Entry point\n//---------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime*6.;\n   \n    // Animation\n    int it = int(floor(gTime));\n    float kt = fract(gTime);\n    \n    float dz = 1.;\n   \n    head = getPos(HEAD, it, kt, dz);\n\n    shoulder1 = getPos(SHOULDER, it, kt, -dz);\n    elbow1 = getPos(ELBOW, it, kt, -dz);\n    wrist1 = getPos(WRIST, it, kt, -dz);\n    \n    foot1 = getPos(FOOT, it, kt, dz);\n    ankle1 = getPos(ANKLE, it, kt, dz);\n    knee1 = getPos(KNEE, it, kt, dz);\n    hip1 = getPos(HIP, it, kt, dz);\n    \n    shoulder2 = getPos(SHOULDER, it+4, kt, dz);\n    elbow2 = getPos(ELBOW, it+4, kt, dz);\n    wrist2 = getPos(WRIST, it+4, kt, dz);\n\n    foot2 = getPos(FOOT, it+4, kt, -dz);\n    ankle2 = getPos(ANKLE, it+4, kt, -dz);\n    knee2 = getPos(KNEE, it+4, kt, -dz);\n    hip2 = getPos(HIP, it+4, kt, -dz);\n\n    \n    float a = -1.5708*.4;\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    a = -1.5708*.1;\n    rot2 = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    float dx = it%8 < 4 ? -85.*.02 : +85.*.02; \n    foot2.x += dx;\n    ankle2.x += dx;\n    knee2.x += dx;\n    hip2.x += dx;\n\n    shoulder2.x += dx;\n    elbow2.x += dx;\n    wrist2.x += dx;\n    \n// ------------------------------------\n \n    vec2 m = iMouse.xy/iResolution.y - .5;\n   \n\n// Positon du point lumineux\n    float distLightRot =  100.;      \n    float lt = 5.;\n    vec3 g_lightPos1 = distLightRot*vec3(cos(lt*.5), 1., sin(lt*.5));\n\n     \n\tfloat traceStart = .2;\n    float t, s1, s2;\n    \n    vec3 col = vec3(0), colorSum = vec3(0.);\n\tvec3 pos;\n    vec3 ro, rd;\n\t\n  \tvec2 q;\n    \n#if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float randPix = hash(iTime);\n        vec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));        \n    \t// camera\t\n        q = (fragCoord.xy+subPix)/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n\n        ro = vec3(hip1.x+12.*cos(3.14*(.01*iTime+m.x+.3)),3.+3.*abs(sin(.01314*iTime))+10.*(m.y+.3),hip1.z+12.*sin(3.14*(.01*iTime+m.x+.3)));// .9*cos(0.1*time), .45, .9*sin(0.1*time) );\n        vec3 ta = hip1;\n\n        ta.x +=1.2;\n        ta.y = 1.2;\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera(ro, ta, 0.0);\n\n        // ray direction\n        rd = ca * normalize( vec3(p.xy,4.5) );\n\n        float tGround = -(ro.y-0.) / rd.y;\n        float traceEnd = 120.;//min(tGround,100.);\n        traceStart = 0.;\n        col = vec3(0);\n        vec3 n;\n        t = Trace(ro, rd, traceStart, traceEnd);\n        \n        if (tGround < 0.) \n            tGround = 100.;\n        t = min(t, tGround);\n        \n        if (t<100.) {\n        \tvec3 objCol = vec3(0,0,0);\n\n            pos = ro + rd*t;\n            n = Normal(pos, rd, t);\n           \tif (pos.y<.01) {\n               objCol = .02*vec3(.8,.8,.9);//textureLod(iChannel0, pos.xz*.1,1.).rgb;\n           \t} else {\n                objCol = vec3(.5,.0,.0) ;\n           \t}\n\n            col = doColor(pos, rd, n, g_lightPos1, objCol).grb;\n            \n        } else {\n            \n            float time = iTime*.5;\n            float kt = fract(time);\n            vec3 k = -.5+hash33(floor(time)+vec3(0, 2, 112));\n            if (k.y>.25) {\n                float t0 = distanceLineLine(ro,rd, k*200.+vec3(-100,0,0), normalize(k));\n\n            // mysterious line in sky\n                col = vec3(1,.8,.7) * (1.-smoothstep(0.,0.8,t0)) * smoothstep(.53,.01,rd.y+.2*kt);\n                col *= (.5+.5*hash(time))*smoothstep(0.,1., kt);\n            }\n        }\n        \n#if (ANTIALIASING > 1)\t\n        colorSum += col;\n\t}\n    \n    col = colorSum/float(ANTIALIASING);\n#endif\n    \n    // 6fps to 7fps\n    // Render star dusts ------------------------\n   // vec4 star = renderStarField(ro, rd, t);\n   // \t star.rgb += col.rgb * (1.0 - star.a);\n   // \t col = star.rgb;\n         \n    // Post processing stuff --------------------\n    // Fog\n    float f = 50.0;\n    col = mix( vec3(.18), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t// Gamma\n    col = pow( col, vec3(0.4545) );\n    // Vigneting\n    //col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .1); \n    \n\tfragColor =  vec4(col,1);\n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljfD1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2824, 2860, 2913, 2913, 3033], [3036, 3207, 3230, 3230, 3268], [3270, 3270, 3301, 3301, 3510], [3513, 3712, 3743, 3743, 3888], [4051, 4081, 4144, 4144, 4235], [4237, 4298, 4357, 4357, 4751], [4754, 4942, 5003, 5003, 5995], [5998, 6255, 6321, 6339, 6560], [6562, 6562, 6614, 6614, 6739], [6741, 6741, 6804, 6804, 6939], [6941, 6941, 6986, 6986, 7025], [7027, 7027, 7069, 7069, 7166], [7168, 7168, 7200, 7226, 7247], [7249, 7249, 7298, 7298, 7386], [7389, 7592, 7617, 7632, 7787], [7793, 7793, 7814, 8034, 12157], [12160, 12405, 12474, 12548, 13176], [14230, 14417, 14494, 14494, 15608], [15611, 15793, 15836, 15836, 16303], [16306, 16463, 16514, 16514, 16691], [16694, 16856, 16913, 16913, 21080]], "test": "untested"}
{"id": "lljfRD", "name": "It's a Question of Time", "author": "rigel", "description": "This was a study on circles inpired by this [url=http://www.dailymail.co.uk/news/article-1236380/Worlds-largest-artwork-etched-desert-sand.html]artwork[/url] . You can play circle inversion with your mouse...", "tags": ["2d", "sdf", "circle", "apollonian"], "likes": 127, "viewed": 14868, "published": "Public API", "date": "1516448535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Rigel rui@gil.com\n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/lljfRD\n\n\n/*\nThis was a study on circles, inspired by this artwork\nhttp://www.dailymail.co.uk/news/article-1236380/Worlds-largest-artwork-etched-desert-sand.html\n\nand implemented with the help of this article\nhttp://www.ams.org/samplings/feature-column/fcarc-kissing\n\nThe structure is called an apollonian packing (or gasket)\nhttps://en.m.wikipedia.org/wiki/Apollonian_gasket\n\nThere is a lot of apollonians in shadertoy, but not many quite like the image above.\nThis one by klems is really cool. He uses a technique called a soddy circle. \nhttps://www.shadertoy.com/view/4s2czK\n\nThis shader uses another technique called a Descartes Configuration. \nThe only thing that makes this technique interesting is that it can be generalized to higher dimensions.\n*/\n\n\n// a few utility functions\n// a signed distance function for a rectangle\nfloat sdfRect(vec2 uv, vec2 s) {vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// a signed distance function for a circle\nfloat sdfCircle(vec2 uv, vec2 c, float r) { return length(uv-c)-r; }\n// fills an sdf in 2d\nfloat fill(float d, float s, float i) { return abs(smoothstep(0.,s,d) - i); }\n// makes a stroke of an sdf at the zero boundary\nfloat stroke(float d, float w, float s, float i) { return abs(smoothstep(0.,s,abs(d)-(w*.5)) - i); }\n// a simple palette\nvec3 pal(float d) { return .5*(cos(6.283*d*vec3(2.,2.,1.)+vec3(.0,1.4,.0))+1.);}\n// 2d rotation matrix\nmat2 uvRotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n// circle inversion\nvec2 inversion(vec2 uv, float r) { return (r*r*uv)/vec2(dot(uv,uv)); }\n// seeded random number\nfloat hash(vec2 s) { return fract(sin(dot(s,vec2(12.9898,78.2333)))*43758.5453123); }\n\n// this is an algorithm to construct an apollonian packing with a descartes configuration\n// remaps the plane to a circle at the origin and a specific radius. vec3(x,y,radius)\nvec3 apollonian(vec2 uv) {\n    // the algorithm is recursive and must start with a initial descartes configuration\n    // each vec3 represents a circle with the form vec3(centerx, centery, 1./radius)\n    // the signed inverse radius is also called the bend (refer to the article above)\n    vec3 dec[4];\n    // a DEC is a configuration of 4 circles tangent to each other\n    // the easiest way to build the initial one it to construct a symetric Steiner Chain.\n    // http://mathworld.wolfram.com/SteinerChain.html\n\tfloat a = 6.283/3.;\n\tfloat ra = 1.+sin(a*.5);\n\tfloat rb = 1.-sin(a*.5);\n\tdec[0] = vec3(0.,0.,-1./ra);\n    float radius = .5*(ra-rb);\n\tfloat bend = 1./radius;\n    for (int i=1; i<4; i++) {\n        dec[i] = vec3(cos(float(i)*a),sin(float(i)*a),bend);\n        // if the point is in one of the starting circles we have already found our solution\n        if (length(uv-dec[i].xy) < radius) return vec3(uv-dec[i].xy,radius);\n    }\n    \n    // Now that we have a starting DEC we are going to try to \n    // find the solution for the current point\n    for(int i=0; i<7; i++) {\n        // find the circle that is further away from the point uv, using euclidean distance\n        int fi = 0;\n        float d = distance(uv,dec[0].xy)-abs(1./dec[0].z);\n        // for some reason, the euclidean distance doesn't work for the circle with negative bend\n        // can anyone with proper math skills, explain me why? \n        d *= dec[0].z < 0. ? -.5 : 1.; // just scale it to make it work...\n        for(int i=1; i<4; i++) {\n            float fd = distance(uv,dec[i].xy)-abs(1./dec[i].z);\n            fd *= dec[i].z < 0. ? -.5: 1.;\n            if (fd>d) {fi = i;d=fd;}\n        }\n        // put the cicle found in the last slot, to generate a solution\n        // in the \"direction\" of the point\n        vec3 c = dec[3];\n        dec[3] = dec[fi];\n        dec[fi] = c;\n        // generate a new solution\n        float bend = (2.*(dec[0].z+dec[1].z+dec[2].z))-dec[3].z;\n        vec2 center = vec2((2.*(dec[0].z*dec[0].xy\n                               +dec[1].z*dec[1].xy\n                               +dec[2].z*dec[2].xy)\n                               -dec[3].z*dec[3].xy)/bend);\n\n\t\tvec3 solution = vec3(center,bend);\n\t\t// is the solution radius is to small, quit\n\t\tif (abs(1./bend) < 0.01) break;\n\t\t// if the solution contains the point return the circle\n    \tif (length(uv-solution.xy) < 1./bend) return vec3(uv-solution.xy,1./bend);\n    \t// else update the descartes configuration,\n    \tdec[3] = solution;\n    \t// and repeat...\n\t}\n\t// if nothing is found we return by default the inner circle of the Steiner chain\n\treturn vec3(uv,rb);\n}\n\n\nvec3 scene(vec2 uv, vec4 ms) {\n    \n\tvec2 ci = vec2(.0);\n\n    // drag your mouse to apply circle inversion\n    if (ms.y != -2. && ms.z > -2.) {\n        uv = inversion(uv,cos(radians(60.)));\n        ci = ms.xy;\n    }    \n\n    // remap uv to appolonian packing\n    vec3 uvApo = apollonian(uv-ci);\n    \n    float d = 6.2830/360.;\n    float a = atan(uvApo.y,uvApo.x);\n    float r = length(uvApo.xy);\n\n    float circle = sdfCircle(uv,uv-uvApo.xy,uvApo.z);\n\t\n    // background\n\tvec3 c = length(uv)*pal(.7)*.2;\n    \n    // drawing the clocks\n    if (uvApo.z > .3) {\n    \tc = mix(c,pal(.75-r*.1)*.8,fill(circle+.02,.01,1.)); // clock \n    \tc = mix(c,pal(.4+r*.1),stroke(circle+(uvApo.z*.03),uvApo.z*.01,.005,1.));// dial\n\n        float h = stroke(mod(a+d*15.,d*30.)-d*15.,.02,0.01,1.);\n    \tc = mix(c,pal(.4+r*.1),h*stroke(circle+(uvApo.z*.16),uvApo.z*.25,.005,1.0));// hours\n\n        float m = stroke(mod(a+d*15.,d*6.)-d*3.,.005,0.01,1.);\n    \tc = mix(c,pal(.45+r*.1),(1.-h)*m*stroke(circle+(uvApo.z*.15),uvApo.z*.1,.005,1.0));// minutes, \n    \t\n    \t// needles rotation\n    \tvec2 uvrh = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z))*d*180.))*d*iTime*(1./uvApo.z*10.)-d*90.);\n    \tvec2 uvrm = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z)*4.)*d*180.))*d*iTime*(1./uvApo.z*120.)-d*90.);\n    \t// draw needles \n    \tc = mix(c,pal(.85),stroke(sdfRect(uvrh+vec2(uvApo.z-(uvApo.z*.8),.0),uvApo.z*vec2(.4,.03)),uvApo.z*.01,0.005,1.));\n    \tc = mix(c,pal(.9),fill(sdfRect(uvrm+vec2(uvApo.z-(uvApo.z*.65),.0),uvApo.z*vec2(.5,.002)),0.005,1.));\n    \tc = mix(c,pal(.5+r*10.),fill(circle+uvApo.z-.02,0.005,1.)); // center\n    // drawing the gears\n    } else if (uvApo.z > .05) {\n    \tvec2 uvrg = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z+2.))*d*180.))*d*iTime*(1./uvApo.z*20.));\n        float g = stroke(mod(atan(uvrg.y,uvrg.x)+d*22.5,d*45.)-d*22.5,.3,.05,1.0);\n        vec2 size = uvApo.z*vec2(.45,.08);\n        c = mix(c,pal(.55-r*.6),fill(circle+g*(uvApo.z*.2)+.01,.001,1.)*fill(circle+(uvApo.z*.6),.005,.0));\n        c = mix(c,pal(.55-r*.6),fill(min(sdfRect(uvrg,size.xy),sdfRect(uvrg,size.yx)),.005,1.));\n    // drawing the screws\n    } else { \n \t    vec2 size = uvApo.z * vec2(.5,.1);\n \t    c = mix(c, pal(.85-(uvApo.z*2.)), fill(circle + 0.01,.007,1.));\n \t    c = mix(c, pal(.8-(uvApo.z*3.)), fill(min(sdfRect(uvApo.xy,size.xy),sdfRect(uvApo.xy,size.yx)), .002, 1.));\n    }\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n\tvec4 ms = (iMouse - iResolution.xyxy * .5 ) / iResolution.y ;\n\tfragColor = vec4(scene(uv*4., ms*4.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljfRD.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[884, 957, 989, 989, 1043], [1044, 1087, 1130, 1130, 1155], [1156, 1178, 1217, 1217, 1255], [1256, 1305, 1355, 1355, 1405], [1406, 1426, 1445, 1445, 1506], [1507, 1529, 1553, 1553, 1598], [1599, 1619, 1653, 1653, 1689], [1690, 1714, 1734, 1734, 1799], [1801, 1977, 2003, 2262, 4615], [4618, 4618, 4648, 4648, 6996], [6998, 6998, 7055, 7055, 7229]], "test": "untested"}
{"id": "lljfRV", "name": "recursive checkerboard pattern", "author": "public_int_i", "description": "texture uvs rotated and mirrored in a checkerboard pattern", "tags": ["checkerboard", "recursive", "mirror", "uvs"], "likes": 5, "viewed": 423, "published": "Public API", "date": "1516754336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2018\nmat2 rot2d(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,s,-s,c);\n}\nvoid mainImage(out vec4 o, in vec2 u)\n{\n\tvec2 uv = u/iResolution.y,iv;\n    float ls = 1., n = 0.;\n    for (float s = 2.; s < 16.; s += s) {\n        if (s > 2.+floor(mod(iTime,24.))) break;\n        uv *= s;\n        iv = floor(uv/ls);\n        ls = s;\n        if (mod(iv.x+iv.y,2.) < 1.) {\n            uv = abs((fract(uv)-.5)*rot2d(s+iv.x+iv.y*9.874))*2.;\n            n++;\n        }\n    }\n    o = cos(texture(iChannel0,uv*.04)*6.28+sin((iTime+n)*.07*vec4(1,2,7,4))*4.)*0.5+0.5;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljfRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 31, 52, 52, 115], [116, 116, 155, 155, 592]], "test": "untested"}
{"id": "lljfW1", "name": "Seascape Clubber VJ version", "author": "MacroMachines", "description": "Audio reactive version of the fantastic sea shader by TDM - fix\nhttps://www.shadertoy.com/view/Ms2SD1, rewired to work with clubber\nhttps://wizgrav.github.io/clubber/tool/tool.html?tool=1&t0=0234\nzorba omg https://goo.gl/pQunGq , https://goo.gl/7tDFmr\n\n", "tags": ["procedural", "sea", "reactive", "clubber"], "likes": 3, "viewed": 2494, "published": "Public API", "date": "1515661223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Re Seascape by TDM\" by wizgrav. https://shadertoy.com/view/4lKSzh\n// 2018-01-11 08:57:40\n\n/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R 0.0\n#define CLUBBER_G 0.0\n#define CLUBBER_B 0.0\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\nvec4 Clubber = vec4(0.);\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM 0.1 / iResolution.x\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nfloat SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.2;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n#define SEA_TIME 1.0 + iTime * SEA_SPEED\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    float md = mix(0.86,1.0,Clubber.b);\n    e.y = max(e.y,0.0);\n    return vec3(pow(0.8+md/5.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4)*md;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        d = sea_octave((uv+SEA_TIME)*freq + 2. * Clubber.r,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq + 2. * Clubber.g,choppy);\n        h += d * amp;        \n    \tuv *= octave_m ; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \tuv += Clubber.rg * 0.1;\n    \td = sea_octave((uv+SEA_TIME)*freq+ 2. * Clubber.r,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq + 2. * Clubber.g,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0)*mix(0.33,1.0,Clubber.b));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    Clubber = vec4(CLUBBER_R,CLUBBER_G, CLUBBER_B, CLUBBER_A);\n    SEA_CHOPPY = mix(4.0,32.0, Clubber.a);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljfW1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1002, 1010, 1036, 1036, 1382], [1383, 1383, 1405, 1405, 1485], [1486, 1486, 1512, 1512, 1813], [1815, 1827, 1865, 1865, 1907], [1908, 1908, 1954, 1954, 2058], [2060, 2067, 2093, 2093, 2232], [2234, 2241, 2282, 2282, 2453], [2455, 2455, 2474, 2474, 2948], [2950, 2950, 2978, 2978, 3484], [3486, 3486, 3549, 3549, 4068], [4070, 4081, 4116, 4116, 4307], [4309, 4309, 4365, 4365, 4877], [4879, 4887, 4944, 4944, 5876]], "test": "untested"}
{"id": "lljfzW", "name": "Sun and Moon", "author": "thedev1l1", "description": "Sun and Moon", "tags": ["simplelearning2d"], "likes": 1, "viewed": 471, "published": "Public API", "date": "1514907237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float lastDegree;\n\nconst vec3 colorSun = vec3(1,1,0);\nconst vec3 colorMoon = vec3(0.8,0.8,1);\n\nfloat Circle(vec2 uv, vec2 p , float r, float blur)\n{\n    float d = length(uv - p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nvec3 ColorByDegree(float degree)\n{\n    float d = float(int(degree + 180.0) % 360);\n    d -= 180.0;\n    if(d < 0.0) d = - d;\n    return clamp(vec3(d / 180.0), colorSun, colorMoon); \n}\n\nvec3 timerCircle(float degreePerSec, vec2 uv, vec2 p , float r, float blur)\n{\n    float degree = iTime * degreePerSec;\n    return Circle(uv, vec2(p.x + sin(radians(degree)) * 0.5, p.y + (cos(radians(degree)) * 0.5) - 0.0), r ,blur) * ColorByDegree(degree);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tfragColor = vec4(timerCircle(30.0,uv, vec2(0,0) , .4, .05) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljfzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 148, 148, 234], [236, 236, 270, 270, 418], [420, 420, 497, 497, 678], [680, 680, 737, 737, 910]], "test": "untested"}
{"id": "lljyRt", "name": "Sphere Experiment", "author": "Xor", "description": "I was playing with worley noise and came up with this fake 3D sphere effect. Sorry that the code is kind of messy. It's just for fun and not really serious.", "tags": ["spheres", "worley", "striped"], "likes": 13, "viewed": 189, "published": "Public", "date": "1515723255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 Hash(vec2 n)\n{\n \treturn fract(cos(n.x*vec3(17,15,14)+n.y*vec3(-13,17,-13))*vec3(947,892,1003));\n}\nvec2 Worley(vec2 n,float s)\n{\n \tfloat Distance = 1.;\n    float Index = 0.;\n\n    for(int X = -1;X<=1;X++)\n\tfor(int Y = -1;Y<=1;Y++)\n    {\n        vec3 Cell = Hash(floor(n)-vec2(X,Y));\n        float Length = pow(length(vec2(X,Y)-Cell.xy+fract(n)),2.);\n        if ((fract(Cell.z+s)<.2) && (Length<Distance))\n        {\n        \tDistance = Length;\n            Index = Cell.x;\n        }\n    }\n    return vec2(Distance,Index);\n}\nvoid mainImage(out vec4 Color,in vec2 Coord)\n{\n    float S = 400./iResolution.y;\n    vec2 B1 = Worley((Coord/24.+iTime)*S,0.);\n    vec2 B2 = Worley((Coord/48.+iTime/1.8)*S,.3);\n    vec2 B3 = Worley((Coord/72.+iTime/2.6)*S,.8);\n    \n    float D1 = 1.-B1.x;\n    float D2 = 1.-B2.x/.8;\n    float D3 = 1.-B3.x/.7;\n    \n    float C1 = smoothstep(.5,.49,B1.x);\n    float C2 = smoothstep(.5,.49,B2.x);\n    float C3 = smoothstep(.5,.49,B3.x);\n\n    float L1 = mix(min(pow(max(B1.x-.49,.01),.25)+.1,1.),D1,C1);\n    float L2 = mix(min(pow(max(B2.x-.49,.01),.25)+.1,1.),D2,C2);\n    float L3 = mix(min(pow(max(B3.x-.49,.01),.25)+.1,1.),D3,C3);    \n    float Light = min(min(L1+C2,1.)*L2+C3,1.)*L3;\n    float Height = (D1*(C1)*(1.-C2)+C2*D2)*(1.-C3)+C3*D3;\n    float Type = (B1.y*(C1)*(1.-C2)+C2*B2.y)*(1.-C3)+C3*B3.y;\n   \t\n    float Stripe = S*Coord.x/256.+S*Coord.y/96.+2.*Height+.3*iTime;\n    vec3 Col1 = vec3(.7,.5,.4)+vec3(.3,.7,.6)*cos(Type+floor(Stripe));\n    vec3 Col2 = vec3(.7,.5,.4)+vec3(.3,.7,.6)*cos(Type+floor(Stripe+.01));\n    vec3 Col = mix(Col1,Col2,smoothstep(.99,1.,fract(Stripe)));\n\tColor = vec4(Col*Light,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 102], [103, 103, 132, 132, 524], [525, 525, 571, 571, 1642]], "test": "untested"}
{"id": "llSBRG", "name": "Circular Smooth II", "author": "Ultraviolet", "description": "Remake of [url=https://www.shadertoy.com/view/4lBfzy]Circular Smooth[/url] with an intensity control (mouse y).", "tags": ["smoothstep", "circular"], "likes": 2, "viewed": 113, "published": "Public", "date": "1516186024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define FACTOR (-1.+iResolution.y/(iResolution.y-iMouse.y))\n\nfloat FACTOR;\n\nfloat preSmoothStep(float step0, float step1, float x)\n{\n    return clamp((x-step0)/(step1-step0), 0., 1.);\n}\n\nfloat smoothFn(float x)\n{\n    /*\n    if(x < 0.5)\n    {\n        vec2 c = vec2(-FACTOR, .5+FACTOR);\n        return c.y-sqrt(dot(c,c)-(c.x-x)*(c.x-x));\n    }\n    vec2 c = vec2(1.+FACTOR, .5-FACTOR);\n    return c.y+sqrt(dot(c-vec2(1.),c-vec2(1.))-(c.x-x)*(c.x-x));\n\t*/\n    \n    \n    float x_ = min(x, 1.-x);\n    vec2 c = vec2(-FACTOR, .5+FACTOR);\n    float y = c.y-sqrt(dot(c,c)-(c.x-x_)*(c.x-x_));\n\treturn (x<0.5) ? y : 1.0-y;\n}\n\n\nfloat smoothFnInv(float x)\n{\n    /*\n    if(x < 0.5)\n    {\n        vec2 c = vec2(.5+FACTOR, -FACTOR);\n        return sqrt(dot(c,c)-(c.x-x)*(c.x-x))+c.y;\n    }\n    vec2 c = vec2(.5-FACTOR, 1.+FACTOR);\n    return c.y-sqrt(dot(c-vec2(1.),c-vec2(1.))-(x-c.x)*(x-c.x));\n\t*/\n    \n    float x_ = min(x, 1.-x);\n    vec2 c = vec2(.5+FACTOR, -FACTOR);\n    float y = sqrt(dot(c,c)-(c.x-x_)*(c.x-x_))+c.y;\n\treturn (x<0.5) ? y : 1.0-y;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px = 1.0/iResolution.y;\n    vec2  p = ( vec2((iResolution.y-iResolution.x)/2.0,0.0)+fragCoord)/iResolution.y;\n    \n    FACTOR = (-1.+iResolution.y/(iResolution.y-iMouse.y));\n    \n    if(length(iMouse.xy) < 10.)\n        FACTOR = 1./(0.001+0.998*sin(iTime)*sin(iTime)) -1.;\n    \n    vec3 col = vec3(0.0);\n    \n    if( p.x>0.0 && p.x<1.0 )\n    {\n        col = vec3( 0.2 ) + 0.01*mod(floor(p.x*20.0)+floor(p.y*20.0),2.0);\n\n        // blue: smoothstep\n        float y1 = smoothFn( preSmoothStep(0.0, 1.0, p.x) );\n        float x1 = smoothFnInv( preSmoothStep(0.0, 1.0, p.y) );\n        float d1 = min(abs(p.y-y1),abs(p.x-x1));\n        col = mix( col, vec3(0.0,0.4,0.8), 1.0-smoothstep( 0.0, 2.0*px, d1 )) ;\n\n        // yellow: inverse_smoothstep\n        float y2 = smoothFnInv( p.x );\n        float x2 = smoothFn( preSmoothStep(0.0, 1.0, p.y) );\n        float d2 = min(abs(p.y-y2),abs(p.x-x2));\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0*px, d2 )) ;\n\n        // gray: smoothstep of inverse_smoothstep, back to identity\n        float y3 = smoothFn( preSmoothStep(0.0, 1.0, y2 ));\n        float x3 = smoothFnInv( preSmoothStep(0.0, 1.0, x2) );\n        float d3 = min(abs(p.y-y3),abs(p.x-x3));\n        col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep(0.0, 1.5*px, d3 ) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSBRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 134, 134, 187], [189, 189, 214, 453, 614], [617, 617, 645, 884, 1040], [1047, 1047, 1104, 1104, 2451]], "test": "untested"}
{"id": "llSBWh", "name": "damier", "author": "Loustik", "description": "damier", "tags": ["damier"], "likes": 0, "viewed": 138, "published": "Public", "date": "1515972264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    float modulo = 0.4;\n    float valueA = floor(mod(uv.x,modulo)/(modulo*0.5));\n    float valueB = floor(mod(uv.y,modulo)/(modulo*0.5));\n    float value = abs(valueA-valueB);\n    \n\tfragColor = vec4(value-uv.x*sin(iTime), value, value-uv.y*sin(iTime),1.0);\n}\n\n/*\n\n// ligne noir\n0  sur 0 > 0\n0  sur 1 > -1\n\n// ligne blanche\n1  sur 0 > 1\n1  sur 1 > 0\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSBWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 434]], "test": "untested"}
{"id": "llSBWm", "name": "13/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I continued exploring voronoi pattern. This time I tried to do it in 3d. I have no idea how to visualize it properly but I think this looks kind of pretty.", "tags": ["voronoi", "dailyshader"], "likes": 1, "viewed": 85, "published": "Public", "date": "1515976614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define PIXELR 0.5/iResolution.x\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\nfloat dist(vec3 q){\n    vec3 f = fract(q);\n    vec3 i = floor(q);\n    \n    vec3 n[27];  \n    n[0] = vec3(-1.0, -1.0, -1.0);\n    n[1] = vec3(-1.0,  0.0, -1.0);\n    n[2] = vec3(-1.0,  1.0, -1.0);\n    \n    n[3] = vec3(0.0,  -1.0, -1.0);\n    n[4] = vec3(0.0,   0.0, -1.0);\n    n[5] = vec3(0.0,   1.0, -1.0);\n    \n    n[6] = vec3(1.0,  -1.0, -1.0);\n    n[7] = vec3(1.0,   0.0, -1.0);\n    n[8] = vec3(1.0,   1.0, -1.0);\n    \n    n[9] = vec3(-1.0, -1.0,\t 0.0);\n    n[10] = vec3(-1.0, 0.0,  0.0);\n    n[11] = vec3(-1.0, 1.0,  0.0);\n    \n    n[12] = vec3(0.0,  -1.0,  0.0);\n    n[13] = vec3(0.0,   0.0,  0.0);\n    n[14] = vec3(0.0,   1.0,  0.0);\n    \n    n[15] = vec3(1.0,  -1.0,  0.0);\n    n[16] = vec3(1.0,   0.0,  0.0);\n    n[17] = vec3(1.0,   1.0,  0.0);\n    \n    n[18] = vec3(-1.0, -1.0,  1.0);\n    n[19] = vec3(-1.0,  0.0,  1.0);\n    n[20] = vec3(-1.0,  1.0,  1.0);\n    \n    n[21] = vec3(0.0,  -1.0,  1.0);\n    n[22] = vec3(0.0,   0.0,  1.0);\n    n[23] = vec3(0.0,   1.0,  1.0);\n    \n    n[24] = vec3(1.0,  -1.0,  1.0);\n    n[25] = vec3(1.0,   0.0,  1.0);\n    n[26] = vec3(1.0,   1.0,  1.0);\n    \n    float t = 1000.0;\n    for(int it = 0; it < 27; ++it){\n        vec3 p = hash33(i+n[it]);\n        p = (1.0+sin(iTime*0.25 + 2.0*PI*p))*0.5;\n        float d = length(n[it]+p-f);\n        t = min(t, d);\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = mat3(x, y, z)*vec3(uv, radians(50.0));\n    \n    //Tiling space..\n    vec3 q = rd*12.0;\n    \n    float t = dist(q);\n    vec3 p = ro+rd*t;\n    vec3 col = p+t+vec3(0.6, 0.6, 0.8);\n    col *= 0.2;\n    \n    col = pow(col, 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 158, 179, 179, 289], [292, 292, 311, 311, 1609], [1611, 1611, 1668, 1668, 2196]], "test": "untested"}
{"id": "llSfDR", "name": "Infrared Dynamo", "author": "xdaimon", "description": "fork of https://www.shadertoy.com/view/ltyXWR", "tags": ["sdf", "inversion"], "likes": 19, "viewed": 334, "published": "Public", "date": "1515317599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original shader by FabriceNeyret2: https://www.shadertoy.com/view/ltyXWR\n\n\n#define iRes (iResolution.xy)\n//#define iMouse (iMouse.xy)\n#define iTime (iTime/2.)\n#define iMouseDown (iMouse.z>0.)\n\n\nfloat scene(in vec3 t, out float closest) {\n\tvec3 ta;\n\tfloat x=1e9;\n\n\t#define mod4(t)         ( mod(t+2.,4.)-2. )\n\t#define setbox(t,h,w,d)  abs(t)/vec3(h,w,d)\n\t#define dbox(t,r)       ( max(t.x,max(t.y,t.z)) -(r) )\n\t#define dsphere(t,r)    ( length((t).xyz) -(r) )\n\t#define dcyl(t,r)       ( length((t).xy) -(r) )\n\t#define union(a,b)       min(a,b)\n\t#define sub(a,b)         max(a,-(b))\n\n\tvec3 b = t;\n\tt/=dot(t,t);\n    //t.xy+= vec2(sin(t.z));\n    \n\n    //t-=vec3(iTime/5.);\n    t.x -= iTime/2.;\n    //t.y -= iTime/3.;\n\n\tta.xy = floor( (t.xy+2.)/4. );\n\tt.z -= iTime * sign( mod(ta.x+ta.y,2.) - .5);\n\n\tta = setbox(mod4(t),1,3,16);\n\tx = dcyl(ta,.5);\n\n\tta = setbox(mod4(t),3,1,16);\n\tx = union(x, dcyl(ta,.5) );\n\n\tta = setbox(mod4(t+vec3( 0,0,2)), 6,2,1);\n\tx = sub(x,  dbox(ta,.27) );\n\n\tta = setbox(mod4(t-vec3(.8,0,0)),.6,3,2);\n\tx = sub(x,  dbox(ta,.5) );\n\n\tta = setbox(mod4(t+vec3(.8,0,0)),.6,3,2);\n\tx = sub(x,  dbox(ta,.5) );\n\n\tta = setbox(mod4(t               ),1,3,.5);\n\tx = sub(x,  dbox(ta,.55) );\n\n\tta = setbox(mod4(t-vec3(0,.8,2)),3,.6,2);\n\tx = sub(x,  dbox(ta,.5) );\n\n\tta = setbox(mod4(t+vec3(0,.8,2)),3,.6,2);\n\tx = sub(x,  dbox(ta,.5) );\n\n\tta = setbox(mod4(t-vec3( 0,0,1)),10,10,1);\n\tx = sub(x,  dbox(ta,.12) );\n\n\tta = setbox(mod4(t+vec3( 0,0,1)),10,10,1);\n\tx = sub(x,  dbox(ta,.12) );\n\n    // float x1 = dsphere(mod4(t),.3);\n    // closest = min(closest, x1);\n\n\treturn x;\n}\n\nfloat scene(in vec3 t) {\n\tfloat x;\n\treturn scene(t,x);\n}\n\nvec3 g(vec3 t, float d) {\n\tvec2 e = vec2(0,.001);\n\treturn normalize(vec3(scene(t+e.yxx), scene(t+e.xyx), scene(t+e.xxy)) - vec3(d));\n}\n\nvoid mainImage(out vec4 f, in vec2 fragCoord) {\n\tf -= f;\n\n\tvec2 m;\n\tif (iMouseDown)\n\t\tm = iMouse.xy/iRes*.5;\n\tif (m.x < .15) m.x=.15;\n\tm.y = -m.y*.6+.12;\n // m.y += .1;\n\tm.x += .5;\n\tm = (-m+.5);\n    \n\tvec2 uv = fragCoord/iRes*2.-1.;\n\tuv.y *= iRes.y/iRes.x;\n\tvec3 ro = vec3(m.x-.1,m.y,.1);\n\tvec3 ta = vec3(0);\n\tvec3 cu = normalize(ta-ro);\n\tvec3 cv = (cross(vec3(0,0,1), cu));\n\tvec3 cw = (cross(cv, cu));\n\tvec3 rd = (cu + cv*uv.x + cw*uv.y);\n\n\tfloat decay = 1.;\n  \tint iter = 0;\n\tfloat closest = 100000.;\n\tvec3 p = ro;\n\tfor (float i=1.; i>0.; i-=.005)  {\n\t\tfloat dist = scene(p, closest);\n\t\tif(dist<.01) {\n\t\t\tf += decay*vec4(pow(i,2.))*.5;\n\t\t\tf += pow(decay,3.)*vec4(1., .4, .4,1)/dot(p,p)/90.;\n\t\t\tdecay /= 2.;\n\t\t\titer += 1;\n\t\t\tif (iter == 2)\n\t\t\t\t\tbreak;\n\t\t\tvec3 n = g(p,dist);\n\t\t\trd = normalize(reflect(rd, n));\n\t\t\tp+=.1*n;\n\t\t}\n\t\tp += rd*dist*.02;\n        //p += rd*dist*.5 * min(1.,dot(p,p));\n\t}\n\tf += vec4(0,0,.3,0) * exp(-length(p))*(.5+.5*cos(iTime/2.)); // glow2 - thanks kuvkar !\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSfDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 197, 240, 240, 1577], [1579, 1579, 1603, 1603, 1635], [1637, 1637, 1662, 1662, 1771], [1773, 1773, 1820, 1820, 2759]], "test": "untested"}
{"id": "llSfWw", "name": "Pattern 14012018", "author": "edapx", "description": "patterns, palm", "tags": ["patterns", "palm"], "likes": 4, "viewed": 106, "published": "Public", "date": "1515956367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distortedDaisy(\n  vec2 st, vec2 orig, float resize, float smoothness,\n  float nPetals, float distorsion, float addendum){\n  // Credits to Inigo\n  // https://www.youtube.com/watch?v=0ifChJ0nJfM\n  \n  // to turn the picture upside down, uncomment the following\n  // line\n  //vec2 toCenter = orig-st;\n  vec2 toCenter = st-orig;\n  float angle = atan(toCenter.y,toCenter.x);\n  float r = resize + addendum*cos(angle * nPetals + distorsion * toCenter.x);\n  return smoothstep(r, r+smoothness, length(toCenter));\n}\n\nfloat flip(float v, float pct){\n  return mix(v, 1. - v, pct);\n}\n\nfloat strokeSmoot(float x, float pos, float width){\n  return smoothstep(pos, pos+0.005,x+ width*0.5) -\n         smoothstep(pos, pos+0.005,x- width*0.5);\n}\n\nfloat circleSDF(vec2 pos, float r){\n  return length(pos - 0.5) * r;\n}\n\nvec2 tileMoveCrossed(vec2 _st, float _zoom, float utime, float speed){\n    float time = utime * speed;\n    _st *= _zoom;\n    // horizontal or vertical?\n    float ver = step(.5,fract(time));\n    float hor = step(ver, 0.);\n    // even rows and columns\n    float evenY = step(.5, fract(_st.y * .5));\n    float oddY = step(evenY,0.);\n    float evenX = step(.5, fract(_st.x * .5));\n    float oddX = step(evenX,0.);\n    // apply movement\n    _st.x += ((fract(time) * 2.0) * evenY) * hor;\n    _st.x -= ((fract(time) * 2.0) * oddY) * hor;\n    _st.y += ((fract(time) * 2.0) * evenX) * ver;\n    _st.y -= ((fract(time) * 2.0) * oddX) * ver;\n    return fract(_st);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // COLORS\n  vec3 sand = vec3(0.970,0.725,0.359);\n  vec3 violet = vec3(0.688,0.287,0.995);\n  vec3 green = vec3(0.266,0.810,0.407);\n\n  float palm = 1.0;\n  vec2 st = fragCoord.xy / iResolution.xy;\n  st.y *= iResolution.y/iResolution.x;\n  st *= 4.0;\n  st = fract(st);\n\n  // CANOPY\n  float d = 101.0; // distorsion\n  float r = 0.24;  // resize\n  float a = 0.1;   // addendum\n  float p = 30.0;  // number of petals\n  float s = 0.03;  // smoothness of the border\n  vec2 center = vec2(0.5, 0.7);\n  palm *= distortedDaisy(st, center,r,s,p,d,a);\n  \n  // STEM\n  float gamboThickness = 0.01;\n  float gamboLenght = 0.14;\n  vec2 position = center-st;\n  float freq_stem = 40.;\n  float amp_stem = 0.03;\n  //gamboThickness += cos(position.y * 120.0) * 0.004;\n  // changing from + to - change the direction of the curve\n  //float curve = abs(position.x  + sin(position.y *freq_stem) * amp_stem);\n  float curve = abs(position.x  + (cos(position.y * freq_stem) * amp_stem));\n  float gambo = 1.0 - (1.0 - smoothstep(gamboThickness, gamboThickness+0.01, curve)) *\n           (1.0 - smoothstep(gamboLenght, 0.01, position.y));\n  palm*=gambo;\n\n  // CIRCLES\n  st = tileMoveCrossed(st, 3., iTime, 0.18);\n  float circle = circleSDF(st, 0.16);\n  circle = strokeSmoot(0.07, circle, .004);\n  \n  // flip on intersection\n  float flipped = flip(palm, circle);\n  \n  green = mix(green, sand, palm);\n  vec3 col = mix(green, violet, flipped);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 127, 302, 510], [512, 512, 543, 543, 575], [577, 577, 628, 628, 731], [733, 733, 768, 768, 802], [804, 804, 874, 874, 1462], [1464, 1464, 1520, 1532, 2960]], "test": "untested"}
{"id": "llSfWy", "name": "heart ice cream", "author": "dildo", "description": "<3", "tags": ["loveheart"], "likes": 0, "viewed": 87, "published": "Public", "date": "1516997749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nmat2 rot(float a)\n{\n    float c = cos(a), s = sin(a);\n    mat2 m = mat2(vec2(c,s),vec2(-s,c));\n    return m;\n}\n\nvec2 spin(vec2 v,float aaa)\n{\n    return rot(fract(aaa)*3.14159265) * v;\n}\n\nfloat g(vec2 v)\n{\n    return ( v.y - v.x );\n}\n\nfloat h(float x)\n{\n    return abs(fract(x)-0.5);\n}\n\nfloat j(float x)\n{\n    x = pow(x,1.5);\n    x = abs(fract(x*5. + iTime)-0.5);\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy - 0.5 ) * 2.;\n    \n    float aa = abs(uv.x)*1.2;\n    float bb = g(vec2(abs(uv.x),uv.y))+0.1;\n    \n    float f = length(vec2(aa, bb));\n    float d = smoothstep(0.7,0.6,f);\n    float t = step(j(f),.16) * d;\n    \n    //t = step(t,0.5);\n    \n    /*\n    float a = 30. * pow(length(uv),1./3.) + iTime * 3.14159265;\n    \n    float f = abs(fract(iTime*.3)-0.5)*2.;\n    float t = smoothstep(f,f+0.5,(uv*m).x);\n*/\n    vec3 rgb = mix(vec3(1.,1.,1.),vec3(1.,0.,0.),1.-t);\n\tfragColor = vec4(rgb,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSfWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 111], [113, 113, 142, 142, 187], [189, 189, 206, 206, 234], [236, 236, 254, 254, 286], [288, 288, 306, 306, 380], [382, 382, 439, 439, 972]], "test": "untested"}
{"id": "llSfzW", "name": "Barf Inducer 2.0", "author": "couch", "description": "more trippy blippies", "tags": ["music", "visualizer"], "likes": 2, "viewed": 132, "published": "Public", "date": "1514772844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float square(float n)\n{\n    return n*n;   \n}\n\n//FabriceNeyret2's Edit\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    vec2 R = iResolution.xy,\n         D = u - R/2.;\n    \n    float sound = texture( iChannel0, vec2(0) ).x,\n\t      s = sin( dot(D/R,D/R) ),\n          b = clamp(sound*2.5, 1., 100.) * (1.-s) / iTime /.8,\n          t = iTime + 2.*s,\n          r = sin(t/2.) *20.*b,\n          p = dot(D,D) * ( sin(t/8.) + 1. )  * (t-2.) * b;\n    \n    O = sin( p/8e2 + r* vec4(0,2,5,0) ) +b/2.;\n}\n\n/* Original Code\nfloat bounce = 0.0;\nfloat bounce2 = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 res = vec2(0.9, 0.9);\n    vec2 iuv = floor( uv * res )/res;\n    \n    \n    float ww = iResolution.x;\n    float hh = iResolution.y;\n    float sound = texture( iChannel0, vec2(iuv.y, 0.0) ).x*1.0;\n    if (bounce2 < sound*15.0){bounce2 += sound*15.0;}\n    if (bounce2 > sound*15.0){bounce2 -= sound*15.0;}\n    bounce2 /= 1.2;\n    if (bounce < bounce2){bounce += bounce2/5.0;}\n    if (bounce > bounce2){bounce -= bounce2/5.0;}\n    bounce = (clamp(bounce, 1.0, 100.0)*((1.0-sin(square(1.0*(uv.x-0.5)) + square(1.0*(uv.y-0.5)))))/(iTime/10.0))/8.0;\n    float time2 = iTime+2.0*(sin(square(1.0*(uv.x-0.5)) + square(1.0*(uv.y-0.5))));\n    \n    float r = sin(time2/2.0)*20.0*bounce;\n    float p = (square(fragCoord.x-ww/2.0) + square(fragCoord.y-hh/2.0))*((sin(time2/8.0)+1.0)/2.0)*((time2-2.0)*2.0)*(bounce/8.0);\n    \n    fragColor.r = sin(p/100.0)+1.0*bounce/2.0;\n    fragColor.g = sin(p/100.0+r/0.5)+1.*bounce/2.0;\n    fragColor.b = sin(p/100.0+r/0.2)+1.0*bounce/2.0;\n}\n*/", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSfzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 44], [46, 70, 108, 108, 487]], "test": "untested"}
{"id": "lt2Bz3", "name": "Kirby Raymarch", "author": "leon", "description": "() Kirby !", "tags": ["3d", "sdf", "kirby"], "likes": 32, "viewed": 826, "published": "Public", "date": "1516755053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// () Kirby !\n// Leon 2018/01/24\n// Using code from IQ, Mercury, LJ, Duke, Koltes\n\n#define STEPS 30.\n#define VOLUME .01\n#define FAR 10.\n#define PI 3.14159\n#define TAU 2.*PI\n\nconst vec3 pink = vec3(0.917,0.482,0.663);\nconst vec3 red = vec3(0.825,0.142,0.111);\nconst vec3 beige = vec3(0.905, 0.670, 0.235);\nconst vec3 blue = vec3(0.058, 0.074, 0.560);\nconst vec3 blueSky = vec3(0.741, 0.941, 1);\nconst vec3 green1 = vec3(0.298,0.830,0.153);\nconst vec3 green2 = vec3(0.038,0.260,0.047);\nconst vec3 gold = vec3(1, 0.858, 0.058);\n\n// sdf toolbox\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nvec2 repeat (vec2 v, float c) { return mod(v,c)-c/2.; }\nvec3 repeat (vec3 v, float c) { return mod(v,c)-c/2.; }\nfloat smoo (float a, float b, float r) { return clamp(.5+.5*(b-a)/r, 0., 1.); }\nfloat smin (float a, float b, float r) { float h = smoo(a,b,r); return mix(b,a,h)-r*h*(1.-h); }\nfloat smax (float a, float b, float r) { float h = smoo(a,b,r); return mix(a,b,h)+r*h*(1.-h); }\nvec2 toroidal (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\nvec3 lookAt (vec3 eye, vec3 target, vec2 uv) {\n  vec3 forward = normalize(target-eye);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  return normalize(forward + uv.x * right + uv.y * up);\n}\n\nstruct Shape {\n    float dist;\n    vec3 color;\n    float spec;\n    float glow;\n};\nShape newShape () { Shape shape; shape.dist = 1000.; shape.color = vec3(1.); shape.spec = 0.; shape.glow = 0.; return shape; }\nShape add (Shape a, Shape b) { Shape c = newShape(); c.dist = min(a.dist, b.dist); float op = step(b.dist, a.dist); c.color = mix(a.color, b.color, op); c.spec = mix(a.spec, b.spec, op); c.glow = mix(a.glow, b.glow, op); return c; }\nShape map (vec3 p);\n\nvec3 getNormal (vec3 p) { vec2 e = vec2(.01,0); return normalize(vec3(map(p+e.xyy).dist-map(p-e.xyy).dist,map(p+e.yxy).dist-map(p-e.yxy).dist,map(p+e.yyx).dist-map(p-e.yyx).dist)); }\nfloat getShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 1.;\n    float t = VOLUME*10.;\n    for (float i = 0.; i <= 1.; i += 1./STEPS) {\n        float dist = map(pos + dir * t).dist;\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nShape sdKirby (vec3 pos) {\n    Shape kirby = newShape();\n    vec3 p;\n\n    // foot\n    p = pos;\n    p.x = abs(p.x)-.4;\n    p.y += 1.;\n    p.z += .35;\n    p.z *= .65;\n    float foot = sdSphere(p, .4);\n    foot = smax(foot, -p.y, .2);\n\n    // breath animation\n    float wave = .5+.5*sin(iTime*5.);\n    pos.y += 1.;\n    pos.y *= 1.+.1*wave;\n    pos.y -= 1.;\n    pos.xz *= 1.-.1*wave;\n\n    // body\n    p = pos;\n    float body = sdSphere(p, 1.);\n\n    // hand\n    p = pos;\n    p.x = abs(p.x)-1.;\n    p.xy *= rot(PI/3.);\n    p.x *= .75;\n    p.y *= 1.5;\n    float hand = sdSphere(p, .4);\n\n    // body compo\n    kirby.dist = min(min(body, foot), hand);\n    kirby.color = mix(pink, red, step(foot, body));\n    // kirby.spec = 1.;\n    kirby.glow = 1.;\n\n    // eyes\n    p = pos;\n    p.y -= .3;\n    p.y *= 1./smoothstep(.0,.1,abs(sin(iTime)));\n    p.x = abs(p.x) - .2;\n    p.x *= 2.;\n    p.y *= .75;\n    kirby.color = mix(kirby.color, vec3(0), step(length(p.xy), .2));\n    p.y -= .1;\n    p.y *= 1.6;\n    kirby.color = mix(kirby.color, vec3(1), step(length(p.xy), .1));\n    p.y += .2;\n    p.x *= .75;\n    p.y *= .4;\n    kirby.color = mix(kirby.color, blue, clamp(-p.y*10.,0.,1.)*step(length(p.xy), .1));\n\n    // open mouth\n    p = pos;\n    p.x *= .5;\n    p.y += .2-abs(p.x*.2);\n    float d = length(p.xy);\n    float mouth = step(d, .1);\n    kirby.color = mix(kirby.color, red, mouth);\n    kirby.color = mix(kirby.color, red*.1, mouth*(1.-clamp(-p.y*10.+.5,0.,1.)));\n\n    // cheeks\n    p = pos;\n    p.x = abs(p.x) - .5;\n    p *= 6.;\n    p.x *= .75;\n    kirby.color = mix(kirby.color, red, .75*(1.-smoothstep(0.5,1.,length(p.xy))));\n\n    return kirby;\n}\n\nShape sdGround (vec3 pos) {\n    Shape ground = newShape();\n    vec3 p;\n    p = pos;\n    p.y += 1.;\n    float cell = .5;\n    float height = .2;\n    float padding = .45;\n    p.xz = repeat(p.xz, cell);\n    p.y += 1. + height;\n    ground.dist = smin(p.y, sdBox(p, vec3(cell*padding, height, cell*padding)), .2);\n    p.y -= 1.;\n    ground.dist = smin(ground.dist, max(sdBox(pos,vec3(1,3,1)),sdBox(p, vec3(cell*padding, height, cell*padding))), .2);\n    ground.color = beige;\n    return ground;\n}\n\nShape sdPlant (vec3 pos) {\n    Shape plant = newShape();\n    plant.spec = .5;\n    plant.glow = 1.;\n    float radius = 2.;\n    pos.y += 1.;\n    pos.xyz = pos.zxy;\n    vec3 p = pos;\n    p.xy = toroidal(p.xy, radius);\n    p.y *= 2.;\n    p.xz *= rot(p.y * 2.+sin(p.y+iTime));\n    float id = amod(p.xz,2.);\n    p.x -= .2;\n    p.xz *= rot(-p.y+iTime+sin(p.y-iTime*2.)*5.);\n    id += amod(p.xz, 4.);\n    p.x -= .1;\n    plant.dist = sdCylinder(p.xz, .04);\n    plant.color = mix(green1, green2, mod(id,2.));\n    return plant;\n}\n\n\nShape sdStar (vec3 pos) {\n    Shape star = newShape();\n    star.spec = 1.;\n    star.glow = 1.;\n    float radius = 5.;\n    float size = .2;\n    vec3 p = pos;\n    p.y -= radius;\n    p.xy *= rot(-iTime*.5);\n    float index = amod(p.xy, 16.);\n    p.x -= radius-1.5;\n    p.xy *= rot(iTime+index);\n    amod(p.xy, 5.);\n    star.dist = sdIso(p, size);\n    star.color = gold;\n    return star;\n}\n\nShape map (vec3 pos) {\n    Shape scene = newShape();\n    vec3 p = pos;\n    scene = add(scene, sdKirby(p));\n    scene = add(scene, sdGround(p));\n    scene = add(scene, sdPlant(p));\n    scene = add(scene, sdStar(p));\n    return scene;\n}\n\n\nvec3 camera (vec3 p) {\n    float click = clamp(iMouse.z, 0., 1.);\n    p.yz *= rot(click*(-.25*PI*(iMouse.y/iResolution.y-.5)));\n    p.xz *= rot(click*(-.5*PI*(iMouse.x/iResolution.x-.5)));\n    p.xz *= rot((1.-click)*(.5*PI*(.4*sin(iTime*.1))));\n    return p;\n}\n\nvec3 raymarch (vec2 uv) {\n    vec3 eye = camera(vec3(0,1,-5.5));\n    vec3 ray = lookAt(eye, vec3(0), uv);\n    float shade = 0., dist = 0.;\n    vec3 pos = eye;\n    Shape shape;\n    for (float i = 0.; i <= 1.; i += 1./STEPS) {\n        shape = map(pos);\n        if (shape.dist < VOLUME || dist > FAR) { shade = 1.-i; break; }\n        shape.dist *= .9 + .1 * rng(uv+fract(iTime));\n        dist += shape.dist;\n        pos = eye + ray * dist;\n    }\n\t   vec3 color = shape.color;\n    vec3 normal = getNormal(pos);\n    vec3 view = normalize(eye-pos);\n    vec3 lightPos = vec3(1.,0,-2.);\n    lightPos.xy *= rot(iTime*.5);\n    lightPos.y += 2.;\n    vec3 lightDir = normalize(lightPos-pos);\n    float light = clamp(dot(lightDir, normal),0.,1.);\n    float ambient = .8;\n    color = mix(shape.color * ambient, shape.color, light);\n    color = mix(color, vec3(1), shape.spec*clamp(pow(light,16.),0.,1.));\n    color *= .3+.7*getShadow(pos, lightPos, 64.)*clamp(dot(lightDir,normal),0.,1.);\n    color = mix(color, shape.color, (1.-abs(dot(normal, view))) * shape.glow);\n    color *= shade;\n    float far = 1.-smoothstep(FAR/2.,FAR,dist);\n    float y = uv.y + sin(uv.x*3.-iTime+sin(uv.x*6.+iTime))*.05;\n    color = mix(beige*abs(y), color, far);\n    color = pow(color, vec3(1./2.));\n    color = mix(color, mix(blueSky, blue, y), (1.-far)*step(0.,y));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tfragColor = vec4(raymarch(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2Bz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 556, 579, 579, 646], [647, 647, 667, 667, 717], [718, 718, 752, 752, 774], [775, 775, 811, 811, 833], [834, 834, 864, 864, 910], [911, 911, 942, 942, 1025], [1026, 1026, 1059, 1059, 1120], [1121, 1121, 1161, 1161, 1349], [1350, 1350, 1383, 1383, 1407], [1408, 1408, 1439, 1439, 1463], [1464, 1464, 1495, 1495, 1519], [1520, 1520, 1560, 1560, 1599], [1600, 1600, 1640, 1640, 1695], [1696, 1696, 1736, 1736, 1791], [1792, 1792, 1825, 1825, 1871], [1872, 1872, 1918, 1918, 2117], [2201, 2201, 2220, 2220, 2327], [2328, 2328, 2358, 2358, 2560], [2582, 2582, 2607, 2607, 2764], [2765, 2765, 2811, 2811, 3164], [3166, 3166, 3192, 3192, 4802], [4804, 4804, 4831, 4831, 5294], [5296, 5296, 5322, 5322, 5814], [5817, 5817, 5842, 5842, 6202], [6204, 6204, 6226, 6226, 6438], [6441, 6441, 6463, 6463, 6701], [6703, 6703, 6728, 6728, 8056], [8058, 8058, 8115, 8115, 8213]], "test": "untested"}
{"id": "lt2fDz", "name": "Torus_Thingy_8", "author": "balkhan", "description": "Another one", "tags": ["3d", "torus", "trivialknot"], "likes": 177, "viewed": 10098, "published": "Public", "date": "1515612374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t400.\n#define E\t\t\t0.00001\n#define FAR\t\t\t50.\n#define PI\t\t\t3.14\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    pos.z = 4.5+1.5*sin(t*10.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    col.xyz = ret_col*(1.-inter.x*.0125);\n    col += h * .4;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    p.z += 10.;\n    \n    rotate(p.xz, 1.57-.5*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    var = atan(p.x,p.y);\n    vec2 q = vec2( ( length(p.xy) )-6.,p.z);\n    rotate(q, var*.25+iTime*2.*0.);\n    vec2 oq = q ;\n    q = abs(q)-2.5;\n    if (oq.x < q.x && oq.y > q.y)\n    \trotate(q, ( (var*1.)+iTime*0.)*3.14+iTime*0.);\n    else\n        rotate(q, ( .28-(var*1.)+iTime*0.)*3.14+iTime*0.);\n    ret_col = 1.-vec3(.350, .2, .3);\n    mind = length(q)+.5+1.05*(length(fract(q*.5*(3.+3.*sin(var*1. - iTime*2.)) )-.5)-1.215);\n    h -= vec3(-3.20,.20,1.0)*vec3(1.)*.0025/(.051+(mind-sin(var*1. - iTime*2. + 3.14)*.125 )*(mind-sin(var*1. - iTime*2. + 3.14)*.125 ) );\n    h -= vec3(1.20,-.50,-.50)*vec3(1.)*.025/(.501+(mind-sin(var*1. - iTime*2.)*.5 )*(mind-sin(var*1. - iTime*2.)*.5 ) );\n    h += vec3(.25, .4, .5)*.0025/(.021+mind*mind);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n            // log trick by aiekick\n\t        if (log(dist.y*dist.y/dist.x/1e5) > .0 || dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2fDz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[476, 698, 726, 726, 1051], [1053, 1100, 1143, 1143, 1492], [1494, 1494, 1515, 1515, 2408], [2410, 2410, 2442, 2442, 2927], [2929, 2943, 2983, 2983, 3058], [3060, 3060, 3082, 3082, 3288]], "test": "untested"}
{"id": "ltBBRm", "name": "3ary interference", "author": "VJSpackOMat", "description": "3ary test for long periods depending on the speeds it may take reaally long for the pattern to restart\n\nthis serves as a personal playground, and is meant to result in some real life art using this mechanics, c.Kleinhuis is playing around, many more will ", "tags": ["3ary"], "likes": 2, "viewed": 71, "published": "Public", "date": "1515013033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat heart(vec2 p,float radius,float thickness){\n\n p *= 0.8;\n    p.y = -0.1 - p.y*1.2 + abs(p.x)*(1.0-abs(p.x));\n    float r = length(p);\n\tfloat d = 0.5;\n \n    return r;\n}\n\n// rings\nfloat circ(vec2 p,float radius,float thickness){\n\treturn mod(length(p ),radius )>thickness*.5?1.:0. ;\n}\n\n// rings squared\nfloat circ2(vec2 p,float radius,float thickness){\n\treturn mod(length(p*p),radius )>thickness*.5?1.:0. ;\n}\n\n// rings cubed\nfloat circ3(vec2 p,float radius,float thickness){\n\treturn mod(length(sin(p)),radius )>thickness*.5?1.:0. ;\n}\n\nfloat circ4(vec2 p,float radius,float thickness){\n    \n    float angle=atan(p.x,p.y);\n        if(mod(angle,2.11)<1.605){\n\treturn  mod(length(p),radius )>thickness*.5?1.:0.;\n        }else{\n        return 0.;\n        }\n}\n\n\n// pattern that repeats after just few rounds\n//  vec3 speeds=vec3(2.,3.,5.);\n\n// longer prime number pattern, repeats after some more frames ....  31*53*67=110081 frames\n// vec3 speeds=vec3(1.31,1.53,1.67);\n\n\n// very long prime number pattern, repeats after some more frames ....  33637*68023*94321=some more frames\nvec3 speeds=vec3(1.33637\t, 1.68023\t,1.94321\t);\nfloat speed=1.;\nfloat moveradius=0.05;\nfloat radius=0.07;\nfloat thickness=.07;  \n\n\nvec3 color1=vec3(1.,0.,0.);\nvec3 color2=vec3(0.,1.,1.);\nvec3 color3=vec3(.5,1.,0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv-=0.5;\n    uv-=iMouse.xy/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 p1=vec2(sin(iTime*speeds.x*speed),cos(iTime*speeds.x*speed))*moveradius;\n    vec2 p2=vec2(sin(iTime*speeds.y*speed),cos(iTime*speeds.y*speed))*moveradius+vec2(.0,0.);\n    vec2 p3=vec2(sin(iTime*speeds.z*speed),cos(iTime*speeds.z*speed))*moveradius-vec2(.0,0.);\n    \n\tvec3 col = vec3( circ(uv+p1,radius,thickness))*color1;\n\tcol +=circ(uv+p2,radius,thickness)*color2;\n\t col += circ(uv+p3,radius,thickness)*color3;\n    fragColor=vec4(col,1.);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBBRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 50, 50, 173], [175, 184, 232, 232, 287], [289, 306, 355, 355, 411], [413, 428, 477, 477, 536], [538, 538, 587, 587, 756], [969, 1291, 1348, 1348, 1934]], "test": "untested"}
{"id": "ltBBzm", "name": "easy clouds", "author": "SourceW", "description": "easy noise clouds", "tags": ["2d", "noise", "clouds", "cloud"], "likes": 1, "viewed": 564, "published": "Public API", "date": "1515037464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec2 p)\n{\n    p  = 20.0*fract( p*0.3 + vec2(0.9,0.101));\n\n    return -1.0 + 2.0 * fract((p.x + p.y) * p.y * p.x);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm( in vec2 p) {\n    float c = 0.0;\n\n    for (float i=1.0;i<10.0;i++) {\n        c+=noise(p*pow(1.5, i))*0.9*pow(0.6, i);\n    }\n    return c;\n}\n\nfloat c(in vec2 p,in float x){\n\np += iTime*0.01;\n    \nreturn fbm(p)*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    p.xy += iTime*0.01;\n \n    vec4 clouds = vec4(1.0);\n\n    clouds *= c(p*5.0,fbm(p*5.0));\n    \n\tfragColor = clouds;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBBzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 126], [128, 128, 154, 154, 448], [449, 449, 472, 472, 598], [600, 600, 630, 630, 672], [674, 674, 731, 731, 896]], "test": "untested"}
{"id": "ltBfDD", "name": "quadratic bezier text", "author": "dahart", "description": "quadratic bezier text", "tags": ["bezier", "text", "quadratic"], "likes": 1, "viewed": 124, "published": "Public", "date": "1515802183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remap(float x, float min1, float max1, float min2, float max2) {\n    return clamp(min2 + (x - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\nconst vec2 X = vec2(1.0, 0.0);\nconst float PI = 3.14159265358979323;\nconst float fMaxFloat = intBitsToFloat(0x7f7fffff);\n\n//https://www.shadertoy.com/view/ltXSDB\n// Solve cubic equation for roots\n#if 0\n// original version for reference\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n#else \n// Solve cubic equation for roots\n// x^3 + ax^2 + bx + c = 0\n// Simplified via constant folding\nvec3 solveCubic(float a, float b, float c)\n{\n    a *= (1./3.);\n    b *= (1./3.);\n    float p = a*a - b;\n    float q =  a*(b/2. - p) - c/2.;\n    float d = q*q - p*p*p;\n    if(d >= 0.) { \n        float z = sqrt(d);\n        vec2 x = vec2(q+z, q-z);\n        vec2 uv = sign(x) * pow(abs(x), vec2(1./3.));\n        return vec3(uv.x + uv.y - a);\n    } else {\n        float snp = sqrt(p);\n        float v = acos(q / (p*snp)) * (1./3.);\n        float m = cos(v);\n        float n = sin(v) * sqrt(3.);\n        return vec3(m+m, -n-m, n-m) * snp - a;\n    }\n}\n#endif\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Find the signed distance from a point to a bezier curve\n// returns a vec4: (dist to boundary, dist to curve, sign, parameter [0-1])\nvec4 sdBezier(vec2 p, vec3 A, vec3 B, vec3 C)\n{    \n    //B = (4.0 * B - A - C) / 2.0;\n    // handle instability when B is midpoint between A and C\n    //B = vec3(mix(B.xy + vec2(1e-4), B.xy, abs(sign(B.xy * 2.0 - A.xy - C.xy))), B.z);\n    vec3 b = A - B * 2.0 + C;\n    //B.xy += 0.0001 * sign(b.xy);\n    \n    vec3 a = B - A;\n    b = A - B * 2.0 + C;\n    vec3 c = a * 2.0;\n    vec2 d = A.xy - p;\n    \n    vec3 k = vec3(3.*dot(a.xy,b.xy),2.*dot(a.xy,a.xy)+dot(d.xy,b.xy),dot(d.xy,a.xy)) / dot(b.xy,b.xy);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec3 it = vec3(1.0) - t;\n\n    mat3x3 pos;\n    pos[0] = A + (c + b*t.x)*t.x;\n    pos[1] = A + (c + b*t.y)*t.y;\n    pos[2] = A + (c + b*t.z)*t.z;\n\n    float[3] dis;\n    dis[0] = length(pos[0].xy - p) - pos[0].z;\n    dis[1] = length(pos[1].xy - p) - pos[1].z;\n    dis[2] = length(pos[2].xy - p) - pos[2].z;\n    \n    int whichMin = 0;\n    if (dis[1] < dis[whichMin]) whichMin = 1;\n    if (dis[2] < dis[whichMin]) whichMin = 2;\n        \n    return vec4(dis[whichMin], \n                dis[whichMin] + pos[whichMin].z,\n                signBezier(A.xy, B.xy, C.xy, p), \n                t[whichMin]);\n}\n\n// evaluate closest distance to a picewise quadratic bezier\n// p is the point to query distance from\n// n is how many control points\n// pts are the n control points\n// returns a vec4: (dist to fat curve boundary, dist to curve center, sign, parameter [0-1])\nvec4 sdCurve(vec2 p, int n, vec3[16] pts) {\n    vec4 d = fMaxFloat * X.xxxx, e;    \n    vec3 pp1 = mix(pts[0], pts[1], -0.001), pp2;\n    float oofn = 1.0 / (float(n));\n    for (int i = 0; i < n; i++) {\n        pp2 = 0.5 * (pts[i] + pts[i+1]);\n        e = sdBezier(p, pp1, pts[i], pp2);\n        pp1 = pp2;\n        //if (e.w < .99 && e.w > 0.01)\n        if (e.x < d.x) d = vec4(e.xyz, (e.w+float(i))*oofn);\n    }\n    return d;\n}\n\n// evaluate a piecewise quadratic bezier. \n// t is the parameter [0,1] for the entire curve.\n// n is how many control points\n// pts are the n control points\nvec3 evalCurve(float t, int n, vec3[16] pts) {\n    t *= float(n);\n    float pt = fract(t);\n    int c1 = int(t);\n    int c0 = max(0, c1 - 1);\n    int c2 = min(n-1, c1 + 1);\n    \n    vec3 p0 = mix(pts[c0], pts[c1], .5);\n    vec3 p1 = pts[c1];\n    vec3 p2 = mix(pts[c1], pts[c2], .5);\n    \n    return mix(mix(p0, p1, pt), mix(p1, p2, pt), pt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime + (iResolution.x + iMouse.x) / 100.;\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n\t//fragColor = texture(iChannel0, uv);\n    \n    // create a curve\n    vec3 curve1[16];\n    for (int i = 0; i < 16; i++) {\n        curve1[i].x = float(i)/10. + 0.1;\n        curve1[i].y = .1 * sin(float(i)*.7 - time) + .5;\n        curve1[i].z = .005 * float(i) + 0.05;\n    }\n    \n    // render the curve\n    vec4 d = sdCurve(uv, 15, curve1);\n    float edgeWidth = fwidth(d.x) * 2.;\n    if (d.x < edgeWidth) {\n\t    vec3 p = evalCurve(d.w, 15, curve1);\n        float aa = smoothstep(edgeWidth, 0., d.x);\n        \n        vec2 curve_uv = vec2(d.w, .5 - .5 * d.z * d.y / p.z);    \n        \n        const float nletters = 26.;\n        float word_u = clamp(remap(fract(curve_uv.x/1.5-time/19.), .0, 1., 0., 1.) * nletters - 1., 0., nletters-1.);\n    \tfloat word_v = remap(curve_uv.y*1.5-.25, .0, 1., 0., 1.);\n    \n    \tvec2 letter_uv = vec2( fract(word_u), word_v );\n\n    \tint a = 16*6 + 1 - 1;\n        int ltrs[] = int[](31,4,9,18,5,3,20,9,15,14,31,178,31,4,9,18,5,3,20,9,15,14,31,178,31,31);\n        int ltr = int(word_u);\n        int idx = a + ltrs[ltr];\n        int sx = idx % 16;\n        int sy = 16 - idx / 16 - 1;\n\n        vec2 fuv = (1./16.) * (letter_uv + vec2(sx, sy));\n        \n        // render text\n        if (letter_uv.x > .1 && letter_uv.x < .9) // avoid the fringing letter edges\n        \tfragColor += vec4(vec3(texture(iChannel0, fuv).r), 1.);\n        \n        fragColor.r = aa;\n        fragColor.g += clamp(curve_uv.y, 0., 1.) * aa; // dist to curve over curve radius\n        fragColor.b = float(int(mod(curve_uv.x, .1) < .05) ^ int(mod(curve_uv.y, .2) < .1)) * aa;\n    }\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBfDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 70, 70, 153], [1605, 1668, 1709, 1709, 1775], [1777, 1847, 1897, 1897, 2248], [2250, 2425, 2472, 2660, 3590], [3592, 3850, 3893, 3893, 4276], [4278, 4435, 4481, 4481, 4777], [4779, 4779, 4836, 4836, 6523]], "test": "untested"}
{"id": "ltBfWR", "name": "Seahorse Valley", "author": "hypothete", "description": "Figure 15 from the book \"The Beauty of Fractals,\" by H. -.O Peitgen and P. H. Richter. Some adjustments to center and animate the fractal.", "tags": ["fractals", "book", "doityourself"], "likes": 2, "viewed": 85, "published": "Public", "date": "1515289845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWOPI 6.283185\n\nvec3 palette(in float t)\n{\n    // http://www.iquilezles.org/www/articles/palettes/palettes.htm\n\tvec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(TWOPI*(c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * vec2(1.75, 0.5) + vec2(0.0, 0.2);\n    float m = 200.0;\n    float ts = abs(cos(iTime / 5.0));\n    float k = 100.0 * ts;\n    vec2 pq = vec2(-0.74543, 0.11301);\n    vec2 dmin = vec2(-1.8);\n    vec2 dmax = vec2(1.8);\n    vec2 dv = (dmax - dmin) / (pq - vec2(1.0));\n    vec2 dk = dmin - uv * dv;\n    float rv = 0.0;\n    for(float s=0.0; s<k; s+=1.0){\n        dk = vec2(\n        \tdk.x * dk.x - dk.y * dk.y + pq.x,\n        \t2.0 * dk.x * dk.y + pq.y\n    \t);\n        float rr = dk.x * dk.x + dk.y + dk.y;\n        if(rr > m){\n        \trv = s/k;\n            break;\n        }\n    }\n    if (rv == 0.0) {\n    \trv = 1.0;\n    }\n    vec3 col = palette(rv);\n    col = pow(col, vec3(1.0/2.2));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBfWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 50, 118, 268], [270, 270, 327, 327, 1075]], "test": "untested"}
{"id": "ltjBDm", "name": "pi pie", "author": "fu5ha", "description": "test", "tags": ["math"], "likes": 0, "viewed": 81, "published": "Public", "date": "1516174425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define animSpeed 5.0\n#define PI 3.14159265\n#define HALFPI PI/2.0\nfloat S(float v) {\n    return smoothstep(1., 0., abs(v)/fwidth(v));\n}\nfloat Smodpi(float v) {\n    return smoothstep(1., 0., abs(mod(v, PI)-HALFPI)/fwidth(v));\n}\n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    float d2 = dot(uv, uv);\n    float col = 1.;\n    float a = atan(uv.y/uv.x);\n    float iT = iTime/animSpeed;\n    if (d2 <= 0.563) {\n        float d = sqrt(d2);\n        float outer = 0.015*sin(12.*(a - iT)) + 0.5 + 0.05 * sin(iT * 10.);\n        float inner = 0.015*sin(12.*(a - iT)) + 0.4 + 0.05 * sin(iT * 10.); \t\n        col -= S(outer - d);\n        col -= S(inner - d);\n        if (d <= inner) {\n            col -= Smodpi((iT-a)*4.);\n        }\n    }\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjBDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 84, 84, 135], [136, 136, 159, 159, 226], [234, 234, 291, 291, 840]], "test": "untested"}
{"id": "ltjBWD", "name": "Moire mandala", "author": "huttarl", "description": "Following IQ's article on distance estimation, I stumbled upon a pretty cool moire pattern. Best viewed at small scale (NOT full screen). Leave it going long enough, and you get circles, crescents, lines in 16 directions (even 32 and more!), and rhombi.", "tags": ["2d", "moire"], "likes": 3, "viewed": 131, "published": "Public", "date": "1515874756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** Following http://iquilezles.org/www/articles/distance/distance.htm */\n\nfloat f(in vec2 p) {\n\tfloat r = length(p), a = atan(p.y, p.x);\n    float t = pow(iTime, 1.4);\n    return r - 1. + 0.5 * sin(3. * a - t + (2. + t * 0.2) * r * r);\n}\n\n// Naive approach:\nfloat color(in vec2 p) {\n    float v = abs(f(p));\n    float eps = 20. / iResolution.x;\n    return smoothstep(1.0 * eps, 2.0 * eps, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) * .6 / iResolution.xx;\n    float col = color(uv * 10. ); // color(uv * 10.);\n    // Make the black a bit purplish.\n    float b = 1.0 - (1.0 - col) * .8;\n\tfragColor = vec4(b, col, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjBWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 75, 95, 95, 238], [240, 259, 283, 283, 395], [397, 397, 454, 454, 692]], "test": "untested"}
{"id": "ltjBzt", "name": "Star Test", "author": "Jamboltheads", "description": "lol", "tags": ["stars"], "likes": 1, "viewed": 89, "published": "Public", "date": "1516901099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MATH_PI\t= float( 3.14159265359 );\n\nvoid Rotate( inout vec2 p, float a ) \n{\n\tp = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1.0 ) * r;\n}\n\nfloat Rand( vec2 c )\n{\n\treturn fract( sin( dot( c.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat saturate( float x )\n{\n\treturn clamp( x, 0.0, 1.0 );\n}\n\nvoid BokehLayer( inout vec3 color, vec2 p, vec3 c )   \n{\n    float wrap = 900.0;       \n    \n    vec2 p2 = mod( p + 0.5 * wrap, wrap ) - 0.5 * wrap;\n    vec2 cell = floor( p / wrap + 0.5 );\n    float cellR = Rand( cell );\n        \n    c *= fract( cellR + 3.33 ) * 0.5;    \n    float radius = mix( 10.0, 100.0, fract( cellR * 7.77 + 7.77 ) );\n    p2.x *= mix( 0.9, 1.1, fract( cellR * 11.13 + 11.13 ) );\n    p2.y *= mix( 0.9, 1.1, fract( cellR * 17.17 + 17.17 ) );\n    \n    float sdf = Circle( p2, radius );\n    float circle = 1.0 - smoothstep( 0.0, 1.0, sdf * 0.04 );\n    float glow\t = exp( -sdf * 0.025 ) * 0.3 * ( 1.0 - circle );\n    color += c * ( circle + glow );\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = (p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat threshold(float f, float thresh) {\n    if (f >= thresh) {\n        return ((f + thresh - 1.0f)/thresh)/4.0f;\n    }\n    return 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.1,1.0);\n    \n\n    \n    float starSize = 2.0f;\n    \n    for (float i = -starSize; i < starSize; i++) {\n        for (float j = -starSize; j <starSize; j++) {\n        \tvec2 offset = vec2(i,j);\n            if (distance(offset, vec2(0)) <= starSize) {               \n           \t\tvec2 sampleCoords = fragCoord.xy - vec2(iMouse) + offset;\n\t\t\t\tfloat f = threshold(noise(sampleCoords),0.75);\n    \t\t\tfragColor += vec4(f);\n            }\n\n        }\n    }\n    \n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = ( 2.0 * fragCoord - iResolution.xy ) / iResolution.x * 1000.0;\n    \n    // background\n\tvec3 color = mix( vec3( 0.7, 0.1, 0.3 ), vec3( 0.1, 0.4, 0.5 ), dot( uv, vec2( 0.2, 0.7 ) ) );\n\n    float time = (iTime - 15.0)/2.0f;\n    \n    Rotate( p, 0.2 + time * 0.03 );\n    BokehLayer( color, p + vec2( -50.0 * time +  0.0, 0.0  ), 3.0 * vec3( 0.2, 0.1, 0.2 ) );\n\n    fragColor += vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjBzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 86, 86, 138], [140, 140, 173, 173, 217], [219, 219, 241, 241, 318], [320, 320, 347, 347, 379], [381, 381, 437, 437, 1050], [1052, 1052, 1072, 1072, 1139], [1141, 1141, 1161, 1161, 1365], [1367, 1367, 1407, 1407, 1505], [1507, 1507, 1564, 1564, 2498]], "test": "untested"}
{"id": "ltjBzw", "name": "hypnotise effect", "author": "andrewww1", "description": "hypnotising effect.\n\nUnfortunately the colour scheme turns rainbow after a while, instead of staying in the initial \"chrome-like\" colour range.\nAlso I would like to make it sharper without making it brighter.", "tags": ["screensaver", "hypnotise"], "likes": 0, "viewed": 98, "published": "Public", "date": "1515193431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//based on https://www.shadertoy.com/view/lsffDf\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=0.5;\n    \n    \n    //float aspect=iResolution.x/iResolution.y;\n    //uv.x*=aspect;\n    \n    //uv*=uv;\n    //float q=uv.y*uv.y*uv.y+uv.x*uv.x*uv.x;\n    //float q=(uv.x*uv.x+uv.y*uv.y*uv.y)*uv.y;\n    //float q=sin(uv.x*uv.x)+cos(uv.y*uv.y*uv.y);\n    float q=dot(uv,uv);\n    //float q=abs(uv.y)+abs(uv.x);\n\n    \n    \n    vec3 c = cos(((iTime*-0.35 +0.0)+q)*20.0 + vec3(0.3,0.7,0.9));\n    \n    //vec3 c= cos(((iTime*-0.35 +0.0)*vec3(1.0,1.0,1.0)+q)*(vec3(0.0,0.1,0.2)+20.0));\n\n    \n    c=c*0.5+0.5;\n    //c=c*0.7+0.5; //sharper\n    \n    //c=abs(c);\n    //c=normalize(c);\n\n    //c*=1.5; //sharper\n   \n    fragColor = vec4(c,1.0);\n}\n\n/*\nvoid mainImage( out vec4 O, vec2 U ) {\n    \n    U = U / iResolution.xy - .5;\n    \n    float q = dot(U,U),\n          t = iTime+10.,\n          s = 20.;\n    \n    O = .5 + .5 * cos( (q - t*.25) * s + vec4(0,.1,.2,0) );\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjBzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 106, 106, 791]], "test": "untested"}
{"id": "ltjfRG", "name": "Noise Holes Mask", "author": "smkgames", "description": "Forked from https://www.shadertoy.com/view/XdyXz3", "tags": ["noise", "mask", "holes"], "likes": 1, "viewed": 148, "published": "Public", "date": "1516349571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//END ASHIMA /////////////////////////////////////////////////\n\nconst float STEPS = 8.;\nconst float CUTOFF = 0.65; //depth less than this, show white wall\nconst vec2  OFFSET = vec2(0.004,0.004); //drop shadow offset\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat getNoise(vec2 uv, float t){\n    \n    //given a uv coord and time - return a noise val in range 0 - 1\n    //using ashima noise\n    \n    //octave 1\n    float SCALE = 2.0;\n    float noise = snoise( vec3(uv.x*SCALE + t,uv.y*SCALE + t , 0));\n    \n    //octave 2 - more detail\n    SCALE = 6.0;\n    noise += snoise( vec3(uv.x*SCALE + t,uv.y*SCALE , 0))* 0.2 ;\n    \n    //move noise into 0 - 1 range    \n    noise = (noise/2. + 0.5);\n    \n    //make deeper rarer\n    //noise = pow(noise,2.);\n    \n    return noise;\n    \n}\n\nfloat getDepth(float n){\n \n    //given a 0-1 value return a depth,\n    //e.g. distance into the hole\n    \n    //remap remaining non-cutoff region to 0 - 1\n\tfloat d = (n - CUTOFF) / (1. - CUTOFF); \n        \n    //step it\n    d = floor(d*STEPS)/STEPS;\n    \n    return d;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float t = iTime * 0.3;    \n    vec3 col = vec3(0);\n    \n   \tfloat noise = getNoise(uv*3., t);\n    \n    if (noise < CUTOFF){\n        \n        //white wall\n        col = vec3(1.,1.,1.);//white\n        \n    }\n    \n    \n    fragColor = vec4(1.-col,1.0);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjfRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 93, 93, 142], [144, 144, 166, 166, 206], [208, 208, 236, 236, 288], [290, 290, 314, 314, 2460], [2577, 2679, 2700, 2700, 2869], [2871, 2871, 2904, 3022, 3390], [3392, 3392, 3416, 3546, 3667], [3669, 3669, 3726, 3726, 4026]], "test": "untested"}
{"id": "ltjfWD", "name": "Simple SDF", "author": "chrisnolet", "description": "Experiments with ray marching", "tags": ["raymarching", "sdf"], "likes": 3, "viewed": 570, "published": "Public", "date": "1515910729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst int kMaxSteps = 1000;\nconst float kMaxDepth = 1000.0;\nconst float kTolerance = 0.01;\nconst float kPi = 3.1415926535897932384626433832795;\nconst float kFov = 90.0;\nconst float kTanFov = tan(kFov / 360.0 * kPi);\n\nconst vec3 kCameraOrigin = vec3(0.0, 0.0, 10.0);\nconst vec3 kDirectionalLight = normalize(vec3(-0.6, -0.4, -0.6));\nconst vec3 kSkyboxColor = vec3(0.0);\nconst vec3 kDiffuseColor = vec3(0.4, 0.05, 0.05);\nconst vec3 kSpecularColor = vec3(0.6, 0.5, 0.5);\nconst float kSpecularExponent = 8.0;\nconst float kAmbientCoefficient = 0.2;\n\n////////////////////////////////////////////////////////////////////////////////\n// Forward declarations\n\nfloat sceneSDF(vec3 point);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\nfloat march(vec3 origin, vec3 direction);\nvec3 normal(vec3 point);\nvec4 color(vec3 point, vec3 direction);\n\nfloat sdSphere(vec3 p, float s);\nfloat udBox(vec3 p, vec3 b);\nfloat udRoundBox(vec3 p, vec3 b, float r);\n\nvec3 opRotation(vec3 point, float angle);\n\n////////////////////////////////////////////////////////////////////////////////\n// Scene\n\nfloat sceneSDF(vec3 point) {\n    \n    // Define object parameters\n    vec3 sphereOffset = vec3(4.0, 2.0, 0.0);\n    float sphereRadius = 1.0;\n    \n    vec3 boxOffset = vec3(-4.0, -2.0, 0.0);\n    vec3 boxSize = vec3(1.2, 1.0, 2.0);\n    float boxRadius = 0.2;\n    \n    // Calculate distance to each object\n    float sphere = sdSphere(\n        opRotation(point, iTime) - sphereOffset,\n        sphereRadius\n    );\n    \n    float box = udRoundBox(\n        opRotation(point - boxOffset, -iTime),\n        boxSize,\n        boxRadius\n    );\n    \n    // Join sphere and box\n    return min(sphere, box);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Functions\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Calculate ray direction from fragment coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    vec3 direction = normalize(vec3(uv, -0.5 / kTanFov));\n    \n    // Set camera origin\n    vec3 origin = kCameraOrigin;\n    \n    // Calculate scene depth\n    float depth = march(origin, direction);\n    \n    // Render color\n    if (depth < kMaxDepth) {\n        vec3 normal = normal(origin + depth * direction);\n        \n        fragColor = color(normal, direction);\n    }\n    else {\n        fragColor = vec4(kSkyboxColor, 1.0);\n    }\n}\n\nfloat march(vec3 origin, vec3 direction) {\n    float depth = 0.0;\n    \n    for (int n = 0; n < kMaxSteps; n++) {\n        \n        // Get distance to nearest object\n        float distance = sceneSDF(origin + depth * direction);\n        \n        // Return when distance is within tolerance\n        if (distance <= kTolerance) {\n            return depth;\n        }\n        \n        // Increment ray\n        depth += distance;\n        \n        // Return if depth exceeds max depth\n        if (depth > kMaxDepth) {\n            return kMaxDepth;\n        }\n    }\n    \n    // Return max depth after too many steps\n    return kMaxDepth;\n}\n\nvec3 normal(vec3 point) {\n    \n    // Measure the change-in-distance along each axis\n    vec3 deltaX = vec3(kTolerance, 0.0, 0.0);\n    vec3 deltaY = vec3(0.0, kTolerance, 0.0);\n    vec3 deltaZ = vec3(0.0, 0.0, kTolerance);\n    \n    float x = sceneSDF(point + deltaX) - sceneSDF(point - deltaX);\n    float y = sceneSDF(point + deltaY) - sceneSDF(point - deltaY);\n    float z = sceneSDF(point + deltaZ) - sceneSDF(point - deltaZ);\n    \n    // Return vector where SDF gradient is maximized\n    return normalize(vec3(x, y, z));\n}\n\nvec4 color(vec3 normal, vec3 direction) {\n    \n    // Calculate lighting\n    vec3 halfway = -normalize(direction + kDirectionalLight);\n    float specularBase = max(0.0, dot(normal, halfway));\n    \n    vec3 diffuse = kDiffuseColor * max(0.0, dot(normal, -kDirectionalLight));\n    vec3 specular = kSpecularColor * pow(specularBase, kSpecularExponent);\n    vec3 ambient = kAmbientCoefficient * kDiffuseColor;\n    \n    // Combine components\n    return vec4(diffuse + specular + ambient, 1.0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distances: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat udBox(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Operations\n\nvec3 opRotation(vec3 point, float angle) {\n    \n    // Invert angle\n    float cosineAngle = cos(-angle);\n    float sineAngle = sin(-angle);\n    \n    // Generate rotation matrix\n    mat3 rotation = mat3(\n        vec3(cosineAngle, 0.0, -sineAngle),\n        vec3(0.0,         1.0, 0.0),\n        vec3(sineAngle,   0.0, cosineAngle)\n    );\n    \n    // Apply rotation\n    return (rotation * point);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjfWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1087, 1178, 1206, 1243, 1771], [1773, 1868, 1923, 1985, 2490], [2492, 2492, 2534, 2534, 3121], [3123, 3123, 3148, 3207, 3648], [3650, 3650, 3691, 3722, 4140], [4142, 4305, 4338, 4338, 4366], [4368, 4368, 4397, 4397, 4440], [4442, 4442, 4485, 4485, 4532], [4534, 4630, 4672, 4697, 5024]], "test": "untested"}
{"id": "ltjfzG", "name": "2D Distance Fields Draft v2", "author": "demicuz", "description": "Just having fun with stuff", "tags": ["notagsitsadraft"], "likes": 0, "viewed": 74, "published": "Public", "date": "1517260115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI radians(180.)\n\nvec2 m;  // mouse\nfloat t; // time\n\nfloat sdCircle(vec2 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 dim)\n{\n    p = abs(p);\n    dim /= 2.;\n    \n    float inDist  = min(-min(dim.x - p.x, dim.y - p.y), .0);\n    float outDist = length(max(vec2(.0), p - dim));\n    \n    return inDist + outDist;\n}\n\nfloat sdPill(vec2 p, vec2 dim)\n{\n    // TODO optimize this\n    \n    dim *= .5;\n    float w, h;  // HALF width and height\n    \n    if (dim.y > dim.x)\n    {\n        p = mat2(0., 1., -1., 0.) * p;  // rotate by 90 degrees\n        \n        w = dim.y;\n        h = dim.x;\n    } else {\n        w = dim.x;\n        h = dim.y;\n    }\n    \n    // This approach is wrong. It lies about inner distance.\n    float c1Dist  = sdCircle(p + vec2(w - h, .0), h);\n    float c2Dist  = sdCircle(p + vec2(h - w, 0.), h);\n    float boxDist = sdBox(p, vec2(2.*(w - h), 2.*h));\n    \n    return min(min(c1Dist, c2Dist), boxDist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = iMouse.xy / iResolution.xy;\n    t = iTime;\n    float ratio = iResolution.x / iResolution.y;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x *= ratio;\n    uv *= 20.;\n    \n    //vec2 circlePos = vec2(5.*sin(t/1.5), 4.*cos(1.3*t+2.));\n    vec2 circlePos = vec2(.0);\n    float circleDist = sdCircle(uv - circlePos, 2.);\n    float circle = step(circleDist, .0);\n    \n    \n    //vec2 boxPos = vec2(3.*sin(t+.3), -4.*cos(t))*2.;\n    vec2 boxPos = vec2(m.x-.5, m.y-.5)*20.;\n    boxPos.x *= ratio;\n    float boxDist = sdBox(uv - boxPos, vec2(1., 4.));\n    float box = step(boxDist, .0);\n    \n    vec2 pillPos = vec2(3.*sin(t+.3), -4.*cos(t));\n    float pillDist = sdPill(uv - pillPos, vec2(m.x*10., m.y*10.));\n    float pill = step(pillDist, .0);\n    \n    //float dist = min(circleDist, boxDist);\n    float dist = pillDist;\n    vec3 c1 = vec3(fract(dist));\n    vec3 c2 = vec3(box + pill);\n    \n    float line = abs(1. / abs(boxDist - circleDist));\n    \n    line *= .01;\n    \n    vec3 color = mix(c1, c2, .7) + line;\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjfzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 62, 96, 96, 124], [126, 126, 157, 157, 342], [344, 344, 376, 402, 947], [950, 950, 1007, 1007, 2078]], "test": "untested"}
{"id": "ltjyWD", "name": "Rippler ", "author": "Vovosunt", "description": ".", "tags": ["2d"], "likes": 1, "viewed": 100, "published": "Public", "date": "1515262175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define c30 0.86602540378\n#define grid 25.0\n#define split 5.0\n#define smooth (40.0 / iResolution.x)\n#define rt (iTime * 5.)\n#define PI      3.14159265359\n#define count 10.0\n#define cutoff 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = (fragCoord.xy -0.5 * iResolution.xy)/ iResolution.x;\n    float a = (atan(st.x,st.y) + PI) /PI /2.;\n    float l = length(st);\n    float lf = abs(fract(l*grid)-0.5)*2.;\n    float ft = (sin(-rt + l*15.0) + 1.0)/2.;\n    ft = ft*ft*ft - 0.002 * grid;\n    vec3 finCol = vec3(smoothstep(smooth,-smooth,lf-ft),\n                      smoothstep(smooth,-smooth,lf-ft -smooth*2.),\n                      smoothstep(smooth,-smooth,lf-ft-smooth*4.));\n\tfragColor = vec4(finCol,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 250, 250, 731]], "test": "untested"}
{"id": "ltSBDW", "name": "2D light", "author": "elk", "description": "first test in 2D for area light", "tags": ["arealight"], "likes": 1, "viewed": 168, "published": "Public", "date": "1515765722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 lightP1 = vec2(-0.05, 0.0);\nvec2 lightP2 = vec2(0.05, 0.0);\nvec2 lightCenterPosition = vec2(0.5, 0.25);\nvec2 lightNormal = vec2(0.0,1.0);\nfloat pi = 3.141592;\n\nvec4 computeSegmentLight(in vec2 position){\n    vec2 P2P1 = lightP2-lightP1;\n    vec2 surfaceP1 = position - lightP1;\n    vec2 surfaceP2 = position - lightP2;\n    vec2 lightP3;\n    \n    float cosTheta1 = dot(normalize(P2P1), normalize(surfaceP1));\n    float cosTheta2 = dot(normalize(-P2P1), normalize(surfaceP2)); \n    if(cosTheta1 < 0.0 || cosTheta2 < 0.0){\n    \tlightP3 = length(surfaceP1) < length(position - lightP2) ? lightP1 : lightP2;\n    }else{\n        float cosTheta = cosTheta1;\n        lightP3 = lightP1 + length(surfaceP1 * cosTheta) * normalize(P2P1);\n        \n    }\n    \n\tvec4 light = vec4(1.0) *  (dot(lightNormal, normalize(position-lightP3)));\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = iTime;\n\tfloat cs = cos(theta);\n\tfloat sn = sin(theta);\n\t\n    lightP1 = vec2(lightP1.x*cs - lightP1.y*sn, lightP1.x*sn + lightP1.y*cs);\n    lightP2 = vec2(lightP2.x*cs - lightP2.y*sn, lightP2.x*sn + lightP2.y*cs);\n\tlightNormal = vec2(lightNormal.x*cs - lightNormal.y*sn, lightNormal.x*sn + lightNormal.y*cs);\n    \n    lightP1 += lightCenterPosition;\n    lightP2 += lightCenterPosition;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xx;\n\t\n    fragColor = computeSegmentLight(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSBDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 208, 208, 851], [853, 853, 910, 910, 1405]], "test": "untested"}
{"id": "ltSBWK", "name": "Fidget Spinner", "author": "slerpy", "description": "My friend Alex asked for it. Might delete this soon.", "tags": ["2d"], "likes": 2, "viewed": 170, "published": "Public", "date": "1517174341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\n\nfloat fidget(vec2 uv, float t)\n{\n    float a = mod(atan(uv.x, uv.y)-t, TAU/3.) - TAU/6.;\n    uv = vec2(sin(a),cos(a))*length(uv);\n    \n    float c0 = length(uv) + .01;\n    float c1 = length(uv - vec2(0, .5));\n    \n    float d = 4. / iResolution.x;\n    float y0 = smoothstep(-d, d, min(c0, c1) - .2);\n    float y1 = smoothstep(-d, d, smin(c0, c1, .2) - .3);\n    \n    return (y0 + y1) / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    float ditter = texelFetch(iChannel0, ivec2(fragCoord)%8, 0).r;\n    float time = iTime - .01 * ditter;\n    fragColor = vec4(fidget(uv, sqrt(4.+iMouse.x) * time)) - 0.1*dot(uv,uv);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSBWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 66, 66, 146], [148, 148, 180, 180, 538], [540, 540, 597, 597, 845]], "test": "untested"}
{"id": "ltSBWz", "name": "vertical - soundcloud - shader", "author": "lienthealien", "description": "Sound shader ", "tags": ["shader"], "likes": 0, "viewed": 59, "published": "Public", "date": "1515325595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 st = fragCoord.xy/iResolution.xy;\nfloat fft1  = texture( iChannel0, vec2(st.y,0.15) ).x; \nfloat fft2  = texture( iChannel0, vec2(st.y,0.25) ).x; \nfloat fft3  = texture( iChannel0, vec2(st.y,0.55) ).x; \n\nfloat pct = 0.0;\nfloat f1=(1.0-fft1);\nfloat f2=(1.0-fft2);\nfloat f3=(1.0-fft3);\npct = distance(st,vec2(0.5));\n\nvec3 color = \n   vec3(pow(st.y*st.y*1.6180+st.y*st.y*1.6180,f1*2.2),f1*pct*1.6180,0.2*pct+st.y/pct)\n        *abs(\n\t\t sin(\n            st.y*1.6180*st.y*\n            16.0*iTime*pct*\n            12.0+1.6180*\n            iTime*\n            pct)*\n            f1)*\n    \t\t(195.0508*f1*pct);\n\n    fragColor = vec4(vec3(1.5) - color, 1.0 );\n}", "image_inputs": [{"id": "Md2XRD", "previewfilepath": "https://soundcloud.com/mindbuffer/the-grid-remix-of-tron-legacy", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mindbuffer/the-grid-remix-of-tron-legacy", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSBWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 710]], "test": "untested"}
{"id": "ltSBzG", "name": "White Pass Route", "author": "dr2", "description": " Lots of trains on the Yukon line out of Skagway; note that trains travel in both directions\n on a single track without difficulty (mouse: horizontal position overrides automatic\n view selection).\n", "tags": ["tunnel", "smoke", "train", "bridge"], "likes": 9, "viewed": 643, "published": "Public API", "date": "1516210869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"White Pass Route\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEVCapsDf (vec3 p, vec4 u, float r);\nfloat PrCapsAnDf (vec3 p, float r, float w, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2s (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define MAX_CAR 8\n\nvec4 carStat[MAX_CAR], vTie;\nvec3 qHit, vnSmk, sunDir;\nfloat dstFar, tCur, trCyc, trMov, szFac, trkWid, trkRad, rlWid, rlHt, tunRad, tunUp, vuMode, tunWl,\n   trVel, trDir, idCyc;\nint idObj, nCar;\nconst float pi = 3.14159;\nconst int idRail = 1, idRbase = 2, idSlp = 3, idVia = 4, idTie = 5, idTun = 6, idGrnd = 7,\n   idEng = 11, idAxle = 12, idCar = 13, idWheel = 14, idCrod = 15, idFun = 16, idCpl = 17, idLamp = 18;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GroundDf (vec3 p, float r, float dMin)\n{\n  vec3 q;\n  float d, dt, s;\n  q = p;  q.y -= tunUp;\n  dt = length (vec2 (r - trkRad, q.y)) - tunRad;\n  q = p;\n  s = 0.5 * Fbm2s (0.75 * q.xz);\n  q.y -= -1.7 + 0.4 * q.z;\n  d = max (r - 1.6 * trkRad, max (q.y - 0.1 - s, - q.y - 0.1));\n  q = p;  q.yz -= vec2 (7., -0.7 * trkRad);\n  d = SmoothMin (d, PrCapsAnDf (q.xzy, 1.7 * trkRad + 0.5 * q.y - s, 0.1 + s, 4.), 3.);\n  if (vuMode <= 0.) d = max (d, - 0.5 * trkRad - q.z);\n  d = max (max (0.7 * d, - dt), q.y - 30.);\n  DMIN (idGrnd);\n  return dMin;\n}\n\nfloat EngDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, aw, sx, tw;\n  p /= szFac;\n  tw = trkWid / szFac;\n  wRad = 0.8;\n  q = p;\n  d = min (max (max (PrBoxDf (q - vec3 (0., 0., -1.75), vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (q - vec3 (0., 0., -1.95), vec3 (0.95, 1.3, 0.65))),\n     - PrBox2Df (q.yz - vec2 (0.7, -1.75), vec2 (0.5, 0.4))),\n     max (PrCylDf (q - vec3 (0., -2.4, -1.75), 4., 0.65), - (q.y - 1.35)));\n  d = min (d, max (PrCapsDf (q - vec3 (0., -0.2, 0.5), 1., 2.), - (q.z + 1.2)));\n  d = min (min (min (min (d, PrBoxDf (q - vec3 (0., -0.5, -3.15), vec3 (1., 0.7, 0.3))),\n     PrBoxDf (q - vec3 (0., -1.3, -0.25), vec3 (1., 0.1, 3.2))),\n     PrBoxDf (q - vec3 (0., -1.4, 3.), vec3 (1.1, 0.2, 0.07))),\n     PrCylDf (vec3 (abs (q.x) - 0.6, q.y + 1.4, q.z - 3.1), 0.2, 0.1));\n  DMINQ (idEng);\n  d = PrCylDf ((q - vec3 (0., -1.4, -3.5)).xzy, 0.4, 0.03);\n  DMIN (idCpl);\n  d = min (PrCylDf ((q - vec3 (0., 1.1, 2.1)).xzy, 0.3, 0.5),\n     PrCylDf ((q - vec3 (0., 1.5, 2.1)).xzy, 0.4, 0.15));\n  d = min (d, PrCapsDf ((q - vec3 (0., 0.8, 0.5)).xzy, 0.3, 0.2));\n  DMINQ (idFun);\n  d = PrCylDf (q - vec3 (0., -0.2, 3.5), 0.2, 0.2);\n  DMIN (idLamp);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.12, -1.4, 1.1);\n  d = min (max (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n  q = p;  q.x = abs (q.x);  q -= vec3 (tw - 0.17, -1.4, 1.1 * sign (q.z));\n  aw = - trkRad * trVel * tCur / (wRad * szFac);\n  q.yz = Rot2D (q.yz, aw);  \n  q.yz = Rot2D (q.yz, 2. * pi * floor ((atan (q.y, q.z) + pi) * 8. /\n     (2. * pi) + 0.5) / 8.);\n  q.z += 0.5 * wRad;\n  d = min (d, PrCylDf (q, 0.05, 0.5 * wRad));\n  DMIN (idWheel);\n  q = p;\n  sx = sign (q.x);\n  q.x = abs (q.x);  q -= vec3 (tw + 0.08, -1.4, 0.);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);  q -= vec3 (-0.1, 0., 1.1);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  DMIN (idCrod);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  DMIN (idAxle);\n  return dMin;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, tw;\n  wRad = 0.35;\n  p /= szFac;\n  tw = trkWid / szFac;\n  q = p;\n  d = min (min (PrBoxDf (q, vec3 (1.3, 1.4, 2.8)),\n     max (PrCylDf (q - vec3 (0., -2.35, 0.), 4., 2.8), - (q.y - 1.4))),\n     PrBoxDf (q - vec3 (0., -1.6, 0.), vec3 (0.8, 0.3, 2.)));\n  DMINQ (idCar);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 2.9);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  DMIN (idCpl);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.1, -1.85, 1.1);\n  d = min (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     PrCylDf (q.zyx, 0.15, 0.10));\n  q.x -= 0.1;\n  d = max (d, - PrCylDf (q.zyx, 0.2, 0.05));\n  DMIN (idWheel);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.85, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.15);\n  DMIN (idAxle);\n  return dMin;\n}\n\nfloat TrackDf (vec3 p, float r, float dMin)\n{\n  vec3 q;\n  float d, a;\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  q = p;  q.xz = Rot2D (q.xz, 2. * pi * (floor (128. * a + 0.5) / 128.));\n  q.y -= -5. - 0.6 * rlHt;\n  r -= trkRad;\n  d = max (max (abs (r) - 1.7 * trkWid, abs (q.y) - 5.),\n     - min (max (max (max (abs (r) - 1.7 * trkWid + 0.08, abs (q.y + 0.2) - 4.8),\n     - PrBox2Df (vec2 (abs (mod (q.y + 0.7, 1.) - 0.5), abs (q.z) - 0.5), vec2 (0.07))), abs (q.y + 0.2) - 5.),\n     max (PrBox2Df (vec2 (mod (q.y + 0.2, 1.) - 0.5, q.z), vec2 (0.43)), abs (q.y + 0.2) - 5.)));\n  DMIN (idVia);\n  d = PrEVCapsDf (abs (vec3 (r, mod (q.y + 0.2, 1.) - 0.5, q.z)), vTie, 0.015);\n  d = max (d, abs (q.y + 0.2) - 5.);\n  DMIN (idTie);\n  dMin = max (dMin, - p.y + 0.4 * p.z - 2.5);\n  q = p;  q.y -= tunUp;\n  d = max (abs (length (vec2 (r, q.y)) - tunRad) - 0.2 * trkWid, - (p.z - 0.3 * p.y - 2.));\n  DMIN (idTun);\n  q = p;  q.xz = Rot2D (q.xz, 2. * pi * (floor (128. * a + 0.5) / 128.));\n  q.xy -= vec2 (- trkRad, -0.2 * rlHt);\n  d = PrBoxDf (q, vec3 (1.3 * trkWid, 0.5 * rlHt, 0.3 * trkWid));\n  DMIN (idSlp);\n  q = vec3 (r, p.yz);  q.y -= -0.4 * rlHt;\n  d = PrBox2Df (q.xy, vec2 (1.5 * trkWid, 0.2 * rlHt));\n  DMIN (idRbase);\n  q = vec3 (abs (r) - trkWid, p.yz);  q.y -= 0.7 * rlHt;\n  d = PrRoundBox2Df (q.xy, vec2 (rlWid, rlHt), 0.8 * rlWid);\n  DMIN (idRail);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, r, d;\n  dMin = dstFar;\n  r = length (p.xz);\n  dMin = GroundDf (p, r, dMin);\n  dMin = TrackDf (p, r, dMin);\n  dMin /= szFac;\n  for (int k = 0; k < MAX_CAR; k ++) {\n    if (k == nCar) break;\n    q = p - carStat[k].xyz;\n    d = PrCylDf (q.xzy, 3.4 * szFac, 2.2 * szFac);\n    if (d < 0.2) {\n      q.xz = Rot2D (q.xz, carStat[k].w);\n      dMin = (k == 0) ? EngDf (q, dMin) : CarDf (q, dMin);\n    } else dMin = min (dMin, d);\n  }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y < 0.02 * Fbm1 (256. * atan (rd.z, rd.x) / pi))\n     col = vec3 (0.4, 0.4, 0.45) * (1. - 0.3 * Fbm2 (256. * vec2 (atan (rd.x, - rd.z), rd.y)));\n  else {\n    rd.y = abs (rd.y);\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.05, 0.1, 0.25) + 0.2 * pow (1. - rd.y, 8.) +\n       0.2 * pow (sd, 8.) + 0.4 * min (pow (sd, 256.), 0.3);\n    f = 2. * Fbm2 (0.05 * (ro + rd * (100. - ro.y) / rd.y).xz);\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  }\n  return col;\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn)\n{\n  vec4 objCol;\n  objCol = mix (vec4 (0.7, 0.72, 0.7, 0.05), vec4 (0.9, 0.9, 0.95, 0.1), smoothstep (0.4, 0.6, vn.y));\n  objCol *= (1. - 0.1 * Fbm2 (4. * ro.xz));\n  return objCol;\n}\n\nvec4 SceneCol (vec3 ro)\n{\n  vec4 objCol, carCol, carCol2;\n  float a, r, h;\n  r = length (ro.xz);\n  a = (r > 0.) ? atan (ro.z, - ro.x) / (2. * pi) : 0.;\n  if (idObj == idEng || idObj == idCar || idObj == idFun) {\n    h = Hashff (5. * idCyc + 17.1);\n    carCol = vec4 (HsvToRgb (vec3 (mod (h, 1.), 0.8, 0.9)), 0.2);\n    carCol2 = vec4 (HsvToRgb (vec3 (mod (h + 0.5, 1.), 0.8, 0.9)), 0.3);\n    if (idObj == idEng) {\n      objCol = (abs (qHit.y + 0.2) < 0.05 || qHit.y > 1.35) ? carCol2 : carCol;\n      if (qHit.y < -1.15) objCol *= 0.5;\n      if (abs (abs (qHit.x) - 0.5) < 0.4 && abs (qHit.y - 1.1) < 0.2) objCol *= 0.7;\n      else if (abs (abs (qHit.z - 1.) - 1.5) < 0.1 && qHit.y > -1.1) objCol *= 0.7;\n      if (qHit.z > 3.1 && qHit.y < -1.) objCol = carCol;\n      if (qHit.z < - 2.8 && qHit.y > 0.1) objCol = vec4 (vec3 (0.01), 0.);\n    } else if (idObj == idCar) {\n      objCol = (abs (qHit.y + 0.2) < 0.05 || qHit.y > 1.4) ? carCol2 : carCol;\n      if (qHit.y < -1.15) objCol *= 0.5;\n      if (abs (qHit.y - 0.6) < 0.6 && (abs (qHit.x) < 0.5 || abs (abs (qHit.z) - 1.2) < 1.1))\n         objCol *= 0.7;\n    } else if (idObj == idFun) {\n      objCol = (qHit.y > 1.35) ? carCol : carCol2;\n    }\n  } else if (idObj == idTun) {\n    if (tunWl == 0.) {\n      if (abs (r - trkRad) < 0.2 * trkWid && abs (mod (32. * a, 1.) - 0.125) < 0.04)\n         objCol = vec4 (0.8, 0.8, 0.4, -1.);\n      else if (length (vec2 (abs (ro.y - tunUp + 0.5 * tunRad),\n         2. * (mod (16. * a + 0.5, 1.) - 0.5))) < 0.02) objCol = vec4 (0., 0.3, 0., -1.);\n      else objCol = vec4 (0.2, 0.2, 0.22, 0.) * (0.7 + 0.3 * SmoothBump (0.02, 0.98, 0.005,\n         mod (128. * a, 1.)));\n    } else {\n      if (max (abs (r - trkRad), abs (ro.y - tunUp - tunRad)) < 0.1 * trkWid)\n         objCol = (trDir * ro.x > 0.) ? vec4 (0., 1., 0., -1.) : vec4 (1., 0., 0., -1.);\n      else objCol = mix (vec4 (0.4, 0.4, 0.44, 0.1), vec4 (0.8, 0.8, 0.85, 0.1),\n         step (2.05, ro.z - 0.3 * ro.y) * smoothstep (0., 0.1, ro.y - tunUp -\n         0.3 * tunRad * Fbm1 (8. * ro.z)));\n    }\n  } else if (idObj == idVia) {\n    objCol = vec4 (0.7, 0.6, 0.4, 0.1);\n    if (ro.y > -0.03) objCol.rgb *= 1. - 0.2 * smoothstep (0.4, 0.6, Fbm2 (128. * vec2 (a, r)));\n  } else if (idObj == idTie) objCol = vec4 (0.4, 0.4, 0.45, 0.1);\n  else if (idObj == idRail) objCol = vec4 (0.7, 0.7, 0.75, 0.5);\n  else if (idObj == idRbase) objCol = vec4 (0.5, 0.4, 0.3, 0.) *\n     (1. - 0.07 * floor (8. * Noisefv2 (64. * ro.xz)));\n  else if (idObj == idSlp) objCol = vec4 (0.5, 0.3, 0.1, 0.) * (1. -\n     0.7 * step (abs (abs (r - trkRad) - trkWid), 2.5 * rlWid) *\n     step (abs (mod (256. * a + 0.5, 1.) - 0.5), 0.03));\n  else if (idObj == idAxle) objCol = vec4 (0.4, 0.4, 0.5, 0.3);\n  else if (idObj == idWheel) objCol = vec4 (0.5, 0.5, 0.6, 0.3);\n  else if (idObj == idCrod) objCol = vec4 (0.7, 0.7, 0.1, 0.3);\n  else if (idObj == idLamp) objCol = (mod (tCur, 2.) < 1.) ? vec4 (1., 1., 0.7, -1.) :\n     vec4 (0.8, 0.8, 0.4, -1.);\n  return objCol;\n}\n\nvec2 TrackPath (float t)\n{\n  return trkRad * vec2 (sin (t), - cos (t));\n}\n\nfloat SmkBallHit (vec3 ro, vec3 rd)\n{\n  vec3 p, u;\n  float b, d, w, dMin, rad, a, da, nb;\n  dMin = dstFar;\n  const float nsBall = 300., nsShow = 20.;\n  da = 0.075 * pi - trDir * (trMov - 0.068 * pi);\n  nb = 0.;\n  for (float n = 0.; n < nsBall; n ++) {\n    a = 2. * pi * n / nsBall + pi;\n    if (mod (a + da, 2. * pi) < 0.15 * pi) {\n      if (abs (mod (a, 2. * pi) - pi) > 0.45 * pi) {\n        p.xz = TrackPath (a);\n        p.y = 1.04;\n        u = ro - p.xyz;\n        rad = 0.09 - (0.085 / nsShow) * ((trDir > 0.) ? nsShow - 1. - nb: nb);\n        if (rad > 0.) {\n          b = dot (rd, u);\n          w = b * b - dot (u, u) + rad * rad;\n          if (w >= 0.) {\n            d = - b - sqrt (w);\n            if (d > 0. && d < dMin) {\n              dMin = d;\n              vnSmk = (u + d * rd) / rad;\n            }\n          }\n        } else break;\n      }\n      ++ nb;\n    }\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, vn, ltVec;\n  vec2 rq;\n  float dstObj, dstSmk, d, reflFac, f;\n  dstSmk = SmkBallHit (ro, rd);\n  if (dstSmk < dstFar) vnSmk = VaryNf (32. * (ro + dstSmk * rd), vnSmk, 2.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    tunWl = (idObj == idTun) ? step (tunRad - 0.1 * trkWid,\n       length (vec2 (length (ro.xz) - trkRad, ro.y - tunUp))) : 0.;\n    if (idObj == idGrnd) objCol = GrndCol (ro, vn);\n    else objCol = SceneCol (ro);\n    if (idObj == idGrnd) vn = VaryNf (vec3 (4., 2., 4.) * ro, vn, 1.);\n    else if (idObj == idRbase || idObj == idSlp || idObj == idVia) vn = VaryNf (64. * ro, vn, 1.);\n    else if (idObj == idTun) vn = VaryNf (16. * ro, vn, 2.);\n    col = objCol.rgb;\n    if (objCol.a >= 0.) {\n      if (ro.z - 0.3 * ro.y > 2.2 && tunWl == 0. && idObj != idGrnd && idObj != idVia) {\n        if (idObj == idEng || idObj == idCar) {\n          col *= 0.2 + (0.07 + 0.13 * max (vn.y, 0.)) * (1. - smoothstep (4., 6., dstObj));\n          if (idObj == idEng && qHit.y > -1. && vn.y > 0.2 || idObj == idCar && qHit.y > -1.) {\n            rq = ro.xz + (tunRad - 0.1 * trkWid - ro.y) * reflect (rd, vn).xz;\n            if (abs (length (rq) - trkRad) < 0.2 * trkWid && abs (mod (32. *\n               atan (rq.y, rq.x) / (2. * pi), 1.) - 0.125) < 0.04) col = mix (col, vec3 (0.8, 0.8, 0.4), 0.2);\n          }\n        } else {\n          if (idObj != idTun) col *= 0.4 + 0.3 * max (vn.y, 0.);\n          ltVec = vec3 (TrackPath (trDir * (trMov + 12. * szFac / trkRad)), 0.5 * szFac).xzy - ro;\n          f = length (ltVec);\n          col *= 0.3 + (0.7 + 0.5 * max (dot (vn, ltVec), 0.) / f) / (1. + 0.8 * pow (f, 1.5));\n        }\n      } else {\n        col = col * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n           objCol.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n        if (abs (length (ro.xz) - trkRad) < 1.2 * trkWid && (idObj == idRbase || idObj == idSlp ||\n           idObj == idRail)) {\n          for (int k = 0; k < MAX_CAR; k ++) {\n            if (k == nCar) break;\n            if ((pi - abs (mod (atan (- ro.x, ro.z) + pi - trDir * (trMov - (float (k) * 6.4 +\n               ((k > 0) ? 0.3 : 0.)) * szFac / trkRad), 2. * pi) - pi)) * trkRad < 0.615) {\n              col *= 0.7;\n              break;\n            }\n          }\n        }\n        reflFac = 0.;\n        if (idObj == idEng && abs (abs (qHit.x) - 0.5) < 0.37 && abs (qHit.y - 1.1) < 0.17 ||\n           idObj == idCar && (abs (qHit.y - 0.6) < 0.55 && (abs (qHit.x) < 0.45 ||\n           abs (abs (qHit.z) - 1.2) < 1.))) reflFac = 0.8;\n        else if (idObj == idEng || idObj == idFun || idObj == idCar || idObj == idRail) reflFac = 0.1;\n        if (reflFac > 0.) col = mix (col, 0.7 * BgCol (ro, reflect (rd, vn)), reflFac);\n        if (idObj == idGrnd) col +=\n          256. * pow (clamp (0.5 + 0.5 * dot (sunDir, reflect (rd, vn)), 0., 1.), 16.) *\n           pow (1. - 0.6 * abs (dot (normalize (sunDir - rd), VaryNf (1024. * ro, vn, 2.))), 8.);\n      }\n    }\n  } else col = BgCol (ro, rd);\n  if (dstSmk < min (dstObj, dstFar))  col = mix (col, vec3 (0.8, 0.8, 0.75) *\n     (0.5 + 0.5 * max (dot (vnSmk, sunDir), 0.)), 0.85);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, vd;\n  vec2 mMid[4], ut[4], mSize, canvas, uv, p1, p2, ori, ca, sa;\n  float el, az, zmFac, t1, t2, r, vuCorn, tCyc;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = 0.;\n  az = 0.;\n  mSize = 0.2 * vec2 (canvas.x / canvas.y, 1.);\n  mMid[0] = (1. / mSize.y - 1.) * mSize;\n  mMid[1] = mMid[0] * vec2 (1., -1.);\n  mMid[2] = mMid[0] * vec2 (-1., -1.);\n  mMid[3] = mMid[0] * vec2 (-1., 1.);\n  for (int k = 0; k < 4; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  vuCorn = 0.;\n  for (int k = 0; k < 4; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuCorn = float (k + 1);\n      break;\n    }\n  }\n  dstFar = 100.;\n  szFac = 0.22;\n  trkRad = 20.;\n  trkWid = 0.31;\n  tunRad = 2.3 * trkWid;\n  tunUp = 1.7 * trkWid;\n  rlWid = 0.012;\n  rlHt = 0.025;\n  vTie.xyz = vec3 (1.6 * trkWid, 0.5, 0.5);\n  vTie = vec4 (normalize (vTie.xyz), length (vTie.xyz));\n  trVel = 0.25;\n  tCyc = 2. * pi / trVel;\n  tCur += 0.5 * tCyc;\n  vuMode = mod (vuCorn + floor (5. * mod (0.8 * tCur / tCyc, 1.)), 5.);\n  tCur += floor (900. * floor (dateCur.w / 900.) / tCyc) * tCyc;\n  if (mPtr.z > 0.) vuMode = mod (vuCorn + floor (5. * clamp (mPtr.x + 0.5, 0., 0.99)), 5.);\n  idCyc = floor (tCur / tCyc);\n  trDir = 2. * floor (2. * Hashff (99. * idCyc + 1.1)) - 1.;\n  trMov = trVel * mod (tCur, tCyc) + pi;\n  nCar = 3 + int (float (MAX_CAR - 3) * Hashff (17. * idCyc + 1.1));\n  for (int k = 0; k < MAX_CAR; k ++) {\n    if (k == nCar) break;\n    p1 = TrackPath (trDir * (trMov - ((float (k) * 6.4 + ((k > 0) ? 0.3 : 0.)) - 1.1) * szFac / trkRad));\n    p2 = TrackPath (trDir * (trMov - ((float (k) * 6.4 + ((k > 0) ? 0.3 : 0.)) + 1.1) * szFac / trkRad));\n    carStat[k].xz = 0.5 * (p1 + p2);\n    carStat[k].y = 2.7 * rlHt + 2.15 * szFac;\n    p1 -= p2;\n    carStat[k].w = atan (p1.x, p1.y);\n  }\n  if (vuMode == 0.) {\n    el += 0.05 * pi;\n    zmFac = 4.2;\n  } else if (vuMode == 1. || vuMode == 2. || vuMode == 3.) {\n     if (vuMode == 1.) {\n      t1 = trMov + 2.5 * szFac / trkRad;\n      t2 = t1 + 6.4 * szFac / trkRad;\n    } else if (vuMode == 2.) {\n      t1 = trMov + 16. * szFac / trkRad;\n      t2 = t1 - 8.3 * szFac / trkRad;\n    } else if (vuMode == 3.) {\n      t1 = trMov - (float (nCar - 1) + 3.) * 6.4 * szFac / trkRad;\n      t2 = t1 + 8.3 * szFac / trkRad;\n    }\n    r = 1.;\n    if (vuMode == 2. || vuMode == 3.) r += (1. + 0.6 * sin (0.15 * pi * tCur)) * trkWid / trkRad;\n    ro.xz = r * TrackPath (trDir * t1);\n    ro.y = 0.8;\n    el += 0.02 * pi;\n    vd.xz = TrackPath (trDir * t2) - ro.xz;\n    az -= atan (vd.x, vd.z);\n    zmFac = 3.5;\n  }\n  if (vuMode == 4.) {\n    ro = vec3 (0., 2., -30.);\n    vd = carStat[2].xyz - ro;\n    r = length (vd);\n    vd = normalize (vd);\n    vd.xz = Rot2D (vd.xz, az);\n    vd.yz = Rot2D (vd.yz, el);\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n       vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n    zmFac = 1. + 0.2 * min (r, 30.);\n  } else {\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., sa.y, 0., 1., 0., - sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, sa.x, 0., - sa.x, ca.x);\n    if (vuMode == 0.) ro = vuMat * vec3 (0., 0., -60.);\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (1., 3., -1.));\n  col = ShowScene (ro, rd);\n  for (int k = 0; k < 4; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n       col = vec3 (0.8, 0.8, 0.1);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrCapsAnDf (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z) - h;\n  return max (length (vec3 (p.xy, max (0., p.z - w))) - r,\n     - length (vec3 (p.xy, max (0., p.z + w))) + r) - w;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2s (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.75);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSBzG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1341, 1387, 1387, 1886], [1888, 1888, 1922, 1922, 4043], [4045, 4045, 4079, 4079, 4891], [4893, 4893, 4938, 4938, 6272], [6274, 6274, 6296, 6296, 6778], [6780, 6780, 6813, 6813, 7024], [7026, 7026, 7047, 7047, 7247], [7249, 7249, 7280, 7280, 7808], [7810, 7810, 7843, 7843, 8024], [8026, 8026, 8051, 8051, 11013], [11015, 11015, 11041, 11041, 11088], [11090, 11090, 11127, 11127, 11981], [11983, 11983, 12018, 12018, 15246], [15248, 15248, 15304, 15304, 19016], [19018, 19018, 19050, 19050, 19150], [19152, 19152, 19198, 19198, 19245], [19247, 19247, 19280, 19280, 19369], [19371, 19371, 19418, 19418, 19465], [19467, 19467, 19509, 19509, 19560], [19562, 19562, 19605, 19605, 19669], [19671, 19671, 19715, 19715, 19784], [19786, 19786, 19840, 19840, 19981], [19983, 19983, 20028, 20028, 20131], [20133, 20133, 20190, 20190, 20273], [20275, 20275, 20305, 20305, 20363], [20365, 20365, 20389, 20389, 20525], [20559, 20559, 20583, 20583, 20620], [20622, 20622, 20646, 20646, 20699], [20701, 20701, 20725, 20725, 20855], [20857, 20857, 20882, 20882, 21028], [21030, 21030, 21055, 21055, 21241], [21243, 21243, 21265, 21265, 21419], [21421, 21421, 21443, 21443, 21596], [21598, 21598, 21619, 21619, 21774], [21776, 21776, 21805, 21805, 22017], [22019, 22019, 22058, 22058, 22242]], "test": "untested"}
{"id": "ltSBzw", "name": "2/2018", "author": "rimina", "description": "My first attend on some fog kind of volumetric kind of thingie. I will get back to this later for sure.\n\nAlso my second shader of the year 2018 and part of my daily shader challenge! ", "tags": ["fog", "density", "dailyshader"], "likes": 18, "viewed": 524, "published": "Public", "date": "1515001910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 12\n//Noise functions from IQ and other sources that I don't exactly remember. However, not my own work.\nfloat noise3D(vec3 p){\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p){\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*simplex3D( p ); p = p*2.01;\n    f += 0.25000*simplex3D( p ); p = p*2.02; //from iq\n    f += 0.12500*simplex3D( p ); p = p*2.03;\n    f += 0.06250*simplex3D( p ); p = p*2.04;\n    f += 0.03125*simplex3D( p );\n\treturn f;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t = 0.0;\n    \n    vec3 p = ro+rd;\n    \n    for(int i = 0; i < STEPS; ++i){\n        float d = fbm(p)*0.08;\n        t += d;\n        p += rd*d;\n        \n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    q = -1.0+q*2.0;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, iTime*0.05);\n\tvec3 target = vec3(0.0, 0.0, -1.0);\n\n\tvec3 cw = normalize(target-ro);//z\n\tvec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );//x\n\tvec3 cv = normalize( cross(cu,cw) );//y\n\tvec3 rd = normalize(mat3( cu, cv, cw )*vec3(q.xy, 1.5));\n\n    float density = trace(ro, rd);\n    \n    vec3 col = vec3(0.8, 0.6, 0.8)+vec3(density);\n    \n    col = pow(col, 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSBzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 118, 140, 140, 221], [223, 223, 247, 247, 2372], [2374, 2374, 2393, 2393, 2639], [2641, 2641, 2671, 2671, 2863], [2865, 2865, 2922, 2922, 3468]], "test": "untested"}
{"id": "ltSfRy", "name": "antialiasing", "author": "wenwen14", "description": "antialiasing", "tags": ["antialiasing"], "likes": 4, "viewed": 156, "published": "Public", "date": "1516568080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Photorealistic rendering course - Step 06\n// By Alan \"Latex\" Savary.\n//\n// Next step: \"[Step07a] Antialiasing with grid\"\n\n//##############################################################################################\n\n// - The aim is to render a 3D sphere seen by a 3D camera with Phong illumination shading.\n// - The sphere is defined by its 3D position and its radius.\n// - The camera is defined by its 3D position, the fact that it looks towards a 3D point target,\n//   has its up vector as upward as possible, and its field of view defined by a vertical angle.\n// \n// The different space coordinates:\n//\n//                +----------------+\n//                |                |\n//                |     screen     |\n//              Y                 |\n//                |                |\n//                +->--------------+\n//                   X\n//                    \n//\n//                                +-----------------+\n//                               .|                .|\n//                               .|        +      . |\n//                               .|       .     .   |\n//                               .+------.-----.----+\n//                               ..     .    .     .\n//                               ..    .   .    .\n//                               ..   .  .    .\n//                               .   .  .    .\n//                               .  . .  .\n//                               cz.. .\n//                               ./.\n//                               /\n//                      camera  +---> cx      \n//                              |\n//                              |\n//                              v cy\n//\n//            \n//                 Y\n//                  \n//                  |       world\n//                  +--> X  \n//                 /  \n//              Z /   \n//        \n\n//##############################################################################################\n\n// In GLSL, IEEE 754 infinity can conveniently be achieved by dividing by zero:\nconst float FLT_MAX = 1.0 / 0.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\n      vec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\n      vec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\n      vec3     lightPos     = vec3(8, 10, -12);\n\n//##############################################################################################\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    // Explanation:\n    //\n    //  Any point P(t) on the ray respect the following equation:\n    //\n    //         P(t) = rayPos + t * rayDir                            (1)\n    //\n    //  Any point on the sphere must be at sphereRadius distance from the sphere center.\n    //  Which, for a point P of space, yields to follow equation:\n    //\n    //                 distance(P - spherePos)   = sphereRadius\n    //     <=>         distance(P - spherePos)^2 = sphereRadius^2\n    //     <=> dot(P - spherePos, P - spherePos) = sphereRadius^2    (2)\n    //\n    // The intersection point(s) of the ray with the sphere must respect both equations.\n    // So, we can replace P of equation (2) with (1) to express both constraints into a\n    // single equation:\n    //\n    //      dot(rayPos+t*rayDir - spherePos, rayPos+t*rayDir - spherePos) = sphereRadius^2\n    //  <=> dot(t*rayDir + rayPos-spherePos, t*rayDir + rayPos-spherePos) = sphereRadius^2\n    //  <=> dot(t * rayDir + diff, t * rayDir + diff)                     = sphereRadius^2\n    //        ; with diff = rayPos - spherePos\n    //\n    // As we can 'distribute' additive component over a dot product, we have:\n    //\n    //      dot(t*rayDir, t*rayDir) + 2*dot(diff,t*rayDir) + dot(diff, diff) = sphereRadius^2\n    //  <=> t^2*dot(rayDir, rayDir) + t*2*dot(diff,rayDir) + dot(diff, diff) = sphereRadius^2\n    //  <=> t^2*dot(rayDir, rayDir) + t*2*dot(diff,rayDir) + dot(diff, diff)-sphereRadius^2 = 0\n    //  <=> a*t^2 + b*t + c = 0\n    //        ; with:\n    //                a =   dot(rayDir, rayDir)\n    //                b = 2*dot(diff  , rayDir)\n    //                c =   dot(diff  , diff  ) - sphereRadius^2\n    //\n    // This is a 2nd degree (quadratic) equation to solve.\n    //\n    // If discriminant di (= b^2 - 4*a*c) is negative, the ray doesn't intersect the sphere.\n    // Otherwise there are up to two solutions (t1 and t2).\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n        \n        // We can notice that 'a' (so 'den') and sdi are positive.\n        // So, we know for sure that t1 <= t2 whatever the configuration.\n\n        // We can also list all the possibilities of intersection or non-intersection:\n        //\n        //    t1...t2.....r------------>\t(t1<0 & t2<0)\t\t\tno intersection\n        //       t1t2.....r------------>\t(t1<0 & t2<0 & t1=t2)\tno intersection\n        //    t1........t2r------------>\t(t1<0 & t2=0)\t\t\tassume no intersection\n        //            t1t2r------------>\t(t1=t2=0)\t\t\t\tassume no intersection\n        //    t1..........r--------t2-->\t(t1<0 & t2>0)\t\t\tintersection at (t2, -n)\n        //              t1r--------t2-->\t(t1=0 & t2>0)\t\t\tintersection at (t2, -n)\n        //                r---t1---t2-->\t(t1>0 & t2>t1)\t\t\tintersection at (t1,  n)\n        //                r---t1t2----->\t(t1>0 & t2=t1)\t\t\tintersection at (t1,  n)\n        \n        // This can be summed up by:\n\t\t//        \n        // If t1 >  0, then the sphere is ahead of the ray, and the point we see is the\n        //             one associated to t1 with a normal pointing outward the sphere.\n        //             \n        // If t1 <= 0 and t2 >  0, then the ray starts inside the sphere, and the point we see\n        //                         is the one associated to t2 with a normal point inward the\n        //                         sphere.\n        //                         \n        // Otherwise, there is no intersection or we assume there is none.\n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        \n        // As we found the value of t, we can insert it into equation (1) to find\n        // the position of the first intersection point encountered along the ray.\n        intersecPt = rayPos + t * rayDir;\n\n        // Then, we can use the property of a sphere that the infinite line along the\n        // normal vector to a point on the sphere is passing through the center of the\n        // sphere.\n        // Then, we need to reverse the vector direction if the intersection point is\n        // seen from inside the sphere.\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    // Explanation:\n    //\n    //  Any point P(t) on the ray respect the following equation:\n    //\n    //         P(t) = rayPos + t * rayDir                            (1)\n    //\n    //  The analytic equation of a plane is of the form: a * x + b * y + c * z + d = 0\n    //  That can be rewritten with a dot-product:              (a,b,c).(x,y,z) + d = 0\n    //  With (a,b,c) being the normal N to the plane which defines the orientation of the plane,\n    //  with (x,y,z) being any 3D point of space, and 'd' defining at which position the plane\n    //  is located.\n    //\n    //  NOTE: Without loss of generality (a,b,c) can be normalized and d scaled accordingly.\n    //        So, the normal is assumed here to be a unit-vector!!!\n    //\n    //  So, we have:    dot(planeNormal, P) + d = 0   for any 3D point P on the plane\n    //\n    //  We can find d because we know our plane pass through planePos point.\n    //  This means planePos also follow the above equation:\n    //      \n    //          dot(planeNormal, planePos) + d = 0\n    //      <=> d = -dot(planeNormal, planePos)\n    //\n    //  So, we now know the complete equation of the plane:\n    //\n    //          dot(planeNormal, P) + (-dot(planeNormal, planePos)) = 0\n    //      <=> dot(planeNormal, P) - dot(planeNormal, planePos) = 0\n    //      <=> dot(planeNormal, P - planePos) = 0                   (2)\n    //\n    // The intersection point(s) of the ray with the plane must respect both equations.\n    // So, we can replace P of equation (2) with (1) to express both constraints into a\n    // single equation:\n    //\n    //      dot(planeNormal, (rayPos + t * rayDir) - planePos) = 0\n    //  <=> dot(planeNormal, t * rayDir + (rayPos - planePos)) = 0\n    //\n    // As we can 'distribute' additive component over a dot product, we have:\n    //\n    //      dot(planeNormal, t * rayDir) + dot(planeNormal, (rayPos - planePos)) = 0\n    //  <=> t * dot(planeNormal, rayDir) + dot(planeNormal, rayPos - planePos) = 0\n    //  <=> t * dot(planeNormal, rayDir) = -dot(planeNormal, rayPos - planePos)\n    //  <=> t * dot(planeNormal, rayDir) =  dot(planeNormal, planePos - rayPos)\n    //\n    // We can find t if 'den = dot(planeNormal, rayDir)' is not zero.\n    // In the case it is zero, it means the ray is parallel to the plane, and there will be\n    // no interesction (or an infinity if the rayPos is on the plane. In that case, we choose\n    // to assume that we have no intersection at all).\n    //\n    // So, here after in this explanation, we assume 'den' is non zero.\n    //\n    // We can then find the value of 't' at which the intersection occurs:\n    //\n    //    t = dot(planeNormal, planePos - rayPos) / dot(planeNormal, rayDir)\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n    // As we found the value of t, we can insert it into equation (1) to find\n    // the position of the first intersection point encountered along the ray.\n    intersecPt = rayPos + t * rayDir;\n    \n    // NOTE: The normal to be returned has to be pointing 'towards' the rayPos position.\n    //       So, the angle between the ray direction and the normal must > 90, so the\n    //       dot-product should be negative.\n    //       This can be expressed by taking the 'sign' of den\n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    // Compute camera focal length for a height on image plane going in [-1,1] range\n    //\n    //        \n    //                     -1\n    //                  /|  \n    //                 / |\n    //                /  |\n    //               /   |\n    //              /). .|. . . . . . fovY (vertical angle field of view expressed in degrees)\n    //             /  )  |\n    //            +---)--|-----> cz\n    //            |\\  )  |           \n    //            | \\)   |           |\n    //            v  \\   |           |\n    //           cy   \\  |           | h\n    //                 \\ |           |\n    //                  \\|           |\n    //                     1         v\n    //                         \n    //            <------>\n    //              focal length\n    //\n    //    We have that:\n    //\n    //        tan((2*Pi/180)*cameraFovY/2) = h / focal\n    //    <=> focal = h / tan(radians(cameraFovY/2))\n    //    <=> focal = 1 / tan(radians(cameraFovY/2))\n                 \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    // Compute camera three main axis (X,Y,Z) expressed in world space\n    //\n    //  NOTES: - First, we compute the Z camera unit vector that goes from the camera position\n    //           and look toward the camera target.\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    //         - Then, we use the fact that the cross-product of two vectors (even if not\n    //           perpendicular) gives a third vector that is perpendicular to the two others.\n    //           Plus, the direction given by the result is given by applying the 'right-hand'\n    //           technique by pointing the thumb along the first vector, the index finger along\n    //           the second vector, and the result will be given by the middle finger.\n    //           NOTE: the length of the resulting vector needs to be normalized if the two\n    //                 input vectors aren't perpendicular AND of unit length.\n    //         - To compute the cx vector, we can assume, temporarily, that the cy vector is the\n    //           perfect '-up' vector.\n    //           This is possible because cy must be as near as '-up' and the true cy vector\n    //           will be in the same plane than the plane defined by the cz & the 'up' vectors.\n    //         - So, as: cx = cross-product(cy, cz)\n    //                      = normalized(cross-product(-up, cz))\n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n    //         - Finally, we can find the true cy by applying: cy = cross-product(cz, cx)\n\n    vec3 cy = normalize(cross( cz, cx));\n\n    // Here we apply a set of transformations to transform the coordinates range:\n    //\n    //     pixCoord.xy                  is in range [0..  iResolution.x] x [0..  iResolution.y]\n    //\n    //  2.*pixCoord.xy                  is in range [0..2*iResolution.x] x [0..2*iResolution.y]\n    //\n    //  2.*pixCoord.xy - iResolution.xy is in range\n    //                        [-iResolution.x..iResolution.x] x [-iResolution.y..iResolution.y]\n    //\n    //  pt = (2.*pixCoord.xy - iResolution.xy) / iResolution.y is in range\n    //                         [-ratio,ratio] x [-1, 1] \n    //            with ratio = iResolution.x / iResolution.y;\n    //\n    // Here the scaled applied is uniform because we divide horizontal & vertical coordinates\n    // by the same value: iResolution.y\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n\t// We can now find the ray properties:\n    //   - The ray start position is the camera position\n    //   - The ray direction can be decomposed into 3 sub-vectors:\n    //      *            dy = (-pt.y) * cy   because pt vertical axis is going in opposite\n    //                                       direction than cy, and pt.y is in range [-1,1],\n    //                                       which matches the range spanned by vertical\n    //                                       positions (in camera space) on the image plane\n    //                                       located at the focal length distance along cz.\n    //\n    //      * similarly: dx =    pt.x * cx   NOTE: pt.x and horizontal positions (in camera\n    //                                             space) shares the same range (taking into\n    //                                             account the image ratio. Said differently,\n    //                                             image & camera have the same ratio).\n    //      * and:       dz =   focal * cz\n    //\n    //     which brings that: rayDir = pt.x * cx - pt.y * cy + focal * cz\n    //\n    //   - Finally, the ray direction is normalized because it makes it more practical later on.\n\n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    // As the plane is textured with a checkboard pattern, we need to define\n    // a 'texture coordinate frame'.\n    //\n    // NOTE: As this is pixel independent it could be calculated once and\n    //       defined by 'const' global value at the top of this source code.\n\t//    \n    // For that, we need first to compute the two X & Y axis of the plane that will serve with\n    // the plane position as defining fully this texture coordinate frame.\n    //\n    // We assume the plane normal is the plane Z-axis.\n    //\n    // We want to find what will be the plane X-axis if this axis is as near as possible to the\n    // world X axis.\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    // To find if a point receive light from a light source, we need to send a ray starting\n    // from the point on the surface and going into the direction of the light source.\n    // \n  \t// If there is an intersection with an object in between the two points, then it means\n    // the surface point does not receive light directly from the light source.\n    //\n    // It is in shadow.\n    //\n\n\t// The 'shadow' ray must not be started exactly from the surface, otherwise a simple\n    // numrical error (because of the lack of precision of number in computer), plus the\n    // fact that we will try to find intersection with all objects, including the object\n    // from which the surface point is (because for a non-convex object, the object could\n    // cast shadow onto itself), could result in finding an intersection right at the start\n    // of the ray because the start of the ray would appear wrongly as starting from below\n    // the surface of that object.\n    // As this error would not be the same everywhere, it would create a very noisy image.\n    //\n    // If you want to see what would happen, just replace the line below by:\n    //      vec3  shadowRayStart = I;\n    \n    vec3  shadowRayStart = I + 0.0001 * N;\t// Move the surface point a little outward\n    \t\t\t\t\t\t\t\t\t\t// (along its normal) to ensure it is a bit\n    \t\t\t\t\t\t\t\t\t\t// above the surface.\n\n\t// the direction of the ray is just the unit-vector going\n    // from the surface point towards the light source\n    vec3  shadowRayDir   = L;\n    \n    // Now, test all geometry for intersection with the 'shadow' ray\n    //\n    // NOTE: We could optimize a bit the code because here we are not interested in finding\n    //       which object is intersecting.\n    //       We only want to know if there is at least one object along the path, plus if\n    //       the nearest intersection (from the surface point of view) is in-between the\n    //       surface and the light source, because if it is 'after' the source, then the\n    //       surface point is being lit by the light source.\n    int   unusedInt;\n    vec3  unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                 unusedInt, unusedVec1, unusedVec2);\n    \n    // Check if there is at least an intersection and if it is in-between the surface point\n    // and the light source.\n    //\n    // If there is not intersection in-between, then the shadow factor is 1, meaning that\n    // the light source is contributing fully.\n    // Otherwise, instead of returning a zero contribution, we decide to say that the light\n    // source contributes as much as the ambiant light.\n    // It allows to have shadows that are not totally black.\n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,\n                         float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n    // Phong shading is simplification of the 'Rendering equation' of Kajiya.\n    //\n    // It consists:\n    //  - in removing all diffuse inter-reflections and to replace them by one ambiant component\n    //  - in assuming the BRDF of material is the addition of a purely diffuse (mat, lambertian)\n    //    surface, plus a perfectly specular (mirror-like) component.\n    \n    // NOTES:\n    //  - The diffuse color is a mix of the light color and the object color.\n    //    It is logical as a light source has a spectrum that is absorbed by the object surface.\n    //    It is, then, the resulting spectrum that is diffused in all direction.\n    //\n    //    For example, a red light shining on a 'blue' (under white light) object would appear\n    //    black, because a 'blue' object is blue because it absorbs all wavelength except the\n    //    blue one that ends up diffusely reflected off the surface towards the observer.\n    //    Hence, the red spectrum part of the light would be absorbed by the object, leaving\n    //    nothing to be reflected.\n    //\n    //    So, we would thing the diffuse shading equation would be something like:\n    //            factor * max(lightCol - (1-objectCol), 0)\n    //               ; where 1-objectCol represents the color absorbed by th object.\n    //                 and max(lightCol - (1-objectCol), 0) would then represents the\n    //                 color remaining after absorbption.\n    //    But that is not what Phong shading is!\n    //\n    //  - The diffuse ammount depends first on the properties of the object to be 'mat', and\n    //    it's controlled with object Kd parameter.\n    //\n    //    It also depends on how 'frontward' the object surface is to the light.\n    //    The more 'frontward' we are, the more light the surface receive, and will then diffuse\n    //    in every direction of the hemisphere at the surface point.\n    //    This is expressed by the cosinus of the angle between the normal and the light vector,\n    //    which is expressed by the dot-product between those two vectors.\n    //\n    //    When the angle is >= 90 the light doesn't shine anymore on the point, so the\n    //    contribution of this light is zero!\n    //    To take that into account, and avoid negative value of the cosinus, we need to clamp\n    //    its value in [0,1] range. This is done by taking the max between 0 and the cosinus.\n\t//\n    //  - The ambiantCol parameter is the most 'unrealistic' parameter because if not set\n    //    properly, you can obtain a color that is totaly irrelevant of the light sources\n    //    and the surrounding diffuse objects, and more importantly the object's color itself!\n    //    Logically, the ambiant should behave like a diffuse lighting, and should be a mix\n    //    of the ambiant color and the object color.\n    //    But that is not what Phong shading is!\n    //\n    //    A good use is to set Ka to be a small value, and to set the ambiant color to a\n    //    color that is mainly the color of the light and a bit of the overall color of the\n    //    entire scene.\n    //\n    //    An improvment would be to replace the Ka and ambiantCol by a single ambiant component\n    //    associated to each object.\n    //    It would enable to emulate the reddish aspect of an object near a red wall.\n    //    Plus, the color would be blended with the object color.\n    //    We could even add a directional & distance aspect to better emulate inter-reflections.\n    //    But that would not be Phong shading anymore! :-)\n    //\n    //  - The specular works quite like the diffuse but the resulting color depends only on the\n    //    light color because specularity comes from light that did not interact much with the\n    //    micro-geometry of the object surface, hence the reflected color does not depend on the\n    //    object color.\n    //\n    //  - The specular component in Phong shading is a cheat!\n    //    As the light source is a point, the perfectly specular reflection would produce a\n    //    single dot (if not nothing because of aliasing).\n    //\n    //    To give the illusion of a light that has a size, Phong applies a kind of diffuse\n    //    principle that relate the reflection direction (from the light that bounces off the\n    //    object surface) and the observer viewing direction.\n    //    The nearer those vectors are (the smaller the angle in-between) the more reflected\n    //    light the observer is receiving.\n\t//\n    //    To control how big the light spot appears (the pseudo light-size is), a power is\n    //    applied on the cosinus of the angle (like the diffuse, it must remain in [0,1] range).\n    //    The higher the value, the smaller the spot will appears.\n    //\n    //  - The shadow factor is to be applied to the diffuse AND specular components because both\n    //    depend proportionnaly on lightCol, whereas the ambiant component describes an\n    //    'overall' distribution of the light in the whole scene.\n    //\n    //  - As the shadow factor is set to be 1.0 when under light visibility, but more than zero\n    //    when under shadow (so that to let object texture to appear under 'diffuse inter-reflection'\n    //    lighting), we need to make sure that there is no specular in such case.\n    //    That is the purpose of shadowFactorSpec.\n    \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lightCol *     max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *              lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid AnimateScene(float time)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    // NOTE: at time=0, the sphere position is the same than the default one defined at\n    \t//       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n    \n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time=0.\n    lightPos += vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    \n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time=0.\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n//##############################################################################################\n//##############################################################################################\nstruct shadeInfo\n{\n\tvec3 shadedCol;\n    float Ks;\n};\n\nvec3 RaycastAtPixelCoord(vec2 pixCoord)\n{\n\t// Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    shadeInfo infos[5];\n    int nbBounces=0;\n    \n    do{\n\t\t// Test ray-objetcs intersections and find the nearest one\n   \t \t// (with its associated intersection point and normal at the object surface)\n    \tint  objectId;\n    \tvec3 intersecI, normalI;\n    \tfloat distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    \tif (distI <= 0.0)\n        {\n         \tinfos[nbBounces].shadedCol=skyCol;\n            infos[nbBounces].Ks=0.0;\n        }\n        \n       // Apply the shading to the points that are on the sphere surface and seen by the camera\n        // unit-vector going from the surface point toward the light and\n        // length of the segment between the two points\n\t    vec3 L = lightPos - intersecI;\n        float Ldist = length(L);\n        L = L / Ldist;\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n\t\t// Find the factor of light attenuation that results\n        // from the intersection point being visible from the light source or in shadow.\n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n    \tvec3 resCol= computePhongShading(objectCol, objectMat,\n                                             shadowFactor, normalI, L, R, V);\n        \n        \n        infos[nbBounces].shadedCol=resCol;\n        infos[nbBounces].Ks=objectMat.Ks;\n        \n        rayDir=2.0 * dot(normalI, rayDir) * normalI - rayDir;\n        rayPos=intersecI;\n        \n        nbBounces++;\n        \n       \n    }\n    while(nbBounces<2);\n    vec3 resCol=vec3(0);\n    \n //  for (int i=0; i<2; i++)       \n    \t resCol=infos[0].shadedCol;   \n   return  resCol;\n    \n}\n\n/******************************************************************\n\n\t\t\t\t\t\tcode of Anti-Aliasing\n\n*******************************************************************/\nconst int PIXEL_SAMPLING_SIZE=3;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set the time used for the animation\n    float time = iTime;\n    \n    // Animate scene objects\n    AnimateScene(time);\n    vec3 resCol;\n    \n     for (int i=0; i<PIXEL_SAMPLING_SIZE; i++) \n     {\n         float n1 = float(i) / float(PIXEL_SAMPLING_SIZE)-0.5;\n         for (int j=0; j<PIXEL_SAMPLING_SIZE; j++)\n         {\n         \tfloat n2 = float(j) / float(PIXEL_SAMPLING_SIZE)-0.5;                                   \n             vec2 Coordtemp =fragCoord+ vec2(n1, n2);\n             resCol += RaycastAtPixelCoord(Coordtemp);\n          }\n     }\n    resCol /= float(PIXEL_SAMPLING_SIZE * PIXEL_SAMPLING_SIZE);\n    fragColor=vec4 (resCol,1);\n    \n  //  fragColor=vec4 (RaycastAtPixelCoord(fragCoord),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSfRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3507, 3605, 3750, 5647, 8411], [8511, 8555, 8695, 11397, 12275], [12277, 12375, 12460, 13432, 17276], [17376, 17472, 17621, 17698, 18636], [18638, 18736, 18773, 18773, 18797], [18897, 18941, 18977, 19613, 20254], [20256, 20354, 20429, 20429, 20691], [20693, 20791, 20878, 22059, 23751], [23753, 23851, 23990, 29302, 29716], [29718, 29816, 29847, 29882, 30821], [30823, 31071, 31112, 31184, 33410], [33412, 33612, 33669, 33712, 34382]], "test": "untested"}
{"id": "ltSfz3", "name": "20/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I continued exploring path tracing. I took the scene from my previous shader (https://www.shadertoy.com/view/MtjBWh). Thanks to fizzer for help with BRDF!", "tags": ["pathtracing", "dailyshader", "sdfgeometry"], "likes": 0, "viewed": 125, "published": "Public", "date": "1516657945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Simple path tracer. I used Iq's great article as a tutorial for this.\n//http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n\n#define STEPS 50\n#define FAR 60.0\n#define EPSILON 0.5/iResolution.x\n#define PI 3.14159265359\n\n#define BOUNCES 3\n#define SAMPLES 10.0\n\n#define FOG_COLOR vec3(0.65, 0.7, 0.8)\n#define SUN_COLOR vec3(0.8, 0.75, 0.7)\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nvec2 hash23(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//from http://amietia.com/lambertnotangent.html\nvec3 lambertNoTangent(vec3 normal, vec2 uv){\n   float theta = 6.283185 * uv.x;\n   uv.y = 2.0 * uv.y - 1.0;\n   vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n   return normalize(normal + spherePoint);\n}\n\n//Distance functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Maximum/minumum elements of a vector\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax3(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.0;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a){\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.0)/((n-1.0)*2.0+sqrt(2.0));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.0)/2.0*r;\n\t\tp.x += columnradius*sqrt(2.0);\n\t\tif (mod(n,2.0) == 1.0) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.0);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n\nvec2 dist(vec3 p){\n    float flr = fPlane(p, vec3(0.0, 1.0, 0.0), 2.0);\n    float ball = fSphere(p-vec3(0.0, 2.0, 0.0), 1.5);\n    \n    vec3 disp = vec3(20.0, 0.0, 0.0);\n    vec3 pp = p;\n    \n    float index = pModPolar(pp.xz, disp.x);\n    pp -= disp;\n    pMod2(pp.xz, vec2(5.0, 4.0));\n    float box = fBox(pp, vec3(1.0, 1.5, 1.0));\n    float sphere = fSphere(pp-vec3(0.0, 1.0, 0.0), 1.0);\n    \n    float field = fOpEngrave(box, sphere, 0.5);\n    \n    float scene = fOpUnionColumns(flr, fOpUnionColumns(field, ball, 0.5, 3.0), 1.0, 4.0);\n    \n    float id = 0.0;\n    if(ball < flr && ball < field || \n      sphere < flr && sphere < ball && sphere < box){\n        id = 1.0;\n    }\n    else if(flr < ball && flr < field){\n        id = 2.0;\n    }\n    \n    return vec2(scene, id);\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(EPSILON, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy).x-dist(p-eps.xyy).x,\n        dist(p+eps.yxy).x-dist(p-eps.yxy).x,\n        dist(p+eps.yyx).x-dist(p-eps.yyx).x\n    ));\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 1.3;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(dist(ro).x);\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*dist(p).x;\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < EPSILON || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*dist(p).x);\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= EPSILON){\n\t\tt = candidate_t;\n\t}\n    \n    p = ro+rd*t;\n    float id = dist(p).y;\n    \n\treturn vec2(t, id);\n}\n\nvec3 light(vec3 p, vec3 rd, vec3 ld){\n    vec3 n = normals(p);\n    float lambertian = max(dot(n, ld), 0.0);\n    \n    return SUN_COLOR+lambertian*FOG_COLOR;\n}\n\nvec3 color(float obj){\n    vec3 base = vec3(0.0);\n    if(obj == 0.0){\n        base = vec3(0.45, 0.45, 0.42);\n    }\n    else if(obj == 1.0){\n        base = vec3(0.75, 0.65, 0.55);\n    }\n    else if(obj == 2.0){\n        base = vec3(0.4, 0.4, 0.45);\n    }\n    return base;\n}\n\n\nvec3 render(vec3 o, vec3 d, vec3 rt, vec2 uv){\n    vec3 ro = o;\n    vec3 rd = d;\n    vec3 ld = (rt-ro)/distance(ro, rt);\n    vec3 ld2 = (rt-vec3(0.0, -2.0, 6.0))/distance(vec3(0.0, -2.0, 6.0), rt);\n    \n    vec3 tcol = vec3(0.0);\n    vec3 fcol = vec3(1.0);\n    \n    for(int i = 0; i < BOUNCES; ++i){\n        vec2 t = march(ro, rd);\n        vec3 p = ro+rd*t.x;\n        if(t.y < 0.0 || t.x > FAR){\n            fcol = FOG_COLOR;\n            tcol += fcol;\n            break;\n        }\n        vec3 scol = color(t.y);\n        vec3 dcol = light(p, rd, ld);\n        dcol += light(p, rd, ld2);\n        dcol *=0.5;\n        fcol *= scol;\n        tcol += fcol * dcol;\n        \n        vec3 n = normals(p);\n        \n        ro = p+(n*0.2);\n        rd = lambertNoTangent(n, hash23(vec3(uv, float(i)+iTime*0.01)));\n        \n        \n    }\n    \n    return tcol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    //vec3 ro = vec3(5.0*sin(iTime*0.5), 2.0, 5.0*cos(iTime*0.5));\n    //vec3 rt = vec3(0.0, 0.5, 0.0);\n    \n    vec3 ro = vec3(10.0*cos(iTime*0.1), 3.5+sin(iTime*0.05), 12.0*sin(iTime*0.1));\n    vec3 rt = vec3(0.0, 2.5, 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    //vec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    \n    vec3 color = vec3(0.0);//render(ro, rd, rt);\n    \n    \n    for(float i = 0.0; i < SAMPLES; ++i){\n    \tvec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    \tcolor += render(ro, rd, rt, uv);\n    }\n    color /= SAMPLES;\n    \n    //color = smoothstep(0.0, 1.1, color);\n    \n     //Vigenting\n    float vigentOffset = 0.005;\n    float darkness = 0.4;\n\tfloat dist = distance(uv, vec2( 0.5 ));\n\tcolor *= smoothstep(0.8, vigentOffset * 0.799, dist *( darkness + vigentOffset ));\n    \n    color = pow(color, 1.0/vec3(1.7));\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSfz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 523, 544, 544, 648], [649, 649, 670, 670, 784], [786, 834, 878, 878, 1075], [1156, 1196, 1217, 1217, 1252], [1254, 1254, 1286, 1286, 1311], [1313, 1387, 1443, 1443, 1485], [1487, 1538, 1571, 1583, 1612], [1614, 1650, 1678, 1678, 1760], [1762, 1906, 1946, 1946, 2067], [2069, 2097, 2134, 2134, 2225], [2227, 2340, 2390, 2390, 2784], [2786, 3024, 3055, 3055, 3097], [3099, 3135, 3160, 3160, 3200], [3202, 3276, 3335, 3335, 3956], [3958, 4030, 4075, 4075, 4121], [4124, 4124, 4142, 4142, 4900], [4902, 4902, 4923, 4923, 5134], [5195, 5234, 5254, 5254, 5284], [5286, 5286, 5315, 5315, 6554], [6556, 6556, 6593, 6593, 6713], [6715, 6715, 6737, 6737, 6986], [6989, 6989, 7035, 7035, 7837], [7840, 7840, 7897, 7897, 8999]], "test": "untested"}
{"id": "MdlfRj", "name": "buildings + train", "author": "antoineMoPa", "description": "Some 2D city made mostly from sine waves.\n\nMade some months ago, I made it public now, there may be some bugs on some GPUs.\n\nYou should see a train, buildings, stars.", "tags": ["2d", "city", "train", "buildings"], "likes": 17, "viewed": 787, "published": "Public API", "date": "1517372964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float time;\n\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define shadertoy 1\n\n#ifdef shadertoy\n#define time iTime\n#endif\n#ifndef shadertoy\nuniform float iTime;\nvarying vec2 UV;\nuniform vec3 iResolution;\n#endif\n\nvec4 buildings(vec2 pos){\n\tvec4 col = vec4(0.0);\n    \n    float roof = 0.1;\n    float bx = pos.x * 20.0;\n    float x = 0.05 * floor(bx - 4.0);\n    // BX = Position relative to building left\n    bx = mod(bx,1.0);\n  \n    // Build pseudorandom rooftop line\n    roof += 0.06 * cos(x * 2.0);\n\troof += 0.1 * cos(x * 23.0);\n\troof += 0.02 * cos(x * 722.0 );\n\troof += 0.03 * cos(x * 1233.0 );\n\t\n    roof += 0.06;\n    \n    if(pos.y < roof && pos.y > 0.0 && bx > 0.1 * cos(20.0 * pos.x)){\n    \tcol.b += 0.4;\n        \n        // Draw windows\n        float window = abs(sin(200.0 * pos.y));\n        window *= abs(sin(20.0 * bx));\n        \n        // type 1 window\n        if(mod(2023.0 * x,2.0) < 0.5){\n          \twindow = floor(1.3 * window);\n        \tcol.rgb += 1.5 * window * vec3(0.9,0.9,0.9);\n        }\n        // type 2 window\n        else if(mod(2983.0 * x,2.0) < 1.3){\n        \tcol.rb += window;\n        }\n        else {\n            if(window > 0.5){\n            \tcol.rg += 0.8;\n           \t}\n        }\n      \tcol.a = 1.0;\n    }\n\n    return col;\n}\n\nvec4 train(vec2 pos){\n\tvec4 col = vec4(0.0);\n    \n    float base = 0.01 * cos(pos.x * 7.0 + time * PI2) + 0.02;\n    \n\n    col.r += base;\n   \t\n    if(pos.y > 0.0){\n        pos.y -= base;\n        // track\n        if(pos.y < 0.01){\n            // Actual track\n            if(pos.y > -0.005){\n                col.rg += 0.1;\n                col.a = 1.0;\n            }\n            // supports\n            else if(cos(4.0 * (pos.x * 7.0 + time * PI2)) < -0.8){\n            \tcol.rg += 0.1;\n                col.a = 1.0;\n            }\n            \n        }\n        // train\n        else if(pos.y < 0.04 && pos.x < 0.3){\n            bool in_y_range = pos.y < 0.02 || pos.y > 0.03;\n              \t\n            if(pos.x < -0.01){\n                // Delimit wagons\n                if(pos.x > -0.02 || cos(pos.x * 100.0) < 0.9){\n\n                    if(pos.y < 0.018 && pos.y > 0.014 && pos.x < -0.02){\n                        col.r += 1.0;\t\n                        col.a = 1.0;\n                    }\n\n                    // windows\n                    else if(!in_y_range && pos.x > 0.01){\n                        col.a = 0.0;\n                    } else if(in_y_range || (cos(pos.x * 400.0) < 0.0) ){\n                        col.rgb += 0.5;\n                        col.a = 1.0;\n                    }\n                }\n            } else if (pos.x < 0.01) {\n                // Front of the train\n                // function: 1-x^3\n                // Make a suitable x and y axis to plot the function\n                float xx = (pos.x + 0.01)/ 0.02;\n                float yy = (pos.y - 0.02) / 0.02;\n                float func = 1.0 - pow(xx, 3.0);\n                \n                if(yy < func){\n                \tcol.rgb += 0.5;\n                    col.a = 1.0;\n                }\n            }\n        }\n    }\n    \n    return col;\n}\n\nvec4 stars(vec2 pos){\n\tvec4 col = vec4(0.0);\n  \tfloat threshold = -0.999;\n\tpos *= 1.0;\n  \tif(1.0 * cos(pos.x * 1000.0) + 1.0 * cos(30000.0 * pos.x + cos(10000.0 * pos.y)) < threshold){\n      \tif(cos(pos.y * 100.0 + 10000.0 * cos(pos.x * 10.0)) < threshold){\n      \t\tcol += 1.0;\n          \tcol.a = 1.0;\n        }\n    }\n  \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n\tvec4 col = vec4(0.0);\n    \n    vec2 pos = uv - vec2(0.5);\n    \n    pos.y += 0.3;\n    \n    vec2 water = vec2(0.0);\n    \n    // Offset for water waves\n    water.x += 0.003 * cos(pos.y * 150.0 + time * PI2);\n    water.x += 0.001 * cos(pos.y * 250.0 +  time * PI2);\n    water.x += 0.001 * cos(pos.y * 4050.0 + time * PI2);\n    \n    col += 0.6 * buildings(pos + vec2(time * 0.2, 0.0)); // Buildings\n    col += 0.3 * buildings(pos * vec2(1.0, -1.0) + vec2(time * 0.2, 0.0) + water); // Reflection of buildings\n    \n    vec4 t = train(pos);\n    col = t.a * t + (1.0 - t.a) * col; // Train\n    t = train(pos * vec2(1.0, -1.0) + water); // Reflection of train\n    t.a *= 0.3;\n    col = t.a * t + (1.0 - t.a) * col;\n    \n    \n    // Sky + water color\n  \tif(col.a < 0.1){\n        if(pos.y < 0.0){\n            col.b += 0.2;\n        } else {\n            col.rgb += vec3(0.1,0.1,0.3);\n            col += stars(pos);\n        }\n    }\n  \n    // Plane\n    if(pos.x < -0.1 && pos.y > 0.6 && pos.y < 0.602){\n    \tcol.rgb += 0.22 +\n            0.1 * cos(pos.x + iTime) + \n            0.03 * cos(pos.x * 200.0 + 10.0 * iTime);\n    }\n    \n    float d = distance(pos,vec2(-0.1, 0.6));\n    \n    if(d < 0.005){\n    \tcol.r += (1.0 - d/0.01) * (pow(cos(time * PI),30.0)  + 0.5);\n    \tcol.b += (1.0 - d/0.01) * (pow(cos(time * PI + 1.0),30.0)  + 0.5);\n    }\n    \n    col.a = 1.0;\n    \n\tfragColor = col;\n}\n\n#ifndef shadertoy\nvoid main(){\n    vec2 uv = UV * iResolution.xy;\n    vec4 col;\n\n    mainImage(col, uv);\n\n    gl_FragColor = col;\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 253, 253, 1270], [1272, 1272, 1293, 1293, 3090], [3092, 3092, 3113, 3113, 3426], [3428, 3428, 3485, 3485, 4914]], "test": "untested"}
{"id": "Ml2BRm", "name": "Escher's box", "author": "keim", "description": "Escher's box. drag to move camera.", "tags": ["illusion", "escher", "reproduction"], "likes": 21, "viewed": 840, "published": "Public API", "date": "1515172632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n vec2  resolution, mouse;\n float time;\n\nconst vec3 V  = vec3(0,.001,100);\nconst vec3 BG = vec3(0.0);\nconst vec3 Amb= vec3(0.01);\nconst vec3 PI = vec3(1.5707963,3.1415927,6.2831853);\nconst float BPM = 120.;\nvec2 uv;\nfloat tick;\n\nfloat rnd(vec3 s){s=fract(s*443.8975);s+=dot(s,s.yzx+19.19);return fract(s.x*s.y*s.z);}\nvec4  gamna(vec3 c){return vec4(pow(c,vec3(1./2.2)),1);}\nvec3  hsv(float h,float s,float v){return((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nmat3  camera(vec3 p, vec3 t, vec3 h){vec3 w=normalize(p-t),u=normalize(cross(w,h));return mat3(u,normalize(cross(u,w)),w);}\nmat3  euler(float h, float p, float r){float a=sin(h),b=sin(p),c=sin(r),d=cos(h),e=cos(p),f=cos(r);return mat3(f*e,c*e,-b,f*b*a-c*d,f*d+c*b*a,e*a,c*a+f*b*d,c*b*d-f*a,e*d);}\nfloat dfPln(vec3 p, vec3 n, float d){return dot(p,n)+d;}\nfloat dfBox(vec3 p, vec3 b, float r){return length(max(abs(p)-b,0.))-r;}\nfloat dfDdc(vec3 p, float r) {vec4 v=vec4(-.8507,.8507,.5257,0);return max(max(abs(dot(p,v.wyz)),max(abs(dot(p,v.wxz)),abs(dot(p,v.zwy)))),max(abs(dot(p,v.zwx)),max(abs(dot(p,v.yzw)),abs(dot(p,v.xzw)))))-r;}\n\nconst vec3 r = vec3(4.8,0.1,0.3), t = vec3(4,-4,0);\n\nvec3 trans(vec3 p) {\n    return (p - vec3(0,10,0)) * euler(tick/21.*PI.z,tick/16.*PI.z,0.0);\n}\n\nfloat trick(vec3 p) {\n    float d = V.z;\n    p = trans(p);\n    d = min(d, dfBox(p-t.yzy, r.yxy, r.z));\n    return d;\n}\n\nfloat map(vec3 p, bool trick) {\n    mat3 rot = euler(-tick/3.*PI.z,tick/5.*PI.z,0.0);\n    float d = dfPln(p, vec3(0,1,0), 0.);\n    p = trans(p);\n    d = min(d, dfDdc((p+vec3(sin(tick/8.*PI.z)*10.,0.,cos(tick/16.*PI.z)*8.))*rot, 1.5));\n    d = min(d, dfDdc((p+vec3(cos(tick/16.*PI.z+PI.x)*8.,sin(tick/8.*PI.z+PI.y)*8.,0.))*rot, 1.));\n    d = min(d, dfBox(p-t.zxy, r.xyy, r.z));\n    d = min(d, dfBox(p-t.zyy, r.xyy, r.z));\n    d = min(d, dfBox(p-t.xzx, r.yxy, r.z));\n    d = min(d, dfBox(p-t.yzx, r.yxy, r.z));\n    d = min(d, dfBox(p-t.xzy, r.yxy, r.z));\n    d = min(d, dfBox(p-t.yzy, r.yxy, r.z));\n    d = min(d, dfBox(p-t.yxz, r.yyx, r.z));\n    d = min(d, dfBox(p-t.yyz, r.yyx, r.z));\n    if (trick) {\n        d = min(d, dfBox(p-t.zxx, r.xyy, r.z));\n        d = min(d, dfBox(p-t.zyx, r.xyy, r.z));\n        d = min(d, dfBox(p-t.xxz, r.yyx, r.z));\n        d = min(d, dfBox(p-t.xyz, r.yyx, r.z));\n    }\n    return d;\n}\n\nvec3 background(vec3 pos, vec3 dir, inout float bld) {\n    bld = 0.;\n    return BG;\n}\n\nvec3 diff(vec3 nml, vec3 lit, vec3 col){return max(dot(nml,lit)*col,0.);}\nfloat shad(vec3 pos, vec3 lit){float s=V.z,t=.05,d;for(int i=20;i!=0;--i){t+=max(d=map(pos+lit*t, true),.05);s=min(s,d/t);if(t>20.)break;}return clamp(s*.2,0.,1.);}\nfloat occl(vec3 pos, vec3 nml){float s=0.;for(float t=.01;t<.5;t+=.05){s+=t-map(pos+nml*t, true);}return clamp(1.-s*.1,0.,1.);}\n\nbool tricktrace(vec3 pos, vec3 dir) {\n    float t = 0., d;\n    for (int i=80; i!=0; --i) {\n        t += (d = trick(pos + dir * t));\n        if (d < V.y) break;\n        if (t > V.z) return true;\n    }\n    return false;\n}\n\nvec3 trace(inout vec3 pos, inout vec3 dir, inout float bld) {\n    float t = 0., d;\n    bool trick = tricktrace(pos, dir);\n    for (int i=80; i!=0; --i) {\n        t += (d = map(pos + dir * t, trick));\n        if (d < V.y) break;\n        if (t > V.z) return bld * background(pos, dir, bld);\n    }\n    vec3 p = pos + dir * t;\n    vec3 n = normalize(vec3(map(p+V.yxx, true),map(p+V.xyx, true),map(p+V.xxy, true))-map(p, true));\n    vec3 c = vec3(1);\n    vec3 ldir = normalize(vec3(sin(tick/24.*PI.z)*20.,20.,cos(tick/24.*PI.z)*20.) - p);\n    vec3 lcol = diff(n, ldir, hsv(tick/16.,0.5,1.0)*10.) * shad(p, ldir) * occl(p, n) + Amb;\n    vec3 ldir2 = normalize(vec3(0.,25,0.) - p);\n    vec3 lcol2 = diff(n, ldir2, hsv(tick/16.+0.33,0.5,1.0)*10.) * shad(p, ldir2) * occl(p, n) + Amb;\n    vec3 col = c * (lcol + lcol2);\n    float b=bld*.4;\n    pos = p + n*V.y;\n    dir = reflect(dir, n);\n    bld *= .6;\n    return mix(col, BG, clamp(length(p.xz)/24.,0.,1.))*b;\n}\n\nvec3 render(in vec3 pos, in vec3 dir) {\n    float b = 1.;\n    vec3 col = trace(pos, dir, b);\n    if (b > V.y) col += trace(pos, dir, b);\n    if (b > V.y) col += trace(pos, dir, b);\n    return col;\n}\n\nvec4 entryPoint(vec2 fragCoord) {\n    uv = (fragCoord * 2.-resolution) / resolution.y;\n    tick = time * BPM / 60.;\n\n    float scan = 1., dist = 0.;\n    vec3 pos = vec3(25.,18.,0.);\n    if (iMouse.z > 0.5) {\n        vec2 r = mouse/resolution*2.-1.;\n        pos = vec3(cos(r.x*PI.y)*25.,r.y*12.+18.,sin(r.x*PI.y)*25.);\n    }\n    vec3 dir = camera(pos, vec3(0,7.5,0), vec3(0,1,0)) * normalize(vec3(uv+vec2(dist,0),-2));\n    return gamna(render(pos, dir)) * scan;\n}\n\nvoid mainImage(out vec4 flagColor,in vec2 flagCoord) {\n    resolution = iResolution.xy;\n    time = iTime;\n    mouse = iMouse.xy;\n    flagColor = entryPoint(flagCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2BRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 269, 269, 338], [339, 339, 359, 359, 395], [396, 396, 431, 431, 503], [504, 504, 541, 541, 627], [628, 628, 667, 667, 800], [801, 801, 838, 838, 857], [858, 858, 895, 895, 930], [931, 931, 961, 961, 1138], [1193, 1193, 1213, 1213, 1287], [1289, 1289, 1310, 1310, 1407], [1409, 1409, 1440, 1440, 2324], [2326, 2326, 2380, 2380, 2411], [2413, 2413, 2453, 2453, 2486], [2487, 2487, 2518, 2518, 2651], [2652, 2652, 2683, 2683, 2779], [2781, 2781, 2818, 2818, 3000], [3002, 3002, 3063, 3063, 3955], [3957, 3957, 3996, 3996, 4155], [4157, 4157, 4190, 4190, 4619], [4621, 4621, 4675, 4675, 4790]], "test": "untested"}
{"id": "Ml2BWR", "name": "Lost marbles", "author": "grinist", "description": "A dirty old 2d sphere trick. Can't withstand closer examination. So you can stop squinting now. ;)", "tags": ["2d", "sphere", "marble", "eyelord"], "likes": 6, "viewed": 642, "published": "Public API", "date": "1515487617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A dirty old 2d sphere trick that just projects a texture in 2d. Obviously this can't withstand\n// closer scrutiny. Textures with distinct features give it away instantly. Also the glow can't\n// represent what's underneath the marble.\n// This is close to something we got away with in a game. Although we were targeting GLES1\n// and did this with texture coordinates and additional tricks with the geometry.\n\n#define PI 3.1415926536\n#define HPI (PI / 2.0)\n#define TAU (2.0 * PI)\n#define TSCALE 1.25\n#define MARBLES 9\n\n// returns normalized distance along sphere surface given 2d radius\nfloat surface(float d)\n{\n    return asin(clamp(d, 0.0, 1.0)) / HPI * TSCALE;\n}\n\n// returns normalized distance along sphere surface given 2d distance on background plane\nfloat glow(float d, float sr)\n{\n    return atan(d / sr) / HPI * TSCALE;\n}\n\nstruct Marble\n{\n    vec2 pos;\n    vec2 v;\n    vec2 nv;\n    float d;\n   \tfloat r;\n    vec2 tpos;\n};\n\nMarble m[MARBLES];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.28;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 size = vec2(iResolution.x/iResolution.y, 1.0);\n\n    // background\n    vec3 color = vec3(0.025, 0.05, 0.15);\n\n    // set up marbles and accumulate glows\n    float p = 0.0;\n    float pinc = TAU / float(MARBLES);\n    for (int i = 0; i < MARBLES; i++)\n    {\n        // position and distance vecs\n        vec2 off = vec2(cos(time + p), sin(time + p));\n        m[i].pos = 0.5 * size + 0.33 * size * off + sin((time + p) * 6.0) * off.yx * 0.12;\n\n        m[i].v = uv - m[i].pos;\n        m[i].d = length(m[i].v);\n        m[i].nv = m[i].v / m[i].d;\n\n        // marble radius and texture position\n        m[i].r = 0.1 + sin(p * 5.0) * 0.025;\n        m[i].tpos = 0.5 + 0.1 * p - m[i].pos / HPI * TSCALE;\n\n        // background glow\n        float g = glow(m[i].d, m[i].r);\n        vec2 guv = 0.5 + m[i].tpos - m[i].nv * g * m[i].r;\n        vec3 gc = texture(iChannel0, guv).rbg;\n        gc = smoothstep(0.5, 0.9, gc) * vec3(0.4, 0.3, 0.1);\n        // attenuation\n        float gd = sqrt(m[i].d * m[i].d + m[i].r * m[i].r) - m[i].r;\n        gc /= (0.5 + 1000.0 * gd * gd);\n        color += gc;\n        \n        p += pinc;\n    }\n    \n    // draw marbles on top\n    for (int i = 0; i < MARBLES; i++)\n    {\n        // marble surface\n        float md = m[i].d / m[i].r;\n        if (md > 1.0)\n            continue;\n        float ms = surface(md);\n        vec2 muv = m[i].tpos + m[i].nv * ms * m[i].r;\n        vec3 mc = texture(iChannel0, muv).rgb;\n        // glow\n        vec3 mg = smoothstep(0.55, 0.9, mc.rbg) * 0.5;\n        // base falloff\n        mc *= (1.0 - clamp(md * 1.1, 0.0, 0.8));\n        // glow with additional falloff\n        mc += mg * (1.0 - 0.5 * md);\n        // rim, hides the problem at rotational poles a bit\n        mc = mix(mc, vec3(0.15, 0.1, 0.2), smoothstep(0.25, 1.0, md * md) * 0.9);\n        // highlight\n        mc += smoothstep(0.18, 0.04, md) * vec3(0.15, 0.15, 0.2);\n        // aa\n        float alpha = 1.0 - smoothstep(m[i].r - 0.002, m[i].r, m[i].d);\n        color = mix(color, mc, alpha);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2BWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 588, 612, 612, 666], [668, 758, 789, 789, 831], [953, 953, 1010, 1010, 3142]], "test": "untested"}
{"id": "Ml2BzW", "name": "try occlusion", "author": "cailuming", "description": "try occlusion", "tags": ["occlusion"], "likes": 8, "viewed": 240, "published": "Public", "date": "1515343484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define FAR 64\n#define SMR 5.\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n\nmat2 rot2D(float a){\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid setCamera(inout Ray r,vec3 pos,vec3 tar,vec2 uv){\n    vec3 look =normalize(tar-pos);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up = normalize(cross(look,right));\n    r.o=pos;\n    r.d= normalize(uv.x*right+uv.y*up +look);\n}\n\nvec2 obj(vec3 p,vec3 c){\n    p-=c;\n    return vec2(length(p)-2.,0);\n}\n\nvec2 obj1(vec3 p,vec3 c){\n    p-=c;\n   \n    float arc =atan(p.y,p.x);\n    float ed=0.5*abs(sin(arc*10.));\n    ed = length(p.xy)<0.8?0.:ed;\n    float v1 =max(abs(p.x),max(abs(p.y),abs(p.z)))-3.;\n    float v2 =length(p)-1.-ed;\n    return vec2(mix(v1,v2,0.2),1);\n}\n\nvec2 obj2(vec3 p,vec3 c){\n    p-=c;\n    return vec2(-max(abs(p.x),max(abs(p.y),abs(p.z)))+25.,3);\n}\n\nvec2 obj3(vec3 p,vec3 c){\n    p-=c;\n    float arc = atan(p.z,p.x);\n    float r = sin(p.y)*0.6+0.8;\n    vec3 polor =vec3(r*cos(arc)+cos(p.y),clamp(p.y,-2.,4.),r*sin(arc)+sin(p.y));\n    return vec2(length(p-polor)-1.,1);\n}\n\n\n\nvec2 plane(vec3 p){\n    return vec2(p.y+2.,2);\n}\n\n\nvoid cmp(vec2 a,inout vec2 r){\n    r=r.x>a.x?a:r;\n}\n\nvec2 map(vec3 p){\n    vec2 r=vec2(2.,-1);\n    cmp(obj(p,vec3(0,0,10.*sin(iTime))),r);\n     \n    cmp(obj1(p,vec3(5.,0.5,0)),r);\n    cmp(obj2(p,vec3(0,0,0)),r);\n    cmp(obj3(p,vec3(-5,0,0)),r);\n  \n    \n    \n    cmp(plane(p),r);\n    return r;\n}\n\nvec3 norm(vec3 rd,float dl){\n    float m =map(rd).x;\n    vec2 d=vec2(0,1)*dl*0.01;\n    \n    return -normalize(\n        vec3(\n            m-map(rd+d.yxx).x,\n            m-map(rd+d.xyx).x,\n            m-map(rd+d.xxy).x\n        ));\n}\n\nvec2 rayHit(Ray r){\n    float t=0.0;\n    vec2 h=vec2(0);\n    \n    for(int i=0;i<FAR;i++){\n        h=map(r.o+t*r.d);\n        if(h.x<=0.0001||t>64.){\n          break; \n        }\n        \n        t+=h.x;\n    }\n    \n    return vec2(t,h.y);\n}\n\n\nvoid fog(inout vec3 col,vec3 ro,vec3 rd,float t){\n    float a =0.1;\n    float b =0.2;\n    float fogv=a * exp(-ro.y*b) * (1.0-exp( -t*rd.y*b ))/rd.y;\n    vec3  fogc  = vec3(0.5,0.6,0.7);\n    \n    fogv*=(1.-exp(-0.01*t*t));\n    col=mix( col, fogc, fogv );\n}\n\nfloat occlusion(vec3 p,vec3 norm){\n    float scalor=0.7;\n    \n    float occ =0.;\n    for(float i=0.;i<SMR;i++){\n       float k= i/SMR;\n       k*=scalor;\n       float d=map(p+k*norm).x;\n       occ+= pow(0.5,i*0.3)*(k-d);\n    }\n    occ=1.-clamp(occ,0.,1.);\n    return occ;\n}\n\n\nvoid doLight(inout vec3 col,Ray r,float t,vec3 lp){\n   vec3 p =r.o+r.d*t;\n   vec3 ld =normalize(lp-p);\n   vec3 n= norm(p,length(p));\n   float nl = clamp(dot(normalize(lp-p),n),0.,1.);\n   float sl = clamp(dot(reflect(-ld,n),n),0.,1.);\n   float ol = occlusion(p,n);\n   \n   col=vec3(mix(nl+pow(sl,80.),ol,0.6));  \n     \n}\n\n\nvoid textureMap(inout vec3 col,int id,vec3 p){\n    float v=0.;\n    if(id==0){\n        vec3 color =vec3(0.5,0.8,0.7);\n        p-=vec3(0,0,10.*sin(iTime));\n    \n        //p.xz*=rot2D(atan(cos(iTime),sin(iTime)));\n    \n        p.yz*=rot2D(-5.*sin(iTime));\n        \n        p=mod(p,2.);\n        p-=1.;\n        \n       \n        float arc =atan(p.y,p.x);\n        \n        v=0.85/(length(p)+0.2*sin(arc*8.));\n        v=max(pow(v,2.),1.);\n        col*=color*vec3(v,0.9*v,0.3*v);\n    }else if(id==1){\n        \n        float arc =atan(p.y,p.x);\n        vec3 color =vec3(1,0.6,0.2);\n        \n        col*=color;\n    }else if(id==2){\n        \n         \n        col*=texture(iChannel1,p.xz/10.).xyz;\n    }else if(id==3){\n       \n        p=mod(p,2.);\n        p-=1.;\n        \n        float arc =atan(p.y,p.x);\n        \n        v=0.85/(length(p)+0.2*sin(arc*8.));\n        v=clamp(pow(v,2.),0.,1.);\n        col*=vec3(v,0.1*v,0.5*v); \n        col*=texture(iChannel1,p.xz/10.).xyz;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5);\n    float as= iResolution.x/iResolution.y;\n    uv.x*=as;\n    Ray ray;\n    vec3 eye =vec3(0,3,-20);\n    vec3 dir =vec3(0,-1,1);\n    vec3 light =vec3(10.*sin(iTime),9,10.*cos(iTime));\n    \n    eye.xz*=rot2D(PI*0.1*iTime);\n    dir.xz*=rot2D(PI*0.1*iTime);\n     \n    setCamera(ray,eye,dir,uv);\n   \n    vec3 col =vec3(0);\n    vec2 res =rayHit(ray);\n    \n    doLight(col,ray,res.x,light);\n   \n\ttextureMap(col,int(res.y),ray.o+ray.d*res.x);\n    fog(col,ray.o,ray.d,res.x);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2BzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 109, 109, 178], [180, 180, 234, 234, 427], [429, 429, 453, 453, 498], [500, 500, 525, 525, 761], [763, 763, 788, 788, 862], [864, 864, 889, 889, 1084], [1088, 1088, 1107, 1107, 1136], [1139, 1139, 1169, 1169, 1190], [1192, 1192, 1209, 1209, 1433], [1435, 1435, 1463, 1463, 1665], [1667, 1667, 1686, 1686, 1904], [1907, 1907, 1956, 1956, 2162], [2164, 2164, 2198, 2198, 2436], [2439, 2439, 2490, 2490, 2757], [2760, 2760, 2806, 2806, 3730], [3732, 3732, 3788, 3788, 4348]], "test": "untested"}
{"id": "Ml2fRc", "name": "graprog_ilas_act4", "author": "ilaschino", "description": "sunset colors transition", "tags": ["graprog"], "likes": 2, "viewed": 110, "published": "Public", "date": "1516762141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colorA = vec3(.99,.37,.33);\nvec3 colorB = vec3(0.0,0.0, 0.76);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 t;\n    \n    t.r = smoothstep(-0.2, 1.0 + (sin(iTime * 0.6)), uv.y);\n    t.g = sin(uv.y * 3.14);\n    t.b = pow(uv.y,0.5);\n    \n    vec3 color = mix(colorA,colorB,t); //mix(color1,color2, % mix for the 2 colros);\n    fragColor = vec4(color,t);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2fRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 127, 127, 424]], "test": "untested"}
{"id": "Ml2fRd", "name": "Thing_5", "author": "balkhan", "description": "Thing", "tags": ["thing"], "likes": 4, "viewed": 154, "published": "Public", "date": "1517134458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t800\n#define E\t\t\t0.01\n#define FAR\t\t\t30.\n\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tid;\nvec3\th;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    h *= 0.;\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2(.35+f.x/iResolution.x, f.y/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 25.0-sin(iTime*.125)*25.*0.-21.+2.);\n\n    vec4\tinter = (march(pos, dir));\n\n    col = 1. - h;\n    col *= (1.-max(inter.x*.001251, 1.-inter.w*.125))*inter.y;\n    //col *= inter.y;\n    c_out =  vec4(col*1., h.x);\n}\n\n/*\n**\tLeon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define\tPI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n**\tend mod polar\n*/\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    p.z -= -20.;\n    p.z -= iTime*5.;\n    rotate(p.xy, p.z*.5 + 1.0*sin(p.z*.125 - iTime*1.) + 1.*iTime\n           + (mod(floor(p.x*.5), 2.)-1. == 0. ? -1. : -1.)*p.z*.5*0. );\n    \n    vec3\tap = p;\n    ap.y += sin(iTime*-1.+p.z*.5)*2.;\n    ap.x += cos(iTime*-1.+p.z*.5)*2.;\n    ap.xy = modA(ap.xy, 50.-(sin(iTime*.0+p.z*.125)*40.));\n    ap.x -= 1.;\n\n    vec3\tpr = p;\n    pr.y -= min(sin(iTime*.125+4.14), .0)*1.*sin(iTime*-1.+p.z*.5)*2.;\n    pr.x -= min(sin(iTime*.125+4.14), .0)*1.*cos(iTime*-1.+p.z*.5)*2.;\n    id = vec3(floor(p.xy*.5), floor(p.z*2.));\n    rotate(pr.xy, iTime*-1.5+floor(p.z*2.)+p.z*2.5 );\n    pr.xy = abs(pr.xy)-.5;\n    pr.xy = abs(pr.xy)-.06125;\n    pr.z = (fract(pr.z*2.)-.5);\n\tmind = mylength(pr.xyz)-.051;\n    pr.xyz = abs(pr.xyz)-.045;\n    mind = min( mind, mylength(pr.xyz)-.025);\n    mind = min( mind, max(max(mylength(ap.xy)-.035, pr.z-.25), 0.) );\n    mind = min(mind, max(max(mylength(vec2(pr.yz ))-0.1, ap.x-.35), -ap.x+.135));\n    mind = min(mind, mylength(vec2(mylength(ap.xy)-.00, fract(pr.z*1.35)-.5 ))-.105);\n    \n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3\tdirr;\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n    \tp = pos + dirr * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x*.125;\n        vec3\ts = p;\n        float\td = max(length(s.xy)-8., -(length(s.xy)-8.1));\n        h -= vec3(.3, .2, .0)*.1/ (max(d, .00001)+.01);\n        h += (\n            .001/(dist.x*dist.x+0.01) \n            -\n            1./(dist.y*dist.y+40.)\n             )\n            *\n            vec3\n        (\n    \t\tabs(sin(id.z+0.00) )\n            ,\n            abs(sin(id.z+1.04) )\n            ,\n            abs(sin(id.z+2.08) )\n        );\n        // log trick by aiekick\n        if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < E || dist.y >= FAR)\n        {\n            if (dist.x < E || log(dist.y*dist.y/dist.x/1e5)>0.)\n\t            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.85) * right + (uv.y-0.5) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2fRd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 398, 441, 441, 827], [829, 943, 976, 976, 1107], [1109, 1133, 1154, 1154, 2246], [2249, 2249, 2281, 2281, 3285], [3287, 3301, 3325, 3325, 3469], [3471, 3471, 3495, 3495, 3633], [3635, 3635, 3675, 3675, 3750], [3752, 3752, 3780, 3780, 3888], [3891, 3891, 3941, 3941, 4201], [4203, 4203, 4225, 4225, 4439]], "test": "untested"}
{"id": "Ml2fzK", "name": "menger sponge", "author": "unnick", "description": "made another raymarcher, but this time with a fractal, some glow, more lights, and a simple tv effect.", "tags": ["3d", "fractal", "raymarcher"], "likes": 2, "viewed": 134, "published": "Public", "date": "1516648667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.283\n\n#define raymul 0.5\n#define near 0.001\n#define far 5.0\n\n#define rand(v) fract( sin( dot( v, vec2(12.9898,78.233 )) ) * 43758.5453 )\n\nvec4 lights[] = vec4[](\n    vec4(5.0, 5.0, 0.0, 1.0),\n    vec4(-5.0, 5.0, 0.0, 1.0),\n    vec4(0.0, 5.0, 5.0, 1.0),\n    vec4(0.0, 5.0, -5.0, 1.0)\n);\nvec4 lightcolor[] = vec4[](\n    vec4(1.0, 1.0, 1.0, 2.0),\n    vec4(1.0, 1.0, 1.0, 2.0),\n    vec4(1.0, 1.0, 1.0, 2.0),\n    vec4(1.0, 1.0, 1.0, 2.0)\n);\n\n//copy pasted code from https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n//end of copy pasted code\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 pos){\n    float pdist = -pos.z-5.0;\n    int iters = 4;\n    float mul = 3.0;\n    vec3 ofs = vec3(1.0, 1.0, 1.0);\n    mat4 rot = rotationMatrix(vec3(1.0, 1.0, 1.0), iMouse.x/iResolution.x*tau/3.0);\n    for(int i = 0; i < iters; i++){\n        pos = (rot * vec4(pos, 1.0)).xyz;\n        pos = abs(pos);\n        if(pos.x-pos.y<0.0) pos.xy = pos.yx;\n        if(pos.x-pos.z<0.0) pos.xz = pos.zx;\n        if(pos.y-pos.z<0.0) pos.yz = pos.zy;\n        pos *= mul;\n        pos.xy -= ofs.xy*(mul-1.0);\n        if(pos.z > 0.5 * ofs.z * (mul-1.0)) pos.z -= ofs.z * (mul - 1.0);\n    }\n    pos /= pow(mul, float(iters));\n    return max(sdBox(pos, vec3(1.0/pow(mul, float(iters)))), pdist)-0.01;\n}\n\nvec3 getnormal(vec3 pos){\n    //basically computes the gradient and then normalizes it.\n    float d = 0.0005;\n    float dx = (map(pos+vec3(d, 0.0, 0.0)) - map(pos-vec3(d, 0.0, 0.0)));\n    float dy = (map(pos+vec3(0.0, d, 0.0)) - map(pos-vec3(0.0, d, 0.0)));\n    float dz = (map(pos+vec3(0.0, 0.0, d)) - map(pos-vec3(0.0, 0.0, d)));\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 intersect(vec3 cam, vec3 ray, out bool collision, out float tdist, out float mdist){\n    collision = false;\n    tdist = 0.0;\n    mdist = 1e8;\n    for(int i = 0; i < 256; i++){\n        //get current distance\n        float cdist = map(cam);\n        \n        //raymarch\n        cam += ray * cdist * raymul;\n        //add to total distance\n        tdist += cdist * raymul;\n        //update minimum distance\n        mdist = min(mdist, cdist);\n        if(cdist < near){\n            collision = true;\n            return cam;\n        }\n        \n        if(tdist > far){\n            return cam;\n        }\n    }\n}\n\nfloat softshadow(vec3 cam, vec3 ray, float dmin, float dmax, float k){\n    float res = 1.0;\n    for(float d = dmin; d < dmax;)\n    {\n        float cdist = map(cam + ray * d);\n        if(cdist < 0.001) return 0.0;\n        res = min(res, k*cdist/d);\n        d += cdist;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    vec2 mpos = (iMouse.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    vec3 ray = normalize(vec3(pos, 1.0));\n    ray = rotate(ray, vec3(1.0, 0.0, 0.0), -tau/20.0);\n    ray = rotate(ray, vec3(0.0, 1.0, 0.0), -iTime+tau/2.0);\n    vec3 cam = vec3(sin(iTime)*3.0, 0.75, cos(iTime)*3.0);\n    \n    float tdist;\n    float mdist;\n    bool collision;\n    cam = intersect(cam, ray, collision, tdist, mdist);\n    if(collision){\n        vec3 normal = getnormal(cam-ray*0.001);\n        fragColor = vec4(0.0);\n        for(int j = 0; j < lights.length(); j++){\n            vec3 lightray = normalize(cam-lights[j].xyz);\n            float nlang = max(dot(-lightray, normal), 0.0);\n            fragColor +=\n                vec4(nlang)\n                * lights[j].w\n                * lightcolor[j]\n                * softshadow(cam, -lightray, 0.01, length(cam)*1.0, lightcolor[j].w);\n        }\n    }else{\n\t    fragColor = mix(vec4(0.1), vec4(0.2, 0.2, 0.1, 1.0), exp(-mdist));\n    }\n    fragColor *= (int(fragCoord.y)&2)==0?vec4(1.0):vec4(0.9, 0.9, 1.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2fzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[450, 538, 583, 583, 1211], [1213, 1213, 1258, 1258, 1331], [1332, 1359, 1390, 1390, 1477], [1479, 1479, 1499, 1499, 2173], [2175, 2175, 2200, 2262, 2548], [2550, 2550, 2639, 2639, 3158], [3160, 3160, 3230, 3230, 3451], [3453, 3453, 3510, 3510, 4673]], "test": "untested"}
{"id": "Ml2fzm", "name": "Shaping Exercise", "author": "ircss", "description": "Practicing basic shaping functions. ", "tags": ["vectorart", "shapingexcerises"], "likes": 13, "viewed": 586, "published": "Public API", "date": "1515263240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 PalletToRGB(vec3 col01, vec3 col02, vec3 col03, vec3 col04, vec3 colorToConvert){\n \t\n    vec3 toReturn = col04;\n    toReturn = mix(toReturn, col01, colorToConvert.x);\n    toReturn = mix(toReturn, col02, colorToConvert.y);\n    toReturn = mix(toReturn, col03, colorToConvert.z);\n    \n    return vec4(toReturn, 1.0);\n}\n\n\n\n//  Function from Iigo Quiles\n//  www.iquilezles.org/www/articles/functions/functions.htm\nfloat impulse( in float k, in float x ){\n    float h = k*x;\n    return h*exp(1.0-abs(h));\n}\n\nvoid DrawACircle(inout vec3 color, in vec3 circleColor, in vec2 pos, in vec2 coord, in float radius){\n    float distanceToCenter = distance(coord, pos);\n    \n    color = mix(circleColor, color, step(radius, distanceToCenter));\n    \n}\n\nvoid DrawRectangle(inout vec3 color, in vec3 recantgleColor, in vec2 pos, in vec2 coord, in vec2 dimensions){\n    vec2 distanceVector = abs(coord - pos);\n    float shilloute = step(0.5, (step(dimensions.x, distanceVector.x) +step(dimensions.y, distanceVector.y))/2.0);\n    color = mix(recantgleColor, color, shilloute);\n}\n\n\nvoid DrawClouds( inout vec3 color, in vec3 cloudcolor, in vec2 pos, in vec2 coord,  in vec2 dimensions, in float cloudsHeight){\n    \n    float randomSeed= rand(vec2 (pos.y));\n    \n    float waveyHeight = (sin((coord.x - dimensions.x) * 20.0 ) * pow(coord.x, randomSeed*2.0)/cloudsHeight) + pos.y;\n    vec2 distanceVector = abs(coord - pos);\n    float drawingBox = step(0.5, (step(dimensions.x, distance( coord, vec2(pos.x, pos.y - dimensions.x*0.7))) +\n                                  step(dimensions.y, distanceVector.y))/2.0);\n    \n    float finalLerpFactor =  (1.0 - drawingBox) *  ( 1.0 - step(waveyHeight , coord.y));\n    \n    color = mix(cloudcolor, color, 1.0- finalLerpFactor);\n    \n}\n\nvoid DrawAPole( inout vec3 color, in vec3 poleColor, in vec2 pos, in vec2 coord){\n    \n    DrawRectangle(color, poleColor, vec2(0.0, 0.18), coord ,vec2(6.5, 0.012));\n    \n    for(int i = 0; i<20; i++){\n      DrawRectangle(color, poleColor, vec2(pos.x - 2.0 + float(i)*0.3, pos.y), coord ,vec2(0.026, 0.14));\n    }\n\n    \n    \n}\n\nvoid DrawTwoSidedTriangle(inout vec3 Color, in vec3 toDrawColor, in vec2 pos, in vec2 coord, in float height, in float width){\n \tfloat functionIn = coord.x - pos.x;\n    float heightValue = height * (1.0 - abs(width * functionIn));\n    \n    float shilloute = 1.0 - step((heightValue + pos.y), coord.y);\n    shilloute *=  step(pos.y, coord.y);\n    \n    Color = mix(toDrawColor, Color, 1.0 - shilloute);\n    \n    \n    \n}\n\nvoid DrawACar( inout vec3 color, in vec2 coord){\n    \n    vec3 backColorIn = color;\n    float yOffset = abs( 2.0 * fract(iTime) - 1.0) * 0.010;\n    DrawRectangle(color, vec3(0.14, 0.03, 0.0), vec2(0.6, 0.2+ yOffset), coord ,vec2(0.3, 0.15));\n    DrawRectangle(color, backColorIn, vec2(0.80, 0.28 + yOffset), coord, vec2(0.11, 0.07));\n     DrawRectangle(color, backColorIn, vec2(0.35, 0.31 + yOffset), coord, vec2(0.1, 0.07));\n    \n    \n    DrawTwoSidedTriangle(color, vec3(0.14, 0.03, 0.0), vec2(0.68, 0.21 + yOffset), coord, 0.142, 10.00001);\n    \n    \n    DrawACircle(color, vec3(0.14, 0.03, 0.0), vec2(0.42, 0.06 + yOffset * 1.4), coord, 0.08);\n     DrawACircle(color, vec3(0.14, 0.03, 0.0), vec2(0.78, 0.05 + yOffset * 1.4), coord, 0.08);\n\n    \n    \n}\n\nvoid DrawMountain(in vec2 coord, inout vec3 color, float buttonHeight, vec3 mountainColor, float manualOffset){\n \t\n    float randomSeed= rand(vec2 (buttonHeight));\n    float offset =  sin(coord.x *2.0 +manualOffset + (pow(randomSeed, randomSeed)) )/\n        (14.0 - pow(randomSeed, randomSeed)/10.0) + abs(cos(sin( (fract(cos(coord.x  + pow(randomSeed, randomSeed) ) *2.0 -1.0 )* \n                  (fract(cos(coord.x * randomSeed+ 0.5) * randomSeed * 20.0))*2.0 -1.0))))/ 4.0;\n    \n    float randomTreeHeight = rand(vec2( floor(coord.x *25.0)));\n    float trees = (pow(abs((2.0* fract(coord.x*0.9 * randomTreeHeight * randomSeed))-1.0),2.0))/\n        (20.0- 10.0 * randomTreeHeight  *pow(randomSeed,2.0)) ;\n    \n    float sillhoute = clamp(step(buttonHeight + offset+ trees, coord.y) + step(buttonHeight-0.1, coord.y) -1.0 , 0.0, 1.0);\n    \n    \n    color = mix(mountainColor, color, sillhoute);\n    \n\t     \n    \n}\n\n\n\nvoid DrawMountainGradient(in vec2 coord, inout vec3 color, float buttonHeight, vec3 mountainColor, vec3 color02, float manualOffset){\n \t\n    float randomSeed= rand(vec2 (buttonHeight));\n    float offset =  sin(coord.x *2.0 +manualOffset + (pow(randomSeed, randomSeed * 4.0)) )/\n        (14.0 - pow(randomSeed, randomSeed)/10.0) + abs(cos(sin( (fract(cos(coord.x  + pow(randomSeed, randomSeed) ) *2.0 -1.0 )* \n                  (fract(cos(coord.x * randomSeed+ 0.5) * randomSeed * 20.0))*2.0 -1.0))))/ 4.0;\n    \n    float randomTreeHeight = rand(vec2( floor(coord.x *25.0)));\n    float trees = (pow(abs((2.0* fract(coord.x*0.9 * randomTreeHeight * randomSeed))-1.0),2.0))/\n        (20.0- 10.0 * randomTreeHeight  *pow(randomSeed,2.0)) ;\n    \n    float sillhoute = clamp(step(buttonHeight + offset+ trees, coord.y) + step(buttonHeight-0.1, coord.y) -1.0 , 0.0, 1.0);\n    \n    float gradientFactor =  clamp( coord.y - buttonHeight/ 120.0, 0.0, 1.0);\n    vec3 colorToUse = mix(mountainColor, color02, 1.0 - gradientFactor);\n    \n    color = mix(colorToUse, color, sillhoute);\n    \n\t     \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Settomg up the UV coordinates\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // Declernation\n    \n    vec3 backGround = vec3( abs (2.0 * fract(iTime*0.05) - 1.0), 0.101, 0.270);\n    vec3 color01 = vec3(0.360, 0.2, abs (2.0 * fract(iTime*0.05) - 1.0));\n    vec3 color02 = vec3(abs(cos(iTime/10.0) + cos(iTime*0.8 +2.215)), 0.827, abs( cos(iTime)+ cos(iTime*0.76 +52.21)) );\n    vec3 color03 = vec3(0.8, 0.9, 0.8);\n    \n    vec3 colorToReturn = vec3(0.0, 0.0, 0.0);\n    \n    \n    // Start of the Painting. \n    \n    // Background color \n    \n    float backGroundGradientBlend = impulse( 2.1, uv.y );\n    \n    colorToReturn = backGround + 1.0- backGroundGradientBlend;\n    \n    //Draw Sun \n    \n    DrawACircle(colorToReturn, vec3(0.8, 0.5, 0.9), vec2(1.3, 0.8), uv, 0.2);\n    \n    //Clouds\n    \n    float cloudMovementSpeed = 0.01;\n    \n    DrawClouds( colorToReturn, vec3(0.3, 0.6, 0.7), vec2(0.5, 0.94),\n               vec2(uv.x - 1.5 + 2.4* fract((iTime + 40.0) *cloudMovementSpeed), uv.y),\n               vec2(0.4,0.13), 10.0);\n    \n     DrawClouds( colorToReturn, vec3(0.2, 0.4, 0.6), vec2(1.0, 0.7),\n               vec2(uv.x - 1.0 + 2.4* fract((iTime +18.0 )*cloudMovementSpeed* 0.5), uv.y),\n                vec2(0.7,0.13), 30.0);\n    \n    DrawClouds( colorToReturn, vec3(0.3, 0.6, 0.7), vec2(0.0, 0.8),\n               vec2(uv.x - 2.0 + 2.4* fract(iTime *cloudMovementSpeed * 2.0 ), uv.y),\n                vec2(0.1,0.04), 40.0);\n    \n    \n    \n    \n    //First Mountains\n    \n    float mountainMovementSpeed = 0.3;\n    \n    DrawMountainGradient(vec2(uv.x + iTime * mountainMovementSpeed * 0.2, uv.y),\n                         colorToReturn, 0.3262, vec3(0.1, 0.9, 0.5), vec3(0.1, 0.9, 0.6),0.0);\n    DrawMountainGradient(vec2(uv.x + iTime * mountainMovementSpeed * 0.5, uv.y),\n                         colorToReturn, 0.2, vec3(0.9, 0.5, 0.2), vec3(0.9, 0.5, 0.4), .2);\n    DrawMountainGradient(vec2(uv.x + iTime * mountainMovementSpeed , uv.y),\n                         colorToReturn, 0.0433, vec3(0.9, 0.1, 0.0), vec3(0.9, 0.1, 0.3),1.8);\n        \n    \n    // Telephone Poles\n    \n    float poleMovementSpeed= 1.6;\n    \n    DrawAPole(colorToReturn, vec3(0.03, 0.3, 0.0), vec2(0.2, 0.07),\n              vec2(uv.x + 2.0 *fract(iTime) -1.0, uv.y) );\n    \n    // Draw The Car \n    \n    DrawACar(colorToReturn, uv);\n    \n    \n   \n    \n    \n\tfragColor = PalletToRGB(color01, color02, color03, backGround, colorToReturn);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2fzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 93], [95, 95, 181, 181, 415], [419, 511, 551, 551, 602], [604, 604, 705, 705, 837], [839, 839, 948, 948, 1160], [1163, 1163, 1290, 1290, 1857], [1859, 1859, 1940, 1940, 2185], [2187, 2187, 2313, 2313, 2604], [2606, 2606, 2654, 2654, 3361], [3363, 3363, 3474, 3474, 4278], [4282, 4282, 4415, 4415, 5372], [5375, 5375, 5432, 5469, 7864]], "test": "untested"}
{"id": "MlBBWm", "name": "Road02", "author": "nslottow", "description": "Iterating on the hacked Road01 from yesterday.", "tags": ["raymarching", "road"], "likes": 11, "viewed": 594, "published": "Public API", "date": "1515994516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 16.0;\n\n\n\n// Maps a position in the world to a position on the road\n\nvec3 pos_road_map(vec3 pos)\n{\n\tfloat z = pos.z;\n\n\tfloat x = pos.x +\n\t\t0.4 * cos(z * 0.1) +\n\t\t1.2 * cos(z * 0.01) +\n\t\t3.0 * sin((z + pos.x) * 0.01);\n\n\tfloat y =\n\t\t1.3 * cos(z * 0.007) * sin(z * 0.08) +\n\t\t0.25 * sin(z * 0.03 + 0.3) +\n\t\t0.1 * cos(x * 0.0348 + 0.24) +\n\t\t0.3 * sin(x * 0.1 + z * 0.2);\n\n\treturn vec3(x, y, z);\n}\n\nvec3 normal_road_map(vec3 pos)\n{\n\tconst float eps = 0.02;\n\n\tvec3 dir_z = pos_road_map(vec3(pos.xy, pos.z - eps)) - pos_road_map(vec3(pos.xy, pos.z + eps));\n\tvec3 dir_x = pos_road_map(vec3(pos.x - eps, pos.yz)) - pos_road_map(vec3(pos.x + eps, pos.yz));\n\tvec3 normal = cross(dir_z, dir_x);\n\n\treturn normalize(normal);\n}\n\nvec3 col_road_map(vec3 pos)\n{\n\tvec3 normal = normal_road_map(pos);\n\n\tvec3 dir_light = normalize(vec3(\n\t\t0.5,\n\t\t1.0 + sin(iTime * 0.134),\n\t\t4.0 * (1.0 + cos(iTime * 0.1))));\n\n\tfloat mix_light = clamp(dot(normal, dir_light), 0.0, 1.0);\n\tvec3 col_light = vec3(0.9, 0.75, 0.3);\n\n\tvec3 col_stripe = vec3(0.2);\n\tfloat mix_stripe = step(2.0, mod(pos.z, 4.0)) * 0.1;\n\n\tvec3 col_ground = vec3(0.135, 0.2, 0.1) +\n\t\tcol_stripe * mix_stripe +\n\t\tcol_light * mix_light;\n\n\tfloat midline = abs(pos_road_map(pos).x);\n\n\tfloat mix_road = 1.0 - smoothstep(0.0, 0.01, pow(midline, 16.0));\n\tvec3 col_road = vec3(0.2, -0.1, 0.2);\n\tcol_ground = mix(col_ground, col_road, mix_road * 0.7);\n\n\tfloat mix_line = (1.0 - smoothstep(0.0, 0.0005, pow(midline, 2.5))) * smoothstep(0.2, 0.3, abs(mod(pos.z, 1.5))-0.75);\n\tvec3 col_line = vec3(0.7, 0.7, 0.7);\n\tcol_ground = mix(col_ground, col_line, mix_line * 0.7);\n\n\treturn col_ground;\n}\n\nvec3 col_sky(vec2 dxy_frag)\n{\n    vec2 uv = dxy_frag.xy / iResolution.xy;\n    return vec3(0.4, 0.6, 0.9 * uv.y);\n}\n\nbool intersect_ray_road(vec3 pos_origin, vec3 dir, out vec3 pos_intersect)\n{\n\tconst float t_min = 0.001;\n\tconst float t_max = 100.0;\n\tconst float dt = 1.0;\n\tfloat y_road = 0.0;\n\tfloat y_ray = 0.0;\n\n\tfor (float t = t_min; t < t_max; t += dt)\n\t{\n\t\tvec3 pos_ray = pos_origin + dir * t;\n\t\tvec3 pos_road = pos_road_map(pos_ray);\n\t\tif (pos_ray.y < pos_road.y)\n\t\t{\n\t\t\t// interpolate to the value of t where the ray actually intersects\n\t\t\t// the road\n\t\t\t\n\t\t\tt = (t - dt) + dt * (y_road - y_ray) / ((pos_ray.y - y_ray) - (pos_road.y - y_road));\n\n\t\t\tpos_intersect = pos_origin + dir * t;\n\t\t\treturn true;\n\t\t}\n\t\ty_road = pos_road.y;\n\t\ty_ray = pos_ray.y;\n\t}\n\n\treturn false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tconst float fov = radians(50.0);\n\tconst float tan_hfov = tan(fov * 0.5);\n\tconst float near = 0.1;\n\tconst float far = 1.0;\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n\tvec3 pos_road_cam = pos_road_map(vec3(0, 0, speed * iTime));\n\n\tfloat len_car = 1.5;\n\tfloat h_car = 0.5;\n\n\tfloat x_next = -pos_road_map(vec3(0, 0, speed * iTime + len_car * 4.0)).x;\n\n\tvec3 pos_cam = vec3(\n\t\t0.35-pos_road_cam.x,\n\t\tpos_road_cam.y + h_car,\n\t\tpos_road_cam.z - len_car);\n\n\tfloat swivel = (x_next - pos_cam.x) * 0.07;\n\n\tvec3 dir_ray = normalize(\n\t\tvec3(\n\t\t\ttan_hfov * uv.x + swivel,\n\t\t\ttan_hfov * uv.y - 0.05,\n\t\t\t1.0)\n\t\t* (far - near));\n\t\n\n\tvec3 pos_intersect;\n\tif (intersect_ray_road(pos_cam, dir_ray, pos_intersect))\n\t{\n\t\tfragColor = vec4(col_road_map(pos_intersect), 1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(col_sky(fragCoord.xy), 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 88, 117, 117, 410], [412, 412, 444, 444, 730], [732, 732, 761, 761, 1634], [1636, 1636, 1665, 1665, 1750], [1752, 1752, 1828, 1828, 2414], [2416, 2416, 2471, 2471, 3314]], "test": "untested"}
{"id": "MlBBWy", "name": "Harmonics", "author": "lookezen", "description": "test", "tags": ["circles"], "likes": 2, "viewed": 86, "published": "Public", "date": "1516994005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool cirOL(vec2 center, float rad)\n{\n    return(length(center) < rad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 col1 = vec4( 0., 0, 0., 1.);\n    float f = abs(sin(iTime * 0.02));\n    int counter = 0;\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float c2 = 0.;\n    for(float i = -2.; i < 2.; i += 0.05)\n    { \t\n        c2+= 10.;\n        vec2 temp = r;\n        temp.x += i;\n        temp.y += sin(c2 * (iTime /400.));\n        if(cirOL(temp, f)){ counter += 1; }\n    }\n    \n    if(counter % 2 == 0)\n    {\n    \tcol1.r = (float(counter) / 28.);\n    \tcol1.g = (float(counter) / 28.);\n    \tfragColor = col1;\n    }\n    \n    else\n    {\n\t\tcol1.r = (float(counter) / 28.);\n    \tcol1.b = 1. - (float(counter) / 28.);\n    \tfragColor = col1;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBBWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 72], [74, 74, 131, 131, 792]], "test": "untested"}
{"id": "MlBfDh", "name": "graprog_ilas", "author": "ilaschino", "description": "activity 1", "tags": ["graprogact1"], "likes": 6, "viewed": 70, "published": "Public", "date": "1515553376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 color(){\n  \tvec4 color1 = vec4(1,0,0,0);\n    vec4 color2 = vec4(0.79,0.55,0.52,0.97);\n    float num1 = 1.0 * (((sin(4.0 *iTime) + 1.0) / 2.0));\n    float num2 = 0.60 * (((sin(0.5 *iTime) + 3.0) / 5.0));\n    float num3 = 0.93 * (((sin(4.0 *iTime) + 2.0) / 7.0));\n    \n    \n \treturn vec4(num1,num2,num3,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    fragColor = color();\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBfDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 13, 13, 311], [313, 313, 370, 462, 498]], "test": "untested"}
{"id": "MlBfWG", "name": "Nuagedebeaute", "author": "lucadb", "description": "Light noise", "tags": ["lightnoise"], "likes": 2, "viewed": 120, "published": "Public", "date": "1516984385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat noise( vec2 co ) {\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime*0.2\n        ;\n\n    float u_brightness = 1.2;\n    float u_blobiness = 1.0;\n    float u_particles = 100.0;\n    float u_limit = 70.0;\n    float u_energy = 0.75 * 5.0;\n\n    vec2 position = fragCoord.xy / iResolution.xy;\n\n    float t = time * u_energy;\n\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    vec2 pos;\n\n    //float aspect = (iResolution.x / iResolution.y) ;\n\n    vec2 center = vec2( 0.5, 0.5 );\n\n    float na, nb, nc, nd, d;\n    float limit = u_particles / u_limit;\n    float step = 1.0 / u_particles;\n    float n = 0.0;\n\n    for ( float i = 0.0; i <= 1.0; i += 0.025 ) {\n\n        if ( i <= limit ) {\n\n            vec2 np = vec2(n, 1-1);\n\n            na = noise( np * 1.1 );\n            nb = noise( np * 2.8 );\n            nc = noise( np * 0.7 );\n            nd = noise( np * 3.2 );\n\n            pos = center;\n            pos.x += sin(t*na) * cos(t*nb) * tan(t*na*0.15) * 0.3;\n            pos.y += tan(t*nc) * sin(t*nd) * 0.1;\n\n            d = pow( 1.6*na / length( pos - position ), u_blobiness );\n\n            if ( i < limit * 0.3333 ) a += d;\n            else if ( i < limit * 0.5 ) b += d;\n            else c += d;\n\n            n += step;\n        }\n    }\n\n    vec3 col = vec3(a*b,a*b,a*b) * 0.0001 * u_brightness;\n\n    fragColor = vec4( col, 0.25 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 106], [108, 108, 165, 165, 1468]], "test": "untested"}
{"id": "MljBDD", "name": "12/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I tried to do some kind of voronoi thing. Inspiration is again from https://thebookofshaders.com/ and Iq's articles.", "tags": ["voronoi", "dailyshader"], "likes": 3, "viewed": 102, "published": "Public", "date": "1515888727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec2  Hash22F(vec2  p ){\n    vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); \n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.xx   + p3.yz  ) * p3.zy  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Tiling space..\n    vec2 q = uv *9.0;\n    vec2 f = fract(q);\n    vec2 i = floor(q);\n    \n    float t = 100.0;\n    \n    vec2 n[9];  \n    n[0] = vec2(-1.0, -1.0);\n    n[1] = vec2(-1.0,  0.0);\n    n[2] = vec2(-1.0,  1.0);\n    n[3] = vec2(0.0,  -1.0);\n    n[4] = vec2(0.0,   0.0);\n    n[5] = vec2(0.0,   1.0);\n    n[6] = vec2(1.0,  -1.0);\n    n[7] = vec2(1.0,   0.0);\n    n[8] = vec2(1.0,   1.0);\n    \n    for(int it = 0; it < 9; ++it){\n        vec2 p = Hash22F(i+n[it]);\n        p = (1.0+sin(iTime*0.5 + 2.0*PI*p))*0.5;\n        float d = length(n[it]+p-f);\n        t = min(t, d);\n    }\n    \n    vec3 col = vec3(0.8, 0.6, 0.2) * vec3(t);\n    col += vec3(0.2, 0.3, 0.7);\n    col *= 0.75;\n    col = smoothstep(0.2, 0.8, col);\n    \n    col = pow(col, 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 126, 150, 150, 286], [289, 289, 346, 346, 1193]], "test": "untested"}
{"id": "MljBDh", "name": "Swirly Sky", "author": "Brendan", "description": "Blue, distorted fbm noise! Used as the sky in my sin Terrain shader: https://www.shadertoy.com/view/4tjfWz", "tags": ["noise"], "likes": 2, "viewed": 179, "published": "Public", "date": "1515638737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//noise and rand2 function from thebookofshaders.com\nfloat rand2 (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand2(i);\n    float b = rand2(i + vec2(1.0, 0.0));\n    float c = rand2(i + vec2(0.0, 1.0));\n    float d = rand2(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p){\n\tfloat f = 0.0;\n    f+=0.5*noise(p); p*=2.03;\n    f+=0.25*noise(p); p*=2.03;\n    f+=0.125*noise(p); p*=2.03;\n    f+=0.0625*noise(p); p*=2.03;\n    f+=0.03125*noise(p); p*=2.03;\n    f+=0.015625*noise(p); p*=2.03;\n    f/=0.984325;\n    return f;\n}\n\nmat2 rotate(float p){\n\treturn mat2(\n    \tcos(p),sin(p),\n        -sin(p),cos(p)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv *2.0 -1.0;\n    \n    uv.x*= iResolution.x/iResolution.y;\n    \n    vec2 p = uv;\n    \n    mat2 m=rotate(fbm(p+iTime));\n    \n    p*=m;\n    \n    float n=fbm(p*3.0);\n    \n    n=abs(n);\n    \n    //n = pow(n,2.0);\n    \n    vec3 fc = vec3(n);\n    \n    fc*=vec3(0.1,0.6,0.8);\n    \n    //vignette\n    \n    float f = length(uv);\n    \n    \n    float c=smoothstep(2.5,0.8,f);\n    \n    fc*=c;\n    \n    \n    \n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljBDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 79, 79, 196], [198, 198, 224, 224, 659], [661, 661, 679, 679, 923], [925, 925, 946, 946, 1012], [1014, 1014, 1071, 1071, 1557]], "test": "untested"}
{"id": "MljBDm", "name": "Pattern01162018b", "author": "edapx", "description": "patterns", "tags": ["2d", "patterns", "flowers"], "likes": 1, "viewed": 65, "published": "Public", "date": "1516137533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n#define TWO_PI 6.28318530718\n\n// Utilities\nfloat strokeSmoot(float x, float pos, float width){\n  return smoothstep(pos, pos+0.01,x+ width*0.5) -\n         smoothstep(pos, pos+0.01,x- width*0.5);\n}\n\nfloat circle(vec2 st, float diameter){\n  return length(st - 0.5) * diameter;\n}\n\nfloat flip(float v, float pct){\n  return mix(v, 1. - v, pct);\n}\n\nfloat fill(float sdfVal, float size){\n  return smoothstep(size, size+0.02,sdfVal);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat quadrifoglio (vec2 st, float diameter, float utime, float speed, float tickness){\n  float time = utime * speed;\n  float offset = .25;\n  float cross = 2.1;\n  float petalsDist = .24;\n  float petalsThickA = -.019 + abs(cos(time * 9.) * tickness);\n  float petalsThickB = -.019 + abs(sin(time * 4.5) * tickness);\n  \n  float center = circle(st, diameter);\n\n  vec2 petAcen = st-vec2(offset, offset);\n  float radiusA = length(petAcen);\n  float petA = circle(petAcen,radiusA*cross);\n\n  vec2 petBcen = rotate2d(TWO_PI/4.) * petAcen;\n  petBcen -= vec2(0., -.5);\n  float radiusB = length(petBcen);\n  float petB = circle(petBcen,radiusB*cross);\n\n  float petals = strokeSmoot(petA, petalsDist,petalsThickA);\n  petals += strokeSmoot(petB, petalsDist,petalsThickB);\n\n  float color = flip(petals,\n                fill(center, .155));\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 blueCol = vec3(0.001,0.381,0.905);\n    vec3 redCol = vec3(0.905,0.283,0.046);\n    vec3 greenCol = vec3(0.683,0.912,0.067);\n    float timeFreq = 0.15;\n    float timeAmp = 1.2;\n    float ampMov = 4.;\n    float zoom = 3.;\n    \n\tvec2 st = fragCoord.xy / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    st *= rotate2d(TWO_PI/3.);\n    // tiling & offset\n    st *=zoom;\n    st.x += step(1.0, mod(st.y,2.0)) * 0.5;\n    st = fract(st);\n    \n    \n    // Flower red\n    float mov = sin(st.x);\n    float thick = 0.1;\n\n    float draw = quadrifoglio(\n      st, 1.9,\n      sin(iTime*timeFreq)*7.2,\n      (mov*ampMov),\n      thick);\n    \n    vec3 col = mix(redCol, greenCol, draw);\n    \n    // Flower green\n    float mov2 = sin(exp(st.y));\n    float thick2 = 0.484;\n\n    float draw2 = quadrifoglio(\n      st, 1.9,\n      sin(iTime*timeFreq)*timeAmp,\n      (mov2*ampMov),\n      thick2);\n    \n    // Sum\n    col = mix(col, blueCol, draw2);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljBDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 88, 139, 139, 240], [242, 242, 280, 280, 320], [322, 322, 353, 353, 385], [387, 387, 424, 424, 471], [473, 473, 501, 501, 587], [589, 589, 676, 676, 1429], [1432, 1432, 1488, 1488, 2467]], "test": "untested"}
{"id": "MljfRd", "name": "polar 2 ( 153 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["2tweets", "short", "golfing"], "likes": 8, "viewed": 415, "published": "Public API", "date": "1516911746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/MljBzt\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O.a = length( O.xy = u+u - iResolution.xy) / 30. ;\n    O += 5.* max( cos( 6.3*O ), cos( 9.* (atan(O.x,O.y) -iTime *floor(O-5.) ) * exp2(floor(log2(O))) )).a - 4. -O; }\n\n\n        \n/** // 155 chars\n\n#define mainImage(O,u)                                       \\\n    float l = length( O.xy = u+u - iResolution.xy) / 30. ;   \\\n    O += 5.* max( cos( 6.3*l ), cos( 9.* (atan(O.x,O.y) -iTime *floor(l-5.) ) * exp2(floor(log2(l))) )) - 4. -O\n\n/**/\n  \n  \n        \n        \n/** // 167 chars\n\n#define mainImage(O,u)                  \\\n    vec2 R = iResolution.xy,            \\\n         U = u+u - R;                   \\\n    float l = 10.* length(U) / R.y,     \\\n          a = atan(U.x,U.y) - iTime *floor(l-5.); \\\n    O += 9.* max( cos( 6.3*l ), cos( 9.*a * exp2(floor(log2(l))) )) - 8.\n        \n/**/\n  \n  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljfRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 85, 85, 257]], "test": "untested"}
{"id": "MljfRt", "name": "Psychedelic Skyscrapers", "author": "nr4", "description": "Where do those wavey artifacts come from? Ideas welcome. Raymarching beginner here :)", "tags": ["raymarching", "perlin", "buggy"], "likes": 2, "viewed": 148, "published": "Public", "date": "1516899578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** Buggy Psychedelic Skyscraper Shader\n    Copyright (C) 2017  Alexander Kraus <nr4@z10.info>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#define AA 1\n\n#define T .5\n\nconst vec2 c = vec2(1.,0.);\nconst float pi = 3.14159;\n\n#define rand(a0) fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453)\n#define blend(a) ((6.*a-15.)*a+10.)*a*a*a\n#define interpolate(d,w00,w10,w01,w11) mix(mix(w00,w10,blend(d.x)),mix(w01,w11,blend(d.x)),blend(d.y))\n\nvec2 g2d(vec2 x, float seed)\n{\n    return vec2(-1.)+2.*vec2(rand(x+vec2(seed+2., seed+1.)), rand(x+vec2(seed+3.,seed+4.)));\n}\n\nfloat perlin2d(vec2 x, float seed)\n{\n    return interpolate(fract(x),\n                       dot(g2d(floor(x), seed), fract(x)), \n                       dot(g2d(floor(x).xy+c.xy, seed), fract(x).xy-c.xy), \n                       dot(g2d(floor(x).xy+c.yx, seed), fract(x).xy-c.yx), \n                       dot(g2d(floor(x).xy+c.xx, seed), fract(x).xy-c.xx));\n}\n\nfloat mfperlin2d(vec2 x, float seed, float fmin, float fmax, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = fmin; f<fmax; f = f*2.)\n    {\n        sum = a*perlin2d(f*x, seed) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\n#define Rx(x) mat3(c.xyyy, cos(x), sin(x), 0., -sin(x), cos(x))\n#define Ry(x) mat3(cos(x), 0., -sin(x), c.yxy, sin(x), 0., cos(x))\n#define Rz(x) mat3(cos(x), sin(x), 0., -sin(x), cos(x), c.yyyx)\n#define rotate(a,a0) Rz(-(a0).z)*Ry(-(a0).y)*Rx(-(a0).x)*(a)\n\n#define sphere(a,a0,a1) vec2(length(a)-(a0),a1)\n#define box(a,a0,a1) vec2(length(max(abs(a)-(a0),0.)),a1)\n#define plane(a,a0,a1) vec2((a).z-(a0),a1)\n\n#define repeat(a,a0) mod(a,a0)-.5*a0\n#define add(a,a0) mix(a0,a,step((a).x,(a0).x))\n#define sub(a,a0) mix(a0,a,step((a).x,-(a0).x))\n\nvec2 scene(vec3 x)\n{\n    vec2 sdf = c.xy;\n    x+=c.yxy*iTime;\n    \n    sdf = add(sdf, plane(x,-.0,1.));\n    vec3 y  = vec3(mod(x.xy,vec2(.5,.5)),x.z)-.25*c.xxy;\n    vec3 index = x-y;\n    \n    float color = 1.+ceil(3.*rand(index.xy));\n    \n    float height = 1.+.8*sin(length(index.xy))+abs(mfperlin2d(index.xy, 0., 1.e0, 1.e2, .3));\n    height -= mod(height, .1);\n    float width = .1+.06*rand(index.xy);\n\tsdf = add(sdf, box(y, vec3(width, width, height), color));\n    \n    float guard = -box(y, vec3(.25,.25,10.), -1.).x;\n    guard = abs(guard)+.5*0.1;\n    sdf.x = min(sdf.x, guard);\n    \n    return sdf;\n}\n\nconst float tmax = 100.;\nconst int nmax = 364;\nconst float epsilon = 5.e-4;\nvec2 intersect(in vec3 origin, in vec3 direction, out vec3 intersection)\n{\n    float t = 0.;\n    for(int i=0; i<nmax; ++i)\n    {\n        intersection = origin+t*direction;\n        vec2 sc = scene(intersection);\n        if(sc.x<epsilon*t)return vec2(t,sc.y);\n        t+=sc.x;\n        if(t>tmax)return vec2(tmax, -1.);\n    }\n    return vec2(tmax,-1.);\n}\n\nconst float dx = 5.e-4;\nvec3 normal(vec3 x)\n{\n    float sc = scene(x).x;\n    return normalize(vec3(scene(x+dx*c.xyy).x-sc, scene(x+dx*c.yxy).x-sc, scene(x+dx*c.yyx).x-sc));\n}\n\nvec3 colorize(vec3 origin, vec3 intersection, float material)\n{\n    if(material < 0.) return c.yyy;\n    vec3 color = c.yyy;\n    vec3 n = normal(intersection);\n    \n    vec3 light = 5.*c.yyx;\n    vec3 l = normalize(light-intersection);\n    \n    float height = .4;//1.+.4*sin(2.*pi*iTime/T-2.*pi*length(intersection.xy)/10.);\n    \n    if(material <= 1.)//mountain color\n    {\n        color += .2*c.xxx;\n        color += vec3(0.,0., 60./255.)*dot(l,n);\n        if(intersection.z>.1)\n        {\n        \tvec3 r = normalize(reflect(-l,n));\n        \tvec3 v = normalize(origin-intersection);\n            vec3 glow = mix(vec3(.6,.2,0.),.4*c.yxy, .5+.5*sin(3.*iTime));\n            color += 2.e0*glow*pow(dot(r,v),6.);\n        }\n    }\n    else if(material <= 2.)//skyscraper color I\n    {\n        vec3 lower = vec3(66.,242.,143.)/255., upper = vec3(49., 1., 1.)/255.;\n       \n        color += 1.5*mix(lower, upper, 1.-intersection.z/height+ceil(sin(pi*100.*intersection.z)))*dot(l,n);\n    }\n    else if(material <=3.)//skyscraper color II\n    {\n        vec3 lower = vec3(235.,177.,78.)/255., upper = vec3(195., 22., 104.)/255.;\n        color += 1.5*mix(lower, upper, 1.-intersection.z/height+ceil(sin(pi*100.*intersection.z)))*dot(l,n);\n    }\n    else if(material <=4.)//skyscraper color III\n    {\n        vec3 lower = vec3(201.,177.,95.)/255., upper = c.yyx;\n        color += 1.5*mix(lower, upper, 1.-.6*intersection.z/height+ceil(sin(pi*100.*intersection.z)))*dot(l,n);\n    }\n    \n    //fog colors\n    vec3 fog_color1 = .4*c.xxx;\n    vec3 fog_color2 = .4*c.xxx; \n    //color = mix(color, fog_color2, clamp(2.-15.*intersection.z,0.,1.));\n    //color = mix(color, fog_color1,  clamp(.2-1.*intersection.z,0.,1.));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray_origin = 2.5*c.yyx;\n    vec3 ray_target =vec3(0.,2.5,.5);\n    vec3 camera_right = c.xyy;\n    vec3 camera_up = normalize(cross(ray_target-ray_origin, -camera_right));\n    \n    vec3 color=c.yyy;\n    \n#if AA!=1\n    for(int i=0; i<AA; ++i)\n    \tfor(int j=0; j<AA; ++j)\n        {\n            vec2 o = vec2(float(i),float(j)) / float(AA) - 0.5;\n        \tvec2 p = (-iResolution.xy + 2.*(fragCoord+o))/iResolution.y;\n#else \n            vec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\n    \n#endif\n    \t\tvec3 ray_direction = normalize(ray_target+p.x*camera_right+p.y*camera_up-ray_origin);        \n            \n            vec3 intersection;\n            vec2 mat_t = intersect(ray_origin, ray_direction, intersection);\n            \n            color +=colorize(ray_origin, intersection, mat_t.y);\n#if AA!=1\n        }\n    color/=float(AA*AA);\n#else\n#endif\n    \n    fragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljfRt.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[0, 1054, 1084, 1084, 1179], [1181, 1181, 1217, 1217, 1540], [1542, 1542, 1615, 1615, 1797], [2339, 2339, 2359, 2359, 2946], [3024, 3024, 3098, 3098, 3375], [3401, 3401, 3422, 3422, 3551], [3553, 3553, 3616, 3616, 5279], [5281, 5281, 5338, 5338, 6245]], "test": "untested"}
{"id": "Mljfzm", "name": "bouncy circle", "author": "vantreeseba", "description": "bouncy circle", "tags": ["animation"], "likes": 0, "viewed": 75, "published": "Public", "date": "1515194198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 drawCircle(vec2 center, float radius) {    \n\tfloat d = length(center - gl_FragCoord.xy);    \n\tfloat c = 1. - smoothstep(radius - 1., radius + 1., d);\n    \n    vec3 col = vec3(1., 1., 0.5) * c;\n    \n    return vec4(col,  c);\n}\n\nvec3 drawRectangle(vec4 coords) {\n    vec3 color = vec3(0);\n    vec2 fc = gl_FragCoord.xy;\n    \n    if(fc.x > coords.x && fc.x < coords.z && fc.y > coords.y && fc.y < coords.w) {\n        color = vec3(1., 0, 0);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{    \n\tfloat st = (1. + sin(iTime));\n    float ct = (1. + cos(iTime * 2.));\n    vec2 uv = fragCoord.xy / iResolution.xy;\t        \n    \n    vec4 color = vec4(0, 0, 0, 1.);\n    \n    \n    vec4 circle = drawCircle(vec2(iResolution.x / 2.  * st, 150. + 100. * ct), 100.);\n    color += circle;\n    \n    vec3 rect = drawRectangle(vec4(50., 50., 100., 100.));\n    color += vec4(rect, 1.0);\n    \n   \n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mljfzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 230], [232, 232, 265, 265, 473], [475, 475, 531, 531, 950]], "test": "untested"}
{"id": "MlSBDm", "name": "brick arches raymarch", "author": "benhardy", "description": "Generating stone brick arches", "tags": ["raymarch", "architecture"], "likes": 13, "viewed": 274, "published": "Public", "date": "1516195773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 ORIGIN = vec3(0,0,0);\n\n#define MAX_STEP 1000\n#define MAX_DIST 200.0\n#define STEP_RATIO 0.25\n#define EPSILON 0.001\n\n// really it's a bowl\n\n#define PI 3.141592654\n\n//shadows *really* slow things down\n#define SHADOWS\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float power;\n};\n\nLight light_1 = Light(vec3(1000,3000,2000), vec3(1,1,1), 10000000.0);\nLight light_2 = Light(vec3(-3000,1000,-2000), vec3(1,1,0.5), 10000000.0);\n\nfloat measure_to_building(vec3 global_where) {\n    vec3 local_where = mod(global_where - vec3(25,0,25), 80.0);\n    vec3 bl = abs(local_where) - vec3(40,20,40);\n    return length(max(bl, ORIGIN));\n}\n\nfloat measure_to_ground(vec3 where) {\n    return where.y;\n}\n\nfloat round_edge(float dist_1, float dist_2, float radius) {\n    float edge = length(vec2(dist_1, dist_2));\n    return min(edge -radius, max(dist_1 -radius, dist_2 - radius));\n}\n\nfloat torus(vec3 where, float major, float minor) {\n  vec2 q = vec2(length(where.xy) - major, where.z);\n  return length(q) - minor;\n}\n\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n/**\n * return polar vector of (angle, radius)\n */\nvec2 to_polar(vec2 where) {\n    return vec2(atan(where.x, where.y), length(where));\n}\n\n/** centred modulo */\nfloat cmod(float x, float m) {\n    return mod(x + m/2.0, m) - m/2.0;\n}\n\nfloat round_box(vec2 where, vec2 dims, float rounding) {\n    return length(max(abs(where) - dims, 0.0)) - rounding;\n}\nfloat round_box_3(vec3 where, vec3 dims, float rounding) {\n    return length(max(abs(where) - dims, 0.0)) - rounding;\n}\n#define united min\n#define intersect max\n#define difference(a,b) max((a), -(b))\n\nfloat interesting_shape(vec3 where_in) {\n    float repetition = 6.2;\n    float room_size = 62.0;\n    where_in.z = abs(abs(cmod(where_in.z, room_size))-3.1);\n    where_in.x = abs(cmod(where_in.x, room_size));\n   //where_in = abs(where_in);\n    \n    //where_in.xz = mod(where_in.xz, repetition*10.0);\n    vec3 where = where_in;\n    if (where_in.z > where_in.x) {\n        where.x = where_in.z;\n        where.z = where_in.x;\n    }\n    //= where_in;// vec3(min(where_in.x,where_in.z),where_in.y,max(where_in.x,where_in.z));\n    /*\n    vec3 where = vec3(\n        where_in.z > where_in.x ? where_in.z : where_in.x,\n        where_in.y - 3.0,\n        where_in.z > where_in.x ? where_in.x : where_in.z\n\t);*/\n    where.x -= repetition /2.0;\n    where.y -= 8.0;\n    float wall_thickness = 0.6;\n    float front = where.z - wall_thickness * 0.5;\n    float top = where.y - 8.0;\n    float wall = intersect(front, top);\n\n    float hole_radius = 4.3;\n\twhere.x = abs(cmod(where.x, repetition));\n    float hx = where.x+hole_radius/2.0;\n    float hole_round = length(vec2(hx, max(0.0,where.y))) - hole_radius;\n    float hole_lower = intersect(hx, where.y);\n    float hole_total = united(hole_round, hole_lower);\n    \n    float main = difference(wall, hole_total);\n    vec2 edge_bulk = vec2(0.0, 0.0);\n    float rounding = 0.1;\n    float hole_edge = round_box(vec2(wall, -hole_total), edge_bulk, rounding);\n    //return max(where.z-1.0,edge);\n    \n    //float more = round_box(vec2(hole_edge, main), vec2(0.1,0.4), 0.05);\n    float borf = united(main, hole_edge);\n    \n    float segments = 24.0;\n    float angular_mod = 1.0 * PI / segments;\n    where.x += hole_radius /2.0;\n    vec2 polar_pos = to_polar(vec2(where.x, where.y));\n    float radius = (where.y>0.0) ? polar_pos.y : where.x;\n    radius -= (hole_radius -0.25);\n    float angle = (where.y>0.0) ? 2.0*cmod(polar_pos.x, angular_mod) \n        : cmod(where.y/PI*2.0, PI*2.0/segments);\n    vec3 block_dim = vec3(0.2, 0.1, 0.8);\n    vec3 on_block = vec3(radius, angle, where.z+0.4);\n    float brick_rounding = 0.037;\n    float brick = round_box_3(on_block, block_dim, brick_rounding);\n    float ebrick = brick;\n    float column = intersect(where.y-30.0,length(where_in.zx)-1.0);\n    return united(column,united(borf, ebrick));\t\n}\n\n\nvec2 closest(vec2 best, vec2 next) {\n    return (best.x < next.x) ? best : next;\n}\n\nvec3 measure(vec3 where) {\n    vec2 res = vec2(measure_to_ground(where), 1.5);\n//    res = closest(res, vec2(measure_to_building(where), 6.5));\n    float interesting = interesting_shape(where);\n    res = closest(res, vec2(interesting, 7.5));\n    return vec3(res, interesting);\n}\n\n/**\n * iq's soft shadow algo\n */\nfloat soft_shadow( in vec3 start, in vec3 ray, float min_dist, float max_dist, float k )\n{\n    float res = 1.0;\n    for( float t=min_dist; t < max_dist; )\n    {\n        vec2 h = measure(start + ray * t).xy;\n        if( h.x < EPSILON )\n            return 0.0; // hit something.\n        res = min( res, k * h.x / t);\n        t += h.x;\n    }\n    return res;\n}\n\n/**\n * currently just used for shadows\n * returns how far we went, and how close we came to hitting anything\n */\nvec2 trace_for_shadow(vec3 start, vec3 ray, float max_dist) {\n    vec3 where = start;\n    float total_dist = 0.0;\n    int steps = 0;\n    vec2 current;\n    float closest = max_dist + 1.0;\n    for (int steps = 0; steps < MAX_STEP; steps++) {\n        vec2 current = measure(where).xy;\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            return vec2(total_dist, current_dist);\n        }\n        \n        if (current_dist < closest) {\n            closest = current_dist;\n        }\n\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > max_dist) {\n            break;\n        }\n        where = start + total_dist * ray;\n    }\n    return vec2(max_dist, closest);\n}\n\nvec2 calculate_lighting(in Light light, vec3 ray, vec3 hit, vec3 surface_normal, float specular) {\n        // how much illumination is the hit surface getting from light 1?\n        vec3 hit_to_light = light.position - hit;\n        vec3 nhit_to_light = normalize(hit_to_light);\n        vec3 reflected = reflect(nhit_to_light, surface_normal);\n\t\tspecular *= pow(max(0.0, dot(ray, reflected)), 16.0);\n        float length_to_light = length(hit_to_light);\n        float light_angle = max(0.0, dot(surface_normal, nhit_to_light));\n        float illum = light.power * light_angle \n            / (1.0 + pow(length_to_light, 2.0));\n        \n        // but wait, is it shadowed?\n        #ifdef SHADOWS\n        if (light_angle > 0.0) {\n            float shadow = soft_shadow(hit, nhit_to_light, EPSILON*2.0, length_to_light, 8.0);\n            illum *= shadow;\n        }\n        #endif\n    return vec2(illum, specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(0.0), 1.0);\n\tvec2 screen_pos = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_at= vec3(0,6,0);\n    vec3 up = vec3(0,1,0);\n    vec3 eye = vec3(sin(iTime*0.1)*20.0+5.0,\n                    sin(iTime*0.13)*2.0+3.0,\n                    cos(iTime*0.1)*10.0+5.0);\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 ray = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    \n    vec3 p_normal = vec3(0,1,0);\n    float p_dist = 0.0;\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec3 current;\n    for(int steps =0;steps < MAX_STEP; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\tvec3 hit = where;\n\n    vec3 base_color = vec3(0,0,0);\n    vec3 paint = vec3(0,0,0);\n    int who = (total_dist < MAX_DIST) ? int(current.y) : 0;\n\n    // add glow for white light\n    vec3 eye_to_light_1 = light_1.position - eye;\n    float dp_1 = dot(ray, normalize(eye_to_light_1));\n    if (dp_1 > 0.0 && length(eye_to_light_1) < total_dist) {\n    \tvec3 short_1 = eye_to_light_1 * dp_1;\n        float diff = length(eye_to_light_1 - short_1);\n\t    //float light_1_dist =  diff / dp_1;\n\t    base_color += light_1.color * (0.0001 * (dp_1*dp_1) / (diff *diff));\n    }\n\t// did we hit anyone?\n    if (who > 0) {\n        float specular = 0.0;\n        vec3 col = vec3(0.7,0.5,0.2);\n        // delta for normal calculation\n        float dnc = 0.001;\n        vec3 surface_normal = normalize(vec3(\n            measure(hit+vec3(dnc, 0.0, 0.0)).x - measure(hit-vec3(dnc, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, dnc, 0.0)).x - measure(hit-vec3(0.0, dnc, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, dnc)).x - measure(hit-vec3(0.0, 0.0, dnc)).x\n        ));\n        if (who == 1) { //floor\n            float atten = min(1.0, fract(current.z) * 8.0);\n            int xi = int(fract(hit.x)*2.0);\n            int zi = int(fract(hit.z)*2.0);\n            if ((xi ^ zi) == 0) {\n\t        \tcol = vec3(0.7,0.5,0.2);\n            } else {\n\t        \tcol = vec3(0.8,0.6,0.3);\n            }\n            col *= atten;\n        } \n        else if (who == 6) {\n\t        col = vec3(0.7, 0.7, 0.7);\n        } \n        else if (who == 7) { // arches etc\n            /*\n            int yi = int(fract(hit.y*5.0)*2.0);\n            if (yi == 0) {\n\t        \tcol = vec3(1.0, 1.0, 1.0);\n            } else {\n\t            col = vec3(1.0, 0.7, 0.7);\n            }\t */\n            col = vec3(1.0, 1.0, 1.0);\n            specular = 0.2;\n        }\n\t\t// lighting\n        vec2 light_1_lighting = calculate_lighting(light_1, ray, hit, surface_normal, specular);\n        vec2 light_2_lighting = calculate_lighting(light_2, ray, hit, surface_normal, specular);\n\n        float ambient = 0.2;\n        float diffuse = 0.8;\n        \n        paint = col * ambient;\n\n        float light_1_diffuse = diffuse * min(1.0, light_1_lighting.x);\n        vec3 light_1_specular = light_1.color * light_1_lighting.y;\n        paint += col * light_1.color * light_1_diffuse;\n        paint += light_1_specular;\n        \n        paint += vec3(col * (light_2.color * min(1.0, light_2_lighting.x)));\n        paint += light_2.color * light_2_lighting.y;\n        \n        \n    }\n    paint *= 1.0 - (total_dist/MAX_DIST);\n    fragColor += vec4(base_color + paint, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSBDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 437, 483, 483, 634], [636, 636, 673, 673, 695], [697, 697, 757, 757, 874], [876, 876, 927, 927, 1009], [1011, 1011, 1064, 1064, 1108], [1110, 1160, 1187, 1187, 1245], [1247, 1269, 1299, 1299, 1339], [1341, 1341, 1397, 1397, 1458], [1459, 1459, 1517, 1517, 1578], [1660, 1660, 1700, 1700, 3921], [3924, 3924, 3960, 3960, 4006], [4008, 4008, 4034, 4034, 4286], [4288, 4321, 4411, 4411, 4677], [4679, 4792, 4853, 4853, 5507], [5509, 5509, 5607, 5681, 6419], [6421, 6421, 6478, 6478, 10196]], "test": "untested"}
{"id": "MlSBRy", "name": "15/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I continued to figure out ways to visualize voronoi. I combined my noise volume march thing from day 2 to my voronoi thing from day 13.", "tags": ["voronoi", "dailyshader"], "likes": 2, "viewed": 179, "published": "Public", "date": "1516226438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 12\n#define PI 3.14159265\n\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\nfloat dist(vec3 q){\n    vec3 f = fract(q);\n    vec3 i = floor(q);\n    \n    vec3 n[27];  \n    n[0] = vec3(-1.0, -1.0, -1.0);\n    n[1] = vec3(-1.0,  0.0, -1.0);\n    n[2] = vec3(-1.0,  1.0, -1.0);\n    \n    n[3] = vec3(0.0,  -1.0, -1.0);\n    n[4] = vec3(0.0,   0.0, -1.0);\n    n[5] = vec3(0.0,   1.0, -1.0);\n    \n    n[6] = vec3(1.0,  -1.0, -1.0);\n    n[7] = vec3(1.0,   0.0, -1.0);\n    n[8] = vec3(1.0,   1.0, -1.0);\n    \n    n[9] = vec3(-1.0, -1.0,\t 0.0);\n    n[10] = vec3(-1.0, 0.0,  0.0);\n    n[11] = vec3(-1.0, 1.0,  0.0);\n    \n    n[12] = vec3(0.0,  -1.0,  0.0);\n    n[13] = vec3(0.0,   0.0,  0.0);\n    n[14] = vec3(0.0,   1.0,  0.0);\n    \n    n[15] = vec3(1.0,  -1.0,  0.0);\n    n[16] = vec3(1.0,   0.0,  0.0);\n    n[17] = vec3(1.0,   1.0,  0.0);\n    \n    n[18] = vec3(-1.0, -1.0,  1.0);\n    n[19] = vec3(-1.0,  0.0,  1.0);\n    n[20] = vec3(-1.0,  1.0,  1.0);\n    \n    n[21] = vec3(0.0,  -1.0,  1.0);\n    n[22] = vec3(0.0,   0.0,  1.0);\n    n[23] = vec3(0.0,   1.0,  1.0);\n    \n    n[24] = vec3(1.0,  -1.0,  1.0);\n    n[25] = vec3(1.0,   0.0,  1.0);\n    n[26] = vec3(1.0,   1.0,  1.0);\n    \n    float t = 1000.0;\n    for(int it = 0; it < 27; ++it){\n        vec3 p = hash33(i+n[it]);\n        p = (1.0+sin(iTime*0.5 + 2.0*PI*p))*0.5;\n        float d = length(n[it]+p-f);\n        t = min(t, d);\n    }\n    return t;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t = 0.0;\n    //the offset IS intentional\n    vec3 p = ro+rd;\n    \n    for(int i = 0; i < STEPS; ++i){\n        float d = dist(p-length(hash33(p+iTime*0.25))*0.03)*0.02;\n        t += d;\n        p += rd*d;\n        \n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, iTime*0.25);\n\tvec3 rt = vec3(0.0, 0.0, -1.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = mat3(x, y, z)*vec3(uv, radians(50.0));\n    \n    //Tiling space..\n    vec3 q = rd*10.0;\n    \n    float t = trace(ro, q);\n    \n    vec3 col = vec3(0.7, 0.65, 0.5)+vec3(t);\n    col = 1.0 - col;\n    col = smoothstep(0.2, 0.8, col);\n    \n    col = pow(col, 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSBRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 143, 164, 164, 274], [277, 277, 296, 296, 1593], [1595, 1595, 1625, 1625, 1879], [1881, 1881, 1938, 1938, 2505]], "test": "untested"}
{"id": "MlSBWG", "name": "Opera Island", "author": "dr2", "description": "A famous opera house has moved", "tags": ["raymarching", "architecture"], "likes": 19, "viewed": 1188, "published": "Public API", "date": "1516976460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Opera Island\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrSphAnDf (vec3 p, float r, float w);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.x = 3.6 - abs (q.x);\n  q.z = 3.6 + q.z;\n  d = max (max (PrSphAnDf (vec3 (abs (q.x) + 2.2, q.y - 0.6, q.z), 5., 0.03),\n     10. - length (vec2 (q.y - 0.6, q.z + 9.))), 1. - q.y);\n  DMIN (1);\n  d = max (max (length (vec2 (q.x, q.z - 6.1)) - 5.5, 0.1 - q.y),\n     PrSphDf (vec3 (abs (q.x) + 2.2, q.y - 0.6, q.z), 5.));\n  DMIN (2);\n  q = p;\n  q.xz = 3.6 - abs (q.xz);\n  d = max (min (max (PrSphAnDf (vec3 (abs (q.x) + 1.8, q.y - 0.2, q.z + 1.), 4.7, 0.03),\n     8.8 - length (vec2 (q.y - 0.6, q.z + 9.))),\n     max (PrSphAnDf (vec3 (abs (q.x) + 1.4, q.y - 0.1, q.z + 1.6), 4.1, 0.03),\n     8. - length (vec2 (q.y - 0.6, q.z + 9.3)))), 1. - q.y);\n  DMIN (1);\n  d = min (max (max (length (vec2 (q.x, q.z - 4.5)) - 5.3, 0.1 - q.y),\n     PrSphDf (vec3 (abs (q.x) + 1.8, q.y - 0.2, q.z + 1.), 4.7)),\n     max (max (length (vec2 (q.x, q.z - 3.3)) - 5., 0.1 - q.y),\n     PrSphDf (vec3 (abs (q.x) + 1.4, q.y - 0.1, q.z + 1.6), 4.1)));\n  DMIN (2);\n  d = min (min (max (PrCylDf (vec3 (abs (q.x) + 2.2, q.y - 0.6, q.z).xzy, 5.05, 0.5), - q.z - 1.4),\n     max (PrCylDf (vec3 (q.x, q.y - 0.85, q.z + 0.7).xzy, 2.5, 0.25), q.z + 1.4)),\n     PrCylDf (vec3 (q.x, q.y - 0.35, q.z + 0.7).xzy, 2.9, 0.25));\n  DMIN (3);\n  d = max (PrTorusDf (vec3 (q.x, abs (q.y - 1.27) - 0.07, q.z + 0.7).xzy, 0.015, 2.45), q.z + 1.1);\n  qq = q;\n  qq.z += 0.7;\n  qq.xz = Rot2D (qq.xz, 2. * pi * (floor (64. * atan (qq.z, - qq.x) / (2. * pi) + 0.5) / 64.));\n  d = min (d, max (PrCylDf (vec3 (qq.x + 2.45, qq.y - 1.2, qq.z).xzy, 0.015, 0.14), q.z + 1.1));\n  DMIN (4);\n  q = p;\n  d = max (PrRoundBox2Df (vec2 (q.xz), vec2 (3.9, 4.7), 3.2), abs (q.y) - 0.1);\n  DMIN (5);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.5 * p + vec2 (0., tCur);\n  h = 0.6 * sin (dot (q, vec2 (-0.05, 1.))) + 0.45 * sin (dot (q, vec2 (0.1, 1.2))) +\n     0.3 * sin (dot (q, vec2 (-0.2, 1.4)));\n  q = 2. * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 3; j ++) {\n    q *= qRot;\n    t4 = q.xyxy * wFreq + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return h;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.5;\n  vn.xz = 0.2 * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, a, f;\n  a = atan (rd.z, rd.x) + 0.001 * tCur;\n  if (rd.y < 0.01 * Fbm1 (32. * a) + 0.005) col = mix (vec3 (0.25, 0.3, 0.25),\n     vec3 (0.3, 0.35, 0.33), 0.5 + 0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n     (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  else {\n    ro.x += 0.5 * tCur;\n    f = Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n    sd = pow (max (dot (rd, sunDir), 0.), 64.);\n    col = vec3 (0.2, 0.3, 0.5) + 0.1 * pow (1. - max (rd.y, 0.), 4.) + (0.35 * sd + 0.65 * min (pow (sd, 4.), 0.3)) *\n       vec3 (1., 1., 0.3);\n    col = mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n  }\n  return col;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.07, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 sf;\n  float dstObj, dstWat, sh, s;\n  bool watRefl, winfRefl;\n  watRefl = false;\n  winfRefl = false;\n  dstObj = ObjRay (ro, rd);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  if (dstWat < min (dstObj, dstFar)) {\n    watRefl = true;\n    ro += dstWat * rd;\n    rd = reflect (rd, WaveNf (ro, dstWat));\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n  sf = vec2 (0.);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.05) * (1. - 0.1 * SmoothBump (0.45, 0.55, 0.02, mod (8. * ro.z, 1.)));\n      sf = vec2 (32., 0.2);\n    } else if (idObj == 2) {\n      if (abs (mod (4. * (ro.x - 3.6 * sign (ro.x)), 1.) - 0.5) < 0.1 || ro.y < 1.2) {\n        if (ro.y < 1.2) col4 = 1.2 * vec4 (0.6, 0.5, 0.4, 0.1);\n        else col4 = vec4 (0.5, 0.5, 0.55, 0.2);\n      } else winfRefl = true;\n    } else if (idObj == 3) {\n      col4 = vec4 (0.6, 0.5, 0.4, 0.1);\n      if (abs (ro.y - 0.86) < 0.15 && abs (ro.z) > 5.35 || abs (ro.y - 0.36) < 0.15 && abs (ro.z) > 3.9)\n         winfRefl = (abs (mod (32. * atan (ro.z - 4.3 * sign (ro.z), ro.x - 3.6 * sign (ro.x)) / pi, 1.) - 0.5) > 0.15);\n      else if (abs (abs (ro.y - 0.61) - 0.25) < 0.15 && abs (ro.z) > 0.4 &&  abs (ro.z) < 3.4)\n         winfRefl = (abs (mod (48. * atan (ro.z - 3.6 * sign (ro.z), ro.x - 1.4 * sign (ro.x)) / pi, 1.) - 0.5) > 0.15);\n      else {\n        s = length (vec2 (ro.z - 4.3 * sign (ro.z), ro.x - 3.6 * sign (ro.x)));\n        if (s < 2.4) col4 *= 1. - 0.1 * SmoothBump (0.45, 0.55, 0.02, mod (4. * s, 1.));\n        sf = vec2 (32., 0.2);\n      }\n    } else if (idObj == 4) {\n      col4 = vec4 (0.5, 0.5, 0.6, 0.2);\n    } else if (idObj == 5) {\n      col4 = vec4 (0.3, 0.5, 0.3, 0.05) * (1. - 0.2 * Fbm2 (16. * ro.xz));\n      sf = vec2 (16., 1.);\n    }\n    if (sf.x > 0.) vn = VaryNf (sf.x * ro, vn, sf.y);\n    if (winfRefl) {\n      rd = reflect (rd, vn);\n      if (rd.y > 0.) col = SkyHrzCol (ro, rd);\n      else {\n        watRefl = true;\n        dstWat = - ro.y / rd.y;\n        ro += dstWat * rd;\n        col = SkyHrzCol (ro, reflect (rd, WaveNf (ro, dstWat)));\n      }\n      col = mix (vec3 (0.3, 0.3, 0.2), col, 0.3);\n    } else {\n      sh = ObjSShadow (ro, sunDir);\n      col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    }\n  } else if (rd.y < 0.) {\n    watRefl = true;\n    dstWat = - ro.y / rd.y;\n    ro += dstWat * rd;\n    col = SkyHrzCol (ro, reflect (rd, WaveNf (ro, dstWat)));\n  } else {\n    col = SkyHrzCol (ro, rd);\n  }\n  if (watRefl) {\n    col = mix (mix (vec3 (0.01, 0.01, 0.), vec3 (0., 0.05, 0.05),\n       smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz))), 0.8 * col, 1. - pow (abs (rd.y), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.25 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  } else {\n    az -= 0.02 * pi * tCur;\n    el += 0.04 * pi * cos (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.1 * pi, -0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 1., -40.);\n  rd = vuMat * normalize (vec3 (uv, 6.));\n  dstFar = 100.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSBWG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 657, 679, 679, 2384], [2386, 2386, 2419, 2419, 2596], [2598, 2598, 2619, 2619, 2819], [2821, 2821, 2844, 2844, 3551], [3553, 3553, 3584, 3584, 3788], [3790, 3790, 3825, 3825, 4489], [4491, 4491, 4528, 4528, 4767], [4769, 4769, 4804, 4804, 7648], [7650, 7650, 7706, 7706, 8580], [8582, 8582, 8629, 8629, 8676], [8678, 8678, 8711, 8711, 8738], [8740, 8740, 8784, 8784, 8821], [8823, 8823, 8865, 8865, 8916], [8918, 8918, 8964, 8964, 9021], [9023, 9023, 9080, 9080, 9163], [9165, 9165, 9195, 9195, 9269], [9303, 9303, 9327, 9327, 9380], [9382, 9382, 9406, 9406, 9536], [9538, 9538, 9563, 9563, 9709], [9711, 9711, 9736, 9736, 9922], [9924, 9924, 9946, 9946, 10100], [10102, 10102, 10123, 10123, 10278], [10280, 10280, 10309, 10309, 10521], [10523, 10523, 10562, 10562, 10742]], "test": "untested"}
{"id": "MlSBWz", "name": "Tracking", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 1, "viewed": 163, "published": "Public", "date": "1515329136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 lookat(vec3 d, vec3 up)\n{\n\tvec3 w = normalize(d),u = normalize(cross(w,up));\n    return (mat3(u,cross(u,w),w));\n}\n\nvec2 rayCastPlane(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 up)\n{\n\tfloat z = dot(pos-ro,nor)/dot(rd,nor);\n    vec3 p=ro+rd*z, a=p-pos, u=normalize(cross(nor,up)), v=normalize(cross(u,nor));\n    return vec2(dot(a,u),dot(a,v));\n}\n\nvec3 hsv(float h, float s, float v)\n{\n    return mix(vec3(1),clamp((abs(fract(h+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 knot(float t)\n{\n    t *= radians(360.);\n    return vec3(sin(t)+2.*sin(2.*t),cos(t)-2.*cos(2.*t),-sin(3.*t));\n}\n\nfloat de(vec2 p)\n{\n    return abs(length(p)-0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float t = iTime*0.05;\n    vec3 ro = knot(t);\n    ro += normalize(ro).zxy*0.5;\n    vec3 ta = knot(t+0.05);    \n    ta += normalize(ta).zxy*0.3;\n    vec3 rd = lookat(ta-ro,ro.xzy)*normalize(vec3(p,2));\t\n    vec3 col = vec3(0.3,0.3,0.5)*p.y*p.y;\n    const int s = 200;\n    for(int i=0;i<s;i++)\n    {\n        float t = float(i)/float(s);\n        vec3 d = normalize(knot(t-0.001)-knot(t+0.001));\n        vec2 b = rayCastPlane(ro,rd,knot(t),d,d.yzx);\n        col = mix(col,hsv(float(i)/float(s),0.8,1.0),smoothstep(0.01,0.0,de(b)));\n    }\n    vec3 d = normalize(knot(t-0.001)-knot(t+0.001));\n    vec2 b = rayCastPlane(ro,rd,ta,ta-rd,(ta-rd).yzx);\n    col = mix(col,hsv(fract(0.5+t),0.8,1.0),smoothstep(0.035,0.0,min(de(b),de(b*2.))));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSBWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 118], [120, 120, 186, 186, 348], [350, 350, 387, 387, 471], [473, 473, 493, 493, 588], [590, 590, 608, 608, 641], [643, 643, 700, 700, 1530]], "test": "untested"}
{"id": "MlSBzW", "name": "Apollonian Variations", "author": "mla", "description": "A variation on evilryu's excellent [url]https://www.shadertoy.com/view/XlSfzW[/url]\n\nUse the mouse to change the view.\n\nKeys a, b, i, m, p, r, s and t also do things.", "tags": ["inversion", "apollonian"], "likes": 52, "viewed": 1176, "published": "Public API", "date": "1514764933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// Modified by Matthew Arcus, 2017.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Now with keyboard controls\n// 'a': more complex AO calculation\n// 'i': toggle inversion\n// 'p': plane transform\n// 's': soft shadows\n// 'm': geometry morphing\n\nbool doAO = false;\nbool doInversion = true;\nbool doPlane = false;\nbool doSoftShadow = false;\nbool doMorph = true;\nbool doBreathe = false;\nbool doRotate = true;\nbool doTranslate = true;\n#define ITERATION 8\n#define PI 3.141592654\n\nfloat K = 0.2;\nvec4 orb;\nfloat apollonian(vec3 p)\n{\n   \tfloat scale = 1.0;\n\torb = vec4(1000.0); \n\tfor( int i=0; i < ITERATION;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n        float r2 = dot(p,p);\n        orb = min( orb, vec4(abs(p),r2) );\n        //float k = 1.2/ r2;\n        float k = (1.0 + K)/r2;\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\t\n    float res = abs(p.y + float(doBreathe)*0.1*sin(iTime));\n    if (!doPlane) res = min(abs(p.z)+abs(p.x), \n                        \tmin(abs(p.x)+abs(p.y),\n                            \tabs(p.y)+abs(p.z)));\n    return 0.25/scale*res;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n  float scale = 5.0;\n    vec3 q=p;\n    p /= scale;\n    float s = 1.0;\n    if (doInversion) {\n      s = dot(p,p);\n      p /= s;\n      p += vec3(1.0);\n    }\n    if (doTranslate) p.y += 0.1*iTime;\n    float d0=apollonian(p)*scale;\n    //float d1=abs(p.y-0.02);\n    //float d3 = box(q+vec3(0.,-2.,0.), 2.9*vec3(3.,2.,2.3));\n    float d = d0; //max(d0, d3); // Don't box\n    //d=min(d,d1);\n    return d*s;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.y * 2.0);\n\n    float t = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c<0.5*pixel_size*t ) break;\n        t += c;\n        if( t>100.0 ) return -1.0;\n    }\n    return t;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<100; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tonemap(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n  float dd, hr, totao = 0.0;\n  float sca = 1.0;\n  vec3 aopos; \n  for( int aoi=0; aoi<5; aoi++ ) {\n    hr = 0.01 + 0.05*float(aoi);\n    aopos =  nor * hr + pos;\n    totao += -(map( aopos )-hr)*sca;\n    sca *= 0.75;\n  }\n  return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.y*PI;\n    p.yz = rotate(p.yz,phi);\n    p.zx = rotate(p.zx,phi);\n  }\n  //p.yz = rotate(p.yz,0.1*iTime * 0.125);\n  if (doRotate) p.zx = rotate(p.zx,0.1*iTime);\n  return p;\n}\n\nbool keypress(int code) {\n#if __VERSION__ < 300\n    return false;\n#else\n    return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tdoAO = keypress(CHAR_A);\n  \tdoInversion = !keypress(CHAR_I);\n  \tdoPlane = keypress(CHAR_P);\n  \tdoSoftShadow = keypress(CHAR_S);\n    doMorph = !keypress(CHAR_M);\n    doBreathe = keypress(CHAR_B);\n    doRotate = !keypress(CHAR_R);\n    doTranslate = !keypress(CHAR_T);\n    \n    if (doMorph) K *= cos(0.123*iTime);\n\n    vec3 ld0=normalize(vec3(-12., 2.0, -7.));\n        \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    //vec3 lookat = vec3(0.0, 1.5, 0.);\n    vec3 lookat = vec3(0);\n    vec3 ro = 1.4*vec3(-1., 1.5,-4.5);\n    if (iMouse.y > 0.0) {\n      ro *= 2.0*iMouse.y/iResolution.y;\n    }\n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    ro = transform(ro);\n    rd = transform(rd);\n    ld0 = transform(ld0);\n\n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        float ao = pow(clamp(orb.w*2.0,0.0,1.0), 1.2);\n        if (doAO) ao = calcAO(pos,n);\n        float c0=pow(clamp(orb.w, 0.0, 1.0), 2.);\n        float c1=pow(clamp(orb.x, 0.0, 1.0), 2.);\n    \tvec3 col0=c0*vec3(0.0,1.0,1.0);\n\t\tvec3 col1=vec3(1.);\n        col1 = mix(col1, vec3(0.4,0.0,0.0), clamp(3.5*orb.y,0.,1.));\n\n\n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float bac2=max(0.0, dot(n, -vec3(0.,1.,0.)));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 64.0));\n        float sha=1.0;\n        if (doSoftShadow) sha = softshadow( pos+0.01*n, ld0, 0.005, 32.0 );\n        vec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.5)*amb*ao;\n        lin+=vec3(5.,5.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(1.,0.8,0.3)*bac2*ao;\n        lin+=vec3(spec*6.2)*sha;\n        \n       \tcol=(lin*col1-col0)*.2;\n        col=mix(col,vec3(0.), 1.0-exp(-0.001*t*t)); \n        col *= min(2000.0*exp(-0.74*t),1.0);\n\n     }\n    col=tonemap(col);\n    //col=pow(col,vec3(1.3,1.,1.));\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSBzW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[146, 563, 589, 589, 1104], [1106, 1106, 1133, 1133, 1222], [1224, 1224, 1243, 1243, 1646], [1648, 1648, 1673, 1673, 1879], [1881, 1881, 1924, 1924, 2178], [2180, 2180, 2245, 2245, 2507], [2509, 2509, 2531, 2531, 2717], [2719, 2719, 2760, 2760, 3025], [3027, 3027, 3063, 3063, 3115], [3117, 3117, 3144, 3144, 3464], [3466, 3466, 3491, 3491, 3606], [3954, 3954, 4011, 4011, 6331]], "test": "untested"}
{"id": "MlScWd", "name": "Old_Sphere", "author": "ragotpaul", "description": "Draw a sphere", "tags": ["sphere"], "likes": 0, "viewed": 253, "published": "Public API", "date": "1515044626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Infini\nconst float infini = 1.0 / 0.0;\n\n#define MAX_REFLECT 20\n\n// Material\nstruct Material {\n\tfloat Ka;\n\tfloat Kd;\n\tfloat Ks;\n\tfloat Shininess;\n};\n    \n// Shade\nstruct Shade {\n    vec3 color;\n    float ks;\n};\n\n// Light color\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0);\nconst vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\nconst vec3 specularColor = vec3(1.0, 1.0, 1.0);\n\n// LookAt\n      vec3 eye = vec3(0.0, 2.0, -5.0);\nconst vec3 center = vec3(0.0, 0.0, 0.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n// Sky\nconst vec3 skyColor = vec3(0.1, 0.2, 0.3);\nconst int skyId = 0;\n\n// Sphere\nconst vec3 sphereColor = vec3(1.0, 0.0, 1.0);\n      vec3 spherePosition = vec3(0.0, 0.0, 0.0);\nconst float sphereRadius = 1.0;\nconst int sphereId = 1;\nconst Material sphereMaterial = Material(0.1, 0.8, 0.5, 64.0);\n\n// Plane\nconst vec3 planeColorDark = vec3(0.0, 0.2, 0.2);\nconst vec3 planeColorLight = vec3(1.0, 1.0, 1.0);\nconst vec3 planePosition = vec3(0.0, -1.0, 0.0);\nconst vec3 planeNormal = vec3(0.0, 1.0, 0.0);\nconst int planeId = 2;\nconst Material planeMaterial = Material(0.1, 0.8, 0.1, 1024.0);\n\n// Key\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float fov = 90.0;\n\nvoid pixelToCamera(in vec2 pixelCoord, out vec3 rayPosition, out vec3 rayDirection)\n{\n    float focal = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 cameraZ = normalize(center - eye);\n    vec3 cameraX = normalize(cross(- up, cameraZ));\n    vec3 cameraY = normalize(cross(cameraZ, cameraX));\n    \n    // float ratio = iResolution.x / iResolution.y;\n    \n    vec2 position = (2.0 * pixelCoord - iResolution.xy) / iResolution.y;\n    \n    rayPosition = eye;\n    rayDirection = normalize(position.x * cameraX - position.y * cameraY + focal * cameraZ);\n}\n\nfloat computeSphere(in vec3 rayPosition, in vec3 rayDirection, out vec3 intersectPosition, out vec3 normal)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayPosition - spherePosition, rayDirection);\n    float c = dot(rayPosition - spherePosition, rayPosition - spherePosition) - sphereRadius * sphereRadius;\n    \n    float square_lenght = b * b - 4.0 * a * c;\n    \n    if (square_lenght >= 0.0)\n    {\n        float lenght = sqrt(square_lenght);\n        float t1 = (- b - lenght) * 1.0 / (2.0 * a);\n        float t2 = (- b + lenght) * 1.0 / (2.0 * a);\n        \n        float t = -1.0;\n        float direction = 1.0;\n        \n        if (t1 > 0.0)\n        {\n            t = t1;\n        }\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            direction = -1.0;\n        }\n        else\n        {\n            return t;\n        }\n        \n        intersectPosition = rayPosition + t * rayDirection;\n        normal = normalize(intersectPosition - spherePosition) * direction;\n        \n        return t;\n        \n    }\n    return -1.0;\n}\n\nfloat computePlane(in vec3 rayPosition, in vec3 rayDirection, out vec3 intersectPosition, out vec3 normal)\n{\n    float d = dot(planeNormal, rayDirection);\n    if (abs(d) <= 0.0001) {\n        return -1.0;\n    }\n    \n    float t = dot(planeNormal, planePosition - rayPosition) / d;\n    \n    intersectPosition = rayPosition + t * rayDirection;\n    \n    normal = - sign(d) * planeNormal;\n    \n    return t;\n}\n\nfloat computeIntersection(in vec3 rayPosition, in vec3 rayDirection, out int id, out vec3 intersectPosition, out vec3 normal)\n{\n    float minDistance = infini;\n    id = skyId;\n    \n    vec3 intersectSphere;\n    vec3 normalSphere;\n    float distanceSphere = computeSphere(rayPosition, rayDirection, intersectSphere, normalSphere);\n    if ((distanceSphere > 0.0) && (distanceSphere < minDistance))\n    {\n        id = sphereId;\n        minDistance = distanceSphere;\n        intersectPosition = intersectSphere;\n        normal = normalSphere;\n    }\n    \n    vec3 intersectPlane;\n    vec3 normalPlane;\n    float distancePlane = computePlane(rayPosition, rayDirection, intersectPlane, normalPlane);\n    if ((distancePlane > 0.0) && (distancePlane < minDistance))\n    {\n        id = planeId;\n        minDistance = distancePlane;\n        intersectPosition = intersectPlane;\n        normal = normalPlane;\n    }\n    \n    if (id == skyId)\n    {\n        minDistance = -1.0;\n    }\n    \n    return minDistance;\n}\n\nvec3 getSphereColor()\n{\n    return sphereColor;\n}\n\nvec3 getPlaneColor(in vec3 position)\n{\n    vec3 axisX  = normalize(vec3(1.0, 0.0, 0.0) - dot(vec3(1.0, 0.0, 0.0), planeNormal) * planeNormal);\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    vec3 diff = position - planePosition; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeColorDark : planeColorLight;\n}\n\nvec3 getObjectColor(in int id, in vec3 position)\n{\n    if (id == sphereId)\n    {\n        return getSphereColor();\n    }\n    else if (id == planeId)\n    {\n        return getPlaneColor(position);\n    }\n        \n    return skyColor;\n}\n\nMaterial getObjectMaterial(in int id)\n{\n    Material mat;\n    if (id == sphereId) {\n        mat = sphereMaterial;\n    } else if (id == planeId) {\n    \tmat = planeMaterial;\n    }\n    \n    return mat;\n}\n\nfloat getShadowFactor(in int id, in vec3 intersectPosition, in vec3 normal, in vec3 L, in float Ldist)\n{\n    int tmpId;\n    vec3 tmpPosition;\n    vec3 tmpNormal;\n    intersectPosition += normal * 0.0001;\n    float dist = computeIntersection(intersectPosition, L, tmpId, tmpPosition, tmpNormal);\n    if (dist < 0.0 || dist > Ldist) {\n        return 1.0;\n    }\n    \n    Material mat;\n    if (id == sphereId) {\n        mat = sphereMaterial;\n    } else if (id == planeId) {\n    \tmat = planeMaterial;\n    }\n    return mat.Ka;\n}\n\nvec3 shadowPhongShading(in int id, in vec3 objectColor, in vec3 N, in vec3 L, in vec3 R, in vec3 V, in float shadowFactor)\n{\n    Material mat;\n    if (id == sphereId) {\n        mat = sphereMaterial;\n    } else if (id == planeId) {\n    \tmat = planeMaterial;\n    }\n    vec3 ambient = mat.Ka * ambientColor;\n    vec3 diffuse = mat.Kd * diffuseColor * objectColor * max(dot(N, L), 0.0) * shadowFactor;\n    vec3 specular = mat.Ks * specularColor * pow(max(dot(R, V), 0.0), mat.Shininess) * ((shadowFactor < 1.0) ? 0.0 : 1.0);\n    \n    return ambient + diffuse + specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    eye = vec3(5.0 * cos(iTime * 0.1), 1.0, 5.0 * sin(iTime * 0.1));\n    spherePosition.y = sin(iTime * 0.1) + sphereRadius;\n    \n    \n    vec3 rayPosition;\n    vec3 rayDirection;\n    \n    pixelToCamera(fragCoord, rayPosition, rayDirection);\n    \n    vec4 m = iMouse;\n    m.x -= (iResolution.x / 2.0);\n    m.y -= (iResolution.y / 2.0);\n    m /= iResolution.xyxy;\n\tvec3 lightPosition = vec3(- m.x * 100.0, m.y * 100.0, 0.0);\n    \n    Shade shade[MAX_REFLECT];\n    \n    int nbReflect = 0;\n    \n    int id;\n    vec3 intersectPosition;\n    vec3 normal;\n    \n    do\n    {\n        \n        float dist = computeIntersection(rayPosition, rayDirection, id, intersectPosition, normal);\n\n        if (dist > 0.0)\n        {\n            vec3 L = normalize(lightPosition - intersectPosition);\n            vec3 R = 2.0 * dot(normal, L) * normal - L;\n            vec3 V = - rayDirection;\n\n            vec3 objectColor = getObjectColor(id, intersectPosition);\n\n            float shadowFactor = getShadowFactor(id, intersectPosition, normal, L, dist);\n\n            shade[nbReflect].color = shadowPhongShading(id, objectColor, normal, L, R, V, shadowFactor);\n            Material mat = getObjectMaterial(id);\n            shade[nbReflect].ks = mat.Ks;\n            \n            rayPosition = intersectPosition + 0.0001 * normal;\n            rayDirection = - 2.0 * dot(normal, rayDirection) * normal + rayDirection;\n        }\n        else\n        {\n            shade[nbReflect].color = skyColor;\n            shade[nbReflect++].ks = 0.0;\n            break;\n        }\n        nbReflect++;\n    } while (nbReflect < MAX_REFLECT);\n    \n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = nbReflect - 1; i >= 0; --i)\n    {\n        finalColor *= shade[i].ks;\n        finalColor += shade[i].color;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlScWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1088, 1225, 1310, 1310, 1773], [1775, 1775, 1884, 1884, 2845], [2847, 2847, 2955, 2955, 3251], [3253, 3253, 3380, 3380, 4251], [4253, 4253, 4276, 4276, 4302], [4304, 4304, 4342, 4342, 4713], [4715, 4715, 4765, 4765, 4946], [4948, 4948, 4987, 4987, 5148], [5150, 5150, 5254, 5254, 5672], [5674, 5674, 5798, 5798, 6242], [6244, 6244, 6299, 6299, 8131]], "test": "untested"}
{"id": "MlSfWh", "name": "8/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I tested again the ambient occlusion method from https://www.shadertoy.com/view/4sdGWN as I did yesterday. Today I just built very different kind of scene. Also testing using multiple lights.", "tags": ["raymarching", "cubes", "fog", "ambientocclusion", "dailyshader"], "likes": 4, "viewed": 202, "published": "Public", "date": "1515538029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 80\n#define PIXELR 0.5/iResolution.x\n#define FAR 60.0\n\n#define PI 3.14159265\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define HASHSCALE1 0.1031\n\nconst vec3 FOG_COLOR = vec3(0.5, 0.45, 0.55);\n\n//Distance functions and helpper functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax3(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a){\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdf(vec3 p){\n    float plane = fPlane(p, vec3(0.0,1.0,0.0), -0.2);\n    \n    vec3 disp = vec3(3.0, 1.0, 3.0);\n    vec3 pp = p-vec3(0.0, 0.0, 0.0);\n    \n    vec2 index = pMod2(pp.xz, disp.xz);\n    float y = (sin(iTime*0.5+length(index))+3.5)*0.5;\n    float box = fBox(pp, vec3(1.0, y, 1.0));\n    \n    float guard = -fBoxCheap(pp, disp*0.5);\n    guard = abs(guard) + disp.x*0.1;\n    \n    return min(plane, min(guard, box));\n}\n\n//calculate normals for objects\nvec3 normals(vec3 p){\n\tvec3 eps = vec3(PIXELR, 0.0, 0.0 );\n    return normalize(vec3(\n        sdf(p+eps.xyy) - sdf(p-eps.xyy),\n        sdf(p+eps.yxy) - sdf(p-eps.yxy),\n        sdf(p+eps.yyx) - sdf(p-eps.yyx)\n    ));\n}\n\n//Ambient occlusion method from https://www.shadertoy.com/view/4sdGWN\n//Random number [0:1] without sine\nfloat hash(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(sdf( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec3 colorify(vec3 ld, vec3 p, vec3 lc){\n\n\tvec3 cc = vec3(0.8) * (ambientOcclusion(p, normals(p), 4.0, 1.0) + ambientOcclusion(p, normals(p), 6.0, 2.0));\n    cc += lc;\n    cc *=0.5;\n\treturn cc;\n}\n\n\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld, vec3 lc){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot( rd, ld ), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.2);\n\tvec3  fogColor = mix(FOG_COLOR, lc, pow(sunAmount, 2.0));\n    return mix(col, fogColor, fogAmount);\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 1.0;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(sdf(ro));\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*sdf(p);\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*sdf(p));\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv * 2.0 - 1.0;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(8.0*cos(iTime*0.1), 3.5, 8.0*sin(iTime*0.1));\n    vec3 rt = vec3(0.0, 2.75, 0.0);\n    \n    //vec3 ro = vec3(0.0, 2.0, iTime*0.5);\n    //vec3 rt = vec3(0.0, 1.0, ro.z+8.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(50.0)));\n    \n    vec3 ld = (rt-vec3(0.0, -1.0, 8.0))/distance(vec3(0.0, -1.0, 8.0), rt);\n    vec3 ld2 = (rt-vec3(0.0, -1.0, -8.0))/distance(vec3(0.0, -1.0, -8.0), rt);\n    vec3 ld3 = (ro-rt)/distance(ro, rt);\n    \n    vec3 lcol = vec3(0.6, 0.5, 0.8);    \n    vec3 col = FOG_COLOR;\n    \n    float t = march(ro, rd);\n\tvec3 p = rd*t+ro;\n    \n    if(t <= FAR){\n\t\tcol = colorify(ld, p, lcol) +\n\t\t\tcolorify(ld2, p, lcol.yzx) +\n            colorify(ld3, p, lcol.zyz);\n\t\tcol /= 3.0;\n\t}\n    \n    vec3 fg = fog(col, p, ro, rd, ld, lcol) +\n\t\tfog(col, p, ro, rd, ld2, lcol.yzx)+\n        fog(col, p, ro, rd, ld3, lcol.zyz);\n\tcol = fg/3.0;\n    \n    col = smoothstep(0.2, 0.8, col);\n    \n    col = pow(smoothstep(0.08, 1.1, col)*smoothstep(0.8, 0.005*0.799, \n          distance(uv, vec2(0.5))*(0.8 + 0.005)), 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSfWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 337, 357, 357, 387], [389, 429, 450, 450, 485], [487, 561, 617, 617, 659], [661, 712, 745, 757, 786], [788, 824, 852, 852, 934], [936, 964, 1001, 1001, 1092], [1094, 1332, 1363, 1363, 1405], [1407, 1407, 1425, 1425, 1835], [1837, 1869, 1890, 1890, 2086], [2088, 2193, 2213, 2213, 2331], [2333, 2333, 2364, 2364, 2467], [2468, 2468, 2512, 2512, 2604], [2606, 2606, 2689, 2689, 3233], [3235, 3235, 3275, 3275, 3430], [3433, 3433, 3496, 3496, 3718], [3720, 3778, 3808, 3808, 4973], [4975, 4975, 5031, 5031, 6367]], "test": "untested"}
{"id": "MlSfzD", "name": "Tandem", "author": "jamesjacobk", "description": "In tandem", "tags": ["light"], "likes": 0, "viewed": 57, "published": "Public", "date": "1514818218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Created by James Jacob Kurian (jamesjacobk) Jan 2018\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 finalColor = vec3(0.0);\n    float mag = 1.0;\n    float thinness = 10.0;\n    float scale = 5.0;\n    float yShift = 2.0;\n    uv = scale * uv;\n    uv.y -= yShift;\n    uv.y += sin(iTime) * tan(iTime) * sin(uv.x + iTime);\n    mag = abs(1.0/(thinness * uv.y));\n    finalColor += vec3(mag);\n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 56, 113, 113, 486]], "test": "untested"}
{"id": "Mt2BWK", "name": "Camera Fractile", "author": "rasimon22", "description": "A simple texture over the camera input using mouse input", "tags": ["camera"], "likes": 0, "viewed": 139, "published": "Public", "date": "1517263420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = fract(uv * tan(iMouse.x/10.0) + iTime);\n\tfragColor = vec4(uv2,0.5+0.5*sin(iTime),1.0);\n    fragColor.xy += cos(iTime);\n    fragColor += texture(iChannel0, uv) * sin(iTime)/ 4.0;\n    if(sin(fragColor.x) == 0.1){\n        fragColor += texture(iChannel0, uv);\n    }\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2BWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 378]], "test": "untested"}
{"id": "Mt2BWR", "name": "radial lines 2", "author": "FabriceNeyret2", "description": "( lines are constant width ).", "tags": ["aliasing", "lines", "radial", "illusion"], "likes": 8, "viewed": 602, "published": "Public API", "date": "1515453907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n\tvec2 R = iResolution.xy;\n         U = ( U+U - R ) / R.y;\n\n    float N = pow(1.2, iTime), // 200.\n          p = 3.1416/N,\n          a = mod( atan(U.y,U.x) + p, p+p) - p;         // 2Pi/N symmetry\n                        \n    O = vec4( smoothstep( 3./R.y,0., length(U) * abs(sin(a)) ) ); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2BWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 328]], "test": "untested"}
{"id": "Mt2BzD", "name": "1/2018", "author": "rimina", "description": "My first shader of the year. Starting with basics.\n\nResources used: https://thebookofshaders.com/07/", "tags": ["2d", "shapes", "dailyshader"], "likes": 6, "viewed": 286, "published": "Public", "date": "1514929004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    q = -1.0+2.0*q;\n    q.x *= iResolution.x/iResolution.y;\n    \n    float a = 0.0;\n    float r = 0.0;\n    float d = 10000.0;\n    \n    for(float i = 0.0; i < 6.0; ++i){\n        vec2 p = q;\n        p += vec2(i*0.5-1.2, 0.0);\n        if(mod(i, 2.0) == 0.0){    \n    \t\tp *= vec2(1.8);\n            p = vec2(p.x*cos(-iTime*0.5)-p.y*sin(-iTime*0.5), p.x*sin(-iTime*0.5)+p.y*cos(-iTime*0.5));\n        }\n        else{   \t\t\n            p = vec2(p.x*cos(iTime*0.5)-p.y*sin(iTime*0.5), p.x*sin(iTime*0.5)+p.y*cos(iTime*0.5));\n        }\n        \n        a = atan(p.x, p.y)+PI;\n    \tr = (PI*2.0)/(i+3.0);\n    \td = min(d, cos(floor(0.5+a/r)*r-a)*length(p));\n        \n        \n    }\n    \n    vec3 col = vec3(0.8, 0.0, 0.5) + vec3(smoothstep(0.2, 0.21, d));\n    \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2BzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 83, 907]], "test": "untested"}
{"id": "Mt2BzK", "name": "Sphere Finale", "author": "schmittflo", "description": "Final", "tags": ["sphere"], "likes": 0, "viewed": 69, "published": "Public", "date": "1516575574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_REFLECT 20\n\nstruct Pixel {\n    vec2 coordinate;\n    vec3 color;\n};\n\nstruct Material {\n    vec3 color;\n    float ka;\n    float kd;\n    float ks;\n    float shininess;\n};\n\nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n\nstruct Plane {\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\nstruct LightColor {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct Light {\n    vec3 position;\n    LightColor color;\n};\n    \nconst int NB_LIGHTS = 2;\n\nstruct Camera {\n    vec3 eye;\n    vec3 front;\n    vec3 up;\n    float fov;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nconst vec3 background = vec3(0, 0, 0); // Couleur du ciel, noir\nconst float infini = 1.0 / 0.0;\nconst float epsilon = 0.0001;\n\nint skyId = 0;\nint sphereId = 1;\nint planeId = 2;\n\nPixel initPixel(in vec3 color, in vec2 fragCoord) {\n    Pixel pixel = Pixel(\n        2.0 * fragCoord.xy / iResolution.xy - 1.0,                          /* coordinate */\n        color                                                                   /* color */\n    );\n    float ratio = iResolution.x / iResolution.y;\n    if (ratio > 1.0) {\n        pixel.coordinate.x *= ratio;\n    } else {\n        pixel.coordinate.y /= ratio;\n    }\n    return pixel;\n}\n\nRay initRay(in Pixel pixel, in Camera camera) {\n    float focal = 1.0 / tan(radians(camera.fov) / 2.0);\n\n    vec3 forward = normalize(camera.front);\n    vec3 side = normalize(cross(forward, camera.up));\n    vec3 up = normalize(cross(forward, side));\n\n    vec3 direction = normalize(pixel.coordinate.x * side - pixel.coordinate.y * up + focal * forward);\n\n    return Ray(\n        camera.eye,                                                             /* origin */\n        direction                                                               /* direction */\n    );\n}\n\nfloat computeSphereIntersection(inout Ray ray, in Sphere sphere) {\n    \n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, ray.origin - sphere.position);\n    float c = dot(ray.origin - sphere.position, ray.origin - sphere.position) - sphere.radius * sphere.radius;\n    \n    float t = -1.0;\n    float delta = b * b - 4.0 * a * c;\n    \n    if (delta >= 0.0) {\n        float sqrt_delta = sqrt(delta);\n        float t1 = (- b - sqrt_delta) / (2.0 * a);\n        float t2 = (- b + sqrt_delta) / (2.0 * a);\n        float direction = 1.0;\n        \n        if (t1 > 0.0) {\n            t = t1;\n        } else if (t2 > 0.0) {\n            t = t2;\n            direction = -1.0;\n        } else {\n            return t;\n        }\n        \n        ray.origin = ray.origin + t * ray.direction;\n        ray.direction = normalize(ray.origin - sphere.position) * direction;\n    }\n    \n    return t;\n}\n\nfloat computePlaneIntersection(inout Ray ray, in Plane plane) {\n    float t = -1.0;\n    float d = dot(plane.normal, ray.direction);\n    if (abs(d) <= epsilon) {\n        return t;\n    }\n    t = dot(plane.normal, plane.position - ray.origin) / d;\n    ray.origin = ray.origin + t * ray.direction;\n    ray.direction = -sign(d) * plane.normal;\n    return t;\n}\n\nMaterial computeCheckboard(in vec3 position, in Plane plane) {\n    vec3 side = vec3(1.0, 0.0, 0.0);\n    vec3 axisX = normalize(side - dot(side, plane.normal) * plane.normal);\n    vec3 axisY = normalize(cross(plane.normal, axisX));\n    vec3 vDelta = position - plane.position;\n    float u = dot(vDelta, axisX);\n    float v = dot(vDelta, axisY);\n    if (mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0) {\n        plane.material.color = vec3(0.0, 0.0, 0.0);\n    }\n    return plane.material;\n}\n\nvec3 computePhongShading(in Ray ray, in Ray intersection, in Material material, in Light light, in float shadow_factor) {\n    vec3 L = normalize(light.position - intersection.origin);\n    vec3 R = 2.0 * dot(L, intersection.direction) * intersection.direction - L;\n    vec3 V = -ray.direction;\n\n    vec3 ambient = material.ka * light.color.ambient;\n    vec3 diffuse = material.kd * light.color.diffuse * material.color * max(dot(intersection.direction, L), 0.0);\n    vec3 specular = material.ks * light.color.specular * material.color * pow(max(dot(R, V), 0.0), material.shininess);\n\n    float specular_shadow_factor = shadow_factor < 1.0 ? 0.0 : 1.0;\n\n    return ambient + (diffuse * shadow_factor) + (specular * specular_shadow_factor);\n}\n\nfloat computeNearestIntersection(inout Ray ray, in Sphere sphere, in Plane plane, out int id) {\n    id = skyId;\n    float t = infini;\n    Ray intersection = ray;\n\n    Ray iSphere = ray;\n    float dSphere = computeSphereIntersection(iSphere, sphere);\n    if (dSphere > epsilon && dSphere < t) {\n        id = sphereId;\n        t = dSphere;\n        intersection = iSphere;\n    }\n\n    Ray iPlane = ray;\n    float dPlane = computePlaneIntersection(iPlane, plane);\n    if (dPlane > epsilon && dPlane < t) {\n        id = planeId;\n        t = dPlane;\n        intersection = iPlane;\n    }\n\n    if (id == skyId) {\n        t = -1.0;\n    }\n\n    ray = intersection;\n\n    return t;\n}\n\nfloat computeShadowFactor(inout Ray ray, in Material material, in Sphere sphere, in Plane plane, in Light light) {\n    Ray iShadow = ray;\n    iShadow.origin = ray.origin + epsilon * ray.direction;\n    iShadow.direction = light.position - ray.origin;\n    int id = skyId;\n    float ray_length = computeNearestIntersection(iShadow, sphere, plane, id);\n    if (ray_length > epsilon && ray_length < length(light.position - ray.origin) - epsilon) {\n        return material.ka;\n    }\n    return 1.0;\n}\n\nvoid drawScene(inout Pixel pixel, inout Ray ray, in Sphere sphere, in Plane plane, in Light[2] light) {\n    Ray intersection = ray;\n    Material material_reflect[MAX_REFLECT];\n    int n = 0;\n    int id = skyId;\n    do {\n        float ray_length = computeNearestIntersection(intersection, sphere, plane, id);\n\n        if (id == sphereId) {\n            \n           \tmaterial_reflect[n] = sphere.material;\n\n\t\t\tmaterial_reflect[n].color = vec3(0.0, 0.0, 0.0);\n            \n            for(int i = 0; i < NB_LIGHTS; i++) {\n                float shadow_factor = computeShadowFactor(intersection, sphere.material, sphere, plane, light[i]);\n            \tmaterial_reflect[n].color += computePhongShading(ray, intersection, sphere.material, light[i], shadow_factor);\n            }\n            \n            material_reflect[n].color /= 2.0;\n        } else if (id == planeId) {\n            \n            material_reflect[n] = plane.material;\n            \n            material_reflect[n].color = vec3(0.0, 0.0, 0.0);\n            \n            for(int i = 0; i < NB_LIGHTS; i++) {\n            \tfloat shadow_factor = computeShadowFactor(intersection, plane.material, sphere, plane, light[i]);\n            \tmaterial_reflect[n].color += computePhongShading(ray, intersection, computeCheckboard(intersection.origin, plane), light[i], shadow_factor);\n            }\n            material_reflect[n].color /= 2.0;\n        } else {\n            material_reflect[n++] = Material(\n                background,\n                0.0,\n                0.0,\n                0.0,\n                0.0\n            );\n            break;\n        }\n        intersection.origin += intersection.direction * epsilon;\n    } while (n++ < MAX_REFLECT);\n\n    for (int i = n-1; i >= 0; --i) {\n        pixel.color *= material_reflect[i].ks;\n        pixel.color += material_reflect[i].color;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Pixel pixel = initPixel(background, fragCoord);\n\n    Camera camera = Camera(\n        vec3(0.0, 1.0,  5.0),                                                   /* eye */\n        vec3(0.0, 0.0, -1.0),                                                   /* front */\n        vec3(0.0, 1.0,  0.0),                                                   /* up */\n        45.0                                                                    /* fov */\n    );\n\n    Ray ray = initRay(pixel, camera);\n\n    Light lights[2];\n\n    lights[0] = Light(\n        vec3(cos(iTime) * 10.0, 10.0, sin(iTime) * 10.0),                     /* position */\n        LightColor(                                                             /* color */\n            vec3(1.0, 1.0, 1.0),                                                /* ambient */\n            vec3(1.0, 1.0, 1.0),                                                /* diffuse */\n            vec3(1.0, 1.0, 1.0)                                                 /* specular */\n        )\n    );\n\n    lights[1] = Light(\n        vec3(sin(iTime) * 10.0, 10.0, cos(iTime) * 10.0),                     /* position */\n        LightColor(                                                             /* color */\n            vec3(1.0, 1.0, 1.0),                                                /* ambient */\n            vec3(1.0, 1.0, 1.0),                                                /* diffuse */\n            vec3(1.0, 1.0, 1.0)                                                 /* specular */\n        )\n    );\n\n    Plane plane = Plane(\n        vec3(0.0, -1.0, 0.0),                                                   /* position */\n        vec3(0.0, 1.0, 0.0),                                                    /* normal */\n        Material(                                                               /* material */\n            vec3(1.0, 1.0, 1.0),                                                /* color */\n            0.1,                                                                /* ka */\n            0.8,                                                                /* kd */\n            0.2,                                                                /* ks */\n            32.0                                                                /* shininess */\n        )\n    );\n\n    Sphere sphere = Sphere(\n        0.5,                                                                    //radius\n        vec3(0.0, sin(iTime) + 0.5, 0.0),                                       //position\n        Material(                                                               // material\n            vec3(1.0, 0.0, 0.0),                                                // color\n            0.1,                                                                // ka\n            0.8,                                                                // kd\n            0.4,                                                                // ks\n            32.0                                                                // shininess\n        )\n    );\n\n    drawScene(pixel, ray, sphere, plane, lights);\n\n    fragColor = vec4(pixel.color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2BzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[679, 818, 869, 869, 1271], [1273, 1273, 1320, 1320, 1841], [1843, 1843, 1909, 1909, 2759], [2761, 2761, 2824, 2824, 3115], [3117, 3117, 3179, 3179, 3606], [3608, 3608, 3729, 3729, 4347], [4349, 4349, 4444, 4444, 5018], [5020, 5020, 5134, 5134, 5514], [5516, 5516, 5619, 5619, 7364], [7366, 7366, 7421, 7421, 10582]], "test": "untested"}
{"id": "Mt2fRw", "name": "Frosted ornament", "author": "saidwho12", "description": "I didn't get to finish the top part as I started getting performance issues for what i was aiming for and I don't think adding the top part would add too much to this shape and so I just will leave it as is but might redo this later when i know more.", "tags": ["julia", "christmas", "red", "swirls", "set", "xmas", "frosted", "ornament"], "likes": 10, "viewed": 453, "published": "Public", "date": "1515137975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 128\n\n#define RAY_T_MAX 1.e30\n#define RAY_T_MIN .01\n#define SPEED .5\n#define TIME iTime*SPEED\n#define PI 3.1415927\n#define EPSILON .006\n#define GAMMA 2.2\n\n#define MOUSE (iMouse.xy/iResolution.xy)*2.-1.\n#define MODE 1\n\n#if (MODE == 0)\n\t#define C MOUSE\n#elif (MODE == 1)\n    #define CR -.181\n    #define CI .667\n\t#define C vec2(CR, CI)\n#endif\n\n// Polynomial smooth minimum by iq\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nint julia (vec2 uv, vec2 c, float n, int maxIter)\n{   \n    int i = 0;\n    float a = uv.x, b = uv.y;\n    while(i<maxIter && a*a+b*b<4.)\n    {   \n        float tmpa = pow((a*a+b*b),(n/2.))*cos(n*atan(b, a)) + c.x;\n        b = pow((a*a+b*b),(n/2.))*sin(n*atan(b, a)) + c.y;\n        a = tmpa;\n        i++;\n    }\n    return i;\n}\n\nstruct camera\n{\n\tvec3 center, forward, up, right;\n    float w, h, fov, aspect;\n};\n\nvoid initCamera(inout camera cam, in vec3 center, in vec3 forward, in vec3 up, in float fov, in float aspect) \n{\n\tcam.center = center;\n    cam.forward = forward;\n    cam.up = up;\n    cam.right = cross(cam.forward, cam.up);\n    cam.fov = fov;\n    cam.aspect = aspect;\n    cam.w = tan(cam.fov);\n    cam.h = cam.w * cam.aspect;\n}\n\nstruct material\n{\n    vec3 ambiant, diffuse, specular;\n    float shininess;\n};\n  \nstruct light\n{\n\tvec3 center;\n    float power;\t\n};\n\nvec3 blinn_phong (vec3 L, vec3 N, vec3 V, light l, float dist, material m)\n{\n\tvec3 ambiant = m.ambiant;\n    vec3 diffuse = m.diffuse*dot(L, N);\n    vec3 H = normalize(L + V);\n    float specAngle = max(dot(N, H), 0.);\n    vec3 specular = m.specular*pow(specAngle, m.shininess);\n    float power = l.power/dist;\n    return ambiant*power + diffuse*power + specular*power;\n    \n}\n\nstruct sphere\n{\n\tvec3 center;\n    float radius;\n};\n\nfloat sphereSDF(vec3 p, sphere s)\n{\n\treturn distance(p, s.center)-s.radius;\n}\n    \nstruct cylinder\n{\n    vec3 base;\n   \tfloat height;\n};\n\nfloat cylinderSDF(vec3 p, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opScaleCylinder(vec3 p, float s, cylinder c)\n{\n    return cylinderSDF(p/s, c.height)*s;\n}\n\nfloat opU(float d0, float d1)\n{\n\treturn min(d0, d1);\n}\n\nstruct point\n{\n    material m;\n\tfloat r;\n};\n\npoint sceneSDF(vec3 p, bool mcalc)\n{\n    sphere s = sphere(vec3(0,-.25,0), 1.5);\n    cylinder c = cylinder(vec3(0,s.radius,0)+s.center, .2);\n\n    float scl = .4;\n    float amp = .015;\n    vec2 offset = vec2(.4, -.1);\n    float j = float(julia(scl*s.center.xy-(scl*p.xy)+offset, C, 2., 64))/float(64);\n    //j = 0.;\n    float d0 = 0.;\n    vec3 cyPoint = p-c.base;\n    float cyScale = 1.5;\n    cyPoint.y -= c.height;\n\t\n    //d0 = mix(0., 1., cyPoint.y);  \n    \n    material m;\n    if (mcalc)\n    {\n        material m0 = material(vec3(.3,0,0), vec3(.7,0,0), vec3(1,.5,.5), 15.);\n        material m1 = material(vec3(.4), vec3(.7), vec3(1.), 5.);\n        material m2 = material(vec3(.05, .05,.09), vec3(.39,.36,.5), vec3(0.9, 0.9, .97), .7);\n        m.ambiant = mix( mix(m0.ambiant, m1.ambiant, d0), m2.ambiant, j );\n        m.diffuse = mix( mix(m0.diffuse, m1.diffuse, d0), m2.diffuse, j);\n        m.specular = mix( mix(m0.specular, m1.specular, d0), m2.specular, j);\n        m.shininess = mix( mix(m0.shininess, m1.shininess, d0), m2.shininess, j);\n    }\n \t\n    float d1 = smin(sphereSDF(p, s), cyScale*cylinderSDF(cyPoint/cyScale, c.height) - d0*.2, .2);\n    float d2 = amp*j;\n    float d = d1 - d2;\n    return point(m, d);\n}\n\nvec3 estimateNormal(vec3 p)\n{\n\treturn normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), false).r - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), false).r,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), false).r - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), false).r,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), false).r - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), false).r\n    ));\n}\n\nfloat trace(vec3 p, vec3 d)\n{\n\tfloat t = RAY_T_MIN;\n    int i = 0;\n    while(t<RAY_T_MAX && i<MAX_ITERATIONS)\n    {\n    \tfloat r = sceneSDF(p + d*t, false).r;\n        if (r<RAY_T_MIN)\n        {\n            break;\n        }\n        t += r;\n        i++;\n    }\n    if (i==MAX_ITERATIONS || t>RAY_T_MAX)\n    {\n       \treturn RAY_T_MAX;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv*2.-1.;\n    camera cam;\n\tinitCamera(cam, vec3(0,0,4.), vec3(0,0,-1), vec3(0,1,0), PI/4., iResolution.y/iResolution.x);\n    \n    vec3 lightPos = vec3(inverse(rotateY(sin(TIME))) * vec4(vec3(0,1.5,cam.center.z), 1.));\n    light l = light(lightPos, 2.2);\n    \n    // d => ray direction, P => point of intersection\n    vec3 d = normalize(cam.forward + p.x * cam.w * cam.right + p.y * cam.h * cam.up);\n    float t = trace(cam.center, d);\n    \n    vec3 col = vec3(0);\n    if (t < RAY_T_MAX)\n    {\n    \tvec3 P = cam.center + (d*t);\n    \tvec3 L = l.center - P;\n    \tfloat dist = length(L);\n    \tL = normalize(L);\n    \tvec3 N = estimateNormal(P);\n        \n    \t//vec3 col = vec3(1./t);\n    \t//vec3 col = texture(iChannel0, uv).xyz;\n    \t//col+=vec3(N/2. + .5);\n    \tcol = blinn_phong(L, N, -d, l, dist, sceneSDF(P, true).m);\n    \tcol *= pow(col,vec3(1./GAMMA));\n    }\n    \n    \n    fragColor = vec4(col, 1.);\n    //fragColor = texture(iChannel0, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2fRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 399, 438, 438, 525], [527, 527, 554, 554, 737], [739, 739, 790, 790, 1062], [1147, 1147, 1259, 1259, 1473], [1608, 1608, 1684, 1684, 1982], [2036, 2036, 2071, 2071, 2113], [2174, 2174, 2210, 2210, 2309], [2311, 2311, 2363, 2363, 2406], [2408, 2408, 2439, 2439, 2462], [2509, 2509, 2545, 2545, 3732], [3734, 3734, 3763, 3763, 4124], [4126, 4126, 4155, 4155, 4479], [4481, 4481, 4536, 4536, 5535]], "test": "untested"}
{"id": "Mt2fWW", "name": "Kagami Mochi Visualizer", "author": "novogrammer", "description": "Kagami Mochi Visualizer", "tags": ["visualizer", "kagamimochi"], "likes": 3, "viewed": 178, "published": "Public", "date": "1515879008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat freq(sampler2D channel, float f){\n    return texture(channel,vec2(f,0.25)).x;\n}\n\nfloat circle(vec2 uv,vec2 position,float radius){\n    return distance(uv,position)-radius;\n}\nfloat box(vec2 uv,vec2 position,vec2 size){\n    vec2 diff=uv-position;\n    vec2 absDiff=abs(diff);\n    vec2 distanceSurface=absDiff-size*0.5;\n    return max(distanceSurface.x,distanceSurface.y);\n}\nfloat mochi(vec2 uv,vec2 position,vec2 size){\n    float boxDistance=box(uv,position,size);\n    float circleADistance=circle(uv,position-vec2(size.x*0.5,0),size.y*0.5);\n    float circleBDistance=circle(uv,position+vec2(size.x*0.5,0),size.y*0.5);\n    return min(boxDistance,min(circleADistance,circleBDistance));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 normalizedUv=(uv*2.0-vec2(1.0))*vec2(iResolution.x/iResolution.y,1.0);\n    float bass=freq(iChannel3,0.01);//100khz as bass\n    float melody=freq(iChannel3,0.05);//500khz as melody\n    float snare=freq(iChannel3,0.2);//2khz as snare\n    if(\n        circle(normalizedUv,vec2(0.0,0.5-0.1),snare)<0.0\n    ){\n        fragColor=vec4(1.0,0.5,0.0,1.0);\n    }else if(\n        mochi(normalizedUv,vec2(0.0,0.0-0.1),vec2(melody))<0.0 ||\n        mochi(normalizedUv,vec2(0.0,-0.5-0.1),vec2(bass))<0.0\n        \n      ){\n        fragColor=vec4(1.0);\n    }else{\n        if(texture(iChannel3,vec2(uv.x,0.25)).x-uv.y>0.0){\n            fragColor=vec4(1.0,0.0,0.0,1.0);\n        }else{\n        \tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n        }\n        //fragColor = texture(iChannel3,uv);\n        //fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    }\n}", "image_inputs": [{"id": "MsSSRw", "previewfilepath": "https://soundcloud.com/lucua_life/never-end-keizomahine-feat-mademoiselle-yulia", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lucua_life/never-end-keizomahine-feat-mademoiselle-yulia", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2fWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 40, 40, 86], [88, 88, 137, 137, 180], [181, 181, 224, 224, 377], [378, 378, 423, 423, 690], [694, 694, 751, 751, 1639]], "test": "untested"}
{"id": "MtBBRD", "name": "2018 fractal", "author": "gleurop", "description": "Written in the 10 minutes preceding 2018", "tags": ["fractal"], "likes": 1, "viewed": 455, "published": "Public API", "date": "1514789278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv(float h,float s,float v) { //las\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy *4.5 - 1.0;\n    float c = 1.0;\n    vec3 z = vec3(0);\n    for (float i=0.; i < 15. ; i++) {\n        uv = abs(uv-1.3);\n        uv /= clamp(length(uv), 0.27, 0.6);\n        vec2 p = vec2(i/15.0+sin(i*iMouse.x+i), sin(iTime*0.2+sin(i)));\n\t\tc = min(c, distance(p, uv));\n       \tz = sin(z+hsv(c, max(uv.x,uv.y), c*0.3)); \n    }\n    \n\tfragColor = vec4(z*0.5+0.5,1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBBRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 41, 126], [132, 132, 189, 189, 591]], "test": "untested"}
{"id": "MtBBzV", "name": "Stupendous Julia matrix", "author": "pjdevpl", "description": "Animated Julia set in a wicked constantly moving world. ", "tags": ["3d", "raymarching", "fractal", "julia", "distancefields", "abstract", "generated"], "likes": 18, "viewed": 365, "published": "Public", "date": "1516485723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by: \n// https://www.shadertoy.com/view/Xd3SDs \n// https://www.shadertoy.com/view/Mtc3zS\n// https://www.shadertoy.com/view/Xds3zN\n// https://www.shadertoy.com/view/lsBXW3 \n// https://www.shadertoy.com/view/MtVGDt\n// https://www.shadertoy.com/view/MsfGRr\n\n//http://140.129.20.249/~jmchen/cg/docs/rendering%20pipeline/rendering/light_specular.html\n//http://ogldev.atspace.co.uk/www/tutorial19/tutorial19.html\n\n#define pi2            (2.*3.141593)\n#define rotate(plane,a)  (plane=vec2(cos((a)*pi2)*plane.x+sin((a)*pi2)*plane.y,cos((a)*pi2)*plane.y-sin((a)*pi2)*plane.x))\n#define pmod(a,b)    ( mod(mod((a),(b))+(b),(b)) )\n#define rep(a,r)    ( pmod(((a)+(r)*.5),(r))-(r)*.5 )\n#define repxz(a,r)    vec3( rep((a).x,(r)), (a).y + 0.5*sin((a).x+iTime)*cos((a).z+iTime), rep((a).z,(r)) )\n\n#define EPSILON .05\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 opTwist(vec3 p)\n{   \n    float  c = cos(.05*sin(iTime)*p.z);\n    float  s = sin(.05*cos(iTime)*p.z);\n    mat2   m = mat2(c,-s,s,c);\n    \n    return vec3(m*p.xy,p.z);\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b, 0.));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y,d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat collumns(vec3 p, vec3 c, float r)\n{\n\tvec3 op = p;    \n    float d;\n    \n    d = udBox(p, vec3(20., 6., 20.));\n    d = max(d, -sdBox(p, vec3(3., 3.5, 3.)));\n\tp = repxz(p, r);\n    d = max(d, udBox(p, vec3(.25, 3., .25)));\n    \n    vec3 cell_center = op - p;\n    float cut = 1000000.;\n    \n    if( textureLod(iChannel3, (cell_center.xz/r+.5)/64., 0.).x < .8 )\n    {\n       cut = sdBox(op-cell_center, vec3(.5, 3.5, .5));\n    }\n\n    return max(d,-cut);\n}\n\nfloat surface(vec3 p, vec3 s, float r)\n{\n    float f = udBox(p, vec3(20., 1., 20.));\n    p = repxz(p, r);\n    f = max(f, udBox(vec3(p.x, p.y, p.z), s));  \n    \n    return f;\n}\n\nvec4 cloud(vec3 pos)\n{\n    rotate(pos.xy,iTime/50.);\n    vec3 p = pos;\n    p.xy += iTime * 5.;\n    float noise = textureLod(iChannel3,(p.xy)/64., 0.).x;\n    vec4 col = vec4(pos.z*.5+.5);\n    col.a = noise * .25; \n    \n    return col;\n}\n\nfloat julia(vec3 p, in vec4 c)\n{\n\tvec4 z = vec4(p, 0.);\n    float md2 = 1.;\n    \n    for( int i=0; i<11; i++ )\n    {\n        // https://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf\n        // http://www.fractalforums.com/3d-fractal-generation/true-3d-mandlebrot-type-fractal/435/\n        // |dz|^2 -> 4*|dz|^2\n        // z'n+1 = 2zn * z'n\n        md2 = 4.*dot(z, z)*md2;\n        \n        // z -> z2 + c\n        z = vec4( z.x * z.x - z.y * z.y - z.z * z.z - z.w * z.w, \n                  2.0 * z.x * z.y, \n                  2.0 * z.x * z.z, \n                  2.0 * z.x * z.w) + c;\n\n        // Just like in 2D Julia set: https://www.shadertoy.com/view/XlSyDK\n        if(dot(z, z)>4.) break;\n    }\n    \n\t// iq explained the following formula here: \n\t// http://www.fractalforums.com/3d-fractal-generation/true-3d-mandlebrot-type-fractal/msg8505/#msg8505\n    // http://www.fractalforums.com/3d-fractal-generation/true-3d-mandlebrot-type-fractal/450/\n    // https://en.wikipedia.org/wiki/Koebe_quarter_theorem\n    // DE = (power/4)  |Z|log |Z| / |dZ|\n    return .25*sqrt(dot(z, z)/md2)*log(dot(z, z));\n}\n\nvec2 fn(vec3 p, in vec4 juliaFactor) \n{    \n    vec2 f = vec2(1.);\n    \n    f = opU(f, vec2(julia(p, juliaFactor), 0.));\n\t\n    p = opTwist(p);\n    \n    f = opU(f, vec2(surface(vec3(p.x, p.y + 3.3, p.z), vec3(.54, .25, .54), 1.15), .9));\n    f = opU(f, vec2(surface(vec3(p.x, p.y - 2.3, p.z), vec3(.54, .25, .54), 1.15), .6));\n    f = opU(f, vec2(collumns(p, vec3(0.), 1.15), .15));\n        \n    return f;\n}\n    \nvec3 getNormal(vec3 pos, vec4 juliaFactor)\n{\n    vec2 e = vec2(EPSILON, 0.);    // delta (epsilon)\n    \n    vec3 n = normalize(vec3(\n            fn(vec3(pos.x+e.x, pos.y, pos.z), juliaFactor).x - fn(vec3(pos.x-e.x, pos.y, pos.z), juliaFactor).x,\n            fn(vec3(pos.x, pos.y+e.x, pos.z), juliaFactor).x - fn(vec3(pos.x, pos.y-e.x, pos.z), juliaFactor).x,\n            fn(vec3(pos.x, pos.y, pos.z+e.x), juliaFactor).x - fn(vec3(pos.x, pos.y, pos.z-e.x), juliaFactor).x));\n    \n    return n;\n}\n\nvec3 getTexture(vec3 n, sampler2D tex)\n{\n\tvec3 mat = vec3(0.);\n\t\n\t// material color from texture\n\tfloat u = atan(n.z, n.x) / 3.1415*2.;\n\tfloat v = asin(n.y) / 3.1415*2. + .5;\n\tmat = texture( tex, vec2(u,v)).xyz;\n\t\n\treturn mat;\n}\n\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softShadow( vec3 rayOrigin, vec3 rayDir, float tMin, float tMax, in vec4 juliaFactor)\n{\n\tfloat res = 1.;\n\tfloat k = 5.;\n    for( float t=tMin; t < tMax; )\n    {\n\t\tfloat h = fn( rayOrigin + rayDir*t, juliaFactor).x;\n        if( h<.001 || t>tMax)\n            return 0.;\n\t\tres = min( res, k*h/t );\n        t += clamp( h, .05, .1 );\n    }\n    return clamp( res, 0., 1. );\n}\n\nvec3 calcLighting(vec3 rayDir, vec3 rayPos, vec2 dist, in vec4 juliaFactor)\n{\n    vec3 material;\n    vec3 texture[3];\n    vec3 color = vec3(0.);\n    vec3 factor = vec3(0.);\n    \n    vec3 normal = getNormal(rayPos, juliaFactor);\n    vec3 sunCol = vec3(1., 1., 1.);\n    vec3 ref = reflect(rayDir, normal);\n    \n    texture[0] = getTexture(normal, iChannel0);\n    texture[1] = getTexture(ref, iChannel1);\n    texture[2] = getTexture(ref, iChannel2);\n    \n    vec3 light = vec3(sin(iTime / 4.), -1., 1);\n    \n\t// https://www.shadertoy.com/view/Xds3zN\n    \n    if(dist.y < 0.1f)\n        material = 0.1 + 0.1*(sin( vec3(0.05*sin(rayPos.x),0.08*tan(rayPos.y),0.1*cos(rayPos.z))*100.0));\n    else\n    {\n        float tmpCol = 1.f + sin(iTime) / 2. + dist.y;\n        material = 0.1 + 0.1*(sin( vec3(0.05,0.08,0.1)*(100.0*tmpCol)));\n    }\n    \n    if(dist.y < 0.1)\n        color = clamp(material + .75*texture[0], 0., 1.);\n    else if (dist.y > .1 && dist.y < .2)\n        color = clamp(.5*material + .5*texture[1], 0., 1.);\n   \telse\n    \tcolor = clamp(.5*material + .5*texture[2], 0., 1.);\n    \n\tfloat ambient = clamp(0.5+0.5*normal.y, 0., 1.);\n    float diffuse = clamp(dot(normal, light), 0., 1.);\n    float backlight = clamp(dot(normal, normalize(vec3(-light.x, 0.,-light.z))), 0., 1. )*clamp( 1.-rayPos.y, 0., 1.);\n    float skydome = smoothstep( -.1, .1, ref.y);\n    float fresnel = pow(clamp(1.+dot(normal, rayDir), 0., 1.), 2.);\n\tfloat specular = pow(clamp(dot(ref, light), 0., 2.), 16.);\n        \n    diffuse *= softShadow(rayPos, light, .02, 2.5, juliaFactor);\n    skydome *= softShadow(rayPos, ref, .02, 2.5, juliaFactor);\n        \n    factor += 2.5*diffuse*vec3(.5, .5, .5);\n\tfactor += 0.1*specular*vec3(.5, .5, .5)*diffuse;\n    factor += 0.5*ambient*vec3(.5, .5, .5);\n    factor += 0.5*skydome*vec3(.5, .5, .5);\n    factor += 0.5*backlight*vec3(.5, .5, .5); \n    factor += 1.0*fresnel*vec3(1., 1., 1.)*(5. + sin(iTime * .5)*5.);\n\tcolor *= factor;\n\n    color = mix( color, vec3(1.,1.,1.), 1.-exp( -.0002*dist.x*dist.x*dist.x ));\n        \n\t// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n\t// gamma correction\n\tcolor = pow( color, vec3(1./2.2));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 juliaFactor = .5*cos(iTime*vec4(.25, .1, .6, .4));\n    vec2 screenPos = -1. + 2. * fragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\n\tscreenPos.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n    \n    float angle = iTime * .1;\n    \n    vec3 front = normalize(vec3(sin(angle),0,cos(angle)));\n    vec3 up = vec3(0., -1., 0.);\n    vec3 right = cross(up, front);\n    vec3 pos = vec3(0., 0., 0.)-front*2.5;\n\n    vec3 rayDir = normalize(front + screenPos.x*right + screenPos.y*up);\n\n    vec3 rayPos = pos;\n    \n    vec2 dist;\n    \n    float step = .2;\n    vec4 color = vec4(0., 0., 0., 1.);\n    \n    rayPos += rayDir*abs(sin(screenPos.x*200.*cos(screenPos.y*200.+iTime)))*step;\n    \n    for(int i=0;i<100;i++)\n    {\n        dist = fn(rayPos, juliaFactor);\n        rayPos += dist.x*rayDir;\n        \n        vec3 p = rayPos;\n        \n        p += vec3(0., .5, 0.);\n        rotate(p.yz, sin(70.));\n        vec4 c = cloud(p);\n        \n        color.r += color.a*c.a*sin(rayPos.x);\n        color.g += color.a*c.a*cos(rayPos.y);\n        color.b += color.a*c.a*sin(rayPos.z);\n        color.a = 1.;\n        \n        if(dist.x<.001) break;\n    }\n\t\n    if (dist.x < EPSILON)\n        fragColor = mix(color, vec4(calcLighting(rayDir, rayPos, dist, juliaFactor), 0.), .9);\n    else\n        fragColor = vec4(vec3(.85, .95, 1.)-pow(screenPos.y, 2.)/1.5, 0.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBBzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 814, 842, 842, 877], [879, 879, 901, 901, 1051], [1053, 1053, 1082, 1082, 1122], [1124, 1124, 1153, 1153, 1245], [1247, 1247, 1288, 1288, 1703], [1705, 1705, 1745, 1745, 1880], [1882, 1882, 1904, 1904, 2117], [2119, 2119, 2151, 2151, 3235], [3237, 3237, 3276, 3276, 3643], [3649, 3649, 3693, 3693, 4143], [4145, 4145, 4185, 4185, 4373], [4375, 4441, 4534, 4534, 4816], [4818, 4818, 4895, 4895, 7019], [7021, 7021, 7076, 7076, 8454]], "test": "untested"}
{"id": "MtBfWw", "name": "Wobbly Wob", "author": "nylki", "description": "Wobbly wobs wobblying around.", "tags": ["2d", "animation", "squares", "cineshader"], "likes": 4, "viewed": 4185, "published": "Public API", "date": "1515958227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author Tom Brewe 2017\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n#define PI 3.14159265358979323846\n\nfloat random (in vec2 st) {\n   return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (in float x) {\n   \n   // split x int its integer and fraction.\n   float i = floor(x);\n   float f = fract(x);\n   \n   float r = random(vec2(i, 1.0));\n   float r_next = random(vec2(i + 1.0, 1.0));\n   // return r;\n   // return mix(r, r_next, f);\n   return mix(r, r_next, smoothstep(0.0, 1.0, f));\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n   _st -= 0.5;\n   _st =  mat2(cos(_angle),-sin(_angle),\n   sin(_angle),cos(_angle)) * _st;\n   _st += 0.5;\n   return _st;\n}\n\n\nfloat posSin(in float val) {\n   return (sin(val) + 1.0) / 2.0;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    // make it perfectly square\n   float aspect = iResolution.y / iResolution.x; \n   _st.y *= _zoom * aspect;\n   _st.x *= _zoom;\n   return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n   _size = vec2(0.5)-_size*0.5;\n   vec2 aa = vec2(_smoothEdges*0.5);\n   vec2 uv = smoothstep(_size,_size+aa,_st);\n   uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n   return uv.y * uv.x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n   // noisify ALL the values!!!1\n   \n   vec2 st = fragCoord.xy / iResolution.xy;\n   vec3 color = vec3(0.0);\n   float tileNum = 3. + noise(iTime * 0.1 + 59349.0) * 5.;\n   \n   // Save original coordinates for later\n   vec2 st_orig = st;\n   \n   // Divide the space in tileNum (eg. 5)\n   st = tile(st, tileNum);\n   \n   // Calculate distance of vec(sinus time) and the actual position\n   float dist = distance(st_orig, vec2(noise(iTime), noise(iTime + 3000.)));\n   \n   // maxDist defines the radius of effect\n   // lower it, to see the diagonal movement (eg. try 0.1 * ...)\n   float maxDist = 1.0 * noise(iTime + 22355.);\n   \n   float rotation = smoothstep(0.0, maxDist, dist);\n   \n   // Use a matrix to rotate the space\n   st = rotate2D(st, PI * rotation);\n   \n   // Draw a square\n   color = vec3(box(st,vec2(0.7),0.01));\n   // fade gray along the x axis of each square\n   float fade = st.x;\n   \n   color *= mix(color, vec3(fade), (cos(iTime) + 1.0) * 0.5);\n   color *= vec3(noise(iTime * 0.5 + 1000.), noise(iTime * 0.5), noise(iTime + 800. * 0.5));\n   \n   fragColor = vec4(color, color.r * dist);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Wobbly Wob\",\n\t\"description\": \"Wobbly wobs wobblying around.\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 157, 184, 184, 257], [259, 259, 285, 333, 565], [567, 567, 605, 605, 728], [731, 731, 759, 759, 795], [797, 797, 830, 862, 983], [985, 985, 1037, 1037, 1227], [1230, 1230, 1287, 1322, 2386]], "test": "untested"}
{"id": "MtBfzd", "name": "22/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Again testing things out with path tracing. Also included some foggy thing from my past shader (https://www.shadertoy.com/view/ltSBzw). Still lot to optimize, fix and learn.", "tags": ["pathtracing", "dailyshader"], "likes": 1, "viewed": 152, "published": "Public", "date": "1516841802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Simple path tracer. I used Iq's great article as a tutorial for this.\n//http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n\n#define STEPS 30\n#define FAR 60.0\n#define EPSILON 0.001\n#define PIXELR 0.5/iResolution.x\n#define PI 3.14159265359\n\n#define BOUNCES 3\n#define SAMPLES 2.0\n\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nvec2 hash23(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat hash11(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p){\n\tvec3 p3 = fract((vec3(p) * HASHSCALE3));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract(((p3.xx+p3.yz)*p3.zy));\n}\nvec3 hash31(float p){\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//from http://amietia.com/lambertnotangent.html\nvec3 lambertNoTangent(vec3 normal, vec2 uv){\n   float theta = 6.283185 * uv.x;\n   uv.y = 2.0 * uv.y - 1.0;\n   vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n   return normalize(normal + spherePoint);\n}\n\nfloat noise3D(vec3 p){\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p){\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*simplex3D( p ); p = p*2.01;\n    f += 0.25000*simplex3D( p ); p = p*2.02; //from iq\n    f += 0.12500*simplex3D( p ); p = p*2.03;\n    f += 0.06250*simplex3D( p ); p = p*2.04;\n    f += 0.03125*simplex3D( p );\n\treturn f;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t = 0.0;\n    vec3 p = ro+rd;\n    \n    for(int i = 0; i < 3; ++i){\n        float d = fbm(p)*0.04;\n        t += d;\n        p += rd*d;\n        \n    }\n    \n    return t;\n}\n\n//Distance functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Maximum/minumum elements of a vector\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.0) {\n\t\tp = p - (2.0*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec2 dist(vec3 p){\n    \n    vec3 pp = p-vec3(0.0, 0.0, 6.0);\n    \n    float ball = fSphere(p-vec3(0.0, -5.0, 0.0), 1.0);\n    float jalusta = fBox(p-vec3(0.0, -8.0, 0.0), vec3(1.5, 2.0, 1.5));\n    float patsas = fOpUnionRound(ball, jalusta, 0.8);\n    \n    pReflect(pp, vec3(0.0, 0.0, 1.0), 6.0);\n    float cube = fBox(pp, vec3(1.0, 10.0, 1.0));\n    \n    \n    float box = -fBox(p, vec3(20.0, 10.0, 20.0));\n    \n    float scene = min(patsas, min(cube,box));\n\n    float id = 0.0;\n    if(ball < cube && ball < box && ball < jalusta){\n        id = 1.0;\n    }\n    else if(cube < ball && cube < box && cube < jalusta){\n        id = 2.0;\n    }\n    else if(jalusta < ball && jalusta < cube && jalusta < box){\n        id = 3.0;\n    }\n    \n    return vec2(scene, id);\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(EPSILON, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy).x-dist(p-eps.xyy).x,\n        dist(p+eps.yxy).x-dist(p-eps.yxy).x,\n        dist(p+eps.yyx).x-dist(p-eps.yyx).x\n    ));\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 1.0;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(dist(ro).x);\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*dist(p).x;\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*dist(p).x);\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n    \n    p = ro+rd*t;\n    float id = dist(p).y;\n    \n\treturn vec2(t, id);\n}\n\nvec3 color(float obj){\n    vec3 base = vec3(0.0);\n    if(obj == 0.0){\n        base = vec3(0.6);\n    }\n    else if(obj == 1.0){\n        base = vec3(0.8);\n    }\n    else if(obj == 2.0){\n        base = vec3(0.25, 0.3, 0.35);\n    }\n    else if(obj == 3.0){\n        base = vec3(0.4);\n    }\n    return base;\n}\n\nvec3 light(float obj, vec3 p, vec3 ld, vec3 rd){\n    vec3 n = normals(p);\n    float lambertian = max(dot(n, ld), 0.0);    \n    vec3 color = vec3(0.2, 0.3, 0.4)+lambertian*0.6;\n    \n    return color;\n}\n\nvec3 render(vec3 o, vec3 d, vec3 rt, vec2 uv){\n    vec3 ro = o;\n    vec3 rd = d;\n    \n    vec3 tcol = vec3(0.0);\n    vec3 fcol = vec3(1.0);\n    \n    bool ref = false;\n    float density = trace(ro, rd);\n    \n    for(int i = 0; i < BOUNCES; ++i){\n        vec2 t = march(ro, rd);\n        \n        \n        vec3 p = ro+rd*t.x;\n        \n        if(t.y < 0.0 || t.x > FAR){\n            break;\n        }\n        \n        vec3 n = normals(p);\n        vec3 ld = -rd;\n        \n        vec3 scol = color(t.y);\n        vec3 dcol = light(t.y, p, ld, rd);\n        fcol *= scol;\n        tcol += fcol * dcol;\n        \n        tcol += density;\n        \n        float rnd = hash11(float(i));\n        \n        ro = p+(n*0.02);\n        \n        if(rnd < 0.25 && t.y < 3.0){\n            rd = reflect(rd,n);\n        }\n        else{\n            rd = rd = lambertNoTangent(n, hash23(vec3(uv, float(i)+iTime*0.01)));\n        }\n        \n    }\n    \n    return tcol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(10.0*cos(iTime*0.2), -2.0+sin(iTime*0.05), 10.0*sin(iTime*0.2));\n    vec3 rt = vec3(0.0, -3.5+cos(iTime*0.02), 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    \n    vec3 color = vec3(0.0);//render(ro, rd, rt);\n    \n    for(float i = 0.0; i < SAMPLES; ++i){\n    \tvec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    \tcolor += render(ro, rd, rt, uv);\n    }\n    color /= SAMPLES;\n    \n    color = pow(color, 1.0/vec3(2.2));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBfzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 443, 464, 464, 568], [569, 569, 590, 590, 700], [702, 702, 724, 724, 842], [843, 843, 866, 866, 974], [976, 976, 997, 997, 1114], [1115, 1115, 1136, 1136, 1254], [1256, 1304, 1348, 1348, 1545], [1547, 1547, 1569, 1569, 1650], [1652, 1652, 1676, 1676, 3801], [3803, 3803, 3822, 3822, 4068], [4070, 4070, 4100, 4100, 4283], [4364, 4404, 4425, 4425, 4460], [4462, 4462, 4494, 4494, 4519], [4521, 4557, 4585, 4585, 4667], [4669, 4669, 4731, 4731, 4839], [4841, 4841, 4889, 4889, 4974], [4976, 4976, 4994, 4994, 5733], [5735, 5735, 5756, 5756, 5967], [6028, 6067, 6087, 6087, 6117], [6119, 6119, 6148, 6148, 7385], [7387, 7387, 7409, 7409, 7690], [7692, 7692, 7740, 7740, 7892], [7894, 7894, 7940, 7940, 8834], [8837, 8837, 8894, 8894, 9642]], "test": "untested"}
{"id": "MtBfzV", "name": "Recursive Voronoi Geometry", "author": "fizzer", "description": "Uses recursion to create irregular voronoi cells, and to create a close approximation of soft shadowing from disc-like lightsources. Ray intersections are computed with ray-versus-plane, not raymarching!", "tags": ["raytracing", "voronoi", "softshadows"], "likes": 77, "viewed": 1329, "published": "Public", "date": "1516490831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float pi=acos(-1.);\nconst int n=3;\nconst float ssd=1.7;\nconst int maxdepth=7;\n\nfloat depth=0.;\nfloat index=0.;\nfloat h0=0.,h1=-.1;\n\nvec2 ps[n];\nint j=0;\n\nvec2 point(vec2 q, int k)\n{\n    return vec2(cos((float(k)+.5)/float(n)*pi*2.+float(index)*2.),sin((float(k)+.5)/float(n)*pi*2.))+vec2(0.,.5);\n}\n\nvoid populatePoints(vec2 p,float ss)\n{\n    float md=1e4;\n    for(int k=0;k<n;++k)\n    {\n        ps[k]=point(p, k);\n        ps[k]*=ss;\n        float d = distance(ps[k], p);\n        if(d<md)\n        {\n            md=d;\n            j=k;\n        }\n    }\n}\n\nfloat shadow(vec3 hitp,vec3 ld,float softness)\n{\n    float shadt=(h0-hitp.z)/ld.z;\n    vec3 shadp=hitp+ld*shadt;\n    float r=softness*shadt;\n    float dd=0.;\n    float ss=1.;\n    depth=0.;\n    index=0.;\n\n    for(int i=0;i<maxdepth;++i)\n    {\n        if(cos(float(index)*239.)<-.8)break;\n\n        populatePoints(hitp.xy, ss);\n\n        for(int k=0;k<n;++k)\n            if(k!=j)\n                dd+=pow(min(0.,-r/2.+dot(shadp.xy-(ps[j]+ps[k])/2.,normalize(ps[j]-ps[k]))),2.);   \n\n            shadp.xy-=ps[j];\n        hitp.xy-=ps[j];\n        ss/=ssd;\n\n        index=index*float(n)+float(j);\n        depth+=1.;\n    }\n    return 1.-clamp(sqrt(dd)/r,0.,1.);\n}\n\nfloat light(vec3 hitp,vec3 ld,vec3 hitnorm,float softness)\n{\n    return max(0.,.5+.5*dot(ld,hitnorm))*pow(shadow(hitp,ld,softness),2.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 t=uv*2.-1.;\n   \tt.y/=iResolution.x/iResolution.y;\n    vec3 ro=vec3(cos(iTime/10.)+.1,0.3,1.1),oro=ro;\n    vec3 rd=normalize(vec3(t.xy,-1.));\n\n    float t0=(h0-ro.z)/rd.z;\n    float t1=(h1-ro.z)/rd.z;\n\n    ro+=rd*t0;\n\n    float ppt=t1-t0;\n\n    vec3 floornorm=vec3(0,0,1);\n    vec3 hitnorm=floornorm;\n\n    float ss=1.;\n    depth=0.;\n    index=0.;\n    float dd=1e3;\n    for(int i=0;i<maxdepth;++i)\n    {\n        if(cos(float(index)*239.)<-.8)break;\n\n        populatePoints(ro.xy, ss);\n\n        for(int k=0;k<n;++k)\n        {\n            if(k!=j)\n            {\n                vec4 plane;\n                plane.xy=-normalize(ps[k]-ps[j]);\n                plane.z=0.;\n                float thickness=.0015;\n                plane.w=dot((ps[j]+ps[k])/2., plane.xy)+thickness;\n                dd=min(dd,-thickness+dot(ro.xy-(ps[j]+ps[k])/2.,plane.xy));\n                float pt=(plane.w-dot(ro,plane.xyz))/dot(rd,plane.xyz);\n                if(dot(rd,plane.xyz)<0.&&pt<ppt)\n                {\n                    ppt=pt;\n                    hitnorm=plane.xyz;\n                }\n            }\n        }      \n\n        ro.xy-=ps[j];\n        ss/=ssd;\n\n        index=index*float(n)+float(j);\n        depth+=1.;\n        if(dd<0.){ppt=0.;hitnorm=floornorm;break;}\n\n    }\n    ppt+=t0;\n    vec3 hitp=oro+rd*ppt;\n\n    vec3 diff=mix(vec3(.5,.75,1),vec3(1,1.,.5),.5+.5*cos(index));\n\n    diff=mix(diff,vec3(1./1.5),1.-clamp(dd/.001,0.,1.));\n    \n  \tvec3 diffm=vec3(1);\n    \n    if(hitnorm.z>.0)\n\t\tdiffm=texture(iChannel0,hitp.xy).rgb;\n    else\n\t\tdiffm=texture(iChannel0,2.*vec2(dot(hitp.xy,normalize(vec2(hitnorm.y,-hitnorm.x))),hitp.z/2.)).rgb;\n    \n    diff*=mix(diffm,vec3(1),.4);\n    diff=mix(diff,vec3(dot(diff,vec3(1./3.))),.13);\n    //diff=diffm;\n    \n    fragColor.rgb=vec3(0);\n    fragColor.rgb+=diff*light(hitp,normalize(vec3(1.,.5,.7)),hitnorm,.2)*vec3(1.,1.,.8)*\n        (.3+smoothstep(.05,.3,abs(fract((hitp.y*6.+hitp.x)*.7)-.5)));\n    fragColor.rgb+=diff*pow(light(hitp,normalize(vec3(-.1,0.,7)),hitnorm,2.5)/1.,.5)/3.*vec3(.8,.9,1.);\n\n    fragColor.rgb*=exp(-length(hitp.xy-oro.xy)/4.);\n    fragColor.rgb*=1.5;\n    fragColor.rgb+=.01*vec3(1,1,.7);\n    fragColor.rgb=pow(fragColor.rgb*1.,vec3(1./2.4));\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBfzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 188, 188, 304], [306, 306, 344, 344, 557], [559, 559, 607, 607, 1211], [1213, 1213, 1273, 1273, 1351], [1353, 1353, 1410, 1410, 3662]], "test": "untested"}
{"id": "MtjBDG", "name": "25/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Ok, yeah I'm bit out of ideas and time. So Friday night's tunnel turned into groovy Saturday night tunnel. I try to experiment with motion blurr here.", "tags": ["tunnel", "pathtracing", "motionblurr"], "likes": 0, "viewed": 109, "published": "Public", "date": "1517077290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 30\n#define FAR 60.0\n#define PIXELR 0.5/iResolution.x\n\n#define BOUNCES 3\n#define SAMPLES 4.0\n\nfloat CTIME = 0.0;\n\n//Hash methods from https://www.shadertoy.com/view/4djSRW\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n#define HASHSCALE1 443.8975\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//Distance functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Maximum/minumum elements of a vector\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nvec2 dist(vec3 p){\n    vec3 pp = p;\n    pR(pp.xy, CTIME);\n    float tunnel = -fBox(pp, vec3(4.0, 4.0, 2.0*FAR));\n    \n    pp = p;\n    pR(pp.xz, CTIME*0.75);\n    pR(pp.yz, CTIME*0.25);\n    float box = fBox(pp, vec3(0.5))-noise((pp+CTIME*0.5)*0.5)*2.0;\n    \n    float scene = min(tunnel, box);\n    float id = 0.0;\n    \n    if(box < tunnel){\n        id = 1.0;\n    }\n    \n    return vec2(scene, id);\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(PIXELR, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy).x-dist(p-eps.xyy).x,\n        dist(p+eps.yxy).x-dist(p-eps.yxy).x,\n        dist(p+eps.yyx).x-dist(p-eps.yyx).x\n    ));\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 1.0;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(dist(ro).x);\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*dist(p).x;\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*dist(p).x);\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n    \n    p = ro+rd*t;\n    float id = dist(p).y;\n    \n\treturn vec2(t, id);\n}\n\n//returns material of the object hit\n// emissive color is xyz, and reflectance w\nvec4 getMaterial(float obj, vec3 p){\n    vec3 base = vec3(0.0);\n    float reflectance = 0.0;\n    float m = mod(p.z-(CTIME*10.0), 8.0) - 4.0;\n    vec3 col = vec3(0.4, 0.3, 0.8);\n    \n    if(obj == 0.0){\n        if(m > 0.0 && m > 2.0){\n            base = col;\n        }\n        else if( m < 0.0 && m > -2.0){\n            base = col.bgb;\n        }\n        reflectance = m > 0.0 ? 0.2 : 0.5;\n    }\n    else if(obj == 1.0){\n        base = col.brg;\n        reflectance = 0.8;\n    }\n    \n    \n    return vec4(base, reflectance);\n}\n\nvec3 render(vec3 o, vec3 d, vec2 uv){\n    \n    vec3 ro = o;\n    vec3 rd = d;\n    \n    vec3 pixel_color = vec3(0.0);\n    vec3 absorption_factor = vec3(1.0);\n    \n    for(int i = 0; i < BOUNCES; ++i){\n        vec2 t = march(ro, rd);\n        vec3 p = ro+rd*t.x;\n        \n        if(t.y < 0.0 || t.x > FAR){\n            break;\n        }\n        \n        //material.xyz == emissive\n        //material.w == reflectance\n        vec4 material = getMaterial(t.y, p);\n        pixel_color += material.xyz * absorption_factor;\n        absorption_factor *= material.w;\n        \n        vec3 n = normals(p);\n        ro = p+(n*0.02);\n        if(t.y == 0.0){\n            rd = reflect(rd,n);\n            //Thanks to fizzer to introducing this skew thing! :)\n            rd = normalize(rd + (hash33(vec3(uv, float(i))) - 0.5)*0.1); \n        }\n        else if(t.y == 1.0){\n            rd = reflect(rd,n);\n        }\n        \n    }\n    \n    return pixel_color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rt = vec3(0.0, 0.0, -2.0);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    \n    vec3 color = vec3(0.0);\n    \n    for(float i = 0.0; i < SAMPLES; ++i){\n        //from http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n        CTIME = (iTime-iTimeDelta) + 0.6*(1.0/24.0)*hash13(vec3(uv, iTime*0.01));\n        \n    \tvec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(60.0)));\n    \tcolor += render(ro, rd, uv);\n    }\n    color /= SAMPLES;\n    color = smoothstep(0.2, 0.9, color);\n    \n    color = pow(color, 1.0/vec3(2.2));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 283, 304, 304, 414], [444, 444, 466, 466, 574], [656, 696, 717, 717, 752], [754, 790, 818, 818, 900], [902, 1140, 1172, 1172, 1214], [1217, 1243, 1263, 1263, 1542], [1544, 1544, 1562, 1562, 1941], [1943, 1943, 1964, 1964, 2174], [2235, 2274, 2294, 2294, 2324], [2326, 2326, 2355, 2355, 3592], [3594, 3675, 3711, 3711, 4198], [4200, 4200, 4237, 4237, 5141], [5144, 5144, 5200, 5200, 6021]], "test": "untested"}
{"id": "MtjBDK", "name": "taku", "author": "tataaphaiyarath", "description": "a mish mash of things", "tags": ["idk"], "likes": 0, "viewed": 90, "published": "Public", "date": "1517266217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    vec4 rainbow = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    vec4 music = texture(iChannel2, fract(uv * 1.0));\n    //fragColor = music + rainbow - 0.3;\n    \n    float frame = float(iFrame) / 400.0;\n    float radius = 0.25;\n    vec2 center = vec2(1.1, 0.5);\n    float d = distance(center + frame, uv);\n    \n    float circle = smoothstep(radius, radius - 0.1, d);\n    \n    if (d > radius)\n        fragColor = music + rainbow;\n    else\n        fragColor = music; //texture(iChannel0, fract(uv * 1.0));\n    \n    fragColor = vec4(circle) + rainbow + music;\n    \n    /*\n\t//set bkgrd to texture\n    vec4 texColor = texture(iChannel0, fract(uv * 4.0));  //get pixel at xy from iChannel0\n    fragColor = texColor;  //set screen pixel to that color\n\n    if (claude.g > 0.0){\n    \tclaude.g -= texColor.g;// - claude.g;\n    }\n    \n    claude.rgb -= texColor.rgb;\n    texColor.rgb += claude.rgb;\n    fragColor = texColor + claude;\n    */\n    \n    \n    /*\n\t//takes image and displays it #^2 amt of times\n\tfract(uv * #);\n\t//takes image and displays fraction of image, starting from bottom left corner\n\tfract(uv / #);\n\n\n    //creates mirror image\n    if (uv.x > 0.5)\n    {\n        uv.x = 1.0 - uv.x;\n    }\n    fragColor = uv;\n    \n    //vec#(r, g, b, a)\n    //set bkgrd color to white\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    \n    if (distance(uv.y, 0.5) < 0.02)\n    {\n        \t//set bkgrd color to black\n        \tc = vec3(0.0, 0.0, 0.0);\n\t}\n\t\n    vec4 bkgrd = vec4(c, 1.0);\n    fragColor = bkgrd;\n    */\n    \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Md2Xzw", "previewfilepath": "https://soundcloud.com/huhwhatandwhere/ta-ku-i-miss-you-more-feat-atu", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/huhwhatandwhere/ta-ku-i-miss-you-more-feat-atu", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjBDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 1684]], "test": "untested"}
{"id": "MtjBRc", "name": "graprog_ilas_act3", "author": "ilaschino", "description": "cube", "tags": ["graprog"], "likes": 1, "viewed": 77, "published": "Public", "date": "1516758429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float stripe1 = step(0.0 + ((sin(iTime) + 1.) * 0.45), uv.x);\n    stripe1 -= step(0.1 + ((sin(iTime) + 1.) * .45)  ,uv.x);\n\t\n    stripe1 -= step(0.6, uv.y);\n    stripe1 -= 1.-step( 0.4, uv.y);\n    \n    fragColor = vec4(stripe1,.5,.5,.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjBRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 346]], "test": "untested"}
{"id": "MtjBWh", "name": "9/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I tried out a bit of modelling with SDF's. To help me in this I'm using SDF library from: http://mercury.sexy/hg_sdf/", "tags": ["raymarching", "dailyshader", "sdfmodelling"], "likes": 2, "viewed": 195, "published": "Public", "date": "1515620697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64\n#define PIXELR 0.5/iResolution.x\n#define FAR 50.0\n\n#define PI 3.14159265\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define HASHSCALE1 0.1031\n\nconst vec3 FOG_COLOR = vec3(0.5, 0.55, 0.65);\n\n//Distance functions and helpper functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax3(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.0;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a){\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.0)/((n-1.0)*2.0+sqrt(2.0));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.0)/2.0*r;\n\t\tp.x += columnradius*sqrt(2.0);\n\t\tif (mod(n,2.0) == 1.0) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.0);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n\nfloat sdf(vec3 p){\n    float flr = fPlane(p, vec3(0.0, 1.0, 0.0), 2.0);\n    float ball = fSphere(p-vec3(0.0, 2.0, 0.0), 1.5);\n    \n    vec3 disp = vec3(20.0, 0.0, 0.0);\n    vec3 pp = p;\n    \n    float index = pModPolar(pp.xz, disp.x);\n    pp -= disp;\n    pMod2(pp.xz, vec2(5.0, 4.0));\n    float box = fBox(pp, vec3(1.0, 1.5, 1.0));\n    float sphere = fSphere(pp-vec3(0.0, 1.0, 0.0), 1.0);\n    \n    float field = fOpEngrave(box, sphere, 0.5);\n    \n    return fOpUnionColumns(flr, fOpUnionColumns(field, ball, 0.5, 3.0), 1.0, 4.0);\n}\n\n//calculate normals for objects\nvec3 normals(vec3 p){\n\tvec3 eps = vec3(PIXELR, 0.0, 0.0 );\n    return normalize(vec3(\n        sdf(p+eps.xyy) - sdf(p-eps.xyy),\n        sdf(p+eps.yxy) - sdf(p-eps.yxy),\n        sdf(p+eps.yyx) - sdf(p-eps.yyx)\n    ));\n}\n\n//Ambient occlusion method from https://www.shadertoy.com/view/4sdGWN\n//Random number [0:1] without sine\nfloat hash(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(sdf( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec3 colorify(vec3 ld, vec3 p, vec3 lc){\n\n\tvec3 cc = vec3(0.8) * (ambientOcclusion(p, normals(p), 4.0, 2.0) + \n                           ambientOcclusion(p, normals(p), 6.0, 1.5));\n    cc += lc;\n    cc *=0.5;\n\treturn cc;\n}\n\n\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld, vec3 lc){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot( rd, ld ), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.03);\n\tvec3  fogColor = mix(FOG_COLOR, lc, pow(sunAmount, 4.0));\n    return mix(col, fogColor, fogAmount);\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 1.3;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(sdf(ro));\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*sdf(p);\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*sdf(p));\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(10.0*cos(iTime*0.1), 3.5+sin(iTime*0.05), 12.0*sin(iTime*0.1));\n    vec3 rt = vec3(0.0, 2.5, 0.0);\n    \n    //vec3 ro = vec3(0.0, 2.0, iTime*0.5);\n    //vec3 rt = vec3(0.0, 1.0, ro.z+8.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    \n    vec3 ld = (ro-rt)/distance(ro, rt);\n    vec3 ld2 = (rt-vec3(0.0, -2.0, -8.0))/distance(vec3(0.0, -2.0, -8.0), rt);\n    \n    vec3 lcol = vec3(0.6, 0.6, 0.55);\n    vec3 lcol2 = vec3(0.7, 0.7, 0.6);  \n    vec3 col = FOG_COLOR;\n    \n    float t = march(ro, rd);\n\tvec3 p = rd*t+ro;\n    \n    if(t <= FAR){\n\t\tcol = colorify(ld, p, lcol); +\n\t\t\tcolorify(ld2, p, lcol2);\n\t}\n    \n    vec3 fg = fog(col, p, ro, rd, ld, lcol) +\n\t\tfog(col, p, ro, rd, ld2, lcol2);\n\tcol = fg*0.5;\n    \n    col = pow(col, 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjBWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 337, 357, 357, 387], [389, 429, 450, 450, 485], [487, 487, 519, 519, 544], [546, 620, 676, 676, 718], [720, 771, 804, 816, 845], [847, 883, 911, 911, 993], [995, 1139, 1179, 1179, 1300], [1302, 1330, 1367, 1367, 1458], [1460, 1573, 1623, 1623, 2017], [2019, 2257, 2288, 2288, 2330], [2332, 2368, 2393, 2393, 2433], [2435, 2509, 2568, 2568, 3189], [3191, 3263, 3308, 3308, 3354], [3357, 3357, 3375, 3375, 3888], [3890, 3922, 3943, 3943, 4139], [4141, 4246, 4266, 4266, 4384], [4386, 4386, 4417, 4417, 4520], [4521, 4521, 4565, 4565, 4657], [4659, 4659, 4742, 4742, 5286], [5288, 5288, 5328, 5328, 5511], [5514, 5514, 5577, 5577, 5800], [5802, 5860, 5890, 5890, 7055], [7057, 7057, 7113, 7113, 8175]], "test": "untested"}
{"id": "MtjfDG", "name": "wave greek frieze 3 (animated)", "author": "FabriceNeyret2", "description": "Top: symmetrical\nBottom: alternate\n\nother greek friezes here: [url]https://www.shadertoy.com/results?query=frieze[/url]", "tags": ["waves", "patterns", "fluid", "vortex", "2tweets", "short", "greek", "instability", "wake", "frieze", "kelvinhelmholtz"], "likes": 25, "viewed": 986, "published": "Public API", "date": "1517082299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/MljBDG\n// variant of https://shadertoy.com/view/ll2fWG\n\nvoid mainImage(out vec4 O, vec2 u) {\n\tvec2 U = 8.*u/iResolution.y, V; U.x -= iTime; V = floor(U);\n         float s = sign(mod(U.y,2.)-1.);\n    U.y = dot( cos(  2.*(iTime+V.x) * (V.y>3.?s:1.)\n                   * max(0.,.5-length(U = fract(U)-.5)) - vec2(33,0) ), U);\n    O += smoothstep(-1.,1., s*U / fwidth(U) ).y; }\n        \n\n \n\n        \n/** // 239 chars\n\n#define mainImage(O,u)                                  \\\n\tvec2 R = iResolution.xy,                            \\\n         U = 8.*u/R.y, V; U.x -= iTime; V = floor(U);   \\\n         float s = sign(mod(U.y,2.)-1.);                \\\n    U.y = dot( cos( (2.*(iTime+V.x)) * (V.y>3.?s:1.) * max(0.,.5-length(U = fract(U)-.5)) - vec2(33,0) ), U); \\\n\tO += smoothstep(-1.,1., s*U.y / fwidth(U.y) )\n        \n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 97, 133, 133, 414]], "test": "untested"}
{"id": "MtjfR3", "name": "Machine not learning", "author": "hamoid", "description": "Messing around", "tags": ["color", "pop"], "likes": 1, "viewed": 2750, "published": "Public API", "date": "1516788966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 pol = mod(vec2(\n        distance(uv, vec2(0.5, 0.5)) * (0.1 + 0.2 * mod(iTime * 0.2, 5.0) ),\n        PI + atan(uv.y-0.5, uv.x-0.5)/PI\n\t), 1.0);\n\tvec2 mid = fract(uv + pol * floor(30.0 * pol.x) + vec2(sin(mod(iTime, 2.0)-1.0)));    \n    float r = 1.0 - distance(uv, mid);\n\tvec4 c = vec4(0.06 / fract(r + pol.x), \n                  0.02 / fract(r + pol.y),\n                  0.01 / fract(r + uv.x), \n                  1.0);\n       \n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjfR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 577]], "test": "untested"}
{"id": "MtjfRd", "name": "Radial Blur 2k18", "author": "PrzemyslawZaworski", "description": "Full procedural shader.\n", "tags": ["procedural", "2d", "noise", "fbm", "blur", "fake", "lighting", "radial", "art", "cartography"], "likes": 20, "viewed": 1685, "published": "Public", "date": "1516911250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Just combination of two shaders:\n//https://www.shadertoy.com/view/4sfGRn by Inigo Quilez\n//https://www.shadertoy.com/view/ld2fRt by Przemyslaw Zaworski\n\n#define factor 74\n\nfloat hash (vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat noise (vec3 n)\n{\n    vec3 base = floor(n * 64.0) * 0.015625;\n    vec3 dd = vec3(0.015625, 0.0, 0.0);\n    float a = hash(base);\n    float b = hash(base + dd.xyy);\n    float c = hash(base + dd.yxy);\n    float d = hash(base + dd.xxy);\n    vec3 p = (n - base) * 64.0;\n    float t = mix(a, b, p.x);\n    float tt = mix(c, d, p.x);\n    return mix(t, tt, p.y);\n}\n\nfloat fbm(vec3 n)\n{\n    float total = 0.0;\n    float m1 = 1.0;\n    float m2 = 0.1;\n    for (int i = 0; i < 5; i++)\n    {\n        total += noise(n * m1) * m2;\n        m2 *= 2.0;\n        m1 *= 0.5;\n    }\n    return total;\n}\n\nfloat heightmap (vec3 n)\n{\n\treturn fbm((5.0 * n) + fbm((5.0 * n) * 3.0 - 1000.0) * 0.05);\n}\n\nvec3 surface(vec2 uv)\n{\n   \tfloat color = clamp(heightmap(vec3(uv.xy*5.0,2.0)*0.02)-1.0,0.0,1.0);\n    if (color<0.1) return vec3(0.35,0.40,0.44);\n    else if (color<0.2) return vec3(0.29,0.32,0.35);\n    else if (color<0.3) return vec3(0.20,0.21,0.22);\n    else if (color<0.55) return vec3(0.09,0.11,0.09);\n    else if (color<0.65) return vec3(0.18,0.19,0.14);\n    else if (color<0.75) return vec3(0.52,0.52,0.33);\n    else if (color<0.85) return vec3(0.45,0.37,0.27);\n    else if (color<0.95) return vec3(0.34,0.25,0.17);     \n    else if (color<0.99) return vec3(0.59,0.34,0.29);        \n\telse return vec3(0.14,0.09,0.08); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3  col = vec3(0.0,0.0,0.0);\n    vec2  d = (vec2(0.0,0.0)-p)/float(factor);\n    float w = 1.0;\n    vec2  s = p;\n    for( int i=0; i<factor; i++ )\n    {\n        vec3 res = surface(vec2(s.x+iTime,s.y)+sin(iTime));\n        col += w*smoothstep( 0.0, 1.0, res );\n        w *= .985;\n        s += d;\n    }\n    col = col * 4.5 / float(factor);\n\tfragColor = vec4( col,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjfRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 174, 196, 196, 276], [278, 278, 300, 300, 638], [640, 640, 659, 659, 861], [863, 863, 889, 889, 954], [956, 956, 979, 979, 1582], [1584, 1584, 1641, 1641, 2074]], "test": "untested"}
{"id": "MtjfRV", "name": "19/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I tried to implement my first path tracer ever. I'm not sure if I'm doing it right and yeah the materials are still quite scars. ", "tags": ["pathtracing"], "likes": 0, "viewed": 98, "published": "Public", "date": "1516579107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Simple path tracer. I used Iq's great article as a tutorial for this.\n//http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n\n#define STEPS 32\n#define FAR 100.0\n#define EPSILON 0.5/iResolution.x\n#define PI 3.14159265359\n\n#define SAMPLES 6.0\n#define BOUNCES 18\n\n#define FOG_COLOR vec3(0.55, 0.6, 0.75)\n#define SUN_COLOR vec3(0.8, 0.75, 0.7)\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 443.8975\nfloat hash(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//Direction functions from Ambient occlusion method\n//introduced in https://www.shadertoy.com/view/4sdGWN\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\n//Distance functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec2 dist(vec3 p){\n    float plane = fPlane(p, vec3(0.0, 1.0, 0.0), 1.0);\n    float sphere = fSphere(p-vec3(-2.0, 0.5, 0.0), 1.0);\n    sphere = min(sphere, fSphere(p-vec3(2.0, 0.5, 0.0), 1.0));\n    \n    float id = 0.0;\n    if(sphere < plane){\n        id = 1.0;\n    }\n    \n    return vec2(min(plane, sphere), id);\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(EPSILON, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy).x-dist(p-eps.xyy).x,\n        dist(p+eps.yxy).x-dist(p-eps.yxy).x,\n        dist(p+eps.yyx).x-dist(p-eps.yyx).x\n    ));\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 1.3;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(dist(ro).x);\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*dist(p).x;\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < EPSILON || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*dist(p).x);\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= EPSILON){\n\t\tt = candidate_t;\n\t}\n    \n    p = ro+rd*t;\n    float id = dist(p).y;\n    \n\treturn vec2(t, id);\n}\n\nvec3 color(float obj){\n    vec3 base = vec3(0.0);\n    if(obj == 1.0){\n        base = vec3(0.6, 0.4, 0.2);\n    }\n    else if(obj == 0.0){\n        base = vec3(0.1, 0.12, 0.15);\n    }\n    return base;\n}\n\n\nvec3 render(vec3 o, vec3 d, vec2 uv){\n    vec3 ro = o;\n    vec3 rd = d;\n    \n    vec3 tcol = vec3(0.0);\n    vec3 fcol = vec3(1.0);\n    \n    for(int i = 0; i < BOUNCES; ++i){\n        vec2 t = march(ro, rd);\n        vec3 p = ro+rd*t.x;\n        if(t.y < 0.0 || t.x > FAR){\n            tcol += FOG_COLOR;\n            break;\n        }\n        vec3 ecol = color(t.y);\n        \n        tcol += ecol * fcol;\n        fcol *= 0.75;\n\n        vec3 n = normals(p);\n        \n        ro = p+(n*0.2);\n        rd = randomHemisphereDir(n, hash13(vec3(uv, float(i)+iTime*0.01)));\n    }\n    \n    return tcol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(5.0*sin(iTime*0.5), 2.0, 5.0*cos(iTime*0.5));\n    vec3 rt = vec3(0.0, 0.5, 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 color = vec3(0.0);\n    \n    for(float i = 0.0; i < SAMPLES; ++i){\n    \tvec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    \tcolor += render(ro, rd, uv);\n    }\n    color /= SAMPLES;\n    \n    color = smoothstep(0.0, 1.3, color);\n    \n    color = pow(color, 1.0/vec3(2.2));\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjfRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 454, 474, 474, 592], [593, 593, 615, 615, 723], [726, 832, 863, 863, 966], [967, 967, 1011, 1011, 1103], [1184, 1258, 1314, 1314, 1356], [1358, 1358, 1390, 1390, 1415], [1417, 1417, 1435, 1435, 1731], [1733, 1733, 1754, 1754, 1965], [2026, 2065, 2085, 2085, 2115], [2117, 2117, 2146, 2146, 3385], [3387, 3387, 3409, 3409, 3586], [3589, 3589, 3626, 3626, 4179], [4182, 4182, 4239, 4239, 4908]], "test": "untested"}
{"id": "MtXSzl", "name": "cmyk dots", "author": "nexor", "description": "cmyk", "tags": ["cymk"], "likes": 3, "viewed": 213, "published": "Public", "date": "1516619604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution.xy\n\nconst float pi = 3.14156;\nconst float pi2 = pi*2.0;\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.8, -0.6, 0.6, 0.8 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 tr(vec2 p)\n{\n\t p /= resolution.xy;\n\t p = -1.0+2.0*p;\n\t p.x *= resolution.x/resolution.y;\n\t return p;\n}\n\nvec2 rot(vec2 p, float deg)\n{\n\tfloat c = cos(deg);\n\tfloat s = sin(deg);\n\tmat2 m = mat2(c,s,\n\t\t   \t\t\t\t\t\t\t\ts,-c);\n\treturn m*p;\n}\n\nvec2 pix(vec2 p, int s)\n{\n\treturn floor(p*float(s)+0.5)/float(s);\n}\n\nfloat eudist(vec2 p, vec2 s)\n{\n\treturn max(abs(p.x-s.x),abs(p.y-s.y));\n}\n\nfloat hex(vec2 p)\n{\n\tp.x *= 0.57735*2.0;\n\tp.y += mod(floor(p.x), 2.0)*0.5;\n\tp = abs((mod(p, 1.0) - 0.5));\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);\n}\n\nfloat circle(vec2 p, float r)\n{\n\t return smoothstep(r,r*.95,length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = tr(fragCoord.xy);\n\tvec3 col = vec3(1.0);\n\n    float t = time*.125;\n    float g = 0.0275;\n\n    p+=vec2(cos(t),sin(t));\n\n    for(int i=0;i<3;++i)\n    {\n    \t vec2 f = rot(p,float(i+1)*-75.);\n    \t vec2 q = mod(f,g)-g*.5;\n         float n = fbm(2.*floor(f/g)*g\n\t\t\t\t\t+4.*t*float(i)+t);\n\t\tcol[i] -= circle(q,n*g*.8);\n    }\n\n    col = sqrt(col);\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXSzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 130, 130, 172], [174, 174, 200, 200, 419], [467, 467, 488, 488, 687], [689, 689, 706, 706, 796], [798, 798, 827, 827, 924], [926, 926, 951, 951, 993], [995, 995, 1025, 1025, 1067], [1069, 1069, 1088, 1088, 1224], [1226, 1226, 1257, 1257, 1299], [1301, 1301, 1358, 1358, 1745]], "test": "untested"}
{"id": "Xl2BDy", "name": "Grid based Particles ", "author": "ircss", "description": "A grid based system that generations glowing particles. ", "tags": ["particlesgenerativ"], "likes": 9, "viewed": 3492, "published": "Public API", "date": "1517049686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 permute(in vec4 x)\n{\n return mod ((34.0 * x + 1.0) * x , 289.0);   \n}\n\nvec2 celluar2x2( vec2 P) {\n    \n    float pp =  7.0; \n \tfloat K = 1.0/pp;\n\tfloat K2 = 0.5/pp;\n\tfloat jitter = 0.8 ; // jitter 1.0 makes F1 wrong more often\n\tvec2 Pi = mod(floor(P), 289.0) ;\n\tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute (Pi.x + vec4(0.0 , 1.0, 0.0, 1.0));\n\tp = permute (p + Pi.y + vec4(0.0 , 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, pp) * K + K2;\n\tvec4 oy = mod(floor(p * K) ,pp) * K + K2;\n\tvec4 dx = Pfx + jitter * ox;\n\tvec4 dy = Pfy + jitter * oy;\n\tvec4 d = dx * dx + dy * dy; // distances squared\n\t// Cheat and pick only F1 for the return value\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn d.xx; // F1 duplicated , F2 not computed\n \n    \n}\n\nvoid DrawAParticleSet(inout vec4 color, vec2 uv, float size ){\n   float aCellLenght = size;\n   vec3 colorTint;\n   float randomSeed01 = rand(floor (uv /aCellLenght));\n   float randomSeed02 = rand(floor (uv /aCellLenght) + 5.0);\n   float randomSeed03 = rand(floor (uv /aCellLenght) + 10.0);\n    \n  \n    colorTint= vec3(randomSeed01, randomSeed02, randomSeed03);\n    \n   float circleLenght =abs(sin(iTime * randomSeed03 + randomSeed02))  * randomSeed01 * aCellLenght;\n   \n   float jitterFreedom = 0.5 - circleLenght;\n   float jitterAmountX =  jitterFreedom * (randomSeed03 *2.0 -1.0);\n   float jitterAmounty =  jitterFreedom * (randomSeed01 *2.0 -1.0); \n   vec2 coord =  fract(uv / aCellLenght);\n    \n    \n   coord -= 0.5;\n   float z = 0.0;\n   vec3 toReturn; \n   for(int i=0; i < 3; i++) {\n       z += 0.015 * celluar2x2(coord + iTime * 0.1).x  /*abs(sin(iTime * randomSeed01 + randomSeed01))*/;\n\t\tcoord += z;\n\t\ttoReturn[i] = 1.0 - smoothstep(circleLenght- 30.5/iResolution.y,\n                                       circleLenght, distance(coord, vec2(jitterAmountX, jitterAmounty)));\n\t}\n    \n   toReturn = mix(color.xyz, colorTint *toReturn, length(toReturn));\n   color = vec4(toReturn.xyz, 0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float screenXLenght = iResolution.x/ iResolution.y;\n    \n    vec4 endColor = vec4(.0);\n    \n    uv.x -= screenXLenght/2.0; \n    uv.y -= 0.5;\n    \n    \n    DrawAParticleSet(endColor, uv, 0.1);\n    DrawAParticleSet(endColor, uv- 0.1, 0.15);\n    DrawAParticleSet(endColor, uv + 0.3, 0.17);\n\tfragColor = vec4(endColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2BDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 93], [95, 95, 120, 120, 169], [171, 171, 197, 197, 924], [926, 926, 988, 988, 2121], [2124, 2124, 2181, 2181, 2544]], "test": "untested"}
{"id": "Xl2BRd", "name": "Volcan Flower", "author": "jpupper", "description": "Like a ... Fauna tunel? \n\nDont know how to call it", "tags": ["mix", "atan", "angle", "length", "tunel", "radius"], "likes": 2, "viewed": 147, "published": "Public", "date": "1516859714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159235659\n\nfloat def(in vec2 uv,float f);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;;\n    vec2 p = vec2(0.5)-uv;\n    float ra = length(p);\n    float a = atan(p.x,p.y);\n\n    float e = sin(uv.x*PI*10.+time+sin(uv.y*PI*10.)+0.03)*sin(a*1.+sin(ra*PI*5.+time*4.)*0.1+time)*sin(ra*PI*5.+time)*sin(sin(a*5.)*sin(ra*PI*5.-time)*0.5);\n\n    float r = def(uv,PI)*3.*(1.-ra*2.)  ;\n    float g = def(uv,PI+PI/18.)*0.5 ;\n    float b = def(uv,PI-PI/18.)*0.5;\n\nfragColor = vec4(r,g,b, 1.0);\n\n}\nfloat def(in vec2 uv,float f){\n    \nfloat time = iTime;\nvec2 p = vec2(0.5)-uv;\nfloat a = atan(p.x,p.y);\nfloat r =length(p);\n\nfloat e3 = sin(uv.x*PI*10.+time+sin(a*10.)*3.)*0.03;\nfloat e2 = sin(r+sin(e3*PI+time*0.7)*0.1);\nfloat e = sin(sin(a*5.)*sin(e2*PI*4.+time)+f+PI*1.5+sin(time)+0.01);\ne = sin(e*PI);\nreturn e;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2BRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 576], [577, 577, 607, 607, 893]], "test": "untested"}
{"id": "Xl2BRR", "name": "The red hiker", "author": "iapafoto", "description": "the red walker", "tags": ["walk", "human", "walkman"], "likes": 66, "viewed": 2906, "published": "Public", "date": "1515080362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------\n// Created by sebastien durand - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n\n// Change this to improve quality (3 is good)\n#define ANTIALIASING 1\n\n//#define WITH_SHADOW\n#define WITH_AO\n\n// Isosurface Renderer\n#define g_traceLimit 64\n#define g_traceSize .004\n\n#define STAR_VOXEL_STEPS 20\n#define STAR_VOXEL_STEP_SIZE 3.\n#define STAR_RADIUS .02\n#define ZERO (min(0, iFrame))\n\nfloat gTime;\n\n//---------------------------------------------------------------------\n//    Animation\n//---------------------------------------------------------------------\n\n//                       Contact           Down               Pass               Up      \n\nvec3[9] HEAD = vec3[9](  vec3(50,24,0),    vec3(73,30,0),     vec3(94,20,0),     vec3(117,15,0),  \n                         vec3(85+50,24,0), vec3(85+73,30,0),  vec3(85+94,20,0),  vec3(85+117,15,0), vec3(168+50,24,0));\n\nvec3[9] SHOULDER = vec3[9](vec3(44,47,16),   vec3(66,53,16),    vec3(91,43,16),    vec3(115,38,16), \n                         vec3(85+51,50,16),vec3(85+73,55,16), vec3(85+91,43,16), vec3(85+111,37,16), vec3(168+44,47,16));\n\nvec3[9] ELBOW = vec3[9]( vec3(25,68,25),   vec3(46,71,25),    vec3(88,74,25),    vec3(120,69,25),\n                         vec3(85+54,66,25),vec3(85+87,71,25), vec3(85+91,75,25), vec3(85+92,65,25), vec3(168+25,68,25));\n\nvec3[9] WRIST = vec3[9](vec3(20,90,15),   vec3(35,81,20),    vec3(88,106,25),   vec3(128,94,25), \n                         vec3(164,85,15),  vec3(85+102,86,20),vec3(85+88,104,25),vec3(85+82,86,20), vec3(168+20,90,15));\n\nvec3[9] HIP = vec3[9](vec3(42,90,10),  vec3(62,95,10.),   vec3(83,88,10),   vec3(107,83,10),  \n                         vec3(127,92,10), vec3(147,94,10.),  vec3(168,91,10),  vec3(192,85,10), vec3(42+168,90,10));\n\nvec3[9] KNEE = vec3[9]( vec3(29,118,7),  vec3(48,120,8),   vec3(97,117,10),  vec3(130,107,10), \n                         vec3(144,120,7), vec3(167,118,7),  vec3(167,118,7),  vec3(181,111,7), vec3(168+29,118,7));\n\nvec3[9] ANKLE=vec3[9](vec3(5,134,5),   vec3(22,132,6),   vec3(71,122,10),  vec3(113,127,10), \n                         vec3(162,146,5), vec3(164,146,5),  vec3(164,146,5),  vec3(168,137,5), vec3(168+5,134,5));\n\nvec3[9] FOOT = vec3[9](  vec3(14,150,10), vec3(16,150,10),  vec3(63,139,10),  vec3(119,143,10), \n                         vec3(178,139,10),vec3(182,150,10), vec3(182,150,10), vec3(182,150,10), vec3(168+14,150,10));\n\n\nvec3 shoulder1, elbow1, wrist1, head,\n     shoulder2, elbow2, wrist2;\nvec3 foot1, ankle1, knee1, hip1,\n     foot2, ankle2, knee2, hip2;\n\nmat2 rot, rot2;\n\n// Interpolate pos of articulations\nvec3 getPos(vec3 arr[9], int it, float kt, float z) {\n    it = it%8;\n    vec3 p = mix(arr[it], arr[it+1], kt);\n\treturn .02*vec3(p.x+floor(gTime/8.)*168., 150.-p.y, p.z*z);\n}\n\n\n//---------------------------------------------------------------------\n//    HASH functions (iq)\n//---------------------------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nvec3 hash33( const in vec3 p) {\n    return fract(vec3(\n        sin( dot(p,    vec3(127.1, 311.7, 758.5453123))),\n        sin( dot(p.zyx,vec3(127.1, 311.7, 758.5453123))),\n        sin( dot(p.yxz,vec3(127.1, 311.7, 758.5453123))))*43758.5453123);\n}\n\n\n//---------------------------------------------------------------------\n//    Palette\n// https://www.shadertoy.com/view/4dsSzr\n//---------------------------------------------------------------------\nvec3 heatmapGradient(float t) {\n\treturn clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\n\n//---------------------------------------------------------------------\n//    Geometry\n//---------------------------------------------------------------------\n\n// Distance from ray to point\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n    //return length(cross(p-ro,rd));\n}\n\n// Distance line / line (must exist simplest way to do this)\nfloat distanceLineLine(vec3 ro1, vec3 u, vec3 ro2, vec3 v) {\n    vec3 w = ro1 - ro2;\n    float a = dot(u,u), b = dot(u,v), c = dot(v,v),\n          d = dot(u,w), e = dot(v,w),\n          D = a*c - b*b,\n     \t  sc = (b*e - c*d) / D,\n     \t  tc = (a*e - b*d) / D;\n    // get the difference of the two closest points\n    vec3 dP = w + (sc * u) - (tc * v);\n    return sc>0. ? length(dP) : 1e3;   // return the closest distance\n}\n\n\n//---------------------------------------------------------------------\n//      Start field (iterate in a 3d grid)\n//---------------------------------------------------------------------\n\nvec4 renderStarField(in vec3 ro, in vec3 rd, in float tmax) { \n    vec3 ros = ro;\n    ros /= STAR_VOXEL_STEP_SIZE;\n\tvec3 offset, id,\n         pos = floor(ros),\n\t     mm, ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ros + .5 + rs*.5) * ri;\n    float dint, d = 0.;\n    vec4 col = vec4(0),\n         sum = vec4(0);\n    \n\tfor( int i=ZERO; i<STAR_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id+.1*cos(id+(id.x)*iTime),STAR_RADIUS, 1.-STAR_RADIUS);\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint>0.&& dint*STAR_VOXEL_STEP_SIZE<tmax) {\n            col.rgb = heatmapGradient(.4+id.x*.6);\n            col = vec4(.6+.4*col.rgb, 1.)*(1.-smoothstep(STAR_RADIUS*.5,STAR_RADIUS,d));\n            col.a *= smoothstep(float(STAR_VOXEL_STEPS),0.,dint);\n            col.rgb *= col.a/dint;\t\t\t\t                                \n            sum += (1.-sum.a)*col;\n            if (sum.a>.99) break;\n        }\n\t\tmm = step(dis, dis.yxy) * step(dis, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\treturn sum;\n}\n\n\n//---------------------------------------------------------------------\n//   Modeling Primitives\n//   [Inigo Quilez] http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------------------\n\nbool cube(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) { //, out vec3 n) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n//\tn = -sign(rd)*step(a.yzx,a)*step(b.zxy,b);\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn>0. && tn<tf;\n}\n\nfloat sdCap(vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCap2(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.))-r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat sdPlane(vec3 p, vec3 n) {\n  // n must be normalized\n  return dot(p,n);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n\n//---------------------------------------------------------------------\n//    Man + Ground distance field \n//---------------------------------------------------------------------\nfloat mapGround(vec3 pos){\n    vec3 te = textureLod(iChannel0, pos.xz*.1,1.).rgb;\n    return pos.y+.3*length(te);\n}\n\nfloat map(in vec3 pos){\n    \n    const float r1= .15, r2 = .1, r3= .1;\n    float d = 100.;\n    \n    // Leg 1\n    d = min(d, sdCap2(pos, foot1, ankle1, r2,r1));\n    d = min(d, sdCap(pos, ankle1, knee1, r1));\n    d = min(d, sdCap2(pos, knee1, hip1, r1,r2));\n \n    // Foot1 flat part - vector base linked to leg 1\n    vec3 v2 = normalize(knee1 - ankle1);\n    vec3 v1 = normalize(ankle1 - foot1-v2*.1);\n    vec3 v3 = cross(v1,v2);\n    d = max(d, -sdPlane(pos-ankle1+v2*.1, -cross(v1,v3))); \n    \n    // Leg 2\n    float d2 = sdCap2(pos, foot2, ankle2, r2,r1);\n    d2 = min(d2, sdCap(pos, ankle2, knee2, r1));\n    d2 = min(d2, sdCap2(pos, knee2, hip2, r1,r2));\n\n    // Foot2 flat part - vector base linked to leg 2\n    v2 = normalize(knee2 - ankle2);\n    v1 = normalize(ankle2 - foot2-v2*.1);\n    v3 = cross(v1,v2);\n    d2 = max(d2, -sdPlane(pos-ankle2+v2*.1, -cross(v1,v3))); \n\n    d = min(d, d2);\n    \n    vec3 ep0 = mix(shoulder1,shoulder2,.5),\n         ha0 = mix(hip1,hip2,.5);\n\n    // Head\n    d = min(d, sdCap2(pos, head - vec3(0,.17,0), head + vec3(-.02,.11,0),.13,.16));\n    \n    // Arm 1\n    v1 = normalize(wrist1-elbow1);\n    d = min(d, sdCap(pos, shoulder1, elbow1, r2));\n    d = min(d, sdCap2(pos, elbow1, wrist1-.05*v1, r2,r3));\n\n    // Hand1 - fix vector base to harm 1\n    v3 = -normalize(cross(v1,normalize(wrist1-shoulder1)));\n    v2 = -cross(v1,v3);\n    vec3 c = wrist1-v3*.06-v1*.12;\n    \n\t// Finders 1\n    d2 = sdCap2(pos, c, wrist1+.1*(v2+v1+v3), .013,.033);\n    d2 = min(d2, sdCap2(pos, c, wrist1+.18*(v1+v2*.2), .01,.03));\n    d2 = min(d2, sdCap2(pos, c, wrist1+.2*(v1-v2*.2), .01,.03));\n    d2 = min(d2, sdCap2(pos, c, wrist1+.15*(v1-v2*.6), .01,.026));\n    \n    // Arm 2\n    v1 = normalize(wrist2-elbow2);\n    d = min(d, sdCap(pos, shoulder2, elbow2, r2));\n    d = min(d, sdCap2(pos, elbow2, wrist2-.05*v1, r2,r3));\n    \n    // Hand2 - fix vector base to harm 2\n    v3 = normalize(cross(v1,normalize(wrist2-shoulder2)));\n    v2 = cross(v1,v3);\n    c = wrist2-v3*.06-v1*.12;\n    \n\t// Finders 2     \n    d2 = min(d2, sdCap2(pos, c, wrist2+.1*(v2+v1+v3), .013, .033));\n    d2 = min(d2, sdCap2(pos, c, wrist2+.18*(v1+v2*.2), .01, .03));\n    d2 = min(d2, sdCap2(pos, c, wrist2+.2*(v1-v2*.2), .01, .03));\n    d2 = min(d2, sdCap2(pos, c, wrist2+.15*(v1-v2*.6), .01, .026));\n\n    d = min(d, sdCap(pos, shoulder1, shoulder2, r2));\n   \td = smin(d2, d, .08);\n    \n    // Torso\n    vec3 a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.78);\n    \n    // Neck\n    d = smin(d, sdCap(pos, mix(shoulder1,shoulder2,.5)-vec3(.1,0,0), head-vec3(.08,.1,0), r2*.5),.06);\n    d = smin(d, sdCap2(pos, a, b, .2,.26),.18);\n\n    // Ground\n    vec3 te = textureLod(iChannel0, pos.xz*.1,1.).rgb;\n    d = min(d, pos.y+.3*length(te));\n    \n    // Belt\n    vec3 pos2 = pos-ha0+vec3(0,-.13,.02);\n    pos2.yz *= rot2;\n    d = min(d,mix(d,sdCappedCylinder(pos2, vec2(.28,.08)),.4)); \n \n    // Backpack\n    pos -= ep0;\n    d2 = udRoundBox(pos+vec3(.33,.2,0), vec3(.1,.3,.2), .15); \n    d2 += .005*(smoothstep(.1,.6,cos(51.*(.2*pos.z+.4*pos.x*pos.x+pos.y)))+smoothstep(.4,.9,sin(51.*(.8*cos(1.+pos.z)+.4*pos.x+.2*pos.y))));\n    pos.yz *= rot;\n    d2 = smin(d2,mix(d,sdCappedCylinder(pos.yzx+vec3(.13,.04,.1), vec2(.37,.05)),.75),.05); \n    \n    return min(d2,d);\n}\n\n\n//---------------------------------------------------------------------\n//   Ray marching scene if ray intersect bbox\n//---------------------------------------------------------------------\n\nfloat Trace(in vec3 pos, in vec3 ray, in float start, in float end ) {\n    // Trace if in bbox (TODO: return intersection with ground otherwise)\n    float t, h, tn, tf, dx = gTime*168.*.02/8.+.85;\n    if (cube(pos-vec3(dx,1.35,0), ray, vec3(1.1, 1.7,.7)*2.,  tn, tf)) {\n        end = min(tf, end);\n        t = max(tn, start);\n        for( int i=ZERO; i < g_traceLimit; i++) {\n            h = map( pos+t*ray );\n            if (h < g_traceSize || t > end)\n                return t > end?100. : t;\n            t += h + .002;\n        }\n    }\n\treturn 100.;\n}\n\n\n//---------------------------------------------------------------------\n//   Soft shadows\n//---------------------------------------------------------------------\n\n#ifdef WITH_SHADOW\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat h, res = 1., t = mint;\n    for(int i=ZERO; i<24; i++) {\n\t\th = map( ro + rd*t );\n        res = min( res, 8.*h/t );\n        t += clamp( h, .05, .20 );\n        if( h<.01 || t>tmax ) break;\n    }\n    return clamp( res, .0, 1.);\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Ambiant occlusion\n//---------------------------------------------------------------------\n\n#ifdef WITH_AO\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=ZERO; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(map( aopos )-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Shading\n//   Adapted from Shane / Iq\n//---------------------------------------------------------------------\n\nvec3 doColor( in vec3 pos, in vec3 rd, in vec3 nor, in vec3 col){\n    vec3 ref = reflect( rd, nor );\n\n    // lighitng   \n#ifdef WITH_AO\n    float occ = calcAO( pos, nor );\n#else\n    float occ = 1.;\n#endif\n    vec3  lig = normalize( vec3(.4, .7, .6) ),\n          hal = normalize( lig-rd );\n    float amb = .4,//clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n          dif = clamp( dot( nor, lig ), 0., 1. ),\n          bac = clamp( dot( nor, normalize(vec3(-lig.x,0.,-lig.z))), 0., 1. )*clamp( 1.-pos.y,0.,1.),\n          dom = smoothstep( -.1, .1, ref.y ),\n          fre = pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n\n#ifdef WITH_SHADOW\n    dif *= calcSoftshadow( pos, lig, .2, 2.5 );\n#endif\n    float spe = pow( clamp( dot( nor, hal ), 0., 1. ),106.)*\n        dif *\n        (.04 + .96*pow( clamp(1. + dot(hal,rd), 0., 1.), 50. ));\n\n    vec3 lin = .80*dif*vec3(1,.8,.55)*(.3+.7*occ) + \n    \t(.4*amb*vec3(.4,.6,1.) +\n    \t .5*dom*vec3(.4,.6,1.) +\n    \t .5*bac*vec3(.25,.25,.25) +\n    \t .25*fre*vec3(1)) * occ;\n    return col*lin + 10.*spe*vec3(1,.9,.7);\n}\n\n\n//---------------------------------------------------------------------\n//   Calculate normal\n//   From TekF \n//---------------------------------------------------------------------\nvec3 Normal( vec3 ro, vec3 rd, float t) {\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = ro+d.xxx, // tetrahedral offsets\n\t     p1 = ro+d.xyy,\n\t     p2 = ro+d.yxy,\n\t     p3 = ro+d.yyx;\n\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2),\tf3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - ro*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(0., dot(grad,rd ))*rd);\n}\n\nvec3 NormalGround(vec3 ro, vec3 rd, float t) {\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = ro+d.xxx, // tetrahedral offsets\n\t     p1 = ro+d.xyy,\n\t     p2 = ro+d.yxy,\n\t     p3 = ro+d.yyx;\n\n\tfloat f0 = mapGround(p0), f1 = mapGround(p1), f2 = mapGround(p2),\tf3 = mapGround(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - ro*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,rd ))*rd);\n}\n\n\n//---------------------------------------------------------------------\n//   Camera\n//---------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr) {\n\tvec3 cw = normalize(ta-ro),\n         cp = vec3(sin(cr), cos(cr),0.),\n         cu = normalize( cross(cw,cp) ),\n         cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//---------------------------------------------------------------------\n//   Entry point\n//---------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime*6.;\n   \n    // Animation\n    int it = int(floor(gTime));\n    float kt = fract(gTime);\n    \n    float dz = 1.;\n   \n    head = getPos(HEAD, it, kt, dz);\n\n    shoulder1 = getPos(SHOULDER, it, kt, -dz);\n    elbow1 = getPos(ELBOW, it, kt, -dz);\n    wrist1 = getPos(WRIST, it, kt, -dz);\n    \n    foot1 = getPos(FOOT, it, kt, dz);\n    ankle1 = getPos(ANKLE, it, kt, dz);\n    knee1 = getPos(KNEE, it, kt, dz);\n    hip1 = getPos(HIP, it, kt, dz);\n    \n    shoulder2 = getPos(SHOULDER, it+4, kt, dz);\n    elbow2 = getPos(ELBOW, it+4, kt, dz);\n    wrist2 = getPos(WRIST, it+4, kt, dz);\n\n    foot2 = getPos(FOOT, it+4, kt, -dz);\n    ankle2 = getPos(ANKLE, it+4, kt, -dz);\n    knee2 = getPos(KNEE, it+4, kt, -dz);\n    hip2 = getPos(HIP, it+4, kt, -dz);\n\n    \n    float a = -1.5708*.4;\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    a = -.15708;\n    rot2 = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    float dx = it%8 < 4 ? -85.*.02 : +85.*.02; \n    foot2.x += dx;\n    ankle2.x += dx;\n    knee2.x += dx;\n    hip2.x += dx;\n\n    shoulder2.x += dx;\n    elbow2.x += dx;\n    wrist2.x += dx;\n    \n// ------------------------------------\n \n    vec2 q, m = iMouse.xy/iResolution.y - .5;\n     \n\tfloat t, s1, s2, traceStart = .2;\n    \n    vec3 pos, ro, rd, col = vec3(0), colorSum = vec3(0);\n     \n#if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float randPix = hash(iTime);\n        vec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));        \n    \t// camera\t\n        q = (fragCoord.xy+subPix)/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n\n        ro = vec3(hip1.x+12.*cos(3.14*(.01*iTime+m.x+.3)),3.+3.*abs(sin(.01314*iTime))+10.*(m.y+.3),hip1.z+12.*sin(3.14*(.01*iTime+m.x+.3)));// .9*cos(0.1*time), .45, .9*sin(0.1*time) );\n        vec3 ta = hip1;\n\n        ta.x +=1.2;\n        ta.y = 1.2;\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera(ro, ta, 0.);\n\n        // ray direction\n        rd = ca * normalize( vec3(p.xy,4.5) );\n\n        float tGround = -ro.y / rd.y;\n        float traceEnd = 100.;//min(tGround,100.);\n        traceStart = 10.;\n        col = vec3(0);\n        vec3 n;\n        t = Trace(ro, rd, traceStart, traceEnd);\n        \n        if (tGround < 0.) \n            tGround = 100.;\n        \n        t = min(t, tGround);\n        \n        if (t<100.) {\n            pos = ro + rd*t;\n            n = pos.y<.02 ? NormalGround(pos, rd, t) : Normal(pos, rd, t);\n            col = doColor(pos, rd, n, pos.y<.02 ? .02*vec3(.8,.8,.9) : vec3(.5,.0,.0));\n            \n        } else {\n            // mysterious line in sky            \n            float time = iTime*.5;\n            float kt = fract(time);\n            vec3 k = -.5+hash33(floor(time)+vec3(0, 2, 112));\n            if (k.y>.25) {\n                float t0 = distanceLineLine(ro,rd, k*200.+vec3(-100,0,0), normalize(k));\n                col = vec3(1,.8,.7) * (1.-smoothstep(0.,.8,t0)) * smoothstep(.53,.01,rd.y+.2*kt);\n                col *= (.5+.5*hash(time))*smoothstep(0.,1., kt);\n            }\n        }\n        \n#if (ANTIALIASING > 1)\t\n        colorSum += col;\n\t}\n    \n    col = colorSum/float(ANTIALIASING);\n#endif\n    \n    // Render star dusts ------------------------\n    vec4 star = renderStarField(ro, rd, t);\n    \t star.rgb += col.rgb * (1. - star.a);\n    \t col = star.rgb;\n         \n    // Post processing stuff --------------------\n    // Fog\n    float f = 50.;\n    col = mix( vec3(.18), col, exp2(-t*vec3(.4,.6,1)/f) );\n\t// Gamma\n    col = pow( col, vec3(.4545) );\n    // Vigneting\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .1); \n    \n\tfragColor =  vec4(col,1);\n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2BRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2693, 2729, 2782, 2782, 2902], [2905, 3076, 3099, 3099, 3137], [3139, 3139, 3170, 3170, 3385], [3388, 3587, 3618, 3618, 3763], [3926, 3956, 4019, 4019, 4110], [4112, 4173, 4233, 4233, 4595], [4598, 4786, 4847, 4847, 5834], [5837, 6094, 6160, 6178, 6399], [6401, 6401, 6448, 6448, 6573], [6575, 6575, 6633, 6633, 6768], [6770, 6770, 6815, 6815, 6854], [6856, 6856, 6897, 6897, 6994], [6996, 6996, 7027, 7053, 7074], [7076, 7076, 7125, 7125, 7213], [7216, 7395, 7421, 7421, 7510], [7512, 7512, 7535, 7535, 10748], [10751, 10942, 11012, 11086, 11495], [12507, 12694, 12759, 12759, 13728], [13731, 13913, 13954, 13954, 14414], [14416, 14416, 14462, 14462, 14946], [14949, 15106, 15160, 15160, 15345]], "test": "untested"}
{"id": "Xl2BzW", "name": "new day", "author": "netgrind", "description": "new day", "tags": ["starburst"], "likes": 24, "viewed": 480, "published": "Public", "date": "1514904985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COUNT 218.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*6.28*.1;\n    fragCoord -= iResolution.xy*.5;\n\tvec2 uv = fragCoord.xy / iResolution.xx*15.;\n    \n    float d = length(uv);\n    float f = 0.;\n    float phase = t;\n    float dir = 1.;\n    float a = 0.;\n    float len = -d*(cos(t)*.2+.2);\n    for(float i = 0.; i<COUNT; i+=1.){\n        float p = phase +(sin(i+t)-1.)*.05+len;\n        a = dot(normalize(uv), normalize(vec2(cos((p)*dir), sin((p)*dir))));\n        a = max(0., a);\n        a = pow(a, 10.);\n\t\tdir*=-1.;\n        phase+=mod(i,6.28);\n        f += a;\n        f = abs(mod(f+1., 2.)-1.);\n    }    \n    f+=1.7-d*(.7+sin(t+dot(normalize(uv), vec2(1., 0.))*12.)*.02);\n    f = max(f, 0.);\n    vec3 c = mix( vec3(0.), vec3(1., .9, .6), f);\n    c = min(max(c, 0.),1.);\n    c = 1.0-vec3(.6, .4, .3)*3.*(1.0-c);\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2BzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 880]], "test": "untested"}
{"id": "XlBBDD", "name": "Open box fractal", "author": "lherm", "description": "just some fun", "tags": ["raymarch"], "likes": 2, "viewed": 480, "published": "Public API", "date": "1515742819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define mouse iMouse\n#define resolution iResolution\n#define time iTime\n#define PI 3.1415926\n\nfloat id;\n\nfloat fftsmooth(float a, sampler2D s)\n{\n    //from nick shelton\n    //FFT_smooth_n = FFTRaw_n * alpha + FFT_smooth_n-1 * (1 - alpha)\n    float audio = texture(s, vec2(.5)).r;\n    return audio * a + audio-1. * (1.-a);\n    \n}\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nmat2 r(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat box(vec3 p, float s)\n{\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z)) - s;\n    d = max(d, -(max(\n        min(p.x, p.y), max(\n            min(p.x, p.z), min(p.y, p.z))\n        ) - s*.8));\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    //p.z -= time;\n    p = mod(p+3., 6.)-3.;\n    float A = fftsmooth(.3, iChannel0);\n    p.z += 1.;\n    float d = 1e5, s = .8;\n    id = 0.;\n    for (int i = 0; i < 7; i++)\n    {       \n        p = abs(p);\n        p.xz *= r(A*.5);\n        p.yz *= r(A*.5);\n        p.xy *= r(A*.5);\n        p.x -= s*.5 + A*.1;\n        p.y -= s*.5 + A*.1;\n        s *= .8 + .5*sin(float(i) + time);\n        d =  min(d, box(p, s));\n        id = float(i);\n    }\n    return d;\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for (int i = 0; i < 50; i++)\n    {\n        vec3 p = ro + rd * t;\n        float h = map(p);\n        t += h;\n        if (h < 1e-2 || t > 40.) break;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-resolution.xy) / resolution.y;\n    vec3 ro = vec3(0, 0, 1), rd = normalize(vec3(uv, -1));\n    float t = trace(ro, rd);\n    vec3 p = ro + rd * t;\n    fragColor += t*.4;\n    fragColor.g = 0.;\n    fragColor.xyz = hue(fragColor.xyz, sin(id+t + time));\n    fragColor = mix(fragColor, vec4(0.), smoothstep(20., 20.5, t));\n}", "image_inputs": [{"id": "4dSXzm", "previewfilepath": "https://soundcloud.com/randyachtz/trustme", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/randyachtz/trustme", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 143, 236, 327], [329, 329, 364, 364, 1313], [1315, 1315, 1332, 1332, 1398], [1400, 1400, 1428, 1428, 1615], [1617, 1617, 1636, 1655, 2092], [2094, 2094, 2125, 2125, 2316], [2319, 2319, 2376, 2376, 2722]], "test": "untested"}
{"id": "XlBBDG", "name": "Menger Square Sketch.", "author": "Glyph", "description": "Quick and dirty menger square with crummy AA. \n\nMouse x controls zooming centered at the bottom left corner", "tags": ["2d", "fractal", "menger"], "likes": 2, "viewed": 432, "published": "Public API", "date": "1516929370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ONETHIRD (1.0/3.0)\n#define BACKGROUND vec3(.012, .014, .013)\n\n#define MAXITERATIONS 18\n#define SUPERSAMPLE_ON\n\n// Smooth HSV to RGB conversion - Courtesy of IQ\nvec3 hsv2rgb_smooth( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat mengerSquare(in vec2 uv, in float pixsize){\n    \n    float val = 1.0;\n    float holesize = ONETHIRD;\n    \n    // Check if point is within 1/3 and 2/3 of the unit square then iteratively\n    // do the same for smaller sub squares. Exit's early if the size of the holes\n    // being checked is smaller than can be rendered/seen. \n    for(int itr = 0; itr < MAXITERATIONS && val >= .5 && pixsize <= holesize; itr++){\n        vec2 dblchk = step(vec2(ONETHIRD), uv) * step(uv, vec2(2.0*ONETHIRD));\n        val = 1.0-(dblchk.x * dblchk.y);\n        uv = fract(uv*3.0);\n        holesize*=ONETHIRD;\n    }\n    // Question: Does MAXITERATIONS matter? Assuming infinite zooming isn't \n    // allowed, does putting a maximum upper bound on the loop change anything\n    // in the way the code compiles or runs? \n    \n    return(val);\n}\n\n// Naive bit of supersampling to avoid rectangles and artifacts as things become small. \n#define SUPERSAMPLE(_UV, _PX){\\\n    float quartpix = (_PX)*.25;\\\n    vec2 pcuv = (uv) + (_PX)*.5;\\\n    float ssbl = mengerSquare(fract(pcuv-quartpix) , (_PX));\\\n    float sstr = mengerSquare(fract(pcuv+quartpix) , (_PX));\\\n    float ssbr = mengerSquare(fract(pcuv+vec2(quartpix, -quartpix)), (_PX));\\\n    float sstl = mengerSquare(fract(pcuv+vec2(-quartpix, quartpix)), (_PX));\\\n    fmask = (ssbl + sstr + ssbr + sstl)*.25;\\\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord / iResolution.y);\n    float pixsize = (1.0 / iResolution.y);\n    \n    // Get zoom from mouse and apply it. \n    float uvscalar = .000001 + pow(iMouse.x/iResolution.x, 2.0) * step(0.0, iMouse.z) + step(iMouse.z, 0.0);\n    uv *= uvscalar; pixsize *= uvscalar;\n    \n    // Coloring hue = sqrt(10 x distance along nearest axis) offset with time \n    float hue = sqrt( 10.0*max(abs(fract(uv.x)-.5),abs(fract(uv.y)-.5)))-iTime*.25;\n    vec3 mengerColor = hsv2rgb_smooth(vec3(hue, .4, .8));\n    \n    vec3 col; float fmask;\n#ifdef SUPERSAMPLE_ON\n    SUPERSAMPLE(uv, pixsize); \n#else\n    fmask = mengerSquare(fract(uv), pixsize);\n#endif\n    col = mix(BACKGROUND, mengerColor, fmask);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 168, 201, 201, 377], [379, 379, 428, 428, 1206], [1208, 1725, 1781, 1781, 2513]], "test": "untested"}
{"id": "XlBBDR", "name": "SDF isolines of metaball-cluster", "author": "MacSlow", "description": "Distance-lines of an animated metaballs-cluster should look interesting I thought. So I tied. I also tried to keep the aliasing of these isolines to a minimum. Apart from looking cool, it is a known method to \"debug\" the consistency of the distance-field.", "tags": ["3d", "raymarching", "sdf", "distance", "pbr"], "likes": 7, "viewed": 1483, "published": "Public API", "date": "1515224750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// SDF isolines of metaball-cluster - visualizing distance-field iso-lines\n//\n// Copyright 2018 Mirco Mller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Mouse y-coordinate moves ground-plane up and down\n\nconst int MAX_STEPS = 64;\nconst float EPSILON = .0001;\nconst float STEP_SIZE = .975;\nconst float PI = 3.14159265359;\n\nfloat saturate (in float v) { return clamp (v, .0, 1.); }\n\n// ray-marching, SDF stuff /////////////////////////////////////////////////////\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\nfloat opCombine (in float d1, in float d2, in float r) {\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat metaBalls (in vec3 p) {\n    float r1 = .1 + .3 * (.5 + .5 * sin (2. * iTime));\n    float r2 = .15 + .2 * (.5 + .5 * sin (3. * iTime));\n    float r3 = .2 + .2 * (.5 + .5 * sin (4. * iTime));\n    float r4 = .25 + .1 * (.5 + .5 * sin (5. * iTime));\n\n    float t = 2. * iTime;\n    vec3 offset1 = vec3 (-.1*cos(t), .1, -.2*sin(t));\n    vec3 offset2 = vec3 (.2, .2*cos(t), .3*sin(t));\n    vec3 offset3 = vec3 (-.2*cos(t), -.2*sin(t), .3);\n    vec3 offset4 = vec3 (.1, -.4*cos(t), .4*sin(t));\n    vec3 offset5 = vec3 (.4*cos(t), -.2, .3*sin(t));\n    vec3 offset6 = vec3 (-.2*cos(t), -.4, -.4*sin(t));\n    vec3 offset7 = vec3 (.3*sin(t), -.6*cos(t), .6);\n    vec3 offset8 = vec3 (-.3, .5*sin(t), -.4*cos(t));\n\n    float ball1 = sdSphere (p + offset1, r4);\n    float ball2 = sdSphere (p + offset2, r2);\n\tfloat metaBalls = opCombine (ball1, ball2, r1);\n\n    ball1 = sdSphere (p + offset3, r1);\n    ball2 = sdSphere (p + offset4, r3);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);\n\n    ball1 = sdSphere (p + offset5, r3);\n    ball2 = sdSphere (p + offset6, r2);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);\n\n    ball1 = sdSphere (p + offset7, r3);\n    ball2 = sdSphere (p + offset8, r4);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);\n\n    return metaBalls;\n}\n\nfloat map (in vec3 p) {\n    return min (metaBalls (p), p.y + 2. * (2. * (1. - iMouse.y / iResolution.y) - 1.) );\n}\n\nfloat march (in vec3 ro, in vec3 rd) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = ro + d * rd;\n        t = map (p);\n        if (t < EPSILON) break;\n        d += t*STEP_SIZE;\n    }\n\n    return d;\n}\n\n// pbr, shading, shadows ///////////////////////////////////////////////////////\nfloat distriGGX (in vec3 N, in vec3 H, in float roughness) {\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat geomSchlickGGX (in float NdotV, in float roughness) {\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat geomSmith (in vec3 N, in vec3 V, in vec3 L, in float roughness) {\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = geomSchlickGGX (NdotV, roughness);\n    float ggx2 = geomSchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness) {\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nvec3 normal (in vec3 p) {\n\tfloat d = map (p);\n    vec3 e = vec3 (.001, .0, .0);\n    return normalize (vec3 (map (p + e.xyy) - d,\n                            map (p + e.yxy) - d,\n                            map (p + e.yyx) - d));\n}\n\nfloat shadow (in vec3 p, in vec3 lPos) {\n    float lDist = distance (p, lPos);\n    vec3 lDir = normalize (lPos - p);\n    float dist = march (p, lDir);\n    return dist < lDist ? .1 : 1.;\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d) {\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p);\n\n    // \"material\" hard-coded for the moment \n    float mask = smoothstep (1., .05, 30.*cos (50.*p.y)+sin (50.*p.x)+ cos (50.*p.z));\n    vec3 albedo = mix (vec3 (.5), vec3 (.2), mask);\n    float metallic = .5;\n    float roughness = mix (.45, .175, mask);\n    float ao = 1.;\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.7, .8, .9)*2.;\n    lightColors[1] = vec3 (.9, .8, .7)*2.;\n\n    vec3 lightPositions[2];\n    lightPositions[0] = vec3 (-1.5, 1.0, -3.);\n    lightPositions[1] = vec3 (2., -.5, 3.);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (0.04); \n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3(.0);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for(int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - p);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - p);\n        float attenuation = 20. / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;\n        \n        // cook-torrance brdf\n        float aDirect = pow (roughness + 1., 2.);\n        float aIBL =  roughness * roughness;\n        float NDF = distriGGX(N, H, roughness);        \n        float G   = geomSmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);       \n        \n        vec3 kS = F;\n        kD = vec3(1.) - kS;\n        kD *= 1. - metallic;\t  \n        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = nominator / max(denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n\t    Lo *= shadow (p+.01*N, L);\n    }\n\n    vec3 irradiance = vec3 (1.);\n    vec3 diffuse    = irradiance * albedo;\n    vec3 ambient    = (kD * diffuse) * ao;\n\n    return ambient + Lo;\n}\n\n// create view-ray /////////////////////////////////////////////////////////////\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n    \n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\n// bringing it all together ////////////////////////////////////////////////////\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // set up \"camera\", view origin (ro) and view direction (rd)\n    float t = iTime + 5.;\n    float angle = radians (300. + 55. * t);\n    float dist = 1.25 + cos (1.5 * t);\n    vec3 ro = vec3 (dist * cos (angle), 2., dist * sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    float d = march (ro, rd);\n    vec3 p = ro + d * rd;\n    \n    vec3 n = normal (p);\n    vec3 col = shade (ro, rd, d);\n    col = mix (col, vec3 (.0), pow (1. - 1. / d, 5.));\n\n    // painting the isolines\n    float isoLines = metaBalls (p);\n    float density = 4.;\n    float thickness = 260.;\n    if (isoLines > EPSILON) {\n\t    col = mix (col, vec3 (.1, .2, .5), pow (1. - 1. / d, 5.));\n        col.rgb *= saturate (abs (fract (isoLines*density)*2.-1.)*thickness/(d*d));\n    }\n\n    // tone-mapping, gamme-correction, vignette\n    col = col / (1. + col);\n    col = sqrt (col);\n    col *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .15);\n\n\tfragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBBDR.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[955, 1127, 1156, 1156, 1184], [1186, 1267, 1307, 1307, 1336], [1338, 1338, 1394, 1394, 1498], [1500, 1500, 1529, 1529, 2826], [2828, 2828, 2851, 2851, 2942], [2944, 2944, 2982, 2982, 3192], [3194, 3275, 3335, 3335, 3588], [3590, 3590, 3649, 3649, 3757], [3759, 3759, 3830, 3830, 4041], [4043, 4043, 4113, 4113, 4193], [4195, 4195, 4220, 4220, 4425], [4427, 4427, 4467, 4467, 4614], [4616, 4616, 4665, 4665, 6774], [6776, 6857, 6923, 6923, 7256], [7258, 7339, 7395, 7395, 8553]], "test": "untested"}
{"id": "XlBBDW", "name": "StaRRRs", "author": "duvengar", "description": "A layered star field based on screen tiling, colored upon a RGB fbm cloud.", "tags": ["2d", "stars", "tiling", "layers"], "likes": 25, "viewed": 675, "published": "Public", "date": "1515786067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(x, y, z) smoothstep(x, y, z)\n#define M(t, d) mat2(cos(t * d), sin(t * d), -sin(t * d), cos(t * d))\n#define SEED .2831\n#define PI acos(-1.)\n\n// fbm code by @iq // https://www.shadertoy.com/view/lsfGRr\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 91438.55123);   \n}\n\nfloat hash2(vec2 p)\n{\n    // hash2 taken from Dave Hoskins \n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * SEED);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\nmat2 m = mat2( 0.6, 0.6, -0.6, 0.8);\nfloat fbm(vec2 p){\n \n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= m * 2.02;\n    f += 0.2500 * noise(p); p *= m * 2.03;\n    f += 0.1250 * noise(p); p *= m * 2.01;\n    f += 0.0625 * noise(p); p *= m * 2.04;\n    f /= 0.9375;\n    return f;\n}\n\nfloat star(vec2 uv, vec2 scale, float density){\n\n    \n    vec2 grid = uv * scale;\n    vec2 id = floor(grid);  \n    grid = fract(grid) - .5;\n\n    float d = length(grid);  \n    float r = pow(hash2(id), density);\n    float star = S(-.01, clamp(r,.0,.5), d);\n\n    return 1. - star ;\n}\n\nfloat halo(vec2 uv, vec2 scale, float density){\n\n    \n    vec2 grid = uv * scale;\n    vec2 id = floor(grid);  \n    grid = fract(grid) - .5;\n\n    float d = length(grid);  \n    float r = pow(hash2(id), density);\n    float a = S(-.4, clamp(r,.0,.5), d);\n\n    return 1. - a ;\n}\n\nfloat bigstar(vec2 uv, vec2 scale, float density, float angle, float speed){\n\n    //angle *= PI*.5;\n    vec2 grid = uv * scale;\n    vec2 id = floor(grid);  \n    grid = fract(grid) - .5;\n\n    float d = length(grid);  \n    float dx = length(M(-angle,speed)*grid*vec2(5.0,.1)); \n    float dy = length(M(-angle,speed)*grid*vec2(.1,5.)); \n    float r = pow(hash2(id), density);\n    float star = S(-.01, clamp(r,.0,.3), d);\n    \n    float l = S(.0, 1.,length(grid-1.));\n \n\n    return   1. - S(-.1,r*l*l, 2.*sqrt(dot(dx,dy)));\n}\n\n\nvec2 dist(vec2 uv){\n    \n    vec2 d = vec2(.0);\n    d += .2*dot(uv,uv)-.5;\n    \n return d;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    \n    vec2 st = uv * 1.35;\n   \n    \n    st += dist(st);\n    float t = iTime * .01;\n    \n    uv-= vec2(.8,.5);\n    st += sign(dot(uv,uv));\n    uv += sign(dot(uv,uv));\n\n\n    float mw = S(-.5, 1.5, length(uv));\n    \n    \n    float a0 = halo(M( t, 2.5) * uv, vec2(15.), mw * 50.0);\n    float l0 = a0+bigstar(M( t, 2.5) * uv, vec2(15.), mw * 50.0,  t , 2.5);\n    \n    \n    \n    float l1 = star(M(10.+t, 2.0) * uv * .8, vec2(120.0), mw * 80.0);\n    float l2 = star(M(20.+t, 1.5) * uv * .6, vec2(150.), mw * 100.0);\n    float l3 = star(M(t*1.4, 1.0) * uv, vec2(200.), mw * 120.0);\n    \n    float a4 = halo(M(PI+t*1.4, 3.0) * uv, vec2(15.), mw * 90.0);\n    float l4 = a4+bigstar(M(PI+t*1.4, 3.) * uv, vec2(15.), mw * 90.0, t * 1.4  , 3.);\n    \n    uv -= sign(dot(uv,uv));\n    \n    vec2 n1 = vec2(.2 * t, .2 * t);\n    vec2 n2 = vec2(.3 * t, .3 * t);\n    vec2 n3 = vec2(.4 * t, .4 * t);\n    \n    float r = .23 * fbm(M(t, 2.5) * (1.5*st + n1));\n    float g = .24 * fbm(M(t, 2.0) * ( 2. * st + n2));\n    float b = .26 * fbm(M(t, 1.5) * (1. * st + n3));\n    \n    vec4 cl = pow(vec4(r, g, b, 1.), vec4(1.3));\n    cl = cl + cl;\n    \n    vec4 s = vec4(vec3(l0 + l1 + l2 + l3 + l4), 1.0);\n    cl = pow(cl  + cl , vec4(1.5));\n    cl = pow(cl + cl + cl , vec4(1.5))*.7;\n \n   \n    cl = mix( cl + cl,  cl * s , .85);\n \t\n    cl += cl * 2.;\n    cl.xyz += .5 * pow(1.-length(uv/2.), 2.5);\n\n    cl = .9 * clamp(cl, vec4(.0), vec4(1.));\n\n    cl += S(.0,1.,S(.7, 1.,s));\n    float cl1 = fbm((fbm(st*.4) - vec2(t, t )) * 15.) * dist(uv).x;\n\n    \n    cl = mix(cl,   cl + cl1+cl1+cl1, .8);\n\tcl += .33 * fbm( vec2(-iTime*.3,iTime*.3) + (uv * 20.)) ;\n    cl -= min(cl, vec4(-.3, .0, -.5, 1.));\n    cl -= .8*dot(uv,uv);\n    \n\tfragColor = cl ;\n    \n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBBDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 211, 232, 232, 277], [279, 279, 300, 383, 499], [501, 501, 527, 527, 734], [773, 773, 791, 791, 1017], [1019, 1019, 1066, 1066, 1299], [1301, 1301, 1348, 1348, 1574], [1576, 1576, 1652, 1675, 2097], [2100, 2100, 2119, 2119, 2195], [2198, 2198, 2255, 2255, 4076]], "test": "untested"}
{"id": "XlBBRw", "name": "pixel mandalas of perfection", "author": "whitenoise", "description": "variation of https://www.shadertoy.com/view/4tBBRw", "tags": ["2d", "moire"], "likes": 2, "viewed": 165, "published": "Public", "date": "1514944342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 120.0 * ((fragCoord.xy - iResolution.xy/2.)/ iResolution.y) + vec2(0, 0);\n    //uv = floor(uv) + smoothstep(0.0, 1.0, fract(uv));\n    uv = floor(uv);\n    uv = uv / (2.5f + iTime*0.02);\n    \n    float d = 1.0; // + sqrt(length(uv)) / 109.0;\n    float t = 10. + iTime + 200.;\n    float value = d * t + (t * 0.125) * cos(uv.x) * cos(uv.y);\n    float color = sin(value) * 3.0;\n    \n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    \n    vec4 lifeColor;\n        \n    if(color > 0.) {\n      lifeColor = vec4(high, high, med,1.0);\n    } else {\n      lifeColor = vec4(med, high, high,1.0);\n    }\n        \n    fragColor = lifeColor * 1.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBBRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 751]], "test": "untested"}
{"id": "XlBBWR", "name": "Ray-marching + lambert shading", "author": "Brendan", "description": "A simple ray marcher with lambertian shading. I know the lighting and shading are very crude but this is my first ray-marcher and my first shader toy shader. There's also probably a ton of errors/inefficiencies in the code too.", "tags": ["raymarching"], "likes": 1, "viewed": 110, "published": "Public", "date": "1515196308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.001;\nconst vec3 light = normalize(vec3(5,3,-1));\nconst float limit = 100.0;\n\nfloat map(vec3 p){\n    vec3 q = fract(p) * 3.0 - 1.5;\n\n    return length(q)-0.3;\n}\n\nfloat march(vec3 o, vec3 r){\n \tfloat t = 0.0;\n    for(int i=0;i<64;++i){\n        vec3 p = o+r*t;\n        float d = map(p);\n        t+=d*0.3;\n        if(t>limit){\n            return limit;\n        }\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x+EPSILON,p.y,p.z))-map(vec3(p.x-EPSILON,p.y,p.z)),\n        map(vec3(p.x,p.y+EPSILON,p.z))-map(vec3(p.x,p.y-EPSILON,p.z)),\n        map(vec3(p.x,p.y,p.z+EPSILON))-map(vec3(p.x,p.y,p.z-EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n\n    uv.x*= iResolution.x/iResolution.y;\n    \n    float theta = iTime/10.0;\n    \n    //took me forever to figure out this\n    mat3 rotate = mat3(\n        cos(theta),sin(theta),0,\n        -sin(theta),cos(theta),0,\n        0,0,1\n        );\n\n    vec3 r = normalize(vec3(uv,2))*rotate;\n\n    vec3 o = vec3(iTime,0,iTime);\n\n    float t = march(o,r);\n\n    if((t == limit) || map(t * r + o)>EPSILON){\n        fragColor = vec4(0,0,0,1);\n    }else{\n\n    vec3 n = getNormal(t * r + o);\n\n    vec3 fc = dot(n,light)*vec3(0.1,0.2,0.5)*2.0;\n\n\tfragColor = vec4(fc, 1);\n\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBBWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 119, 119, 183], [185, 185, 213, 213, 404], [406, 406, 430, 430, 679], [681, 681, 738, 738, 1368]], "test": "untested"}
{"id": "XlBfDh", "name": "Self Assembly", "author": "rohtie", "description": "Fooling around with some fake 3D stuff :)", "tags": ["deform"], "likes": 0, "viewed": 111, "published": "Public", "date": "1515495476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 p = uv;\n\tfragColor = texture(iChannel0, uv - mod(uv, 0.02));\n    uv -= mod(uv, 0.04 * (1. - uv.y) * 3.);\n    uv.x -= sin(uv.y * 10. - iTime * 0.4) * 0.2;\n    float r = smoothstep(0., 0.01, length(uv) - 0.4);\n    p.x += sin(p.y * 300. + iTime) * 3.;\n    fragColor = vec4(1. - r) * vec4(p.y + 0.632, p.y * 5. - 0.9, p.y * 1.5, 0.) + r * vec4(1., 0.25, (1. - abs(p.x)) * 0.75, 1.);\n    fragColor += exp(p.x) * 0.0025;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBfDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 588]], "test": "untested"}
{"id": "XlBfDK", "name": "sneaker modeling", "author": "yasuo", "description": "Sneaker modeling experiment. I actually wanted to create like this and will work on another shape in my spare time.....", "tags": ["glitch", "raymerching", "sneaker"], "likes": 1, "viewed": 525, "published": "Public API", "date": "1517408502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Always Thank you for Mr Iq's great distance function.\n// raymarching based from https://www.shadertoy.com/view/lt2Bz3\n\n#define STEPS 50.\n#define VOLUME .01\n#define FAR 60.\n#define PI 3.14159\n\nvec2 hash(vec2 v) {\n\tvec2 n;\n\tn.x=fract(cos(v.y-v.x*841.0508)*(v.y+v.x)*3456.7821);\n\tn.y=fract(sin(v.x+v.y*804.2048)*(v.x-v.y)*5349.2627);\n\treturn n;\n}\n\n//from http://glsl.herokuapp.com/e#4841.11\nfloat partition_noise(vec2 p) {\n\tvec2 id;\n\t\n\tid = floor(floor(p)-.3);\n\t\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\t\n\tp.yx *= floor(hash(id) * 3.)-3.;\n\tid -= floor(p);\n\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\n\tp -= id;\n\n\tvec2 u = abs(p - .6) * 3.;\n\n\treturn max(u.x, u.y);\n}\n\nfloat partition_noise2(vec2 p) \n{\n\tvec2 id;\n\t\n\tp.yx *= floor(hash(id) * 3.)-2.;\n\tid -= floor(p);\n\n\tp *= floor(hash(id) * 3.)+3.;\n\tid = floor(p);\n\n\tp -= id;\n\n\tvec2 u = abs(p - .3) * 3.;\n\n\treturn max(u.x, u.y);\n}\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nvec3 lookAt (vec3 eye, vec3 target, vec2 uv) {\n  vec3 forward = normalize(target-eye);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  return normalize(forward + uv.x * right + uv.y * up);\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec3 camera (vec3 p) {\n    float click = clamp(iMouse.z, 0., 1.);\n    p.yz *= rot(click*(-.25*PI*(iMouse.y/iResolution.y-.5)));\n    p.xz *= rot(click*(-.5*PI*(iMouse.x/iResolution.x-.5)));\n    p.xz *= rot((1.-click)*(.5*PI*(.4*sin(iTime*.1))));\n    p.xz *= rot(iTime*0.2);\n    return p;\n}\n\nfloat sdSphereCustom (vec3 p, float r, vec3 form) {\n    p.x *= form.x;\n    p.y *= form.y;\n    p.z *= form.z;\n    return length(p)-r; \n}\n\nfloat sdCappedCylinderCustom( vec3 p, vec2 h, vec3 form )\n{\n    p.x *= form.x;\n    p.y *= form.y;\n    p.z *= form.z;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorusCustom( vec3 p, vec2 t, vec3 form ){\n    p.x *= form.x;\n    p.y *= form.y;\n    p.z *= form.z;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdFloor (vec3 p){return dot(p, vec3(0.0, 1.0, 0.0)) + 1.0;}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 map(vec3 p,vec2 uv) {\n    p.y+= 0.2;\n    vec3 pos = p;\n    vec3 pos2 = p;\n    vec3 pos3 = p;\n    vec3 pos4 = p;\n    vec3 pos5 = p;\n    vec3 pos6 = p;\n    vec3 pos7 = p;\n\tvec3 pos8 = p;\n    \n    vec4 soleFront = vec4(0.9,0.9,0.9,sdSphereCustom(pos+vec3(0.9,0.0,0.0),0.5,vec3(0.35,1.3,0.5)));\n    vec4 soleBack = vec4(0.9,0.9,0.9,sdSphereCustom(pos+vec3(-0.8,0.0,0.0),0.5,vec3(0.45,1.4,0.5)));\n    vec4 heelpart = vec4(255.0/255.0, 145.0/255.0, 164.0/255.0,sdCappedCylinderCustom(pos+vec3(-0.7,-0.7,0.0),vec2(0.5,0.8),vec3(0.45,1.6,0.7)));\n    pos.xy *= rot(PI/-6.5);\n    \n    vec4 upper = vec4(255.0/255.0, 145.0/255.0, 164.0/255.0,sdSphereCustom(pos+vec3(0.45,-0.9,0.0),0.5,vec3(0.34,0.95,0.6)));\n    \n    float topPart = smoothMin(heelpart.w,upper.w,10.0);\n    vec4 combinedTopPart =  vec4(255.0/255.0, 195.0/255.0, 194.0/255.0,topPart);\n    \n    pos2.xy *= rot(PI/-30.0);\n    vec4 heelPartBox =vec4(0.8,0.8,0.8,sdSphereCustom(pos2+vec3(-0.8,-0.2,0.0),0.5,vec3(0.4,1.4,0.6)));\n    \n    // toebox\n    pos3.xy *= rot(PI/18.0);\n\tvec4 toebox = vec4(255.0/255.0, 195.0/255.0, 194.0/255.0,sdSphereCustom(pos3+vec3(1.6,0.1,0.0),0.5,vec3(0.7,2,0.7)));\n    \n    float wholeupper = smoothMin(combinedTopPart.w,toebox.w,9.0);\n    vec4 resUpper =  vec4(255.0/255.0, 195.0/255.0, 194.0/255.0,wholeupper);\n\tresUpper.rgb =  resUpper.rgb/partition_noise(p.xy*1.5-iTime*0.2);\n    resUpper.rgb *= vec3(255.0/255.0, 195.0/255.0, 194.0/255.0);\n    \n    // heel\n    pos4.xy *= rot(PI/-6.5);\n    vec4 heel = vec4(0.9,0.9,0.9,sdSphereCustom(pos4+vec3(-1.3,-0.3,0.0),0.5,vec3(0.45,1.4,0.6)));\n    float sheel = smoothMin(heelpart.w,heel.w,10.0);\n    vec4 resHeel = vec4(0.0, 0.0, 0.3,sheel);\n    resHeel.rgb =  resHeel.rgb/partition_noise2(p.xy-iTime*0.1);\n    \n    // race part\n    pos5.xy *= rot(PI/-1.7);\n    pos5.y = abs(pos5.y)-0.25;// symetory\n    vec4 race = vec4(1.0, 1.0, 1.0,sdTorusCustom(pos5+vec3(-0.9,0.0,0.0),vec2(0.62,0.03),vec3(1.0,0.4,0.9)));\n    race.rgb *= vec3(2.0);\t\t\t\n  \n    pos6.xy *= rot(PI/-1.7);\n    pos6.yz *= rot(PI/-2.0);\n    vec4 heelloop= vec4(255.0/255.0, 195.0/255.0, 194.0/255.0,sdTorusCustom(pos6+vec3(-0.8,0.0,-2.3),vec2(0.32,0.03),vec3(1.7,0.5,1.5)));\n    heelloop.rgb *= vec3(2.0);\n    \n    // race 2\n    pos7.xy *= rot(PI/-1.7);\n    vec4 race2 = vec4(1.0, 1.0, 1.0,sdTorusCustom(pos7+vec3(-0.8,-0.7,0.0),vec2(0.62,0.03),vec3(1.0,0.4,0.9)));\n    race2.rgb *= vec3(2.0);\t\n    \n    // heel counter\n     pos8.xy *= rot(PI/-16.0);\n    vec4 heelCounter =vec4(0.3,0.3,0.3,sdSphereCustom(pos8+vec3(-0.9,-0.5,0.0),0.5,vec3(0.4,0.92,0.65)));\n    \n    vec4 f = vec4(vec3(.3,.3,.3),sdFloor(p+vec3(0.0,6.0,0.0)));\n    vec4 res = combine(soleFront, soleBack);\n    vec4 res2 = combine(combinedTopPart,heelPartBox);\n    vec4 res3 = combine(resUpper, resHeel);\n    vec4 res4 = combine(race, heelloop);\n    vec4 res5 = combine(race2, heelCounter);\n    vec4 res6 = combine(f, res);\n    vec4 res7 = combine(res2, res3);\n    vec4 res8 = combine(res4, res5);\n    vec4 res9 = combine(res6, res7);\n    vec4 res10 = combine(res8, res9);\n    return res10;\n}\n\nvec3 raymarch (vec2 uv) {\n    vec3 eye = camera(vec3(0,1.5,-4.0));\n    vec3 ray = lookAt(eye, vec3(0), uv);\n    float shade = 0., dist = 0.;\n    vec3 pos = eye;\n    \n    vec4 shape;\n    for (float i = 0.; i <= 1.; i += 1.0 / STEPS) {\n        shape = map(pos,uv);\n        if (shape.w < VOLUME || dist > FAR) { break; }\n        dist += shape.w;\n        pos = eye + ray * dist;\n    }\n    \n    vec3 color = shape.xyz;\n    \n    if ( dist> 10.0 ){\n        float temp = length(uv)+0.1;\n        return vec3(.2,.2,.2)/vec3(temp);\n    } else {\n        vec3 lightPos = vec3(10.0, 1.0, 1.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( 250.0, 30.0, 0.0 );\n        vec3 n = vec3(shape.w - map( pos - eps.xyy,uv ).w,\n                      shape.w - map( pos - eps.yxy,uv ).w,\n                      shape.w - map( pos - eps.yyx,uv ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        color = vec3(dist)*color* vec3(lambert);\n    }\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tfloat block_thresh = pow(fract(iTime * 16.0453), 1.0) * 3.1;\n\tfloat line_thresh = pow(fract(iTime * 1236.0453), 1.0) *0.2;\n    \n    float block_thresh2 = pow(fract(iTime * 126.0453), 1.0) *3.1;\n\tfloat line_thresh2 = pow(fract(iTime * 1236.0453), 1.0) * 0.1;\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // scan effect\n    float uvy = sin((iTime+10.0)*0.6)*1.2;\n\tif (uv.y+uvy > 0.5 && uv.y+uvy < 0.7) {\n        uv.x += sin(uv.y*10.0)*0.1;\n    }\n\n    vec4 c = vec4(raymarch(uv),1.0); // raymerching result\n\n    fragColor = c;\n\n    // glitch effect\n    float ypos = sin(fract(iTime * 6.0453))-0.5;\n\tif (uv.y+ypos > block_thresh && uv.y+ypos < line_thresh && uv.x+ypos*1.5 > block_thresh) {\n\t\tfloat line = fract(fragCoord.y / 3.0);\n\t\tvec3 mask = vec3(3.0, 0.0, 0.0);\n\t\tif (line > 0.133)\n\t\t\tmask = vec3(0.0, 3.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 3.0);\n\t\t\n\t\tfragColor.xyz += mask;\n\t}\n    \n    float ypos2 = sin(fract(iTime * 3.0453))-0.5;\n\tif (uv.y+ypos2 > block_thresh && uv.y+ypos2 < line_thresh2) {\n\t\tfloat line = fract(fragCoord.y / 3.0);\n\t\tvec3 mask = vec3(3.0, 0.0, 0.0);\n\t\tif (line > 0.233)\n\t\t\tmask = vec3(0.0, 3.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 3.0);\n\t\t\n\t\tfragColor.xyz += mask;\n\t}\n    \n        float ypos3 = sin(fract(iTime * 6.0453))-0.5;\n\tif (uv.y+ypos3 > block_thresh && uv.y+ypos3*1.5 < block_thresh && uv.x+ypos3*1.5 < block_thresh) {\n\t\tfloat line = fract(fragCoord.y / 3.0);\n\t\tvec3 mask = vec3(3.0, 0.0, 0.0);\n\t\tif (line > 0.333)\n\t\t\tmask = vec3(0.0, 3.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 3.0);\n\t\t\n\t\tfragColor.xyz += mask;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBfDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 195, 214, 214, 346], [348, 391, 422, 422, 676], [678, 678, 711, 711, 888], [890, 890, 910, 910, 960], [962, 962, 1008, 1008, 1207], [1209, 1209, 1254, 1254, 1323], [1325, 1325, 1347, 1347, 1613], [1615, 1615, 1666, 1666, 1750], [1752, 1752, 1811, 1811, 1967], [1969, 1969, 2018, 2018, 2140], [2142, 2142, 2165, 2165, 2207], [2209, 2209, 2245, 2245, 2304], [2306, 2306, 2332, 2332, 5358], [5360, 5360, 5385, 5385, 6381], [6383, 6383, 6440, 6440, 8066]], "test": "untested"}
{"id": "XljBDW", "name": "rayspheres", "author": "inantop", "description": "spheres", "tags": ["ray"], "likes": 0, "viewed": 69, "published": "Public", "date": "1515808189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_SPHERE = 10;\nint NUM_SPHERE;\n\n\n/* Define World */\nstruct Spheres\n{\n    vec3 position[MAX_SPHERE];\n    float radius[MAX_SPHERE];\n    vec3 color[MAX_SPHERE];\n    float shininess[MAX_SPHERE];\n} spheres;\n    \nvoid InitSpheres()\n{\n    int i = -1;\n    \n    i++;//0\n\tspheres.position[i] = vec3(0.0);\n    spheres.radius[i] = 1.0;\n    spheres.color[i] = vec3(1.0, 1.0, 0.0);\n    spheres.shininess[i] = 64.0;\n    \n    i++;//1\n\tspheres.position[i] = vec3(0.0, 3.0, 0.0);\n    spheres.radius[i] = 0.8;\n    spheres.color[i] = vec3(1.0, 0.2, 1.0);\n    spheres.shininess[i] = 128.0;\n    \n    i++;//2\n\tspheres.position[i] = vec3(0.0, 4.5, 2.0);\n    spheres.radius[i] = 0.3;\n    spheres.color[i] = vec3(1.0, 0.0, 0.0);\n    spheres.shininess[i] = 32.0;\n    \n    i++;//3\n\tspheres.position[i] = vec3(3.0, 0.0, 0.0);\n    spheres.radius[i] = 0.9;\n    spheres.color[i] = vec3(0.0, 1.0, 0.0);\n    spheres.shininess[i] = 48.0;\n    \n    i++;//4\n\tspheres.position[i] = vec3(3.0, 0.0, 0.0);\n    spheres.radius[i] = 0.6;\n    spheres.color[i] = vec3(1.0, 0.0, 1.0);\n    spheres.shininess[i] = 16.0;\n    \n    NUM_SPHERE = ++i;\n}\n\nvoid AnimateScene(float iTime)\n{\n\tspheres.position[1] = vec3(sin(iTime), 0.0, cos(iTime)) * 3.0;\n    spheres.position[2] = vec3(sin(iTime), cos(iTime), 0.0) * 2.0;\n    spheres.position[3] = vec3(2.0, sin(iTime), sin(iTime) * cos(iTime)) * (2.0 + cos(iTime));\n    spheres.position[4] = vec3(sin(iTime), 0.0, cos(iTime)) * 2.0 + spheres.position[3];\n}\n\n/* Matrix Utilities */\n\nmat4 perspective(float fovy, float aspect, float near, float far)\n{\n\tmat4 result;\n    float rad = fovy * 3.14159265 / 180.0;\n    float tanHalfFovy = tan(rad / 2.0);\n    result[0][0] = 1.0 / (aspect * tanHalfFovy);\n    result[1][1] = 1.0 / tanHalfFovy;\n    result[2][2] = - (far + near) / (far - near);\n    result[2][3] = - 1.0;\n    result[3][2] = - (2.0 * far * near) / (far - near);\n    return result;\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n    mat4 Result = mat4(1.0);\n    \n    vec3  f = normalize(center - eye);\n    vec3  u = normalize(up);\n    vec3  s = normalize(cross(f, u));\n    \n    u = cross(s, f);\n    Result[0][0] = s.x;\n    Result[1][0] = s.y;\n    Result[2][0] = s.z;\n    Result[0][1] = u.x;\n    Result[1][1] = u.y;\n    Result[2][1] = u.z;\n    Result[0][2] =-f.x;\n    Result[1][2] =-f.y;\n    Result[2][2] =-f.z;\n    Result[3][0] =-dot(s, eye);\n    Result[3][1] =-dot(u, eye);\n    Result[3][2] = dot(f, eye);\n    return Result;   \n}\n\n\n\nvec3 unproject(vec3 win, mat4 mvp, vec4 vp)\n{\n    mat4 inv = inverse(mvp);\n\n    vec4 tmp = vec4(win, 1.0);\n    tmp.x = (tmp.x - vp.x) / vp.z;\n    tmp.y = (tmp.y - vp.y) / vp.w;\n    tmp.x = tmp.x * 2.0 - 1.0;\n    tmp.y = tmp.y * 2.0 - 1.0;\n\n    vec4 obj = inv * tmp;\n    obj /= obj.w;\n\n    return vec3(obj);\n}\n\n/* Rays */\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nbool RaySphereCollision(in Ray ray, int sphereIndex, out vec3 collision)\n{\n    vec3 p = ray.origin;\n    vec3 d = ray.direction;\n    \n    vec3 s = spheres.position[sphereIndex];\n    float r = spheres.radius[sphereIndex];\n    vec3 v = s - p;\n    \n    if(dot(v,d) > 0.0)\n    {\n        //Sphere is in front of ray\n        //Compute distance from sphere center to ray\n        vec3 c = cross(s - p, d);\n        float dist = length(c);\n        \n        if (dist < r)\n        {\n            //The distance from the center to the point on the ray is \"dist\"\n            //The distance from the point on the ray to the surface of the sphere is \"x\"\n            //The distance from the center to the surface of the sphere is \"r\"\n            //These form a right triangle\n            float x = sqrt(r * r - dist * dist);\n            \n            //The collision is a point on the ray \"x\" distance back toward the origin.            \n            vec3 pointOnRayClosestToSphereCenter = p + dot(v,d) * d;\n            collision = pointOnRayClosestToSphereCenter - (d * x);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    else\n    {\n        //Sphere is behind ray\n        return false;\n    }    \n}\n\nRay ScreenToWorldRay(in Ray screenRay, mat4 mvp, vec4 vp)\n{\n\tRay ret;\n    ret.origin = unproject(screenRay.origin, mvp, vp);\n    ret.direction = normalize(unproject(screenRay.origin + screenRay.direction, mvp, vp) - ret.origin);\n    \n    return ret;\n}\n\n/* Lighting */\nvec3 DoPhong(vec3 color, float shininess, vec3 lightColor, vec3 eyeToPoint, vec3 lightToPoint, vec3 normal)\n{\n    vec3 l = normalize(lightToPoint);\n    vec3 e = normalize(eyeToPoint);\n    vec3 r = normalize(-reflect(lightToPoint, normal));\n    vec3 n = normalize(normal);\n    \n    float att = 10.0 / length(lightToPoint);\n                       \n    vec3 combinedColor = color * lightColor;\n\tvec3 ambient = combinedColor * 0.2;\n    vec3 diffuse = combinedColor * max(dot(n, l), 0.0) * att;\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    \n    vec3 specular = combinedColor * pow(max(dot(r, e), 0.0), 0.3 * shininess) * att * att;\n    specular = clamp(specular, 0.0, 1.0);\n    \n    return ambient + diffuse + specular;\n}\n\n/* Main */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitSpheres();\n    AnimateScene(iTime);\n    \n\tRay pixelRay;\n    pixelRay.origin = vec3(fragCoord, 0.0);\n    pixelRay.direction = vec3(0.0, 0.0, 1.0);\n    \n    vec3 worldEye = vec3(0.0, 0.0, -10.0);\n    \n    worldEye.z += iMouse.y / iResolution.y * 5.0;\n    \n    vec3 worldTarget = vec3(0.0, 0.0, 0.0);\n    \n    vec3 worldLight = vec3(0.0, 2.0, -2.0);\n    vec3 lightColor = vec3(1.0);\n    \n    vec4 viewport = vec4(0.0, 0.0, iResolution.x, iResolution.y);\n    mat4 mvp = perspective(45.0f, iResolution.x / iResolution.y, 0.1, 1000.0) * lookAt(worldEye, worldTarget, vec3(0.0, 1.0, 0.0));\n    \n    Ray worldRay = ScreenToWorldRay(pixelRay, mvp, viewport);\n    \n    float minDepth = 100000000.0;\n\tvec3 collision;\n    for (int i = 0; i < NUM_SPHERE; i++)\n    {\n    \tif (RaySphereCollision(worldRay, i, collision))\n        {\n            if (collision.z < minDepth)\n            {\n                minDepth = collision.z;\n            \tvec3 normal = normalize(collision - spheres.position[i]);\n            \tfragColor = vec4(DoPhong(spheres.color[i], spheres.shininess[i], lightColor, worldEye - collision, worldLight - collision, normal), 1.0);\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljBDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 219, 239, 239, 1110], [1112, 1112, 1144, 1144, 1461], [1463, 1487, 1554, 1554, 1891], [1893, 1893, 1938, 1938, 2440], [2444, 2444, 2489, 2489, 2752], [2754, 2819, 2893, 2893, 4052], [4054, 4054, 4113, 4113, 4305], [4307, 4322, 4431, 4431, 5037], [5039, 5050, 5107, 5107, 6279]], "test": "untested"}
{"id": "XljBRK", "name": "GeneralizedTonemapper", "author": "TimothyLottes", "description": "Generalized Tonemapper", "tags": ["tonemapper"], "likes": 15, "viewed": 1347, "published": "Public", "date": "1516496081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tonemapper settings\n#define CONTRAST 1.4\n#define SHOULDER 1.0\n#define HDR_MAX 64.0\n#define MID_IN 0.18\n#define MID_OUT 0.18\n#define SATURATION vec3(0.0,0.0,0.0)\n#define CROSSTALK vec3(64.0,32.0,128.0)\n#define CROSSTALK_SATURATION vec3(4.0,1.0,16.0)\n//--------------------------------------------------------------\n#define GT_GPU 1\n#define GT_GLSL 1\n#define GT_SHOULDER 1\n\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//\n//           [GT] GENERALIZED TONEMAPPER - 20180122\n//\n//                      by Timothy Lottes\n//\n//\n//--------------------------------------------------------------\n// Showing full flexibility of over-exposure color shaping\n// Via 3 channel 'crosstalk' and 'crosstalk saturation' terms\n//--------------------------------------------------------------\n// Based on AMD GDC Presentation:\n//  Advanced Techniques and Optimization of HDR Color Pipelines\n//  https://gpuopen.com/gdc16-wrapup-presentations/\n//--------------------------------------------------------------\n// Using math fixup from Bart Wronski (see comments),\n//  https://bartwronski.com/2016/09/01/dynamic-range-and-evs/\n//--------------------------------------------------------------\n// DEFINES\n// =======\n// GT_CPU - Define to get CPU code (not implemented)\n// GT_GPU - Define to get GPU code\n// GT_SHOULDER - Define if shoulder is not set to 1.0\n// GT_GLSL - Define for OpenGL/Vulkan\n// GT_HLSL - Define for DX (not tested)\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                          CPU CODE\n//\n//==============================================================\n#ifdef GT_CPU\n // TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n#endif\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                          GPU CODE\n//\n//==============================================================\n#ifdef GT_GPU\n//_____________________________/\\_______________________________\n//==============================================================\n//                         PORTABILITY\n//==============================================================\n #ifdef GT_GLSL\n  #define GtF1 float\n  #define GtF2 vec2\n  #define GtF3 vec3\n  #define GtF4 vec4\n  #define GtFractF1 fract\n  #define GtLerpF3(x,y,a) mix(x,y,a)\n  #define GtRcpF1(x) (1.0/(x))\n  #define GtSatF1(x) clamp((x),0.0,1.0)\n//--------------------------------------------------------------\n  GtF1 GtMax3F1(GtF1 a,GtF1 b,GtF1 c){return max(a,max(b,c));}\n #endif\n//==============================================================\n #ifdef GT_HLSL\n  #define GtF1 float\n  #define GtF2 float2\n  #define GtF3 float3\n  #define GtF4 float4\n  #define GtFractF1 frac\n  #define GtLerpF3(x,y,a) lerp(x,y,a)\n  #define GtRcpF1(x) (1.0/(x))\n  #define GtSatF1(x) saturate(x)\n//--------------------------------------------------------------\n  GtF1 GtMax3F1(GtF1 a,GtF1 b,GtF1 c){return max(a,max(b,c));}\n #endif\n//_____________________________/\\_______________________________\n//==============================================================\n//                     CONSTANT GENERATION\n//--------------------------------------------------------------\n// GPU version of math to generate constants for tonemapper\n// Better to generate constants into a constant buffer first\n//==============================================================\n void GtConstants(\n  out GtF4 tone0,\n  out GtF4 tone1,\n  out GtF4 tone2,\n  out GtF4 tone3,\n  GtF1 contrast,\n  GtF1 shoulder,\n  GtF1 hdrMax,\n  GtF1 midIn,\n  GtF1 midOut,\n  GtF3 saturation,\n  GtF3 crosstalk,\n  GtF3 crosstalkSaturation\n ){\n  tone0.x=contrast;\n  tone0.y=shoulder;\n  GtF1 cs=contrast*shoulder;\n//--------------------------------------------------------------\n  // TODO: Better factor and clean this up!!!!!!!!!!!!!!!!!!!!!!\n  GtF1 z0=-pow(midIn,contrast);\n  GtF1 z1=pow(hdrMax,cs)*pow(midIn,contrast);\n  GtF1 z2=pow(hdrMax,contrast)*pow(midIn,cs)*midOut;\n  GtF1 z3=pow(hdrMax,cs)*midOut;\n  GtF1 z4=pow(midIn,cs)*midOut;\n  tone0.z=-((z0+(midOut*(z1-z2))/(z3-z4))/z4);\n//--------------------------------------------------------------\n  GtF1 w0=pow(hdrMax,cs)*pow(midIn,contrast);\n  GtF1 w1=pow(hdrMax,contrast)*pow(midIn,cs)*midOut;\n  GtF1 w2=pow(hdrMax,cs)*midOut;\n  GtF1 w3=pow(midIn,cs)*midOut;\n  tone0.w=(w0-w1)/(w2-w3);\n//--------------------------------------------------------------\n  // Saturation base is contrast\n  saturation+=contrast;\n  tone1.xyz=saturation/crosstalkSaturation;\n  tone2.xyz=crosstalk;\n  tone3.xyz=crosstalkSaturation;}\n//_____________________________/\\_______________________________\n//==============================================================\n//                      APPLY TONEMAPPER\n//--------------------------------------------------------------\n// Note 'pow(x,y)' is implimented as 'exp2(log2(x)*y)'\n//==============================================================\n GtF3 GtFilter(\n  // Linear input color\n  GtF3 color,\n  // Tonemapper constants\n  GtF4 tone0,\n  GtF4 tone1,\n  GtF4 tone2,\n  GtF4 tone3\n ){\n//--------------------------------------------------------------\n  // Peak of all channels\n  GtF1 peak=GtMax3F1(color.r,color.g,color.b);\n  // Protect against /0\n  peak=max(peak,1.0/(256.0*65536.0));\n  // Color ratio\n  GtF3 ratio=color*GtRcpF1(peak);\n//--------------------------------------------------------------\n  // Apply tonemapper to peak\n  // Contrast adjustment\n  peak=pow(peak,tone0.x);\n//--------------------------------------------------------------\n  // Highlight compression\n  #ifdef GT_SHOULDER\n   peak=peak/(pow(peak,tone0.y)*tone0.z+tone0.w);\n  #else\n   // No shoulder adjustment avoids extra pow\n   peak=peak/(peak*tone0.z+tone0.w);\n  #endif\n//--------------------------------------------------------------\n  // Convert to non-linear space and saturate\n  // Saturation is folded into first transform\n  ratio=pow(ratio,tone1.xyz);\n  // Move towards white on overexposure\n  vec3 white=vec3(1.0,1.0,1.0);     \n  ratio=GtLerpF3(ratio,white,pow(GtF3(peak),tone2.xyz));\n  // Convert back to linear\n  ratio=pow(ratio,tone3.xyz);\n//--------------------------------------------------------------\n   return ratio*peak;}\n//==============================================================\n#endif\n\n\n\n\n\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                 SIMPLE MESSY-CODE TEST SCENE\n//\n//==============================================================\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n//--------------------------------------------------------------\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\nF1 Noise(F2 n,F1 x){n+=fract(iTime)*x;return fract(sin(dot(n.xy,F2(12.9898, 78.233)))*43758.5453);}\nF1 Dither(F2 n){return (Noise(n,0.07)+Noise(n,0.11)+Noise(n,0.13))/3.0;}\n//--------------------------------------------------------------\nF3 Hue(F1 n){return clamp(F3(\n abs(fract(n)-0.5)*(-6.0)+2.0,\n abs(fract(n+(1.0/3.0))-0.5)*(-6.0)+2.0,\n abs(fract(n-(1.0/3.0))-0.5)*(-6.0)+2.0),F3(0.0),F3(1.0));}\n//==============================================================\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n F2 uv=fragCoord.xy/iResolution.xy;\n uv.y=1.0-uv.y;\n F3 color=Linear3(texture(iChannel0,uv*3.0).rgb);\n color*=(1.0/8.0);\n//--------------------------------------------------------------\n #if 1\n  // Add colored gradients\n  F3 bars=Hue(uv.y/(5.0/8.0))*2.0;   \n  color+=bars*bars*(uv.x*uv.x*uv.x*uv.x*uv.x);\n #endif\n//--------------------------------------------------------------\n #if 1      \n  // Draw swatches\n  if(uv.y>7.0/8.0){\n   color.b=fract(uv.x*8.0);\n   color.r=1.0-fract(uv.y*8.0);\n   color.g=floor(uv.x*8.0)/8.0;\n   color.rgb=Linear3(color);}\n  else if(uv.y>6.0/8.0){\n   color.r=fract(uv.x*8.0);\n   color.g=1.0-fract(uv.y*8.0);\n   color.b=floor(uv.x*8.0)/8.0;\n   color.rgb=Linear3(color);}\n  else if(uv.y>5.0/8.0){\n   color.g=fract(uv.x*8.0);\n   color.b=1.0-fract(uv.y*8.0);\n   color.r=floor(uv.x*8.0)/8.0;\n   color.rgb=Linear3(color);}\n #endif   \n//--------------------------------------------------------------\n color*=16.0;\n//--------------------------------------------------------------\n #if 1\n  // Fade in/out\n  color.rgb*=pow(abs(sin(fract(iTime/16.0)*3.14159*2.0)),2.2);    \n #endif\n//--------------------------------------------------------------\n // Apply generalized tonemapper\n // In practice GtConstants() would be run on CPU,\n //  or if run on GPU, \n //  run on one wave and store into constant buffer in prepass\n GtF4 tone0;\n GtF4 tone1;\n GtF4 tone2;\n GtF4 tone3;\n GtConstants(\n  // Outputs\n  tone0,tone1,tone2,tone3,\n  // Inputs\n  CONTRAST,SHOULDER,HDR_MAX,MID_IN,MID_OUT,\n  SATURATION,CROSSTALK,CROSSTALK_SATURATION);\n color=GtFilter(color,tone0,tone1,tone2,tone3);\n//--------------------------------------------------------------\n // Convert back into sRGB.\n color=Srgb3(color);\n color+=(Dither(uv)-0.5)*(16.0/256.0);    \n fragColor=F4(color,1.0);}\n    \n    \n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljBRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[7162, 7227, 7244, 7244, 7297], [7298, 7298, 7315, 7315, 7366], [7367, 7367, 7382, 7382, 7438], [7439, 7439, 7454, 7454, 7499], [7500, 7500, 7520, 7520, 7599], [7600, 7600, 7616, 7616, 7672], [7673, 7738, 7751, 7751, 7899], [7900, 7965, 8018, 8018, 9794]], "test": "untested"}
{"id": "XljBW3", "name": "The cat is a glitch (Matrix)", "author": "antoineMoPa", "description": "I was just experimenting to create clouds with some help from Voronoi. During this process, while tweaking my vorocloud function, I realized I could create this nice Matrix-terminal-like effect.", "tags": ["2d", "voronoi", "matrix"], "likes": 18, "viewed": 6042, "published": "Public API", "date": "1517372842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nuniform float ratio;\n\n#define PI2 6.28318530718\n#define PI 3.1416\n\nfloat vorocloud(vec2 p){\n\tfloat f = 0.0;\n    vec2 pp = cos(vec2(p.x * 14.0, (16.0 * p.y + cos(floor(p.x * 30.0)) + time * PI2)) );\n    p = cos(p * 12.1 + pp * 10.0 + 0.5 * cos(pp.x * 10.0));\n    \n    vec2 pts[4];\n    \n    pts[0] = vec2(0.5, 0.6);\n    pts[1] = vec2(-0.4, 0.4);\n    pts[2] = vec2(0.2, -0.7);\n    pts[3] = vec2(-0.3, -0.4);\n    \n    float d = 5.0;\n    \n    for(int i = 0; i < 4; i++){\n      \tpts[i].x += 0.03 * cos(float(i)) + p.x;\n      \tpts[i].y += 0.03 * sin(float(i)) + p.y;\n    \td = min(d, distance(pts[i], pp));\n    }\n    \n    f = 2.0 * pow(1.0 - 0.3 * d, 13.0);\n    \n    f = min(f, 1.0);\n    \n\treturn f;\n}\n\nvec4 scene(vec2 UV){\n    float x = UV.x;\n    float y = UV.y;\n    \n    vec2 p = vec2(x, y) - vec2(0.5);\n    \n    vec4 col = vec4(0.0);\n\tcol.g += 0.02;\n    \n    float v = vorocloud(p);\n    v = 0.2 * floor(v * 5.0);\n    \n    col.r += 0.1 * v;\n    col.g += 0.6 * v;\n    col.b += 0.5 * pow(v, 5.0);\n    \n    \n    v = vorocloud(p * 2.0);\n    v = 0.2 * floor(v * 5.0);\n    \n    col.r += 0.1 * v;\n    col.g += 0.2 * v;\n    col.b += 0.01 * pow(v, 5.0);\n    \n    col.a = 1.0;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = scene(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljBW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 111, 111, 713], [715, 715, 735, 735, 1203], [1206, 1206, 1263, 1263, 1331]], "test": "untested"}
{"id": "XljfDR", "name": "Soup", "author": "tsuhre", "description": "A moving noise function using Inigio Quilez's voronoi noise modified by time. Works by walking the sin function", "tags": ["voronoi", "noise"], "likes": 2, "viewed": 129, "published": "Public", "date": "1515362169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//adapted from https://thebookofshaders.com/edit.php#12/2d-voronoise.frag\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// http://iquilezles.org/www/articles/voronoise/voronoise.htm\nvec3 hash3( vec2 p ) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)),\n                   dot(p,vec2(269.5,183.3)),\n                   dot(p,vec2(419.2,371.9)) );\n    return abs(mod(sin(q)*43758.5453*iTime/500000., 2.) - 1.);\n}\n\nfloat iqnoise( in vec2 x, float u, float v ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0+63.0*pow(1.0-v,4.0);\n\n    float va = 0.0;\n    float wt = 0.0;\n    for (int j=-2; j<=2; j++) {\n        for (int i=-2; i<=2; i++) {\n            vec2 g = vec2(float(i),float(j));\n            vec3 o = hash3(p + g)*vec3(u,u,1.0);\n            vec2 r = g - f + o.xy;\n            float d = dot(r,r);\n            float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n            va += o.z*ww;\n            wt += ww;\n        }\n    }\n\n    return va/wt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    st *= 10.;\n    st.y *= 1.;\n    float n = iqnoise(st, 1., 1.);\n    n = abs(mod(n, .1) - .05)*20.;\n    \n    fragColor = vec4(vec3(n),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljfDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[75, 261, 283, 283, 485], [487, 487, 533, 533, 1043], [1045, 1045, 1102, 1102, 1358]], "test": "untested"}
{"id": "XljfRc", "name": "conversion of GLSL - fluid", "author": "catafest", "description": "The website example with code: http://glslsandbox.com/e#44875.0", "tags": ["fluid", "shader"], "likes": 18, "viewed": 1277, "published": "Public API", "date": "1516732104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Ctlin George Fetil - http://free-tutorials.org\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// convert example from http://glslsandbox.com/e#44875.0\n\n#define f length(fract(q*=m*=.6+.1*d++)-.5)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = 0.;\n    //vec3 uv = vec3(fragCoord.xy / iResolution.xy,iTime*.2);\n    vec3 q = vec3(fragCoord.xy/iResolution.yy-13., iTime*.2);\n    mat3 m = mat3(-2,-1,2, 3,-2,1, -1,1,3);\n    vec3 col = vec3(pow(min(min(f,f),f), 7.)*40.);\n    fragColor = vec4(clamp(col + vec3(0., 0.35, 0.5), 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljfRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 259, 316, 316, 626]], "test": "untested"}
{"id": "XljfW1", "name": "", "author": "tenonno", "description": "test", "tags": ["test"], "likes": 1, "viewed": 101, "published": "Public", "date": "1515600154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n// \nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(hash(i + vec2(0.0, 0.0)),\n            hash(i + vec2(1.0, 0.0)), u.x),\n        mix(hash(i + vec2(0.0, 1.0)),\n            hash(i + vec2(1.0, 1.0)), u.x), u.y\n    );\n}\n\nfloat _noise(in vec2 uv) {\n    float f = 0.0;\n\tuv *= 8.0;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\tf = 0.5000*noise( uv );\n    uv = m * uv;\n\tf += 0.2500 * noise(uv);\n    uv = m * uv;\n\tf += 0.1250 * noise(uv);\n    uv = m * uv;\n\tf += 0.0625 * noise(uv);\n    uv = m * uv;\n\tf = 0.5 + 0.5 * f;\t\n    return f;\n}\n\n\n// -----------------------------------------------\n\n\n\n// fragColor: \n// fragCoord:  UV \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //  0, 0  1, 1 \n    vec2 p = fragCoord / iResolution.xy * vec2(iResolution.x / iResolution.y, 1.0);\n\n    //  ( R, G, B )\n    vec3 color = vec3(1, 0, 1);\n        \n    \n    // \n    p += vec2(iTime * 100.0);\n\t\n    \n    // \n    p.x *= 0.03;\n    \n    // \n    float f = _noise(p * 3.0);\n    \n    // f  0.0  1.0 \n    \n    // \n    f -= 0.65;\n    // \n    f *= 13.0;\n    \n    //  0.0  1.0 \n    f = clamp(f, 0.0, 1.0);\n    \n    \n    // \n    vec3 movie = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n\n\t// \n\tfragColor.xyz = mix(movie.xyz, color, vec3(f));\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljfW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 72, 72, 176], [178, 206, 230, 230, 504], [506, 506, 532, 532, 811], [868, 932, 987, 1048, 1974]], "test": "untested"}
{"id": "XljfWG", "name": "Raymarched Clouds Experiment", "author": "lukasxl", "description": "Little raymarched clouds experiment with camera controls.", "tags": ["raymarch", "clouds"], "likes": 5, "viewed": 552, "published": "Public API", "date": "1517009121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 512\n#define STEP_SIZE .05\n#define NUM_OCTAVES 5\n#define AREA_WIDTH 30.0\n#define AREA_HEIGHT 6.0\n\n// \t<www.shadertoy.com/view/XsX3zB>\n//\tby Nikita Miropolskiy\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nvec2 rot2D(vec2 p, float angle) \n{\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\n// https://www.shadertoy.com/view/4sSBDG\nconst float F3 = 0.3333333;\nconst float G3 = 0.1666667;\nfloat snoise(vec3 p) \n{\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}\n\nfloat fbm(vec3 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < NUM_OCTAVES; ++i) \n    {\n        v += a * snoise(x - 0.05 * vec3(iTime, 0, iTime));\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nbool cube(vec3 ro, vec3 rd, out float tn, out float tf) \n{\n    ro -= vec3(0.0, AREA_HEIGHT * .5, 0.0);         \n\tvec3 size = vec3(AREA_WIDTH, AREA_HEIGHT, AREA_WIDTH);\n    \n\tvec3 m = 1./rd,\n         k = abs(m)*size,\n         a = -m*ro-k*.5, \n         b = a+k;\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn < tf && tf > .0;\n}\n\nfloat getDensityAtPoint(vec3 pos)\n{\n    pos *= .2;\n\n    float alt = pos.y;\n\n    // Can't remember where this is from\n    float h = (1.0 - exp(-50.0 * alt)) * exp(-4.0 * alt);\n    float v = 4.0 * fbm(pos) * h;\n\n    if (v < 0.001)\n    {\n        v = 0.0;\n    }\n\n    return v;\n}\n\nfloat march(vec3 pos, int maxStep, float step, vec3 dir)\n{\n    float start, end;\n\tif(!cube(pos, dir, start, end))\n    {\n        return 0.0;\n    }\n        \n    float density = 0.0;\n\n    float depth = max(0.0, start);\n    \n    for (int i = 0; i < maxStep && depth < end; i++)\n    {\n        vec3 p = pos + depth * dir;\n\n        float d = 0.2 * getDensityAtPoint(p);\n\n        density += d;\n        if (density >= 1.0)\n        {\n            return density;\n        }\n\n        depth += step;  \n    }\n\n    return density;\n}\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst vec3 _LightDir = normalize(vec3(.2,0.4,.2));\nconst vec3 _LightColor = vec3(0.8,0.8,1.0);\nconst vec3 _WorldOrigin = vec3(0.0,-1.0,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ----- Camera: https://www.shadertoy.com/view/MdKGzG\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    vec2 m = .55 + 0.5 * ((iMouse.xy / iResolution.xy) * 2. - 1.);\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\n    dir.xz = rot2D(dir.xz, 180. * m.x);\n    // -----\n    \n    vec4 sky = 1.35 * vec4(.6,.7,.8, 1.0);\n    sky = sky - 0.5 * dir.y;\n    \n    vec4 finalColor = vec4(0.0);\n\t\n\tfloat start, end;\n\tif(cube(_WorldOrigin, dir, start, end))\n\t{    \n\t\tfloat depth = max(0.0, start);\n\t\t\n\t\tfor(int i = 0;i<STEPS && depth < end;i++)\n\t\t{\n\t\t\tvec3 p = _WorldOrigin + depth * dir;\n\t\t\t\n\t\t\tdepth += STEP_SIZE;\n\t\t\tdepth += random3(p).x * .01;\n\t\t\t\n\t\t\tfloat d = getDensityAtPoint(p);\n\t\t\t\n\t\t\tif (d > .2)\n\t\t\t{\n\t\t\t\tfloat totalDensity = d + march(p, 100, 0.01, dir);\n\t\t\t\ttotalDensity = saturate((totalDensity - 0.5) / 0.9);\n\n\t\t\t\tfloat shadow = march(p, 20, 0.1, _LightDir);\n\t\t\t\tfinalColor = vec4(3.0 * vec3(totalDensity) * _LightColor * max(.2, (1.0 - shadow)), 0.5 * totalDensity);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    \n\tfragColor = vec4(mix(finalColor.xyz, sky.xyz, 1.0 - finalColor.w), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 246, 268, 268, 441], [443, 443, 477, 477, 602], [604, 701, 724, 724, 1354], [1356, 1356, 1375, 1375, 1618], [1620, 1620, 1678, 1678, 1973], [1975, 1975, 2010, 2010, 2249], [2251, 2251, 2309, 2309, 2767], [2951, 2951, 3008, 3067, 4133]], "test": "untested"}
{"id": "XljfWW", "name": "moon phase", "author": "BadBadDog", "description": "moon shader", "tags": ["moon"], "likes": 1, "viewed": 181, "published": "Public", "date": "1515799657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 9.0;\n    \n//    float shape = smoothstep( 1.0, 0.9, (length(uv)/0.5) );\n//    vec3 sfc = vec3( sin(radians((uv.x/0.5)*90.0)), cos(radians((length(uv)/0.5)*90.0)), sin(radians((uv.y/0.5)*90.0)) );\n    \n//    vec3 sun = vec3( sin(iTime*0.3)*1.0, cos(iTime*0.3), 0.0 );\n    \n//    float moon = dot( (sun), (sfc) );\n//    moon = clamp( moon*10.0, 0.0, 1.0 );\n    \n    vec3 tex = 0.6 + texture( iChannel0, uv*0.08 ).xyz*0.1 + texture( iChannel0, uv*0.02 ).zxy*0.3;\n    \n\t//fragColor = vec4( normalize(sfc*0.5+vec3(0.5,0.5,0.5))*shape, 1.0);\n//\tfragColor = vec4( tex*moon*shape, 1.0);\n    \n    \n    float phase = 0.2+sin(iTime*0.1)*0.8;\n\n    vec3 sun = normalize(vec3( abs(1.0-phase)*sin(iTime*0.3), phase*2.0-1.0, abs(1.0-phase)*cos(iTime*0.3) ));\n    \n    \n    \n    float shape = smoothstep( 1.0, 0.9, (length(uv)/0.5) );\n    \n    float glare = (smoothstep( 10.0, 0.0, (length(uv)/0.5) ));\n    \n    float mh = cos(radians((length(uv)/0.5)*90.0));\n    vec3 sfc = normalize(vec3(uv.x,mh,uv.y));\n    \n    float sm = dot( normalize(sfc), normalize(sun) );\n    \n    glare = glare * (dot( normalize(sfc), (vec3(sun.x,0.0,sun.z)) ) + sun.y);\n    \n    sm = pow( sm, 0.5 );\n    \n    \n    float dither = texture( iChannel0, uv ).x * 0.02;\n\n    float stars = smoothstep( 0.8, 1.0, texture( iChannel0, uv/8.0 ).y ) * smoothstep( 0.8, 1.0, texture( iChannel0, uv/2.0 ).x );\n    \n\tfragColor = vec4( clamp(tex*shape*sm, 0.0, 1.0) + 0.05*glare*(1.0-shape) - dither + shape*0.015 + stars*1.0*(1.0-shape), 1.0 );\n    \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljfWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1654]], "test": "untested"}
{"id": "XlSBWG", "name": "23/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. I have been working with path tracing for few days now. I was getting more and more confused about everything but thanks to good conversations with fizzer and noby I'm back on the path! ;)", "tags": ["pathtracing", "dailyshader"], "likes": 4, "viewed": 153, "published": "Public", "date": "1516920096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 30\n#define FAR 40.0\n#define EPSILON 0.001\n#define PIXELR 0.5/iResolution.x\n#define PI 3.14159265359\n\n#define BOUNCES 3\n#define SAMPLES 3.0\n\n//Hash methods from https://www.shadertoy.com/view/4djSRW\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nvec2 hash23(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//from http://amietia.com/lambertnotangent.html\nvec3 lambertNoTangent(vec3 normal, vec2 uv){\n   float theta = 6.283185 * uv.x;\n   uv.y = 2.0 * uv.y - 1.0;\n   vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n   return normalize(normal + spherePoint);\n}\n\n//Distance functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Maximum/minumum elements of a vector\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.0) {\n\t\tp = p - (2.0*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec2 dist(vec3 p){\n    \n    vec3 pp = p-vec3(0.0, 0.0, 6.0);\n    \n    float ball = fSphere(p-vec3(0.0, -4.75, 0.0), 1.25);\n    float jalusta = fBox(p-vec3(0.0, -8.0, 0.0), vec3(1.5, 2.0, 1.5));\n    float patsas = fOpUnionRound(ball, jalusta, 0.5);\n    \n    pReflect(pp, vec3(0.0, 0.0, 1.0), 6.0);\n    float cube = fBox(pp, vec3(1.0, 10.0, 1.0));\n    \n    float box = -fBox(p, vec3(10.0, 10.0, 10.0));\n    \n    float scene = min(patsas, min(cube,box));\n\n    float id = 0.0;\n    if(ball < cube && ball < box && ball < jalusta){\n        id = 1.0;\n    }\n    else if(cube < ball && cube < box && cube < jalusta){\n        id = 2.0;\n    }\n    else if(jalusta < ball && jalusta < cube && jalusta < box){\n        id = 3.0;\n    }\n    \n    return vec2(scene, id);\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(EPSILON, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy).x-dist(p-eps.xyy).x,\n        dist(p+eps.yxy).x-dist(p-eps.yxy).x,\n        dist(p+eps.yyx).x-dist(p-eps.yyx).x\n    ));\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 1.0;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(dist(ro).x);\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*dist(p).x;\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*dist(p).x);\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n    \n    p = ro+rd*t;\n    float id = dist(p).y;\n    \n\treturn vec2(t, id);\n}\n\n//returns material of the object hit\n// emissive color is xyz, and reflectance w\nvec4 getMaterial(float obj, vec3 p){\n    vec3 base = vec3(0.0);\n    float reflectance = 0.0;\n    if(obj == 0.0){\n        if(p.y > 9.99||  p.y < -9.99){\n            \n            vec2 m = mod(p.xz, 4.0) - vec2(2.0, 2.0);\n    \t\tbase =  m.x*m.y > 0.0 ? vec3(0.0) : vec3(0.8, 0.8, 0.7);\n            reflectance = 0.1;\n        }\n        else{\n            base = vec3(0.0);\n        \treflectance = 0.1;\n        }\n    }\n    else if(obj == 1.0){\n        base = vec3(5.0);\n        reflectance = 2.0;\n    }\n    else if(obj == 2.0){\n        base = vec3(0.65, 0.7, 0.75);\n        reflectance = 0.1;\n    }\n    else if(obj == 3.0){\n        base = vec3(0.02, 0.02, 0.02);\n        reflectance = 0.1;\n    }\n    return vec4(base, reflectance);\n}\n\nvec3 render(vec3 o, vec3 d, vec2 uv){\n    \n    vec3 ro = o;\n    vec3 rd = d;\n    \n    vec3 pixel_color = vec3(0.0);\n    vec3 absorption_factor = vec3(1.0);\n    \n    for(int i = 0; i < BOUNCES; ++i){\n        vec2 t = march(ro, rd);\n        vec3 p = ro+rd*t.x;\n        \n        if(t.y < 0.0 || t.x > FAR){\n            break;\n        }\n        \n        //material.xyz == emissive\n        //material.w == reflectance\n        vec4 material = getMaterial(t.y, p);\n        pixel_color += material.xyz * absorption_factor;\n        absorption_factor *= material.w;\n        \n        vec3 n = normals(p);\n        ro = p+(n*0.02);\n        if(p.x > 9.99 || p.x < -9.99){\n            rd = reflect(rd,n);\n        }\n        else if(t.y == 3.0){\n            rd = reflect(rd,n);\n            //Thanks to fizzer to introducing this skew thing! :)\n            rd = normalize(rd + (hash33(vec3(uv, float(i))) - 0.5)*0.1); \n        }\n        else{\n        \trd = lambertNoTangent(n, hash23(vec3(uv, float(i)+iTime*0.01)));\n        }\n        \n    }\n    \n    return pixel_color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(9.5*cos(iTime*0.2), -1.0+sin(iTime*0.1), 9.5*sin(iTime*0.2));\n    vec3 rt = vec3(0.0, -3.5+cos(iTime*0.2), 0.0);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    \n    vec3 color = vec3(0.0);\n    \n    for(float i = 0.0; i < SAMPLES; ++i){\n    \tvec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    \tcolor += render(ro, rd, uv);\n    }\n    color /= SAMPLES;\n    \n    color = pow(color, 1.0/vec3(2.2));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 311, 332, 332, 436], [437, 437, 458, 458, 568], [570, 618, 662, 662, 859], [940, 980, 1001, 1001, 1036], [1038, 1038, 1070, 1070, 1095], [1097, 1133, 1161, 1161, 1243], [1245, 1245, 1307, 1307, 1415], [1417, 1417, 1465, 1465, 1550], [1552, 1552, 1570, 1570, 2306], [2308, 2308, 2329, 2329, 2540], [2601, 2640, 2660, 2660, 2690], [2692, 2692, 2721, 2721, 3958], [3960, 4041, 4077, 4077, 4766], [4768, 4768, 4805, 4805, 5822], [5825, 5825, 5881, 5881, 6537]], "test": "untested"}
{"id": "XlSBWK", "name": "ray marching and reflection", "author": "youko", "description": "just a sketch", "tags": ["ray"], "likes": 0, "viewed": 395, "published": "Public", "date": "1517116635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//created by Ye Liu 2018/01/28\n\nconst float EPSILON = 0.0001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst int MAX_STEP = 32; \n\n//geometry property\nvec3 sphere_p = vec3(3,0.0,0.0);\nfloat sphere_r = 1.0;\n\nvec3 box_p = vec3(-2,0.0,0.0);\nvec3 box_s = vec3(1.0,1.0,1.0);\n\n//vec3 mirror_p = vec3(0,0,-2);\nvec4 mirror_n = vec4(0.0,0.0,1.0,0.0);\n\n//camera \nvec3 eye = vec3(0.0, -1.0, 4.0);\nvec3 up = vec3(0,1,0);\n/*vec3 right = vec3(1,0,0);*/\nvec3 eyeLookAt = vec3(0.0, 0.0, 0.0);\n\n//sdf\nfloat sdSphere(vec3 p, float radius) {\n\n    return length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 size ){  \n    vec3 d = abs(p) - size;  \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n ){  \n    return dot(p,n.xyz) + n.w;\n}\n\nfloat distanceField(vec3 p) {\n    float d1 = sdSphere(p+sphere_p, sphere_r);    \n    float d2 = sdBox(p+box_p,box_s);\n    float d3 = sdPlane(p,mirror_n);\n    return min(d3,min(d1, d2));\n}\n\nvec2 distanceField2(vec3 p) {\n    float i=0.0;\n    float d1 = sdSphere(p+sphere_p, sphere_r);    \n    float d2 = sdBox(p+box_p,box_s);\n    float d3 = sdPlane(p,mirror_n);\n    float m = min(d3,min(d1, d2));\n    if(m==d3){\n        i = 3.0;\n    }\n    return vec2(m,i);\n}\n\n//light!\nvec3 getNormal(vec3 p){\n    vec3 normal = normalize(vec3(\n        distanceField(vec3(p.x + EPSILON, p.y, p.z)) - distanceField(vec3(p.x - EPSILON, p.y, p.z)),\n        distanceField(vec3(p.x, p.y + EPSILON, p.z)) - distanceField(vec3(p.x, p.y - EPSILON, p.z)),\n        distanceField(vec3(p.x, p.y, p.z  + EPSILON)) - distanceField(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n    return normal;\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = getNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0*sin(0.3 * iTime),\n                          2.0*cos(0.3 * iTime),\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    vec3 light2Pos = vec3(2.0 * cos(0.37 * iTime),\n                          2.0 * sin(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    \n    return color;\n}\n\n//trace\n/*float trace(vec3 o, vec3 r){\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p = o + r * depth;\n        float dist = distanceField(p);\n        if (dist < EPSILON) {\n               return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}*/\n\n\n\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //uv\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    float ea=0.0;\n    vec3 eyeOrigin = vec3(eye.z*sin(ea)+eye.x*cos(ea),\n                          eye.y,\n                          eye.z*cos(ea)-eye.x*sin(ea));\n    vec3 eyeDir = normalize(eyeLookAt - eyeOrigin);\n    vec3 eyeRight = normalize(cross(up, eyeOrigin));\n    vec3 eyeUp = normalize(cross(eyeDir, eyeRight));\n    \n    //ray\n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n    vec3 o = eyeOrigin;\n    vec3 r = rayDir;\n    float reflection = 0.0;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);//ambient\n    vec3 K_d = vec3(0.7, 0.2, 0.2);//diffuse\n    vec3 K_s = vec3(1.0, 1.0, 1.0);//specular\n    float shininess = 5.0;\n    vec3 color=vec3(0.0,0.0,0.0);\n           \n    //float dist=trace(o,r);\n    float dist = MAX_DIST;\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 pos = o + r * depth;\n        vec2 cal_d=  distanceField2(pos);\n        float d = cal_d.x;\n        float index = cal_d.y;\n        if (d < EPSILON) {\n            dist = depth;\n            if(index == 3.0){\n                o = dist * r;\n                r=reflect(r,normalize(mirror_n.xyz));\n            }else{\n                vec3 p = eye + dist * rayDir;\n                vec3 N = getNormal(p);\n                color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);   \n            }\n                \n        }\n        depth += d;\n        \n    }\n      \n     fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSBWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 500, 538, 538, 572], [574, 574, 607, 607, 705], [707, 707, 739, 739, 774], [776, 776, 805, 805, 963], [965, 965, 994, 994, 1232], [1234, 1243, 1266, 1266, 1632], [1634, 1634, 1774, 1774, 2199], [2202, 2202, 2287, 2287, 3095], [3475, 3482, 3539, 3549, 5101]], "test": "untested"}
{"id": "XlSBWR", "name": "4/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. It is pretty much the same as yesterday's shader (3/2018). I continued from it and figured out things that were wrong. Also added some shading & fog.\n", "tags": ["raymarching", "sierpinski", "dailyshader"], "likes": 1, "viewed": 118, "published": "Public", "date": "1515191630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64\n#define FAR 100.0\n#define EPSILON 0.001\n\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nfloat dist(vec3 p){\n    //return length(p)-1.0;\n    vec3 pp = p;\n    float scale = 2.0;\n    float offset = 8.0;\n    \n    int n = 0;\n    for(int i= 0; i < 20; ++i){\n        ++n;\n        if(pp.x+pp.y < 0.0){\n            pp.xy = -pp.yx;\n        }\n        if(pp.x+pp.z < 0.0){\n            pp.xz = -pp.zx;\n        }\n        if(pp.y+pp.z < 0.0){\n            pp.zy = -pp.yz;\n        }\n        pp = pp*scale-offset*(scale-1.0);\n        \n    }\n    \n    return length(pp)*pow(scale, -float(n));\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(0.1, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy)-dist(p-eps.xyy),\n        dist(p+eps.yxy)-dist(p-eps.yxy),\n        dist(p+eps.yyx)-dist(p-eps.yyx)\n    ));\n}\n\n//Ambien occlusion & shadow coeffience function modified from\n//las's (Mercury) and dechipher's (YUP) methods from pouet raymarching thread\n//PRAMETERS:\n//  p = position,\n//  n = normals (ao) or unit vector of light direction (shadow)\n//  k = constant\n\nfloat ambientOcclusion(vec3 p, vec3 n, float k){\n    float s = sgn(k);\n    float o = s*.5+.5;\n    for(float i = 0.; i < 6.; ++i){\n        o -= (i*k - dist(p+n*i*k*s))/exp2(i);\n    }\n    return max(min(o, 1.), 0.);\n}\n\nvec3 color(vec3 p, vec3 ld){\n    vec3 n = normals(p);\n   \tvec3 col = ambientOcclusion(p, n, 0.5)*vec3(0.6, 0.3, 0.6)+vec3(0.5, 0.3, 0.8);\n    \n    return ambientOcclusion(p, ld, 0.25)*col;\n}\n\nvec3 fog(vec3 col, vec3 p, vec3 ro){\n    float dist = length(p-ro);\n\tfloat fogAmount = 1.0 - exp( -dist*0.07);\n    return mix(col, vec3(1.0), fogAmount);\n}\n\n\n\nvec3 march(vec3 ro, vec3 rd){\n    \n    float t = 0.0;\n    vec3 p = ro;\n    for(int i = 0; i < STEPS; ++i){\n        float d = dist(p);\n        t += d;\n        p += rd*d;\n        \n        if(d < EPSILON || t > FAR){\n            break;\n        }\n    }\n    \n    vec3 col = vec3(0.0);\n    if(t <= FAR){\n       col = color(p, vec3(0.0, -1.0, 0.0));\n    }\n    return fog(col, p, ro);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    q = -1.0+2.0*q;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(cos(iTime*0.25)*9.0, 1.0, sin(iTime*0.25)*9.0);\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x,z));\n    \n    vec3 rd = mat3(x,y,z)*vec3(q.xy, radians(50.0));\n    rd = normalize(rd);\n    \n    vec3 col = march(ro, rd);\n    col = pow(col, 1.0/vec3(2.2));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSBWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 78, 78, 106], [108, 108, 127, 155, 594], [596, 596, 617, 617, 812], [814, 1067, 1115, 1115, 1282], [1284, 1284, 1312, 1312, 1474], [1476, 1476, 1512, 1512, 1631], [1635, 1635, 1664, 1664, 2013], [2014, 2014, 2071, 2071, 2606]], "test": "untested"}
{"id": "Xt2BD1", "name": "Torus_Thingy_9", "author": "balkhan", "description": " ", "tags": ["3d", "raymarch", "torus"], "likes": 10, "viewed": 161, "published": "Public", "date": "1515621931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t400.\n#define E\t\t\t0.00001\n#define FAR\t\t\t50.\n#define PI\t\t\t3.14\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    pos.z = 4.5+1.5*sin(t*10.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n//    if (inter.y <= FAR)\n        col.xyz = ret_col*(1.-inter.x*.005);\n//    else\n//        col *= 0.;\n    col += h*.005125;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    p.z += 10.;\n    \n    rotate(p.xz, 1.57-.5*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    var = atan(p.x,p.y);\n    vec2 q = vec2( ( mylength(p.xy) )-6.,p.z);\n\n    rotate(q, var*.25-floor(iTime*20.)/20. );\n    q = abs(q)-2.5;\n    var = cos(floor(var*14.)+1.*floor(iTime*50.)/50. );\n    rotate(q, ( (var*1.)+iTime*0.5)*3.14-floor(iTime*5.)/5. );\n    ret_col = vec3(.50, .82, .3);\n    mind = length(q)+.25-(length(fract(q*.25*(3.+3.*sin(var*1. - 1.*iTime*1.5)) )-.5)+.250);\n    h -= vec3(-1.0,-.50,.26)*vec3(1.)*.0125/(.01+(mind )*(mind ) );\n    h += vec3(.5,.58,1.27)*vec3(1.)*.0125/(.01+mind*mind);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2BD1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[427, 569, 612, 612, 1025], [1027, 1027, 1048, 1048, 1714], [1716, 1716, 1748, 1748, 2159], [2161, 2175, 2199, 2199, 2296], [2298, 2298, 2338, 2338, 2413], [2415, 2415, 2443, 2443, 2551], [2553, 2553, 2575, 2575, 2781], [2783, 2783, 2833, 2833, 3096]], "test": "untested"}
{"id": "Xt2BDc", "name": "Understand noise", "author": "marzinp", "description": "Just a place to experiment some noise implementations... using Shane, IQ FabriceNeyret and other talented coders!", "tags": ["noise"], "likes": 17, "viewed": 582, "published": "Public", "date": "1517424905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash31( vec3 p ) {\n\tfloat h = dot(p,vec3(17, 1527, 113));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n//iq noise and derivatives\nvec4 noised( in vec3 p )\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    vec3 u = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);\n    vec3 du = 30.0*fp*fp*(fp*(fp-2.0)+1.0);\n\n    float a = hash31( ip+vec3(0,0,0) );\n    float b = hash31( ip+vec3(1,0,0) );\n    float c = hash31( ip+vec3(0,1,0) );\n    float d = hash31( ip+vec3(1,1,0) );\n    float e = hash31( ip+vec3(0,0,1) );\n    float f = hash31( ip+vec3(1,0,1) );\n    float g = hash31( ip+vec3(0,1,1) );\n    float h = hash31( ip+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( (k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tvec3 fp = p-ip; // Cell's fractional component.\n\t\n    // A bit of quintic smoothing, to give the noise that rounded look.\n\tfp = fp*fp*fp*(fp*(fp * 6. - 15.) + 10.);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), fp.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, fp.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, fp.z); // Range: [0, 1].\n\t\n}\nconst mat3 rot = mat3( 0.80,  0.60,0.0,-0.60,  0.80 ,0.0,0.0,0.0,1.0);\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\n// returns 3D fbm and its 3 derivatives\nvec4 fbm( in vec3 x, int octaves ) \n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.49;  // could be 0.5\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i < octaves; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n    return vec4( a, d );\n}\nvec4 map(vec3 p){\n    \n    // One layer of noise at isolevel \"0.3\" - I have no idea whether that's the\n    // correct terminology. :)\n\n    return fbm(p*2.0,3) - .3;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n\t\n    // Unit direction ray. The last term is one of many ways to fish-lens the camera.\n    // For a regular view, set \"rd.z\" to something like \"0.5.\"\n    vec3 rd = normalize(vec3(uv,.5));//, (1.-dot(uv, uv)*.5)*.5)); // Fish lens, for that 1337, but tryhardish, demo look. :)\n    \n    // There are a few ways to hide artifacts and inconsistencies. Making things go fast is one of them. :)\n    // Ray origin, scene color, and surface postion vector.\n    vec3 ro = vec3(0., iTime*1.5, iTime*1.5), col=vec3(0), sp;\n\t\n    // Swivel the unit ray to look around the scene.\n    // Compact 2D rotation matrix, courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.375);\n    rd.xz = mat2(a, -a.y, a.x)*rd.xz;    \n    rd.xy = mat2(a, -a.y, a.x)*rd.xy;     \n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    t = .2; \n    \n    // Surface distance threshold. Smaller numbers gives a thinner membrane, but lessens detail... \n    // hard to explain. It's easier to check it out for yourself.\n    float thD = .02; // + smoothstep(-0.2, 0.2, sin(iTime*0.75 - 3.14159*0.4))*0.025;\n \n\t\n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(float i=0.; i<56.; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>20. || col.x > 1. || t>20.) break;\n        \n        // Current ray postion. Slightly redundant here, but sometimes you may wish to reuse\n        // it during the accumulation stage.\n        sp = ro+rd*t;\n        d = map(sp).x; // Distance to nearest point on the noise surface.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. You could smoothly interpolate it, if you wanted.\n        //\n        // 1/.(1. + t*t*0.1) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d)*23./24.)/thD;\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n            \n            // Add the accumulated surface distance value, along with some basic falloff (fog, if \n            // you prefer) using the camera to surface distance, \"t.\" If you wanted, you could\n            // add a light, and use the light position to ray position distance instead.\n            // There's a bit of color jitter there, too.\n            \n            //col += aD*aD*(3.-2.*aD)/(1. + t*t*0.125)*.1 ;\n\n            col += vec3(aD/(1. + t*0.15)*.07,aD/(1. + t*t*0.1)*.07,aD/(1. + t*t*0.1)*.1);\n            \n            // The layer number is worth noting. Accumulating more layers gives a bit more glow.\n            // Lower layer numbers allow a quicker bailout. A lot of it is guess work.\n            layers++;  \n        }\n\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit \n        // of knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        t += max(abs(d)*.7, thD*.7); \n        \n\t\t\t    \n\t}\n    \n    // Clamping \"col\" above zero, but just to be safe.\n    col = max(col, 0.);\n\n    \n\t// Presenting the color to the screen. Note that there's no gamma correction. It was a style\n    // choice - to give more contrast, but it's usually best to have it.\n\tfragColor = vec4( clamp(col, 0., 1.), 1.0 );\n    \n     \n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2BDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 106], [108, 135, 161, 161, 1196], [1198, 1198, 1220, 1313, 2295], [2629, 2669, 2706, 2706, 3208], [3209, 3209, 3226, 3342, 3376], [3380, 3380, 3434, 3467, 7461]], "test": "untested"}
{"id": "Xt2BDG", "name": "Trippy Waves", "author": "lukasxl", "description": "Just some trippy waves / kaleidoscope effect", "tags": ["waves", "kaleidoscope"], "likes": 19, "viewed": 5268, "published": "Public API", "date": "1517014970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy ) / iResolution.y; \n    \n    vec4 result = vec4(0,0,0,1);\n\n    float t = 1.;\n    float offset = -5. * iTime;\n    float base = 100. * length(uv);\n\n    float d = sin(-iTime + 15. * length(uv));\n    d *= d * d;\n\n    mat2 rot = rotate(5. * length(uv));\n    uv += .5;\n    \n    uv = abs(rot * uv);\n    \n    for (int p = 0; p < 3; p++)\n    {\n        result[p] = sin(offset + t * base) - cos(20. * uv.x) - cos(20. * uv.y);\n        t += 0.05;\n    }\n\n    result.xyz *= result.xyz;\n    result.xyz = 1. - result.xyz;\n\n    fragColor = result * d;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2BDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 111], [113, 113, 170, 170, 753]], "test": "untested"}
{"id": "Xt2BWw", "name": "Saturn_Ring", "author": "duvengar", "description": "An audio reactive Saturn ring.", "tags": ["2d", "noise", "sound", "space", "planet"], "likes": 12, "viewed": 359, "published": "Public", "date": "1516032315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// \"Saturn_Ring\"\n// by Julien Vergnaud @duvengar-2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// music : https://soundcloud.com/alex-jedi/space-effect-end\n\n// Sound sensitivity inspired by @ocb shader.\n// https://www.shadertoy.com/view/4ljfWW\n\n////////////////////////////////////////////////////////////////////////////////////////////\n#define M(t, d) mat2(cos(t * d), sin(t * d), -sin(t * d), cos(t * d))\n#define S(x, y, z) smoothstep(x, y, z)\n#define SEED .2831\n\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 91438.55123);   \n}\n\n\nfloat hash2(vec2 p)\n{\n    // hash2 taken from Dave Hoskins \n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * SEED);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\nmat2 m = mat2( 0.6, 0.6, -0.6, 0.8);\n\nfloat fbm(vec2 p){\n \n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= m * 2.02;\n    f += 0.2500 * noise(p); p *= m * 2.03;\n    f += 0.1250 * noise(p); p *= m * 2.01;\n    f += 0.0625 * noise(p); p *= m * 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n\nfloat starcloud(vec2 uv, vec2 scale, float density){\n\n    \n    vec2 grid = uv * scale;\n    vec2 id = floor(grid);  \n    grid = fract(grid) - .5;\n\n    float d = length(grid);  \n    float r = pow(hash2(id), density);\n    float star = 1. - S(-.01, clamp(r,.0,.5), d);\n\n    ;\n    return star ;\n}\nvec2 pol( vec2 uv){\n    \n   float scale = 3.;\n    uv.y *= scale;\n    vec2 pos = vec2(-scale*.01, -scale*.4);\n    uv += pos;\n    float l = length(uv);\n    vec2 r = vec2(sqrt(dot(uv,uv)));\n\n   return vec2(l);\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime;\n     float amp = .0;\n    amp += .6 - texelFetch(iChannel0,ivec2(20,0),0).x + .5\n       *texelFetch(iChannel0,ivec2(400,0),0).x;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv*=1.3;\n    vec2 st = uv/1.3;\n    //uv *= 1.1;\n      \n    st = -1. + 2.*st;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 st2 = uv;\n    uv.y += .1 * dot(uv,uv);\n    \n    //\n    float p = S(.6,.58,length(uv + vec2(-.05,-.45)));\n    float p2 = min(p, p-S(.65,.54,length(uv + vec2(-.05,-.42))));\n    \n    \n    uv = pol(uv);\n    \n    float ring = pow(noise(noise(4.*uv- iTime*.5)*uv*5.),3.);\n    ring += pow(noise(noise(2.*uv- iTime*.3)*uv*30.),4.);\n    ring -= pow(fbm(2.*uv- iTime*.3*uv*60.),10.);\n\n    ring -=  amp < .5  && amp > -.5 ?  S(-.49,.4, amp *2.) : .0;\n    ring = pow(clamp(ring,-1.0,1.), 3.);\n    ring  -= 1.-S(.8,1.,length(uv*.5));  \n    ring *= 1.-S(.8,1.5,length(uv.y*.5));\n    \n\n    float star = starcloud(M(t*.02,1.) * st2, vec2(70.), 200.);\n    //star += starcloud(st2, vec2(100.), 50.);\n   \n    \n\tvec4 C = vec4(vec3( clamp(ring - p, .0,1.) + (p2 * 2.) ),1.0);\n    C = clamp(C,.0,1.);\n    C += vec4(.0,.0,.05,1.); \n    C += 2.*S(vec4(star),vec4(.0),  vec4(1.-length(st2.x*.41 )));\n   \n\tC += .06*hash2(uv*vec2(1462.439, 297.185));\n\n    C += .04*length(st.y + 1.5);\n    C -= .1 * dot(st*st,st*st);\n\n    fragColor = C;\n    \n    \n}", "image_inputs": [{"id": "MsBSRm", "previewfilepath": "https://soundcloud.com/alex-jedi/space-effect-end", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/alex-jedi/space-effect-end", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2BWw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[293, 516, 537, 537, 582], [585, 585, 606, 689, 805], [807, 807, 833, 833, 1040], [1080, 1080, 1098, 1098, 1324], [1327, 1327, 1379, 1379, 1618], [1619, 1619, 1638, 1638, 1837], [1839, 1839, 1896, 1896, 3245]], "test": "untested"}
{"id": "Xt2BzD", "name": "portals of perfect order", "author": "jes5199", "description": ":D", "tags": ["2d", "moire"], "likes": 2, "viewed": 120, "published": "Public", "date": "1514868462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 50.0 * ((fragCoord.xy - iResolution.xy/2.)/ iResolution.y) + vec2(0, 0);\n    \n    float d = 1.0;// + sqrt(length(uv)) / 109.0;\n    float t = 0. + iTime;\n    float value = d * t + (t * 0.5) * cos(uv.x) * cos(uv.y);\n    float color = sin(value) * 3.0;\n    //color = color * sign(uv.x) * sign(uv.y); // revision 2\n\n    \n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float medhigh = abs(color) - 1.5;\n    float high = abs(color) - 2.0;\n    \n    vec4 metalColor;\n    vec4 lifeColor;\n        \n    if(color > 0.) {\n      metalColor = vec4(med, medhigh, high,1.0);\n      lifeColor = vec4(high, high, med,1.0);\n    } else {\n      metalColor = vec4(medhigh, medhigh, medhigh,1.0);\n      lifeColor = vec4(med, high, high,1.0);\n    }\n        \n    fragColor = lifeColor * 1.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2BzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 854]], "test": "untested"}
{"id": "Xt2fRV", "name": "Collatz Experiments", "author": "rrx", "description": "fork of iq shader: https://www.shadertoy.com/view/llcGDS", "tags": ["fractal", "collatz"], "likes": 5, "viewed": 149, "published": "Public", "date": "1516536942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// The visuals for the third part of my video \"Collatz and Self Similarity\": \n//\n// https://www.youtube.com/watch?v=GJDz4kQqTV4\n//\n// (minus the text overlays, which cannot do in the online version of Shadertoy\n\n\n//------------------------------------------------------\n// global\n//------------------------------------------------------\n\n#define AA 2   // supersampling level. Make higher for more quality.\n\nconst float pi = 3.1415926535897932384626433832795; // should be pronounced \"pee\" not \"pie\", dear english speakers!\n\n\n\n//------------------------------------------------------\n// complex numbers\n//------------------------------------------------------\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cmulj( vec2 z ) { return vec2(-z.y,z.x); }\nvec3 cexp( vec2 z ) { return vec3( exp(z.x), vec2( cos(z.y), sin(z.y) ) ); }\nvec3 cexpj( vec2 z ) { return vec3( exp(-z.y), vec2( cos(z.x), sin(z.x) ) ); }\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n//------------------------------------------------------\n// Visualization\n//------------------------------------------------------\n\nvec3 render( in vec2 fragCoordScreen, float time )\n{\n    float sc = 4.5;\n    vec2 ce = vec2(.0,0.0);    \n\n    float zoomDepth = 2.5;\n    float eTime = zoomDepth*sin(time/zoomDepth) + zoomDepth;\n    \n    sc = 4.5 * pow( 0.1, eTime );\n        \n    vec2 center = vec2(0.5,0.5);\n    \n    float spinAngle = 0.0;\n\n    vec2 fragCoord = rotate(fragCoordScreen, spinAngle);\n\n    vec2 p = ce + sc*(-iResolution.xy+2.0*fragCoord) / iResolution.x;\n    float e = sc*2.0/iResolution.x;\n    \n    \n    vec2 z = rotate(p, time);\n    //n = vec2(n.x,0.0);\n    \n    const float th = 10000000000.0;\n    \n    vec2 lz = z;\n    float d = 0.0;\n    float f = 0.0;\n    float rmin = th;\n    vec2 dz = vec2(1.0,0.0);\n    vec2 ldz = dz;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 k = cexpj( pi*z );\n        \n        lz = z;\n        ldz = dz;\n\n        dz = cmul( (vec2(8.0,0.0) - k.x*cmul(k.yz,vec2(5.0-5.0*pi*z.y, pi*(5.0*z.x+2.0))))/4.0, dz );\n        \n        //rmin = min( rmin, length(cdiv( cadd(7.0*z,2.0) , cadd(5.0*z,2.0) ) - k.x*k.yz) );\n        \n        z = ( cadd(7.0*z,2.0) - k.x*cmul(k.yz,cadd(5.0*z,2.0)) )/3.9;\n\n\n        float r = length(z);\n        rmin = min( rmin, r );\n        if( r>th ) { d=1.0; break; }\n        f += 1.0;\n    }\n    \n    vec3 col = vec3(0.0);\n    if( d<2.0 )\n    {\n        col = vec3(1.0,0.6,0.2);\n        \n        f += clamp( log(th/length(lz))*1.8, 0.0, 1.0 ) - 1.0;\n        col = 0.5 + 0.5*cos(0.15*f + 1.5 + vec3(0.2,0.9,1.0));\n        col *= 0.027*f;\n        \n        col += 0.01*sin(40.0*atan(lz.x,lz.y));\n        \n        float dis = log(length(lz))*length(lz)/length(ldz);\n        col += 0.025*sqrt(dis/sc) - 0.1;\n        col *= 0.9;\n    }\n    else\n    {\n        col = vec3(0.0,0.0,0.0);\n    }\n\n   \n    //col = clamp( col, 0.0, 1.0 );\n      \n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 px = fragCoord + vec2(float(m),float(n))/float(AA);\n    \tcol += render( px, iTime );    \n    }\n    col /= float(AA*AA);\n#else\n        \n    col = render( fragCoord, iTime );\n#endif            \n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2fRV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[653, 787, 817, 817, 846], [847, 847, 877, 877, 932], [933, 933, 963, 963, 1033], [1034, 1034, 1056, 1056, 1081], [1082, 1082, 1103, 1103, 1158], [1159, 1159, 1181, 1181, 1237], [1240, 1240, 1270, 1270, 1354], [1356, 1488, 1540, 1540, 3268], [3271, 3271, 3328, 3328, 3677]], "test": "untested"}
{"id": "Xt2fWc", "name": "Hexagoniser", "author": "mooped", "description": "Quantize distance field based on hexiness of the gradient. Break your eyes.", "tags": ["hexes"], "likes": 0, "viewed": 95, "published": "Public", "date": "1517418876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 pos, float rad)\n{\n    return length(pos) - rad;\n}\n\nvec2 getMouse()\n{\n    return iMouse.xy/iResolution.xy;\n}\n\nfloat dist(vec2 uv)\n{\n    //return texture(iChannel0, uv).r;\n    return min(\n        min(circle(uv - vec2(0.5, 0.0), 0.1),\n           circle(uv - vec2(0.0, 1.f), 0.1)\n        ),\n        circle(uv - getMouse(), 0.1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y + 0.5;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Distance field\n    float d = dist(uv);\n    vec2 n = normalize(vec2(dFdx(d), dFdy(d)));\n    \n    float ang = (atan(n.y, n.x) / 3.1415 + 1.0) * 0.5;\n    \n    ang = floor(ang * 6.f) / 6.f;\n    ang = ang * 2.f - 1.f;\n    \n    float v = dot(uv, vec2(sin(3.1415 * (ang)), cos(3.1415 * (ang))));\n    \n    col *= sin((v + iTime * 0.5) * 50.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2fWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 67], [69, 69, 86, 86, 125], [127, 127, 148, 187, 350], [352, 352, 409, 459, 1026]], "test": "untested"}
{"id": "XtBBDD", "name": "Rotating Circles", "author": "hallabada", "description": "How can I remove these visual artifacts?\nInspired By (https://www.youtube.com/watch?v=uTQy_UqTtGo&t=4s)", "tags": ["2d"], "likes": 1, "viewed": 94, "published": "Public", "date": "1515751494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 drawSmooth(float d, vec3 color);\nfloat sdfCircle(vec2 center, float radius, vec2 pt);\nfloat sdfUnion(float sdf1, float sdf2);\nfloat sdfDiff(float sdf1, float sdf2);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 0.5 - fragCoord.xy / iResolution.xy;\n    vec2 p = vec2(iResolution.x / iResolution.y, 1) * uv;\n\t\n    float outerRadius = 0.4;\n    int circleCount = 50;\n    float t = iTime;\n    float strokeWidth = 0.003 + 0.001*sin(t);\n    \n    float d = 10000.0;\n    \n    for (int i=0; i<circleCount; i++)\n    {\n        float rstep = outerRadius/float(circleCount);\n        float radius = float(i)*rstep;\n        float offset = (outerRadius-sin(t)*radius);\n        vec2 center = vec2(offset*cos(t), offset*sin(t));\n        \n        float circle1 = sdfCircle(center, radius+strokeWidth, p);\n        float circle2 = sdfCircle(center, radius, p);\n        float stroke = sdfDiff(circle1, circle2);\n        \n        d = sdfUnion(d, stroke);\n    }\n    \n    vec4 layer = drawSmooth(d, vec3(0,0,0));\n    vec4 bg = vec4(1.0, 1.0, 1.0, 1.0);\n    fragColor = vec4(mix(bg.rgb, layer.rgb, layer.a), 1.0);\n}\n\n\nvec4 drawSmooth(float d, vec3 color)\n{\n    float aaf = fwidth(d);\n    vec4 stroke = vec4(color, 1.0-d*80.0);\n    return stroke;\n}\n\n/* (x - center)^2 + (y - center)^2 = radius^2 */\nfloat sdfCircle(vec2 center, float radius, vec2 pt)\n{\n    vec2 r = pt - center;\n    return sqrt((r.x*r.x) + (r.y*r.y)) - radius;\n}\nfloat sdfUnion(float sdf1, float sdf2)\n{\n    return min(sdf1, sdf2);\n}\n\nfloat sdfDiff(float sdf1, float sdf2)\n{\n    return max(sdf1, -sdf2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 229, 229, 1118], [1121, 1121, 1159, 1159, 1250], [1252, 1301, 1354, 1354, 1431], [1432, 1432, 1472, 1472, 1502], [1504, 1504, 1543, 1543, 1574]], "test": "untested"}
{"id": "XtBBDR", "name": "Randazzo Dimension", "author": "jpupper", "description": "So ive made it using the book of shaders as a guide. This is the one I made for the chapter about patterns", "tags": ["thebookofshaderstilepattern"], "likes": 1, "viewed": 128, "published": "Public", "date": "1515221552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265358979323846\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotateTilePattern(vec2 _st){\n\n    //  Scale the coordinate system by 2x2\n    _st *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 0.0){\n    _st = rotate2D(_st,PI*2.*1./4.);\n    }\n    else if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n         _st = rotate2D(_st,PI*2.*3./4.);\n         \n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n         _st = rotate2D(_st,PI*2.*1./4.);\n         \n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        _st = rotate2D(_st,PI*2.*3./4.);\n    }\n\n    return _st;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = tile(uv,1.);\n    uv = rotateTilePattern(uv);\n    \n    \n    vec2 pos = vec2(0.,5.) - uv;\n    float radius = length(pos);\n    float angle = atan(pos.x,pos.y);\n    float r = sin(radius*sin(uv.y*PI*5.+iTime+cos(sin(uv.x*PI*3.)*PI*2.+sin(uv.y*PI*15.)))\n                  *1.*sin(uv.y*PI+sin(uv.x*PI*5.)));\n    \n    //float r = sin(sin(uv.x*PI*5.+));\n    float g = cos(r*PI*2.+PI*2.)*0.9;\n    \n    float b = cos(r*PI*2.+PI*2.)*0.9+sin(r*PI*2.+PI*2.)*0.7;\n    \n    r+=g;\n    \n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBBDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 75, 75, 215], [217, 217, 252, 252, 295], [297, 297, 330, 374, 1236], [1239, 1239, 1296, 1296, 1856]], "test": "untested"}
{"id": "XtBBDz", "name": "[MAGFest18] Audioshader", "author": "qguv", "description": "Submitted for the Magfest demo competition. Music is original and created just for this demo.", "tags": ["basic", "audio", "demo", "magfest18"], "likes": 2, "viewed": 359, "published": "Public", "date": "1515267096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 black = vec4(0.0);\nconst vec4 white = vec4(1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 0.0);\nconst float bpm = 112.0;\nconst int STYLE_VERTICAL_LEFT = 0;\nconst int STYLE_HORIZONTAL_BOTTOM = 1;\n\nbool gate(int beat)\n{\n    switch (beat % 8) {\n        case 1:\n        case 4:\n        case 7:\n            return false;\n    }\n    return true;\n}\n\nfloat frac(float x)\n{\n    return x - floor(x);\n}\n\n\nfloat rand(vec2 co)\n{\n    /* magic */\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nbool bg8(vec2 fragCoord)\n{\n    return rand(floor(fragCoord / 30.0 + iTime)) < 0.3;\n}\n\nvec4 arp(vec2 p, int beat16, bool vertical, vec4 top, in vec2 fragCoord)\n{\n    float quadrant1 = float((beat16 % 4) + 1);\n    \n    float cutoff;\n    bool on = vertical\n        \n      ? /* vertical */\n      fragCoord.x < (iResolution.x / 4.0) * quadrant1\n\n      : /* horizontal */\n      fragCoord.y < (iResolution.y / 4.0) * quadrant1;\n\n    return on\n        ? top\n        : ((beat16 / 4) % 8 == 7)\n            ? rand(p * iTime) > 0.2\n                ? black\n                : white\n            : black;\n}\n\nfloat circle(vec2 p, vec2 r, float R, float Rwidth)\n{\n    return smoothstep(R, R + Rwidth, length(p - r));\n}\n\nfloat inv(float x)\n{\n    return -1.0 * x + 1.0;\n}\n\nbool zero(vec4 v)\n{\n    return 0.0 == v.x && 0.0 == v.y && 0.0 == v.z && 0.0 == v.w;\n}\n\nvec4 above(vec4 x, vec4 y)\n{\n    return zero(x) ? y : x + y;\n}\n\nvec4 planets(vec2 p, float fbeat, vec4 planet_color, vec4 moon_color)\n{\n    float swell = 0.4 + frac(fbeat) / 5.0;\n\n    vec2 moon_pos = vec2(sin(iTime - 0.8), cos(iTime));\n    vec4 moon = length(moon_pos - vec2(-1.0)) > 0.5\n        ? moon_color * inv(circle(p, moon_pos, 0.2, 0.01))\n        : black;\n\n    vec4 planet = planet_color * inv(circle(p, vec2(0.0), swell, 0.01));\n\n    return above(moon, planet);\n}\n\nbool rect(vec2 p, float xmin, float xmax, float ymin, float ymax)\n{\n    return p.x > xmin && p.x < xmax && p.y > ymin && p.y < ymax;\n}\n\nvec4 magfest(vec2 p)\n{\n    /* vertical lines */\n    float half_width = 0.01;\n    vec4 verts = black;\n    for (float i = -0.8; i <= 0.8; i += 0.4)\n        verts += rect(p, i - half_width, i + half_width, -0.3, 0.3) ? white : black;\n\n    vec4 top = rect(p, -0.8 - half_width, 0.9, 0.29, 0.31)\n            && !(p.x > -0.4 + half_width && p.x < 0.0 - half_width)\n            && !(p.x > 0.4 + half_width && p.x < 0.8 - half_width)\n             ? white\n             : black;\n\n    vec4 bottom = rect(p, -0.9, 0.8 + half_width, -0.31, -0.29)\n            && !(p.x > -0.8 + half_width && p.x < -0.4 - half_width)\n            && !(p.x > 0.0 + half_width && p.x < 0.4 - half_width)\n             ? white\n             : black;\n\n    return top + bottom + verts;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0 + 2.0 * q) * vec2(iResolution.x / iResolution.y, 1.0);\n\n    float beat_time = 60.0 / bpm;\n    float fbeat = iChannelTime[0] / beat_time;\n    int beat = int(fbeat);\n\n    float beat16_time = 15.0 / bpm;\n    float fbeat16 = iChannelTime[0] / beat16_time;\n    int beat16 = int(fbeat16);\n\n    /* chords only */\n    if (beat < 32) {\n\t    fragColor = gate(beat)\n            ? planets(p, fbeat, red, white)\n            : (beat % 8 == 7)\n                ? rand(p * iTime) > 0.2\n                    ? black\n                    : white\n                : black;\n    /* chords & arps, then arps only */\n    } else {\n        bool vertical = (beat / 8) % 2 == 0;\n        fragColor = gate(beat)\n            ? beat < 96\n                /* pulse for chords */\n                ? planets(p, fbeat, red, white)\n\n                /* static for no chords */\n                : planets(p, 0.0, red, white)\n\n            : vertical\n                ? arp(p, beat16, true, red, fragCoord)\n                : arp(p, beat16, false, red, fragCoord);\n    }\n\n    /* fade out everything */\n    fragColor *= -1.0 * smoothstep(112.0, 128.0, fbeat) + 1.0;\n\n    /* but fade in magfest */\n    fragColor = above(magfest(p) * smoothstep(104.0, 120.0, fbeat), fragColor);\n}", "image_inputs": [{"id": "Md2SzW", "previewfilepath": "https://soundcloud.com/madwithcolors/shade", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/madwithcolors/shade", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBBDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 224, 224, 347], [349, 349, 370, 370, 397], [400, 400, 421, 437, 510], [512, 512, 538, 538, 596], [598, 598, 672, 672, 1102], [1104, 1104, 1157, 1157, 1212], [1214, 1214, 1234, 1234, 1263], [1265, 1265, 1284, 1284, 1351], [1353, 1353, 1381, 1381, 1415], [1417, 1417, 1488, 1488, 1825], [1827, 1827, 1894, 1894, 1961], [1963, 1963, 1985, 2010, 2711], [2713, 2713, 2768, 2768, 4060]], "test": "untested"}
{"id": "XtBBRw", "name": "SquarePump", "author": "PlamenPavlov", "description": "Pulsating Checker Pattern", "tags": ["pulsatingcheckerpattern"], "likes": 0, "viewed": 70, "published": "Public", "date": "1514942119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.) / vec2(500. * (1. - sin(iTime /2.)/2.)) - vec2(1);\n    uv *= 4.;\t\n    float col = mod(floor(uv.x) + floor(uv.y), 2.);\n    fragColor = vec4(vec3(col),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBBRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 249]], "test": "untested"}
{"id": "XtBBWm", "name": "Omega Ripple beats", "author": "sunilpro", "description": "Music synced milk woofer ", "tags": ["sound", "beat", "ripple", "milk", "woofer"], "likes": 7, "viewed": 233, "published": "Public", "date": "1515953763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    \n    float beat = texture( iChannel0, vec2( 0.001, 0.25 ) ).x / 2.0;\n    float dt = fract(iTime/2.)*2.;\n    float time = PI*dt*2.;\n   \n\tfloat cLength = length(uv)/(1.-beat);\n    float offset = uv.y*cos(cLength*PI*2.*4.-time)*.5;\n    \n    float amplitude = 1. - distance(fragCoord.xy/iResolution.xy, vec2(0.5, 0.5));\n    offset *= pow(amplitude, 4.0);\n    \n    fragColor = vec4(0.96, 0.96, 0.96, 1.0) + offset;\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 557]], "test": "untested"}
{"id": "XtBfDG", "name": "lucazade", "author": "dexterwritescode", "description": "For atheletes", "tags": ["shaderclub"], "likes": 3, "viewed": 478, "published": "Public API", "date": "1516936559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    float TAU = 6.2831853071;\n    \n    float angleX = uv.x * TAU;\n    float angleY = uv.y * TAU;\n    \n    float r = (sin(angleX * cos(angleY + iTime) + iTime) * cos(sin(angleY * 5.0 + angleX) + iTime));\n    float g = (cos(cos(angleX) + sin(angleY) + iTime) + sin(sin(angleY * angleX) + iTime));\n    float b = 0.4;\n    vec4 color = vec4(mix(vec3(255.0, 97.0, 65.0) / vec3(255.0),\n                          vec3(0.0, 163.0, 136.0) / vec3(255.0),\n                          r - g), 1.0);\n    \n\tfragColor = color;\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}, {"id": "XsXGR8", "previewfilepath": "/media/previz/buffer01.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer01.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 616]], "test": "untested"}
{"id": "XtBfDW", "name": "Voronoise Octaves", "author": "tsuhre", "description": "iq's voronoise function with octaves. u value shifted by time", "tags": ["noise", "voronoise", "ovtaves"], "likes": 7, "viewed": 128, "published": "Public", "date": "1515710228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float octaves = 2.;\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// http://iquilezles.org/www/articles/voronoise/voronoise.htm\nvec3 hash3( vec2 p ) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)),\n                   dot(p,vec2(269.5,183.3)),\n                   dot(p,vec2(419.2,371.9)) );\n    return abs(mod(sin(q)*43758.5453*(iTime+1000.)/50000., 2.) - 1.);\n}\n\nfloat iqnoise( in vec2 x, float u, float v ) {\n    \n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0+63.0*pow(1.0-v,4.0);\n\n    float va = 0.0;\n    float wt = 0.0;\n    for (int j=-2; j<=2; j++) {\n        for (int i=-2; i<=2; i++) {\n            vec2 g = vec2(float(i),float(j));\n            vec3 o = hash3(p + g)*vec3(u,u,1.0);\n            vec2 r = g - f + o.xy;\n            float d = dot(r,r);\n            float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n            va += o.z*ww;\n            wt += ww;\n        }\n    }\n\n    return va/wt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    st *= 10.;\n    st.y *= 1.;\n    float n = 0.;\n    float k = 0.;\n    \n    for(float i = 0.; i < octaves; i++){\n        \n    \tk += iqnoise((st + sin(iTime)/2.)*pow(2., i), sin(iTime)*0.5 + 0.5, .2)/pow(2., i);\n        n += iqnoise((st + sin(iTime)/2.)*pow(2., i), sin(iTime)*0.5 + 0.5, 1.)/pow(2., i);\n        //k += iqnoise(st*pow(2., i), 1., .2)/pow(2., i);\n        //n += iqnoise(st*pow(2., i), 1., 1.)/pow(2., i);\n    }\n    n /= 2.;\n    k /= 2.;\n    \n    k *= pow(n, 2.);\n    \n    fragColor = vec4(vec3(n, k, .0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBfDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 213, 235, 235, 444], [446, 446, 492, 492, 1007], [1009, 1009, 1066, 1066, 1705]], "test": "untested"}
{"id": "XtBfzc", "name": "sRGB Experiment", "author": "battlebottle", "description": "Testing out sRGB conversion algorithm.\n\nUse the mouse to adjust the brightness of the bands of colour.", "tags": ["srgb"], "likes": 3, "viewed": 436, "published": "Public API", "date": "1516657268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float SRGB_GAMMA = 1.0 / 2.2;\nconst float SRGB_INVERSE_GAMMA = 2.2;\nconst float SRGB_ALPHA = 0.055;\n\n\nfloat linear_to_srgb(float channel) {\n    if(channel <= 0.0031308)\n        return 12.92 * channel;\n    else\n        return (1.0 + SRGB_ALPHA) * pow(channel, 1.0/2.4) - SRGB_ALPHA;\n}\n    \n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float col = uv.y;\n    \n    if (iMouse.z > 0.0) {\n    \tcol = iMouse.x / iResolution.x;\n    } else {\n        col = mod(iTime / 6.0, 1.0);\n    }\n    //if (uv.x > 5.5/6.0 && uv.y > 0.05){\n    //    col = 1.0;\n    //}\n    \n    \n    float colSection = floor((1.0 - (uv.y - (20.0 / iResolution.y)) / ((iResolution.y - 20.0) / iResolution.y)) * 8.0);\n   \tvec3 multCol = vec3(1.0);\n    if (colSection == 0.0) {\n        multCol = vec3(1.0, 0.0, 0.0);\n    } else if (colSection == 1.0) {\n        multCol = vec3(0.0, 1.0, 0.0);\n    } else if (colSection == 2.0) {\n        multCol = vec3(0.0, 0.0, 1.0);\n    \n    } else if (colSection == 3.0) {\n        multCol = vec3(0.0, 1.0, 1.0);\n    } else if (colSection == 4.0) {\n        multCol = vec3(1.0, 0.0, 1.0);\n    } else if (colSection == 5.0) {\n        multCol = vec3(1.0, 1.0, 0.0);\n    } else if (colSection == 6.0) {\n        multCol = vec3(0.0, 0.0, 0.0);\n    }\n    \n    \n    \n    vec4 black = vec4(vec3(0.0),1.0);\n    vec4 white = vec4(vec3(1.0),1.0);\n    vec4 gray = vec4(vec3(0.5),1.0);\n    \n    if (fragCoord.y < 20.0) {\n        if (col > uv.x) {\n\t\t\tfragColor = black;\n        } else {\n            if (mod((linear_to_srgb(uv.x)) * 256.0, 2.0) > 1.0) {\n            //if (mod((1.0 - linear_to_srgb(1.0 - uv.x)) * 256.0, 2.0) > 1.0) {\n            //if (mod(uv.x * 256.0, 2.0) > 1.0) {\n\t\t\t\tfragColor = white;\n            } else {\n\t\t\t\tfragColor = gray;\n            }\n        }\n    } else{\n    \n    \tif (uv.x < 1.0/5.0) {\n\t\t\tfragColor = vec4(col * multCol,1.0);\n        } else if (uv.x >= 2.0/5.0 && uv.x < 3.0 / 5.0) {\n            fragColor =  vec4(pow(col * multCol, vec3(SRGB_GAMMA)), 1.0);\n        } else if (uv.x >= 4.0/5.0) {\n            \n            vec3 srgbCol = vec3(linear_to_srgb(col * multCol.r), linear_to_srgb(col * multCol.g), linear_to_srgb(col * multCol.b));\n\t\t\tfragColor = vec4(srgbCol,1.0);\n        } else  {\n            \n            vec4 noise1 = texture(iChannel1, uv * (iResolution.xy / vec2(256.0)));\n            float noise =  noise1.r * (255.0/256.0) + noise1.g / 256.0;\n            if (noise >= col ) {\n\t\t\t\tfragColor = black;\n    \t    } else {\n\t\t\t\tfragColor = vec4(multCol,1.0);;\n    \t    }\n    \t} \n\t}\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBfzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 146, 146, 290], [303, 303, 360, 360, 2580]], "test": "untested"}
{"id": "XtBfzw", "name": "Simple Snow", "author": "selim", "description": "Snow from: http://www.glslsandbox.com/e#36547.0", "tags": ["snow"], "likes": 7, "viewed": 574, "published": "Public", "date": "1514972485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float snow(vec2 uv,float scale)\n{\n\tfloat w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\n\tuv+=iTime/scale;uv.y+=iTime*2./scale;uv.x+=sin(uv.y+iTime*.5)/scale;\n\tuv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\n\tp=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n    \treturn k*w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv=(gl_FragCoord.xy*2.-iResolution.xy)/min(iResolution.x,iResolution.y); \n\tvec3 finalColor=vec3(0);\n\tfloat c=smoothstep(1.,0.3,clamp(uv.y*.3+.8,0.,.75));\n\tc+=snow(uv,30.)*.3;\n\tc+=snow(uv,20.)*.5;\n\tc+=snow(uv,15.)*.8;\n\tc+=snow(uv,10.);\n\tc+=snow(uv,8.);\n\tc+=snow(uv,6.);\n\tc+=snow(uv,5.);\n\tfinalColor=(vec3(c));\n\tfragColor = vec4(vec3(c),1);\n    \n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBfzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 367], [369, 369, 426, 426, 790]], "test": "untested"}
{"id": "XtjBWm", "name": "Torus_Thingy_10", "author": "balkhan", "description": " ", "tags": ["torus"], "likes": 6, "viewed": 133, "published": "Public", "date": "1516065815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t400.\n#define E\t\t\t0.00001\n#define FAR\t\t\t50.\n#define PI\t\t\t3.14\n\n// noises taken from : https://www.shadertoy.com/view/4djSRW\n\n// -------------noise--------------------- //\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1, .05030, -.0973)\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n// -------------noise--------------------- //\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    pos.z = 4.5+1.5*sin(t*10.);    \n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y < FAR)\n    col.xyz = ret_col*(1.-inter.x*.00125);\n    col += .5*blackbody(3000.*length(h.x+h.y+h.z)*.005125);\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    p.z += 10.;\n    \n    rotate(p.xz, 1.57-.5*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    var = atan(p.x,p.y);\n    vec2 q = vec2( ( length(p.xy) )-6.,p.z);\n    var = sin(floor(sin(atan(p.x, p.y)*4.+iTime*2.)*3.14 + 3.14*sin(floor(atan(q.x, q.y)*4. + iTime*5.) + ((iTime*1.1))*.8 ) ));//+sin(floor(atan(p.x, p.y)*4. +floor(iTime*10.1)*.1 ) );\n    var = ( hash11(sin(var*1.) ) );\n    float\toldvar = 5.1;//var;\n    ret_col = 1.-vec3(.350, .2, .3);\n    ret_col = .5*hash31(sin(var*1.) );\n    mind = length(q)-2.-var*.25;\n    h -= .8-ret_col*.125/(.0251+mind*mind);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n            // log trick by aiekick\n\t        if (log(dist.y*dist.y/dist.x/1e5) > .0 || dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjBWm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[426, 542, 565, 565, 683], [685, 685, 707, 707, 825], [985, 1207, 1235, 1235, 1560], [1562, 1609, 1652, 1652, 2066], [2068, 2068, 2089, 2089, 2718], [2720, 2720, 2752, 2752, 3237], [3239, 3253, 3293, 3293, 3368], [3370, 3370, 3392, 3392, 3598]], "test": "untested"}
{"id": "XtjfDw", "name": "Pattern15012018", "author": "edapx", "description": "pattern flower", "tags": ["flower", "pattern"], "likes": 0, "viewed": 53, "published": "Public", "date": "1516108171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n\n// Utilities\nfloat strokeSmoot(float x, float pos, float width){\n  return smoothstep(pos, pos+0.01,x+ width*0.5) -\n         smoothstep(pos, pos+0.01,x- width*0.5);\n}\n\nfloat circle(vec2 st, float diameter){\n  return length(st - 0.5) * diameter;\n}\n\nfloat flip(float v, float pct){\n  return mix(v, 1. - v, pct);\n}\n\nfloat fill(float sdfVal, float size){\n  return smoothstep(size, size+0.02,sdfVal);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat quadrifoglio (vec2 st, float diameter, float utime, float speed, float tickness){\n  float time = utime * speed;\n  float offset = .25;\n  float cross = 2.1;\n  float petalsDist = .24;\n  float petalsThickA = -.019 + abs(cos(time * 9.) * tickness);// .5\n  float petalsThickB = -.019 + abs(sin(time * 4.5) * tickness);// .5\n  \n  float center = circle(st, diameter);\n\n  vec2 petAcen = st-vec2(offset, offset);\n  float radiusA = length(petAcen);\n  float petA = circle(petAcen,radiusA*cross);\n\n  vec2 petBcen = rotate2d(TWO_PI/4.) * petAcen;\n  petBcen -= vec2(0., -.5);\n  float radiusB = length(petBcen);\n  float petB = circle(petBcen,radiusB*cross);\n\n  float petals = strokeSmoot(petA, petalsDist,petalsThickA);\n  petals += strokeSmoot(petB, petalsDist,petalsThickB);\n\n  float color = flip(petals,\n                fill(center, .155));\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 bgCol = vec3(0.049,0.398,0.905);\n    vec3 fCol = vec3(0.905,0.283,0.046);\n    float timeFreq = 0.7;\n    float timeAmp = 1.2;\n    float zoom = 2.;\n    float thick = 0.1;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    // tiling\n    st.x *= iResolution.x/iResolution.y;\n    st *=zoom;\n    // offset\n    st.x += step(1.0, mod(st.y,2.0)) * 0.5;\n    st = fract(st);\n    \n    // Movement\n    float mov = sin(mod(st.x, 2.7));\n    float ampMov = 4.;\n\n    float draw = quadrifoglio(\n      st, 1.9,\n      sin(iTime*timeFreq)*timeAmp,\n      (mov*ampMov),\n      thick);\n    vec3 col = mix(fCol, bgCol, draw);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjfDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 91, 142, 142, 243], [245, 245, 283, 283, 323], [325, 325, 356, 356, 388], [390, 390, 427, 427, 474], [476, 476, 504, 504, 590], [592, 592, 679, 679, 1442], [1445, 1445, 1501, 1501, 2139]], "test": "untested"}
{"id": "XtjfDy", "name": "polar 3b ( 225 chars )", "author": "FabriceNeyret2", "description": "NB: #7 :     cos(  .3 * floor     for longer rainbows", "tags": ["2tweets", "short", "golfing"], "likes": 6, "viewed": 3014, "published": "Public API", "date": "1517051308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/lt2Bzd\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 U = u+u - iResolution.xy;\n    float T = 6.2832, l = length(U) / 30., L = ceil(l) * 6.,\n          a = atan(U.x,U.y) - iTime * 2.*(fract(1e4*sin(L))-.5);\n    O = .6 + .4* cos( floor(fract(a/T)*L) + vec4(0,23,21,0) )\n        - max(0., 9.* max( cos(T*l), cos(a*L) ) - 8. ); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjfDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 85, 85, 366]], "test": "untested"}
{"id": "XtjfRd", "name": "Doble Random Pattern", "author": "jpupper", "description": "Modifing the random pattern of the book of shaders to accoplish this", "tags": ["randomnoiseboxpattern"], "likes": 4, "viewed": 113, "published": "Public", "date": "1516860273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159235659\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    vec2 p  = vec2(0.5)-uv;\n\tfloat time = iTime;\n    float a = atan(p.x,p.y);\n    float rad  = length(p);\n    uv-=0.5;\n    \n    float sp=0.5;\n    //uv*=abs(sin(time*sp))*50.+20;\n    uv*=10.;\n\n    float def = abs(cos(a+time+sin(rad*PI*1000000000.)))*(abs(cos(time*sp))*0.3+0.2);\n    \n    vec2 p2 = vec2(uv.x*cos(def),uv.y*cos(def));\n    vec2 ipos = floor(p2);\n    vec2 fpos = fract(p2);\n\n    float rand = sin(random(ipos)*time);\n    \n    \n    float rand2 = cos(random(ipos)*time);\n    \n    fpos -=0.5;\n    float fa = atan(fpos.x,fpos.y);\n    float frad = length(fpos);\n    fpos+=0.5;\n    \n    float e = rand;\n    float e2 = rand2;\n    \n    \n    float r = e;\n    float g = smoothstep(0.7,0.8,e)*abs(sin(frad+time))*rand2;\n    float b = r*g+sin(e*2.+sin(frad*PI+sin(fa*5.+time)*0.1))*1.+0.4;\n    r=1.;\n    g=1.;\n    b=1.;\n\n    vec3 col = hsb2rgb(vec3(r,g,b));\n    col = vec3(0.7,0.3,0.5)*e+vec3(0.5,0.2,0.5)*e2;\n    \n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjfRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 50, 50, 157], [159, 159, 185, 185, 417], [420, 420, 477, 477, 1472]], "test": "untested"}
{"id": "XtjfzD", "name": "Analytic Single Scattering", "author": "greje656", "description": "A closed form solution for a simple point light in an isotropic homogeneous volume. The solution for the integral is described in this awesome paper by Vincent Pegoraro:\nhttp://www.cs.utah.edu/~vpegorar/research/2009_EG/paper.pdf", "tags": ["analytic", "singlescattering", "closedform"], "likes": 45, "viewed": 1938, "published": "Public", "date": "1514867785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI4 12.5663706144\n#define ks 0.05\n#define kt ks\n#define I 10.0\n#define light_color vec3(1.000, 0.778, 0.620)\n#define TONEMAP\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat I0(float a, float va, float vb) {\n\tconst int maxIterations = 3; // Enough precision for the current scene\n\n\tfloat pva = sqrt(a * a * (va * va + 1.0));\n\tfloat pvb = sqrt(a * a * (vb * vb + 1.0));\n\tfloat ova = atan(a, a * va);\n\tfloat ovb = atan(a, a * vb);\n\tfloat sina = sin(a);\n\tfloat cosa = cos(a);\n\tfloat logv = log(pvb / pva);\n\tfloat phiv = ovb - ova;\n\tfloat I0 = sina * logv - cosa * phiv;\n\n\tfloat kfac = 1.0;\n\tfloat pkva = 1.0;\n\tfloat pkvb = 1.0;\n\tfor (int k = 1; k <= maxIterations; k++) {\n        float kf = float(k);\n\t\tkfac *= kf;\n\t\tpkva *= pva;\n\t\tpkvb *= pvb;\n\t\tfloat okva = a - kf * ova;\n\t\tfloat okvb = a - kf * ovb;\n\t\tfloat denom = 1.0 / (kf * kfac);\n\t\tI0 += (pkvb * sin(okvb) - pkva * sin(okva)) * denom;\n\t}\n\treturn I0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord.xy / iResolution.xy;\n\tvec2 ndc = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1);\n\tvec3 O   = vec3( 0.0, 0.0, -2.0 );\n    vec3 NP  = vec3(ndc.xy, 0.0);\n\tvec3 V   = normalize(NP - O);\n\n\tvec3 Lp  = vec3( sin(iTime) * 2.0, 0.0, cos(iTime) + 2.0);\n\tvec3 Xa  = O;\n\n\tvec3 P0  = vec3( 0.0, 0.0, 5.0 );\n\tvec3 N0  = vec3( 0.0, 0.0,-1.0 );\n\tvec3 P1  = vec3( 0.0,-2.0, 0.0 );\n\tvec3 N1  = vec3( 0.0, 1.0, 0.0 );\n\n    float ti = dot(P0 - Xa, N0) / dot(V, N0);\n\tfloat tf = dot(P1 - Xa, N1) / dot(V, N1);\n\n    vec3 Xb  = Xa + V * ti;\n\tvec3 Xf  = Xa + V * tf;\n    \n    float Lt = 0.0;\n\n\tif (tf > 0.0) {\n\t\tfloat d = length(Lp - Xf);\n\t\tvec3 L = normalize(Lp - Xf);\n\t\tLt = I * (exp(-kt * d)/(d*d)) * dot(L, N1) * 0.35; // Grey floor\n\t}\n\n    float mousex = iMouse.z < 0.01 ? 0.5 : iMouse.x/iResolution.x;\n    if(fragCoord.x > (iResolution.x*mousex) && fragCoord.x < (iResolution.x*mousex + 1.5)){\n        fragColor = vec4(0.1, 0.1, 0.1,1.0);\n        return;\n    }\n    \n    if (uv.x < mousex) {\n\t\t// Raymarch...\n\t\tconst int num_steps = 50;\n\t\tfloat total_travel_distance = length(Xb - Xa);\n\t\tfloat sample_width = total_travel_distance / float(num_steps);\n\t\tfloat random_offset = noise(vec3(uv * 1000.0, iTime * 10.0));\n\t\tfor (int i = 0; i < num_steps; ++i) {\n\t\t\tfloat nd = float(i) / float(num_steps);\n\t\t\tfloat distance_travelled = nd * total_travel_distance + random_offset * sample_width;\n\t\t\tvec3 X = Xa + V * distance_travelled;\n\t\t\tfloat d = length(Lp - X);\n\t\t\tfloat Li = I / PI4 * (exp(-kt * d) / (d * d));\n\t\t\tLt += exp(-kt*distance_travelled) * (ks*Li) * sample_width;\n\t\t}\n    } else {\n\t\t// Closed Form...\n\t\tvec3 Xh = Xa + (dot(Lp - Xa, V) / dot(V, V)) * V;\n\t\tfloat h = length(Xh - Lp);\n\t\tfloat H = kt * h;\n        float XaXh = length(Xa - Xh);\n        float XbXh = length(Xb - Xh);\n\t\tfloat Va = (-XaXh / h) + sqrt(1.0 + pow(XaXh / h, 2.0));\n\t\tfloat Vb = ( XbXh / h) + sqrt(1.0 + pow(XbXh / h, 2.0));\n\t\tfloat i0 = I0(-H, Va, Vb);\n\t\tLt += I * (ks / h) * exp(-kt * XaXh) * (2.0 / PI4) * i0;\n    }\n\n    Lt = pow(Lt, 1.0/2.2);\n    vec3 color = (Lt * light_color);\n    #if defined(TONEMAP)\n    \tcolor = ACESFilm(color);\n    #endif\n    \n\tfragColor = vec4(color.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 218, 241, 241, 380], [382, 428, 448, 448, 543], [545, 545, 569, 569, 1043], [1045, 1045, 1084, 1084, 1783], [1785, 1785, 1842, 1842, 4027]], "test": "untested"}
{"id": "XtSBRK", "name": "Mandala elevator", "author": "Flopine", "description": "Training training training !", "tags": ["raymarching", "mandala"], "likes": 6, "viewed": 226, "published": "Public", "date": "1516386924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind and leon for teaching me!\n\n#define PI 3.14\n\nmat2 rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\nvec2 moda (vec2 p, float per)\n{\n    float angle = atan(p.y,p.x);\n    float l = length(p);\n    angle = mod(angle-per/2.,per)-per/2.;\n    return vec2 (cos(angle),sin(angle))*l;\n}\n\nfloat cylY (vec3 p, float r)\n{\n    return length(p.xz)-r;\n}\n\nfloat cylZ (vec3 p, float r)\n{\n    return length(p.xy)-r;\n}\n\n\nfloat base (vec3 p)\n{   \n    p.xy *= rot(abs(p.z)-iTime);\n    p.xy = moda(p.xy,2.*PI/3.);\n    p.x -= 0.4;\n\n    return cylZ(p,0.2);\n}\n\n\nfloat prim(vec3 p)\n{\n    p.xz = moda(p.xz, 2.*PI/7.);\n    p.x -= 4.;\n    return base(p);\n}\n\nfloat elevator (vec3 p)\n{\n    float per = 8.;\n    p.yz = mod (p.yz-per/2.,per)-per/2.;\n    float rep1 = prim(p);\n    \n    float per2 = 15.;\n    p.yz *= rot(PI/2.);\n     p.x = mod (p.x-per2/2.,per2)-per2/2.;\n    float rep2 = prim(p);\n    \n    return min(rep1,rep2);\n}\n\nfloat background (vec3 p)\n{\t\n    float per = 5.;\n    p.yz *= rot(PI/2.);\n    p.x = mod (p.x-per/2.,per)-per/2.;\n    return prim(p);\n}\n\nfloat SDF(vec3 p)\n{\n    return min(elevator(p), background(p));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy)-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = vec3 (-.001,iTime,-3.);\n    vec3 dir = normalize(vec3(uv,1.));\n    \n    float shad = 0.;\n    vec3 color = vec3 (0.);\n    \n    for (int i=0; i<100;i++)\n    {\n        float d = elevator(p);\n        if (d<0.01)\n        {\n            shad = float(i)/80.;\n           break;\n        }\n        else shad = .0;\n        p+=d*0.2*dir;\n    }\n    color = vec3(shad)*vec3(0.8,p.z,abs(p.x*0.5));\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSBRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 83, 106, 106, 187], [189, 189, 220, 220, 365], [367, 367, 397, 397, 426], [428, 428, 458, 458, 487], [490, 490, 511, 511, 622], [625, 625, 645, 645, 715], [717, 717, 742, 742, 983], [985, 985, 1012, 1012, 1118], [1120, 1120, 1139, 1139, 1185], [1189, 1189, 1246, 1246, 1769]], "test": "untested"}
{"id": "XtSBWD", "name": "10/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I tried out some subsurface scattering method. I played with these in the past (2016?) but never got a good result. So now it is better. Enjoy the snowperson! :D", "tags": ["subsurfacescattering", "dailyshader"], "likes": 7, "viewed": 286, "published": "Public", "date": "1515712739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 48\n#define PIXELR 0.5/iResolution.x\n#define FAR 50.0\n\n#define PI 3.14159265\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n#define HASHSCALE1 0.1031\n\nconst vec3 FOG_COLOR = vec3(0.5, 0.55, 0.65);\n\n//Distance functions and helpper functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a){\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.0);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\nfloat cosNoise(vec2 p){\n    return 0.5*(sin(p.x) + sin(p.y));\n}\n\nfloat sdf(vec3 p){\n    \n    float sphere = fSphere(p-vec3(0.0, 0.0, 0.0), 2.0);\n    sphere = fOpUnionSoft(sphere, fSphere(p-vec3(0.0, 2.0, 0.0), 1.5), 0.5);\n    sphere = fOpUnionSoft(sphere, fSphere(p-vec3(0.0, 4.0, 0.0), 1.0), 0.25);\n    \n    //For the ground distortion I have taken some inspiration from here:\n    //https://www.shadertoy.com/view/XlSSzK\n    float h = 0.0;\n    vec2 q = p.xz*0.5;\n    float s = 0.5;\n    \n    const mat2 m2 = mat2(1.,-1.,1., 0.5);\n    \n    for(int i = 0; i < 6; ++i){\n        h += s*cosNoise(q); \n        q = m2*q*0.8; \n        q += vec2(2.41,8.13);\n        s *= 0.52 + 0.2*h;\n    }\n    h *= 1.2;\n    \n    float ground = fPlane(p, vec3(0.,1.,0.), 1.)-h;\n    return fOpUnionSoft(ground, sphere, 1.0);\n}\n\n//calculate normals for objects\nvec3 normals(vec3 p){\n\tvec3 eps = vec3(PIXELR, 0.0, 0.0 );\n    return normalize(vec3(\n        sdf(p+eps.xyy) - sdf(p-eps.xyy),\n        sdf(p+eps.yxy) - sdf(p-eps.yxy),\n        sdf(p+eps.yyx) - sdf(p-eps.yyx)\n    ));\n}\n\n//Ambient occlusion method from https://www.shadertoy.com/view/4sdGWN\n//Random number [0:1] without sine\nfloat hash(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 32;\n    const float nbIteInv = 1.0/float(nbIte);\n    const float rad = 1.0-1.0*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(sdf( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n//Subsurface scattering method inspired from noby\n//Example implementation in https://www.shadertoy.com/view/lllBDM\nfloat subsurfaceScattering(vec3 p, vec3 rd, vec3 n){\n    vec3 d = refract(rd, n, 1.31);\n    vec3 pos = p;\n    float thickness = 0.0;\n    const float max_scatter = 2.0;\n    for(float i = 0.1; i < max_scatter; i += 0.2){\n        pos += i*d;\n        float t = sdf(pos);\n        thickness += t;\n    }\n    thickness = max(0.0, -thickness);\n    float scatter= pow(ambientOcclusion(p, -normals(p), 4.0, 2.0), -0.5);\n    return scatter*min(max_scatter, 2.2/thickness);\n}\n\nvec3 colorify(vec3 p, vec3 rd, vec3 ro, vec3 ld, vec3 lc){\n    vec3 n = normals(p);\n    vec3 h = normalize(ld + rd);\n    \n    float angle = max(dot(reflect(-ld, n), rd), 0.0);\n    float spec = pow(angle, 10.0);\n    \n    float lamb = max(0.0, dot(n, ld));\n    float ss = max(0.0, subsurfaceScattering(p, rd, n));\n    lamb = smoothstep(0.0, 0.5, pow(ss, 0.6));\n\n    float fresnel = pow( max(0.0, 1.0+dot(n, rd)), 1.31 );\n    \n    vec3 cc = lc*(ambientOcclusion(p, n, 4.0, 1.0)) + \n        vec3(0.7, 0.7, 0.65)*lamb + vec3(0.6, 0.6, 0.7)*spec +\n        fresnel*FOG_COLOR;\n\n\treturn cc;\n}\n\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld, vec3 lc){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot( rd, ld ), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.065);\n\tvec3  fogColor = mix(FOG_COLOR, lc, pow(sunAmount, 4.0));\n    return mix(col, fogColor, fogAmount);\n}\n\n//Enhanced sphere tracing algorithm introduced by Mercury\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.001;//EPSILON;\n    float step = 0.0;\n\n    float omega = 1.2;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(sdf(ro));\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*sdf(p);\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*sdf(p));\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(10.0*cos(iTime*0.1), 3.5+sin(iTime*0.05), 12.0*sin(iTime*0.1));\n    vec3 rt = vec3(0.0, 2.5, 0.0);\n    \n    //vec3 ro = vec3(0.0, 0.0, -4.0);\n    //vec3 rt = vec3(0.0, -2.0, 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(90.0)));\n    \n    vec3 ld = (rt-ro)/distance(ro, rt);\n    vec3 ld2 = (rt-vec3(0.0, -2.0, -6.0))/distance(vec3(0.0, -2.0, -6.0), rt);\n    \n    \n    vec3 lcol = vec3(0.7, 0.65, 0.5);\n    vec3 lcol2 = vec3(0.85, 0.75, 0.8);\n    vec3 col = FOG_COLOR;\n    \n    float t = march(ro, rd);\n\tvec3 p = rd*t+ro;\n    \n    if(t <= FAR){\n\t\tcol = colorify(p, rd, ro, ld, lcol) + \n            colorify(p, rd, ro, ld2, lcol2);\n        col *= 0.5;\n\t}\n    \n    vec3 fg = fog(col, p, ro, rd, ld, lcol) +\n\t\tfog(col, p, ro, rd, ld2, lcol2);\n\tcol = fg*0.5;\n    \n    //Vigenting\n    float vigentOffset = 0.005;\n    float darkness = 0.5;\n\tfloat dist = distance(uv, vec2( 0.5 ));\n\tcol *= smoothstep(0.8, vigentOffset * 0.799, dist *( darkness + vigentOffset ));\n    \n    \n    col = pow(col, 1.0/vec3(2.2));\n\tfragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSBWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 339, 359, 359, 389], [391, 391, 423, 423, 448], [450, 524, 580, 580, 622], [625, 863, 894, 894, 936], [938, 974, 999, 999, 1039], [1042, 1230, 1277, 1277, 1348], [1350, 1350, 1373, 1373, 1413], [1415, 1415, 1433, 1433, 2150], [2152, 2184, 2205, 2205, 2401], [2403, 2508, 2528, 2528, 2646], [2648, 2648, 2679, 2679, 2782], [2783, 2783, 2827, 2827, 2919], [2921, 2921, 3004, 3004, 3551], [3554, 3670, 3722, 3722, 4132], [4134, 4134, 4192, 4192, 4717], [4719, 4719, 4782, 4782, 5006], [5008, 5066, 5096, 5096, 6261], [6263, 6263, 6319, 6319, 7624]], "test": "untested"}
{"id": "XtSBWh", "name": "7/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge.\n\nToday I tried out ambient occlusion method from https://www.shadertoy.com/view/4sdGWN . I'm not quite sure if I got it working right with deformed marched plane. But at least the outcome looks nice.", "tags": ["landscape", "dailyshader"], "likes": 10, "viewed": 366, "published": "Public", "date": "1515459863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64\n#define FAR 60.0\n#define EPSILON 0.5/iResolution.x\n\n#define HASHSCALE1 0.1031\n\nconst float PI = 3.14159265359;\n\n//Distance functions and helpper functions from Mercury's SDF library\n//http://mercury.sexy/hg_sdf/\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x < 0.0)?-1.0:1.0;\n}\n\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat dist(vec3 p){\n    float plane = fPlane(p, vec3(0.0, 1.0, 0.0), 1.0)-\n        smoothstep(0.0, 1.0, noise(p*(sqrt(5.0)*0.5 + 0.5)*0.2+iTime*0.25));\n    return plane;\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        dist(p+eps.xyy)-dist(p-eps.xyy),\n        dist(p+eps.yxy)-dist(p-eps.yxy),\n        dist(p+eps.yyx)-dist(p-eps.yyx)\n    ));\n}\n\n//Ambient occlusion method from https://www.shadertoy.com/view/4sdGWN\n//Random number [0:1] without sine\nfloat hash(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(dist( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n\n//Fog introduced in http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot( rd, ld ), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.015);\n\tvec3  fogColor = mix(vec3(0.2, 0.4, 0.5), vec3(0.64, 0.62, 0.6), pow(sunAmount, 2.0));\n    return mix(col, fogColor, fogAmount);\n}\n\nvec3 shade(vec3 p){\n    \n    vec3 n = normals(p);\n    vec3 col = vec3(0.6, 0.4, 0.64);\n    col *= ambientOcclusion(p, n, 4.0, 1.0);\n    col *= ambientOcclusion(p+vec3(EPSILON, 0.0, 0.0), n, 8.0, 1.0);\n    \n    return col;\n}\n\n\n//Enhanced sphere tracing algorithm introduced by Mercury\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.001;\n    float step = 0.0;\n\n    float omega = 1.0;//muista testata eri arvoilla! [1,2]\n    float prev_radius = 0.0;\n\n    float candidate_t = t;\n    float candidate_error = 1000.0;\n    float sg = sgn(dist(ro));\n\n    vec3 p = vec3(0.0);\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tp = rd*t+ro;\n\t\tfloat sg_radius = sg*dist(p);\n\t\tfloat radius = abs(sg_radius);\n\t\tstep = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < step;\n\t\tif(fail){\n\t\t\tstep -= omega * step;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\tstep = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < EPSILON || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += step;\n\t}\n    //discontinuity reduction\n    float er = candidate_error;\n    for(int j = 0; j < 6; ++j){\n        float radius = abs(sg*dist(p));\n        p += rd*(radius-er);\n        t = length(p-ro);\n        er = radius/t;\n\n        if(er < candidate_error){\n            candidate_t = t;\n            candidate_error = er;\n        }\n    }\n\tif(t <= FAR || candidate_error <= EPSILON){\n\t\tt = candidate_t;\n\t}\n\treturn t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 1.5, -3.0);\n    vec3 rt = vec3(0.0, 1.25, 3.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    \n    vec3 rd = mat3(x, y, z)*vec3(q, radians(90.0));\n    vec3 ld = z;\n    \n    float t = march(ro, rd);\n    vec3 p = ro+rd*t;\n\n    vec3 col = vec3(0.0);\n    if(t <= FAR && t > EPSILON){\n        col = shade(p);\n\t}\n    \n    col = smoothstep(-0.1, 1.2, fog(col, p, ro, rd, ld));\n    \n    col = pow(smoothstep(0.08, 1.1, col)*smoothstep(0.8, 0.005*0.799,\n        distance(uv, vec2(0.5))*(0.8 + 0.005)), 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSBWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 269, 289, 289, 319], [322, 396, 452, 452, 494], [496, 522, 542, 542, 821], [823, 823, 842, 842, 994], [996, 996, 1017, 1017, 1214], [1216, 1321, 1341, 1341, 1459], [1461, 1461, 1492, 1492, 1595], [1596, 1596, 1640, 1640, 1732], [1734, 1734, 1817, 1817, 2362], [2366, 2437, 2491, 2491, 2744], [2746, 2746, 2765, 2765, 2969], [2972, 3030, 3060, 3060, 4220], [4224, 4224, 4281, 4281, 5048]], "test": "untested"}
{"id": "XtSBzK", "name": "17/2018", "author": "rimina", "description": "This shader is part of my daily shader challenge. Today I tested some terrain marching implementation from iq's articles: http://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm", "tags": ["terrain", "dailyshader"], "likes": 4, "viewed": 155, "published": "Public", "date": "1516399178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 20.0\n#define EPSILON 0.01\n#define PI 3.14159265359\n#define PIXELR 0.5/iResolution.x\n\n#define FOG_COLOR vec3(0.55, 0.6, 0.75)\n#define SUN_COLOR vec3(0.64, 0.62, 0.6)\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 0.1031\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat dist(vec2 p){\n    return noise(p.xyx)+(sin(p.x)*sin(p.y*2.0)+1.0);\n}\n\n\n//Based on Iq's terrain marching article\n//http://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\nfloat march(in vec3 ro, in vec3 rd, out bool hit){\n    \n    float delta = EPSILON;\n    float lh = 0.0;\n    float ly = 0.0;\n    float t = 0.0;\n    for(float i = EPSILON; i < STEPS; i += delta){\n        vec3 p = ro+rd*i;\n        float h = dist(p.xz);\n        if(p.y < h){\n            t = i-delta+delta*(lh-ly)/(p.y-ly-h+lh);\n            hit = true;\n            break;\n        }\n        delta = EPSILON*i;\n        lh = h;\n        ly = p.y;\n    }\n    \n    return t;\n}\n\nvec3 normals(vec3 p){\n    vec2 eps = vec2(PIXELR, 0.0);\n    return normalize(vec3(\n        dist(p.xz-eps.xy) - dist(p.xz+eps.xy),\n        2.0*eps.x,\n        dist(p.xz-eps.yx) - dist(p.xz+eps.yx)\n    ));\n}\n\n\n//Ambient occlusion method from https://www.shadertoy.com/view/4sdGWN\n//Random number [0:1] without sine from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(dist( p.xz + rd.xz ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nvec3 shade(vec3 p, vec3 rd, vec3 ld){\n    vec3 n = normals(p);\n    float lambertian = max(dot(n, ld), 0.0);\n    \n    vec3 color = vec3(0.5, 0.4, 0.65) * ambientOcclusion(p, n, 4.0, 2.0) +\n        lambertian*vec3(0.6, 0.6, 0.65);\n    \n    return color;\n}\n\n//Fog introduced in http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot( rd, ld ), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.28);\n\tvec3  fogColor = mix(FOG_COLOR, SUN_COLOR, pow(sunAmount, 2.0));\n    return mix(col, fogColor, fogAmount);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 2.0, iTime*0.5+1.0);\n    vec3 rt = vec3(0.0, 1.5, ro.z+10.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    \n    vec3 rd = normalize(mat3(x, y, z)*vec3(q, radians(70.0)));\n    vec3 ld = (rt-vec3(0.5, 2.0, 0.0))/distance(rt, vec3(0.5, 2.0, 0.0));\n    \n    bool hit = false;\n    float t = march(ro, rd, hit);\n    vec3 p = ro+rd*t;\n    \n    vec3 color = FOG_COLOR;\n    if(hit){\n        color = shade(p, rd, ld);\n    }\n    \n    color = fog(color, p, ro, rd, ld);\n    color = smoothstep(-0.3, 1.0, color);\n    \n    color = pow(smoothstep(0.08, 1.1, color)*smoothstep(0.8, 0.005*0.799,\n        distance(uv, vec2(0.5))*(0.8 + 0.005)), 1.0/vec3(2.2));\n        \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 290, 310, 310, 589], [591, 591, 610, 610, 665], [668, 786, 836, 836, 1249], [1251, 1251, 1272, 1272, 1455], [1458, 1606, 1626, 1626, 1744], [1746, 1746, 1777, 1777, 1880], [1881, 1881, 1925, 1925, 2017], [2019, 2019, 2102, 2102, 2653], [2656, 2656, 2693, 2693, 2909], [2911, 2982, 3036, 3036, 3266], [3269, 3269, 3326, 3326, 4234]], "test": "untested"}
{"id": "XtSfWW", "name": "Circle-Wave", "author": "smkgames", "description": "Simple wave", "tags": ["wave", "circle"], "likes": 1, "viewed": 152, "published": "Public", "date": "1515693247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float dt = sin(mod(length((uv - vec2(0.8, 0.5)) * 5.) - iTime, 3.14));\n\tfragColor =  vec4(step(dt,0.5));\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n    float circle = length(uv);\n    float dist = mod(iTime,3.);\n    float result = step(circle,0.2+dist)-step(circle,dist);\n\tfragColor = vec4(result);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSfWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 210]], "test": "untested"}
