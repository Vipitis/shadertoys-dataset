{"id": "4d33R8", "name": "one cube challenge (258)", "author": "iapafoto", "description": "Challenge: code golf (here) or propose alternate algorithm (with close result) separately (then, copy this rule and accept code-golfing). The winner is the smaller :-) ( but must adapt to window resolution )", "tags": ["cube", "2tweets"], "likes": 13, "viewed": 533, "published": "Public", "date": "1447881841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 258 char version (color and double rotation)\n\n#define M(c) length(max(abs(b)-c,0.))\n\nvoid mainImage(out vec4 O, vec2 p) {\n    float  C  = iTime, a=sin(C), d=cos(C);\n    mat3   u  = mat3(a,d*d,d*a,0,a,-d,-d,a*d,a*a);\n    vec3   b  = vec3(0,0,7)*u,\n           e  = .6*(.5-vec3(p/iResolution.y,2.))*u;\n    for(int i=0;i<99;i++) b+=e*max(.12-M(.9),a=M(1.));\n    O.rgb = a<1.?e*e:e-e;}\n\n\n\n// --------------------------------------------------------------\n// Fabrice 241 char version !!!\n// --------------------------------------------------------------\n/*\n#define M(k) length (max( abs(O.xyz*mat3(c,0,-s,0,1,0,s,0,c)) -k , 0. ))\n\nvoid mainImage(out vec4 O,vec2 p){\n    float C=iDate.w, s=sin(C), c=cos(C);\n    O  = vec4(2,0,7,0);\n    for(int i=0;i<99;i++) \n        O += .6*(.5-vec4(p/iResolution.y,2,0)) * max(.12-M(.9),C=M(1.));\n    O -= C + O++;\n}\n*/\n// --------------------------------------------------------------\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d33R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 124, 124, 383]], "test": "ok"}
{"id": "4d33z4", "name": "My first ShaderToy: Learning SDF", "author": "sagarpatel", "description": "Hacked on top of @cabbibo's awesome SDF tutorial ( https://www.shadertoy.com/view/Xl2XWt ) and uses funcs from IQ's SDF page (http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\nDid the tut + this on the bus ride from Ha Long Bay to Hanoi", "tags": ["sdf"], "likes": 11, "viewed": 1374, "published": "Public API", "date": "1448268262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @sagzorz\n// My first shader on ShaderToy!\n\n\n\n// The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n// https://www.shadertoy.com/view/Xl2XWt\n\n// I read thorugh it then looked at IQ's page on distance functions \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// got inspired and remixed stuff in really messy code\n// my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n// from Ha Long Bay to Hanoi and batteries were starting to run out :/\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iTime);\n    \n  // First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); //vec3( -1.3 , .3 , -0.4 );\n    \n  // than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); //sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  //vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); //box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; //0.001 + distanceToThingsInTheWorld * abs(sin(iTime)); //distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); //vec3( 0., 0.5, 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d33z4.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[15590, 15992, 16075, 16075, 16253], [16457, 16474, 16517, 16517, 17738], [17740, 17740, 17773, 17773, 17838], [17840, 17840, 17884, 17884, 18130], [18132, 18132, 18169, 18169, 18519], [18521, 18521, 18552, 18552, 18668], [18670, 18670, 18706, 18770, 18799], [18802, 18802, 18841, 18882, 19967], [19970, 20165, 20221, 20221, 20605], [20613, 20765, 20809, 20809, 21118], [22490, 22490, 22553, 22758, 27037], [27214, 27576, 27625, 27625, 28622], [28628, 28716, 28741, 28741, 28765], [28770, 28770, 28834, 28834, 29925], [29929, 29929, 29991, 29991, 31084], [31087, 31208, 31268, 31268, 31467], [31472, 31573, 31650, 31714, 33042], [33046, 33046, 33103, 33547, 36672]], "test": "ok"}
{"id": "4d3GRr", "name": "gnome lands", "author": "xdaimon", "description": "first shader ! :) this was a lot of fun. \nUses an effect from an android ndk sample.\nUses an idea from https://www.shadertoy.com/view/Mds3zn\nUses noise function from https://www.shadertoy.com/view/lsf3WH", "tags": ["sines", "gnomes", "lands"], "likes": 2, "viewed": 779, "published": "Public API", "date": "1447576863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = smoothstep(vec2(0), vec2(1), f); // similar to u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec4 color_at_uv(vec2 uv, vec2 p, float t)\n{    \n    vec2 rad_x = p - uv * vec2(172., 100.) * vec2(sin(t/10.),cos(t/10.)),\n         rad_y = p - uv * vec2(242., 163.);\n       \n    float ii = dot(sin(rad_x)+sin(rad_y), vec2(1));\n    // ii = abs(ii); // this is cool too.\n\n    vec4 a_col = vec4(.9, 1.,  1,1),\n         b_col = vec4(0, .75,  1,1),\n         c_col = vec4(0,  0,   1,1);\n    \n    float a_bool = step(1.,ii)    +step(.5, ii),\n          b_bool = step(2.*-abs(sin(t/5.)), ii),\n          c_bool = step(3.,                 ii);\n   \n    a_col *= a_bool;\n    b_col *= b_bool;\n    c_col *= c_bool;\n    \n    return a_col + b_col + c_col;\n}\n\n#define chromatic\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    //float t = 1.;\n    vec2 R = iResolution.xy,\n    \tuv = fragCoord.xy/R/7.,\n    \t p = t*(1.+iMouse.xy/R)/5.;\n    \n    // gnome tv\n    //float nse = 1.;\n\n    // gnome carousel\n    float nse = noise((uv+vec2(cos(t/50.), sin(t/50.)))*15.);\n    \n    // gnome family portrait\n    //float nse = noise((1. + abs(sin(t/50.)))*uv*25.);\n    \n    // gnome voyage\n    //float nse = noise((200.+t)*uv);\n    \n#ifdef chromatic\n    float shift = 1.;\n    shift = pow(shift, 3.);\n    shift *= .05;\n    \n    vec3 col;\n    col.r = color_at_uv(nse*(uv+shift), p, t).r;\n    col.g = color_at_uv(nse*(uv)      , p, t).g;\n    col.b = color_at_uv(nse*(uv-shift), p, t).b;\n    col *= (1. - shift * .5);\n\t\n    fragColor = vec4(col,1.);\n#else\n    fragColor = color_at_uv(nse*uv, p, t);\n#endif\n    \n    \n    // Look at the value noise\n    //if (iMouse.w < 0.)\n    //\treturn;\n    //fragColor = vec4(nse,nse,nse,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3GRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 114], [116, 116, 142, 142, 490], [492, 492, 536, 536, 1132], [1152, 1152, 1209, 1209, 2118]], "test": "ok"}
{"id": "4d3Gzn", "name": "Sound Experiment 5", "author": "aiekick", "description": "An attempt to colorize the [url=https://www.shadertoy.com/view/XscGRn]Sound Experiment 4[/url]", "tags": ["sound", "experiment", "5"], "likes": 5, "viewed": 1720, "published": "Public API", "date": "1447555521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// based on https://www.shadertoy.com/view/4ljSDt from gilesruscoe \n\nvec4 freq1, freq2, freq3;\n\nvec4 map(vec3 p)\n{   \n    p.xy += vec2(cos(p.z),sin(p.z));\n\t\n    float c = 1.0;\n\n    float cz = p.z, sz = p.z;\n    \n    cz += freq1.x; sz -= freq2.w;\n   \tfloat tube = length(p.xy + vec2(cos(cz),sin(sz))*.5);\n    vec4 res = vec4(tube, c, freq1.x, freq2.w);\n    \n\tcz += freq1.y; sz -= freq2.z;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.4));\n    if (tube < res.x) res = vec4(tube, c, freq1.y, freq2.z);\n        \n\tcz += freq1.z; sz -= freq2.y;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.3));\n    if (tube < res.x) res = vec4(tube, c, freq1.z, freq2.y);\n    \n\tcz += freq1.w; sz -= freq2.x;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.2));\n    if (tube < res.x) res = vec4(tube, c, freq1.w, freq2.x);\n    \n    \n    cz += freq3.x; sz -= freq1.w;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.1));\n    if (tube < res.x) res = vec4(tube, c, c, c);\n    \n\tcz += freq3.y; sz -= freq1.z;\n\ttube = min(tube, length(p.xy/* + vec2(cos(cz),sin(sz))*.0*/));\n    if (tube < res.x) res = vec4(tube, c, c, c);\n    \n\tcz += freq3.z; sz -= freq1.y;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.1));\n    if (tube < res.x) res = vec4(tube, c, c, c);\n    \n\tcz += freq3.w; sz -= freq1.x;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.2));\n    if (tube < res.x) res = vec4(tube, c, c, c);\n    \n    \n\tcz += freq2.x; sz -= freq3.w;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.3));\n    if (tube < res.x) res = vec4(tube, freq2.x, freq3.w, c);\n    \n\tcz += freq2.y; sz -= freq3.z;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.4));\n    if (tube < res.x) res = vec4(tube, freq2.y, freq3.z, c);\n    \n\tcz += freq2.z; sz -= freq3.y;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.5));\n    if (tube < res.x) res = vec4(tube, freq2.z, freq3.y, c);\n    \n\tcz += freq2.w; sz -= freq3.x;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.6));\n    if (tube < res.x) res = vec4(tube, freq2.w, freq3.x, c);\n    \n\treturn vec4(res.x - 0.05, res.yzw);\n}\n\nvec4 trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    vec4 d;\n    for (int i = 0; i < 60; ++i)\n    {\n        vec3 p = o + r * t;\n        d = map(p);\n        t += d.x * (d.x>0.05?0.5:0.1);\n    }\n    return vec4(t, d.yzw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from CubeScape : https://www.shadertoy.com/view/Msl3Rr\n    freq1.x = texture( iChannel0, vec2( 0.075, 0.25 ) ).x;\n\tfreq1.y = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreq1.z = texture( iChannel0, vec2( 0.225, 0.25 ) ).x;\n\tfreq1.w = texture( iChannel0, vec2( 0.3, 0.25 ) ).x;\n    \n    freq2.x = texture( iChannel0, vec2( 0.375, 0.25 ) ).x;\n\tfreq2.y = texture( iChannel0, vec2( 0.45, 0.25 ) ).x;\n\tfreq2.z = texture( iChannel0, vec2( 0.525, 0.25 ) ).x;\n\tfreq2.w = texture( iChannel0, vec2( 0.6, 0.25 ) ).x;\n    \n    freq3.x = texture( iChannel0, vec2( 0.675, 0.25 ) ).x;\n    freq3.y = texture( iChannel0, vec2( 0.75, 0.25 ) ).x;\n    freq3.z = texture( iChannel0, vec2( 0.825, 0.25 ) ).x;\n    freq3.w = texture( iChannel0, vec2( 0.9, 0.25 ) ).x;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 2.0));\n    \n    vec3 o = vec3(0.0, 0.0, iTime * 2.);\n    \n    vec4 t = trace(o, r);\n    \n    float fog = 2. / (1. + t.x * t.x * 0.1);\n    \n\tfragColor = vec4(fog * t.yzw, 1.);\n}\n\n", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3Gzn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[234, 234, 252, 252, 2239], [2241, 2241, 2269, 2269, 2461], [2463, 2463, 2520, 2582, 3612]], "test": "error"}
{"id": "4dc3RH", "name": "Burning down", "author": "vcanaa", "description": "White paper burning from center", "tags": ["burn"], "likes": 3, "viewed": 222, "published": "Public", "date": "1447955271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvM = iMouse.xy / iResolution.xy;\n    vec4 o = texture(iChannel1, uv);\n    float noise = 1.0 - (o.x + o.y + o.z) / 3.0;\n    //float m = sqrt(pow(uvM.x - 0.5, 2.0) + \n    //           pow(uvM.y - 0.5, 2.0));\n    \n    float m = iTime / 50.0;\n    \n    float range = 0.1;\n    float s = smoothstep(m - range, m + range, sqrt(pow(uv.x - 0.5, 2.0) + pow(uv.y - 0.5, 2.0)));\n    float v = mix(noise, s, 0.55);\n    fragColor = vec4(1,1,1,1) * step(0.5, v);\n    \n    float cut = (1.0 - step(0.5, v) * step(-0.55, -v));\n    fragColor.y = fragColor.y * cut;\n    fragColor.z = fragColor.z * cut;\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 693]], "test": "error"}
{"id": "4dc3RN", "name": "Halloween2", "author": "H3LLbot", "description": "halloween2", "tags": ["halloween2"], "likes": 0, "viewed": 589, "published": "Public API", "date": "1448279652", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n\tfloat cameraX = 250.0 + 50.0 * cos(iTime * 2.0);\n    float cameraY = 150.0 + 10.0 * cos(iTime* 4.0);\n    float x = pixCoords.x - cameraX;\n    float y = pixCoords.y - cameraY;\n    \n    float distance1 = sqrt((x * x) + (y * y));\n    \n    float circle2X = -30.0;\n    float circle2Y = 10.0;\n    \n    float circle3X = 30.0;\n    float circle3Y = 10.0;\n    \n    float circle4X = -20.0;\n    float circle4Y = 5.0;\n    \n    float circle5X = 30.0;\n    float circle5Y = 5.0;\n\n    \n    float differenceX = x - circle2X;\n    float differenceY = y - circle2Y;\n    \n    float difference2X = x - circle3X;\n    float difference2Y = y - circle3Y;\n    \n    float difference4X = x - circle2X;\n    float difference4Y = y - circle2Y; \n    \n    float difference5X = x - circle5X;\n    float difference5Y = y - circle5Y; \n    \n    float distance2 = sqrt((differenceX * differenceX) + (differenceY * differenceY));\n    float distance3 = sqrt((difference2X * difference2X) + (difference2Y * difference2Y));\n    float distance4 = sqrt((difference4X * difference4X) + (difference4X * difference4X));\n    float distance5 = sqrt((difference5X * difference5X) + (difference5X * difference5X));\n    \n    if (y < (5.0 * cos((x + 100.0*iTime)/ 20.0)) - 50.0) {\n        color = vec4(0.2,0.2,0.2,1.0);\n        return;\n    }\n    \n\n    \n    // left eye\n    if (distance2 <20.0){\n        color = vec4(0.0,0.0,0.0,1.0);\n    } \n    \n     // background\n    else if (distance1 >70.0){\n        color = vec4(0.2,0.2,0.2,1.0);\n    }\n    \n     // right eye\n    else if (distance3 <20.0){\n        color = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    // bande gauche\n    else if (distance4 <20.0){\n        color = vec4(1.0,0.0,0.0,1.0);\n    }\n    \n    // bande droite\n    else if (distance5 <20.0){\n        color = vec4(1.0,0.0,0.0,1.0);\n    }\n    \n    // color ghost\n    else {\n        color = vec4(1.0,1.0,1.0,1.0); \n    }\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 1927]], "test": "ok"}
{"id": "4dc3zM", "name": "ripple shader test", "author": "shanemarks", "description": "ripple effect", "tags": ["ripple"], "likes": 5, "viewed": 410, "published": "Public", "date": "1448608090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float _Scale = 1.0;\n    float _Speed = 10.0;\n    float _Frequency = -45.0;\n   \n    vec2 mouseOffset =  iMouse.xy / iResolution.xy;\n     if (mouseOffset.x == 0.0 && mouseOffset.y == 0.0)\n    {\n        mouseOffset.x = 0.5;\n        mouseOffset.y = 0.5;\n    }\n    float amplitude = 1.0 - distance(fragCoord.xy / iResolution.xy,mouseOffset);\n    \n    \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n//\tuv = map (uv, vec2(0,0),vec2(1,1),vec2(-1,-1),vec2(1,1));\n    uv = 2.0*uv-1.0;\n    vec2 mouseOffsetMapped = 2.0 * mouseOffset - 1.0;\n    //float offset = ((uv.x-mouseOffsetMapped.x) *(uv.x-mouseOffsetMapped.x )) + ((uv.y - mouseOffsetMapped.y)*(uv.y  - mouseOffsetMapped.y));\n    //better written as:\n    float offset = length(uv-mouseOffsetMapped);\n    offset*=offset;\n    float value = _Scale * sin(iTime*_Speed+offset*_Frequency);\n    uv.y= value;\n\n    \n    uv.y= value * pow(amplitude,8.0);\n    fragColor = vec4(uv.y,uv.y,uv.y,1.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1002]], "test": "ok"}
{"id": "4dc3zr", "name": "Nixie Tube Digits", "author": "Flyguy", "description": "Some nixie tube like digits made of lines, arcs and circles.\nThe digits were designed in AutoCAD and converted to GLSL code using C# and netDxf.", "tags": ["text", "distance", "font", "digit", "nixie"], "likes": 67, "viewed": 2438, "published": "Public API", "date": "1447633262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n\t\n\tfloat n = iTime;\n\t\n\tfloat nsize = numberLength(n);\n\t\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumber(pos, n, uv));\n\t\n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 / (dist);\n\t\n\tcolor += vec3(1,0.2,0) * shade;\n    \n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = vec4( color , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 219, 264, 264, 442], [444, 480, 532, 532, 618], [620, 642, 717, 717, 1039], [1041, 1076, 1122, 1122, 3390], [3392, 3415, 3464, 3464, 3853], [3855, 3886, 3915, 3915, 3974], [3976, 3976, 4034, 4034, 4646]], "test": "ok"}
{"id": "4dcGzH", "name": "Fiber Optics", "author": "setphen", "description": "expanded upon https://www.shadertoy.com/view/MtB3zw", "tags": ["sinewave"], "likes": 4, "viewed": 146, "published": "Public", "date": "1447945033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 1.5;\nconst float widthFactor = 4.0;\n\nvec3 calcSine(vec2 uv, \n              float frequency, float amplitude, float shift, float offset,\n              vec3 color, float width, float exponent)\n{\n    float angle = iTime * speed * frequency + (shift + uv.x * 1.0 * width) * 6.2831852;\n    \n    float y = sin(angle) * amplitude + offset;\n    \n    float scale = pow(smoothstep(width, width-0.03, distance(y, uv.y)), exponent);\n    scale *= 3.0 * width + 0.2 / pow(smoothstep(10.0 * width, 0.1*width, distance(y, uv.y)), 190.);\n    \n    return color * scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    color += calcSine(uv, 1.5, 0.25, 1.2, 0.5, vec3(0.1, 0.5, 1.0), 0.13, 1.0);\n    color += calcSine(uv, 1.0, 0.25, 2.3, 0.5, vec3(0.1, 0.5, 1.0), 0.1, 1.0);\n    color += calcSine(uv, 0.3, 0.25, 12.0, 0.5, vec3(0.1, 0.5, 1.0), 0.08, 1.0);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 212, 212, 573], [575, 575, 632, 632, 987]], "test": "ok"}
{"id": "4dcGzr", "name": "hexahypnosis", "author": "macbooktall", "description": "dis one is 4 the haters", "tags": ["raymarch", "hexagons", "haters"], "likes": 8, "viewed": 928, "published": "Public API", "date": "1447614699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tweaked copy of https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    const float height = .22;\n    const float depth = .15;\n    const float t = 0.01;\n    pos.z = mod(pos.z,depth*10.)-0.5*depth*10.;\n\tpos.y = mod(pos.y,height*1.9)-0.5*height*1.9;\n\tpos.x = mod(pos.x,height*2.2)-0.5*height*2.2;\n    \n   \tfloat cyl = sdHexPrism( pos, vec2(height-t, depth+t));\n   \tfloat scyl = sdHexPrism( pos, vec2(height-t*2.0, depth+t+.001));\n\n   return vec2(opS(scyl, cyl), 1.5);\n \n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 100.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n   vec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n   m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\nvec3 eps = vec3( 0.01, 0.0, 0.0 );\nvec3 nor = vec3(\n   map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n   map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n   map(pos+eps.yyx).x - map(pos-eps.yyx).x );\nreturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 )*occ;    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n\n\t\tcol = hue(vec3(0.0,1.0,1.0),pos.z);\n    }\n\nreturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n \n\t// camera\n\tvec3 ro = vec3(0., 0.,iTime );\n\t\n    vec3 ta = ro+vec3( 0., 0.,1. );\n\t\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 3.14159/2.0 );\n\n    // ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy,2.5));\n\n    // render\n    vec3 col = render( ro, rd );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcGzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[171, 171, 206, 206, 1155], [1157, 1157, 1193, 1193, 1277], [1279, 1279, 1310, 1310, 1406], [1408, 1408, 1441, 1441, 1467], [1469, 1469, 1499, 1499, 1532], [1534, 1534, 1559, 1559, 1961], [1963, 1963, 2003, 2003, 2283], [2285, 2285, 2317, 2317, 2528], [2530, 2530, 2572, 2572, 2873], [2878, 2878, 2917, 2917, 3155], [3157, 3157, 3209, 3209, 3382], [3384, 3384, 3441, 3441, 3901]], "test": "ok"}
{"id": "4dd3zH", "name": "Boobs !!!!!!!!!!!!!!!!!", "author": "Dermenslof", "description": "i like it", "tags": ["interactive", "sexy"], "likes": 14, "viewed": 1495, "published": "Public", "date": "1448129027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution\n#define T iTime\n\nvec3 ro;\nvec3 rd;\nvec3 light;\nvec3 dir;\n\nstruct RAY\n{\n    vec3 p;\n    float l;\n    float d;\n};\n\nfloat plane(in vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sphere(in vec3 p, vec4 s)\n{\n    return length(p - s.xyz) - s.w;\n}\n\nfloat blob(float a, float b, float coef)\n{\n    return dot(a, b) / coef;\n}\n\nfloat cut(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat sub(float a, float b)\n{\n    return max(-a, b);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat triangle( vec3 p, vec3 a, vec3 b, vec3 c)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nmat3 md()\n{\n    return mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.);\n}\n\n\nmat3 rotx(float a)\n{\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat3(1.,0.,0.,0.,c,-s,0.,s,c);\n}\n\nmat3 roty(float a)\n{\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat3(c,0.,s,0.,1.,0.,-s,0.,c);\n}\n\nmat3 rotz(float a)\n{\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat3(c,-s,0.,s,c,0.,0.,0.,1.);\n}\n\nvec3 rot(in vec3 p, vec3 a, vec3 c)\n{\n    p -= c;\n    return c + p * md() * rotx(a.x) * roty(a.y) * rotz(a.z); \n}\n\nfloat scene(in vec3 p)\n{       \n    float s1 = sin(T);\n    float s2 = .2 + sin(T - .2);\n    \n    vec3 nipPosL = vec3(-1.9,s1,0);\n    vec3 titPosL = vec3(-1.5,.1 + s2,-2.15);\n    vec3 mlPos = vec3(-1.6,s2,-1.5);\n    vec3 nipPosR = vec3(1.9,s1,0);\n    vec3 titPosR = vec3(1.5,.1 + s2,-2.15);\n    vec3 mrPos = vec3(1.6,s2,-1.5);\n    vec3 a = vec3(radians((-50. + R.y / 2.) / 16.), 0.,0);\n    \n    if (iMouse.z > 0.)\n        a = radians(vec3((iMouse.y - R.y / 2.) / 16.,-(iMouse.x - R.x / 2.) / 16.,0));\n    titPosL = rot(titPosL, a, nipPosL);\n    mlPos = rot(mlPos, a,nipPosL);\n    titPosR = rot(titPosR, a, nipPosR);\n    mrPos = rot(mrPos, a, nipPosR);\n    \n    float nipL = sphere(p, vec4(nipPosL,2));\n    float nipR = sphere(p, vec4(nipPosR,2));\n    float titL = sphere(p, vec4(titPosL,.02));\n    float titR = sphere(p, vec4(titPosR,.02));\n    float mL = sphere(p, vec4(mlPos,.6));\n    float mR = sphere(p, vec4(mrPos,.6));\n    float b = iTime * 50.;\n    return min(smin(nipL, smin(mL, titL, 15.), 20.), smin(nipR, smin(mR, titR, 15.), 20.));\n}\n\nRAY trace(float maxd)\n{\n    RAY r = RAY(ro, 2., .001);\n    for (int i = 0; i < 128; ++i)\n    {\n        if (abs(r.d) < .001 || r.l > maxd)\n            break;\n        r.l += r.d;\n        r.p = ro + rd * r.l;\n        r.d = scene(r.p);\n    }\n    return r;\n}\n\nvoid init(in vec2 uv)\n{\n    ro = vec3(0,.6,-4);\n    rd = normalize(vec3(uv, 1));\n    light = vec3(0,4,-8);\n\tdir = normalize(vec3(0,0,-1));\n}\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    C.rgb = vec3(0);\n\tvec2 uv = 2. * U.xy / R.xy - 1.;\n    uv.x *= R.x / R.y;\n    init(uv);\n    RAY r = trace(100.);\n    if (r.l < 100.)\n    {\n        vec3 c = mix(vec3(1.,.83,.73), vec3(.98,.7,.6), vec3(-r.p.z));\n        vec3 e = vec3(.00001, 0, 0);\n        vec3 n = vec3(r.d) - vec3(scene(r.p - e.xyy), scene(r.p - e.yxy), scene(r.p - e.yyx));\n        float b = dot(normalize(n), normalize(light - r.p));\n        C.rgb = (b * c + 0.02 * pow(b, 42.)) * (1. - r.l * .01);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dd3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 167, 167, 201], [203, 203, 236, 236, 274], [276, 276, 318, 318, 349], [351, 351, 380, 380, 404], [406, 406, 435, 435, 460], [462, 462, 487, 487, 506], [507, 507, 556, 556, 1063], [1065, 1065, 1106, 1106, 1177], [1179, 1179, 1190, 1190, 1237], [1240, 1240, 1260, 1260, 1345], [1347, 1347, 1367, 1367, 1452], [1454, 1454, 1474, 1474, 1559], [1561, 1561, 1598, 1598, 1674], [1676, 1676, 1700, 1700, 2720], [2722, 2722, 2745, 2745, 2975], [2977, 2977, 3000, 3000, 3117], [3119, 3119, 3158, 3158, 3638]], "test": "error"}
{"id": "4dt3R7", "name": "Colorful Snake", "author": "twbmsp", "description": "I am completely beginning please let me know if you have any advice. I should try to remove this aliasing. :/", "tags": ["random", "snake"], "likes": 3, "viewed": 135, "published": "Public", "date": "1448655508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\n\nconst float SNAKE_NW  = 0.10;\nconst float SNAKE_DW = 0.106;\n\nconst vec4 VCOL = vec4(1.0, 0.2, 0.0, 1.0);\nconst vec4 WCOL = vec4(0.8, 0.4, 1.0, 1.0);\nconst vec4 XCOL = vec4(0.2, 0.4, 0.8, 1.0);\nconst vec4 YCOL = vec4(0.2, 0.8, 0.2, 1.0);\nconst vec4 BCOL = vec4(0.0, 0.0, 0.0, 1.0);\n\nconst vec4 BACK = vec4(1.0, 0.8, 0.4, 1.0);\n\nconst float SNAKE_STEP = 0.2;\n\n\nfloat rand(const float timeShift, const float index, const float timeStep)\n{\n    float f = floor((iTime + timeShift) / timeStep);\n    \n    vec2 v = vec2(mod(f + index, iResolution.y),\n                  mod(f - index, iResolution.x));\n    \n    return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat continuousRand(const float timeShift, const float index, const float timeStep)\n{\n    float c00 = 0.5 *       rand(timeShift           , index, timeStep);\n    float c10 = 0.5 *       rand(timeShift + timeStep, index, timeStep);\n    float c01 = 2.0 * PI  * rand(timeShift           , index + 0.5, timeStep);\n    float c11 = 2.0 * PI  * rand(timeShift + timeStep, index + 0.5, timeStep);\n    \n    float t = 0.5 + 0.5 * sin(PI * (fract((iTime + timeShift) / timeStep) - 0.5));\n    \n    return (1.0 - t) * c00 * sin((iTime + timeShift) / timeStep + c01) +\n                  t  * c10 * sin((iTime + timeShift) / timeStep + c11);\n    \n}\n\nvec4 addSnakeColor(const vec4 scol, const vec4 fragColor, const float timeShift, const vec2 p)\n{\n    vec2 v = 2.0 * vec2(continuousRand(timeShift * SNAKE_STEP, 0.0, 1.0) + 0.5,\n                        continuousRand(timeShift * SNAKE_STEP, 1.0, 1.0) + 0.5);\n    \n    float l = length(p - v);\n    float x = step(l, SNAKE_NW);\n    float y = step(l, SNAKE_DW) - x;\n    \n\treturn (scol - fragColor) * x +\n           (BCOL - fragColor) * y;\n}\n\nvec4 antialiasing(const vec4 scol, const vec4 fragColor, const float timeShift, const vec2 p)\n{\n    vec2 DX = vec2(1.0 / iResolution.x, 0.0);\n    vec2 DY = vec2(0.0, 1.0 / iResolution.y);\n    \n\treturn 0.25 * addSnakeColor(scol, fragColor, timeShift, 2.0 * p) +\n           0.25 * addSnakeColor(scol, fragColor, timeShift, 2.0 * p + DX) +\n           0.25 * addSnakeColor(scol, fragColor, timeShift, 2.0 * p + DY) +\n           0.25 * addSnakeColor(scol, fragColor, timeShift, 2.0 * p + DX + DY);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2(fragCoord.x / iResolution.x,\n                  fragCoord.y / iResolution.y);\n    \n    fragColor = BACK;\n    \n    fragColor += antialiasing(VCOL, fragColor, 0.0, p);\n    fragColor += antialiasing(WCOL, fragColor, 1.0, p);\n    fragColor += antialiasing(XCOL, fragColor, 2.0, p);\n    fragColor += antialiasing(YCOL, fragColor, 3.0, p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dt3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 386, 462, 462, 695], [697, 697, 783, 783, 1332], [1334, 1334, 1430, 1430, 1770], [1772, 1772, 1867, 1867, 2266], [2267, 2267, 2324, 2324, 2677]], "test": "ok"}
{"id": "4dt3R8", "name": "MetaPixelBalls", "author": "RenoM", "description": "metaballs pixel", "tags": ["metaballspixel"], "likes": 8, "viewed": 196, "published": "Public", "date": "1448063278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 25.\n\nfloat superellipse(vec2 uv,vec2 o,float r,float n)\n{\n    float res=pow(abs((uv.x-o.x)/r),n)+pow(abs((uv.y-o.y)/r),n);\n    return res<=1.?sqrt(1.-res):.0;\n}\n\nvec3 putPixel(vec2 uv)\n{\n    return superellipse(fract(uv),vec2(.5),.5,3.5)*vec3(.1,.9,.07);\n}\n\nvoid mainImage(out vec4 C,in vec2 U)\n{\n    vec2 R=iResolution.xy;\n    vec2 uv=(2.*U-R)/R.y*scale,\n        fuv=floor(uv)+.5,\n          t=vec2(sin(iTime),cos(iTime))*scale/2.,\n         o1=vec2(0,t.x),\n         o2=vec2(1.7*t.x,0),\n         o3=2.*t.yx;\n    vec3 l=vec3(distance(o1,fuv),distance(o2,fuv),distance(o3,fuv)),\n    \t g=scale*vec3(.5/(l.x*l.x),1./(l.y*l.y),.75/(l.z*l.z));\n    C.xyz=g.x+g.y+g.z>10./scale?putPixel(uv):vec3(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dt3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 71, 71, 174], [176, 176, 200, 200, 270], [272, 272, 310, 310, 706]], "test": "ok"}
{"id": "4l2SW3", "name": "SnowScreen", "author": "jt", "description": "A snow-effect created by multiple layers of \"blob-noise\" traveling at different speed\n(for the basic effect see [url]https://www.shadertoy.com/view/4ljSW3[/url]).", "tags": ["particles", "superposition", "blobnoise"], "likes": 30, "viewed": 1214, "published": "Public", "date": "1446914698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SnowScreen (superposition of blobs in displaced-grid voronoi-cells) by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define pi 3.1415926\n\nfloat T;\n\n// iq's hash function from https://www.shadertoy.com/view/MslGD8\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nfloat simplegridnoise(vec2 v)\n{\n    float s = 1. / 256.;\n    vec2 fl = floor(v), fr = fract(v);\n    float mindist = 1e9;\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 pos = .5 + .5 * cos(2. * pi * (T*.1 + hash(fl+offset)) + vec2(0,1.6));\n            mindist = min(mindist, length(pos+offset -fr));\n        }\n    \n    return mindist;\n}\n\nfloat blobnoise(vec2 v, float s)\n{\n    return pow(.5 + .5 * cos(pi * clamp(simplegridnoise(v)*2., 0., 1.)), s);\n}\n\nfloat fractalblobnoise(vec2 v, float s)\n{\n    float val = 0.;\n    const float n = 4.;\n    for(float i = 0.; i < n; i++)\n        //val += 1.0 / (i + 1.0) * blobnoise((i + 1.0) * v + vec2(0.0, iTime * 1.0), s);\n    \tval += pow(0.5, i+1.) * blobnoise(exp2(i) * v + vec2(0, T), s);\n\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    T = iTime;\n\n    vec2 r = vec2(1.0, iResolution.y / iResolution.x);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float val = fractalblobnoise(r * uv * 20.0, 5.0);\n    //float val = fractalblobnoise(r * uv * 40.0, 1.25); // more snowflakes\n    //float val = blobnoise(r * uv * 10.0, 5.0);\n    //fragColor = vec4(vec3(val), 1.0);\n    fragColor = mix(texture(iChannel0, uv), vec4(1.0), vec4(val));\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2SW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[208, 273, 294, 294, 385], [387, 387, 418, 418, 810], [812, 812, 846, 846, 925], [927, 927, 968, 968, 1223], [1225, 1225, 1282, 1282, 1683]], "test": "error"}
{"id": "4l2SWc", "name": "Spirograph Plotter", "author": "Flyguy", "description": "A spirograph plotter using the discard bug as a crude backbuffer.\nA framerate of 60 fps is assumed for the lines to be drawn properly (an iFrameTime input would be useful).", "tags": ["graph", "plot", "spirograph", "discard"], "likes": 17, "viewed": 1659, "published": "Public API", "date": "1446946486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define polar(l,a) (l*vec2(cos(a),sin(a)))\n\nfloat tau = atan(1.0)*8.0;\n\nfloat timeScale = 1.0;\n\nfloat distLine(vec2 p0,vec2 p1,vec2 uv)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tuv = (uv - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(uv, clamp(uv, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\n//Spirograph function (change these numbers to get different patterns)\nvec2 spirograph(float t)\n{\n    return polar(0.30, t * 1.0) \n         + polar(0.08, t *-4.0)\n         + polar(0.06, t *-8.0)\n         + polar(0.05, t * 16.0)\n         + polar(0.02, t * 24.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frameTime = (1.0 / 60.0) * timeScale;\n\n    vec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n    \n    float lineRad = 1.0 / iResolution.y;\n    \n    float curTime = iTime * timeScale;\n    float lastTime = curTime - frameTime;\n    \n    float dist = distLine(spirograph(curTime), spirograph(lastTime), uv);\n    \n    vec3 col = vec3(0.0);\n    \n    //Click to reset\n    if(iMouse.w > 0.0)\n    {\n\t\tcol = vec3(0.0);\n    }\n    else\n    {\n        if(dist < lineRad)\n        { \n            col = vec3(1.0);\n        }\n        else\n        {\n            discard;\n        }        \n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2SWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 137, 137, 295], [297, 368, 394, 394, 560], [562, 562, 619, 619, 1289]], "test": "ok"}
{"id": "4l2XWK", "name": "Bumped Sinusoidal Warp", "author": "Shane", "description": "Point lit, bump mapped, sinusoidal warp.", "tags": ["specular", "warp", "bump", "sinusoidal"], "likes": 125, "viewed": 4830, "published": "Public API", "date": "1446729264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tBumped Sinusoidal Warp\n\t----------------------\n\n\tSinusoidal planar deformation, or the 2D sine warp effect to people \n\tlike me. The effect has been around for years, and there are\n\tcountless examples on the net. IQ's \"Sculpture III\" is basically a \n\tmuch more sophisticated, spherical variation.\n\n    This particular version was modified from Fabrice's \"Plop 2,\" which in \n\tturn was a simplified version of Fantomas's \"Plop.\" I simply reduced \n\tthe frequency and iteration count in order to make it less busy.\n\n\tI also threw in a texture, added point-lit bump mapping, speckles... \n\tand that's pretty much it. As for why a metallic surface would be \n\tdefying\tthe laws of physics and moving like this is anyone's guess. :)\n\n\tBy the way, I have a 3D version, similar to this, that I'll put up at \n\ta later date.\n    \n\n\n\tRelated examples:\n\n    Fantomas - Plop\n    https://www.shadertoy.com/view/ltSSDV\n\n    Fabrice - Plop 2\n    https://www.shadertoy.com/view/MlSSDV\n\n\tIQ - Sculpture III (loosely related)\n\thttps://www.shadertoy.com/view/XtjSDK\n\n\tShane - Lit Sine Warp (far less code)\n\thttps://www.shadertoy.com/view/Ml2XDV\n\n*/\n\n\n// Warp function. Variations have been around for years. This is\n// almost the same as Fabrice's version:\n// Fabrice - Plop 2\n// https://www.shadertoy.com/view/MlSSDV\nvec2 W(vec2 p){\n    \n    p = (p + 3.)*4.;\n\n    float t = iTime/2.;\n\n    // Layered, sinusoidal feedback, with time component.\n    for (int i=0; i<3; i++){\n        p += cos(p.yx*3. + vec2(t, 1.57))/3.;\n        p += sin(p.yx + t + vec2(1.57, 0))/2.;\n        p *= 1.3;\n    }\n\n    // A bit of jitter to counter the high frequency sections.\n    p +=  fract(sin(p+vec2(13, 7))*5e5)*.03 - .015;\n\n    return mod(p, 2.) - 1.; // Range: [vec2(-1), vec2(1)]\n    \n}\n\n// Bump mapping function. Put whatever you want here. In this case, \n// we're returning the length of the sinusoidal warp function.\nfloat bumpFunc(vec2 p){ \n\n\treturn length(W(p))*.7071; // Range: [0, 1]\n\n}\n\n/*\n// Standard ray-plane intersection.\nvec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {\n    \n    float dn = dot(rd, n);\n\n    float s = 1e8;\n    \n    if (abs(dn) > 0.0001) {\n        s = dot(p-o, n) / dn;\n        s += float(s < 0.0) * 1e8;\n    }\n    \n    return o + s*rd;\n}\n*/\n\nvec3 smoothFract(vec3 x){ x = fract(x); return min(x, x*(1.-x)*12.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // PLANE ROTATION\n    //\n    // Rotating the canvas back and forth. I don't feel it adds value, in this case,\n    // but feel free to uncomment it.\n    //float th = sin(iTime*0.1)*sin(iTime*0.12)*2.;\n    //float cs = cos(th), si = sin(th);\n    //uv *= mat2(cs, -si, si, cs);\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane \n    // situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.2, -1); // Light position - Back from the screen.\n\tvec3 sn = vec3(0, 0, -1); // Plane normal. Z pointing toward the viewer.\n \n     \n/*\n\t// I deliberately left this block in to show that the above is a simplified version\n\t// of a raytraced plane. The \"rayPlane\" equation is commented out above.\n\tvec3 rd = normalize(vec3(uv, 1));\n\tvec3 ro = vec3(0, 0, -1);\n\n\t// Plane normal.\n\tvec3 sn = normalize(vec3(cos(iTime)*.25, sin(iTime)*.25, -1));\n    //vec3 sn = normalize(vec3(0, 0, -1));\n\t\n\tvec3 sp = rayPlane(vec3(0), ro, sn, rd);\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.25, -1); \n*/    \n    \n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4./iResolution.y, 0);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy - eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy - eps.yx); // Same for the nearby sample in the Y-direction.\n   \n \t// Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.05;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx - f)/eps.x; // Change in X\n    fy = (fy - f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize(sn + vec3(fx, fy, 0)*bumpFactor);           \n   \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), .0001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1. + lDist*lDist*.15);\n\t//float atten = min(1./(lDist*lDist*1.), 1.);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth.\n    atten *= f*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 12.); \n\n\t\n    // TEXTURE COLOR\n    //\n\t// Combining the surface postion with a fraction of the warped surface position to index \n    // into the texture. The result is a slightly warped texture, as a opposed to a completely \n    // warped one. By the way, the warp function is called above in the \"bumpFunc\" function,\n    // so it's kind of wasteful doing it again here, but the function is kind of cheap, and\n    // it's more readable this way.\n    vec3 texCol = texture(iChannel0, sp.xy + W(sp.xy)/8.).xyz; \n    texCol *= texCol; // Rough sRGB to linear conversion... That's a whole other conversation. :)\n    // A bit of color processing.\n    texCol = smoothstep(.05, .75, pow(texCol, vec3(.75, .8, .85)));    \n    \n    // Textureless. Simple and elegant... so it clearly didn't come from me. Thanks Fabrice. :)\n    //vec3 texCol = smoothFract( W(sp.xy).xyy )*.1 + .2;\n    \n\t\n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol*(diff*vec3(1, .97, .92)*2. + .5) + vec3(1, .6, .2)*spec*2.)*atten;\n    \n    // Faux environment mapping: I added this in at a later date out of sheer boredome, and  \n    // because I like shiny stuff. You can comment it out if it's not to your liking. :)\n    float ref = max(dot(reflect(rd, sn), vec3(1)), 0.);\n    col += col*pow(ref, 4.)*vec3(.25, .5, 1)*3.;\n    \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2XWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1131, 1298, 1313, 1313, 1751], [1753, 1885, 1908, 1908, 1958], [2236, 2236, 2261, 2261, 2306], [2308, 2308, 2364, 2392, 7504]], "test": "error"}
{"id": "4l2XWw", "name": "phyllotaxis 2D", "author": "shaderology", "description": "infinite zoom into 2d pattern of romanesco broccoli. ", "tags": ["2d", "fibonacci", "phyllotaxis", "logpolar", "romanesco", "broccoli"], "likes": 22, "viewed": 1124, "published": "Public API", "date": "1448919713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define SPIRALS 7.\n#define LEV 5\n//#define CELLROTATION\n\nvec2 rotate2D(vec2 p, float t)\n{\n    mat2 m = mat2( cos(t), sin(t), -sin(t), cos(t) );\n    return m * p;\n}\n\nvec4 phyllotaxis( vec2 uv, float offset )\n{\n\n    // initiate\n    float i_s = 1.;\n    float r_s = 1.;\n    float t_s = 0.;\n    float occ = 1.;\n    float dsp = 0.5;\n    vec3 n = vec3(0., 0., 1.);\n\n    for( int i=1; i<LEV; i++ )\n    {\n      float zoom = i == 1 ? offset : 0.;\n        \n      // Log-Polar coordinates from UVs generated in previous iteration\n      float r = length(uv);\n      float lr = log(r);\n      float theta = atan( uv.x, uv.y);\n        \n      // Logarithmic spiral coordinates\n      vec2 spiral = vec2( theta - lr, theta + lr - zoom)/PI;\n      \n      // Phyllotaxis florets - main pattern\n      // Log-polar fractions back to cartesian cells\n      uv = fract( spiral * SPIRALS ) -  0.5;\n\n      // Align new theta's using parent theta. Not very accurate as there is some distortion.\n      // Also had to offset with a mysterious constant of 0.36 (golden fraction?)\n      #ifdef CELLROTATION\n        // Experimental part. Flatten the spiral coordinates to cells\n        // and use uniform value of an entire cell to offset theta\n        float cellr = floor(spiral.x * SPIRALS) - floor(spiral.y * SPIRALS);\n        float cellt = floor(spiral.x * SPIRALS ) + floor(spiral.y * SPIRALS );\n        vec2 uvcell = vec2( cellr, cellt / (SPIRALS / 1.55) );\n        //uv = rotate2D( uv, -(theta+0.72)  ); // + 2x golden fraction?\n        uv = rotate2D( uv,  -(uvcell.y) );\n        t_s = theta;\n      #else\n        // cheap offset with golden(?) constant.\n        // thetas are aligned but slightly distorted\n        t_s = theta + t_s + 0.36;\n      #endif\n      \n      // smooth cone tips\n      float taper = smoothstep(0.0, 0.2, r) * (1. - smoothstep(0.5, 0.8, r));\n        \n      // build and layer the normals and multiply with floret radius\n      n += mix( vec3(0., 0., 1.0), vec3( sin(t_s), cos(t_s), 0. ),  pow(taper, 0.5)) * r_s;        \n  \n      // comp occlusion.\n      occ *= 1.-pow(r, 2.);\n        \n      // displacement is not used in this demo\n      // dsp += (1.-r) * i_s * r_s;\n      \n      // store iteration multiplier for displacements\n      i_s = 1. / float(i);\n        \n      // combine and store floret radius. next iteration we use it to\n      // multiply displacements and normals\n      r_s *= sqrt(r);\n    }    \n    \n   return vec4( normalize(n), occ ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n\n\tvec2 m = iMouse.xy / iResolution.xy -.5;\n\tm.x*= iResolution.x/ iResolution.y;\n\tm *= 20.0;\n\t\n    // VARIABLES\n    float t = fract(iTime * .05) * PI;\n    vec3 sp = vec3(uv - 0.4, 0.);\n    vec3 lp = iMouse.z < .5 ? vec3(sin(t*5.)*10.,cos(t*8.)*10., -1.5) : vec3(m, -2.);\n    vec3 ld = normalize(lp - sp);\n    vec3 ro = vec3(0, 0, -0.5);\n    vec3 rd = normalize(ro-sp);\n\n    // THE PATTERN\n    vec4 brocc = phyllotaxis(sp.xy, t);\n    vec3 n = vec3( brocc.xy, -brocc.z);\n    float occ = brocc.w;\n    \n    // COLORS\n    vec3 base = vec3(0.38, 0.52, 0.26);\n    vec3 diff = vec3(0.6, 0.6, 0.5);\n    vec3 spec = diff;\n    vec3 back = vec3(0.1, 0.01, 1.5);\n    vec3 ambi = vec3(0.25, 0.44, 0.23);\n    \n    // SHADE\n\tdiff *= max(dot(n, ld), 0.);\n    back *= max(dot(n, vec3(0.4, -0.4, 0.2)), 0.);\n    spec *= pow(max(dot( reflect(-ld, n), rd), 0.), 7.); \n    ambi *= occ;\n\n    // COMP\n    vec3 col = base * ambi;\n    col += base * diff;\n    col += spec * 0.2;\n    col += base * back;\n\n    // POST\n    col *= pow(20.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.5) +  0.1;\n    col = sqrt(col);\n    \n\tfragColor = vec4( col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2XWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 140, 140, 214], [216, 216, 259, 276, 2500], [2502, 2502, 2559, 2559, 3757]], "test": "ok"}
{"id": "4lBSD3", "name": "2d experiment #8 - pii", "author": "public_int_i", "description": "lksdjlfjlsdj", "tags": ["lksjdlfjsldj"], "likes": 1, "viewed": 352, "published": "Public API", "date": "1446762130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv *= 7.+sin(iTime*.1)*4.;\n    uv += vec2(sin(iTime*.1),cos(iTime*.044))*3.;\n\t\n    for (int i = 0; i < 3; i++) {\n        float ang = abs(atan(uv.y,uv.x))/4.+\n            cos((abs(uv.x)+abs(uv.y))/2.);\n        uv *= mat2(sin(ang), cos(ang), -cos(ang), sin(ang));\n        \n        vec2 dir = -normalize(abs(mod(uv*(1.+sin(iTime*.1)*.5),.5)-.25));\n        uv = uv.yx + dir * .2 * sin(atan(uv.y,uv.x)+iTime*.14);\n        uv = abs(uv);\n    }\n    \n    float dst = max(0., 1.-(length(max(abs(sin(uv))-.1,0.))));\n    fragColor = vec4(cos(dst*16.+iTime)*.5+.5,\n                     dst,\n                    dst,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 717]], "test": "ok"}
{"id": "4lBSWt", "name": "quadrangle structure", "author": "Equations", "description": "It's a simple thing to draw in reallife, so I thought I'd be able to get it done here too.\nEnjoy!\nAlso modify the speed to your liking", "tags": ["quadranglerotation"], "likes": 4, "viewed": 121, "published": "Public", "date": "1447360296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define maxDist 1000000.0\n\n//global variables and constants\n#define lineWidth 0.003\n#define amount 48.0\nfloat delta  = 2.0 * PI / amount;\nfloat rotationSpeed(){\n    return 2.0 * iTime;\n}\nvec2 centre1 = vec2(-0.4, 0.1),\n\tcentre2 = vec2(0.4, -0.1);\n\n//basic functions\nfloat toAngle(vec2 ray){\n\treturn atan(ray.y, ray.x);\n}\nvec2 toCartesian(float angle){\n\treturn vec2(cos(angle), sin(angle));\n}\nfloat getWidth(vec2 rayDir, vec2 rightRay){\n    //normalizes the ray, if you were wondering, and compares it to rightRay\n    return length(rayDir - rightRay * dot(rayDir, rightRay) / dot(rightRay, rightRay));\n}\nfloat modify(float arg){\n    //fixing and making some quadrangles white\n    if(arg > amount / 2.0) arg = amount - arg;\n    \n    return mod(arg, 2.0) == 0.0 ? 0.0 : arg + 1.0;\n}\n\nvec2 castRayToEdge(vec2 rayOrg, vec2 rayDir){\n    //casting ray to edge of screen\n    float dist_topBot, dist_leftRight;\n    //topBot\n    if(rayDir.y != 0.0) \n        dist_topBot = (sign(rayDir.y) - rayOrg.y) / rayDir.y;\n    else dist_topBot = maxDist;\n    //rightLeft    \n    if(rayDir.x != 0.0)\n        dist_leftRight = (sign(rayDir.x) * iResolution.x / iResolution.y - rayOrg.x) / rayDir.x;\n    else dist_leftRight = maxDist;\n    \n    return rayOrg + min(dist_topBot, dist_leftRight) * rayDir;\n}\n\nfloat floorToGlobal(float alpha){\n\treturn floor((rotationSpeed() - alpha) / delta);\n}\n\nfloat alphaToNextRay(float alpha){\n    return mod(rotationSpeed() - alpha, delta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0  + 2.0 * fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y; float color = 1.0;\n    \n    //vars for calculation:\n    float angle1 = toAngle(castRayToEdge(centre1, uv - centre1)), \n        angle2 = toAngle(castRayToEdge(centre2, uv - centre2));\n    \n    //coloring the lines\n    if(getWidth(uv - centre1, castRayToEdge(vec2(0.0), toCartesian(angle1 + alphaToNextRay(angle1))) - centre1) < lineWidth) color = 0.0;\n    if(getWidth(uv - centre2, castRayToEdge(vec2(0.0), toCartesian(angle2 + alphaToNextRay(angle2))) - centre2) < lineWidth) color = 0.0;\n    \n    //coloring the squares\n    color -= 1.5 * modify(abs(floorToGlobal(angle1) - floorToGlobal(angle2))) / amount;\n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 185, 185, 211], [273, 291, 315, 315, 345], [346, 346, 376, 376, 416], [417, 417, 460, 537, 627], [628, 628, 652, 699, 804], [806, 806, 851, 887, 1304], [1306, 1306, 1339, 1339, 1391], [1393, 1393, 1427, 1427, 1477], [1479, 1479, 1536, 1536, 2278]], "test": "ok"}
{"id": "4lBXWt", "name": "Spectacles", "author": "cabbibo", "description": "\nAnother prototype for the vr raytrace gallery being created by http://tree.is", "tags": ["raytrace", "rainbow", "spectacles", "pyshcedelic"], "likes": 10, "viewed": 710, "published": "Public", "date": "1447120750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float PI = 3.14159;\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\n// q is point\n// n is normal\n// p is point on plane\nvec3 projOnPlane( vec3 q, vec3 p , vec3 n){\n    \n    vec3 v = q - dot(q - p, n) * n;\n    return v;\n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\n\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float an = 0.3 + 10.0*mouse.x;\n\tcamPos = vec3(1.5*sin(an),0.,1.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return udRoundBox( q , size , rad );\n    \n    \n}\n\n\n\nvec2 smoothU( vec2 d1, vec2 d2, float k)\n{\n    float a = d1.x;\n    float b = d2.x;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return vec2( mix(b, a, h) - k*h*(1.0-h), mix(d2.y, d1.y, pow(h, 2.0)));\n}\n\n\nvec2 smoothSub( vec2 d1, vec2 d2, float k)\n{\n    return  vec2( smax( -d1.x , d2.x , k ) , d2.y );\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n/*float opRepCube( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return primitve( q );\n}\n*/\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n   return (-d1.x>d2.x) ? vec2( -d1.x , d1.y ) : d2;\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat doRing( vec3 p ){\n  \n    vec3 pos = p;\n    \n     \n    float lor = sign( pos.x );\n    \n    \n    pos.x = abs( pos.x );\n    \n    //pos.x = mod( pos.x , 1.5 );\n    float degree = atan( pos.y , pos.z );\n    \n    float ogD = degree;\n    \n    degree += iTime;// * (1. + lor * .2);\n    float l = length( pos.yz );\n    \n\n    \n    degree = mod( degree - 3.14159  / 8. , 3.14159  / 4. );\n \n    \n    pos.y = l * sin( degree );\n    pos.z = l * cos( degree );\n\n    \n    return sdSphere( pos - vec3( 2.4 ,  1. , 2.39 )  * .2  , .04 *( 1. + abs(ogD) ));\n    \n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    \n    \n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nvec3 twist( vec3 p ){\n float c = cos(20.0*p.z);\n  float s = sin(20.0*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);   \n    \n    return q;\n}\n\n\nfloat bentCappedCylinder( vec3 p, vec2 h )\n{\n    \n \n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec2 glasses( vec3 p ){\n    \n    \n   vec3 og = p;\n    \n   mat3 r = xrotate( -.18 * PI / 2. );\n    \n    p = r * p;\n \n    \n   p.x = abs( p.x );\n    \n   vec3 eyePos = vec3( 0.25 , 0. , 0. );\n    \n   r = xrotate( PI / 2. );\n    \n   vec2 res;\n    \n   // Rims\n   res = vec2( sdTorus( r * (p -eyePos) , vec2( .16 , .02 ) ) , 2. );\n    \n    \n   //spectacles\n   res = smoothU( res ,vec2( sdCappedCylinder( r * (p -eyePos) , vec2( .15 , .01 ) ), 10. ), .01);\n    \n    \n   eyePos = vec3( 0.41 , 0.1 , -0.25 );\n    \n   //earHolders\n   res = smoothU( res ,vec2( bentCappedCylinder( r * (p -eyePos) , vec2( .01 , .25 ) ), 2. ), .03);\n    \n   r = xrotate(.6* PI / 2. );\n   eyePos = vec3( 0.41 , 0.06 , -0.55 );\n   res = smoothU( res ,vec2( bentCappedCylinder( r * (p -eyePos) , vec2( .008 , .08 ) ), 3. ), .02);\n     \n    \n   // cross bar\n    eyePos = vec3( 0. , .13 , 0. );\n    \n   r = zrotate( PI / 2. );\n    \n   res = smoothU( res , vec2( sdCappedCylinder( r * ( og - eyePos) , vec2( .01 , .13 )) , 2. ), .03);\n   return res;\n    \n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n   \n    \n    vec2 ring;\n\n\n    vec2 res = glasses( pos );\n    vec2 plane = vec2( sdPlane( pos , vec4( 0., 1. , 0. , .17 ) ), 20. );\n    \n    res = opU( res , plane );\n    \n\n    \n    \t\n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 bodyColor( vec3 p , vec3 n ){\n    return vec3( 1. );\n    \n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n} \n\n\n/*vec3 cPal( float t ){\n return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25));   \n    \n}*/\n\nvec3 cPal( float t ){\n return vec3( 1. - t );    \n}\nvec3 lensColor( vec3 p , vec3 n , vec3 rd ){\n    \n   vec3 pos; vec3 col; float v;\n    \n   float offset = sin(iTime * .1 + sin( iTime * .3 + sin( iTime * .1)));\n    \n   for( int i = 0; i < 10; i++ ){\n       \n    pos = p + rd * .03 * float(i);\n    v = noise( pos * 10. + rd * offset  );\n    \n    col = hsv( abs(v) * .1 + offset + float( i ) / 10. , 1. , 1. ) *(1.+ float( i ) / 10.);\n       \n    if( v > .5 ){ break;}\n        \n   }\n    \n   return col; \n    \n}\n\nvec3 turtleColor( vec3 p , vec3 n ){\n    \n   return vec3( 1. );\n}\n\nvec3 planeColor( vec3 p , vec3 n  , float ao ){\n    \n   \n   return cPal( length( p ) * .1 ) *ao;\n   \n}\n\nvec3 bgColor(){\n    \n   return vec3( .8 );\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\n    vec3 col = vec3( 0. );\n    \n    mat3 basis = mat3(\n     \n        1. , 0. , 0. ,\n        0. , 1. , 0. ,\n        0. , 0. , 1.\n       \n    );\n        \n    \n    col = bgColor();\n   \n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n        float ao = calcAO( pos , norm );\n        \n      \n        \n        vec3 refr = refract( rd , norm , 1. / 1.2 );\n        \n        //col = texture( iChannel0 , normalize(refr) ).xyz;\n \n\t\t\n        // Lens\n        if( res.y >= 4. && res.y < 10.1 ){\n        \tcol = lensColor( pos , norm , rd );// vec3( pow((1. - dot( norm , normalize( pos ) )) , .3) );\n        \n        // Plane\n        }else if( res.y == 20. ){\n         \tcol = planeColor( pos , norm , ao ); \n            \n        //Turtle\n        }else if( res.y== 3. ){\n         \tcol = vec3( 2.  ) * ao;   \n            \n        // body\n        }else{\n        \tcol =  vec3( .5 ) * ao;\n    \t}\n        \n        \n    }\n\n    fragColor = vec4( col , 1. );\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 395, 395, 527], [530, 530, 569, 569, 608], [610, 610, 649, 649, 693], [695, 747, 790, 790, 847], [849, 901, 923, 923, 948], [949, 949, 970, 970, 1050], [1086, 1138, 1181, 1181, 1484], [1486, 1486, 1513, 1513, 1576], [1581, 1581, 1612, 1612, 1650], [1653, 1653, 1698, 1698, 1738], [1741, 1741, 1776, 1776, 1800], [1803, 1803, 1836, 1836, 1901], [1904, 1935, 1999, 1999, 2177], [2179, 2179, 2260, 2260, 2373], [2375, 2448, 2471, 2471, 2577], [2579, 2579, 2602, 2602, 2708], [2710, 2710, 2733, 2733, 2842], [2845, 2845, 2871, 2871, 2940], [2942, 2942, 3004, 3004, 3098], [3102, 3102, 3144, 3144, 3310], [3313, 3313, 3357, 3357, 3412], [3417, 3511, 3540, 3540, 3583], [3685, 3685, 3718, 3718, 3744], [3747, 3747, 3777, 3777, 3831], [3834, 3834, 3866, 3894, 3955], [3957, 3957, 4009, 4009, 4136], [4138, 4138, 4161, 4161, 4688], [4690, 4690, 4726, 4726, 4760], [4764, 4764, 4806, 4806, 4915], [4919, 4919, 4940, 4940, 5079], [5082, 5082, 5126, 5126, 5232], [5235, 5235, 5258, 5258, 6255], [6257, 6257, 6290, 6316, 6347], [6350, 6434, 6455, 6455, 6663], [6667, 6667, 6715, 6715, 7182], [7187, 7300, 7331, 7331, 7557], [7559, 7559, 7633, 7633, 7894], [7897, 7897, 7939, 7939, 8238], [8241, 8241, 8275, 8275, 8305], [8307, 8307, 8330, 8330, 8366], [8367, 8367, 8393, 8393, 8762], [8767, 8767, 8835, 8835, 8878], [9010, 9010, 9031, 9031, 9061], [9062, 9062, 9106, 9106, 9519], [9521, 9521, 9557, 9557, 9586], [9588, 9588, 9635, 9635, 9690], [9692, 9692, 9707, 9707, 9736], [9743, 9743, 9800, 9800, 11372]], "test": "ok"}
{"id": "4lBXWV", "name": "Lava 01", "author": "LucaHofmann", "description": "My first try of a lava shader.", "tags": ["lava"], "likes": 3, "viewed": 241, "published": "Public", "date": "1446418679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// This is the noise algorithm that I used:\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 div = vec2(10, 10);\n\tvec2 uv = fragCoord.xy / iResolution.xy * div.xy;\n\tvec3 v = vec3(\n        uv.x + sin(iTime) * 0.2, \n        uv.y + cos(iTime) * 0.2, \n        iTime / 10.0);\n\n    \n\n    float noise = snoise(v);\n\tuv = fragCoord.xy / iResolution.xy * div.xy;\n    vec3 v2 = vec3(uv.x , uv.y, iTime / 5.0);\n    noise = sin(noise * 3.14 * (sin(iTime) + snoise(v2) * 2.0) * 0.75);\n    \n    float darkenFactor = 0.2;\n    float darkenValue = darkenFactor;\n\n    div = vec2(5, 5);\n    uv = fragCoord.xy / iResolution.xy * div.xy;\n    vec3 v3 = vec3(uv.x, uv.y, iTime / 2.0);\n    darkenValue = darkenValue * snoise(v3);\n    \n    vec3 v4 = vec3(uv.x * 1000.0, uv.y * 1000.0, iTime);  \n\n    float b = snoise(v4) * 0.1;\n     \n    fragColor = vec4(1.0 - darkenValue + (noise * (darkenValue + 0.2)) - b,\n                     noise - b,\n                     b,\n                     1.0);\n    \n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBXWV.jpg", "access": "shaders20k", "license": "mit", "functions": [[439, 439, 460, 460, 509], [511, 511, 532, 532, 581], [583, 583, 605, 605, 645], [647, 647, 675, 675, 727], [729, 729, 753, 753, 2899], [2902, 2902, 2959, 2959, 3851]], "test": "ok"}
{"id": "4ljSDd", "name": "Seasick in the night", "author": "redking", "description": "fun thing to do when in math class ", "tags": ["rotation"], "likes": 1, "viewed": 88, "published": "Public", "date": "1447408547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.1415;\n\n\n\n\n\n\nvoid mainImage( out vec4 color, in vec2 pixCoord )\n\n\n\n{\n\tfloat zoom = (iResolution.x / 10.0) * (1.0 + 0.2 * cos(2.0 * iTime));\n    float cameraX = 5.0   + 4.0 * cos(iTime);\n    float cameraY = 2.0  + 4.0 * sin(iTime * 1.1);\n    float angle = 20.0*(pi/180.0)+iTime;\n    \n    \n    \n    \n    float xBeforeRot = (pixCoord.x / zoom) - cameraX;\n    float yBeforeRot = (pixCoord.y / zoom) - cameraY;\n    float x = xBeforeRot * cos (angle) + yBeforeRot*sin(angle);\n    float y = -xBeforeRot * sin(angle) + yBeforeRot*cos(angle);\n    \n\n    \n    \n    \n    float hauteurMoyenne = 0.0;\n    float amplitude = cos(iTime);\n    float phase = 4.0 + 5.0 * cos(iTime);\n    float periode = 3.0;\n    float fx = hauteurMoyenne + cos(x * 2.0 * pi / periode + phase) * amplitude;\n    \n    if (y < fx) {\n        color = vec4(cos(iTime)*0.5, sin(iTime)*0.3, cos(iTime), 1.0);\n        return;\n    }\n    \n    float fx2 = 1.0 + cos(2.5 * (x + iTime)) *sin(iTime);\n    \n    if (y < fx2) {\n        color = vec4(0.6+sin(iTime), cos(iTime), 1.0, 1.0);\n        return;\n    }\n\t\n    \n    color = vec4(0.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 80, 80, 1112]], "test": "ok"}
{"id": "4ljSDt", "name": "RayCubesLearning", "author": "gilesruscoe", "description": "Learning stuff", "tags": ["raymarchcube"], "likes": 28, "viewed": 465, "published": "Public", "date": "1447360536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat map(vec3 p)\n{\n   \tp.z += iTime * 6.0;\n    p.y += sin(iTime + p.z * 0.25) * 5.0;\n    vec3 q = fract(p) * 2.0 - 1.0;\n    float result = (mix(length(q) - sin(2.0 * iTime + p.x), sdBox(q, vec3(0.25)), sin(iTime  * 2.0) * 0.5 + 0.5));\n    result = sin(result);\n    return result;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 2.0));\n    float the = iTime * 0.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    vec3 o = vec3(0.0, iTime, iTime);\n    \n    float st = (sin(iTime) + 1.5) * 0.4;\n    \n    float t = trace(o, r * st);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog * 2.0);\n    \n    //vec3 tint = vec3(st - 0.5,st,st + 0.5);\n    float st2 = sin(iTime) * 0.5 + 0.5;\n    float ct2 = cos(iTime) * 0.5 + 0.5;\n    vec3 tint = vec3(st2, ct2, -st2);\n\tfragColor = vec4(fc * tint, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 118], [119, 119, 138, 138, 401], [403, 403, 432, 432, 588], [590, 590, 647, 647, 1311]], "test": "ok"}
{"id": "4ljXDt", "name": "SimpleStars", "author": "Trisomie21", "description": "'Stars' shape defined in the Cell() function. ", "tags": ["2d", "stars"], "likes": 25, "viewed": 577, "published": "Public", "date": "1447370193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Cell(vec2 c) {\n\tvec2 uv = fract(c);c -= uv;\n\treturn (1.-length(uv*2.-1.)) * step(fract(sin(c.x+c.y*1e2)*1e3), .04);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = fragCoord.xy / iResolution.xy -.5;\n\tfloat a = fract(atan(p.x, p.y) / 6.2832);\n\tfloat d = length(p);\n\t\n\tvec2 coord = vec2(pow(d, .04), a)*256.;\n\tvec2 delta = vec2(1. + iTime*20., 1.);\n\t\n\tfloat c = Cell(coord-=delta);\n\tc += Cell(coord-=delta);\n\t\n\tfragColor = vec4(c*d*3.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 123], [125, 125, 182, 182, 466]], "test": "ok"}
{"id": "4ljXW3", "name": "2d experiment #10 - pii", "author": "public_int_i", "description": "kjwnfkqndf", "tags": ["oijsdofjo"], "likes": 2, "viewed": 394, "published": "Public API", "date": "1446919357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//#define VISUALIZE_UV\n//#define VISUALIZE_CIRCLE_DF\n#define VISUALIZE_COOL\n\n#define SAMPLES 10\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv *= 40.;//4.5+sin(iTime*.25)*2.;\n    vec2 ruv = uv;\n    \n    for (int b = 0; b < SAMPLES; b++) {\n    \n        uv = ruv+(cos(uv*6.7521+float(b)*.42)*.3+cos(uv.yx*.82234+float(b)*2.42));\n        \n        for (int i = 0; i < 3; i++) {\n            uv = vec2(cos(uv.x+iTime+float(b)*.4)+uv.y*.5,\n                      sin(uv.y)+uv.x*.5);\n        }\n\n        #ifdef VISUALIZE_UV\n        fragColor += vec4(cos(normalize(abs(uv))*12.)*.5+.5,0.,1.0);\n        #endif\n\n        #ifdef VISUALIZE_CIRCLE_DF\n        float dist = (length(uv)-.5) + iTime*.03;\n        fragColor += vec4(sin(dist*3.5+.46),\n                         cos(dist*4.6),\n                         -sin(dist*8.6), 1.)*.5+.5;\n        #endif\n\n        #ifdef VISUALIZE_COOL\n        fragColor += vec4((cos(uv*10.)*.5+.5)*vec2(1.,.6)\n                        ,cos(length(uv)*4.)*.5+.5,1.);\n        #endif\n        \n    }\n    \n    fragColor /= float(SAMPLES);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 156, 156, 1117]], "test": "ok"}
{"id": "4ljXWK", "name": "2015/11/03", "author": "hughsk", "description": "SDFs", "tags": ["geometry"], "likes": 10, "viewed": 762, "published": "Public API", "date": "1446597454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 doModel(vec3 p, vec2 beats);\n\nvec2 calcRayIntersection_2_0(vec3 rayOrigin, vec3 rayDir, float maxd, float precis, vec2 beats) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 50; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = doModel(rayOrigin + rayDir * dist, beats);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_2_0(vec3 rayOrigin, vec3 rayDir, vec2 beats) {\n  return calcRayIntersection_2_0(rayOrigin, rayDir, 20.0, 0.001, beats);\n}\n\nvec3 calcNormal_3_1(vec3 pos, float eps, vec2 beats) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * doModel( pos + v1*eps, beats ).x +\n                    v2 * doModel( pos + v2*eps, beats ).x +\n                    v3 * doModel( pos + v3*eps, beats ).x +\n                    v4 * doModel( pos + v4*eps, beats ).x );\n}\n\nvec3 calcNormal_3_1(vec3 pos, vec2 beats) {\n  return calcNormal_3_1(pos, 0.002, beats);\n}\n\n\n\nfloat ao_1_2( in vec3 pos, in vec3 nor, vec2 beats )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float( i ) / 4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = doModel( aopos, beats ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nfloat orenNayarDiffuse_4_3(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;\n}\n\nvec2 squareFrame_9_4(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\n\n\nmat3 calcLookAtMatrix_11_5(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\n\n\nvec3 getRay_10_6(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_10_6(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_11_5(origin, target, 0.0);\n  return getRay_10_6(camMat, screenPos, lensLength);\n}\n\n\n\n\nvoid orbitCamera_5_7(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 fragCoord\n) {\n  vec2 screenPos = squareFrame_9_4(screenResolution, fragCoord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay_10_6(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\n\n\nfloat gaussianSpecular_6_8(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\n\n// Originally sourced from:\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdBox_7_9(vec3 position, vec3 dimensions) {\n  vec3 d = abs(position) - dimensions;\n\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\n\nfloat fogFactorExp2_8_10(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n\n\n  \n#define rs(a) (a * 0.5 + 0.5)\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n              oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n              oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n              0.0,                                0.0,                                0.0,                                1.0);\n}\n  \nfloat boxTiles(vec3 p, float r) {\n  float l = 0.3;\n  mat4 rot = rotationMatrix(normalize(vec3(1, 0, 1)), sin(iTime * 0.15) * 5.);\n  p = (rot * vec4(p, 1)).xyz;\n  p = mod(p + l, l * 2.) - l;\n  \n  return sdBox_7_9(p, vec3(r));\n}\n  \nvec2 doModel(vec3 p, vec2 beats) {\n  float d  = mix(length(p) - 2.0, sdBox_7_9(p, vec3(1.)), 0.5 + sin(iTime * 0.215) * 0.35);\n  float id = 0.0;\n  \n  d = max(d, -boxTiles(p, 0.15 + 0.125 * rs(sin(iTime))));\n  d = max(d, 1.35 - length(p));\n\n  return vec2(d, id);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 color = vec3(0.0);\n  vec3 ro, rd;\n\n  float rotation = sin(iTime * 0.25) * 0.5 + 1.5 + iMouse.x / iResolution.x * 6.;\n  float height   = 2.0 - (iMouse.y / iResolution.y - 0.25) * 10.;\n  float dist     = 4.0;\n  orbitCamera_5_7(rotation, height, dist, iResolution.xy, ro, rd, fragCoord);\n    \n  vec2 beats = vec2(0);\n  \n  color = mix(clamp(abs(rd * 2.), 0., 1.), vec3(1.0), 0.75);\n\n  vec2 t = calcRayIntersection_2_0(ro, rd, 10., 0.0001, beats);\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 nor = calcNormal_3_1(pos, beats);\n    vec3 mat = nor * 0.5 + 0.5;\n    vec3 dir = normalize(vec3(-0.5, 1, -0.15));\n    vec3 lcl = vec3(1.9, 1.75, 1.7);\n    vec3 col;\n    \n    float spec = gaussianSpecular_6_8(dir, -rd, nor, 0.3) * 0.33;\n    float diff = orenNayarDiffuse_4_3(dir, -rd, nor, 1.5, 1.1);\n    \n    col = mix(mat, lcl * (spec + diff * mat), 0.55);\n    col *= mix(0.75, 1.0, ao_1_2(pos, nor, beats));\n    \n    color = mix(col, color, fogFactorExp2_8_10(t.x, 0.15));\n  }\n  \n  color = pow(color, vec3(0.6545));\n\n  fragColor.rgb = color;\n  fragColor.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 133, 133, 531], [533, 533, 604, 604, 679], [681, 681, 735, 735, 1139], [1141, 1141, 1184, 1184, 1230], [1234, 1234, 1288, 1288, 1604], [1607, 1607, 1738, 1738, 2221], [2223, 2223, 2274, 2274, 2398], [2402, 2402, 2468, 2468, 2659], [2664, 2664, 2729, 2729, 2789], [2791, 2791, 2869, 2869, 2984], [2989, 2989, 3176, 3176, 3448], [3452, 3452, 3567, 3567, 3719], [3821, 3821, 3870, 3870, 3977], [3981, 3981, 4052, 4052, 4166], [4204, 4204, 4249, 4249, 4857], [4861, 4861, 4894, 4894, 5087], [5091, 5091, 5125, 5125, 5354], [5356, 5356, 5411, 5411, 6489]], "test": "error"}
{"id": "4llSRS", "name": "Vogel MetaBloom", "author": "jayjayjay", "description": "Exploring fibonacci numbers through the vogel distribution\n\nhttps://en.wikipedia.org/wiki/Fibonacci_number", "tags": ["vogeldistribution"], "likes": 1, "viewed": 188, "published": "Public", "date": "1447335058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define GA 2.39996322972865332\n\n#define N 50\n#define C sin(TIME)*1.3\n\n#define TIME iTime/5.\n\n#define RADIUS (C*.2)\n#define MIN_ZOOM 25.\n#define MAX_ZOOM 30.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5; //center the normal vector\n\n    uv *= MIN_ZOOM + ( sin(TIME) * (MAX_ZOOM-MIN_ZOOM) ); //zooming\n    \n    float m = 0.;\n    \n    for(int i=1;i<N;i++){\n        \n    \tfloat r = C * sqrt(float(i));\n        float theta = (2.0*PI*float(i))/(GA*GA);\n        \n        theta += TIME;\n        \n        vec2 pos = vec2(r*cos(theta),r*sin(theta));\n\n        //metaball, scaled by i/N\n        m+= RADIUS / dot(uv-pos,uv-pos) * float(i)/float(N);\n        \n    }\n    float u = (C+1.)/2.;\n    //fragColor = vec4(.5,.5,.5,1.0)+(m);\n    fragColor = vec4(-m/10.0,1.0,1.0,1.0)+(u)*(1.-m);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 240, 240, 871]], "test": "ok"}
{"id": "4lSXD3", "name": "plop 3", "author": "rcread", "description": "version of https://www.shadertoy.com/view/ltSSDV -> https://www.shadertoy.com/view/MlSSDV", "tags": ["2d"], "likes": 8, "viewed": 156, "published": "Public", "date": "1446749079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// version of https://www.shadertoy.com/view/ltSSDV -> https://www.shadertoy.com/view/MlSSDV\n\nvoid mainImage( out vec4 o,  vec2 U ) {\n    float t = iTime;\n    U = -2.5 + ( 3. + sin( t / 2.7 ) ) * 3. * ( U / iResolution.xy - .5 );\n    \n    for (int i=0; i<8; i++)\n    \tU += ( 1. + cos( U.yx * 3. + vec2(t,1.6))) / 3.,\n        U += ( 1. + sin( U.yx + t * 1.21 + vec2(1.6,0))) / 2.,\n        U *= 1.3;\n    \n    vec3 c = vec3( U.xy, ( U.x - U.y ) );\n    \n\to.xyz = (.02*c-.3)*1.5; // color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSXD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[221, 221, 260, 260, 612]], "test": "ok"}
{"id": "4lSXWR", "name": "Simple sphere dojo", "author": "pmilian", "description": "Simple shader to learn the basics of GLSL by displaying a sphere through ray marching and adding some lighting", "tags": ["sphereraymarchinglighting"], "likes": 2, "viewed": 205, "published": "Public", "date": "1447584959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float zNear = 1.0;\nconst float zFar = 400.0;\n\nconst float epsilon = 0.01;\n\nconst vec3 sphereCenter = vec3(0.5, 0.5, 100.0);\nconst float sphereRadius = 25.0;\n\n\nvec3 computeColor(in vec3 m, in vec3 ray, in vec3 normal, in vec3 light) {\n    vec3 baseColor = vec3(1.0, 0.0, 0.0);\n    \n    vec3 diffuseColor = vec3(0.5, 0.5, 0.5);\n    vec3 specularColor = vec3(0.3, 0.3, 0.3);\n    vec3 ambientColor = vec3(0.2, 0.2, 0.2);\n    \n    vec3 lightRay = normalize(m - light);\n    \n    float diffuseFactor = dot(normal, lightRay);\n    \n    vec3 ambient = baseColor * ambientColor;\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    \n    if (diffuseFactor > 0.0) {\n        diffuse = baseColor * diffuseColor * diffuseFactor;\n        \n        float shininess = 20.0;\n        float specularFactor = dot(ray, reflect(lightRay, normal));\n        if (specularFactor > 0.0) {\n       \t\tspecular = specularColor * pow(max(0.0, specularFactor), shininess);\n        }\n    }\n                             \n\treturn ambient + diffuse + specular;\n}\n\nfloat map(in vec3 m, out vec3 normal) {\n    normal = normalize(m - sphereCenter);\n \treturn length(sphereCenter - m) - sphereRadius;\n}\n\n\nbool raymarch(in vec3 origin, in vec3 dir, out vec3 normal, out vec3 hit) {\n\tfloat totalDist = 0.0;\n    vec3 m = vec3(origin);\n    \n    for (int i = 0; i < 50; i++) {\n        float dist = map(m, normal);\n        \n        totalDist += dist;\n        \n        if (dist < epsilon) {\n            hit = origin *  dir * totalDist;\n        \treturn true;   \n        }\n        \n        if (totalDist > zFar) {\n            return false;\n        }\n        \n        \n        m += dir * dist;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 viewportCoord = vec3(uv, zNear);\n    vec3 camera = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ray = normalize(viewportCoord - camera);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    vec3 light = sphereCenter - vec3(cos(iTime) * 30.0, 5.0, 100.0 + sin(iTime) * 20.0);\n    vec3 hit;\n\n    if (raymarch(camera, ray, normal, hit)) {\n        vec3 color = computeColor(hit, ray, normal, light);\n   \t\tfragColor = vec4(color, 1);     \n    } else {\n     \tfragColor = vec4(0.0, 0.0, 0.0, 1);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 239, 239, 1059], [1061, 1061, 1100, 1100, 1194], [1197, 1197, 1272, 1272, 1701], [1703, 1703, 1760, 1760, 2363]], "test": "ok"}
{"id": "4s33Dr", "name": "LineSegmentWave", "author": "jt", "description": "An obscure version of [url]https://www.shadertoy.com/view/llBSWt[/url]", "tags": ["small", "linesegment"], "likes": 1, "viewed": 103, "published": "Public", "date": "1448895764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Line Segment \"Wave\" written 2015 by JT\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    I = 2. * I / iResolution.xy - 1.;\n    o -= o;\n    vec4 Q = 2. * abs(2. * fract(iTime * vec4(.0432, .0123, .0257, .0332)) - 1.) - 1.;\n    Q.wz -= Q.xy;\n    o += cos(length(I - (Q.xy + Q.wz * clamp(dot(I - Q.xy, Q.wz) / dot(Q.wz, Q.wz), 0., 1.)))*25.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s33Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 84, 84, 341]], "test": "ok"}
{"id": "4s33Rn", "name": "Invaders, Invaders", "author": "movAX13h", "description": "I have stopped counting them.", "tags": ["invaders", "pseudofont"], "likes": 60, "viewed": 2401, "published": "Public API", "date": "1447550123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Invaders,Invaders, fragment shader by movAX13h, Nov.2015\n\n//vec3 color = vec3(0.2, 0.42, 0.68); // blue 1\n//vec3 color = vec3(0.1, 0.3, 0.6); // blue 2\nvec3 color = vec3(0.6, 0.1, 0.3); // red\n//vec3 color = vec3(0.1, 0.6, 0.3); // green\n\nfloat rand(float x) { return fract(sin(x) * 4358.5453123); }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357); }\n\nfloat invader(vec2 p, float n)\n{\n\tp.x = abs(p.x);\n\tp.y = floor(p.y - 5.0);\n    return step(p.x, 2.0) * step(1.0, floor(mod(n/(exp2(floor(p.x - 3.0*p.y))),2.0)));\n}\n\nfloat ring(vec2 uv, float rnd)\n{\n    float t = 0.6*(iTime+0.2*rnd);\n    float i = floor(t/2.0);\n    vec2 pos = 2.0*vec2(rand(i*0.123), rand(i*2.371))-1.0;\n\treturn smoothstep(0.2, 0.0, abs(length(uv-pos)-mod(t,2.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iMouse.z > 0.5) color = vec3(0.5, 0.3, 0.1);\n    \n    vec2 p = fragCoord.xy;\n\tvec2 uv = p / iResolution.xy - 0.5;\n    p.y += 120.0*iTime;\n    float r = rand(floor(p/8.0));\n    vec2 ip = mod(p,8.0)-4.0;\n    \n    float a = -0.3*smoothstep(0.1, 0.8, length(uv)) + \n        invader(ip, 809999.0*r) * (0.06 + 0.3*ring(uv,r) + max(0.0, 0.2*sin(10.0*r*iTime)));\n    \n\tfragColor = vec4(color+a, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s33Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 263, 263, 302], [303, 303, 324, 324, 392], [394, 394, 426, 426, 557], [559, 559, 591, 591, 777], [779, 779, 834, 834, 1237]], "test": "ok"}
{"id": "4s3GDr", "name": "Test haha", "author": "loucass003", "description": "hooo", "tags": ["test"], "likes": 3, "viewed": 115, "published": "Public", "date": "1448887695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define presi 0.0001\n#define it 50\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 center = vec2(iResolution.x/2., iResolution.y/2.);\n \t vec2 uv = fragCoord.xy / iResolution.xy;\n    /*\n   \n\tvec2 position = fragCoord.xy - center;\n        \n    fragColor = vec4(vec3(0.), 1.);    \n    for(float i = 0.; i < 5.; i++) {\n   \t\tfloat r1 = i * 20. + 80. + 0.5+10.0*sin(iTime);\n        float r2 = r1 + 20.;\n        if(length(position) > r1 + 0.8002 && length(position) < r2)\n            fragColor = vec4(uv,0.5+(3.* i + 1.)* sin(iTime),1.0);\n    }\n    float size = 55. + 0.5+10.0*sin(iTime);\n    if(fragCoord.x > center.x - size && fragCoord.x < center.x + size)\n        if(fragCoord.y > center.y - size && fragCoord.y < center.y + size)\n        fragColor = vec4(1.0);\n    */  \n        \n       \n    vec2 z = fragCoord.xy / iResolution.xy*2.0 - 1.0;\n   z.y*=iResolution.y/iResolution.x;\n   //z.x += sin(z.y*2.0+iTime * .2)/10.0;\n    z*= 1.2 + sin(iTime*.15);\n  //  z+=vec2(sin(iTime*.2),cos(iTime*.01));\n  //  z=vec2(z.x*cos(iTime*.2)- z.y*sin(iTime*.2),z.y*cos(iTime*.2)+ z.x*sin(iTime*.2));\n\tvec2 c=vec2(0.5, 1.1);\n    \n    float average=0.;\n    float l=length(z);\n    float prevl;\n    for (int i=0; i< it; i++)\n    {\n        z=abs(z)/dot(z,z) -c;\n\n        prevl=l;\n        l=length(z);\n\n        average+=abs(l-prevl);\n    }\n\n    average/=float(it) * 15.;\n\t\n    average+=iTime*0.08;\n \n    vec3 myColor=vec3(0.2,0.25,.62);\n    vec3 finalColor;\n \n    finalColor.r = (fract(float(average)/myColor.r));\n    finalColor.g = (fract(float(average)/myColor.g));\n    finalColor.b = (fract(float(average)/myColor.b));\n \n    \n    \n    fragColor = vec4(finalColor,1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3GDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 93, 1676]], "test": "ok"}
{"id": "4sc3RM", "name": "strip hide image illusion", "author": "FabriceNeyret2", "description": "pause the video for stronger effect.\nThe image is masked by the strip high-freq... but any blurring (motion, distance, unfocusing) fades the mask.", "tags": ["video", "illusion", "2tweets", "perception", "strip", "short"], "likes": 6, "viewed": 1024, "published": "Public API", "date": "1448512954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define L 8.   // interline distance\n#define A .25  // amplification factor\n\nvoid mainImage( out vec4 o,  vec2 uv )\n{\n    uv /= L;\n // float t = -10.*iMouse.x/iResolution.x;          // strips move with mouse   \n    float t = .5*iTime; t= 30.*(t+sin(t));    // strips move with time \n    t=fract(t); \n    float  x = floor(uv.x+.5+t)-t;\n\n    #define T texture(iChannel0,L*vec2(x,uv.y)/iResolution.xy)\n\n // o += 1.-cos(6.28*(uv.x-x)*(1.+A*(2.*T-1.))) -o;\n    o += cos( 6.28*(uv.x-x) * (1.-A*(2.*T-1.)) ) -o;    // modulates line thickness\n // o += cos( 6.28*(uv.x-x) + A*4.*(2.*T-1.) ) -o;      // modulates line offset\n\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sc3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 117, 117, 620]], "test": "error"}
{"id": "4sc3RN", "name": "Sea01", "author": "H3LLbot", "description": "sea", "tags": ["sea"], "likes": 0, "viewed": 568, "published": "Public API", "date": "1448279818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat distanceTo(float x, float y, float centerX, float centerY) {\n\tfloat deltaX = x - centerX;\n    float deltaY = y - centerY;\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{\n    float zoom = (iResolution.x / 10.0);// * (1.0 + 0.2 * cos(2.0 * iTime));\n    float cameraX = 5.0;  // + 4.0 * cos(iTime);\n    float cameraY = 2.0; // + 4.0 * sin(iTime * 1.1);\n    \n    float x = (pixCoords.x / zoom) - cameraX;\n    float y = (pixCoords.y / zoom) - cameraY;\n\n\n    \n    float PI = 3.1415;\n    float hauteurMoyenne = cos(iTime)+0.5;\n    float amplitude = .2;\n    float phase = iTime * 1.5;\n    float periode = cos(iTime)+7.0;\n    \n    \n    float fx = hauteurMoyenne + cos(x * 2.0 * PI/ periode + phase) * amplitude;\n    \n    if (y < fx) {\n        color = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    float fx2 = (hauteurMoyenne*1.2) + cos(0.5 * (x + iTime)) * 0.3;\n    \n    if (y < fx2) {\n        color = vec4(0.6, 0.6, 1.0, 1.0);\n        return;\n    }\n\t\n\n    color = vec4(0.0,0.0,0.3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sc3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 160, 160, 275], [277, 277, 330, 330, 1152]], "test": "ok"}
{"id": "4sc3zr", "name": "151113", "author": "dmmn", "description": "Candles", "tags": ["fire"], "likes": 0, "viewed": 88, "published": "Public", "date": "1447633025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.1415926535897932384626433832795\n\nstruct Voxel\n{\n  float dist;\n  vec4 color;\n};\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nVoxel smin( Voxel voxel1, Voxel voxel2, float blendRatio )\n{\n  float ratio = clamp(.5 + .5 * (voxel2.dist - voxel1.dist) / blendRatio, 0., 1.);\n\n  float dist = mix(voxel2.dist, voxel1.dist, ratio) - blendRatio * ratio * (1. - ratio);\n  vec4 color = mix(voxel2.color, voxel1.color, ratio);\n\n  return Voxel(dist, color);\n}\n\nVoxel minVoxel( Voxel voxel1, Voxel voxel2 )\n{\n  if(voxel1.dist - voxel2.dist < 0.) {\n    return voxel1;\n  }\n  else {\n    return voxel2;\n  }\n}\n\nVoxel maxVoxel( Voxel voxel1, Voxel voxel2 )\n{\n  if(voxel1.dist - voxel2.dist > 0.) {\n    return voxel1;\n  }\n  else {\n    return voxel2;\n  }\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nVoxel map( in vec3 p) {\n    \n    Voxel voxel = Voxel(1., vec4(.12, .1, 0., 1.));\n    \n    vec2 gridPosition = floor(p.xz + .5);\n    \n    float height = rand(gridPosition);\n    \n    vec3 positionOffset = vec3(0.0, 0.0, 2.0);\n    vec3 q = p;\n    q.xz = mod(p.xz + positionOffset.xz + 1.0, 2.0) - 1.0;\n    \n    q.y += height;\n    \n    Voxel candle = Voxel(sdCapsule(q, vec3(0., 1., 0.), vec3(0., -1., 0.), .1), vec4(1.) * (q.y - height + .3));\n    voxel = minVoxel(voxel, candle);\n    \n    Voxel plane = Voxel(p.y + 1.0, vec4(0.));                                    \n\tvoxel = smin(voxel, plane, .5);\n                                        \n    Voxel wick = Voxel(sdCappedCylinder(q + vec3(0., -1.2, 0.), vec2(.01, .2)), vec4(1.));\n\tvoxel = minVoxel(voxel, wick);\n    \n    return voxel;\n}\n\nVoxel mapCandles( in vec3 p) {\n    \n    Voxel voxel = Voxel(1., vec4(0.));\n    \n    vec2 gridPosition = floor(p.xz + .5);\n   \n    float height = rand(gridPosition);\n    \n    vec3 positionOffset = vec3(0.0, 0.0, 2.0);\n    vec3 q = p;\n    \n    q.xz = mod(p.xz + positionOffset.xz + 1.0, 2.0) - 1.0;\n    q.y += height;\n    \n    vec3 flamePosition = q + vec3(0., -1.5, 0.);\n    Voxel flame = Voxel(sdEllipsoid(flamePosition, vec3(.1, .4, .1)), vec4(1., .5, 0., 1.) + (.2 - flamePosition.x));\n    vec2 noiseOffset = flamePosition.xy;\n    noiseOffset.y = noiseOffset.y - iTime + gridPosition.x + gridPosition.y;\n    \n    Voxel flameHalo = flame;\n    \n    flame.dist += noise(noiseOffset * 10.) * .10;\n    voxel = minVoxel(voxel, flame);\n    \n    return voxel;\n}\n\nvec3 calcNormal ( vec3 p ) {\n  vec2 e = vec2(.0001, 0.0);\n  return normalize(vec3(\n    map(p + e.xyy).dist - map(p - e.xyy).dist,\n    map(p + e.yxy).dist - map(p - e.yxy).dist,\n    map(p + e.yyx).dist - map(p - e.yyx).dist\n  ));\n}\n\nvec3 calcNormalCandles ( vec3 p ) {\n  vec2 e = vec2(.0001, 0.0);\n  return normalize(vec3(\n    mapCandles(p + e.xyy).dist - mapCandles(p - e.xyy).dist,\n    mapCandles(p + e.yxy).dist - mapCandles(p - e.yxy).dist,\n    mapCandles(p + e.yyx).dist - mapCandles(p - e.yyx).dist\n  ));\n}\n\nVoxel rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n  Voxel voxel = Voxel(0., vec4(0.0));\n\n  float rayMarchingStep = 0.001;\n  float dist = .1;\n\n  for(int i = 0; i < 64; i++) {\n    if (rayMarchingStep < 0.001 || dist > 100.) break;\n    voxel = map(rayOrigin + rayDirection * dist);\n    rayMarchingStep = voxel.dist;\n    dist += rayMarchingStep;\n  }\n\n  vec3 normal = calcNormal(rayOrigin + rayDirection * dist);\n  voxel.color *= 1.7 + dot(normal, normalize(vec3(1., 1., 1.)));\n\n  return voxel;\n}\n\nVoxel rayMarchCandles(vec3 rayOrigin, vec3 rayDirection)\n{\n  Voxel voxel = Voxel(0., vec4(0.0));\n\n  float rayMarchingStep = 0.001;\n  float dist = .1;\n\n  for(int i = 0; i < 64; i++) {\n    if (rayMarchingStep < 0.001 || dist > 100.) break;\n    voxel = mapCandles(rayOrigin + rayDirection * dist);\n    rayMarchingStep = voxel.dist;\n    dist += rayMarchingStep;\n  }\n\n  vec3 normal = calcNormalCandles(rayOrigin + rayDirection * dist);\n  voxel.color *= 2. + dot(normal, normalize(vec3(1., 1., 1.)));\n\n  return voxel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 2., -iTime);\n    vec3 rd = normalize( vec3( p, 1.0 ));\n    float rotation = (1.0 - (iMouse.x / iResolution.x) * 2.0) * PI;\n    vec3 direction = vec3(cos(rotation + PI * .5), -.4, sin(rotation + PI * .5));\n    rd = normalize(direction + vec3( cos(rotation) * p.x, p.y, sin(rotation) * p.x ));\n    \n    Voxel voxel = rayMarch(ro, rd);\n    \n    voxel.color += rayMarchCandles(ro, rd).color;\n    \n\tfragColor = vec4(voxel.color.rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sc3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 136, 136, 235], [237, 237, 289, 289, 416], [418, 418, 461, 461, 521], [523, 523, 583, 583, 843], [845, 845, 891, 891, 987], [989, 989, 1035, 1035, 1131], [1133, 1133, 1153, 1153, 1223], [1225, 1225, 1245, 1245, 1480], [1482, 1482, 1505, 1505, 2268], [2270, 2270, 2300, 2300, 3025], [3027, 3027, 3055, 3055, 3257], [3259, 3259, 3294, 3294, 3538], [3540, 3540, 3591, 3591, 4033], [4035, 4035, 4093, 4093, 4548], [4550, 4550, 4607, 4607, 5183]], "test": "ok"}
{"id": "4sd3Rn", "name": "Holcombe's Variation", "author": "mikepfrank", "description": "Make sound and watch it change", "tags": ["fractal", "audio"], "likes": 2, "viewed": 193, "published": "Public", "date": "1447729092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265359\n\n//#define iTime tan(iTime*.1)+iTime*.1\n\nfloat bassBoostLow = 0.0;\nfloat bassBoostHigh = 0.0;\nfloat time = 0.0;\n\nvec3 hsv(in float h, in float s, in float v)\n{\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 formula(in vec2 p, in vec2 c)\n{\n\tconst float n = 2.0;\n\tconst int iters = 5;\n\n\t//float time = iTime*0.1;\n\tvec3 col = vec3(0);\n\tfloat t = 1.0;\n\tfloat dpp = dot(p, p);\n\tfloat lp = sqrt(dpp);\n\tfloat r = smoothstep(0.0, 0.2, lp);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t// The transformation\n        //p+=vec2(sin(c.x+p.x)*.01,\n        //        cos(c.y+p.y)*.01);\n        float to = bassBoostHigh;\n        float index = mod(float(i)*1234.1234, 2.0);\n        \n        \n        if(index < .1)\n        {\n        \tp = p*mat2(cos(cos(time+to)+time+to), -sin(cos(time+to)+time+to),\n                   sin(cos(time+to)+time+to), cos(cos(time+to)+time+to));\n\t\t\tp = abs(mod(p*(1.0) + c, n) - (n)/2.0);\n        }\n        else if(index < 1.1)\n\t\t\tp = abs(mod(p*(1.0) + c, n) - (n)/2.0);//mod(p/dpp + c, n) - n/2.0;\n        else if(index < 2.1)\n\t\t\tp = p+to;\n\t\t\n\t\tdpp = dot(p, p);\n        p /= dpp;\n\t\tlp = pow(dpp, 1.5);\n        \n        \n        //if(int(14.0*sin(iTime))+iters < i) break;\n\n\t\t//Shade the lines of symmetry black\n#if 0\n\t\t// Get constant width lines with fwidth()\n\t\tfloat nd = fwidth(dpp);\n\t\tfloat md = fwidth(lp);\n\t\tt *= smoothstep(0.0, 0.5, abs((n/2.0-p.x)/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs((n/2.0-p.y)/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs(p.x/md))\n\t\t   * smoothstep(0.0, 0.5, abs(p.y/md));\n#else\n\t\t// Variable width lines\n\t\tt *= smoothstep(0.0, 0.01, abs(n/2.0-p.x)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(n/2.0-p.y)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(p.x)*2.0) \n\t\t   * smoothstep(0.0, 0.01, abs(p.y)*2.0);\n#endif\n\n\t\t// Fade out the high density areas, they just look like noise\n\t\tr *= smoothstep(0.0, 0.2, lp);\n\t\t\n\t\t// Add to colour using hsv\n\t\tcol += lp+bassBoostHigh;\n\t\t\n\t}\n\t\n\tcol = vec3(sin(col.x+time*.125),\n\t\t\t   cos(col.y+time*.125+4.0*pi/3.0),\n\t\t\t   sin(col.z+time*.125+2.0*pi/3.0))*.5+.5;\n    \n\treturn col*t;\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 1; i < iters/2; i++)\n    {\n        next = length(texture(iChannel0, vec2(float(i)/float(iters), 0.0)));\n        sum += last;//pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum/float(iters)*2.0;\n}\n\nfloat highAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 17; i < iters; i++)\n    {\n        next = length(texture(iChannel0, vec2(float(i)/float(iters), 0.0)));\n        sum += last;//pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum/float(iters)*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    bassBoostLow += lowAverage()*1.0;\n    bassBoostHigh += highAverage()*1.0;\n    time = iTime+bassBoostLow*8.0*pi;\n    \n    p += .125;\n    \n    p += .5*vec2(cos(time), sin(time));\n    \n\tp.x *= iResolution.x / iResolution.y;\n\tp *= 1.5+1.125*sin(time*.25);\n    \n\tconst vec2 e = vec2(0.06545465634, -0.05346356485);\n\tvec2 c = time*e;\n\t//c = 8.0*iMouse.xy/iResolution.xy;\n\tfloat d = 1.0;\n\tvec3 col = vec3(0.0);\n\tconst float blursamples = 4.0;\n\tfloat sbs = sqrt(blursamples);\n\tfloat mbluramount = 1.0/iResolution.x/length(e)/blursamples*2.0;\n\tfloat aabluramount = 1.0/iResolution.x/sbs*4.0;\n\tfor (float b = 0.0; b < blursamples; b++) {\n\t\tcol += formula(\n\t\t\tp + vec2(mod(b, sbs)*aabluramount, b/sbs*aabluramount), \n\t\t\tc + e*mbluramount*b);\n\t}\n\tcol /= blursamples;\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sd3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 184, 184, 292], [294, 294, 330, 330, 2124], [2126, 2126, 2146, 2146, 2500], [2502, 2502, 2523, 2523, 2876], [2878, 2878, 2935, 2935, 3784]], "test": "error"}
{"id": "4sdGR8", "name": "Ring Sequence", "author": "jameswilddev", "description": "There ain't nothing I like stretching too far than a technique, except a joke.", "tags": ["infinite"], "likes": 9, "viewed": 166, "published": "Public", "date": "1448063133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 chequer(vec2 uv) {\n    uv = fract(uv);\n    return uv.x > 0.5 != uv.y > 0.5 ? vec3(0.6, 0.6, 1.0) : vec3(1.0, 1.0, 0.6);\n}\n\n#define PI 3.14159265359\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n/* \n   These functions take a \"camera\" variable specifying:\n     X/Y: Where on the screen we are rendering.\n     Z: How far forwards we are.\n   And return:\n     X/Y: UVs you can use for texture mapping.\n     Z: How far the pixel is.\n*/\n\n/* A wall directly in front of you. */\nvec3 planeZ(float z, vec3 camera) {\n    z -= camera.z;\n    return vec3(camera.xy * z, z);\n}\n\n/* Parallel walls to the left/right of you. */\nvec3 planeX(float x, vec3 camera) {\n    float divisor = x / camera.x;\n    return vec3(camera.y * divisor, abs(divisor) + camera.z, abs(divisor));\n}\n        \n/* Parallel floor and ceiling. */\nvec3 planeY(float y, vec3 camera) {\n    float divisor = y / -camera.y;\n    return vec3(camera.x * divisor, abs(divisor) + camera.z, abs(divisor));\n}\n\n/* \n\tParallel walls to the left/right of you. \n\tLines up with tunnels.\n*/\nvec3 planeXForTunnel(float x, vec3 camera) {\n    float divisor = x / camera.x;\n    return vec3(camera.y * divisor + (camera.x > 0.0 ? 0.0 : (camera.y > 0.0 ? 2.0 : -2.0)), abs(divisor) + camera.z, abs(divisor));\n}\n        \n/* \n\tParallel floor and ceiling. \n\tLines up with tunnels.\n*/\nvec3 planeYForTunnel(float y, vec3 camera) {\n    float divisor = y / -camera.y;\n    return vec3(camera.x * divisor + (camera.y > 0.0 ? 1.0 : -1.0), abs(divisor) + camera.z, abs(divisor));\n}\n\n/* A round tunnel. */\nvec3 tunnel(float radius, vec3 camera) {\n    float dist = radius / length(camera.xy);\n    return vec3(atan(camera.y, camera.x) * radius / HalfPI, dist + camera.z, dist);\n}\n\n/* Similar to planeZ, but matches up with tunnel. */\nvec3 tunnelEnd(float z, float radius, vec3 camera) {\n    float angle = atan(camera.x, camera.y);\n    float dist = length(camera.xy);\n    return vec3(angle * radius / HalfPI, dist * (z - camera.z), z - camera.z);\n}\n\n/* -------------------------------------------------------- */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectNdc = (fragCoord.xy - (iResolution.xy / 2.0)) / (min(iResolution.x, iResolution.y) / 2.0);\n \n   \n    vec4 mouse = (iMouse.xyzw - (iResolution.xyxy / 2.0)) / min(iResolution.x, iResolution.y);\n    if(iMouse.z <= 0.0) mouse = vec4(0.0);\n    mouse *= 2.0;\n    aspectNdc -= mouse.xy;\n    aspectNdc /= 1.0 + dot(mouse.xy, aspectNdc);\n\n    \n    vec3 camera = vec3(aspectNdc, iTime);\n    \n\tvec3 ringInside = tunnel(1.0, camera);\n    \n    vec3 ringFront = tunnelEnd(floor(ringInside.y) + 1.0, 1.0, camera);\n    \n    vec3 wall = planeX(2.0, camera);\n    \n    vec3 pillarSide = planeX(3.0, camera);\n    vec3 pillarFront = planeZ(floor(pillarSide.y) + 0.75, camera);\n    \n    vec3 sea = planeY(1.0, camera);\n\n    vec3 compute;\n    \n    if(fract(ringInside.y) < 0.25) {\n        compute = ringInside;\n    } else {\n        if(ringFront.y < 1.2) {\n            compute = ringFront;\n        } else {\n            if(abs(sea.x) > 2.0) {\n                if(fract(pillarSide.y) > 0.75) {\n                    if(abs(pillarSide.x) < 1.0) {\n                        compute = pillarSide;\n                    } else {\n                        compute = sea;\n                    }\n                } else {\n                    if(abs(pillarFront.y) < 1.0) {\n                        if(abs(pillarFront.x) < 3.5) {\n                            compute = pillarFront;\n                        } else {\n                            compute = sea;\n                        }\n                    } else {\n                        compute = sea;\n                    }\n                }\n            } else {\n                compute = wall;\n            }\n        }\n    }\n   \n    \n\tfragColor = vec4(mix(vec3(0.8, 0.9, 1.0), mix(vec3(0.6, 0.7, 1.0), chequer(compute.xy) / (1.0 + compute.z * 0.5), 1.0 / (1.0 + compute.z * 0.2)), 1.0 / (1.0 + compute.z * 0.05)), 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 126], [473, 512, 547, 547, 603], [605, 652, 687, 687, 799], [809, 843, 878, 878, 991], [993, 1067, 1111, 1111, 1280], [1290, 1351, 1395, 1395, 1540], [1542, 1564, 1604, 1604, 1735], [1737, 1790, 1842, 1842, 2003], [2069, 2069, 2126, 2126, 3966]], "test": "ok"}
{"id": "4sdGRM", "name": "Chapter 5 - drawing", "author": "hamoid", "description": "Learning from the book of shaders", "tags": ["2d", "learning"], "likes": 4, "viewed": 133, "published": "Public", "date": "1448624601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define MODE6\n\n// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct){\n  return smoothstep( pct-0.2, pct, st.y) - \n         smoothstep( pct, pct+0.01, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Interactive mouse x\n    #ifdef MODE0\n    float y = 0.5 + 0.5 * sin(uv.x * 2.0 * PI);\n    y = pow(y, iMouse.x / 50.0);\n    y = step(0.5, y);\n    y = smoothstep(0.45, 0.55, y);\n    #endif\n\n    #ifdef MODE1\n    float y = smoothstep(0.4,0.5,uv.x) - smoothstep(0.5,0.6,uv.x);\n    #endif\n    \n    #ifdef MODE2\n    float y = 0.5 + 0.5*sin(sin(uv.x*PI)*sin(uv.x * uv.x - iTime));\n    #endif\n    \n    #ifdef MODE3\n    float y = fract(3.0 * sin(uv.y + iTime) * 3.0 * sin(uv.x*6.0 - iTime));\n    #endif\n\n    // rombos\n    #ifdef MODE4\n    float y = 0.5 * sin(10.0 * uv.y + iTime) + \n              0.5 * sin(60.0 * uv.x - iTime);\n    //threshold for rombos\n    y = ceil(y) + floor(y);\n    #endif\n\n    // glass courtain\n    #ifdef MODE5\n    float x = uv.x * 8.0;\n    float y = fract(x + iTime) * ceil(x) * 0.3;\n    y = y - 0.1 * floor(x * 0.4 + uv.y) *  abs(uv.y*3.0);\n    y = y * 0.5;\n    #endif\n\n\n\t// crocodile lsd\n    #ifdef MODE6\n\tfloat d = 40.0 * distance(uv, vec2(0.5));\n\tfloat y = 0.5 + \n      0.25 * sin(uv.x * d) + \n      0.25 * sin(uv.y * d);\n    y = mod(y * 5.0 + iTime, 1.0);\n    y = smoothstep(0.1, 0.5, y) - smoothstep(0.5, 0.8, y);\n\t#endif\n    \n    \n    // get angle -PI ~ PI\n    #ifdef MODE7\n    vec2 toCenter = vec2(0.5) - uv;\n    float a = atan(toCenter.y, toCenter.x);\n    float y = 0.5 + 0.5 * a / PI;\n    y = mod(y * 5.0 + iTime * 0.2, 1.0);    \n    vec3 color = vec3(y);    \n    float pct = plot(uv, y);\n    color = (1.0 - pct) * color +\n        pct * vec3(sin(a), \n                   sin(a+1.0),\n                   sin(a+2.0));\n   \t#else\n        vec3 color = vec3(y);    \n\t#endif\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 90, 121, 121, 210], [212, 212, 269, 269, 1954]], "test": "ok"}
{"id": "4sdGRn", "name": "Dance Party", "author": "dirkadirkadan", "description": "Hmm", "tags": ["noise", "raymarch", "reflections"], "likes": 2, "viewed": 148, "published": "Public", "date": "1447717080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_ITER 50\n#define MAX_BOUNCES 4\n#define EPS .001\n#define STEP .4\n#define Scale 2.\n#define Offset .3\n#define DIST iMouse.y*.1\n#define FRACT_ITER 9\n#define X_EPS .001\n#define Y_EPS X_EPS\nvec3 mat;\n\nfloat seed = 0.0;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nfloat ground(vec3 p, float height)\n{\n    return p.y - height;//+.2*sin(p.z*3.);\n}\n\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n    return length(p-center) - radius;\n}\n\nfloat column(vec3 p, vec3 center, float height, float radius)\n{\n    return length((p-center).xz)-radius;\n}\n\nfloat fbm(vec2 p)\n{\n    float c = cos(.45);\n    float s = sin(.45);\n    \n    p.x *= .2;\n    \n    mat2 m = mat2(c, -s, s, c);\n    p+=vec2(1.5);\n    \n    float a = 1.5;\n    float f = .132;\n    float l = 7.5;\n    float g = .635;\n    float x = .0;\n    for (int i = 0; i < 7; i++)\n    {\n   \t\tx += a*texture(iChannel0, p*f).r;\n        p *= m * 2.;\n        a *= g;\n        f *= l;\n    }\n    \n    return x;\n}\n\nfloat de(in vec3 p)\n{\n    float s1 = sphere(p, vec3(0., sin(iTime), .0), .5);\n    float orbit_radius = 1.3;\n    float s2_angle = iTime*3.;\n    float s2 = sphere(p, vec3(orbit_radius*cos(s2_angle), \n                              1., orbit_radius*sin(s2_angle)), .5);\n    float f = ground(p, -.7);\n    float c = column(mod(p, 8.)-4., vec3(2.), 5., .5);\n    \n    vec3 scol = vec3(1., .6, .3);\n    \n    vec2 st = sin(3.14159*p.xz/1.);\n    float tile=step(st.x*st.y,0.);\n    vec3 fcol = .5*vec3((tile+1.)* fbm(p.xz));\n    \n    vec3 ccol = vec3(1., 0., 0.);\n\n    float d = min(s1, f);\n    d = min(d, s2);\n    d = min(d, c);\n    float factor = step(f, s1);\n    mat = scol*(1.-factor) + fcol*factor;\n    factor = step(s2, d);\n    mat = mat*(1.-factor) + ccol*factor;\n    factor = step(c, d);\n    mat = mat*(1.-factor) + ccol*factor;\n    return d;\n    \n}\n\nvec3 normal(vec3 p)\n{\n    float d = de(p);\n    \n    float x = de(vec3(p.x+EPS, p.y, p.z)) - d;\n    float y = de(vec3(p.x, p.y+EPS, p.z)) - d;\n    float z = de(vec3(p.x, p.y, p.z+EPS)) - d;\n    \n    return normalize(vec3(x, y, z));\n}\n\nvec3 light(vec3 norm)\n{\n    vec3 light_dir = normalize(vec3(-1.));\n    \n    return vec3(.15)+vec3(1.)*mat*clamp(dot(light_dir, -norm), .0, 1.);\n}\n\nfloat ao(vec3 p, vec3 norm)\n{\n    return .3+clamp(de(p+norm*.2), 0., 1.);   \n}\n\n\nvoid trace(vec3 ro, vec3 rd, inout vec3 col)\n{\n    float tot_d = 0.;\n    float d = 0.;\n    \n    for (int j = 0; j < MAX_BOUNCES; j++)\n    {\n        for (int i = 0; i < MAX_ITER; i++)\n        {\n            vec3 pt = ro+rd*d;\n\n            float s = de(pt);\n            d += STEP*s;\n\n            if (s < EPS)\n            {\n                tot_d += d;\n                vec3 norm = normal(pt);\n                col += light(norm) * ao(pt, norm) * exp(-tot_d*tot_d*.01);\n                rd = reflect(rd, -norm);\n                ro = pt + rd *EPS;\n                d = 0.;\n                break;\n            }\n        }\n       \n        \n    }\n    \n}\n\nvec3 color(vec2 uv)\n{\n    vec3 ro = vec3(0., 0., 1.5+DIST);\n    vec3 rd = normalize(vec3(uv, -1.));\n    \n    vec3 col = vec3(0.);\n\n    trace(ro, rd, col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy -iResolution.xy)/ iResolution.y;\n\t\n    vec3 c;\n   /* \n    c = color(uv)+\n             color(uv+X_EPS)+\n             color(uv+Y_EPS)+\n             color(uv-X_EPS)+\n             color(uv-Y_EPS);\n    c /= 4.;\n    \n    \n    fragColor = vec4(c,1.);\n    */\n    \n    float gamma = 2.75;\n    c = color(uv);\n    c = pow(c, vec3(gamma));\n    \n    fragColor = vec4(c, 1.);\n    \n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 239, 239, 282], [284, 284, 320, 320, 365], [367, 367, 416, 416, 456], [458, 458, 521, 521, 564], [566, 566, 585, 585, 966], [968, 968, 989, 989, 1813], [1815, 1815, 1836, 1836, 2047], [2049, 2049, 2072, 2072, 2194], [2196, 2196, 2225, 2225, 2274], [2277, 2277, 2323, 2323, 2916], [2918, 2918, 2939, 2939, 3095], [3097, 3097, 3154, 3154, 3551]], "test": "error"}
{"id": "4sdGRr", "name": "unicorn crystal puke", "author": "nicoptere", "description": "one has to start somewhere...", "tags": ["voronoi", "cells"], "likes": 19, "viewed": 362, "published": "Public", "date": "1447759844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat hash(in float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time = iTime;\n    \n    //\"squarified\" coordinates \n\n\tvec2 xy = ( 2.* fragCoord -iResolution.xy ) / iResolution.y ;\n\n    //rotating light \n    vec3 lightDir = vec3( sin( time ), 1., cos( time * .5 ) );\n    \n    const float count = 200.;\n    \n    vec3 pp = vec3(0.);\n    float length = 1e10;\n    for( float i = 0.; i < count; i+=1. )\n    {\n        //random cell\n        float an = sin( time * PI * .00001 ) - hash( i ) * PI * 2.;\n        float ra = sqrt( hash( an ) );\n\n    \tvec2 p = vec2( lightDir.x + cos( an ) * ra, lightDir.z + sin( an ) * ra );\n\n        //finds the closest cell center from XY coords\n        float di = distance( xy, p );\n        length = min( length, di );\n        if( length == di )\n        {\n            pp.xy = p;\n            pp.z = i / count * ( xy.y*xy.x );\n        }\n    }\n\n    //shimmy shake\n    fragColor = vec4( pp + vec3( 1.) * ( 1.- max( 0.0, dot( pp, lightDir)) ), 1. );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 70, 70, 112], [114, 114, 171, 171, 1089]], "test": "ok"}
{"id": "4sdGz7", "name": "Electric Jelly", "author": "gdschmdt", "description": "Prototyping for illumination of the protestant church in Hockenheim, November 2015", "tags": ["red", "prototyping", "cyan"], "likes": 5, "viewed": 627, "published": "Public", "date": "1448669236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI   = 3.141519;\nconst float dots = 12.0;\n\n// Conver HSV/HSB color to RGB\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float time = iTime/5.0;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv -= 0.5;\n  vec3 color = vec3(0.0);\n\n  // Create 12 single dots\n  for(float i=0.0; i < dots; i++) {\n    float radius = 0.2;\n    vec2 dotPosition = vec2(radius * cos(2.0 * PI * i/dots + time/2.0),\n                            radius * sin(2.0 * PI * i/dots + time));\n    // dotRadius and trignometric function to create wafting effect\n    float dotRadius = 0.02 * (sin(time * PI/2.0 * i) + 2.0);\n    vec3 dotColor = hsv2rgb(vec3((i + time*10.)/dots,1.,1.0));\n    // Add dots to main color output\n    color += dotRadius/length(uv - dotPosition) * dotColor;\n  }\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 107, 128, 128, 291], [293, 293, 348, 348, 1013]], "test": "ok"}
{"id": "4sdGzr", "name": "Test Plane Helix", "author": "Orace", "description": "http://www.pouet.net/topic.php?which=4161&page=245", "tags": ["test"], "likes": 2, "viewed": 357, "published": "Public", "date": "1447778370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float BLADE       = 5.0;\nconst float BLADE_RADIUS  = 0.5;\nconst float SCAN_SPEED  = 4.5;\nconst float SCAN_LINE   = 1.0;\n\n\nconst float TAU         = 6.2831853;\nconst vec2 CENTER       = vec2(0.5,0.5);\nconst vec4 BLACK        = vec4(0.0,0.0,0.0,1.0);\nconst vec4 BLUE         = vec4(0.0,0.0,1.0,1.0);\n\nbool bladeBorder(vec2 uv, float r, inout vec4 fragColor)\n{\n    float cur_radius = length(uv)/BLADE_RADIUS;\n    if (cur_radius < r)\n    {\n        if (length(cur_radius - r) < 0.04)\n        {\n            fragColor = vec4(0.2,0.6,.4,1.0);\n        }\n        return true;\n    }\n    return false;\n}\n\nbool bladeColor(vec2 uv, float r, inout vec4 fragColor)\n{\n    float cur_radius = length(uv)/BLADE_RADIUS;\n    if (cur_radius < r)\n    {\n        if (length(cur_radius - r) < 0.04)\n        {\n            fragColor = vec4(0.2,0.6,.4,1.0);\n        }\n        else\n        {\n\t\t\tfragColor = vec4(1.0,0.0,0.0,1.0);\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(0.0,0.0);\n    vec2 center =  iResolution.xy/2.0;\n    \n    float m = min(iResolution.x, iResolution.y);\n    uv = (fragCoord-center)/m;\n    \n    float time = iTime/4.0;    \n    \n    float t = atan(uv.y, uv.x);\n    \n    float dt1 = uv.y;    \n    float dt2 = mod(time, TAU*BLADE);\n    \n    float t1 = (t + dt1) * BLADE;\n    float t2 = (t + dt2) * BLADE;\n    \n    float dl = mod(t1 - t2, TAU);\n    float dl2 = mod(t1 - t2, 2.0 * TAU);\n    \n    if (length(dl)*iResolution.y < 2.0)\n    {\n        fragColor = BLUE;\n    }\n    else\n    {       \n        float r1 = cos(t1);\n        float r2 = cos(t2);\n        \n        if (dl >= dl2)\n        {\n            \n            if (!bladeColor(uv, r1, fragColor))\n            if (!bladeBorder(uv, r2, fragColor))\n                fragColor = BLACK;\n        }\n        else\n        {\n            \n            if (!bladeColor(uv, r2, fragColor))\n            if (!bladeBorder(uv, r1, fragColor))\n                fragColor = BLACK;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 363, 363, 597], [599, 599, 656, 656, 961], [963, 963, 1020, 1020, 2013]], "test": "ok"}
{"id": "4st3R7", "name": "TruchetFlip", "author": "jt", "description": "Another truchet-tiles shader - just playing around with flipping the configuration randomly.", "tags": ["truchettiles"], "likes": 18, "viewed": 421, "published": "Public", "date": "1448663264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Truchet Tiles - written 2015 by JT\n\n/*\n// Compact version (325 chars) by FabriceNeyret2\nfloat t = iTime;\n#define R(s) texture(iChannel0, s + t/1e3).x\n#define S(v) smoothstep(.0,.05, abs(len(v)-.5)) \n\nfloat len(vec2 v) {\n    float w = 5./(1.+abs(8.*fract(t/16.)-4.));\n    v = pow(v, vec2(w));\n    return pow(v.x+v.y, 1./w);\n}\n\n\nvoid mainImage( out vec4 O,  vec2 v ) {\n    v *= 10./iResolution.y;\n    v.x *= sign( R(ceil(v)/ 128.) - .5 );\n\n    O -= S(v=fract(v))*S(1.-v) + O++;\n}\n*/\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat rnd(vec2 seed)\n{\n    return texture(iChannel0, seed + iTime*0.001).x;\n}\n\nfloat len(vec2 v)\n{\n    float w = 1.25/(.25+mirror(iTime*.125));\n    return pow(dot(pow(v, vec2(w)), vec2(1)), 1./w);\n}\n\nfloat flip(vec2 v, float w)\n{\n    v = fract(v / 2.) - .5;\n    return mix(w, 1. - w, step(0., v.x * v.y));\n}\n\nfloat tile(vec2 v)\n{\n    v = fract(v);\n    return smoothstep(.0,.05, abs(len(v)-.5)) * smoothstep(.0,.05, abs(len(1.-v)-.5));\n}\n\nfloat tile_full(vec2 v)\n{\n    v = fract(v);\n    return smoothstep(.45,.55, len(v)) * smoothstep(.45,.55, len(1.-v));\n}\n\nfloat pattern(vec2 v)\n{\n    vec2 id = floor(v);\n    return mix(\n        flip(v, rnd(id / 128.) < .5 ? 1.-tile_full(v) : tile_full(vec2(1.-v.x,v.y))),\n        1.-(rnd(id / 128.) < .5 ? tile(v) : tile(vec2(1.-v.x,v.y))),\n        mirror(iTime*.01));\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n\tI /= iResolution.y;\n    float p = 1.-pattern(I*10.);\n    O = vec4(p);\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4st3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 555, 555, 610], [612, 612, 631, 631, 731], [733, 733, 762, 762, 840], [842, 842, 862, 862, 969], [971, 971, 996, 996, 1089], [1091, 1091, 1114, 1114, 1339], [1341, 1341, 1382, 1382, 1455]], "test": "error"}
{"id": "4st3Rn", "name": "Flow Of Goods", "author": "movAX13h", "description": "From one of those superfancy Euclideon videos... https://youtu.be/Irf-HJ4fBls?t=184\nI know, I should look into translucent raymarching... feel free to enhance this, if you like.", "tags": ["raymarcher", "visualisation"], "likes": 19, "viewed": 1294, "published": "Public API", "date": "1447782493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Flow of goods, fragment shader by movAX13h, Nov.2015\n\n#define SHADOW\n#define EDGES\n#define SUN_POS vec3(15.0, 15.0, -8.0)\n\n#define GAMMA 2.2\n\n//---\nfloat sdBox(vec3 p, vec3 b)\n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+q.y*0.5,q.y)-h.x);\n}\n\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\n// globals\nfloat T;\nvec3 sun = normalize(SUN_POS);\nconst float focus = 5.0;\nconst float far = 50.0;\nconst vec3 green = vec3(0.2, 1.0, 0.9);\nconst vec3 red = vec3(0.9, 0.3, 0.3);\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 col;\n};\n\nHit scene(vec3 p)\n{\n    Hit hit = Hit(1e6,vec3(0.01));\n    if (p.z > 4.0) return hit;\n    \n    vec3 r = p;\n    float side = sign(p.z);\n\tvec3 c = mix(green,red,side);\n    \n    p.x = mod(-side*p.x-3.0*iTime,5.5)-2.75;\n\tp.z = mod(p.z, 6.0)-3.0;\n    \n    hit.d = sdBox(p-vec3(0.0, -0.9, 0.0), vec3(8.0, 0.2, 1.3)); // road\n    float arrow = smoothstep(0.6, 0.65, abs(mod(side*r.x, 2.6)-0.6-abs(p.z)));\n    hit.col = mix(hit.col, green, arrow*(0.4 + max(0.0, 0.6*sin(0.1*r.x+side*4.0*iTime))));\n    hit.col = mix(hit.col, vec3(1.0), smoothstep(0.5, 1.9, abs(p.z)));\n        \n    float t = sdHexPrism(p-vec3(1.1, -0.1, 0.0), vec2(0.3, 0.3)); // truck\n    t = min(t, sdBox(p-vec3(0.0, 0.0, 0.0), vec3(0.9, 0.4, 0.4)));\n    t = min(t, sdBox(p-vec3(1.35, -0.3, 0.0), vec3(0.1, 0.2, 0.3)));\n    t = min(t, sdBox(p-vec3(-0.8, -0.3, 0.0), vec3(0.1, 0.2, 0.4)));\n    if (t < hit.d) { hit = Hit(t,vec3(1.0)); }\n    \n    vec3 q = p-vec3(0.19, 0.0, 0.0); // arrow\n    q.xy = rotate(q.xy, -0.5);\n    t = sdTriPrism(q, vec2(0.2, 0.41));\n    t = min(t, sdBox(p-vec3(-0.14, 0.0, 0.0), vec3(0.25, 0.1, 0.41)));\n    if (t < hit.d) { hit = Hit(t,c); }\n    \n\treturn hit;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\nfloat edges(vec3 p) // by srtuss\n{\n\tfloat acc = 0.0;\n\tfloat h = 0.01;\n\tacc += scene(p + vec3(-h, -h, -h)).d;\n\tacc += scene(p + vec3(-h, -h, +h)).d;\n\tacc += scene(p + vec3(-h, +h, -h)).d;\n\tacc += scene(p + vec3(-h, +h, +h)).d;\n\tacc += scene(p + vec3(+h, -h, -h)).d;\n\tacc += scene(p + vec3(+h, -h, +h)).d;\n\tacc += scene(p + vec3(+h, +h, -h)).d;\n\tacc += scene(p + vec3(+h, +h, +h)).d;\n\treturn acc / h;\n}\n\nvec3 colorize(Hit hit, vec3 n, vec3 dir, const in vec3 lightPos)\n{\n\tfloat diffuse = 0.3*max(0.0, dot(n, lightPos));\n\t\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = 0.4*pow(max(0.0, dot(ref, lightPos)), 6.5);\n    \n\treturn (hit.col + \n\t\t\tdiffuse * vec3(0.9) +\n\t\t\tspecular * vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    T = iTime;\n\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\t\n\tvec3 cp = vec3(15.0, 8.0, -13.0); \n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\tvec3 glowCol = vec3(0.0);\n        \n\t// raymarch scene\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n        \n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d * 0.9;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h, n, dir, sun)*m;\n\n    #ifdef EDGES\n\tfloat edge = edges(ray);\n    col = mix(col, vec3(0.0), min(0.1*edge, 1.0));\n    #endif\n\t\n\t// SHADOW with low number of rm iterations (from obj to sun)\n\t#ifdef SHADOW\n\tvec3 ray1 = ray;\n\tdir = normalize(SUN_POS - ray1);\n\tray1 += n*0.002;\n\t\n\tfloat sunDist = length(SUN_POS-ray1);\n\tdist = 0.0;\n\t\n\tfor(int i=0; i < 35; i++) \n\t{\n\t\th = scene(ray1 + dir*dist);\n\t\tdist += h.d;\n\t\tif (abs(h.d) < 0.001) break;\n\t}\n\n\tcol -= 0.24*smoothstep(0.5, -0.3, min(dist, sunDist)/max(0.0001,sunDist));\n\t#endif\n    \n\tcol -= 0.2*smoothstep(0.0,2.0,length(pos));\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.3)) * 2.1;\n\tcol = pow(col, vec3(1.0 / GAMMA));\n    \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4st3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 151, 180, 180, 266], [268, 268, 302, 302, 384], [386, 386, 420, 420, 507], [509, 509, 539, 539, 625], [844, 844, 863, 863, 1992], [1994, 1994, 2015, 2015, 2194], [2196, 2196, 2230, 2230, 2596], [2897, 2897, 2955, 2955, 4400]], "test": "error"}
{"id": "4t2XWK", "name": "Normals Compression - Fibonacci", "author": "iq", "description": "Compressing normals by using Spherical Fibonacci points, as described by this paper [url]http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf[/url]", "tags": ["3d", "normals", "compression"], "likes": 48, "viewed": 3170, "published": "Public API", "date": "1446535518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Compressing normals by using Spherical Fibonacci points, as described by this paper\n// by Benjamin Keinert, Matthias Innmann, Michael Sanger and Marc Stamminger\n\n// The digits indicate the number of bits used to encode the normal. At 16 bits the  normals \n// look pretty good for this model and view distance (I added some specular to the shading so\n// that normal compression artifacts would be more obvious). That means that the compression\n// ratio would be of 6x (for a regular vec3 normal). With 12 bits the quality is pretty decent,\n// and the compression would be 8x.\n\n// The lack of 2D coherency makes it less efficient for compression of normals for disk-storage \n// of meshes or normalmaps though, where the current normal could be predicted from the previous \n// or neighboring normals. But for bast indexing / constant bitrate kind of compression scenarios\n// (compact vertex format for rendering) it's perfec!\n\n// Can somebody investigate a 2D hilbert curve maybe? That would be killer.\n\n// Check https://www.shadertoy.com/view/lllXz4 for a simpler version of the code below.\n\n// Compare to direct, spherical and octahedon projection\n//\n// Octahedron: https://www.shadertoy.com/view/Mtfyzl\n// Spherical:  https://www.shadertoy.com/view/llfcRl\n\n\n//=================================================================================================\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\n//=================================================================================================\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2 a, float b) { return a*b -floor(a*b); }\n\nfloat sf2id(vec3 p, float n) \n{\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.0)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\n\nvec3 id2sf( float i, float n) \n{\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n\n//=================================================================================================\n// digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n//=================================================================================================\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\n//=================================================================================================\n// all iq code below\n//=================================================================================================\n\nfloat map( vec3 p )\n{\n    p.xz *= 0.8;\n    p.xyz += 1.000*sin(  2.0*p.yzx );\n    p.xyz -= 0.500*sin(  4.0*p.yzx );\n    float d = length( p.xyz ) - 1.5;\n\treturn d * 0.25;\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    // from Paul Malin (4 samples only in a tetrahedron\t\n    vec2 e = vec2(1.0,-1.0)*0.002;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 q = fragCoord/iResolution.xy;\n\t\n    //-----------------------------------------------------\n\n\n    float ti = mod( 0.25*iTime, 8.0 );\n    float am = clamp( ti/3.0, 0.0, 1.0 ) - clamp( (ti-4.0)/3.0, 0.0, 1.0 );\n    float bits = 1.0 + floor(15.0*am);\n    float precis = pow(2.0,bits);\n    \n    //-----------------------------------------------------\n\t\n\tfloat an = 4.0 + 0.1*iTime;\n    \n\tvec3 ro = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        vec3 sor = nor;\n        \n        // compress normal\n        float id = sf2id( nor, precis );\n        \n        // decompress normal\n        nor = id2sf( id, precis);\n        \n        nor = (p.x>0.0) ? nor : sor;\n\n        // material\n\t\tcol = vec3(0.2);\n        col *= 1.0 + 0.5*nor;\n\n        \n\t\t// lighting\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = pow(max( dot(-rd,nor),0.0),32.0);\n\t\t// lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky;\n        \t lin += 8.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.1+0.9*pow(fre,5.0))*sky;\n             lin += 1.0*fre*vec3(1.0,0.90,0.80);\n        col = col * lin;\n        col += 0.50*spe;\n        col += 0.15*spe*spe*spe;\n\t}\n\n\t\n\tcol = sqrt(col);\n    \n    col += PrintInt( (q-vec2(0.7,0.75))*12.0*vec2(1.0,iResolution.y/iResolution.x), bits );\n\n    col *= smoothstep( 0.003,0.004,abs(q.x-0.5) );\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2XWK.jpg", "access": "shaders20k", "license": "mit", "functions": [[2730, 2730, 2763, 2763, 2789], [2790, 2790, 2823, 2823, 2849], [2851, 2851, 2882, 2882, 4083], [4085, 4085, 4117, 4117, 4295], [5723, 5723, 5769, 5769, 6085], [6309, 6309, 6330, 6330, 6480], [6483, 6483, 6526, 6526, 6780], [6782, 6782, 6814, 6871, 7063], [7065, 7065, 7089, 7089, 7131], [7133, 7133, 7188, 7188, 7366], [7368, 7368, 7425, 7425, 9297]], "test": "error"}
{"id": "4tBSW3", "name": "Glowing Stone", "author": "834144373", "description": "move the mouse to change the color,choose the color which you like,but it's not perfect,\nhere you can get a good look:[url]http://www.glslsandbox.com/e#28740.0[/url]and[url]http://www.glslsandbox.com/e#28669.0[/url]", "tags": ["raymarch", "glow", "stone", "density"], "likes": 51, "viewed": 2415, "published": "Public API", "date": "1446702896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//Created by 834144373  2015/11/5\n\nfloat noise(vec3 p) //from Las of the \"Mercury\"\n{\n  vec3 i = floor(p);\n  vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n  vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n  a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n  a.xy = mix(a.xz, a.yw, f.y);\n  return mix(a.x, a.y, f.z);\n}\n\n#define time iTime*0.3\n//..........................................................\nvec3 roty(vec3 p,float angle){\n  float s = sin(angle),c = cos(angle);\n    mat3 rot = mat3(\n      c, 0.,-s,\n        0.,1., 0.,\n        s, 0., c\n    );\n    return p*rot; \n}\n//............................................................\n\n///////////////////////////////////\n//raymaching step I for normal obj\n///////////////////////////////////\nfloat obj(vec3 pos){\n    pos -= vec3(0.,0.13,0.);\n    float  n = noise(pos);\n    // float res =  length(max(abs(pos)-vec3(0.8,0.4,0.4)-n,0.0))-0.1;\n  \n    float res = length(pos)-(1.- 0.3*n);\n    return res;\n}\n\n//raymarching step I\n//find object\nfloat disobj(vec3 pointpos,vec3 dir){\n    float dd = 1.;\n    float d = 0.;\n    for(int i = 0;i<30;++i){\n      vec3 sphere = pointpos + dd*dir;\n          d = obj(sphere);\n      dd += d;\n      if(d<0.02)break;\n    }\n    return dd;\n}\n\n//ramarching step for normal\n/*\nvec3 normal(vec3 surface){\n  vec2 offset = vec2(0.01,0.);\n    vec3 nDir = vec3(\n      obj(surface+offset.xyy),\n        obj(surface+offset.yxy),\n        obj(surface+offset.yyx)\n    ) - obj(surface);\n    return normalize(nDir);\n}\n*/\n\n//////raymarching step II for detail obj\n/////////////////////////////////////////////////////////////\n///////here is form guil https://www.shadertoy.com/view/MtX3Ws\n//vec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\nfloat objdetal(in vec3 p) {\n  \tfloat res = 0.;\n    vec3 c = p;\n  \tfor (int i = 0; i < 10; ++i) {\n        p =1.7*abs(p)/dot(p,p) -0.8;\n        //p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-20. * abs(dot(p,c)));        \n  }\n  return res/2.;\n}\n////////////////////////////////////////////////////\n//raymarching step II \nvec4 objdensity(vec3 pointpos,vec3 dir,float finaldis){\n  vec4 color;\n    float den = 0.;\n    vec3 sphere = pointpos + finaldis*dir;\n    //vec3 nDir = normal(sphere);\n    float dd = 0.;\n    //if(dot(nDir,dir)<0.){\n        for(int j = 0;j<45;++j){\n            vec4 col;\n            col.a = objdetal(sphere);\n      \n            //col.rgb = smoothstep(vec3(0.1,0.2,0.1),vec3(0.7,0.2,0.6),col.aaa);\n            //col.rgb *= col.a;\n            float c = col.a/200.;\n            col.rgb = vec3(c,c,c*c);\n            col.rgb *= col.a;\n            col.rgb *= float(j)/20.;\n            dd = 0.01*exp(-2.*col.a);\n            //float dd = max(0.1,col.a);\n            sphere += dd*dir;\n\n            color += col*0.8;\n            //if(color.a/200.>.9 || dd>200.)break;\n        }\n    //}\n    return color*4.5;\n}\n/////////////////////////////////////////\n/////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy / iResolution.xy-0.5)*2.;\n  \n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = (iMouse.xy/iResolution.xy-0.5)*2.2;\n    ///////////////////\n    vec3 dir = normalize(vec3(uv,2.));\n      dir = roty(dir,time);\n    ///////////////////\n    vec3 campos = vec3(0.,0.,-2.8);\n      campos = roty(campos,time);\n    //raymarching step I\n    float finaldis = disobj(campos,dir);\n    vec4 col = vec4(0.061,0.06,0.061,1.);\n    if(finaldis < 40.){\n      \t//col.r = 1.;\n        col = objdensity(campos,dir,finaldis);\n        col += 0.6*col*vec4(0.7+mouse.x,0.8+mouse.y,0.5,1.);\n    }\n    \n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBSW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 171, 171, 414], [439, 500, 530, 530, 670], [735, 842, 862, 862, 1051], [1053, 1088, 1125, 1125, 1318], [1584, 1824, 1851, 1851, 2075], [2076, 2152, 2207, 2207, 2949], [2950, 3034, 3091, 3091, 3739]], "test": "ok"}
{"id": "4tBSWc", "name": "PairOfPants", "author": "jt", "description": "Visualization of the pair-of-pants function\n[url]https://en.wikipedia.org/wiki/Pair_of_pants_(mathematics)[/url]\n", "tags": ["raytracer", "visualization", "implicitsurface", "pairofpants", "cobordism"], "likes": 7, "viewed": 261, "published": "Public", "date": "1446761784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// PairOfPants-function visualization - written 2015 by Jakob Thomsen\n// (intended to be used to improve SineTree https://www.shadertoy.com/view/MljXDV)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat mirror(float v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nfloat fn(vec3 v)\n{\n    v.xy *= 1.75;\n    v.z = v.z / 2.0 - 0.5;\n    //v.x *= 1.75;\n    //v.z = mirror(v.z) - 1.0;\n    // https://en.wikipedia.org/wiki/Pair_of_pants_(mathematics)\n    // implicit surface formula from http://tube.geogebra.org/m/437815\n    // (NOTE: original formula without abs doesn't run on all systems - thanks again, Fabrice!)\n    //return (1.0+v.z)*(pow(abs(v.x-1.0),2.0)+v.y*v.y-0.5)*(pow(abs(v.x+1.0),2.0)+v.y*v.y-0.5)-v.z*(v.x*v.x+v.y*v.y-0.5);\n    // Compactified formula by FabriceNeyret2\n    float d = dot(v.xy,v.xy);\n    return (1.+v.z) * (d-2.*v.x+.5) * (d+2.*v.x+.5) - v.z*(d-.5);\n}\n\nvec3 nrm(vec3 v)\n{\n    vec3 n;\n    float d = 0.01;\n    n.x = fn(v + vec3(d, 0.0, 0.0)) - fn(v + vec3(-d, 0.0, 0.0));\n    n.y = fn(v + vec3(0.0, d, 0.0)) - fn(v + vec3(0.0, -d, 0.0));\n    n.z = fn(v + vec3(0.0, 0.0, d)) - fn(v + vec3(0.0, 0.0, -d));\n    return normalize(n);\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec4 tex(vec3 v)\n{\n    float d = abs(v.z * 20. + sfract(-iTime, 4.) * 5.); \n    vec4 c = vec4(0.5 + 0.5 * nrm(v), 1.0);\n    return exp(-d*d) + c * abs(nrm(v).x);\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float phi = iTime*.1,  C=cos(phi), S=sin(phi);\n\n    vec3 v = vec3(uv, depth);\n    \n    v *= mat3( 0, 1,-1,\n              -1,-1,-1, \n               1,-1,-1 );\n\n    v.zy *=  mat2 (C,S,-S,C); // could be mixed above\n    \n    return v;\n}\n\nvoid mainImage( out vec4 o,  vec2 uv )\n{\n    float t = iTime * 0.1;\n    vec2 R  = iResolution.xy;\n        uv = ( 2. * uv - R)  / R.y;\n\n    vec3 w = vec3(0), v;\n    \n    for(float layer = 0.; layer < 1.; layer += 1./256.) \n        v = camera(uv, 2. * layer - 1.),\n        abs(v.x) < 1. && abs(v.y) < 1. && abs(v.z) < 1. && abs(fn(v)) < .05 ?  w = v : w;\n    \n    // o = tex(w);\n    o = all(equal(w, vec3(0))) ? vec4(0.0) : tex(w); // avoids flashing background\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBSWc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[263, 263, 301, 301, 368], [370, 370, 393, 393, 439], [441, 441, 459, 459, 1052], [1054, 1054, 1072, 1072, 1329], [1331, 1331, 1361, 1361, 1413], [1415, 1415, 1433, 1433, 1578], [1580, 1580, 1615, 1615, 1853], [1855, 1855, 1895, 1895, 2316]], "test": "ok"}
{"id": "4tjSDc", "name": "Octopod", "author": "dr2", "description": "For arachnophiles only (use the mouse for a closer look).", "tags": ["raymarching", "spiders", "walking"], "likes": 4, "viewed": 853, "published": "Public API", "date": "1446981392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Octopod\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Gait based on Dave_H's \"Spider\"; knee positions computed using trig.\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r, float dFac) {\n  return dFac * (length (p / r) - 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 footPos[8], kneePos[8], hipPos[8], sunDir, qHit;\nfloat tCur, legLenU, legLenD, gDisp, bdyHt, bdyEl;\nint idObj;\nconst int idBdy = 1, idHead = 2, idEye = 3, idAnt = 4, idLegU = 5, idLegD = 6;\nbool multi;\nconst float dstFar = 200.;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y / rd.y;\n    ro += sd * rd;\n    ro.z += gDisp;\n    sd /= dstFar;\n    f = Fbm2 (0.2 * ro.xz);\n    vn = normalize (vec3 (f - Fbm2 (0.2 * (ro.xz + vec2 (0.2, 0.))), 0.4,\n       f - Fbm2 (0.2 * (ro.xz + vec2 (0., 0.2)))));\n    f = 0.5 + 0.5 * smoothstep (0.8, 1.1, f * exp (-2. * sd * sd));\n    col = mix (vec3 (0.4, 0.3, 0.2), vec3 (0.3, 0.5, 0.2), f) *\n       (1. - 0.1 * Noisefv2 (21. * ro.xz));\n    col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.1, 0.2, 0.4) + 0.25, pow (1. + rd.y, 32.));\n  }\n  return col;\n}\n\nfloat ShpCylDf (vec3 p, vec3 v, float md, float r, float rf)\n{\n  float len, s;\n  len = length (v);\n  v = normalize (v);\n  s = clamp (dot (p, v), 0., len);\n  p -= s * v;\n  s = s / len - md;\n  return length (p) - r * (1. - rf * s * s);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pp, q, v;\n  float d, dMin, s, len, hGap, bf;\n  if (multi) {\n    hGap = 6.;\n    bf = PrOBoxDf (p - vec3 (0., 4., 0.), vec3 (3. * hGap, 5., 3. * hGap));\n    p.xz -= 2. * hGap * floor ((p.xz + hGap) / (2. * hGap));\n  } else bf = -1.;\n  dMin = dstFar;\n  pp = p - vec3 (0., bdyHt, 0.);\n  pp.yz = Rot2D (pp.yz, bdyEl);\n  q = pp - vec3 (0., -0.15, 0.2);\n  d = max (bf, PrEllipsDf (q, vec3 (0.7, 0.5, 1.3), 0.6));\n  if (d < dMin) { dMin = d;  idObj = idBdy;  qHit = q; }\n  q = pp - vec3 (0., 0.1, 1.1);\n  d = max (bf, PrEllipsDf (q, vec3 (0.2, 0.4, 0.5), 0.2));\n  if (d < dMin) { dMin = d;  idObj = idHead;  qHit = q; }\n  q = pp;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 0.25, 1.5);\n  d = max (bf, PrSphDf (q, 0.1));\n  if (d < dMin) { dMin = d;  idObj = idEye; }\n  q -= vec3 (-0.05, 0.15, -0.3);\n  d = max (bf, ShpCylDf (q, vec3 (0.3, 1.1, 0.4), 0., 0.05, 0.7));\n  if (d < dMin) { dMin = d;  idObj = idAnt; }\n  for (int j = 0; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = max (bf, 0.6 * ShpCylDf (q, kneePos[j] - hipPos[j], 0., 0.15, 0.4));\n    if (d < dMin) { dMin = d;  idObj = idLegU;  qHit = q; }\n    q = p - kneePos[j];\n    d = max (bf, 0.6 * ShpCylDf (q, footPos[j] - kneePos[j], 0.3, 0.1, 1.3));\n    if (d < dMin) { dMin = d;  idObj = idLegD;  qHit = q; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 20; j ++) {\n    h = 1.5 * ObjDf (ro + rd * d);\n    sh = min (sh, 30. * h / d);\n    d += h + 0.07;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.5);\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn)\n{\n  vec4 col;\n  if (idObj == idBdy) {\n    col = mix (vec4 (0., 0.8, 0., 0.5), vec4 (0.8, 0., 0., 0.5),\n       smoothstep (-0.7, 0.3, qHit.z));\n  } else if (idObj == idHead) {\n    col = vec4 (0.8, 0.8, 0., 0.5);\n    if (qHit.z > 0.4) col = mix (vec4 (0.1, 0.03, 0.03, 0.1), col,\n       smoothstep (0.02, 0.04, abs (qHit.x)));\n  } else if (idObj == idEye) {\n    if (vn.z > 0.6) col = vec4 (0., 0., 0., 0.3);\n    else col = vec4 (0.6, 0.6, 0., 1.);\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = vec4 (0.6, 0.4, 0., 0.3) * (0.6 + 0.4 * cos (8. * length (qHit)));\n  } else if (idObj == idAnt) {\n    col = vec4 (0.2, 0.4, 0.7, 0.5);\n  }\n  return col;\n}\n\nvoid ConfigWalker ()\n{\n  vec3 v;\n  float tCyc, tWait, tc, spd, a, az, fz, d, ll;\n  for (int j = 0; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];  hipPos[j + 4].x *= -1.;\n  }\n  spd = 1.5;\n  tCyc = 19.5;\n  tWait = 4.;\n  tCur += 4.;\n  tc = mod (spd * tCur, tCyc);\n  gDisp = spd * tCur - tc + ((tc < tWait) ? 0. :\n     (tc - tWait) * tCyc / (tCyc - tWait));\n  bdyHt = 1. + 1.2 * SmoothBump (tWait + 1.5, tCyc - 1.5, 1.5, mod (tc, tCyc));\n  bdyEl = -10. * (1. + 1.2 * SmoothBump (tWait + 1.5, tCyc - 1.5, 1.5,\n     mod (tc + 0.05, tCyc)) - bdyHt);\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = 0; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) +\n       mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j].yz = Rot2D (hipPos[j].yz, - bdyEl);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], rPath, a, r, tC, tL, tWf, tWb;\n  bool rotStep;\n  rPath = 22.;\n  tC = pi * rPath / 8.;\n  tL = 2. * rPath / 5.;\n  tWf = 15.;\n  tWb = 1.;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tWf;\n  ti[2] = ti[1] + tL;\n  ti[3] = ti[2] + tWb;\n  ti[4] = ti[3] + tC;\n  p.y = 4. - 2. * cos (2. * pi * fract (t / (2. * ti[4])));\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    tr.y = rPath;\n  } else if (t < ti[2]) {\n    tr.y = rPath - 2. * rPath * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    tr.y = - rPath;\n  } else {\n    rotStep = true;\n    a = 1.5 - (t - ti[3]) / (ti[4] - ti[3]);\n    r = rPath;\n  }\n  if (rotStep) {\n    a *= pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  p.x -= 5.;\n  return p;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstHit, sh;\n  int idObjT;\n  idObj = -1;\n  sh = 1.;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = ObjCol (ro, vn);\n    sh = ObjSShadow (ro, sunDir);\n  } else if (rd.y < 0.) {\n    sh = ObjSShadow (ro - rd * ro.y / rd.y, sunDir);\n  }\n  if (dstHit < dstFar) {\n    col = sh * col4.rgb * ((0.2 +\n       0.2 * max (dot (vec3 (- sunDir.x, 0., - sunDir.z), vn), 0.) +\n       0.8 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n  } else col = sh * BgCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec2 canvas, uv, vf, cf, sf;\n  vec3 ro, rd, vd, u;\n  float f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  multi = (mPtr.z <= 0.);\n  ConfigWalker ();\n  if (multi) {\n    ro = TrackPath (0.8 * tCur);\n    vd = normalize (vec3 (0., 2., 10.) - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    rd = vuMat * normalize (vec3 (uv, 2.));\n    sunDir = normalize (vec3 (-1., 1.5, 1.));\n  } else {\n    vf = vec2 (clamp (0.7 - 1.5 * mPtr.y, 0.01, 1.4), pi + 6. * mPtr.x);\n    cf = cos (vf);\n    sf = sin (vf);\n    vuMat = mat3 (1., 0., 0., 0., cf.x, - sf.x, 0., sf.x, cf.x) *\n       mat3 (cf.y, 0., sf.y, 0., 1., 0., - sf.y, 0., cf.y);\n    rd = normalize (vec3 (uv, 4.5)) * vuMat;\n    ro = vec3 (0., 0., -20.) * vuMat;\n    ro.y += 1.;\n    sunDir = normalize (vec3 (-0.3, 1.5, 1.));\n  }\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjSDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[335, 335, 359, 359, 406], [408, 408, 433, 433, 632], [634, 634, 655, 655, 794], [796, 796, 829, 829, 872], [874, 874, 907, 907, 934], [936, 936, 983, 983, 1024], [1026, 1026, 1083, 1083, 1166], [1168, 1168, 1198, 1198, 1272], [1509, 1509, 1540, 1540, 2480], [2482, 2482, 2544, 2544, 2717], [2719, 2719, 2741, 2741, 4022], [4024, 4024, 4057, 4057, 4235], [4237, 4237, 4258, 4258, 4471], [4473, 4473, 4510, 4510, 4727], [4729, 4729, 4761, 4761, 5421], [5423, 5423, 5445, 5445, 6931], [6933, 6933, 6959, 6959, 7747], [7749, 7749, 7784, 7784, 8481], [8483, 8483, 8539, 8539, 9613]], "test": "error"}
{"id": "4tjXDd", "name": "rotation vague", "author": "anilord", "description": "rotationn", "tags": ["rotation"], "likes": 2, "viewed": 99, "published": "Public", "date": "1447413632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n    float zoom = (iResolution.x / 10.0);// * (1.0 + 0.2 * cos(2.0 * iTime));\n    float cameraX = 5.0;  // + 4.0 * cos(iTime);\n    float cameraY = 2.0; // + 4.0 * sin(iTime * 1.1);\n    \n    float cameraAngle=(30.0*3.14)/180.0;\n    \n    float xBeforeRot=(pixCoords.x/zoom)-cameraX*iTime;\n    float yBeforeRot=(pixCoords.y/zoom)-cameraY*iTime;\n    float x=(xBeforeRot*cos(cameraAngle)+(yBeforeRot*sin(cameraAngle*2.0)));\n    float y=(-xBeforeRot*sin(cameraAngle)+(yBeforeRot*cos(cameraAngle*2.0)));\n    \n    \n   //float x = (pixCoords.x / zoom) - cameraX;\n    //float y = (pixCoords.y / zoom) - cameraY;\n\t\n    float lineSemiWidth = 0.05;\n    \n    if (abs(x) < lineSemiWidth || abs(y)<lineSemiWidth) {\n\t\tcolor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    \n    if (mod(x, 1.0) < lineSemiWidth || mod(y, 1.0) < lineSemiWidth) {\n\t\tcolor = vec4(0.5, 0.5, 0.5, 1.0);\n        return;\n    }\n    \n    float PI = 3.1415;\n    float hauteurMoyenne = 0.0;\n    float amplitude = 1.0;\n    float phase = 4.0 + 5.0 * cos(iTime);\n    float periode = 3.0;\n    float fx = hauteurMoyenne + cos(x * 2.0 * PI / periode + phase) * amplitude;\n    \n    if (y < fx) {\n        color = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    float fx2 = 1.0 + cos(2.5 * (x + iTime)) * 0.3;\n    \n    if (y < fx2) {\n        color = vec4(0.6, 0.6, 1.0, 1.0);\n        return;\n    }\n\t\n    \n    color = vec4(1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 1446]], "test": "ok"}
{"id": "4tjXWV", "name": "ubuntu logo", "author": "MacSlow", "description": "Just for fun I made the logo of ubuntu (Linux).", "tags": ["raymarching", "csg"], "likes": 16, "viewed": 2106, "published": "Public", "date": "1446593391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// ubuntu-logo rendered with ray-marching\n//\n// Copyright 2015 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265358979323846;\nconst vec4 laubergine = vec4 (float (0x77) / 255., float (0x21) / 255., float (0x6F) / 255., 1.);\nconst vec4 wgrey = vec4 (float (0xAE) / 255., float (0xA7) / 255., float (0x9F) / 255., 1.);\nconst vec4 uorange = vec4 (float (0xdd) / 255., float  (0x48) / 255., float  (0x14) / 255., 1.);\nconst int MAX_STEPS = 64;\nconst float epsilon = 0.0001;\n\nmat4 trans (vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (.0, .0, 1., .0),\n                     vec4 (t.x, t.y, t.z, 1.));\n    return mat;\n}\n\nvec3 opTransf (vec3 p, mat4 m)\n{\n    return vec4 (m * vec4 (p, 1.)).xyz;\n}\n\nmat4 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, 0.0,  -s, 0.0),\n                     vec4 (0.0, 1.0, 0.0, 0.0),\n                     vec4 (  s, 0.0,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, 0.0, 0.0),\n                     vec4 ( -s,   c, 0.0, 0.0),\n                     vec4 (0.0, 0.0, 1.0, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nfloat opSubtract (float d1, float d2)\n{\n    return max (-d1, d2);\n}\n\nfloat box (vec3 p, vec3 b, float r)\n{\n    return length (max (abs (p) - b + vec3 (r), .0)) - r;\n}\n\nfloat cylinder (vec3 p, vec2 h)\n{\n  vec2 d = abs (vec2 (length (p.xy), p.z)) - h;\n  return min (max (d.x, d.y), .0) + length (max (d, .0));\n}\n\nfloat wavyfloor (vec3 p, vec4 n)\n{\n    return dot ((p).xyz, n.xyz) + n.w - .1 * sin (4. * p.x) * cos (4. * p.z);\n}\n\nfloat logo (vec3 np)\n{\n    float d1 = .0;\n    float d2 = .0;\n    const float angle = 120.;\n    const float offset = 60.;\n\n    vec3 p = opTransf (np, rotZ (90.));\n    const float a = 1.;          // outter circle\n    const float b = 164. / 284.; // cutout circle\n    const float c = 110. / 284.; // inner circle\n    const float d = 10.  / 284.; // beam\n    const float e = 53.  / 284.; // head-circle\n    const float f = 38.  / 284.; // head-circle cutout\n    const float g = 192. / 284.; // head-circle offset\n\n    // big outter and smaller inner \"circle\"\n    mat4 m1 = trans (vec3 (.0, .0, .0));\n    d1 = cylinder (opTransf (p, m1), vec2 (a, .1));\n    mat4 m2 = trans (vec3 (.0, .0, .0));\n    d2 = cylinder (opTransf (p, m2), vec2 (b, .4));\n    d1 = opSubtract (d2, d1);\n    d2 = cylinder (opTransf (p, m1), vec2 (c, .1));\n    d1 = min (d1, d2);\n\n    // three \"beams\"\n    m1 = trans (vec3 (.0, .2, .0));\n    d2 = box (opTransf (p, m1), vec3 (d, .4, .1), .0);\n    d1 = min (d1, d2);\n\n    m1 = trans (vec3 (.0, .2, .0)) * rotZ (angle);\n    d2 = box (opTransf (p, m1), vec3 (d, .4, .1), .0);\n    d1 = min (d1, d2);\n\n    m1 = trans (vec3 (.0, .2, .0)) * rotZ (2. * angle);\n    d2 = box (opTransf (p, m1), vec3 (d, .4, .1), .0);\n    d1 = min (d1, d2);\n\n    // three small \"circles\"\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset);\n    d2 = cylinder (opTransf (p, m1), vec2 (e, .1));\n    d1 = min (d1, d2);\n\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset + angle);\n    d2 = cylinder (opTransf (p, m1), vec2 (e, .1));\n    d1 = min (d1, d2);\n\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset + 2. * angle);\n    d2 = cylinder (opTransf (p, m1), vec2 (e, .1));\n    d1 = min (d1, d2);\n\n    // three small \"circle\"-cutouts\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset);\n    d2 = cylinder (opTransf (p, m1), vec2 (f, .2));\n    d1 = opSubtract (d2, d1);\n\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset + angle);\n    d2 = cylinder (opTransf (p, m1), vec2 (f, .2));\n    d1 = opSubtract (d2, d1);\n\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset + 2. * angle);\n    d2 = cylinder (opTransf (p, m1), vec2 (f, .2));\n    d1 = opSubtract (d2, d1);\n\n    return d1;\n}\n\nfloat map (vec3 p, inout int matindex)\n{\n    float ground = .0;\n    float ulogo = .0;\n    float t = iTime;\n\n    ground = wavyfloor (p, normalize (vec4 (.0, -.5, .0, 1.)));\n    mat4 m = rotY (40. * t);\n    ulogo = logo (opTransf (p, m));\n\n    float d = min (ground, ulogo);\n    if (d == ground) {\n        matindex = 1;\n    } else if (d == ulogo) {\n        matindex = 2;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec3 e = vec3 (.0001, .0, .0);\n    int matindex;\n    float d = map (p, matindex);\n\n    vec3 n = vec3 (map (p + e.xyy, matindex) - d,\n                   map (p + e.yxy, matindex) - d,\n                   map (p + e.yyx, matindex) - d);\n\n    return normalize (n);\n}\n\nfloat shadow (vec3 ro, vec3 rd, float tmin, float k)\n{\n    float s = 1.;\n    float d = .0;\n    float t = tmin;\n    int index = 0;\n    for (int i = 0; i < 32; i++) {\n        d = map (ro + rd * t, index);\n        if (d < epsilon) {\n            return .0;\n        }\n        s = min (s, k * d / t);\n        t += d;\n    }\n    return s;\n}\n\nvec4 shade (vec3 p, vec4 color)\n{\n    float t = 1.5 * iTime;\n    vec3 lPos0 = vec3 (3. * cos (t),       -4., 3. * sin (t));\n    vec3 lPos1 = vec3 (4. * cos (-t * .2), -3., 4. * sin (-t));\n\n    vec4 lCol = vec4 (.95, .95, .9, 1.);\n    vec3 n = normal (p);\n    vec3 lDir0 = normalize (lPos0 - p);\n    vec3 lDir1 = normalize (lPos1 - p);\n    vec4 lInt0 = lCol * dot (n, lDir0);\n    vec4 lInt1 = lCol * dot (n, lDir1);\n    vec4 col = shadow (p, normalize (lPos0 - p), 0.001, 64.) * lInt0 * color;\n    col += shadow (p, normalize (lPos1 - p), 0.001, 64.) * lInt1 * color;\n\n    return col;\n}\n\nmat3 camera (vec3 eye, vec3 aim, float r)\n{\n    vec3 cw = normalize (aim - eye);\n    vec3 cp = vec3 (sin (r), cos (r), .0);\n    vec3 cu = normalize (cross (cw, cp));\n    vec3 cv = normalize (cross (cu, cw));\n    return mat3 (cu, cv, cw);\n}\n\nfloat march (vec3 ro, vec3 rd, float pixelSize, inout int index)\n{\n    bool forceHit = false;\n    float infinity = 10000.0;\n    float t_min = .0001;\n    float t_max = 50.0;\n    float t = t_min;\n    float candidate = t_min;\n    float candidate_error = infinity;\n    float w = 1.4;\n    float lastd = .0;\n    float stepSize = .0;\n    float sign = map (ro, index) < .0 ? -1. : 1.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n\t{\n        float signedd = sign * map (ro + rd * t, index);\n        float d = abs (signedd);\n        bool fail = w > 1. && (d + lastd) < stepSize;\n\n        if (fail) {\n            stepSize -= w * stepSize;\n            w = 1.;\n        } else {\n            stepSize = signedd * w;\n        }\n\n\t\tlastd = d;\n\n        float error = d / t;\n        if (!fail && error < candidate_error) {\n            candidate_error = error;\n            candidate = t;\n        }\n\n        if (!fail && error < pixelSize || t > t_max) {\n        \tbreak;\n\t\t}\n\n        t += stepSize;\n \n\t}\n\n    if ((t > t_max || candidate_error > pixelSize) && !forceHit) {\n        return infinity;\n    }\n\n\treturn candidate;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (4. * mouse.x) * 7., -3., sin (4. * mouse.x) * 7.);\n    vec3 aim = vec3 (.0, .0, .0);\n    mat3 cam = camera (eye, aim, .0);\n    vec2 uv = vec2 (-.9 + fragCoord.x / iResolution.y, .5 - fragCoord.y / iResolution.y);\n\n    vec3 ro = eye;\n    vec3 rd = cam * normalize (vec3 (uv, 1.8));\n    vec4 bg = laubergine;\n    float pixelSize = 1. / iResolution.x;\n    int matindex = 0;\n    float t = march (ro, rd, pixelSize, matindex);\n    vec4 color = bg;\n    if (matindex == 1) {\n\t\tcolor = mix (shade (ro + rd * t, wgrey), bg, length (rd * t) / 50.);\n    } else if (matindex == 2) {\n        color = mix (shade (ro + rd * t, uorange), bg, length (rd * t) / 50.);\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXWV.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1308, 1308, 1329, 1329, 1527], [1529, 1529, 1561, 1561, 1603], [1605, 1605, 1633, 1633, 1929], [1931, 1931, 1959, 1959, 2255], [2257, 2257, 2296, 2296, 2324], [2326, 2326, 2363, 2363, 2423], [2425, 2425, 2458, 2458, 2566], [2568, 2568, 2602, 2602, 2682], [2684, 2684, 2706, 2706, 4839], [4841, 4841, 4881, 4881, 5232], [5234, 5234, 5256, 5256, 5523], [5525, 5525, 5579, 5579, 5857], [5859, 5859, 5892, 5892, 6444], [6446, 6446, 6489, 6489, 6685], [6687, 6687, 6753, 6753, 7785], [7787, 7787, 7844, 7844, 8597]], "test": "timeout"}
{"id": "4tSSWd", "name": "Homer Simpson curve", "author": "coyote", "description": " The function was taken from WolframAlpha. http://m.wolframalpha.com/input/?i=Homer+Simpson+curve", "tags": ["parametric"], "likes": 17, "viewed": 1107, "published": "Public API", "date": "1447165936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//parametric function for Homer Simpson taken from WolframAlpha\n//http://m.wolframalpha.com/input/?i=Homer+Simpson+curve\n\n//put larger time here if you want to try it in fullscreen\n//so you'll have enough time to switch to fullscreen\n\n#define WAIT .5\n\n#define pi 3.141592653589793\n\n#define theta(x) step(0., x)\n\n//Fabrice's alert function for thumbnails list to avoid all black thumbnail\nfloat message(vec2 p) {  // the alert function to add to your shader\n    int x = int(p.x+1.)-1, y=int(p.y)-10,  i;\n    if (x<1||x>32||y<0||y>2) return -1.; \n    i = ( y==2? i=  757737252: y==1? i= 1869043565: y==0? 623593060: 0 )/ int(exp2(float(32-x)));\n \treturn i==2*(i/2) ? 1. : 0.;\n}\n\nvec2 homer(float t) {\n\n    return .001 * vec2(\n  //x(t)\n           ((-11./8.*sin(17./11.-8.*t)\n             -3./4.*sin(11./7.-6.*t)\n             -9./10.*sin(17./11.-5.*t)\n             +349./9.*sin(t+11./7.)\n             +17./12.*sin(2.*t+8./5.)\n             +288./41.*sin(3.*t+8./5.)\n             +69./10.*sin(4.*t+8./5.)\n             +8./5.*sin(7.*t+13./8.)\n             +4./7.*sin(9.*t+28./17.)\n             +4./7.*sin(10.*t+19./11.)+1051./8.)*theta(39.*pi-t)*theta(t-35.*pi)+\n            (-3./4.*sin(11./7.-5.*t)\n             -54.*sin(11./7.-t)\n             +237./8.*sin(2.*t+11./7.)\n             +52./11.*sin(3.*t+33./7.)\n             +38./9.*sin(4.*t+11./7.)+249./2.)*theta(35.*pi-t)*theta(t-31.*pi)+\n            (-16./9.*sin(14./9.-5.*t)\n             -5./2.*sin(14./9.-3.*t)\n             +781./8.*sin(t+33./7.)\n             +291./11.*sin(2.*t+11./7.)\n             +23./7.*sin(4.*t+11./7.)\n             +18./19.*sin(6.*t+11./7.)\n             +2./5.*sin(7.*t+61./13.)\n             +24./23.*sin(8.*t+14./9.)\n             +1./27.*sin(9.*t+5./11.)\n             +4./11.*sin(10.*t+11./7.)\n             +1./75.*sin(11.*t+5./8.)+1411./7.)*theta(31.*pi-t)*theta(t-27.*pi)+\n            (-7./11.*sin(13./10.-13.*t)\n             +3003./16.*sin(t+33./7.)\n             +612./5.*sin(2.*t+11./7.)\n             +542./11.*sin(3.*t+47./10.)\n             +137./7.*sin(4.*t+51./11.)\n             +53./7.*sin(5.*t+17./11.)\n             +23./12.*sin(6.*t+41./9.)\n             +94./11.*sin(7.*t+51./11.)\n             +81./11.*sin(8.*t+41./9.)\n             +53./12.*sin(9.*t+23./5.)\n             +73./21.*sin(10.*t+13./9.)\n             +15./7.*sin(11.*t+6./5.)\n             +37./7.*sin(12.*t+7./5.)\n             +5./9.*sin(14.*t+27./7.)\n             +36./7.*sin(15.*t+9./2.)\n             +68./23.*sin(16.*t+48./11.)\n             +14./9.*sin(17.*t+32./7.)+1999./9.)*theta(27.*pi-t)*theta(t-23.*pi)+\n            (1692./19.*sin(t+29./19.)\n             +522./5.*sin(2.*t+16./11.)\n             +767./12.*sin(3.*t+59./13.)\n             +256./11.*sin(4.*t+31./7.)\n             +101./5.*sin(5.*t+48./11.)\n             +163./8.*sin(6.*t+43./10.)\n             +74./11.*sin(7.*t+49./12.)\n             +35./4.*sin(8.*t+41./10.)\n             +22./15.*sin(9.*t+29./14.)\n             +43./10.*sin(10.*t+4.)\n             +16./7.*sin(11.*t+6./5.)\n             +11./21.*sin(12.*t+55./14.)\n             +3./4.*sin(13.*t+37./10.)\n             +13./10.*sin(14.*t+27./7.)+2383./6.)*theta(23.*pi-t)*theta(t-19.*pi)+\n            (-1./9.*sin(7./5.-10.*t)\n             -2./9.*sin(11./9.-6.*t)\n             +20./11.*sin(t+16./15.)\n             +7./13.*sin(2.*t+15./4.)\n             +56./13.*sin(3.*t+25./9.)\n             +1./6.*sin(4.*t+56./15.)\n             +5./16.*sin(5.*t+19./8.)\n             +2./5.*sin(7.*t+5./16.)\n             +5./12.*sin(8.*t+17./5.)\n             +1./4.*sin(9.*t+3.)+1181./4.)*theta(19.*pi-t)*theta(t-15.*pi)+\n            (-1./6.*sin(8./11.-5.*t)\n             +5./8.*sin(t+6./5.)\n             +13./5.*sin(2.*t+45./14.)\n             +10./3.*sin(3.*t+7./2.)\n             +13./10.*sin(4.*t+24./25.)\n             +1./6.*sin(6.*t+9./5.)\n             +1./4.*sin(7.*t+37./13.)\n             +1./8.*sin(8.*t+13./4.)\n             +1./9.*sin(9.*t+7./9.)\n             +2./9.*sin(10.*t+63./25.)\n             +1./10.*sin(11.*t+1./9.)+4137./8.)*theta(15.*pi-t)*theta(t-11.*pi)+\n            (-17./13.*sin(6./5.-12.*t)\n             -15./7.*sin(25./26.-11.*t)\n             -13./7.*sin(3./14.-10.*t)\n             -25./7.*sin(9./13.-6.*t)\n             -329./3.*sin(8./17.-t)\n             +871./8.*sin(2.*t+2.)\n             +513./14.*sin(3.*t+5./4.)\n             +110./9.*sin(4.*t+3./8.)\n             +43./8.*sin(5.*t+1./5.)\n             +43./13.*sin(7.*t+42./11.)\n             +49./16.*sin(8.*t+11./13.)\n             +11./5.*sin(9.*t+2./7.)\n             +5./7.*sin(13.*t+42./13.)+1729./4.)*theta(11.*pi-t)*theta(t-7.*pi)+\n            (427./5.*sin(t+91./45.)\n             +3./11.*sin(2.*t+7./2.)+5656./11.)*theta(7.*pi-t)*theta(t-3.*pi)+\n            (-10./9.*sin(7./10.-4.*t)\n             -7./13.*sin(5./6.-3.*t)\n             -732./7.*sin(4./7.-t)\n             +63./31.*sin(2.*t+1./47.)\n             +27./16.*sin(5.*t+11./4.)+3700./11.)*theta(3.*pi-t)*theta(t+pi)) //*theta(sqrt(sign(sin(t/2.))))\n        ,\n  //y(t)\n            ((-4./11.*sin(7./5.-10.*t)\n              -11./16.*sin(14./13.-7.*t)\n              -481./11.*sin(17./11.-4.*t)\n              -78./7.*sin(26./17.-3.*t)\n              +219./11.*sin(t+11./7.)\n              +15./7.*sin(2.*t+18./11.)\n              +69./11.*sin(5.*t+11./7.)\n              +31./12.*sin(6.*t+47./10.)\n              +5./8.*sin(8.*t+19./12.)\n              +10./9.*sin(9.*t+17./11.)+5365./11.)*theta(39.*pi-t)*theta(t-35.*pi)+\n             (-75./13.*sin(14./9.-4.*t)\n              -132./5.*sin(11./7.-2.*t)\n              -83.*sin(11./7.-t)\n              +1./7.*sin(3.*t+47./10.)\n              +1./8.*sin(5.*t+14./11.)+18332./21.)*theta(35.*pi-t)*theta(t-31.*pi)+\n             (191./3.*sin(t+33./7.)\n              +364./9.*sin(2.*t+33./7.)\n              +43./22.*sin(3.*t+14./3.)\n              +158./21.*sin(4.*t+33./7.)\n              +1./4.*sin(5.*t+74./17.)\n              +121./30.*sin(6.*t+47./10.)\n              +1./9.*sin(7.*t+17./6.)\n              +25./11.*sin(8.*t+61./13.)\n              +1./6.*sin(9.*t+40./9.)\n              +7./6.*sin(10.*t+47./10.)\n              +1./14.*sin(11.*t+55./28.)+7435./8.)*theta(31.*pi-t)*theta(t-27.*pi)+\n             (-4./7.*sin(14./9.-13.*t)\n              +2839./8.*sin(t+47./10.)\n              +893./6.*sin(2.*t+61./13.)\n              +526./11.*sin(3.*t+8./5.)\n              +802./15.*sin(4.*t+47./10.)\n              +181./36.*sin(5.*t+13./3.)\n              +2089./87.*sin(6.*t+14./3.)\n              +29./8.*sin(7.*t+69./16.)\n              +125./12.*sin(8.*t+47./10.)\n              +4./5.*sin(9.*t+53./12.)\n              +93./47.*sin(10.*t+61./13.)\n              +3./10.*sin(11.*t+9./7.)\n              +13./5.*sin(12.*t+14./3.)\n              +41./21.*sin(14.*t+22./5.)\n              +4./5.*sin(15.*t+22./5.)\n              +14./5.*sin(16.*t+50./11.)\n              +17./7.*sin(17.*t+40./9.)+4180./7.)*theta(27.*pi-t)*theta(t-23.*pi)+\n             (-7./4.*sin(8./11.-14.*t)\n              -37./13.*sin(3./2.-12.*t)\n              +2345./11.*sin(t+32./21.)\n              +632./23.*sin(2.*t+14./3.)\n              +29./6.*sin(3.*t+31./21.)\n              +245./11.*sin(4.*t+5./4.)\n              +193./16.*sin(5.*t+7./5.)\n              +19./2.*sin(6.*t+32./7.)\n              +19./5.*sin(7.*t+17./9.)\n              +334./23.*sin(8.*t+35./8.)\n              +11./3.*sin(9.*t+21./11.)\n              +106./15.*sin(10.*t+22./5.)\n              +52./15.*sin(11.*t+19./12.)\n              +7./2.*sin(13.*t+16./13.)+12506./41.)*theta(23.*pi-t)*theta(t-19.*pi)+\n             (-3./7.*sin(1./10.-9.*t)\n              -1./8.*sin(5./14.-5.*t)\n              -9./8.*sin(26./17.-2.*t)\n              +18./7.*sin(t+14./11.)\n              +249./50.*sin(3.*t+37./8.)\n              +3./13.*sin(4.*t+19./9.)\n              +2./5.*sin(6.*t+65./16.)\n              +9./17.*sin(7.*t+1./4.)\n              +5./16.*sin(8.*t+44./13.)\n              +2./9.*sin(10.*t+29./10.)+6689./12.)*theta(19.*pi-t)*theta(t-15.*pi)+\n             (-1./27.*sin(1.-11.*t)\n              -1./6.*sin(4./11.-10.*t)\n              -1./5.*sin(2./11.-9.*t)\n              -7./20.*sin(1./2.-5.*t)\n              -51./14.*sin(29./28.-3.*t)\n              +23./7.*sin(t+18./5.)\n              +25./9.*sin(2.*t+53./12.)\n              +3./2.*sin(4.*t+41./15.)\n              +1./5.*sin(6.*t+36./11.)\n              +1./12.*sin(7.*t+14./3.)\n              +3./10.*sin(8.*t+19./9.)+3845./7.)*theta(15.*pi-t)*theta(t-11.*pi)+\n             (-8./7.*sin(1./3.-13.*t)\n              -9./13.*sin(4./5.-11.*t)\n              -32./19.*sin(17./12.-9.*t)\n              -11./6.*sin(9./13.-8.*t)\n              -169./15.*sin(8./17.-3.*t)\n              +917./8.*sin(t+55./12.)\n              +669./10.*sin(2.*t+4./13.)\n              +122./11.*sin(4.*t+49./24.)\n              +31./9.*sin(5.*t+1./8.)\n              +25./9.*sin(6.*t+6./7.)\n              +43./10.*sin(7.*t+1./21.)\n              +18./19.*sin(10.*t+9./13.)\n              +2./9.*sin(12.*t+31./15.)+1309./5.)*theta(11.*pi-t)*theta(t-7.*pi)+\n             (-267./38.*sin(3./10.-2.*t)\n              +625./8.*sin(t+62./17.)+8083./14.)*theta(7.*pi-t)*theta(t-3.*pi)+\n             (1370./13.*sin(t+25./6.)\n              +41./21.*sin(2.*t+205./51.)\n              +11./16.*sin(3.*t+8./13.)\n              +9./13.*sin(4.*t+26./9.)\n              +6./5.*sin(5.*t+11./14.)+2251./4.)*theta(3.*pi-t)*theta(t+pi)) //*theta(sqrt(sign(sin(t/2.))))\n    );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iResolution.y<200.) // alert for the icon\n        {fragColor=vec4(message(34.*fragCoord/iResolution.x));return;}\n\n    float T = iTime;\n    \n    //clear the screen on time reset\n    if( T < WAIT ) {\n        fragColor=vec4(0,0,0,1);\n        return;\n    }\n        \n    T -= WAIT;\n\n    vec3 R = iResolution;\n    vec2 uv = fragCoord / R.y;    \n    float dot_radius = 2. / R.y;\n\n    //don't calculate for the right side of the screen\n    if( uv.x > .5 * R.x / R.y )\n        discard;\n    \n    //slow down time to better fill the gaps when in fullscreen\n    T /= (R.y/360.)*(R.y/360.);\n\n    //stop calculating when the image is done\n    //if( T > 20.*pi )\n    //    discard;\n\n    vec2 p1 = homer(T);\n    vec2 p2 = homer(T + 20.*pi);\n    \n    if( distance(p1, uv) <= dot_radius ||\n        distance(p2, uv) <= dot_radius\n    )\n        fragColor=vec4(1);\n    else\n        discard;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSSWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 388, 411, 456, 675], [677, 677, 698, 698, 9306], [9308, 9308, 9365, 9365, 10245]], "test": "timeout"}
{"id": "4tSXWd", "name": "Mod Effect (126c)", "author": "aiekick", "description": "Mod Effect", "tags": ["modeffect"], "likes": 3, "viewed": 752, "published": "Public API", "date": "1447180514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by FabriceNeuret2\nvoid mainImage(out vec4 f,  vec2 g )\n{\n\tvec2 R = iResolution.xy;\n    g =  abs( abs( (g+g -R)/R.y ) + sin(iTime+vec2(1.6,0)) );\t\n\tf += mod(g.x, g.y);\n}\n\n/* original\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 uv = (2.* g -iResolution.xy)/iResolution.y;\n\t\n\tfloat m = mod(abs(abs(uv.x)+cos(iTime)), abs(abs(uv.y)+sin(iTime)));\n\t\n\tf.rgb = vec3(m);\n}*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 59, 59, 171]], "test": "ok"}
{"id": "4tSXWV", "name": "03 Substraction", "author": "yiwenl", "description": "Substraction", "tags": ["raytracing"], "likes": 3, "viewed": 769, "published": "Public API", "date": "1446414791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat smin( float a, float b )\n{\n    return smin(a, b, 3.0);\n}\n\nfloat iPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat iSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n\nfloat map(vec3 pos) {\n    float dSphere = iSphere(pos, 4.0);\n    \n    float s1 = iSphere(pos - vec3(sin(iTime*.55)*1.85, cos(iTime*.19) * 0.95, sin(iTime*.91) * 1.21) * 1.0, 2.6451);\n    float s2 = iSphere(pos - vec3(cos(iTime*.43)*1.55, sin(iTime*.38) * 1.12, cos(iTime*.76) * 1.67) * 1.4, 2.564821);\n    float s3 = iSphere(pos - vec3(sin(iTime*.26)*2.52, cos(iTime*.57) * 0.56, sin(iTime*.12) * 1.58) * 1.2, 2.98441);\n    float s4 = iSphere(pos - vec3(sin(iTime*.97)*1.72, sin(iTime*.22) * 0.81, cos(iTime*.34) * 0.97) * 1.5, 2.12373);\n    float s5 = iSphere(pos - vec3(sin(iTime*.62)*1.47, cos(iTime*.76) * 0.73, sin(iTime*.75) * 1.45) * 1.7, 2.2748186);\n    \n    float d = smin(s1, smin(s2, smin(s3, smin(s4, s5))));\n    \n    return max(-d, dSphere);\n}\n\nconst float PI = 3.141592657;\nconst vec3 lightDirection = vec3(1.0, 1.0, -1.0);\nconst vec4 lightBlue = vec4(186.0, 209.0, 222.0, 255.0)/255.0;\n\nfloat diffuse(vec3 normal) {\n    return max(dot(normal, normalize(lightDirection)), 0.0);   \n}\n\nfloat specular(vec3 normal, vec3 dir) {\n\tvec3 h = normalize(normal - dir);\n\treturn pow(max(dot(h, normal), 0.0), 40.0);\n}\n\nvec3 getColor(vec3 pos, vec3 normal, vec3 dir) {\n    pos.xz = rotate(pos.xz, sin(iTime*.25)*.2);\n    pos.yz = rotate(pos.yz, cos(sin(iTime*.25)*.2)+iTime*.1) * .3;    \n    float zOffset = 200.0 + sin(cos(iTime*0.443256)*0.716786) * 200.0;\n    zOffset = 1.0 + zOffset*.05;\n    float grey = fract(pos.z*zOffset - iTime*.1);\n    grey = 1.0 - sin(grey * PI);\n    grey *= mix(1.0 + sin(pos.z*50.0 - iTime*.1) * 0.5, 0.0, .25);\n    grey = grey * grey;\n    \n    float diff = diffuse(normal);\n    float spec = specular(normal, dir);\n    \n//    return vec3(grey+diff*.75);\n    return vec3(grey+spec*.75+diff*.5);\n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.01, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n\t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n\t\tmap(pos + eps.yyx) - map(pos - eps.yyx)\n\t);\n\treturn normalize(normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focus = 1.25;\n    vec3 pos = vec3(0.0, 0.0, -10.0);\n    vec3 dir = normalize(vec3(uv, focus));\n    \n    vec4 color = vec4(.0);\n    float d;\n    \n    const int NUM_ITER = 64;\n    for(int i=0; i<NUM_ITER; i++) {\n        d = map(pos);\n        if(d < 0.0001) {\n            vec3 normal = computeNormal(pos);\n            color.rgb = getColor(pos, normal, dir);\n            color.a = 1.0;\n            break;\n        }\n        \n        pos += d * dir;\n        if(length(pos) > 10.0) break;\n    }\n    \n    color = color;\n    \n\tfragColor = vec4(color) * lightBlue;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 118], [120, 120, 161, 161, 232], [234, 234, 266, 266, 296], [298, 298, 322, 322, 342], [344, 344, 383, 383, 418], [421, 421, 442, 442, 1177], [1323, 1323, 1351, 1351, 1417], [1419, 1419, 1458, 1458, 1540], [1542, 1542, 1590, 1590, 2147], [2149, 2149, 2179, 2179, 2391], [2394, 2394, 2451, 2451, 3134]], "test": "ok"}
{"id": "4tXSDS", "name": "MarbleticField", "author": "felixfaire", "description": "A 10 min 2D shader.", "tags": ["2d", "noise", "fbm", "field", "marble", "magnet"], "likes": 6, "viewed": 197, "published": "Public", "date": "1446489484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n \nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n \nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n        f = f*f*(3.0-2.0*f);\n        float n = p.x + p.y*57.0;\n        float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n        return res;\n}\n \nfloat fbm( vec2 p )\n{\n        float f = 0.0;\n        f += 0.50000*noise( p ); p = p*2.02;\n        f += 0.25000*noise( p ); p = p*2.03;\n        f += 0.12500*noise( p ); p = p*2.01;\n        f += 0.06250*noise( p ); p = p*2.04;\n        f += 0.03125*noise( p );\n        return f/0.984375;\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Set up domain\n    vec2 p = ( fragCoord / iResolution.xy );\n    p = p * 2.0 - 1.0;\n    \n    //p *= mat2(cos(0.2);\n    \n    // Fix aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n    \n    p.x *= 1.0 - abs(p.y) * smoothstep(0.0, 0.5, abs(p.y)) * abs(p.x) * 1.0;\n \n    vec3 col = vec3 ( 0.0, 0.0, 0.0 );\n    \n    p.y += 3.0 * fbm(p * 2.0);\n    \n    // Create noise using fBm\n    float f = fbm( vec2(5.0*p.x + iTime * 0.2, fbm(10.*p + iTime)) );\n    \n    col.x += smoothstep( 0.6, 1.0, f * 1.4);\n    col.y += smoothstep( 0.2, 0.8, f);\n    col.z += smoothstep( 0.1, 0.7, f);\n    \n    //col += palette(f, vec3(0.3,0.2,0.9), vec3(0.5,0.9,0.5), vec3(0.6, 0.4,0.3),vec3(0.0,1.0,0.5));\n    \n    col += p.y * 0.04;\n    col -= abs(p.x) * 0.1;\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 115], [118, 118, 141, 141, 180], [183, 183, 209, 209, 449], [452, 452, 473, 473, 738], [742, 742, 799, 823, 1580]], "test": "ok"}
{"id": "ldcGRN", "name": "Embellished Audio Visualizer", "author": "chronos", "description": "Added more effects to the basic audio visualizer.", "tags": ["2d", "audio", "visualizer", "soundcloud"], "likes": 25, "viewed": 774, "published": "Public", "date": "1448572854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Embellished audio visualizer by chronos\n// \n// Recommended tracks:\n// https://soundcloud.com/wearecastor/rad\n// https://soundcloud.com/kubbi/pathfinder\n// https://soundcloud.com/finn-bollongino/galactic-love-song-original\n// https://soundcloud.com/zircon-1/augment\n*/\n\n#define DUST_MOTE_COUNT 10\n#define WIDTH 1.0\n\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.25) ).x; }\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.75) ).x; }\n\nvec3 dust_mote(vec3 color, vec2 pos, vec2 center, float radius, float alpha, float focus){\n    vec2 disp = pos - center;\n    float dist = dot(disp,disp);\n    vec3 mote = (color+0.005)*alpha* vec3(smoothstep(radius * (1.0+focus), radius, dist));\n    return (1.0-mote)*color + mote;\n}\n\nfloat rnd(float s) { return sin(2923.138674*s); }\n\nvec3 dust_motes(vec3 color, vec2 pos, const int number, float t) {\n    vec3 new_color = color;\n    for(int i = 0; i < DUST_MOTE_COUNT; i++) {\n        float fudge = rnd(float(i));\n        float cycle = fract(t+fudge);\n    \tfloat fade = 2.0 * cycle * (1.0 - cycle);\n        vec2 center = vec2(fudge+sin(t*fudge+fudge), 1.1-cycle*2.0+rnd(fudge));\n        new_color = dust_mote(new_color, pos, center, 0.01+0.007*fudge, 0.5*fade, 0.6 + 0.4*fudge); \n    }\n    return new_color;\n}\n\nvec3 B2_spline(vec3 x) { // returns 3 B-spline functions of degree 2\n    vec3 t = 3.0 * x;\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\n\treturn 0.5 * (\n    \tb0 * pow(t, vec3(2.0)) +\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + \n    \tb2 * pow(3.0-t,vec3(2.0))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y += 0.02 * sin(3.0*uv.x+iTime / 2.0);\n    vec2 centered = (uv - 0.5)/WIDTH;\n    float intro = smoothstep(0.0, 30.0, iTime);\n    centered.y -=  intro - 1.0;\n    float sample0 = audio_ampl(iChannel3, 0.02);\n    centered /= 1.0 + 0.03*(sample0-0.5);\n    centered.x *= 0.97 + 0.01*(1.0 + cos(iTime));\n    float mirrored = abs(centered.x);\n    centered.x *= iResolution.x / iResolution.y;\n    \n    float dist2 = dot(centered, centered);\n    float clamped_dist = smoothstep(0.0, 1.0, dist2);\n    float arclength    = abs(atan(centered.y, centered.x) / radians(360.0))+0.01;\n    float shine_shift = 0.15-centered.y;\n    \n    float sample1 = audio_freq(iChannel3, mirrored + 0.01);\n    float sample2 = audio_ampl(iChannel3, clamped_dist);\n    float sample3 = audio_ampl(iChannel3, arclength);\n    float sample4 = audio_freq(iChannel3, 0.01+.05*mirrored/(shine_shift));\n\n    // Color variation functions\n    float t = iTime / 100.0;\n    float polychrome = (1.0 + sin(t*10.0))/2.0; // 0 -> uniform color, 1 -> full spectrum\n    vec3 spline_args = fract(vec3(polychrome*uv.x-t) + vec3(0.0, -1.0/3.0, -2.0/3.0));\n    vec3 spline = B2_spline(spline_args);\n    \n    float f = abs(centered.y);\n    vec3 base_color  = vec3(1.0, 1.0, 1.0) - f*spline;\n    vec3 flame_color = pow(base_color, vec3(3.0));\n    vec3 disc_color  = 0.20 * base_color;\n    vec3 wave_color  = 0.10 * base_color;\n    vec3 flash_color = 0.05 * base_color;\n    \n    float disp_dist = smoothstep(-0.2, -0.1, sample3-dist2);\n    disp_dist *= (1.0 - disp_dist);\n\t\n    vec3 color = vec3(0.0);\n    \n    float shine = (sample4)*smoothstep(1.5, 0.0, shine_shift)*smoothstep(0.05, 0.3, shine_shift);\n    shine = pow(shine, 5.0);\n    \n    // spline debug\n    // vec3 s = smoothstep(-0.01, 0.01, spline-uv.y); color += (1.0-s) * s;\n    \n    float v = abs(centered.y);\n    color += flame_color * smoothstep(v, v*8.0, sample1);\n    color += disc_color  * smoothstep(0.5, 1.0, sample2) * (1.0 - clamped_dist);\n    color += flash_color * smoothstep(0.5, 1.0, sample3) * clamped_dist;\n    color += wave_color  * disp_dist;\n    color = dust_motes(color, centered+sample0*0.03-0.06, 10, t*10.0);\n    color += intro * intro*flame_color * shine;\n    color = pow(color, vec3(0.4545));\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XtsGzn", "previewfilepath": "https://soundcloud.com/finn-bollongino/galactic-love-song-original", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/finn-bollongino/galactic-love-song-original", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 371, 371, 417], [418, 418, 471, 471, 517], [519, 519, 609, 609, 801], [803, 803, 823, 823, 852], [854, 854, 920, 920, 1328], [1330, 1330, 1354, 1398, 1705], [1707, 1707, 1764, 1764, 4066]], "test": "error"}
{"id": "lddGRH", "name": "Night Road", "author": "AkshayDhok", "description": "\nIn the process of learning distance rayMarching I created this scene.\nModified @XT95 's checker function to create path. Thanks for that!!\nThis shader is result of improvement over my old shader : https://www.shadertoy.com/view/lst3z8\n", "tags": ["raymarch", "sky", "road", "night", "ride"], "likes": 8, "viewed": 484, "published": "Public", "date": "1448660863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 sun_position_shift = vec2( 1.0,-0.5);\n\nvec4 SkyColor = vec4(0.3, 0.3, 0.5, 1.0);\n\nfloat ground_height = -0.55;\n\nfloat Brightness = 0.2; \n\n//more steps you take more accurate will be the results\n// less steps color gets fadded\nconst int maxSteps = 10;\n\nfloat sphereRadius = 0.15;\n\n//min considerable distance to break marching \nfloat epsilon = 0.01;\n\n\n//returns distance of point p from sphere of given radius \nfloat distSphere(vec3 p, float radius)\n{\n    //if point is outside the radius it will return +ve\n    // else it will return -ve value\n    return length(p) - radius;\n}\n\n//Standard ray march implementation\nfloat raymarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        //pick a point p from origin along rayDirection\n        //at distance step t. (addition of 2 vectors)\n        vec3 p = rayOrigin + rayDirection * t; \n        \n        //calculate distance of p from sphere\n        float d = distSphere(p, sphereRadius);\n        \n        \n        //increment the step value by distance\n        t += d;\n        \n        //if we are close enough to target pixel. break\n        if(d < epsilon)\n        {\n            break;\n        }\n    }\n    return t;\n}\n\n//Function returns the sky shade besed on uv.y \nvec4 DrawSky(vec2 uv)\n{\n    vec4 color = vec4(0.0, 0.0, 0.3, 1.0);\n    // above 0 is sky below is ground\n    if(uv.y > ground_height)\n    {\n        //adding gradient by adding uv.y value.\n        color = SkyColor + (-uv.y * Brightness); //multiply by brightness\n        \n        //if brightness is high, change in y will be more giving bright color\n    }\n    \n    return color;\n}\n\n//Function responsible for road color\nfloat road( vec3 p )\n{ \n    // draw black for x in range of [-2,2] else draw gray\n    float road =  abs(p.x) < 2.0 ? 0.1 : 0.25;\n    \n    // alternator for strip 1 if z is divisible by 2 else 0\n    float i = mod(floor(p.z),2.0) < 1.0 ? 1.0 : 0.0;\n    \n    //strin is narrower than road \n    float strips =  (abs(p.x) < 0.1) ? 0.25*i : 0.0;\n    \n    return road + strips;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //map uv in 0-1 range\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //shift uv to -1 to 1 range\n    uv = uv * 2.0 - 1.0;\n    //correct aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //screen goes from 0 to 1 in x and y\n    // eye (camera) is at center\n    vec3 eye   = vec3(0, 0, -1);\n    \n    //ray vector starts from origin in direction of uv \n    //as uv covers all the pixels on screen thus ray\n    //goes in all direction in +ve z axis. \n    vec3 ray = normalize(vec3(uv + sun_position_shift,1.0));\n    \n    //origin of ray should be eye position\n    vec3 rayOrigin = normalize(eye);\n\n    \n    float t = raymarch(rayOrigin, ray);\n    \n    vec4 sky = vec4(1.0/t) + DrawSky(uv);\n    \n    //magic numbers 1: 0.2 here define the width of distance road\n    //magic numbers 2: 1.8 here define the number of strips on road\n\tvec3 dir = normalize( vec3(uv.x, uv.y+0.2, 1.8));\n    \n    // dividing x and z by y - this make the road narrow as we go up in y \n    // also adding global time in z to make strips move\n    vec3 path = vec3( road(dir.xzz/dir.y + vec3(0.0, 0.0, -iTime*3.0)));\n    \n    //mixing two images\n    vec3 color = mix(path, sky.xyz, exp(-max(-uv.y*20.0 - 5.0,0.0)) );\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 416, 456, 549, 582], [584, 620, 671, 671, 1225], [1227, 1275, 1298, 1298, 1654], [1656, 1694, 1716, 1775, 2066], [2068, 2068, 2125, 2151, 3366]], "test": "ok"}
{"id": "lddGz8", "name": "Colour cycling test", "author": "bananaboy", "description": "Some kind of Barycentric colour cycling thing.", "tags": ["2d", "colourcycling"], "likes": 1, "viewed": 135, "published": "Public", "date": "1448158923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    vec3 p0 = vec3(1.0, 0.0, 0.0);\n    vec3 p1 = vec3(0.0, 1.0, 0.0);\n    vec3 p2 = vec3(0.0, 0.0, 1.0);\n    float t = 1.0 - uv.x - uv.y;\n    t = abs(cos(t + sin(iTime) + iTime * 0.1));\n    vec3 colour = (uv.x * p0) + (uv.y * p1) + (t * p2);\n\tfragColor = vec4(colour.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 386]], "test": "ok"}
{"id": "ll2SDK", "name": "2DD", "author": "fantomas", "description": ":)", "tags": ["2d", "fractale"], "likes": 8, "viewed": 840, "published": "Public API", "date": "1446654144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy-0.5)*5.;\n    float an;\n    for (int i=0; i<24; i++)\n    {\n        an =1.+cos(length(uv/=1.6)*5.+_t/2.);\n        uv += normalize(vec2(-uv.y, uv.x))*an/6.;\n        uv = abs(uv*=1.8)-_t/20.-2.5;        \n    }\n    float d=length(uv)*2.;\n\tfragColor = normalize(vec4(sin(d),sin(d*1.2),sin(d*1.3),0.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2SDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 75, 75, 416]], "test": "ok"}
{"id": "ll2XWc", "name": "SwegShit", "author": "TinoPit", "description": "I've seen som sht", "tags": ["drugs"], "likes": 4, "viewed": 111, "published": "Public", "date": "1447067481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(1.0,1.0,1.0,1.0);\n    \n    //Cration du repere\n    float viewX = iResolution.x/2.0;;\n\tfloat viewY = iResolution.y/2.0;\n    \n    float repWidth = 0.05;\n    \n\tfloat x = fragCoord.x - viewX;\n    float y = fragCoord.y - viewY;\n    float dist = sqrt(x*x+y*y);\n    \n    float light = (cos((dist/3.0)-iTime*20.0)+1.0)*3.0;\n    \n    \n    \n    //Creation du cercle\n    \n    \n    \n    //if (cos(dist) < light)\n   // {\n        fragColor = vec4 (light,light,light,1.0);\n      //  return;\n    //}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2XWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 603]], "test": "ok"}
{"id": "llBSDK", "name": "Magic Tree", "author": "dr2", "description": "A tree with its own temple (mouse enabled).", "tags": ["raymarching", "fractal", "tree"], "likes": 9, "viewed": 870, "published": "Public API", "date": "1446464923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Magic tree\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Tree includes ideas from eiffie (4s23Rh) and iapafoto (XsS3Dm).\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  const vec2 e = vec2 (1., -1.);\n  return q * cos (a) * e.xx + q.yx * sin (a) * e.yx;\n}\n\nmat3 RMat3D (vec3 a)\n{\n  vec3 cr, sr;\n  cr = cos (a);\n  sr = sin (a);\n  return mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrECapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, 0., h))) - r;\n}\n\nmat3 bRot;\nvec3 qHit, sunDir;\nfloat tCur, trAge, trBloom, szTree, nCyc, flRad, brLen, brRad, brRadMax;\nint idObj;\nconst float sScale = 0.726;\nconst float dstFar = 100.;\nconst int brMax = 14;\nconst int idBase = 1, idCol = 2, idRing = 3, idTop = 4, idWat = 5, idIWall = 6,\n   idLatt = 7, idOWall = 8, idBrnch = 101, idFlwr = 120;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.1 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    f = Noisefv2 ((ro.xz - rd.xz * ro.y / rd.y) * 17.1);\n    col = mix (mix (vec3 (0.2, 0.4, 0.2), vec3 (0.3, 0.6, 0.3), f),\n       0.9 * (vec3 (0.1, 0.2, 0.4) + 0.2) + 0.1, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat TreeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rFac, d, fr;\n  q = p / szTree;\n  q.xz = Rot2D (q.xz, 1.3 * nCyc);\n  q *= RMat3D (vec3 (0.2, 0.5, -0.2));\n  rFac = 1.;\n  for (int j = 0; j < brMax - 4; j ++) {\n    rFac *= sScale;\n    brRad = max (brRadMax - 0.02 * q.y, 0.02);\n    d = PrECapsDf (q.xzy, brRad, brLen) * rFac;\n    if (d < dMin) {\n      dMin = SmoothMin (dMin, d, 0.1 * brRad * rFac);\n      idObj = idBrnch + j;\n      qHit = q;\n    }\n    q.x = abs (q.x);\n    q.y -= brLen;\n    q *= bRot;\n  }\n  fr = 0.8 * flRad;\n  for (int j = 0; j < 4; j ++) {\n    rFac *= sScale;\n    d = PrCylDf (q + vec3 (brRad, brLen, 0.), fr, 0.03 * brLen) * rFac;\n    if (d < dMin) {\n      dMin = d;\n      idObj = idFlwr + j;\n      qHit = q;\n    }\n    q.x = abs (q.x);\n    q.y -= brLen;\n    q *= bRot;\n    fr += 0.05 * flRad;\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  const vec3 bIw = vec3 (7., 0., 9.);\n  const vec3 bOw = vec3 (8.9, 0., 10.9);\n  const float tIw = 0.3, hIw = 0.6;\n  const float tOw = 0.15, cLen = 2.4, hb = 0.05, hTop = 0.4;\n  float dMin, d, da, db, wr;\n  dMin = dstFar;\n  q = p;\n  db = max (PrBox2Df (q.xz, bIw.xz + tIw), - PrBox2Df (q.xz, bIw.xz - tIw));\n  q.y -= hb;\n  d = PrBoxDf (q, vec3 (bOw.x + 0.5, hb, bOw.z + 0.5));\n  if (d < dMin) { dMin = d;  idObj = idBase;  qHit = q; }\n  q = p;\n  q.y -= 2. * hb + cLen + hIw + 1.1 * hTop;\n  d = max (max (PrBox2Df (q.xz, bOw.xz + tOw),\n     - PrBox2Df (q.xz, bOw.xz - tOw)), abs (q.y) - (cLen + hIw + 1.1 * hTop));\n  d = max (d, - min (PrBox2Df (q.xy, vec2 (bOw.x - 0.5, 3.)),\n     PrBox2Df (q.zy, vec2 (bOw.z - 0.5, 3.))));\n  d = max (d, min (- q.y, 0.7 - min (abs (q.x), abs (q.z))));\n  if (d < dMin) { dMin = d;  idObj = idOWall;  qHit = q; }\n  q = p;\n  q.y -= hIw + 2. * hb;\n  d = min (d, max (max (PrBoxDf (q, vec3 (bIw.x + tIw, hIw, bIw.z + tIw)),\n     0.7 - min (abs (q.x), abs (q.z))), db));\n  if (d < dMin) { dMin = d;  idObj = idIWall;  qHit = q; }\n  q = p;\n  q.y -= 2. * cLen + hTop + 2. * hIw + 2. * hb;\n  d = max (PrBoxDf (q, vec3 (bIw.x + tIw, hTop, bIw.z + tIw)), db);\n  q.xz = mod (q.xz + 1., 2.) - 1.;\n  q.y -= -0.6;\n  d = max (d, - min (PrCylDf (q, 0.7, bIw.z + 1.),\n     PrCylDf (q.zyx, 0.7, bIw.x + 1.)));\n  if (d < dMin) { dMin = d;  idObj = idTop;  qHit = q; }\n  q = p;\n  q.y -= 2. * cLen + 2. * hTop + 2. * hIw;\n  d = max (PrBoxDf (q, vec3 (bOw.x, hb, bOw.z)),\n     - PrBox2Df (q.xz, bIw.xz - 0.15));\n  q.xz = mod (q.xz + 1., 2.) - 1.;\n  d = max (d, - PrBox2Df (q.xz, vec2 (0.8)));    \n  if (d < dMin) { dMin = d;  idObj = idLatt;  qHit = q; }\n  q = p;\n  q.xz = mod (q.xz, 2.) - 1.;\n  q.y -= cLen + 2. * hIw + 2. * hb;\n  wr = q.y / cLen;\n  d = max (PrCylDf (q.xzy, tIw * (0.8 - 0.05 * wr * wr), cLen), db);\n  if (d < dMin) { dMin = d;  idObj = idCol;  qHit = q; }\n  q = p;\n  q.y -= 0.2;\n  d = PrCylAnDf (q.xzy, 4.4, 0.1, 0.15);\n  if (d < dMin) { dMin = d;  idObj = idRing;  qHit = q; }\n  q = p;\n  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 4.5, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idWat;  qHit = q; }\n  dMin = TreeDf (q, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 10; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 5. * h / d);\n    d *= 1.7;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.);\n}\n\nfloat ChqPat (vec3 p, float dHit)\n{\n  vec2 q, iq;\n  float f;\n  q = p.xz;\n  iq = floor (q);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = smoothstep (0., 0.1, abs (fract (q + 0.5) - 0.5));\n  f = dHit / dstFar;\n  return 1. - 0.6 * exp (-10. * f * f) * (1. - q.x * q.y);\n}\n\nvec3 ChqNorm (vec3 p, vec3 n)\n{\n  vec2 q, iq;\n  q = p.xz;\n  iq = floor (q);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = 2. * fract (q) - 1.;\n  n.xz += 0.5 * q * q * sign (q);\n  return normalize (n);\n}\n\nvoid SetupTree ()\n{\n  float t;\n  nCyc = floor (tCur / 60.);\n  trAge = tCur / 60. - nCyc;\n  trBloom = mod (5. * trAge, 1.);\n  szTree = 2.3 - 2.2 * smoothstep (0.93, 0.98, trAge);\n  t = min (trAge, 0.8);\n  brLen = min (0.95, 0.03 + 1.3 * sqrt (t));\n  brRadMax = 0.01 + 0.12 * sqrt (t);\n  flRad = (0.2 + 6. * t) * (0.05 +\n     0.8 * clamp (6. * trBloom * (1. - trBloom) - 0.1, 0., 1.));\n  bRot = RMat3D (vec3 (-0.5 + 0.3 * t, -1.5, 0.7 + 0.2 * t) +\n     0.05 * sin (0.5 * nCyc)) / sScale;\n}\n  \nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], chRingO, chRingI, vuVel, a, r, tO, tI, tR, rGap;\n  bool rotStep;\n  chRingO = 21.;\n  chRingI = 6.;\n  vuVel = 2.;\n  tO = 0.5 * pi * chRingO / vuVel;\n  tI = 0.5 * pi * chRingI / vuVel;\n  rGap = chRingO - chRingI;\n  tR = rGap / vuVel;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tO;  ti[2] = ti[1] + tR;\n  ti[3] = ti[2] + tI;  ti[4] = ti[3] + tR;\n  p.y = 4.;\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    rotStep = true;\n    a = (t - ti[0]) / (ti[1] - ti[0]);\n    r = chRingO;\n  } else if (t < ti[2]) {\n    tr.y = chRingO - rGap * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    rotStep = true;\n    a = 1. - (t - ti[2]) / (ti[3] - ti[2]);\n    r = chRingI;\n  } else {\n    tr.x = chRingI + rGap * (t - ti[3]) / (ti[4] - ti[3]);\n  }\n  if (rotStep) {\n    a *= 0.5 * pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  return p;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 objCol, col, roo, vn, vnw;\n  float dstHit, refl, sh, a, f;\n  int idObjT;\n  refl = 1.;\n  idObj = -1;\n  roo = ro;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar && idObj == idWat) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    vec2 u = ro.xz;\n    float s = length (u);\n    u /= s;\n    u *= cos (20. * s - 5. * tCur) * (1. - s / 5.);\n    vn = normalize (vec3 (u.x, 50., u.y));\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    refl *= 0.9;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idCol) {\n      a = 0.5 - mod (20. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5), 1.);\n      vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a));\n    }\n    if (idObj == idBase) {\n      objCol = vec3 (0.6, 0.6, 0.5);\n      if (vn.y > 0.99) {\n        if (abs (abs (qHit.x) - 3.7) < 3. && abs (abs (qHit.z) - 4.7) < 4.) {\n\t  objCol = mix (vec3 (0.2, 0.5, 0.2), vec3 (0.3, 0.8, 0.2),\n             Noisefv2 (qHit.xz * 41.)) * (0.5 + 0.5 * Noisefv2 (qHit.zx * 57.));\n\t} else {\n          objCol *= ChqPat (qHit * vec3 (3., 1., 3.), dstHit);\n          vn = ChqNorm (qHit * vec3 (3., 1., 3.), vn);\n          vn = VaryNf (10. * qHit, vn, 2.);\n\t}\n      } else {\n        vn = VaryNf (20. * qHit, vn, 5.);\n      }\n    } else if (idObj == idTop || idObj == idIWall) {\n      objCol = vec3 (0.6, 0.6, 0.5);\n      vn = VaryNf (20. * qHit, vn, 2.);\n    } else if (idObj == idOWall) {\n      objCol = vec3 (0.6, 0.57, 0.6);\n      vn = VaryNf (20. * qHit, vn, 5.);\n    } else if (idObj == idLatt) {\n      objCol = vec3 (0.6, 0.6, 0.5);\n      vn = VaryNf (5. * qHit, vn, 1.);\n    } else if (idObj == idRing) {\n      objCol = vec3 (0.9, 0.7, 0.4);\n      vn = VaryNf (20. * qHit, vn, 1.);\n    } else if (idObj == idCol) {\n      objCol = vec3 (0.9, 0.7, 0.6);\n      vn = VaryNf (20. * qHit, vn, 1.);\n    } else if (idObj >= idBrnch && idObj < idFlwr + 4) {\n      if (idObj < idFlwr) {\n\tobjCol = mix (vec3 (0.3, 0.7, 0.3), vec3 (0.5, 0.3, 0.1),\n           smoothstep (0.02, 0.05, trAge));\n\tobjCol *= (0.7 + 0.3 * clamp (0.7 + 0.6 * cos (11. * qHit.y), 0., 1.));\n\ta = mod (20. * (atan (qHit.z, qHit.x) / (2. * pi) + 0.5), 1.);\n\tvn.xz = Rot2D (vn.xz, 0.5 * sin (pi * a));\n\tvn = VaryNf (50. * ro, vn, 5. * smoothstep (0.03, 0.08, trAge));\n      } else {\n\tobjCol = HsvToRgb (vec3 (0.35 * max (0.05 * float (idObj - idFlwr) +\n           1. - 1.2 * trBloom, 0.),\n\t   0.05 + 0.95 * smoothstep (0.15, 0.2, trBloom), 1.)); \n\tif (idObj == idFlwr + 3) objCol = mix (vec3 (1., 0., 0.), objCol,\n\t   smoothstep (0.05, 0.2, trBloom));\n\tobjCol = mix (objCol, vec3 (0.5, 0.3, 0.1), smoothstep (0.9, 1., trBloom));\n      }\n      objCol = mix (objCol, vec3 (0.8), smoothstep (0.93, 0.98, trAge));\n    }\n    sh = ObjSShadow (ro, sunDir);\n  } else {\n    if (rd.y < 0.) {\n      sh = 0.7 + 0.3 * ObjSShadow (ro - rd * ro.y / rd.y, sunDir);\n    } else sh = 1.;\n  }\n  if (dstHit < dstFar) {\n    col = refl * objCol * (0.3 +\n       0.7 * max (dot (vn, sunDir), 0.) * (0.5 + 0.5 * sh) +\n       0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n  } else col = sh * BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mat3 vuMat;\n  vec3 ro, rd, vd, u;\n  float f, tPath;\n  tPath = tCur;\n  if (mPtr.z > 0.) tPath = 50. + 50. * mPtr.y;\n  SetupTree ();\n  ro = 0.5 * (TrackPath (tPath + 0.2) + TrackPath (tPath - 0.2));\n  vd = normalize (vec3 (0., 0.5 + 2.5 * min (trAge, 0.8) * szTree, 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 1. + 0.03 * length (ro)));\n  sunDir = normalize (vec3 (1., 3., 1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBSDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[333, 333, 357, 357, 404], [406, 406, 431, 431, 630], [632, 632, 653, 653, 792], [794, 794, 823, 823, 1035], [1037, 1037, 1076, 1076, 1293], [1295, 1295, 1340, 1340, 1443], [1445, 1445, 1475, 1475, 1563], [1565, 1565, 1587, 1587, 1816], [1818, 1818, 1842, 1842, 1978], [1980, 1980, 2012, 2012, 2107], [2109, 2109, 2142, 2142, 2226], [2228, 2228, 2270, 2270, 2321], [2323, 2323, 2376, 2376, 2437], [2439, 2439, 2483, 2483, 2546], [2877, 2877, 2908, 2908, 3506], [3508, 3508, 3543, 3543, 4344], [4346, 4346, 4368, 4368, 6544], [6546, 6546, 6579, 6579, 6755], [6757, 6757, 6778, 6778, 6991], [6993, 6993, 7030, 7030, 7233], [7235, 7235, 7270, 7270, 7514], [7516, 7516, 7547, 7547, 7728], [7730, 7730, 7749, 7749, 8217], [8221, 8221, 8247, 8247, 9166], [9168, 9168, 9203, 9203, 12394], [12396, 12396, 12452, 12452, 13199]], "test": "error"}
{"id": "llBSWc", "name": "Bias Function", "author": "qwert33", "description": "A function to tweak the range of 0..1 to give it a bias towards 0 or 1. \nhttps://www.desmos.com/calculator/c4w7ktzhhk\nIt it is similar to a brightness/contrast function but does not loose information due to clipping.\n\nMade by Dominik Schmid. MIT license.", "tags": ["function", "tweak", "plotting", "bias", "twang"], "likes": 11, "viewed": 1354, "published": "Public API", "date": "1446851914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made by Dominik Schmid\n// MIT license\n\n\n\n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    b = -log2(1.0 - b);\n    return 1.0 - pow(1.0 - pow(x, 1./b), b);\n}\n\n\nfloat PI = 3.1415926;\n#define t iTime\n#define bias_number 0.4*sin(iTime) + 0.5\n\nfloat formula(float x) {\n    return bias(x, bias_number);\n}\nbool isClose(float a, float b) { return abs(a-b) < 0.005; }\nvoid plot(out vec4 fragColor, in vec2 uv )\n{\n    float px = 2.0 / iResolution.x;\n    float py = 2.0 / iResolution.y;\n   \n\n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 blue  = vec4(0.1, 0.1, 0.9, 1.0);\n    if (isClose(uv.x, 0.5)) color = blue;\n    if (isClose(uv.x, 1.5)) color = blue;\n    if (isClose(uv.y, 0.5)) color = blue;\n    if (isClose(uv.y, 1.0)) color = blue;\n\t\n    \n    float x = (uv.x - .5);\n    float y = formula(x);\n    float y2 = formula(x + px*.5);\n    float dy = max(px*4.0, abs(y2 - y));\n    \n    float modX = floor(.5+10.0*(uv.x-.5)) / 10.0;\n    float fmodX = formula(modX);\n\n    // 2d samples\n    // ok but wonky and horribly inefficient\n    float avg = 0.0;\n    float screen_y = 0.0;\n    float stroke = 1.0;\n    float dist = 0.0;\n    for (float step_x = -1.0; step_x < 1.0; step_x += .1)\n    {\n        x = (uv.x - .5 +3.0*stroke*(-step_x)*px);\n        \n        for (float step_y = -1.0; step_y < 1.0; step_y += .1)\n        {\n            \n            y = formula(x);\n            screen_y = uv.y + stroke*(-step_y)*py;\n            dist = step_x*step_x + step_y*step_y;\n            dist /= stroke*stroke;\n            avg += (1.0 - min(1.0,(abs(screen_y-.5  - .5*y)/py))) /dist;\n        }\n    }\n    avg /= 100.0;\n    color.r -= avg;\n    color.g -= avg; \n    color.b -= avg;\n    fragColor = color;\n}\n\n\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    p /= iResolution.xy;\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.2377))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec2 p){\n    return clamp(rand(p)*1.005, 0.0, 1.0); \n}\n\n\nvoid applyBias(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(\n        bias(rand_inclusive(fragCoord), bias_number)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (isClose(uv.x, 0.5)) {\n        fragColor = vec4(0.5);\n    }\n    else if (uv.x < 0.5) {\n        uv += vec2(0.4, 0.3);\n        uv -= vec2(0.5);\n        uv *= vec2(3.0, 1.0);\n        uv += vec2(0.5);\n        //uv += vec2(0.5, 0.0);\n        plot(fragColor, uv);\n    }\n    else {\n        applyBias(fragColor, fragCoord);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBSWc.jpg", "access": "shaders20k", "license": "mit", "functions": [[44, 360, 390, 390, 461], [544, 544, 568, 568, 603], [604, 604, 636, 636, 663], [664, 664, 708, 708, 1985], [1989, 2054, 2073, 2073, 2171], [2173, 2238, 2267, 2267, 2313], [2316, 2316, 2371, 2371, 2455], [2457, 2457, 2512, 2512, 2893]], "test": "ok"}
{"id": "llBSWt", "name": "LineSegment", "author": "jt", "description": "A bouncing line segment.", "tags": ["linesegment"], "likes": 6, "viewed": 301, "published": "Public", "date": "1447263304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Line Segment (bouncing) written 2015 by Jakob Thomsen\n\n// mirror/bounce inside -1,+1\nvec2 mirror(vec2 pos)\n{\n    return (2.0 * abs(2.0 * fract(pos) - 1.0) - 1.0);\n}\n\n// Cleaned up by Fabrice ;)\nfloat PointLineSegDist2d(vec2 a, vec2 b, vec2 p)\n{\n    p -= a; b -= a;                        // go to A referential\n    float q = dot(p, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate\n    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P \n    return length( p - b);                 // distance to P\n}\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    vec2 speed0 = vec2(0.0432, 0.0123);\n    vec2 speed1 = vec2(0.0257, 0.0332);\n    I = 2. * I / iResolution.xy - 1.;\n    vec2 a = mirror(iTime * speed0);\n    vec2 b = mirror(iTime * speed1);\n    float d = PointLineSegDist2d(a, b, I);\n\to = vec4(1.0 - smoothstep(0.0, 0.01, d)); // line\n    //o = vec4(pow(1.0 - d, 17.0)); // glow\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 88, 111, 111, 167], [169, 197, 247, 247, 549], [551, 551, 592, 592, 924]], "test": "ok"}
{"id": "llBXDc", "name": "05", "author": "yiwenl", "description": "05", "tags": ["raymarching"], "likes": 6, "viewed": 823, "published": "Public API", "date": "1446900497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\tTOOLS\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\n//\tGEOMETRY\nfloat sphere(vec3 pos, float radius) {\treturn length(pos) - radius;\t}\nfloat box(vec3 pos, vec3 size) {\treturn length(max(abs(pos) - size, 0.0)); }\n\nfloat substract(float d1, float d2) {\treturn max(-d1,d2);\t}\nfloat intersection(float d1, float d2) { return max(d1, d2);\t}\n\n\nconst float thickness = .05;\nconst float gap = .15;\nconst float numLayers = 7.0;\nconst float diff = .3;\nconst float maxDist = 3.6;\nconst int NUM_ITER = 100;\n\nfloat shell(vec3 pos, float radius, float index) {\n\tpos.xz        = rotate(pos.xz, sin(index * diff-iTime*.35784));\n\tpos.yz        = rotate(pos.yz, cos(index * diff-iTime*.7845));\n\tfloat dOuter  = sphere(pos, radius);\n\tfloat dInner  = sphere(pos, radius-thickness);\n\tfloat dBox    = box(pos + vec3(0.0, 0.0, -radius), vec3(radius));\n\t\n\tfloat dSphere = substract(dInner, dOuter);\n\tfloat d       = intersection(dSphere, dBox);\n\treturn d;\n}\n\n\nfloat map(vec3 pos) {\n\tfloat r = 1.5;\n\tfloat d = shell(pos, r, 0.0);\n\tfloat dShell;\n\tfor(float i=1.0; i<numLayers; i+= 1.0) {\n\t\tr += gap;\n\t\tdShell = shell(pos, r, i);\n\t\td = min(d, dShell);\n\t}\n\t\n\treturn d;\n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.01, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n\t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n\t\tmap(pos + eps.yyx) - map(pos - eps.yyx)\n\t);\n\treturn normalize(normal);\n}\n\n\n//\tLIGHTING\n\nfloat diffuse(vec3 normal, vec3 lightDirection) {\n\treturn max(dot(normal, normalize(lightDirection)), 0.0);\n}\n\nvec3 diffuse(vec3 normal, vec3 lightDirection, vec3 lightColor) {\n\treturn lightColor * diffuse(normal, lightDirection);\n}\n\nfloat specular(vec3 normal, vec3 dir) {\n\tvec3 h = normalize(normal - dir);\n\treturn pow(max(dot(h, normal), 0.0), 50.0);\n}\n\n\nconst vec3 lightPos0 = vec3(1.0, .75, -1.0);\nconst vec3 lightColor0 = vec3(1.0, 1.0, .96);\nconst float lightWeight0 = 0.75;\n\nconst vec3 lightPos1 = vec3(-1.0, -0.75, 0.0);\nconst vec3 lightColor1 = vec3(.96, .96, 1.0);\nconst float lightWeight1 = 0.25;\n\n\nvec4 getColor(vec3 pos, vec3 dir, vec3 normal) {\n\tfloat ambient = .2;\n\tvec3 diff0 = diffuse(normal, lightPos0, lightColor0) * lightWeight0;\n\tvec3 diff1 = diffuse(normal, lightPos1, lightColor1) * lightWeight1;\n\n\t// float spec = specular(normal, dir) * 1.;\n\tvec3 color = vec3(ambient) + diff0 + diff1;\n\n\treturn vec4(color, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focus = 2.25;\n    vec3 pos   = vec3(0.0, 0.0, -10.0);\t\t//\tposition of camera\n\tvec3 dir   = normalize(vec3(uv, focus));\t//\tray\n\tvec4 color = vec4(.1, .1, .1, 1.0);\n\tfloat prec = .0001;\n\tfloat d;\n\n\t\n\tfor(int i=0; i<NUM_ITER; i++) {\n\t\td = map(pos);\t\t\t\t\t\t//\tdistance to object\n\n\t\tif(d < prec) {\t\t\t\t\t\t// \tif get's really close, set as hit the object\n\t\t\tcolor       = vec4(1.0);\n\t\t\tvec3 normal = computeNormal(pos);\n\t\t\tcolor       = getColor(pos, dir, normal);\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += d * dir;\t\t\t\t\t\t//\tmove forward by\n\t\tif(length(pos) > maxDist) break;\n\t}\n\t\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 10, 46, 46, 128], [130, 142, 180, 180, 211], [212, 212, 244, 244, 288], [290, 290, 327, 327, 349], [350, 350, 390, 390, 412], [573, 573, 623, 623, 1010], [1013, 1013, 1034, 1034, 1219], [1221, 1221, 1251, 1251, 1463], [1479, 1479, 1528, 1528, 1588], [1590, 1590, 1655, 1655, 1711], [1713, 1713, 1752, 1752, 1834], [2090, 2090, 2138, 2138, 2419], [2422, 2422, 2479, 2479, 3182]], "test": "ok"}
{"id": "llBXWV", "name": "Exit Sunlight", "author": "felixfaire", "description": "Very quick attempt to mimic a photograph by Marcus W. :P", "tags": ["horizon"], "likes": 15, "viewed": 325, "published": "Public", "date": "1446489230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 col1 = vec3( 0.938, 0.678, 0.375 );\nvec3 col2 = vec3( 0.455, 0.456, 0.55 );\n\nfloat hillSoftening = 0.01;\nfloat reflectionSoftening = 0.1;\n\n\n \nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n \nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n        f = f*f*(3.0-2.0*f);\n        float n = p.x + p.y*57.0;\n        float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n        return res;\n}\n \nfloat fbm( vec2 p )\n{\n        float f = 0.0;\n        f += 0.50000*noise( p ); p = p*2.02;\n        f += 0.25000*noise( p ); p = p*2.03;\n        f += 0.12500*noise( p ); p = p*2.01;\n        f += 0.06250*noise( p ); p = p*2.04;\n        f += 0.03125*noise( p );\n        return f/0.984375;\n}\n\n\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n \nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n \nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n \nvec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat pnoise(vec2 P, vec2 rep)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n     \n    vec4 i = permute(permute(ix) + iy);\n     \n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n     \n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n     \n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;  \n    g01 *= norm.y;  \n    g10 *= norm.z;  \n    g11 *= norm.w;  \n     \n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n     \n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3( 0.0 );\n    \n    if (abs(uv.x) < 1.0)\n    {\n\n    \n    \t// add sky\n    \tcol += mix( col1, col2, abs(uv.y) ) + 0.2;\n    \tcol += mix( vec3(1.0), vec3(0.3), abs((uv.y - 0.45) * 1.5) ) * 0.3;\n\n    \t// add hills\n    \tfor (int i = 0; i < 2; i++)\n    \t{\n        \tfloat edge = fbm( vec2(0.0, uv.x * 3.0 + float(i)) ) * 0.15 + 0.1;\n    \t\tif (uv.y < edge + hillSoftening && uv.y > 0.0)\n        \t\tcol -= 0.8 * smoothstep( edge + hillSoftening, edge, uv.y );\n    \t}\n\n    \t// add vignette\n    \tfloat r = length( uv );\n    \tcol -= r * r * 0.2;\n    \n    \tfloat dist = 1.0 - abs(uv.y) * 0.9;\n    \tuv.y *= 0.9;\n    \n    \t// add shadows\n    \tif (uv.y < 0.1)\n    \t{\n        \tuv.x *= dist * 1.2;\n        \tcol -= 0.6 * smoothstep(-0.3, 0.1, uv.y);\n        \n        \tfloat sand = pnoise(vec2(uv.x * 3.5 * dist + dist * 100.0, uv.y * 40.0 * dist), vec2(100.0, 100.0)) - \n            \t\t pnoise(vec2(uv.x * 5.0 * dist * dist * dist, uv.y * 1.0 * dist), vec2(100.0, 100.0));\n     \t\tif (sand > 0.4)\n            \tcol -= smoothstep(0.4, 0.7, dist) * 0.2 * smoothstep( 0.4, 0.8, sand); \n\n    \t}\n\n    \t// warp reflections\n    \tif (uv.y < 0.0)\n    \t{\n    \t\tuv.x += 0.05 * pnoise(vec2(uv.x * 10.0 * dist, uv.y * 100.0 * dist + iTime * 0.5), vec2(100.0, 100.0));\n    \t\tuv.y += 0.04 * pnoise(vec2(uv.x * 10.0 * dist, uv.y * (100.0 * dist + 20.0) + iTime * 0.5), vec2(50.0, 100.0)) * (0.5 + abs(uv.x) * 2.0) - 0.05;\n    \t}\n    \n   \t\t// add mountain reflections\n    \tfor (int i = 0; i < 2; i++)\n    \t{\n        \tfloat edge = fbm( vec2(0.0, uv.x * 3.0 + float(i)) ) * 0.1 + 0.1;\n \n        \tif (uv.y > -edge - reflectionSoftening && uv.y < 0.1)\n        \t\tcol -= 0.3 * smoothstep( -edge - reflectionSoftening, -edge, uv.y );\n    \t}\n    \n    \t// highlights\n    \tcol -= smoothstep( 0.5, 0.0, abs(uv.y + 0.6) ) * 0.2;\n    \tcol += smoothstep( 0.3, 0.0, abs(uv.y + 0.3) ) * 0.1;\n    \tcol -= smoothstep( 0.6, 0.0, abs(uv.y + 1.0) ) * 0.1;\n    \tcol.z += 0.05 * (1.0 - dist);\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 170, 170, 209], [212, 212, 238, 238, 478], [481, 481, 502, 502, 767], [771, 771, 792, 792, 843], [846, 846, 868, 868, 907], [910, 910, 938, 938, 992], [995, 995, 1014, 1014, 1056], [1058, 1058, 1090, 1090, 2295], [2299, 2299, 2356, 2356, 4458]], "test": "ok"}
{"id": "lljSDd", "name": "Pshychodelic", "author": "Instationa", "description": "Pixel shader on acid", "tags": ["mandlebrot"], "likes": 1, "viewed": 757, "published": "Public API", "date": "1447505126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 calcMandleBase(vec2 xy, vec2 c)\n{\n    return vec2(xy.x*xy.x-xy.y*xy.y + c.x, 2.0*xy.x*xy.y + c.y);\n}\n\nfloat calcMandelBrot(vec2 xy)\n{\n    float count = 0.0;\n    float vecLength = 0.0;\n    vec2 mandleBase = xy;\n    for(int i = 0; i < 500; i++)\n    {\n    \tmandleBase = calcMandleBase(mandleBase, xy);\n    \tvecLength = length(mandleBase);\n        if(vecLength >= 2.0)\n        {\n         \tbreak;   \n        }\n        count++;\n    }\n    \n    return count;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Position = (fragCoord - iResolution.xy/2.0) / iResolution.xy;\n    float mandleBrot = mod(calcMandelBrot((Position+vec2(0.08802,0.1058)*pow(iTime * 10.0,2.0))*4.0/(pow(iTime* 10.0,2.0))),iTime * 10.0) / (iTime * 10.0);\n    float mandleBrot2 = mod(calcMandelBrot((Position+vec2(0.08702,0.1055)*pow(iTime * 20.0,2.0))*4.0/(pow(iTime* 20.0,2.0))),iTime * 20.0) / (iTime * 20.0);\n    float mandleBrot3 = mod(calcMandelBrot((Position+vec2(0.08602,0.1045)*pow(iTime * 40.0,2.0))*4.0/(pow(iTime* 40.0,2.0))),iTime * 5.0) / (iTime * 5.0);\n    fragColor = vec4(mandleBrot, mandleBrot2 , mandleBrot3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 105], [107, 107, 138, 138, 457], [459, 459, 516, 516, 1122]], "test": "ok"}
{"id": "lljXWc", "name": "Wololo", "author": "apulby", "description": "Wololo, you're mine now", "tags": ["wololo"], "likes": 3, "viewed": 107, "published": "Public", "date": "1447067412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoord )\n    \n{\n\t/*vec2 uv = pixCoord.xy / iResolution.xy;\n    \n    \n    float cameraX = iResolution.x / 2.0;\n    float cameraY = iResolution.y / 2.0;\n    float zoom    = iResolution.x / 10.0;\n    float x = pixCoord.x - cameraX;\n    float y = pixCoord.y - cameraY;\n    \n    \n    y/=zoom;\n    x/=zoom;\n    float dist = sqrt((x * x) + (y * y));\n    if (dist < 10000.0 ) {\n        color = vec4(cos(dist/10.0-iTime*10.0)+1.0/2.0,cos(dist/10.0+iTime*10.0)+1.0/2.0,cos(dist/10.0-iTime*30.0)+1.0/2.0,1.0);\n    }*/\n    \n    vec2 uv = pixCoord / iResolution.xy,\n\tcamera = iResolution.xy / 2.,\n\txy = pixCoord - camera;\n\n\tfloat dist = length(xy);\n\tif (dist < 10000. ) \n\tcolor = cos( dist/10. + iTime*vec4(-10,10,-30,0) ) + 1.0/2.0;\n   \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 548, 773]], "test": "ok"}
{"id": "lllXz4", "name": "Inverse Spherical Fibonacci", "author": "iq", "description": "Spherical Fibonacci points, as described by this paper [url]https://dokumen.tips/documents/spherical-fibonacci-mapping-fibonacci-mapping-benjamin-keinert-1matthias-innmann.html[/url]", "tags": ["3d", "sampling", "spherical", "fibonacci"], "likes": 77, "viewed": 4053, "published": "Public API", "date": "1446535483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Spherical Fibonnacci points, as described by Benjamin Keinert, Matthias Innmann, \n// Michael Sanger and Marc Stamminger in their paper (below)\n\n\n//=================================================================================================\n// https://dokumen.tips/documents/spherical-fibonacci-mapping-fibonacci-mapping-benjamin-keinert-1matthias-innmann.html\n//=================================================================================================\n\nvec2 inverseSF( vec3 p ) \n{\n    const float kTau = 6.28318530718;\n    const float kPhi = (1.0+sqrt(5.0))/2.0;\n    const float kNum = 150.0;\n\n    float k  = max(2.0, floor(log2(kNum*kTau*0.5*sqrt(5.0)*(1.0-p.z*p.z))/log2(kPhi+1.0)));\n    float Fk = pow(kPhi, k)/sqrt(5.0);\n    vec2  F  = vec2(round(Fk), round(Fk*kPhi)); // |Fk|, |Fk+1|\n    \n    vec2  ka = 2.0*F/kNum;\n    vec2  kb = kTau*(fract((F+1.0)*kPhi)-(kPhi-1.0));    \n\n    mat2 iB = mat2( ka.y, -ka.x, kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    vec2 c = floor(iB*vec2(atan(p.y,p.x),p.z-1.0+1.0/kNum));\n\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2  uv = vec2(s&1,s>>1);\n        float id = clamp(dot(F, uv+c),0.0,kNum-1.0); // all quantities are integers\n        \n        float phi      = kTau*fract(id*kPhi);\n        float cosTheta = 1.0 - (2.0*id+1.0)/kNum;\n        float sinTheta = sqrt(1.0-cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float tmp = dot(q-p, q-p);\n        if( tmp<d ) \n        {\n            d = tmp;\n            j = id;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\n\n//=================================================================================================\n// iq code starts here\n//=================================================================================================\n\nfloat hash1( float n ) { return fract(sin(n)*158.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n    \n    vec3 col = vec3(1.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n        col = vec3(1.0);\n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n        \n        vec2 fi = inverseSF(nor);\n        col = 0.5 + 0.5*sin( hash1(fi.x*13.0)*3.0 + 1.0 + vec3(0.0,1.0,1.0));\n        col *= smoothstep(0.02, 0.03, fi.y);\n        col *= mix( 1.0, 1.0 - smoothstep(0.12, 0.125, fi.y), smoothstep(-0.1,0.1,sin(iTime) )) ;\n        col *= 1.0 + 0.1*sin(250.0*fi.y);\n        col *= 1.5;\n\t}\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\tcol *= occ;\n\t\tcol = mix( col, vec3(1.0), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllXz4.jpg", "access": "shaders20k", "license": "mit", "functions": [[1549, 1549, 1576, 1576, 2701], [2928, 2928, 2952, 2952, 2988], [2990, 2990, 3047, 3047, 4621]], "test": "ok"}
{"id": "llSSDV", "name": "Fractal anim", "author": "Aj_", "description": "Just a fractal changing one of its parameters over time", "tags": ["fractal"], "likes": 10, "viewed": 1402, "published": "Public API", "date": "1446568306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float iter    = 64.,\n            divAng  = 24. * 6.2831853/360.,\n            circRad = .23, \n    \t    rat     = .045/circRad;\n\nfloat nearestMult(float v, float of) {\n\tfloat m = mod(v, of);\n\tv -= m * sign(of/2. - m);\n\treturn v - mod(v,of);\n}\n\n//Color palette function taken from iq's shader @ https://www.shadertoy.com/view/ll2GD3\n#define  pal(t) ( .5 + .5* cos( 6.283*( t + vec4(0,1,2,0)/3.) ) )\n\nvoid mainImage( out vec4 o, vec2 uv ) {\n    vec2 R = iResolution.xy,\n         center = vec2(0.), p;\n    \n\tfloat time = iTime,\n          sCircRad = circRad*rat, \n          ds = (3.2+ 1.3*abs(sin(time/10.))) * rat,\n          ang, dist,\n\t      M = max(R.x, R.y);\n    \n \tuv = ( uv -.5*R) / M / .9;\n    o = vec4(0.0);\n\tfor(float i=0.;i< iter;i+=1.) {\n        p = uv-center;\n\t\tang =  atan(p.y,p.x);\t\t\n        ang = nearestMult(ang, divAng);     \n\t\tcenter += sCircRad/rat* vec2(cos(ang), sin(ang));\n\t\tdist = distance( center, uv);\n\n\t\tif( dist <=sCircRad )\n             o += 15.*dist * pal( fract(dist/sCircRad + abs(sin(time/2.))) );\n   \n  \t\tsCircRad *= ds;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 171, 171, 246], [403, 403, 442, 442, 1058]], "test": "ok"}
{"id": "ls3GRr", "name": "Paper Kaleidoscope", "author": "fizzer", "description": "A sketch with some paper-like pieces and soft shadowing in layers.", "tags": ["kaleidoscope", "heart", "paper"], "likes": 79, "viewed": 3297, "published": "Public", "date": "1447677612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 softPolyOffset;\nint softPolyIndex;\n\nfloat poly(vec2 p, int n, float r)\n{\n    float d=0.;\n    for(int i=0;i<8;++i)\n    {\n        float a=float(i)/float(n)*acos(-1.)*2.;\n        float b=max(0.,dot(p,vec2(cos(a),sin(a)))-r);\n        d+=b*b;\n    }\n    return sqrt(d);\n}\n\n\nfloat heart(vec2 p,float s)\n{\n    float d=max(dot(p, vec2(-1., -1.2)*8.), dot(p, vec2(1., -1.2)*8.));\n    float u=abs(p.x) + 1.7;\n    float v=max(0.0, p.y + .9);\n    return length(vec2(d, length(vec2(u, v))))-1.8-s;\n}\n\nfloat softPoly(vec2 p, int n, float r, float s)\n{\n    if(softPolyIndex==12)\n    {\n        float d=heart(p,r-s);\n        return clamp(smoothstep(0.,s*2.,d),0.,1.);\n    }      \n    p=abs(p);\n    if(p.x>p.y)\n        p=p.yx;\n    float aa=float(n);\n    p*=mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n    p-=softPolyOffset;\n    float d=poly(p,n,r-s);\n    return clamp(smoothstep(0.,s*2.,d),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 t=(uv-vec2(.5))*1.5;\n    t.x*=iResolution.x/iResolution.y;\n    vec3 col=vec3(0.2,0.15,0.1)*(cos((t.y*100.+sin(t.x+t.y*5.)*10.*cos(t.x*3.)*sin(t.y*20.))*2.)*.1+.9);\n    float depth=0.;\n    float shad0=1.,shad1=1.;\n\n    for(int i=0;i<20;++i)\n    {\n        softPolyIndex=i;\n        softPolyOffset=vec2(cos(float(i)+iTime*0.3),sin(float(i)*2.+iTime*0.1))*0.4;\n        vec2 p=t.xy;\n        vec2 p2=p;\n        int n=3+int(mod(float(i),7.));\n        float r=0.2;\n        float a=1.0-softPoly(p2,n,r,0.003);\n        float as0=softPoly(p2+2.0*vec2(0.002,0.005)*(1.0+float(i)-depth),n,r,0.01+0.003*(1.0+float(i)-depth));\n        float as1=softPoly(p2,n,r,0.01+0.01*(1.0+float(i)-depth));\n        shad0*=as0;\n        shad1*=as1;\n        shad0=mix(shad0,1.,a);\n        shad1=mix(shad1,1.,a);\n        vec3 c=(i==12)?vec3(1,.3,.6):vec3(1);\n        col=mix(col,c,a);\n        depth=mix(depth,float(i+1),a);\n    }\n\n    col=(.6*.5*col*mix(0.,1.,shad0)*vec3(1,1,.6)+.5*vec3(.8,.8,1)*col*mix(0.,1.,shad1));\n\n    col+=pow(1.0-smoothstep(0.,3.,-t.y+1.),4.)*vec3(1,1,.6)*.3;\n\n    fragColor.rgb=sqrt(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3GRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 78, 78, 271], [274, 274, 303, 303, 491], [493, 493, 542, 542, 882], [884, 884, 941, 941, 2079]], "test": "ok"}
{"id": "lsc3Rn", "name": "Plug your microphone in!!!", "author": "vox", "description": "Dammit man, find it and plug it in!!!", "tags": ["fractal"], "likes": 6, "viewed": 322, "published": "Public", "date": "1447651797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265359\n\n//#define iTime tan(iTime*.1)+iTime*.1\n\nfloat bassBoostLow = 0.0;\nfloat bassBoostHigh = 0.0;\nfloat time = 0.0;\n\nvec3 hsv(in float h, in float s, in float v)\n{\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 formula(in vec2 p, in vec2 c)\n{\n\tconst float n = 2.0;\n\tconst int iters = 5;\n\n\t//float time = iTime*0.1;\n\tvec3 col = vec3(0);\n\tfloat t = 1.0;\n\tfloat dpp = dot(p, p);\n\tfloat lp = sqrt(dpp);\n\tfloat r = smoothstep(0.0, 0.2, lp);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t// The transformation\n        //p+=vec2(sin(c.x+p.x)*.01,\n        //        cos(c.y+p.y)*.01);\n        float to = bassBoostHigh;\n        float index = mod(float(i)*1234.1234, 2.0);\n        \n        \n        if(index < .1)\n        {\n        \tp = p*mat2(cos(cos(time+to)+time+to), -sin(cos(time+to)+time+to),\n                   sin(cos(time+to)+time+to), cos(cos(time+to)+time+to));\n\t\t\tp = abs(mod(p*(1.0) + c, n) - (n)/2.0);\n        }\n        else if(index < 1.1)\n\t\t\tp = abs(mod(p*(1.0) + c, n) - (n)/2.0);//mod(p/dpp + c, n) - n/2.0;\n        else if(index < 2.1)\n\t\t\tp = p+to;\n\t\t\n\t\tdpp = dot(p, p);\n        p /= dpp;\n\t\tlp = pow(dpp, 1.5);\n        \n        \n        //if(int(14.0*sin(iTime))+iters < i) break;\n\n\t\t//Shade the lines of symmetry black\n#if 0\n\t\t// Get constant width lines with fwidth()\n\t\tfloat nd = fwidth(dpp);\n\t\tfloat md = fwidth(lp);\n\t\tt *= smoothstep(0.0, 0.5, abs((n/2.0-p.x)/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs((n/2.0-p.y)/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs(p.x/md))\n\t\t   * smoothstep(0.0, 0.5, abs(p.y/md));\n#else\n\t\t// Variable width lines\n\t\tt *= smoothstep(0.0, 0.01, abs(n/2.0-p.x)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(n/2.0-p.y)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(p.x)*2.0) \n\t\t   * smoothstep(0.0, 0.01, abs(p.y)*2.0);\n#endif\n\n\t\t// Fade out the high density areas, they just look like noise\n\t\tr *= smoothstep(0.0, 0.2, lp);\n\t\t\n\t\t// Add to colour using hsv\n\t\tcol += lp+bassBoostHigh;\n\t\t\n\t}\n\t\n    col = vec3(sin(col.x+time*.125),\n               sin(col.y+time*.125+4.0*pi/3.0),\n               sin(col.z+time*.125+2.0*pi/3.0))*.5+.5;\n    \n\treturn col*t;\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 1; i < iters/2; i++)\n    {\n        next = length(texture(iChannel0, vec2(float(i)/float(iters), 0.0)));\n        sum += last;//pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum/float(iters)*2.0;\n}\n\nfloat highAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 17; i < iters; i++)\n    {\n        next = length(texture(iChannel0, vec2(float(i)/float(iters), 0.0)));\n        sum += last;//pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum/float(iters)*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    bassBoostLow += lowAverage()*1.0;\n    bassBoostHigh += highAverage()*1.0;\n    time = iTime+bassBoostLow*8.0*pi;\n    \n    p += .125;\n    \n    p += .5*vec2(cos(time), sin(time));\n    \n\tp.x *= iResolution.x / iResolution.y;\n\tp *= 1.5+1.125*sin(time*.25);\n    \n\tconst vec2 e = vec2(0.06545465634, -0.05346356485);\n\tvec2 c = time*e;\n\t//c = 8.0*iMouse.xy/iResolution.xy;\n\tfloat d = 1.0;\n\tvec3 col = vec3(0.0);\n\tconst float blursamples = 4.0;\n\tfloat sbs = sqrt(blursamples);\n\tfloat mbluramount = 1.0/iResolution.x/length(e)/blursamples*2.0;\n\tfloat aabluramount = 1.0/iResolution.x/sbs*4.0;\n\tfor (float b = 0.0; b < blursamples; b++) {\n\t\tcol += formula(\n\t\t\tp + vec2(mod(b, sbs)*aabluramount, b/sbs*aabluramount), \n\t\t\tc + e*mbluramount*b);\n\t}\n\tcol /= blursamples;\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsc3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 184, 184, 292], [294, 294, 330, 330, 2145], [2147, 2147, 2167, 2167, 2521], [2523, 2523, 2544, 2544, 2897], [2899, 2899, 2956, 2956, 3805]], "test": "error"}
{"id": "lsc3Wn", "name": "Rainbow Reflect Normal Sphere Fi", "author": "cabbibo", "description": "Trying to get to understand structs a bit more... As you can see, I am failing, but as usual, with shaders, even failure is fun.", "tags": ["spheres", "normal", "reflect", "oprep"], "likes": 13, "viewed": 274, "published": "Public", "date": "1448910188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\nstruct Material\n{\n  float reflectivity;\n  float ambient;\n  vec3  color;\n};\n    \n    \nstruct Ray{\n    vec3 color;\n\tvec3 currentPos;\n    vec3 currentDir;\n    vec3 lastPos;\n    vec3 lastDir;\n    float power;\n    float stepsTaken;\n    float timesReflected;  \n    float complete;\n};\n\n\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    pos -= vec3( 0., 0. , iTime * .1 );\n    \n    vec3 modVal =  vec3( .4 , .4 , .4 );\n    vec3 q = mod( pos , modVal ) - modVal / 2.;\n \tvec2 res = vec2( sdSphere( q - vec3( 0. , 0. , 0. ) , .1 ) , 1. ); \n    return res;  \n    \n}\n\n//The inverse model, so that we can properly refract\nvec2 iMap( vec3 pos ){  \n    \n    pos -= vec3( 0., 0. , iTime * .1 );\n    \n    vec3 modVal =  vec3( .4 , .4 , .4 );\n    vec3 q = mod( pos , modVal ) - modVal / 2.;\n \tvec2 res = vec2( sdSphere( q - vec3( 0. , 0. , 0. ) , .1 ) , 1. ); \n    return res;  \n    \n}\n\n\n\nvec3 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n   \tfloat stepsTaken = 0.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        stepsTaken = float( i );\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec3( res , id , stepsTaken );\n    \n}\n\nvec3 calcIIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n   \tfloat stepsTaken = 0.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = iMap( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        stepsTaken = float( i );\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec3( res , id , stepsTaken );\n    \n}\n\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n// Takes in a ray, and \n// gives back a new ray w/ info!\nRay shootRay( Ray ray ){\n    \n    vec3 res = calcIntersection( ray.currentPos , ray.currentDir );\n    \n    if( res.y >= 0. ){\n        \n    \n    \tvec3 pos = ray.currentPos + ray.currentDir * res.x;\n        vec3 nor = calcNormal( pos );\n        //float ao = calcAO( pos , norm );\n        \n        vec3 refl = reflect( ray.currentDir , nor );\n        vec3 refr = refract( ray.currentDir , nor , 1. / 1.2 );\n    \n    \n   \t \tfloat newSteps = ray.stepsTaken + res.z;\n        \n        vec3 color = nor * .5 + .5;\n        return Ray(\n            \t\tcolor,\n                    pos + refl * INTERSECTION_PRECISION * 2.,\n                    refl,\n                    ray.currentPos,\n                    ray.currentDir,\n                    ray.power - .8,\n                    newSteps,\n                    ray.timesReflected + 1.,\n                    0.\n        \t\t);\n        \n        \n        \n        \n    }else{\n        \n        // If it didn't hit anything, lets follow it to the end\n        vec3 pos = ray.currentPos + ray.currentDir * MAX_TRACE_DISTANCE;\n        \n        return Ray( \n            vec3( 1. ),\n            pos, \n            ray.currentDir ,\n            ray.lastPos,\n            ray.lastDir ,\n            ray.power , \n            ray.stepsTaken,\n            ray.timesReflected,\n            1.\n         );\n        \n    }\n    \n    \n    \n    \n}\n\n\nvec3 render( vec3 ro , vec3 rd ){\n \n\n  \n   Ray ray = Ray( vec3( 0. ),  ro , rd , ro , rd , 1. ,0.,0.,0.);\n    \n   vec3 col = vec3( 0. );\n    \n   for( int i = 0; i < 10; i++ ){\n    \n   \tRay newRay = shootRay( ray );\n       \n    if( newRay.power <= 0. || newRay.complete == 1. ){\n        \n      col = newRay.color ;\n      break;\n           \n    }\n       \n    ray = newRay;\n       \n   \n   }\n    \n    \n   return col;\n   \n    \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n  \tvec3 color = render( ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsc3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 575, 639, 639, 817], [819, 913, 942, 942, 985], [987, 987, 1018, 1018, 1114], [1116, 1116, 1151, 1151, 1175], [1178, 1262, 1283, 1283, 1519], [1521, 1574, 1596, 1596, 1832], [1836, 1836, 1884, 1884, 2424], [2426, 2426, 2475, 2475, 3016], [3021, 3134, 3165, 3165, 3391], [3395, 3452, 3476, 3476, 4799], [4802, 4802, 4835, 4835, 5225], [5232, 5232, 5289, 5289, 5721]], "test": "ok"}
{"id": "lsc3z4", "name": "Simple star field", "author": "bjarkeck", "description": "I also wanted to give it a go.\n\nAdvice and imporvements is always welcome :)", "tags": ["stars"], "likes": 21, "viewed": 806, "published": "Public", "date": "1448318369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STARDISTANCE 150.\n#define STARBRIGHTNESS 0.5\n#define STARDENSITY 0.05\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat stars(vec3 ray)\n{\n    vec3 p = ray * STARDISTANCE;\n    float h = hash13(p);\n    float flicker = cos(iTime * 1. + hash13(abs(p) * 0.01) * 13.) * 0.5 + 0.5;\n    float brigtness = smoothstep(1.0 - STARDENSITY, 1.0, hash13(floor(p)));\n    return smoothstep(STARBRIGHTNESS, 0., length(fract(p) - 0.5)) * brigtness * flicker;\n}\n\nvec3 camera(vec2 fragCoord)\n{\n\tvec3 ray = normalize(vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x));\n    vec2 angle = vec2(3. + iTime * -0.01, 10. + iTime * 0.10);\n    vec4 cs = vec4(cos(angle.x), sin(-angle.x), cos(angle.y), sin(angle.y));\n    ray.yz *= mat2(cs.xy,-cs.y,cs.x); \n    ray.xz *= mat2(cs.zw,-cs.w,cs.z); \n    return ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = camera(fragCoord);\n    float s = stars(ray);\n\tfragColor = vec4(s, s ,s ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsc3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 102, 102, 225], [227, 227, 250, 250, 554], [556, 556, 585, 585, 898], [900, 900, 957, 957, 1052]], "test": "ok"}
{"id": "lscGR4", "name": "Phong Illumintaion Demo", "author": "sixstring982", "description": "Demo box thing with Phong illumination", "tags": ["phong", "lighting", "illuminationdemo"], "likes": 0, "viewed": 196, "published": "Public", "date": "1448351474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAY_DIST 100.0\n#define MAX_RAY_ITERS 100\n#define EPSILON 0.001\n\n#define CAM_DIST 3.0\n#define CAM_SPEED 0.01\n\n#define PI 3.1415926535\n\n#define EV vec2(EPSILON, 0.0)\n\n#define GLOBAL_AMBIENT vec3(0.1)\n\nfloat sphere(in vec3 pos, in float r) {\n    return length(pos) - r;\n}\n\nfloat box(in vec3 pos, in vec3 dims) {\n  vec3 d = abs(pos) - dims;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));   \n}\n\nfloat plane(in vec3 pos) {\n    return -pos.y;\n}\n\nfloat opU(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2) {\n    return max(d1, -d2);\n}\n\nfloat bentBox(in vec2 bp, in vec3 pos, in vec3 dims) {\n    float c = cos(bp.x * pos.y);\n    float s = sin(bp.y * pos.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m * pos.xy, pos.z);\n    return box(q, dims);\n}\n\nfloat map(in vec3 pos) {\n    float d = box(pos, vec3(1.0));\n    for (float x = -1.0; x <= 1.0; x += 2.0) {\n    \tfor (float y = -1.0; y <= 1.0; y += 2.0) {\n    \t\tfor (float z = -1.0; z <= 1.0; z += 2.0) {\n        \t\td = opU(d, sphere(pos + vec3(x, y, z), 0.5));\n    \t\t}   \n    \t}\n    }\n    vec2 arms = vec2(2.0, 0.25);\n    d = opS(d, box(pos, arms.xyy));\n    d = opS(d, box(pos, arms.yxy));\n    d = opS(d, box(pos, arms.yyx));\n    \n    return d;\n}\n\nvec3 normalAt(in vec3 ro) {\n    return normalize(vec3(map(ro + EV.xyy) - map(ro - EV.xyy),\n                          map(ro + EV.yxy) - map(ro - EV.yxy),\n                          map(ro + EV.yyx) - map(ro - EV.yyx)));\n}\n\nvec3 colorAt(in vec3 ro) {\n    return vec3(0.0, 1.0, 1.0);\n}\n\nfloat shadow(in vec3 ro, in vec3 lo, in vec3 ld) {\n    float dist = EPSILON;\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (abs(dist) < EPSILON ||\n            totalDist > MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = map(lo);\n        totalDist += dist;\n        lo += dist * ld;\n    }\n    \n    if (abs(length(ro - lo)) < 0.01) {\n        return 1.0;\n    } else {\n        return 0.25;\n    }\n}\n\nvec3 getLightPos(in int idx) {\n    if (idx == 0) {\n        return vec3(3.0);\n    } else {\n        return vec3(CAM_DIST * 2.0 * sin(iTime * PI), \n                    CAM_DIST * 2.0 * sin(iTime),\n                    CAM_DIST * 2.0 * cos(iTime * PI));\n    }\n}\n\nvec3 lighting(in vec3 ro, in vec3 rd, in float dist) {\n    const float SHININESS = 90.0;\n    float diffuse = 0.0;\n    float spec = 0.0;\n    float shade = 0.0;\n    for (int i = 0; i < 2; i++) {\n        vec3 lightPos = getLightPos(i);\n    \tvec3 L = normalize(lightPos - ro);\n    \tvec3 N = normalAt(ro);\n    \tvec3 V = normalize(-dist * rd);\n\t    vec3 R = normalize(reflect(-L, N));\n        \n        \n\t    diffuse += max(0.0, dot(N, L));\n\t\tspec += pow(max(0.0, dot(R, V)), 0.3 * SHININESS);\n        \n        shade = max(shade, shadow(ro, lightPos, -L));\n    }\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    spec = clamp(spec, 0.0, 1.0);\n    shade = clamp(shade, 0.0, 1.0);\n    \n    vec3 light = shade * vec3(diffuse + spec);\n    \n    return GLOBAL_AMBIENT + light * colorAt(ro);\n}\n\nvec3 march(in vec3 ro, in vec3 rd) {\n    float dist = EPSILON;\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (abs(dist) < EPSILON ||\n            totalDist > MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = map(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n    \n    if (abs(dist) < EPSILON) {\n        return lighting(ro, rd, totalDist);\n    } else {\n        return GLOBAL_AMBIENT;\n    }\n}\n\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float camTheta = iMouse.x * CAM_SPEED;\n    float camPhi = (iMouse.y / iResolution.y) * PI;\n    vec3 cop = vec3(CAM_DIST * -sin(camTheta), \n                    CAM_DIST * cos(camPhi), \n                    CAM_DIST * cos(camTheta));\n    \n    vec3 target = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cdir = normalize(target - cop);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cright, cdir);\n    \n    rd = uv.x * cright + uv.y * cup + cdir;\n    ro = cop;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro;\n    vec3 rd;\n    \n    setupCamera(uv, ro, rd);\n    \n\tfragColor = vec4(march(ro, rd), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 250, 250, 280], [282, 282, 320, 320, 424], [426, 426, 452, 452, 473], [475, 475, 512, 512, 538], [540, 540, 577, 577, 604], [606, 606, 660, 660, 822], [824, 824, 848, 848, 1269], [1271, 1271, 1298, 1298, 1491], [1493, 1493, 1519, 1519, 1553], [1555, 1555, 1605, 1605, 2005], [2007, 2007, 2037, 2037, 2263], [2265, 2265, 2319, 2319, 3038], [3040, 3040, 3076, 3076, 3502], [3504, 3504, 3560, 3560, 4057], [4059, 4059, 4116, 4116, 4334]], "test": "ok"}
{"id": "lscGR8", "name": "lots of dots", "author": "ak", "description": "simple", "tags": ["raymarching"], "likes": 4, "viewed": 136, "published": "Public", "date": "1447968137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 128\n\nmat3 my(float beta)\n{\n\treturn mat3(cos(beta), 0, sin(beta),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(beta), 0, cos(beta));\n}\n\nmat3 mx(float beta)\n{\n\treturn mat3(1, 0, 0,\n\t\t\t\t0, cos(beta), sin(beta),\n\t\t\t\t0, -sin(beta), cos(beta));\n}\n\n\nfloat sphere ( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\n\nfloat rep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    return sphere(q, 0.05);\n}\n\nfloat map( vec3 ro, vec3 rd )\n{\n\tfloat res;\n\tfloat val = -1.0;\n\tvec3 ray = ro + rd;\n\tfor (int j = 0; j < STEPS; j++)\n\t{\n\t\tfloat t = float(j)/float(STEPS);\n\t\t\n\t\tfloat res = rep(ray, vec3(0.55));\t\t\n\t\t\n\t\tif (res < .001)\n\t\t{\n\t\t\tval = length(ray);\n            break;\n\t\t}\n\t\t\t\t\n\t\tif (length(ray) > 9.0) return -1.0;\n\t\tray += res * rd;\n\t}\n\treturn val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    float aspect = iResolution.x/iResolution.y;\n\tvec3 ro = vec3(0.0, 0.0, 3.0);\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv) * vec2(aspect, 1.0), -1.0));\n    \n    ro *= my(iTime) * mx(iTime * 0.1);\n    rd *= my(iTime) * mx(iTime * 0.1);\n    \n    float c;\n\tfloat d = map(ro, rd);\n\t\n\tvec3 col;\n\tif (d > 0.0)\n\t{\n        col = vec3(pow(d * 0.3, 0.9));\n\t}\n\telse\n    {\n\t\tcol = vec3(1.0); //background\n    }\n    \n    \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 40, 40, 124], [126, 126, 147, 147, 231], [234, 234, 268, 268, 296], [299, 299, 328, 328, 392], [394, 394, 425, 425, 739], [741, 741, 798, 798, 1287]], "test": "ok"}
{"id": "lsfGDN", "name": "Rectangular Area Light", "author": "tsone", "description": "Approximation for rectangular area light. Uses distance field on a plane. Using this technique, the emitter could probably have any shape, not just rectangle.", "tags": ["light", "rectangular", "area"], "likes": 45, "viewed": 2681, "published": "Public API", "date": "1447082224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nCopyright 2015 Valtteri \"tsone\" Heikkila\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n\n*/\n\n#define PI\t\t\t3.141592653589793\n#define SQRT2\t\t1.414213562373095\n#define INVSQRT2\t0.707106781186548\n\n// Set 1 to treat intensity as power (varies by rectangle area).\n#define VARY_LIGHT_INTENSITY 0\n// Set 1 to detect HDR range overflow.\n#define HDR_DETECTOR 0\n// HDR range maximum. (0 is minimum.)\n#define HDR_MAX 7.0\n\n\nstruct Material\n{\n    float roughness;\n    float tailamount;\n    float tailtheta;\n    float F0;\n    vec3 basecolor;\n  \tvec3 specularcolor;\n};\n\nstruct RectLight\n{\n    vec3 position;\n    mat3 basis;\n    vec2 size;\n    vec3 intensity;\n    float attenuation;\n};\n\nconst vec3 roomsize = vec3(15.0, 6.0, 15.0);\n    \nMaterial mat = Material(\n    0.163, // Roughness.\n    0.577, // Tail amount.\n    PI/2.0/3.0, // Specular cone tail theta angle.\n    0.0205, // Schlick Fresnel coefficient for zero viewing angle.\n    vec3(1.00), // Base color.\n   \tvec3(0.45) // Specular color.\n);\n\nRectLight light = RectLight(\n \tvec3(0.0, 6.0, -15.0), // Light position (center).\n \tmat3( // Light basis.\n    \t1.0, 0.0, 0.0,\n    \t0.0, 1.0, 0.0,\n    \t0.0, 0.0, 1.0\n\t),\n \tvec2(15.0, 0.6), // Light size.\n    vec3(42.0), // Light intensity.\n\t2.13 // Constant attenuation at 0 distance.\n);\n\n\nfloat sqr(float x) { return x*x; }\n\n// Approximate irradiance \"weight\" for a rectangular emitter.\n// Uses distance function to rectangle and a Gaussian standard\n// normal distribution (variance v^2 = 1/2) to approximate the\n// illumination from the \"cone\". Result is weight in (0,1] in\n// units 1/(m^2*sr). Parameter theta is the cone angle.\n// NOTE: Intersection of cone and plane is a conic, but here\n// distance to sphere is used. It's not accurate, particularly on\n// glazing angles.\nfloat RectLight_calcWeight(in vec3 P, in vec3 R, in RectLight light, float theta)\n{\n    // Intersect ray and light plane.\n    float RoPlN = dot(R, light.basis[2]);\n    float d = dot(light.basis[2], light.position - P) / RoPlN;\n    if (d < 0.0 || RoPlN > 0.0) {\n        // Intersection behind ray, or direction is away from plane.\n    \treturn 0.0;\n    }\n    // PlC: Point on plane.\n    vec3 PlC = P + d*R - light.position;\n    // uvPl: UV coordinate on plane.\n    vec2 PlUV = vec2(dot(PlC, light.basis[0]), dot(PlC, light.basis[1]));\n    // r: Radius of cone at distance d.\n    float r = d * tan(theta);\n    // s: Rect size shifted by radius. This for weigth 1 inside the rect.\n    vec2 s = max(light.size - 0.5*r, 0.0);\n    // h: Distance from rect on plane.\n    float h = length(max(abs(PlUV) - s, 0.0));\n    // sr: Steradians from the sphere cap equation: sr = 2pi * (1-cos(a))\n    float sr = 2.0*PI * (1.0 - cos(theta));\n    // This distribution f(x) has variance v^2 = 1/2, hence\n    // v = (1/2)^(1/2) = 2^(-1/2) = INVSQRT2. Using this we can\n    // linearly map h = [0,2r] -> x = [0,3v]. Why 3v is to cover\n    // approximately 100% of the distribution. \n    return exp(-sqr((3.0*INVSQRT2/2.0) * (h/r))) / (light.attenuation + sqr(d)*sr);\n}\n\n// TODO: No need to calculate Fresnel inside the function. Add as function param?\n// TODO: Combine specular and tail calculation into one? Use other distribution?\nvec3 RectLight_shade(in RectLight light, in Material material, in vec3 P, in vec3 N, in vec3 R, float NoR)\n{\n    // Schlick Fresnel.\n    float Fr = material.F0 + (1.0-material.F0) * pow(1.0 - NoR, 5.0);\n    \n    // Approximate specular/glossy.\n    float theta = mix(PI*0.003, PI/2.0/3.0, material.roughness);\n    float Cs = RectLight_calcWeight(P, R, light, theta);\n    // Specular glossy tail. Using other than Gaussian could help. \n    float Cst = RectLight_calcWeight(P, R, light, material.tailtheta);\n    \n    // Crude hack for diffuse.\n    // Average normal and inversed emitter direction to create\n    // a vector W that points towards the light.\n    vec3 W = normalize(N - light.basis[2]);\n    float Cd = RectLight_calcWeight(P, W, light, PI/4.0);\n\t\n    return light.intensity * mix(\n        (Cd * max(dot(N, W), 0.0)) * material.basecolor,\n        (mix(Cs, Cst, material.tailamount) * NoR) * material.specularcolor,\n        Fr);\n}\n\n// Simple tone mapping operation from Brian Karis.\n// Output range hard-coded to 1. Reference:\n// http://graphicrants.blogspot.ca/2013/12/tone-mapping.html\nvec3 ToneMap(in vec3 c, float maxc)\n{\n#if HDR_DETECTOR\n    if (c.r > maxc || c.g > maxc || c.b > maxc) {\n    \treturn vec3(1.0, 0.0, 0.0);\n    } else if (c.r < 0.0 || c.g < 0.0 || c.b < 0.0) {\n    \treturn vec3(0.0, 1.0, 0.0);\n    }\n#endif\n   \tfloat v = max(c.r, max(c.g, c.b));\n    return c / (1.0 + v / maxc);\n}\n\nvec3 Tex3D(in vec3 P, in vec3 N, float s)\n{\n    P *= s;\n    mat3 tc = mat3(\n        texture(iChannel0, P.yz).rgb,\n        texture(iChannel0, P.xz).rgb,\n        texture(iChannel0, P.xy).rgb\n    );\n    N = pow(abs(N), vec3(16.0));\n    N = N / (N.x+N.y+N.z);\n    return pow(tc*N, vec3(2.2)); // Gamma decode.\n}\n\nfloat Map(in vec3 P)\n{\n    // Room walls.\n    vec3 t = roomsize - abs(vec3(P.x, P.y - roomsize.y, P.z));\n    float d = min(t.x, min(t.y, t.z));\n    \n    // Repeated sphere.\n    P.xz = mod(P.xz + vec2(0.0, -0.75), 4.0);\n    d = min(d, length(P - vec3(2.0, 3.25, 2.0)) - 1.2);\n    return d;\n}\n\nvec3 Gradient(in vec3 P)\n{\n    const vec3 d = vec3(0.05, 0.0, 0.0);\n    return vec3(\n        Map(P + d.xyy) - Map(P - d.xyy),\n        Map(P + d.yxy) - Map(P - d.yxy),\n        Map(P + d.yyx) - Map(P - d.yyx)\n    );\n}\n\nfloat March(in vec3 P, in vec3 D)\n{\n    float t = 0.01;\n    float m = 0.0;\n    for (int i = 0; i < 72; ++i) {\n        float d = Map(P + D*t);\n        if (d <= 0.008) {\n            break;\n        }\n        t += d + 0.004;\n    }\n    return t;\n}\n\nmat3 LookAt(in vec3 P, in vec3 focusP)\n{\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = normalize(P - focusP);\n    vec3 left = normalize(cross(up, dir));\n    up = cross(dir, left);\n    return mat3(left, up, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.xx;\n    float t = iTime;\n    \n    // Modify light.\n    light.size.x = 0.1 + 14.6*(0.5+0.5*sin(t));\n    light.size.y = 0.1 + 5.6*(0.5+0.5*cos(t));\n    //light.position.z = -(0.5+0.5*sin(0.5*t))*roomsize.z;\n    \n#if VARY_LIGHT_INTENSITY\n    // A bit hacky. Assume intensity is power, so it's adjust by area.\n    light.intensity *= light.size.x*light.size.y / (13.0*4.0);\n#endif\n\n    // Camera position and basis.\n    vec2 a = vec2(0.25*t, 0.0);\n    if (iMouse.z > 0.0) {\n    \ta = (2.0*iMouse.xy/iResolution.xy - 1.0);\n    \ta.x *= 0.5*PI;\n    }\n    vec3 camP = vec3(14.0*sin(a.x), roomsize.y * (1.0 + 0.8*a.y), 24.0*sqr(cos(a.x)) - 14.0);\n    mat3 camM = LookAt(camP, vec3(0.0, roomsize.y, 1.0-roomsize.z));\n    \n    // Cast ray and vignette.\n    vec3 D = INVSQRT2*(uv.x*camM[0] + uv.y*camM[1]) - camM[2];\n    vec3 P = camP + D;\n    D = normalize(D);\n    float vignette = 0.77 + 0.23*sqr(D.z);\n\n    // March for surface point.\n    float res = March(P, D);\n    P = P + res * D;\n    \n    // Normal and reflection vectors.\n    vec3 N = normalize(Gradient(P));\n    float NoR = -dot(N, D);\n    vec3 R = D + (2.0*NoR)*N;\n    NoR = max(NoR, 0.0);\n    \n    // Modify material.\n    vec3 texColor = Tex3D(P, N, 0.35);\n    float maxv = max(texColor.r, max(texColor.g, texColor.b));\n    mat.basecolor = min(0.33+maxv, 1.0) * vec3(1.0, 0.53, 0.32);\n    //mat.roughness = res.y;\n    \n    vec3 C = vec3(0.0);\n    if (P.z <= -roomsize.z+0.15) {\n        if (abs(P.y-light.position.y) < light.size.y\n            \t&& abs(P.x-light.position.x) < light.size.x) {\n    \t\tC = vec3(HDR_MAX);\n        } else {\n            C = vec3(0.0);\n        }\n    } else {\n    \tC = RectLight_shade(light, mat, P, N, R, NoR);\n    }\n    \n    C = C * vignette;\n    C = ToneMap(C, HDR_MAX);\n    C = pow(C, vec3(1.0/2.2)); // Gamma encode.\n\tfragColor = vec4(C, 1.0);\n}\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfGDN.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[1401, 1401, 1421, 1421, 1435], [1437, 1889, 1972, 2010, 3135], [3137, 3300, 3408, 3432, 4238], [4240, 4396, 4433, 4433, 4707], [4709, 4709, 4752, 4752, 5016], [5018, 5018, 5040, 5059, 5308], [5310, 5310, 5336, 5336, 5525], [5527, 5527, 5562, 5562, 5769], [5771, 5771, 5811, 5811, 5988], [5990, 5990, 6045, 6045, 7928]], "test": "error"}
{"id": "lst3Rn", "name": "goingup", "author": "macbooktall", "description": "A mod of @netgrind's beautiful fractal https://www.shadertoy.com/view/ltjGzd\nBased on iq's raymarch primitives https://www.shadertoy.com/view/Xds3zN", "tags": ["fractal"], "likes": 30, "viewed": 1146, "published": "Public API", "date": "1447884462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//forked By Cale Bradbury, 2015 from https://www.shadertoy.com/view/ltjGzd\n\n//fuck yeah, mirror that shit\n#define MIRROR\n\n// Base ray trace code via https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat qbox( vec3 p, float s )\n{\n  return length(max(abs(p)-vec3(s,s,s),0.0));\n}\n\nfloat box(vec3 p, vec3 b){ \n    p = abs(p) - b;\n    return max(p.x, max(p.y,p.z));\n}\n\nvec2 map( in vec3 pos )\n{\n    float size = .65;\n    //pos.z = mod(pos.z,size*5.)-0.5*size*5.;\n\tpos.y = mod(pos.y,size)-0.5*size;\n    float res = qbox(pos,size);\n\n    pos+=size;\n    \n    float t = iTime;\n    for(float i = 0.0; i<3.;i++){\n        size /= 3.0;\n        \n        float b = box(opRep(pos,vec3(size*5.,size*5.,0)),vec3(size,size,10.));\n        res = opS(res,b);\n        b = box(opRep(pos,vec3(size*5.25,0.,size*5.)),vec3(size,10.,size));\n        res = opS(res,b);\n        b = box(opRep(pos,vec3(0.,size*2.,size*6.)),vec3(10.,size,size));\n        res = opS(res,b);\n    }\n\t\n    return vec2(res,1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.;\n    float tmax = 120.0;\n    \n\tfloat precis = 0.001;\n    float t = tmin;\n    float m = 0.0;\n    for( int i=0; i<120; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<4; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        float occ = calcAO( pos, nor );\n\t\tcol = occ*smoothstep(vec3(0.8, 0.2, 0.2)*(1.0-occ), vec3(0.2, 0.8, .8)*occ, vec3(occ));\n    }\n\nreturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    #ifdef MIRROR\n    p.x = -abs(p.x);\n    #endif\n\t\t \n\tfloat time = 15.0 + iTime*.5;\n\tfloat camDist = 3.;\n\t// camera\t\n\tvec3 ro = vec3(-.02, iTime*.1, 0.);\n    //vec3( -0.5+camDist*cos(0.1*time), 5.0, 0.5 + camDist*sin(0.1*time) );\n\tvec3 ta = ro + vec3(-1., -1., -1. );\n\t\n\t// camera-to-world transformation\n//    mat3 ca = setCamera( ro, ta, 56.54 );\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,5.) );\n\n    // render\t\n    vec3 col = render( ro, rd);\n    col += (vec3(1.)*p.y)*0.35;\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lst3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 335, 335, 361], [363, 363, 393, 393, 422], [424, 424, 455, 455, 503], [505, 505, 531, 531, 589], [591, 591, 616, 616, 1200], [1202, 1202, 1242, 1242, 1561], [1563, 1563, 1637, 1637, 1897], [1899, 1899, 1931, 1931, 2152], [2154, 2154, 2196, 2196, 2495], [2497, 2497, 2536, 2536, 2979], [2981, 2981, 3033, 3033, 3210], [3212, 3212, 3269, 3269, 3939]], "test": "ok"}
{"id": "lst3zH", "name": "Mandelbrot -- iterating", "author": "Cobbleopolis", "description": "A mandelbrot shader that shows it's various iterations", "tags": ["fractal"], "likes": 0, "viewed": 97, "published": "Public", "date": "1448220220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int iter = 100;\nconst float stepTime = 0.5;\nconst float scale = 0.5;\nconst vec2 center = vec2(0.5, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n\tuv /= iResolution.xy;\n\n    vec2 c = vec2(4, 3) * (uv-.5) / (scale * 3.0) - center, z=c;\n\n    int v = 0;\n    for(int i=0; i<iter; i++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (z.y * z.x + z.x * z.y) + c.y;\n\n        if((x * x + y * y) > 4.0) break;\n        z = vec2(x, y);\n        v++;\n    }\n    \n    float val = 1.0 -  float(v) / min((iTime / stepTime), float(iter));\n    fragColor = vec4(val, val, val,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lst3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 162, 162, 602]], "test": "ok"}
{"id": "lt2SDK", "name": "vt220 at night", "author": "sprash3", "description": "A review of https://www.shadertoy.com/view/MljXDG but this time with lights off. At night bloom and reflection effects need to be taken care of. To increase quality, increase blur/bloom iterations. Uncomment MOUSE_MOVE to move terminal around.", "tags": ["2d", "retro", "screen", "crt", "curve", "terminal"], "likes": 46, "viewed": 3124, "published": "Public", "date": "1446747087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOUSE_CURVE\n//#define MOUSE_MOVE\n\n#define MAIN_BLOOM_ITERATIONS 10\n#define MAIN_BLOOM_SIZE 0.01\n\n#define REFLECTION_BLUR_ITERATIONS 10\n#define REFLECTION_BLUR_SIZE 0.05\n\n#define WIDTH 0.48\n#define HEIGHT 0.3\n#define CURVE 3.0\n\n#define BEZEL_COL vec4(0.8, 0.8, 0.6, 0.0)\n#define PHOSPHOR_COL vec4(0.2, 1.0, 0.2, 0.0)\n#define AMBIENT 0.2\n\n#define NO_OF_LINES iResolution.y*HEIGHT\n#define SMOOTH 0.004\n\nprecision highp float;\n\n// using normal vectors of a sphere with radius r\nvec2 crtCurve(vec2 uv, float r) \n{\n        uv = (uv - 0.5) * 2.0;// uv is now -1 to 1\n    \tuv = r*uv/sqrt(r*r -dot(uv, uv));\n        uv = (uv / 2.0) + 0.5;// back to 0-1 coords\n        return uv;\n}\n\nfloat roundSquare(vec2 p, vec2 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Calculate normal to distance function and move along\n// normal with distance to get point of reflection\nvec2 borderReflect(vec2 p, float r)\n{\n    float eps = 0.0001;\n    vec2 epsx = vec2(eps,0.0);\n    vec2 epsy = vec2(0.0,eps);\n    vec2 b = (1.+vec2(r,r))* 0.5;\n    r /= 3.0;\n    \n    p -= 0.5;\n    vec2 normal = vec2(roundSquare(p-epsx,b,r)-roundSquare(p+epsx,b,r),\n                       roundSquare(p-epsy,b,r)-roundSquare(p+epsy,b,r))/eps;\n    float d = roundSquare(p, b, r);\n    p += 0.5;\n    return p + d*normal;\n}\n\n// Some Plasma stolen from dogeshibu for testing\nfloat somePlasma(vec2 uv)\n{\n    if(uv.x < 0.0 || uv.x > 1.0 ||  uv.y < 0.0 || uv.y > 1.0) return 0.0;\n    \n    float scln = 0.5 - 0.5*cos(uv.y*3.14*NO_OF_LINES); // scanlines\n    uv *= vec2(80, 24); // 80 by 24 characters\n    uv = ceil(uv);\n    uv /= vec2(80, 24);\n    \n    float color = 0.0;\n    color += 0.7*sin(0.5*uv.x + iTime/5.0);\n    color += 3.0*sin(1.6*uv.y + iTime/5.0);\n    color += 1.0*sin(10.0*(uv.y * sin(iTime/2.0) + uv.x * cos(iTime/5.0)) + iTime/2.0);\n    float cx = uv.x + 0.5*sin(iTime/2.0);\n    float cy = uv.y + 0.5*cos(iTime/4.0);\n    color += 0.4*sin(sqrt(100.0*cx*cx + 100.0*cy*cy + 1.0) + iTime);\n    color += 0.9*sin(sqrt(75.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += -1.4*sin(sqrt(256.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += 0.3 * sin(0.5*uv.y + uv.x + sin(iTime));\n    return scln*floor(3.0*(0.5+0.499*sin(color)))/3.0; // vt220 has 2 intensitiy levels\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t// aspect-ratio correction\n\tvec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\tuv = 0.5 + (uv -0.5)/ aspect.yx;\n    \n#ifdef MOUSE_CURVE\n    float r = 1.5*exp(1.0-iMouse.y/iResolution.y);\n#else\n    float r = CURVE;\n#endif\n        \n    // Screen Layer\n    vec2 uvS = crtCurve(uv, r);\n#ifdef MOUSE_MOVE\n    uvS.x -= iMouse.x/iResolution.x - 0.5;\n#endif\n\n    // Screen Content\n    vec2 uvC = (uvS - 0.5)* 2.0; // screen content coordinate system\n    uvC *= vec2(0.5/WIDTH, 0.5/HEIGHT);\n    uvC = (uvC / 2.0) + 0.5;\n    \n    c += PHOSPHOR_COL * somePlasma(uvC);\n    \n    // Simple Bloom\n    float B = float(MAIN_BLOOM_ITERATIONS*MAIN_BLOOM_ITERATIONS);\n    for(int i=0; i<MAIN_BLOOM_ITERATIONS; i++)\n    {\n        float dx = float(i-MAIN_BLOOM_ITERATIONS/2)*MAIN_BLOOM_SIZE;\n        for(int j=0; j<MAIN_BLOOM_ITERATIONS; j++)\n        {\n            float dy = float(j-MAIN_BLOOM_ITERATIONS/2)*MAIN_BLOOM_SIZE;\n            c += PHOSPHOR_COL * somePlasma(uvC + vec2(dx, dy))/B;\n        }\n    }           \n    \n    // Ambient\n    c += max(0.0, AMBIENT - 0.3*distance(uvS, vec2(0.5,0.5))) *\n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvS-0.5, vec2(WIDTH, HEIGHT), 0.05));\n  \n\n    // Enclosure Layer\n    vec2 uvE = crtCurve(uv, r+0.25);\n#ifdef MOUSE_MOVE\n    uvE.x -= iMouse.x/iResolution.x - 0.5;\n#endif\n    \n    // Inner Border\n    for( int i=0; i<REFLECTION_BLUR_ITERATIONS; i++)\n    {\n    \tvec2 uvR = borderReflect(uvC + (vec2(rand(uvC+float(i)), rand(uvC+float(i)+0.1))-0.5)*REFLECTION_BLUR_SIZE, 0.05) ;\n    \tc += (PHOSPHOR_COL - BEZEL_COL*AMBIENT) * somePlasma(uvR) / float(REFLECTION_BLUR_ITERATIONS) * \n\t        smoothstep(-SMOOTH, SMOOTH, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT), 0.05)) * \n\t\t\tsmoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n    }\n               \n  \tc += BEZEL_COL * AMBIENT * 0.7 *\n        smoothstep(-SMOOTH, SMOOTH, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT), 0.05)) * \n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n    \n    // Corner\n  \tc -= (BEZEL_COL )* \n        smoothstep(-SMOOTH*2.0, SMOOTH*10.0, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n        smoothstep(SMOOTH*2.0, -SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n\n    // Outer Border\n    c += BEZEL_COL * AMBIENT *\n       \tsmoothstep(-SMOOTH, SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.15, 0.05)); \n\n\n    fragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 482, 516, 516, 679], [681, 681, 725, 725, 767], [769, 769, 789, 789, 861], [863, 970, 1007, 1007, 1386], [1388, 1437, 1464, 1464, 2338], [2340, 2340, 2396, 2396, 5109]], "test": "ok"}
{"id": "lt2XDV", "name": "knup_BasicRaymarchTest", "author": "knup", "description": "raymarching test i.e. how to copy code and change some parameters.", "tags": ["raymarchtest"], "likes": 3, "viewed": 446, "published": "Public", "date": "1446708259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//primitive functions\nfloat sdSphere( vec3 p )\n{\n  return length(p)-0.1;\n}\nfloat sdTorus( vec3 p )\n{\n  vec2 t = vec2 (0.45,0.04);\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//--------------------------------------------------------\nfloat map(vec3 p) \n{\n    //Repetition\n    vec3 c = vec3 (1.0,1.0,1.0);\n    vec3 q = mod(p,c)-0.5*c; \n    return sdTorus (q);   \n}\n\nfloat trace(vec3 o, vec3 r) //raymarching function\n{ \n    float t = 0.0;\n    for (int i=0; i<32;i++)\n    {\n     vec3 p = o + r * t;\n        \n     float d = map(p);\n     \n     t += d*1.0;   \n    }\n    \n   return t;     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //resolution/uv adjustments\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv*2.0 -1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 r = normalize (vec3(uv,1.0));\n    \n    //camera\n    vec3 o = vec3 (0.0, iTime/5.0,+3.0- iMouse.x/50.0);\n    \n    float t = trace(o,r);\n    \n    float fog = 1.0 / (1.0 +t *t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2XDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 48, 48, 74], [75, 75, 100, 100, 194], [195, 254, 274, 291, 383], [385, 385, 437, 437, 605], [607, 607, 664, 696, 1070]], "test": "ok"}
{"id": "ltBSWt", "name": "BinaryTree3dFix", "author": "jt", "description": "Fix-size variant of [url]https://www.shadertoy.com/view/MtjXW3[/url]", "tags": ["raytracing", "implicitsurface", "binarytree"], "likes": 3, "viewed": 162, "published": "Public", "date": "1447279296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Double Binary Tree/Quaternary Tree as Ray-Traced Implicit Surface - written 2015-11-10 by Jakob Thomsen\n// Closed-form expression Implicit Surface Tree - NO recursion/iteration, using only fract,exp2,ceil,log2 for branching.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nvec2 mirror2(vec2 v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nvec3 BinarySubDiv(vec3 v )\n{\n    v = fract(exp2(ceil(-log2(v.z))) * v * vec3(.5, .5, 1.));\n    v.xy = mirror2(2. * v.xy);\n    return v;\n}\n\nfloat fn(vec3 v)\n{\n    v.z *= -1.0;\n    v = 0.5 * v + 0.5;\n    float z = v.z;\n    vec3 p = vec3(0.5, .5, 0.);\n    vec3 n = vec3(1.0, 1.0, 1.) - p;\n    v = BinarySubDiv(v);\n    v.xy = mirror2(v.xy);\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01;\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * ceil(-log2(1.0-v.z));\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * exp2(ceil(-log2(1.0-v.z)));\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * exp2(ceil(-log2(v.z)));\n    return length((v - p) - dot(v - p, n) * n / dot(n, n)) * exp2(ceil(log2(z))) - .01;\n}\n\nvec3 nrm(vec3 v)\n{\n    vec3 n;\n    float d = 0.01;\n    n.x = fn(v + vec3(d, 0.0, 0.0)) - fn(v + vec3(-d, 0.0, 0.0));\n    n.y = fn(v + vec3(0.0, d, 0.0)) - fn(v + vec3(0.0, -d, 0.0));\n    n.z = fn(v + vec3(0.0, 0.0, d)) - fn(v + vec3(0.0, 0.0, -d));\n    return normalize(n);\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec3 tex(vec3 v)\n{\n    float d = abs(v.z * 20. + sfract(-iTime, 4.) * 5.); \n    vec3 c = 0.5 + 0.5 * nrm(v);\n    return exp(-d*d) + c * abs(nrm(v).x);\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float t = iTime * 0.1;\n    vec3 v;\n    //v.x = uv.x * cos(t) + uv.y * sin(t);\n    //v.y = uv.x * -sin(t) + uv.y * cos(t);\n    //v.z = depth;\n    \n    // isometry\n    vec3 iso;\n//    iso.x =  v.x - v.y - v.z;\n//    iso.y = -v.x - v.y - v.z;\n//    iso.z =        v.y - v.z;\n\n//    return iso;\n    iso.x =  uv.x - uv.y - depth;\n    iso.y = -uv.x - uv.y - depth;\n    iso.z =         uv.y - depth;\n\n    v.x = iso.x * cos(t) + iso.y * sin(t);\n    v.y = iso.x * -sin(t) + iso.y * cos(t);\n    v.z = iso.z;\n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 0.1;\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    const int depth = 256;//128;\n    //float m = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for(int layer = 0; layer < depth; layer++) // slow...\n    {\n        vec3 v = camera(uv, 2.0 * float(layer) / float(depth) - 1.0);\n\n        if(abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0)\n            continue;\n\n        if(abs(fn(v)) < 0.01)\n        {\n            //m = 2.0 * float(layer) / float(depth) - 1.0;\n            color = tex(v);\n        }\n    }\n    \n    //fragColor = vec4(color * vec3(m), 1.0);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBSWt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[399, 399, 437, 437, 504], [506, 506, 528, 528, 574], [576, 576, 604, 604, 713], [715, 715, 733, 733, 1351], [1353, 1353, 1371, 1371, 1628], [1630, 1630, 1660, 1660, 1712], [1714, 1714, 1732, 1732, 1866], [1868, 1868, 1903, 1903, 2422], [2424, 2424, 2481, 2481, 3152]], "test": "ok"}
{"id": "ltBXDd", "name": "star field 4 (433 chars)", "author": "FabriceNeyret2", "description": "Test for shorter starfield. This one is based on texture advection + quadtree + procedural stars (indeed, it is an infinite zoom. or perspective, depending on lines #10-11).\nI'm sure it's possible to do nicer + shorter ;-)", "tags": ["texture", "advection", "starfield", "short"], "likes": 31, "viewed": 3443, "published": "Public API", "date": "1447338826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Test for shorter starfield. \n// see also https://www.shadertoy.com/results?query=starfield&sort=newest\n// This one is based on texture advection, quadtree and procedural stars.\n\nfloat D=8., Z=3.;               // D: duration of advection layers, Z: zoom factor\n\n#define R(U,d) fract( 1e4* sin( U*mat2(1234,-53,457,-17)+d ) )\n\nfloat M(vec2 U, float t) {           // --- texture layer\n// vec2 iU = ceil(U/=exp2(t-8.)),              // quadtree cell Id - infinite zoom\n   vec2 iU = ceil(U/=exp2(t-8.)*D/(3.+t)),     // quadtree cell Id - with perspective\n          P = .2+.6*R(iU,0.);                  // 1 star position per cell\n    float r = 9.* R(iU,1.).x;                  // radius + proba of star ( = P(r<1) )\n\treturn r > 1. ? 1. :   length( P - fract(U) ) * 8./(1.+5.*r) ;\n}\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o -= o;\n    U = U / iResolution.y - .5;\n\n    // --- prepare the timings and weightings of the 3  texture layers\n\n    vec3 P = vec3(-1,0,1)/3., T,\n         t = fract( iTime/D + P +.5 )-.5,  // layer time\n         w = .5+.5*cos(6.28*t);                  // layer weight\n    t = t*D+Z;  \n    \n    // --- prepare the 3 texture layers\n\n    T.x = M(U,t.x),  T.y = M(-U,t.y),  T.z = M(U.yx,t.z); // avoid using same U for all layers\n    //T = sin(100.*U.x/exp2(t3))+sin(100.*U.y/exp2(t3));  // try this for obvious pattern\n    T = .03/(T*T);\n\n    // --- texture advection: cyclical weighted  sum\n\n    o += dot(w,T);\n    // o.rgb = w*T;             // try this alternative to see the 3 layers of texture advection\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 329, 355, 469, 782], [784, 784, 823, 823, 1535]], "test": "ok"}
{"id": "ltjGzK", "name": "OSCILOSCOPER0", "author": "Branch", "description": "OSCILOSCOPER0", "tags": ["osciloscoper0"], "likes": 12, "viewed": 197, "published": "Public", "date": "1446757161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return -min(max(100.0*(length( pa - ba*h ) - r),-1.),0.);\n}\n\n\n\nmat2 rotate(float Angle){\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat vasenKulmakarva=floor(mod(iTime*0.8,2.0))*0.1;\n\tfloat oikeaKulmakarva=floor(mod(iTime*0.3,2.0))*0.1;\n\tfloat vasenSilma=min(max(0.24*sin(iTime),0.006),0.06);\n\tfloat oikeaSilma=min(max(0.24*sin(iTime),0.006),0.06);\n\tfloat suu=iTime*10.0;\n\tvec4 tulos;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n    \n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    \n\ttulos=vec4(vec3(0.0/255.0, 23.0/255.0, 12.0/255.0),1.0);\n    coord *= rotate(iTime+length(coord)/2.*sin(iTime));\n    coord *= 1.0 + sin(length(coord)+iTime*3.) * 0.2;\n    coord.y += sin(coord.x*3.+iTime)/32.;\n    coord.x += 0.6*sin(iTime/8.);\n    for(float i=0.0; i<31.0; i++) {\n    \ttulos.rgb+=sdCapsule(coord,vec2( 0.0, 0.0),vec2( cos(i), sin(i))*12.0, 0.02+sin(i*33.-iTime*3.+length(coord)*10.)/11.0);\n    \n    \ttulos.rgb-=sdCapsule(coord,vec2( 0.0, 0.0),vec2( cos(i), sin(i))*12.0, 0.0016+sin(i*33.-iTime*3.+length(coord)*10.)/11.0);\n    }\n    \n    for(float i=0.0; i<16.0; i++) {\n    \tcoord.y += cos(i+iTime)/32. + sin(sin(coord.x+i*sin(iTime)/32.)*3.+coord.x*1.3+iTime+i+sin(i+iTime)/(8.+sin(iTime)*2.))/3.;\n    \ttulos.rgb += sdCapsule(coord,vec2( 888.0, 0.0),vec2(-888.0,0.0),0.005+sin(iTime+i)/666.0);\n    }\n\ttulos.xyz-=floor(mod(fragCoord.y,32.0)/32.0 + 1./32.0) / 12.0;\n\ttulos.xyz-=floor(mod(fragCoord.x,32.0)/32.0 + 1./32.0) / 12.0;\n    tulos.rgb-=rand(coord*iTime)/12.0;\n\ttulos.xyz=tulos.xyz/1.3 * mod(fragCoord.y,2.0);\n    tulos.rgb*=vec3(0.0,1.0,0.4);\n\tfragColor = tulos;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 93], [94, 94, 145, 145, 298], [302, 302, 327, 327, 459], [460, 460, 517, 517, 2081]], "test": "ok"}
{"id": "ltjSDd", "name": "Smooth Lines", "author": "snolot", "description": "Try to get lines with smooth edges", "tags": ["lines", "aa", "smooth"], "likes": 5, "viewed": 402, "published": "Public", "date": "1447497369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(vec2 p, float theta){\n\treturn mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float Frequency = 16.;\n    float V = 3.;\n    \n\tvec2 uv = -1.+ 2. *(fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= rotate(uv, iTime*.1);\n    float sawtooth \t= fract(uv.y * Frequency);\n    float triangle \t= abs(2.0 * sawtooth - 1.0);\n    float dp \t\t= length(vec2(dFdx(uv.x), dFdy(uv.y)));\n    float edge \t\t= dp * Frequency * 2.0;\n    float square \t= smoothstep(0.5 - edge, 0.5 + edge, triangle);\n    \n\tfragColor \t\t= vec4(vec3(square),1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 98], [100, 100, 156, 156, 648]], "test": "ok"}
{"id": "ltjXDt", "name": "Different gradients", "author": "anastadunbar", "description": "Gradients between two points.", "tags": ["2d", "tutorial", "gradient", "distance", "linear", "photoshop", "shade", "tip"], "likes": 12, "viewed": 373, "published": "Public", "date": "1447442047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793238462\nvec2 rotation(float rot,vec2 pos)\n{\n    mat2 rotation = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    return vec2(pos*rotation);\n}\nfloat linearstep(float a, float b, float x) //Thank you Dave_Hoskins\n{\n    return clamp((x-a)/(b-a),0.0,1.0);\n}\n//Gradients\nfloat gradient_linedist(vec2 uv, vec2 p1, vec2 p2) {\n    return abs(((p2.x-p1.x)*(p1.y-uv.y))-((p1.x-uv.x)*(p2.y-p1.y)))/length(p1-p2);\n}\nfloat gradient_radial(vec2 uv, vec2 p1, vec2 p2) {\n    return length(uv-p1)/length(p1-p2);\n}\nfloat gradient_diamond(vec2 uv, vec2 p1, vec2 p2) {\n    float a = (atan(p1.x-p2.x,p1.y-p2.y)+PI)/(PI*2.);\n    vec2 d = rotation((a*PI*2.)+(PI/4.),uv-p1);\n    vec2 d2 = rotation((a*PI*2.)+(PI/4.),p1-p2);\n    return max(abs(d.x),abs(d.y))/max(abs(d2.x),abs(d2.y));\n}\nfloat gradient_angle(vec2 uv, vec2 p1, vec2 p2) {\n    //Non-smooth version:\n    /*float a = (atan(p1.x-p2.x,p1.y-p2.y)+PI)/(PI*2.);\n    return fract((atan(p1.x-uv.x,p1.y-uv.y)+PI)/(PI*2.)-a);*/\n    //Smooth version (For those who hate pixels, includes linearstep function):\n    float a = (atan(p1.x-p2.x,p1.y-p2.y)+PI)/(PI*2.);\n    float a2 = fract((atan(p1.x-uv.x,p1.y-uv.y)+PI)/(PI*2.)-a);\n    return a2+linearstep(0.0005/length(uv-p1),0.,a2);\n}\nfloat gradient_linear(vec2 uv, vec2 p1, vec2 p2) {\n    /* TOO LONG.\n\tfloat a = (atan(p1.x-p2.x,p1.y-p2.y)+PI)/(PI*2.);\n    uv -= p1;\n    uv = uv/length(p1-p2);\n    uv = rotation((a*PI*2.)-(PI/2.),uv);\n    return uv.x;\n\t*/\n\t//dot = (x1*y1)+(x2*y2)+...\n    //Found out when seeing this: https://www.shadertoy.com/view/lscGDr\n    return clamp(dot(uv-p1,p2-p1)/dot(p2-p1,p2-p1),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = vec2(((uv.x-0.5)*(iResolution.x / iResolution.y))+0.5,uv.y);\n    float time = iTime;\n    \n    vec2 point1 = vec2(sin(time*0.96),cos(time*2.12));\n    point1 = (point1+1.)/2.;\n    /*\n    if (iMouse.z >= 1.) {\n        point1 = vec2((((((iMouse.x*(iResolution.x/iResolution.y))*2.)/iResolution.x)-(iResolution.x/iResolution.y))+1.)/2.,iMouse.y/iResolution.y);\n    }*/\n    vec2 point2 = vec2(sin(time*3.11),cos(time*1.05));\n    point2 = (point2+1.)/2.;\n    \n    float drawing = 0.;\n    float time2 = floor(mod(time/2.,5.));\n    \n    if (time2 == 0.) {\n    drawing = gradient_linear(suv,point1,point2);\n    }\n    if (time2 == 1.) {\n    drawing = gradient_radial(suv,point1,point2);\n    }\n    if (time2 == 2.) {\n    drawing = gradient_angle(suv,point1,point2);\n    }\n    if (time2 == 3.) {\n    drawing = gradient_diamond(suv,point1,point2);\n    }\n    if (time2 == 4.) {\n    drawing = gradient_linedist(suv,point1,point2);\n    }\n    \n    fragColor = vec4(drawing,1.-((length(suv-point1)-0.01)*400.),1.-((length(suv-point2)-0.01)*400.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 70, 70, 170], [171, 171, 241, 241, 282], [283, 295, 347, 347, 432], [433, 433, 483, 483, 525], [526, 526, 577, 577, 790], [791, 791, 840, 1064, 1238], [1239, 1239, 1289, 1561, 1622], [1624, 1624, 1681, 1681, 2776]], "test": "ok"}
{"id": "ltjXWd", "name": "simple hexagon raymarch", "author": "macbooktall", "description": "just a simple raymarch.\nforked from cail's https://www.shadertoy.com/view/lt2SRt", "tags": ["hexagons"], "likes": 64, "viewed": 13355, "published": "Public API", "date": "1447460535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tweaked copy of https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    //pos.x += sin(pos.z+iTime)*0.2;\n    //pos.y += cos(pos.z+iTime)*0.2;\n    \n    float height = .42;\n    float depth = .75;\n    float t = 0.02 + sin(iTime)*0.01;\n    pos.z = mod(pos.z,depth*2.)-0.5*depth*2.;\n\n   \tfloat cyl = sdHexPrism( pos, vec2(height-t, depth+t));\n   \tfloat scyl = sdHexPrism( pos, vec2(height-t*2.0, depth+t+.001));\n    \n    vec2 res = vec2(opS(scyl,cyl),1.5); \n    vec2 final = res;\n    \n    for (int i = 1; i < 3; i++) {\n\n//        float c = cos(pos.z+iTime*0.5);\n//    float s = sin(pos.z+iTime*0.5);\n//    mat2  m = mat2(c,-s,s,c);\n//    pos = vec3(m*pos.xy,pos.z);\n        \n        height -= 0.1;\n        depth -= 0.19;\n    \tcyl = sdHexPrism( pos, vec2(height-t, depth+t));\n    \tscyl = sdHexPrism( pos, vec2(height-t*2.0, depth+t+.001));\n\t\n       final = opU(final, vec2(opS(scyl,cyl),2.5)); \n    \n    }\n     \n   return final;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 100.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n   vec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n   m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\nvec3 eps = vec3( 0.01, 0.0, 0.0 );\nvec3 nor = vec3(\n   map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n   map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n   map(pos+eps.yyx).x - map(pos-eps.yyx).x );\nreturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        float occ = calcAO( pos, nor );\n\t\tcol = 1.0 - hue(vec3(0.0,1.0,1.0),iTime*0.02+pos.z)*occ;\n    }\n\nreturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n \n\t// camera\n\tvec3 ro = vec3(0., 0.,iTime );\n\t\n    vec3 ta = ro+vec3( 0., 0.,1. );\n\t\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 3.14159/2.0 );\n\n    // ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy,4.5));\n\n    // render\n    vec3 col = render( ro, rd );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjXWd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[171, 171, 206, 206, 1155], [1157, 1157, 1193, 1193, 1277], [1279, 1279, 1310, 1310, 1406], [1408, 1408, 1441, 1441, 1467], [1469, 1469, 1499, 1499, 1532], [1534, 1534, 1559, 1633, 2416], [2418, 2418, 2458, 2458, 2738], [2740, 2740, 2772, 2772, 2983], [2985, 2985, 3027, 3027, 3324], [3329, 3329, 3368, 3368, 3780], [3782, 3782, 3834, 3834, 4007], [4009, 4009, 4066, 4066, 4526]], "test": "ok"}
{"id": "ltSSDd", "name": "Cylindrical objects", "author": "TomF", "description": "Let's not render these things with polygonal objects - it looks terrible! They're easy to raytrace, so just render a bounding box and do it right.", "tags": ["raytrace", "cylinder", "bullet"], "likes": 7, "viewed": 723, "published": "Public", "date": "1447356453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Equation of a general cone.\n// Radius at z=Z0 is R0\n// Radius at z=Z1 is R1\n// Therefore r = R0 + ((z-Z0)/(Z1-Z0))*(R1-R0)\n//             = sqrt(x^2+y^2)\n//\n// Simplify the first line a bit:\n// Zo = R0 - ((Z0)/(Z1-Z0))*(R1-R0)\n// Zs =          1/(Z1-Z0))*(R1-R0)\n// Therefore:\n//   r = Zo + z*Zs = sqrt(x^2+y^2)\n//\n// Line equation for the ray we're casting is (xyz) = p + d*v\n//\n// Substitute one in the other, solve for d:\n//\n// (p.x + d*v.x)^2+(p.y + d*v.y)^2\n//     = (Zo + (p.z+d*v.z)*Zs)^2\n//     = (Zo + p.z*Zs + d*v.z*Zs)^2\n//\n// Gather by powers of d:\n//\n// 0 =\n//     d^2 * (v.x^2+v.y^2 - (v.z*Zs)^2)\n//   + d   * 2*(p.x*v.x + p.y*v.y - v.z*Zs*(Zo + p.z*Zs))\n//   +       (p.x^2 + p.y^2 - (Zo + p.z*Zs)^2\n\nstruct Cone\n{\n    float Z0, Z1;\n    float R0, R1;\n    int Material;\n    float Zo, Zs;\n};\n\nvoid PrecomputeCone ( inout Cone cn )\n{\n    cn.Zs = (cn.R1-cn.R0)/(cn.Z1-cn.Z0);\n    cn.Zo = cn.R0 - (cn.Z0*cn.Zs);\n}\n\n// Returns both distances to cone given a ray origin p, direction v\nvec2 ConeDistances ( in Cone cone, in vec3 p, in vec3 v )\n{\n    // Convert to standard form A(d^2) + Bd + C = 0\n    float t0 = v.z * cone.Zs;\n    float t1 = cone.Zo + p.z*cone.Zs;\n    float A = (v.x*v.x + v.y*v.y - t0*t0);\n    float B = 2.0*(p.x*v.x + p.y*v.y - v.z*cone.Zs*t1);\n    float C = (p.x*p.x + p.y*p.y - t1*t1);\n\n\t// Then solve, paying attention to numerical stability as shown in\n\t// https://en.wikipedia.org/wiki/Loss_of_significance#A_better_algorithm\n\t// x1 = (-B-sgn(B)*sqrt(B^2-4AC))/2A\n    // x2 = C/(Ax1)\n    float discriminant = B*B-4.0*A*C;\n\tif ( discriminant < 0.0 )\n    {\n        return vec2(-1.0,-1.0);\n    }\n\tfloat d1 = (-B-sign(B)*sqrt(discriminant))/(2.0*A);\n    float d2 = C/(A*d1);\n    vec2 res = vec2(d1, d2);\n\treturn res;\n}\n\nconst int NumCones = 13;\n\nCone cones[NumCones];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Yes, I am nerdy enough to have made sure these dimensions are correct!\n    // Thanks Wikipedia! https://upload.wikimedia.org/wikipedia/commons/4/41/9x19mm_Parabellum.svg\n    float q = -12.0;\n    cones[ 0] = Cone(q+ 0.00,0.0, 0.00*0.5,0.0, 0, 0.0,0.0);\n    cones[ 1] = Cone(q+ 0.00,0.0, 9.36*0.5,0.0, 0, 0.0,0.0);\n    cones[ 2] = Cone(q+ 0.30,0.0, 9.96*0.5,0.0, 0, 0.0,0.0);\n    cones[ 3] = Cone(q+ 1.27,0.0, 9.96*0.5,0.0, 0, 0.0,0.0);\n    cones[ 4] = Cone(q+ 1.27,0.0, 8.79*0.5,0.0, 0, 0.0,0.0);\n    cones[ 5] = Cone(q+ 2.17,0.0, 8.79*0.5,0.0, 0, 0.0,0.0);\n    cones[ 6] = Cone(q+ 2.98,0.0, 9.93*0.5,0.0, 0, 0.0,0.0);\n    cones[ 7] = Cone(q+19.15,0.0, 9.65*0.5,0.0, 0, 0.0,0.0);\n    cones[ 8] = Cone(q+19.15,0.0, 9.03*0.5,0.0, 1, 0.0,0.0);\n    cones[ 9] = Cone(q+21.50,0.0, 8.80*0.5,0.0, 1, 0.0,0.0);\n    cones[10] = Cone(q+25.00,0.0, 7.40*0.5,0.0, 1, 0.0,0.0);\n    cones[11] = Cone(q+28.00,0.0, 4.50*0.5,0.0, 1, 0.0,0.0);\n    cones[12] = Cone(q+29.40,q+29.69, 2.00*0.5,0.0, 1, 0.0,0.0);\n\t\n\tfor ( int cn = 0; cn < NumCones; cn++ )\n\t{\n        if ( cn < NumCones-1 )\n        {\n        \tcones[cn].Z1 = cones[cn+1].Z0;\n            cones[cn].R1 = cones[cn+1].R0;\n        }\n\t\tPrecomputeCone ( cones[cn] );\n\t}\n\t\n\tvec3 pos;\n\tvec3 vec;\n    \n    \n    vec2 angles;\n    angles.x = 0.02 * iMouse.x + 0.5*iTime;\n    angles.y = 0.02 * iMouse.y;\n    \n    float viewdist = 40.0;\n    \n\tpos.x = viewdist*sin(angles.x) * cos(angles.y);\n\tpos.z = viewdist*cos(angles.x) * cos(angles.y);\n    pos.y = viewdist*                sin(angles.y);\n    \n\tvec3 lookat = vec3(0.0,0.0,0.0);\n\tvec3 viewz = normalize(lookat-pos);\n\tvec3 viewx = normalize(cross(vec3(0.0,1.0,0.0),viewz));\n\tvec3 viewy = normalize(cross(viewz,viewx));\n    \n    vec3 lightpos;\n\tlightpos.x = viewdist*sin(0.5*iTime);\n\tlightpos.z = viewdist*cos(0.5*iTime);\n\tlightpos.y = viewdist*2.0;\n    vec3 lightvec = normalize(lightpos);\n    \n\tfloat tanfov = 0.6;\n    \n    vec2 ndc = fragCoord.xy - 0.5*iResolution.xy;\n    ndc *= 2.0/iResolution.x;\n\tndc *= tanfov;\n\tvec3 dirn = normalize(viewz + viewx*ndc.x + viewy*ndc.y);\n    \n\tint closestCn = -1;\n    Cone closestCone;\n\tfloat closestDist = 1000000000.0;\n\tvec3 hitpos = vec3(0.0,0.0,10000000.0);\n    vec3 normal;\n\tfor ( int cn = 0; cn < NumCones; cn++ )\n\t{\n        if ( cones[cn].Z0 == cones[cn].Z1 )\n        {\n            // Flat disc section.\n            // Intersect view vector with plane at Z0\n            // Z0 = pos.z + dirn.z * dist;\n            // dist = (Z0-pos.z)/dirn.z;\n            float Z0 = cones[cn].Z0;\n            float dist = ( Z0 - pos.z ) / dirn.z;\n            if ( dist > 0.0 )\n            {\n                float R0 = cones[cn].R0;\n                float R1 = cones[cn].R1;\n                vec2 hit = pos.xy + dirn.xy * dist;\n                float radius2 = hit.x*hit.x + hit.y*hit.y;\n                if ( R0 > R1 )\n                {\n                    if ( ( radius2 < (R0*R0) ) && ( radius2 > (R1*R1) ) )\n                    {\n\t                    if ( closestDist > dist )\n    \t                {\n        \t                closestDist = dist;\n            \t            closestCn = cn;\n                \t        closestCone = cones[cn];\n                    \t    hitpos = vec3 ( hit, Z0 );\n                        \tnormal = vec3 ( 0.0, 0.0, 1.0 );\n                    \t}\n                    }\n                }\n                else\n                {\n                    if ( ( radius2 < (R1*R1) ) && ( radius2 > (R0*R0) ) )\n                    {\n\t                    if ( closestDist > dist )\n    \t                {\n        \t                closestDist = dist;\n            \t            closestCn = cn;\n                \t        closestCone = cones[cn];\n                    \t    hitpos = vec3 ( hit, Z0 );\n                        \tnormal = vec3 ( 0.0, 0.0, 1.0 );\n                    \t}\n                    }\n                }\n            }\n        }\n        else\n        {\n            vec2 dist = ConeDistances ( cones[cn], pos, dirn );\n            float dists[2];\n            dists[0] = dist.x;\n            dists[1] = dist.y;\n            for ( int i = 0; i < 2; i++ )\n            {\n                vec3 hit = pos + dirn * dists[i];\n                if ( ( dists[i] > 0.0 ) && ( hit.z < cones[cn].Z1 ) && ( hit.z > cones[cn].Z0 ) )\n                {\n                    if ( closestDist > dists[i] )\n                    {\n                        closestDist = dists[i];\n                        closestCn = cn;\n                        closestCone = cones[cn];\n                        hitpos = hit;\n                        normal.xy = normalize(hitpos.xy);\n                        normal.z = -closestCone.Zs;\n                    }\n                }\n            }\n        }\n\t}\n\t\n\tif ( closestCn < 0 )\n\t{\n        vec2 uv = fragCoord.xy / iResolution.xx;\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t}\n\telse\n\t{\n\t\tnormal = normalize(normal);\n\t\t\n        // wraparound diffuse\n\t\tfloat shade = dot(lightvec,normal);\n\t\tshade = shade * 0.5 + 0.5;\n        \n        vec3 col = vec3(1.0,1.0,1.0);\n        float specshade = 1.0;\n        if      ( closestCone.Material == 0 ) { col = vec3(1.0,1.0,0.5); specshade = 0.3; }\n        else if ( closestCone.Material == 1 ) { col = vec3(0.3,0.3,0.3); specshade = 0.4; }\n            \n        col *= shade;\n        //vec4 tex = texture ( iChannel0, vec2(hitpos.x, hitpos.z));\n        //col *= tex.xyz;\n\n        // Blinn-Phong specular\n        vec3 lightvec = normalize(lightpos-hitpos);\n        vec3 halfvec = normalize(lightvec-viewz);\n        float spec = dot(halfvec,normal);\n        if ( spec > 0.0 )\n        {\n\t        col += pow(spec,10.0) * specshade;\n        }\n\n\t\tfragColor = vec4(col, 1.0);\n\t}\n}\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[811, 811, 850, 850, 928], [930, 998, 1057, 1109, 1751], [1802, 1802, 1859, 2036, 7498]], "test": "ok"}
{"id": "ltSSDV", "name": "plop", "author": "fantomas", "description": "i wana be a chicken", "tags": ["2d"], "likes": 1, "viewed": 1005, "published": "Public API", "date": "1446490667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _t iTime/10.\n\nvec2 itere (vec2 uv)\n{\n    for (int i=0; i<8; i++)\n    {\n    \tuv+=vec2(cos(uv.y*3.+_t),-sin(uv.x*3.))/3.;\n        uv+=vec2(cos(_t+uv.y),sin(_t+uv.x))*0.5;\n        uv*=1.3;\n    }\n    \n    return uv;\n}\nfloat color (vec2 uv)\n{\n     uv = itere (uv);\n     float sc = 2.;\n     uv = mod(uv,sc)-sc/2.;\n     return length(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5)*8.;\n    float c = color(uv);\n    float cx = color (uv+vec2(0.01,0.))-c;\n    float cy = color (uv+vec2(0.,0.01))-c;\n\tfragColor = normalize((vec4(cx,sqrt(abs(cx*cy)),cy,c/2.)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 44, 44, 221], [222, 222, 245, 245, 341], [343, 343, 400, 400, 627]], "test": "ok"}
{"id": "Md33Rn", "name": "SpotlightTest", "author": "NylonGamer_", "description": "first shader ever, did i do something terribly wrong?", "tags": ["testing"], "likes": 0, "viewed": 186, "published": "Public", "date": "1447637693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 light;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    light = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n    vec2 pos = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n    float dist = sqrt((pos.x-light.x)*(pos.x-light.x) + (pos.y-light.y)*(pos.y-light.y));\n\tfloat col = 0.5 - sqrt(dist) + 0.075 * rand(pos) * rand(pos * vec2(iTime, iTime));\n    if (col < 0.01)\n        col = 0.;\n\tfragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md33Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [107, 107, 164, 164, 559]], "test": "ok"}
{"id": "Md3GR4", "name": "Meditation for dummies", "author": "iapafoto", "description": "Modeling human head and play with animations.\nTry to have a picture without artfact.", "tags": ["sss", "antialiasing", "animation", "man"], "likes": 129, "viewed": 6302, "published": "Public API", "date": "1448915868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by sebastien durand - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n// Shading, essentially based on one of incredible TekF shaders:\n// https://www.shadertoy.com/view/lslXRj\n\n// Pupils effect came from lexicobol shader: [famous iq tutorial]\n// https://www.shadertoy.com/view/XsjXz1\n\n// Smooth max from cabbibo shader:\n// https://www.shadertoy.com/view/Ml2XDw\n\n//-----------------------------------------------------\n\n// Display distance field in a plane perpendicular to camera crossing pt(0,0,0)\n//#define DRAW_DISTANCE\n\n\n#ifndef DRAW_DISTANCE\n// To enable mouse rotation (enable to explore modeling)\n//\t#define MOUSE\n\n// Change this to improve quality (3 is good)\n\t#define ANTIALIASING 3\n\n#else\n\n// To enable mouse rotation (enable to explore modeling)\n   #define MOUSE\n\n// Change this to improve quality (3 is good)\n  #define ANTIALIASING 1\n\n#endif\n\n// consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n// Isosurface Renderer\nconst int g_traceLimit=48;\nconst float g_traceSize=.005;\n\n// globals\nconst vec3 g_nozePos = vec3(0,-.28+.04,.47+.08);\nconst vec3 g_eyePos = vec3(.14,-.14,.29);\nconst float g_eyeSize = .09;\n\nvec3 g_envBrightness = vec3(.5,.6,.9); // Global ambiant color\nvec3 g_lightPos;\nmat2 ma, mb, mc, g_eyeRot, g_headRotH, g_headRot;\nfloat animNoze;\n    \nbool g_bHead = true, g_bBody = true;\n\n// -----------------------------------------------------------------\n\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// Smooth HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\n// Distance from ray to point\nfloat dist(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\n// Intersection ray / sphere\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, out float t0, out float t1) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n    if (d<0.) return false;\n\tfloat sd = sqrt(d);\n\tt0 = max(0., -b - sd);\n\tt1 = -b + sd;\n\treturn (t1 > 0.);\n}\n\n// -- Modeling Primitives ---------------------------------------------------\n\nfloat udRoundBox(in vec3 p,in vec3 b, in float r) {\n  return length(max(abs(p)-b,0.0))-r ;\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\n// capsule with bump in the middle -> use for neck\nvec2 sdCapsule2(in vec3 p,in vec3 a,in vec3 b, in float r0,in float r1,in float bump) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    float dd = bump*sin(3.14*h);  // Little adaptation\n    return vec2(length(pa - ba*h) - mix(r0,r1,h)*(1.+dd), 1.); \n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n// Smooth max from cabbibo shader:\n// https://www.shadertoy.com/view/Ml2XDw\nfloat smax(in float a, in float b, in float k) {\n    return log(exp(a/k)+exp(b/k))*k;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p/r ) - 1.) * min(min(r.x,r.y),r.z);\n}\n\n\n\n// -- Modeling Head ---------------------------------------------------------\n\nfloat dEar(in vec3 p, in float scale_ear) {\n    vec3 p_ear = scale_ear*p;\n    p_ear.xy *= ma;\n    p_ear.xz *= ma; \n    float d = max(-sdEllipsoid(p_ear-vec3(.005,.025,.02), vec3(.07,.11,.07)), \n                       sdEllipsoid(p_ear, vec3(.08,.12,.09)));\n    p_ear.yz *= mb; \n    d = max(p_ear.z, d); \n    d = smin(d, sdEllipsoid(p_ear+vec3(.035,.045,.01), vec3(.04,.04,.018)), .01);\n    return d/scale_ear;\n}\n\nfloat dSkinPart(in vec3 pgeneral, in vec3 p) {\n#ifndef DRAW_DISTANCE    \n    if (!g_bHead) return 100.;\n#endif\n    \n// Neck    \n    float dNeck = sdCapsule2(pgeneral, vec3(0,-.24,-.11), vec3(0,-.7,-.12), .22, .12, -.45).x;\n    \n    float d = 1000.;\n   \n// Skull modeling -------------------------\n    d = sdEllipsoid(p-vec3(0,.05,.0), vec3(.39,.48,.46));\t\t\t\t  \n    d = smin(d, sdEllipsoid(p-vec3(0.,.1,-.15), vec3(.42,.4,.4)),.1);     \n    d = smin(d, udRoundBox(p-vec3(0,-.28,.2), vec3(.07,.05,.05),.05),.4); // Basic jaw \n\t// small forehead correction with a rotated plane\n    vec3 p_plane = p; \n    p_plane.yz *= ma;\n    d = smax(d, p_plane.z-.68, .11);  \n\n// Neck -----------------------------------\n    d = smin(d, dNeck, .05);\n\n// Symetrie -------------------------------\n    p.x = abs(p.x);\n\n// Eye hole \n    d = smax(d, -sdEllipsoid(p-vec3(.12,-.16,.48), vec3(.09,.06,.09)), .07);\n\n// Noze ------------------------------------\n    d = smin(d, max(-(length(p-vec3(.032,-.325,.45))-.028),   // Noze hole\n                    smin(length(p-vec3(.043,-.29+.015*animNoze,.434))-.01,  // Nostrils\n                    sdCapsule(p, vec3(0,-.13,.39), vec3(0,-.28+.004*animNoze,.47), .01,.04), .05)) // Bridge of the nose\n            ,.065); \n   \n// Mouth -----------------------------------    \n    d = smin(d, length(p- vec3(.22,-.34,.08)), .17); // Jaw\n    d = smin(d, sdCapsule(p, vec3(.16,-.35,.2), vec3(-.16,-.35,.2), .06,.06), .15); // Cheeks\n   \n    d = smin(d, max(-length(p.xz-vec2(0,.427))+.015,  \t// Line under the noze\n        \t\tmax(-p.y-.41+.008*animNoze,   \t\t\t\t\t\t// Upper lip\n                    sdEllipsoid(p- vec3(0,-.34,.37), vec3(.08,.15,.05)))), // Mouth bump\n             .032);\n\n// Chin -----------------------------------  \n    d = smin(d, length(p- vec3(0,-.5,.26)), .2);   // Chin\n    d = smin(d, length(p- vec3(0,-.44,.15)), .25); // Under chin \n  \n    //d = smin(d, sdCapsule(p, vec3(.24,-.1,.33), vec3(.08,-.05,.46), .0,.01), .11); // Eyebrow \n    \n// Eyelid ---------------------------------\n\tvec3 p_eye1 = p - g_eyePos;\n    p_eye1.xz *= mb;\n    \n    vec3 p_eye2 = p_eye1;\n    float d_eye = length(p_eye1) - g_eyeSize;\n          \n\tp_eye1.yz *= g_eyeRot;\n\tp_eye2.zy *= mc;\n    \n    float d1 = min(max(-p_eye1.y,d_eye - .01),\n                   max(p_eye2.y,d_eye - .005));\n    d = smin(d,d1,.01);\n\n// Ear ------------------------------------\n    d = smin(d, dEar(vec3(p.x-.4,p.y+.22,p.z), .9), .01);    \n\n//\td = max(p.y+cos(iTime),d); // Cut head  :)\n\treturn d; \n}\n\nfloat dEye(vec3 p_eye) {\n    p_eye.xz *= ma;     \n    return length(p_eye) - g_eyeSize;\n}\n\nvec2 min2(in vec2 dc1, in vec2 dc2) {\n\treturn dc1.x < dc2.x ? dc1 : dc2; \n}\n\nvec2 dToga(vec3 p) {\n#ifndef DRAW_DISTANCE        \n    if (!g_bBody) return vec2(100.,-1.);\n#endif\n    \n    p -= vec3(0.,0.,-.02);\n    \n    float d_skin = udRoundBox(p- vec3(0,-1.22,-.12), vec3(.25,.5,.0), .13); // Shoulder\n\n    // Scarf\n    float d1 = udRoundBox(p - vec3(-.05, -1.02,-.1), vec3(.15, .25, .0), .22);\n    float r = length(p-vec3(1.,0,-.1))-1.25;\n    d1 = max(d1, -r);\n    d1 = max(d1+.007*sin(r*42.+.6), (length(p-vec3(1.,.1,-.1))-1.62)); \n    \n    // Toga\n    float d = .004*smoothstep(.0,.45, -p.x)*cos(r*150.)+udRoundBox(p - vec3(-.05, -1.,-.1), vec3(.15, .23, .0), .2);\n    \n //   d = min(d , length(p- vec3(0,-.018,.02))-.65);\n //   d = min(d , length(p- vec3(0,-.7,.02))-.5);\n        \n    return min2(vec2(d_skin,2.), min2(vec2(d,0.), vec2(d1, 1.)));\n}\n\n\nvec3 headRotCenter = vec3(0,-.2,-.07);\nfloat map( vec3 p) {\n    float d = dToga(p).x;\n    \n    vec3 p0 = p;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p.xz *= g_headRot;\n    p += headRotCenter;\n    \n\td = min(d, dSkinPart(p0,p));\n    p.x = abs(p.x);\n    d = min(d, dEye(p- g_eyePos));\n    return d;\n}\n\n\n// render for color extraction\nfloat colorField(vec3 p) {\n    vec2 dc = dToga(p);\n    vec3 p0 = p;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p.xz *= g_headRot;\n    p += headRotCenter;\n\n    dc = min2(dc, vec2(dSkinPart(p0,p), 2.));\n         \n    p.x = abs(p.x);\n\treturn min2(dc, vec2(dEye(p - g_eyePos), 3.)).y;\n}\n\n\n// ---------------------------------------------------------------------------\n\nfloat SmoothMax( float a, float b, float smoothing ) {\n\treturn a-sqrt(smoothing*smoothing + pow(max(.0,a-b),2.0));\n}\n\nvec3 Sky( vec3 ray) {\n\treturn g_envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\n// -------------------------------------------------------------------\n// pupils effect came from lexicobol shader:\n// https://www.shadertoy.com/view/XsjXz1\n// -------------------------------------------------------------------\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x), f = fract(x);\n    float va = 0., wt = 0.;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ ) {\n        vec2 g = vec2(i,j);\n\t\tvec3 o = hash3( p + g )*vec3(0,0,1);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r),\n\t\tww = 1.-smoothstep(0.,1.414,sqrt(d));\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\n\n\nmat2 m = mat2(.8,.6,-.6,.8);\n\nfloat fbm( vec2 p)\n{\n\tfloat f;\n    f  = .5    * noise(p); p *= m* 2.02;\n    f += .25   * noise(p); p *= m* 2.03;\n    f += .125  * noise(p); p *= m* 2.01;\n    f += .0625 * noise(p); p *= m* 2.04;\n    f /= .9375;\n    return f;\n}\n\n\nvec3 iris(vec2 p, float open)\n{\n    float\n    \n     r = sqrt( dot (p,p)),\n     r_pupil = .15 + .15*smoothstep(.5,2.,open),\n     a = atan(p.y, p.x),\n     ss = .5,\n     anim = 1. + .05*ss* clamp(1.-r, 0., 1.);\n    \n  \n     r *= anim;\n     vec3 col = vec3(1);\n        \n     if (r< .8) {\n        col = mix(vec3(.12, .6, .57), vec3(.12,.52, .60), fbm(5. * p)); // iris bluish green mix\n        col = mix(col, vec3(.6,.44,.12), 1. - smoothstep( r_pupil, r_pupil+.2, r)); //yellow\n        \n        a += .05 * fbm(20.*p);\n        col = mix(col, vec3(1), smoothstep(.3, 1., fbm(vec2(5. * r, 20. * a))));  // white highlight\n        col = mix(col, vec3(.6,.44,.12), smoothstep(.3, 1., fbm(vec2(5. * r, 5. * a)))); // yellow highlight\n        col *= 1. - smoothstep(.5, 1., fbm(vec2(5. * r, 15. * a))); // dark highlight\n        col *= 1. - .6*smoothstep(.55, .8, r); //dark at edge\n        col *= smoothstep( r_pupil, r_pupil + .05, r); //pupil; \n        col = .5*mix(col, vec3(1), smoothstep(.75, .8, r));\n    }\n    \n\treturn col;\n}\n\n// -------------------------------------------------------------------\n\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n    \n    float colorId = colorField(pos);\n    \n\tvec3 ambient = g_envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n    \n    // ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n    \n\tambient *= occlusion*.8+.2; // reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n    \n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);\n\n\tvec3 light = vec3(0);\n    \n\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n    \n\t// And sub surface scattering too! Because, why not?\n    float transmissionRange = distance/10.0; // this really should be constant... right?\n    float transmission1 = map( pos + lightDir1*transmissionRange )/transmissionRange;\n    float transmission2 = map( pos + lightDir2*transmissionRange )/transmissionRange;\n    \n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n\n    float specularity = .2; \n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n    \n\tfloat specPower;\n    specPower = exp2(3.0+5.0*specularity);\n\n    vec3 p = pos;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p.xz *= g_headRot;\n    p += headRotCenter;\n\n    vec3 albedo;\n    if (colorId < .5) {  \n        // Toge 1\n        albedo = vec3(1.,.6,0.);\n        specPower = sqrt(specPower);\n    } else if (colorId < 1.5) {  \n        // Toge 2\n        albedo = vec3(.6,.3,0.);\n        specPower = sqrt(specPower);\n    } else if (colorId < 2.5) {\n         // Skin color\n        albedo = vec3(.6,.43,.3); \n    \tfloat v = 1.;\n        if (p.z>0.) {\n        \tv = smoothstep(.02,.03, length(p.xy-vec2(0,-.03)));\n        }\n\t\talbedo = mix(vec3(.5,0,0), albedo, v);\n         \n    } else {\n        // Eye\n        if (p.z>0.) {\n            vec3 g_eyePosloc = g_eyePos;\n            g_eyePosloc.x *= sign(p.x);\n            vec3 pe = p - g_eyePosloc;\n \n            // Light point in face coordinates\n        \tvec3 g_lightPos2 = g_lightPos - headRotCenter;\n    \t\tg_lightPos2.yz *= g_headRotH;\n    \t\tg_lightPos2.xz *= g_headRot;\n    \t\tg_lightPos2 += headRotCenter;\n\n            vec3 dir = normalize(g_lightPos2-g_eyePosloc);\n            \n            float a = clamp(atan(-dir.x, dir.z), -.6,.6), \n                  ca = cos(a), sa = sin(a);\n            pe.xz *= mat2(ca, sa, -sa, ca);\n\n            float b = clamp(atan(-dir.y, dir.z), -.3,.3), \n                  cb = cos(b), sb = sin(b);\n            pe.yz *= mat2(cb, sb, -sb, cb);\n            \n            albedo = (pe.z>0.) ? iris(17.*(pe.xy), length(g_lightPos2-g_eyePosloc)) : vec3(1);\n        }\n        specPower *= specPower;\n     }\n    \n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower/32.0;\n    \n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - map( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve\n\t\n\t// prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; // could fire an additional ray for more accurate results\n    \n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\n    light += ambient;\n\tlight += subsurface;\n\n    vec3 result = light*albedo;\n\tresult = mix( result, reflection, fresnel );\n\tresult += specular1;\n    result += specular2;\n\n\treturn result;\n}\n\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n    float t0=0.,t1=100.;\n    float t2=0.,t3=100.;\n    // trace only if intersect bounding spheres\n#ifndef DRAW_DISTANCE       \n    g_bHead = intersectSphere(pos, ray, vec3(0,-.017,.02), .65, t0, t1);\n    g_bBody = intersectSphere(pos, ray, vec3(0,-.7,.02), .5, t2, t3);\n    if (g_bHead || g_bBody) \n#endif        \n    {   \n            float t = max(traceStart, min(t2,t0));\n            traceEnd = min(traceEnd, max(t3,t1));\n            float h;\n            for( int i=0; i < g_traceLimit; i++) {\n                h = map( pos+t*ray );\n                if (h < g_traceSize || t > traceEnd)\n                    return t>traceEnd?100.:t;\n                t = t+h;\n            }\n      }\n    \n\treturn 100.0;\n}\n\n\n\nvec3 Normal( vec3 pos, vec3 ray, float t) {\n\n\tfloat pitch = .2 * t / iResolution.x;\n    \n//#ifdef FAST\n//\t// don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n//#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = map(p0);\n\tfloat f1 = map(p1);\n\tfloat f2 = map(p2);\n\tfloat f3 = map(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t//return normalize(grad);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n// Camera\nvec3 Ray( float zoom, in vec2 fragCoord) {\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a ) {\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree ){\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\n\nmat2 matRot(in float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\n#ifdef DRAW_DISTANCE\n\n// ---------------------------------------------\nconst vec3 ep2 = vec3(.001,0.,0.); \nvec3 gradAt(in vec3 p) {\n\treturn vec3(\n    \t\tmap(p+ep2.xyy) - map(p-ep2.xyy),\n            map(p+ep2.yxy) - map(p-ep2.yxy),\n            map(p+ep2.yyx) - map(p-ep2.yyx));\n}\n\nfloat isoline(vec3 p, vec3 n, float pas, float tickness) {\n    float dist = map(p);\n    vec3 grad = (dist - vec3(map(p-ep2.xyy), map(p-ep2.yxy), map(p-ep2.yyx)));\n    grad -= n*dot(grad,n);\n\tfloat k = length(grad);\n    if (k != 0.) {\n        k = (iResolution.x*ep2.x)/(k*tickness);\n    \tfloat v1 = abs(mod(dist+pas*.5, pas)-pas*.5)*k/3.;\n    \tfloat v2 = abs(mod(dist+pas*2., pas*4.)-pas*2.)*k/4.;\n    \tfloat v3 = abs(dist)*k/8.;\n    \treturn smoothstep(.01,.99, v3) * (.5+.5*smoothstep(.01,.99, v1)) * smoothstep(.01,.99, v2);\n    } \n    return 1.;\n}\n\nvec3 heatmapGradient(in float t) {\n    return clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\nbool intersectPlane(in vec3 ro, in vec3 rd, in vec3 pt, in vec3 n, out float t) {\n\tfloat k = dot(rd, n);\n\tif (k == 0.) return false;\n\tt = (dot(pt, n)-dot(ro,n))/k;\n\treturn t>0.;\n}\n#endif\n\n\n\n// adapted from  BigWIngs : https://www.shadertoy.com/view/XlcSzM\nvec3 background(vec3 upCol, vec3 r, vec2 uv) {\n    float u = dot(r, vec3(0,1,0))*.5+.5;\n    vec3 col = upCol*u*2.;\n    float t = iTime*.1, \t\t\n     \tx = atan(r.x, r.z),\t\t\t\t\t\n     \ty = 3.1415*0.5-acos(r.y),\n        a = sin(r.x),\n     \tbeam = clamp(sin(10.*x+a*y*5.+t),0.,1.) * clamp(sin(7.*x+a*y*3.5-t),0.,1.)\n     \t\t + clamp(sin(42.*x+a*y*21.-t),0.,1.) * clamp(sin(34.*x+a*y*17.+t),0.,1.);\n    col *= 1.+beam*.05;\n    return col;\n}\n\n// -------------------------------------------\n\nconst float\n    a_eyeClose = .55, \n    a_eyeOpen = -.3;\n\n\nconst float \n    t_apear = 5.,\n    t_noze = t_apear+8., \n    t_openEye = t_noze + 1.,\n    t_g_headRot = t_openEye + 4.5,\n    t_rotDown = t_g_headRot + 3.5,\n    t_outNoze = t_rotDown + 3.,\n    t_night = t_outNoze + 4.,\n    t_colorfull = t_night + 5.,\n    t_disapear = t_colorfull + 2.,\n    t_closeEye = t_disapear + 3.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float st = 1.2; // speed coeff\n    float time = mod(iTime*st+55., 62.831);\n    \n// constantes\n    ma = matRot(-.5);\n    mb = matRot(-.15);\n    mc = matRot(-.6);\n\n// Eye blink\n    float a_PaupieresCligne = mix(a_eyeOpen,a_eyeClose, hash(floor(time*10.))>.98?2.*abs(fract(20.*time)-.5):0.);    \n    float a_Paupieres = mix(a_eyeClose, .2, smoothstep(t_openEye, t_openEye+2., time));    \n    a_Paupieres = mix(a_Paupieres, a_PaupieresCligne, smoothstep(t_rotDown, t_rotDown+1., time));\n    a_Paupieres = mix(a_Paupieres, a_eyeClose, smoothstep(t_closeEye, t_closeEye+3., time));\n\n    g_eyeRot = matRot(a_Paupieres);\n\n// rotation de la tete \n    float a_headRot = 0.1, a_headRotH = 0.1;\n\t\n    a_headRot = mix(0., .2*cos(20.*(time-t_g_headRot)), smoothstep(t_g_headRot, t_g_headRot+.5, time)-smoothstep(t_g_headRot+1., t_g_headRot+1.5, time));\n    a_headRotH = mix(-.1, .2*sin(20.*(time-t_g_headRot)), smoothstep(t_g_headRot+1.5, t_g_headRot+2., time)-smoothstep(t_g_headRot+2., t_g_headRot+2.5, time));\n    a_headRotH = mix(a_headRotH, .3, smoothstep(t_g_headRot+2.6, t_rotDown, time));\n    a_headRotH = mix(a_headRotH, -.2, smoothstep(t_outNoze, t_outNoze+2., time));\n    a_headRotH = mix(a_headRotH, -.1, smoothstep(t_closeEye, t_closeEye+3., time));\n    \n    g_headRot = matRot(a_headRot); \n    g_headRotH = matRot(a_headRotH); \n    mat2 g_headRot2 = matRot(-a_headRot); \n    mat2 g_headRotH2 = matRot(-a_headRotH); \n\n// Position du nez\n    animNoze = smoothstep(t_openEye+2., t_openEye+2.1, time) - smoothstep(t_openEye+2.1, t_openEye+2.3, time)\n             + smoothstep(t_openEye+2.5, t_openEye+2.6, time) - smoothstep(t_openEye+2.6, t_openEye+2.8, time);\n    \n    vec3 p_noze = g_nozePos - headRotCenter;\n    p_noze.xz *= g_headRot2;\n    p_noze.yz *= g_headRotH2;\n    p_noze += headRotCenter;\n\n// Positon du point lumineux\n    float distLightRot = mix(1., .4, smoothstep(3.,t_noze-2., time));\n    vec3 centerLightRot = vec3(0,.2,1.7);\n                              \n    float lt = 3.*(time-1.);\n    vec3 lightRot = centerLightRot + distLightRot*vec3(cos(lt*.5), .025*sin(2.*lt), sin(lt*.5));\n\t\n    g_lightPos = mix(lightRot, p_noze+.004*animNoze, smoothstep(t_noze, t_noze + 1., time));\n    g_lightPos = mix(g_lightPos, lightRot, smoothstep(t_outNoze,t_outNoze+2., time));\n\n// intensitee et couleur du point\n    float lightAppear = smoothstep(t_apear, t_apear+2., time)-smoothstep(t_disapear, t_disapear+3., time);\n\tvec3 lightCol2 = hsv2rgb_smooth(.6*(floor(st*iTime/62.831))+.04,1.,.5);\n    \n\t// Ambiant color\n\tg_envBrightness = mix(vec3(.6,.65,.9), vec3(.02,.03,.05), smoothstep(t_night, t_night+3., time));\n\tg_envBrightness = mix(g_envBrightness, lightCol2, smoothstep(t_colorfull, t_colorfull+1., time));\n\tg_envBrightness = mix(g_envBrightness, vec3(.6,.65,.9), smoothstep(t_disapear+5., t_disapear+9., time));\n\t\n\n\tvec3 lightDir1 = normalize(vec3(.5,1.5,1.5));\n\tvec3 lightCol1 = vec3(1.1,1.,.9)*.7*g_envBrightness;\n\n\tfloat lightRange2 = .4; \n\tfloat traceStart = 0.;\n\tfloat traceEnd = 40.0;\n\n    vec3 col, colorSum = vec3(0.);\n\n#if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n\t\tcol = vec3(0);\n\n        // Camera    \n\n#if (ANTIALIASING == 1)\t        \n        float randPix = 0.;\n#else \n        float randPix = hash(iTime); // Use frame rate to improve antialiasing ... not sure of result\n#endif        \n\t\tvec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));\n\t\tvec3 ray = Ray(2.0,fragCoord.xy+subPix);\n\t\t\n\t\tBarrelDistortion(ray, .5 );\n\t\t\n\t\tray = normalize(ray);\n\t\tvec3 localRay = ray;\n\t\tvec2 mouse = vec2(0);\n\t#ifdef MOUSE\n\t\tif ( iMouse.z > 0.0 )\n\t\t\tmouse = .5-iMouse.yx/iResolution.yx;\n\t\tvec3 pos = 5.*Rotate(ray, vec2(-.1,1.+time*.1)+vec2(-1.0,-3.3)*mouse );        \n\t#else    \n\t\tvec3 pos = vec3(0,0,.6) + 5.5*Rotate(ray, vec2(-.1,1.+time*.1));        \n\t#endif\n\n\t\t\n#ifdef DRAW_DISTANCE    \n        float tPlane;\n        if (intersectPlane(pos, ray, vec3(0.), -ray, tPlane)) {\n            vec3 p = pos+tPlane*ray;\n            float dist = map(p);\n            if (dist > 0.) {\n            \tcol = .1+.8*heatmapGradient(clamp(1.2*dist,0.,10.));   \n            }\n            else {\n            \tcol.brg = .1+.8*heatmapGradient(clamp(-1.2*dist,0.,10.));     \n            }\n            col *= isoline(p, -ray, .05, 1.); \n          \n        } \n        else {\n            col = vec3(0);\n        }\n#else            \n\t\tfloat t = Trace(pos, ray, traceStart, traceEnd );\n        if ( t < 10.0 )\n\t\t{           \n\t\t\tvec3 p = pos + ray*t;\n\t\t\t\n\t\t\t// Shadows\n\t\t\tvec3 lightDir2 = g_lightPos-p;\n\t\t\tfloat lightIntensity2 = length(lightDir2);\n\t\t\tlightDir2 /= lightIntensity2;\n\t\t\tlightIntensity2 = lightAppear*lightRange2/(.1+lightIntensity2*lightIntensity2);\n\t\t\t\n\t\t\tfloat s1 = 0.0;\n\t\t\ts1 = Trace(p, lightDir1, .05, 4.0 );\n\t\t\tfloat s2 = 0.0;\n\t\t\ts2 = Trace(p, lightDir2, .05, 4.0 );\n\t\t\t\n\t\t\tvec3 n = Normal(p, ray, t);\n\t\t\tcol = Shade(p, ray, n, lightDir1, lightDir2,\n\t\t\t\t\t\tlightCol1, lightCol2*lightIntensity2,\n\t\t\t\t\t\t(s1<20.0)?0.0:1.0, (s2<20.0)?0.0:1.0, t );\n\t\t\t\n\t\t\t// fog\n\t\t\tfloat f = 200.0;\n\t\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcol = Sky( ray );\n            col = background(col, ray, subPix);\n        //    col *= .8+.2*b;\n\t\t}\n        // Draw light\n\t\tfloat s1 = max(dist(pos, ray, g_lightPos)+.03,0.);\n\t\tfloat dist = length(g_lightPos-pos);\n\t\tif (dist < t) {\n\t\t\tvec3 col2 = lightCol2*2.5*exp( -.01*dist*dist );\n\t\t\tfloat BloomFalloff = 15000.; //mix(1000.,5000., Anim);\n\t\t\tcol = col *(1.-lightAppear) + lightAppear*mix(col2, col, smoothstep(.037,.047, s1));\n\t\t\tcol += lightAppear*col2*col2/(1.+s1*s1*s1*BloomFalloff);\n\t\t}\n        \n#endif\t\t\t\n\t\t\n\n\t// Post traitments -----------------------------------------------------    \n\t\t// Vignetting:\n\t\tcol *= smoothstep(.5, .0, dot(localRay.xy,localRay.xy) );\n\n\t\t\t\n\t\tcolorSum += col;\n        \n#if (ANTIALIASING > 1)\t\n\t}\n    \n    col = colorSum/float(ANTIALIASING);\n#else\n\tcol = colorSum;\n#endif\n    \n\n    // Compress bright colours, (because bloom vanishes in vignette)\n    vec3 c = (col-1.0);\n    c = sqrt(c*c+.05); // soft abs\n    col = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\n\t// compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));//dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); // prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2/l;\n    \n\tfragColor =  vec4(pow(col,vec3(1./1.6)),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3GR4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1513, 1513, 1536, 1536, 1574], [1576, 1576, 1602, 1602, 1811], [1813, 1893, 1941, 1941, 2097], [2099, 2129, 2167, 2167, 2201], [2203, 2232, 2329, 2329, 2502], [2583, 2583, 2634, 2634, 2675], [2677, 2677, 2754, 2754, 2889], [2891, 2942, 3029, 3029, 3236], [3238, 3238, 3287, 3287, 3375], [3377, 3453, 3501, 3501, 3540], [3542, 3542, 3584, 3584, 3642], [3725, 3725, 3768, 3768, 4136], [4138, 4138, 4184, 4184, 6627], [6629, 6629, 6653, 6653, 6718], [6720, 6720, 6757, 6757, 6795], [6797, 6797, 6817, 6817, 7571], [7613, 7613, 7633, 7633, 7882], [7885, 7916, 7942, 7942, 8207], [8290, 8290, 8344, 8344, 8406], [8408, 8408, 8429, 8429, 8526], [8758, 8758, 8780, 8780, 8931], [8933, 8933, 8954, 8954, 9293], [9327, 9327, 9347, 9347, 9553], [9556, 9556, 9587, 9587, 10578], [10654, 10654, 10819, 10819, 14873], [15651, 15651, 15694, 15694, 16308], [16311, 16321, 16363, 16363, 16433], [16435, 16435, 16472, 16472, 16687], [16709, 16709, 16763, 16834, 16941], [16944, 16944, 16969, 16969, 17038], [18244, 18310, 18356, 18356, 18740]], "test": "error"}
{"id": "Md3GRn", "name": "Simple Terrain", "author": "felipevsfbr", "description": "Result of some effects put together ...", "tags": ["raymarching"], "likes": 15, "viewed": 390, "published": "Public", "date": "1447633199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*The moment aliasing actually make things better ahahahaha*/\nconst float dMax = 100.0;\nconst float dSea = 30.3;\nconst int ITER_FRAGMENT = 4;\nconst float SEA_HEIGHT = 1.1;\nconst float SEA_CHOPPY = 0.9;\nconst float SEA_SPEED = 1.0;\nconst float SEA_FREQ = 0.3;\nconst vec3 SEA_BASE = vec3(0.1,0.29,0.19);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,1.0,0.8);\nfloat SEA_iTime = 0.;\nvec3 camEye;\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nconst mat2 rotate2D = mat2(1.732, 1.323, -1.523, 1.652);\nvec3 sunColour = vec3(1.0, .75, .4);\nvec3 sunP;\nvec3 sunLight;\nfloat Hash( float n );\nvec3 noise( in vec2 x );\nfloat snoise(vec2 p);\nfloat Terrain(vec2 p);\nvec3 GetSky(in vec3 rd);\nvec3 doLight(vec3 ro, vec3 rd, vec2 res);\nvec3 getNormal(vec3 p);\n\nfloat sea_octave(vec2 uv, float choppy) \n{\n    \tuv += snoise(uv);        \n    \tvec2 wv = 1.0-abs(cos(uv));\n    \treturn pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat Sea(vec3 p)\n{\n\tfloat freq = SEA_FREQ;\n    \tfloat amp = SEA_HEIGHT;\n    \tfloat choppy = SEA_CHOPPY;\n    \tvec2 uv = p.xz; uv.x *= 0.75;\n    \n    \tfloat d, h = 0.0;    \n    \tfor(int i = 0; i < ITER_FRAGMENT; i++) \n\t{        \n    \t\td = sea_octave((uv + SEA_iTime)*freq,choppy);\n    \t\td += sea_octave((uv - SEA_iTime)*freq,choppy);\n       \t\t\n\t\th += d * amp;        \n    \t\tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        \tchoppy = mix(choppy,1.0,.2);\n\t}\n\treturn p.y - h;\t\n}\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) \n{    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) \n{  \n    \tfloat fresnel = 1.0 - max(dot(n,-eye),0.0);\n    \tfresnel = pow(fresnel,3.0) * 0.85;\n        \n    \tvec3 reflected = GetSky(reflect(eye,n));    \n    \tvec3 refracted = SEA_BASE; \n    \n    \tvec3 color = mix(refracted,reflected,fresnel);\n    \n    \tfloat atten = max(1.0 - dot(dist,dist) * 0.001, 0.2);\n    \tcolor += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n   \n    \tcolor += vec3(specular(n,l,eye,10.0));\n    \treturn color;\n}\n\nvec2 map(vec3 p)\n{\n\tfloat d = Terrain(p.xz);\n\tfloat dd = Sea(p);\n\tfloat m = -1.0;\n\tfloat dist = length(p - camEye);\n\td = p.y - d;\n\tif(d < dSea && dist < dSea + 2.555)\n\t\tm = 1.0;\n\t\n\telse if(d < dMax)\n\t{\n\t\td = dd;\n\t\t m = 2.0;\n\t}\n\treturn vec2(d, m); \n}\n\nvec2 raymarch(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tfloat eps = 0.01;\n\tfloat h = 2.0*eps;\n\tfloat m = -1.0;\n\tfor(int i = 0; i < 20;  i++)\n\t{\n\t\tif(abs(h) > eps || t < dMax)\n\t\t{\n\t\t\tt += h;\n\t\t\tvec2 res = map(ro + t*rd);\n\t\t\th = res.x;\n\t\t\tm = res.y;\n\t\t}\n\t\telse break;\n\t}\n\tif(t > dMax) m = -1.0;\n\treturn vec2(t,m);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 color = vec3(0.0);\n\tvec2 res = raymarch(ro, rd);\n\tvec3 sky = GetSky(rd);\n\tcolor = sky;\n\tvec3 pos = ro + res.x*rd;\n\tvec3 nor = getNormal(pos);\n\tif(res.y > 0.5 && res.y < 1.5)\n\t{\n\t\tcolor = doLight(ro, rd, res);\n\t\tvec3 darker = vec3(0.1);\t\n\t\tcolor -= darker;\n\t\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\t\tcolor = mix(color, sky, 0.92*uv.y);\n\t}\n\telse if(res.y > 1.5)\n\t{\n\t\tcolor = mix(\n        \tsky,\n       \t\tgetSeaColor(pos,nor,sunLight,rd,pos - camEye),\n    \t\tpow(smoothstep(0.0,-.3,rd.y),0.2)) * vec3(0.45);\n\t\tfloat fogAmount = clamp(res.x*res.x* 0.00009, 0.0, 1.0);\n\t\tcolor = mix(color, sky, fogAmount);\n\t}\n\treturn color;\n}\n\nvec3 lensFlare(vec3 rgb, vec3 ww, vec3 uu, vec3 vv,\n\t\t\t\t\t\t\t\t   vec2 uv, vec3 dir)\n{\n\tvec3 color = rgb;\n\tfloat bri = dot(ww,sunLight)*.75;\n\tmat3 camMat = mat3(uu, vv, ww);\n\tfloat PI = 3.1415;\n\tif(bri > 0.0)\n\t{\n\t\tvec2 sunPos = (-camMat * sunLight).xy;\n\t\t\n\t\tbri = pow(bri, 7.0)*.8;\n\t\tfloat glare = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\tfloat glare2 = max(sin(smoothstep(.4, .7, length(sunPos - uv*.5))*PI), 0.0);\n\n\t\tfloat glare3 = max(1.0-length(sunPos - uv*2.1), 0.0);\n\t\tfloat glare4 = max(sin(smoothstep(-0.05, .4, length(sunPos + uv*2.5))*PI), 0.0);\n\n\t\tcolor += bri * vec3(1.0, .0, .0)  * pow(glare, 12.5)*.07;\n\t\tcolor += bri * vec3(.0, 1.0, 1.0) * pow(glare2, 3.0);\n\t\tcolor += bri * vec3(1.0, 1.0, 0.0)* pow(glare3, 3.0)*4.0;\n\t\tcolor += bri * vec3(.5, 1.0, 1.0) * pow(glare4, 33.9)*.7;\n\t} \t\n\treturn color;\n}\n\nvec3 PostProcess(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(0.45));\n\tfloat contrast = 1.3;\n\tfloat saturation = 1.0;\n\tfloat brightness = 1.3;\n\trgb = mix(vec3(0.5), mix(vec3(dot(vec3(.2125, .7154, .0721), \n\t\t\t\t\trgb*brightness)), rgb*brightness, saturation), contrast); \n\trgb *= 0.4 + 0.4*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2);\n\treturn rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunP = vec3(1000.0, 750.0 + 650.0*sin(0.5*iTime), 3500.0);\n   \tsunLight = normalize(sunP);\n\tSEA_iTime = iTime * SEA_SPEED;\n\tvec2 xy = fragCoord.xy/iResolution.xy;\n\tvec2 uv = 2.0*xy - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\tfloat x = 0.0 ;\n\tfloat y = 10.0;\n\tfloat z = -11.0;\n\tvec3 eye = vec3(x,y,z);\n\tvec3 at = vec3(eye.x +4.0, eye.y - 0.9, 0.0);\n\tcamEye = eye;\n\t//at.x *= 5.0*sin(iTime);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 ww = normalize(at-eye);\n\tvec3 uu = normalize(cross(ww, up));\n\tvec3 vv = normalize(cross(uu, ww));\n\tvec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n\tvec3 ro = eye;\n\tvec3 color = render(ro, rd);\n\tcolor = lensFlare(color, ww, uu, vv, uv, rd);\n\tcolor = PostProcess(color, xy);\n    fragColor = vec4(color, 1.0);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 n;\n\tfloat eps = 0.001;\n\tn.x = map(vec3(p.x + eps, p.y, p.z)).x - map(vec3(p.x - eps, p.y, p.z)).x; \n\tn.y = map(vec3(p.x, p.y + eps, p.z)).x - map(vec3(p.x, p.y - eps, p.z)).x;\n\tn.z = map(vec3(p.x, p.y, p.z + eps)).x - map(vec3(p.x, p.y, p.z - eps)).x;\n\treturn normalize(n);\n}\n\nvec3 doLight(vec3 ro, vec3 rd, vec2 res)\n{\n\tvec3 pos = ro + res.x*rd;\n\tvec3 nor = getNormal(pos);\n\tvec3 lightv = sunP - pos;\t\n\tfloat dist = length(lightv);\n\tlightv = normalize(lightv);\n\tfloat at = 1500.0/(.0 + 0.1*dist);\n\tvec3 difc = vec3(0.7, 0.5, 0.2);\n\tvec3 dif = at*sunColour*max(0., dot(lightv, nor))*difc;\n\tvec3 refl = reflect(lightv, nor);\n\tfloat s = dot(lightv, refl);\n\tvec3 spec = vec3(0.0);\n\tif(s > 0.7)\n\t\tdif -= vec3(0.1)*pow(s, 64.0);\n\treturn max(dif + spec, 0.1);\n}\n\nfloat Terrain(vec2 p)\n{\n\tvec2 pos = p*0.0035;\n\tfloat w = 24.0;\n\tfloat f = 0.0;\n\tvec2 d = vec2(0.0);\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tvec3 n = noise(pos);\n\t\td += n.yz;\n\t\tf += w*n.x/(1.0 + dot(d,d));\n\t\tw = w*0.57;\n\t\tpos = rotate2D * pos;\n\t}\n\treturn f;\n}\n\nfloat snoise(vec2 p) \n{\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,.0),3.);\n\tvec3  sky = mix(vec3(.015,0.0,.01), vec3(.42, .2, .1), v);\n\tsky = sky + sunColour * sunAmount * sunAmount * .5;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .4);\n\treturn clamp(sky, 0.3, 1.0);\n}\n\nvec3 noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n\n    float a = Hash(n+  0.0);\n    float b = Hash(n+  1.0);\n    float c = Hash(n+ 57.0);\n    float d = Hash(n+ 58.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat Hash( float n )\n{\n    return fract(sin(n)*33753.545383);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3GRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[731, 731, 773, 773, 890], [892, 892, 911, 911, 1367], [1369, 1369, 1416, 1416, 1520], [1522, 1522, 1586, 1586, 2026], [2028, 2028, 2046, 2046, 2277], [2279, 2279, 2312, 2312, 2587], [2589, 2589, 2620, 2620, 3249], [3251, 3251, 3334, 3334, 4091], [4093, 4093, 4130, 4130, 4440], [4442, 4442, 4499, 4499, 5243], [5245, 5245, 5269, 5269, 5551], [5553, 5553, 5595, 5595, 6031], [6033, 6033, 6056, 6056, 6284], [6286, 6286, 6309, 6309, 6543], [6545, 6545, 6570, 6570, 6864], [6866, 6866, 6891, 6891, 7232], [7234, 7234, 7257, 7257, 7298]], "test": "error"}
{"id": "Md3GzM", "name": "2d experiment #12 - pii", "author": "public_int_i", "description": "lsdflsjdljf", "tags": ["lsdjflsj"], "likes": 1, "viewed": 345, "published": "Public API", "date": "1448564646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//#define VISUALIZE_UV\n#define VISUALIZE_CIRCLE_DF\n//#define VISUALIZE_COOL\n\n#define SAMPLES 1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv *= 3.5+cos(iTime*.5)*2.5;//4.5+sin(iTime*.25)*2.;\n    vec2 ruv = uv;\n    \n    fragColor = vec4(0.);\n    \n    for (int b = 0; b < SAMPLES; b++) {\n    \n      //  uv = ruv+(cos(uv*.7521+float(b)*.42)+cos(uv.yx*.2234+float(b)*2.42))*.;\n        \n        for (int i = 0; i < 3; i++) {\n            float ang = 0.;//length(uv)*.1+\n                //length(reflect(cos(uv),sin(uv.yx)))*.1;\n            uv = reflect(sin(uv),cos(uv));//*mat2(sin(ang),cos(ang),-cos(ang),sin(ang));\n        }\n\n        #ifdef VISUALIZE_UV\n        fragColor += vec4(cos(normalize(abs(uv))*12.)*.5+.5,0.,1.0);\n        #endif\n\n        #ifdef VISUALIZE_CIRCLE_DF\n        float dist = max(0.,1.-length(mod(abs(uv),1.)-.5)) + iTime*.03;\n        fragColor += vec4(sin(dist*3.5+.8),\n                         cos(dist*4.6+.2),\n                         sin(dist*2.6), 1.)*.5+.5;\n        #endif\n        \n        #ifdef VISUALIZE_SQUARE_DF\n        \n        #endif\n\n        #ifdef VISUALIZE_COOL\n        fragColor += vec4(cos(uv*10.)*.5+.5\n                        ,cos(length(uv)*4.)*.5+.5,1.);\n        #endif\n        \n    }\n    \n    fragColor /= float(SAMPLES);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3GzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 155, 155, 1331]], "test": "ok"}
{"id": "MdcGRM", "name": "Simple HSV Palette fade", "author": "prozacgod", "description": "I'm trying to understand shaders, another piece to the puzzle of getting cool stuff working, this seems to be a decent prof of concept!\nvalue boundary", "tags": ["colors", "palette", "hsv", "fade"], "likes": 4, "viewed": 200, "published": "Public", "date": "1448548043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tThis code creates a color gradiant from the palette!\n\t\n\t* You can also make the color gradiant palette have dynamic stops.\n\n*/\n\n// this was shamelessly pulled from the web\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/* the following code is generated from a python script */\nvec4 _p_0 = vec4(1.0, 0.750,0.380,0.000);\nvec4 _p_1 = vec4(0.006,0.780,0.760,0.200);\nvec4 _p_2 = vec4(0.033,0.750,1.000,0.400);\nvec4 _p_3 = vec4(0.125,0.520,1.000,0.600);\nvec4 _p_4 = vec4(0.244,0.070,1.000,0.800);\nvec4 _p_5 = vec4(0.000,0.000,1.000,1.000);\nvec4 _palette_lo(float i) {\n  return  (i<=_p_1.w)?_p_0: (i<=_p_2.w)?_p_1: (i<=_p_3.w)?_p_2: (i<=_p_4.w)?_p_3: (i<=_p_5.w)?_p_4: _p_5;\n}\nvec4 _palette_hi(float i) {\n  return  (i<=_p_1.w)?_p_1: (i<=_p_2.w)?_p_2: (i<=_p_3.w)?_p_3: (i<=_p_4.w)?_p_4: (i<=_p_5.w)?_p_5: _p_5;\n}\n/* end generated code */\n\nvec3 palette(float i) {\n    vec4 hi = _palette_hi(i);\n    vec4 lo = _palette_lo(i);\n    \n    float i_p = clamp((i - lo.w) / (hi.w - lo.w), 0.0, 1.0);\n    float i_pp = (1.0 - i_p);\n        \n    float xc = (lo.x*i_pp) + (hi.x*i_p);\n    \n    if (abs(hi.x - lo.x) > 0.5) {\n        xc = ((lo.x + 1.0 + hi.x) / 2.0) - 1.0;\n    }\n    \n    vec3 rlo = lo.xyz * i_pp;\n    vec3 rhi = hi.xyz * i_p;\n    vec3 r = rlo.xyz + rhi.xyz;\n    r.x = xc;\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float t = sin(mod(iTime, 1.0) * 6.288);\n    \n    // this just plays around with the hue start/stop positions...\n    \n    _p_1.w = 0.200 + (sin(t+0.0) * 0.05);\n    _p_2.w = 0.400 + (sin(t+2.0) * 0.05);\n    _p_3.w = 0.600 + (sin(t+4.0) * 0.05);\n    _p_4.w = 0.800 + (sin(t+6.0) * 0.05);\n    \n    fragColor = vec4(hsv2rgb(palette(uv.x)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 176, 198, 198, 367], [685, 685, 712, 712, 820], [821, 821, 848, 848, 956], [983, 983, 1006, 1006, 1436], [1438, 1438, 1495, 1495, 1886]], "test": "ok"}
{"id": "MdcGzH", "name": "wew lad", "author": "asneakyfatcat", "description": "First shader, raymarch func based of off dilas ", "tags": ["raymarching", "reactive"], "likes": 3, "viewed": 185, "published": "Public", "date": "1448050048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat map(vec3 p)\n{\n    \n    \n    vec3 q = fract(p) * 2.0 - 1.0;\n    q.y = q.y*0.6*cos(iTime);\n    //q.x = texture( iChannel0, vec2(q.x,q.x) ).x;\n    \n    //q.x = q.z*0.1*cos(iTime);\n    //q.x = q.x*.9;\n    \n    //return length(q) - 0.05;\n    return length(q)-sin(iTime)/9.0-.3;\n}\n\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for(int i = 0; i < 32; i++) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * .5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv*2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    //vec3 r = vec3(uv,1.0);\n    \n    float the = iTime * .1;\n    r.xz *= mat2(cos(the), -sin(the), -sin(the), -cos(the));\n    \n    vec3 o = vec3(0.0, iTime, iTime);\n    \n    float t = trace(o, r);\n    \n    float fog_bright = 0.3;\n    fog_bright = 1.0-smoothstep(.5,.9,(texture( iChannel0, vec2(1.0, 3.0) ).x));\n    //fog_bright = texture(iChannel0, vec2(0.0,0.0)).x/3.0;\n    float fog = 1.0 / (1.0 + t * t * fog_bright);\n    \n    vec3 fc = vec3(fog);\n    \n    fc.x =  fc.x * sin(iTime);\n    fc.z = fc.z * cos(iTime+9.4);\n    //fc.z = smoothstep(.3, .9, abs(fc.z*sin(iTime)));\n    //fc.z = fc.z * -sin(iTime);\n    //fc.z+=1.0;\n\tfragColor = vec4(fc,1.0);\n    //fragColor = vec4(0.0);\n}", "image_inputs": [{"id": "4ssGRn", "previewfilepath": "https://soundcloud.com/mangojuicerecords/swindail-dunk", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/mangojuicerecords/swindail-dunk", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 21, 282], [285, 285, 314, 314, 464], [466, 466, 523, 523, 1375]], "test": "error"}
{"id": "Mdd3R7", "name": "SunflowerTransform", "author": "jt", "description": "An efficient (loop-less) transformation to \"sunflower coordinates\".", "tags": ["spiral", "sunflower", "loopless", "coordinatetransformation", "vogelspiral"], "likes": 14, "viewed": 727, "published": "Public", "date": "1448754187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sunflower Transform - written 2015-11-18 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thanks to FabriceNeyret2 for optimizations!\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat circ(vec2 v)\n{\n    v = fract(v)-.5;\n    return max(     smoothstep(.4, .5, length(v)), \n                (1.-smoothstep(.0, .1, abs(v.y))) * mirror(iTime*.1) );\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n\tvec2 R = iResolution.xy; \n    I = 8.* (I+I-R)/R.y;\n\n    //I = vec2(0, length(I)) + fract( atan(I.y, I.x) / 2./3.1415926 );\n    I = vec2(0, length(I)) + fract( atan(I.y, I.x) / 6.283 );\n    I.x = ceil(I.y) - I.x;\n    //I.x *= I.x * (sqrt(5.)-1.)*2.;\n    I.x *= I.x * 2.4; // approximation to golden angle pi * (3-sqrt(5))\n    //I.x *= I.x * 3.1415926/(sqrt(5.)-1.);\n    //I.x *= I.x * (sqrt(5.)-1.)*2.*mirror(iTime*.01);\n    //I.x -= iTime;\n\n    O = vec4(circ(I));\n    //O = vec4(length(fract(I)-.5));\n}\n\n/*\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat circ(vec2 v)\n{\n    //return smoothstep(.4, .5, length(fract(v)-.5));\n    return max(smoothstep(.4, .5, length(fract(v)-.5)), (1.- smoothstep(.0, .1, abs(fract(v.y)-.5)))*mirror(iTime * .1));\n    //return smoothstep(.0, .1, abs(length(fract(v)-.5)-.4));\n    //return smoothstep(.0, .1, abs(length(fract(v)-.5)-.4)) * smoothstep(.0, .1, abs(fract(v.y)-.5));\n    //return max(smoothstep(.0, .1, abs(length(fract(v)-.5)-.4)), (1.- smoothstep(.0, .1, abs(fract(v.y)-.5)))*mirror(iTime * .1));\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n\tI = 2.*I/iResolution.xy-1.;\n    I.x *= iResolution.x / iResolution.y;\n    I *= 8.;\n    float a = fract(atan(I.y, I.x) / 2./3.1415926);\n    float b = length(I) + a;\n    I = vec2(a, b);\n    I.x = ceil(b) - I.x;\n    I.x *= I.x * (sqrt(5.)-1.)*2.;\n\n    O = vec4(circ(I));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdd3R7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[244, 244, 264, 264, 411], [413, 413, 451, 451, 955]], "test": "ok"}
{"id": "Mdd3Rr", "name": "Scanline(ish) filter", "author": "rafaellago", "description": "This is a kind of old crt green monitors filter. It will be a base for a program I'm putting together to run as an Android daydream.\n\nAny thought on how to improve are very welcome :)", "tags": ["scanline", "green", "kindof"], "likes": 8, "viewed": 463, "published": "Public", "date": "1447865144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 tex = texture(iChannel0, uv ).xyz; \t\n\n\n\tvec3 defaultColor = vec3(0.5, 1.0, 0.5);\n    \n    vec3 finalColor = defaultColor;\n    float value = ceil(iTime / 10.0) - iTime / 10.0;\n    vec2 aniuv = uv - value;\n    finalColor *= abs (0.01 / sin((aniuv.y)) * 0.2 ) + 0.0;\n    finalColor += tex * defaultColor;\n    \n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdd3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 457]], "test": "error"}
{"id": "MddGzn", "name": "Hello metaballs!", "author": "danim", "description": "Little practice with metaballs.", "tags": ["metaballs"], "likes": 5, "viewed": 162, "published": "Public", "date": "1447842462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tweak seed values\n#define INITIAL_POSITION_SEED 3.141592\n#define RADIUS_SEED 2.0\n#define RADIUS_MAX 0.2\n#define METABALLS 15\n#define METABALL_THRESHOLD 4.\n#define THRESHOLD_ERROR 0.05\n\n\nfloat hash(float seed)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec2 metaball_position( int metaball )\n{\n    float x = hash( pow(float(metaball),4.) + INITIAL_POSITION_SEED );\n    float y = hash( x );\n    float a = hash( x + y );\n    float b = x + y + a;\n    return vec2( x + 0.5 * cos( a * iTime ), hash( x ) + 0.5 * sin( b * iTime ) );\n}\n\nfloat metaball_radius( int metaball )\n{\n    float r = hash( pow(float(metaball),2.) + RADIUS_SEED );\n    return min( r, RADIUS_MAX );\n}\n\nfloat metaball_function( in vec2 center, float radius, in vec2 p )\n{\n    vec2 r = p - center;\n    //return radius / length(r); // 1 / r\n    return (radius * radius) / dot( r,r ); // 1 / r^2\n    \n    //R / ( |x-x0| + |y-y0| )\n    //return radius / ( abs(r.x) + abs(r.y) );\n    \n    // try other functions\n\t// (1-r^2)^2\n    //r^4 - r^2 + 0.25\n\t//6r^5 - 15r^4 + 10r^3\n}\n\n// debugging purposes\nfloat disk( in vec2 center, float radius, in vec2 p )\n{\n    return 1. - smoothstep( radius - 0.01, radius + 0.01, length( p - center ) );\n    //return 1. - step( radius, length( p - center ) );\n}\n\n/*vec4 metaball_color( int metaball, in vec2 p )\n{\n    return vec4(p,0.5+0.5*sin(iTime),1.0);\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    //fragColor = vec4( 1. );\n    float f = 0.;\n    float t = 0.;\n    for( int i = 0; i < METABALLS; ++i )\n    {\n        vec2 mp = metaball_position( i );\n        float mr = metaball_radius( i );\n        f += disk( mp, mr, uv );\n        t += metaball_function( mp, mr, uv );\n    }\n    \n    float e = smoothstep( METABALL_THRESHOLD - THRESHOLD_ERROR, METABALL_THRESHOLD + THRESHOLD_ERROR, t );\n    if( e > 0. && e < 1. )\n    {\n        fragColor = vec4( 0.0 );\n        return;\n    }\n    \n    f = clamp( f, 0., 1. );\n    fragColor = fragColor * f + (1.-f) * vec4( 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddGzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 213, 262, 306], [308, 308, 348, 348, 583], [585, 585, 624, 624, 720], [722, 722, 790, 790, 1088], [1090, 1112, 1167, 1167, 1307], [1408, 1408, 1465, 1465, 2126]], "test": "ok"}
{"id": "MdtGRH", "name": "SinCosInversion", "author": "RenoM", "description": "image is distorted by circle inversion. comment line 11 to undo the distortion", "tags": ["sinsinecosinversion"], "likes": 2, "viewed": 153, "published": "Public", "date": "1448175923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define D(a,b) 1.-abs(2.*(a-b.x)/(b.y-b.x)-1.)\n#define S(op,a,b) l=vec2(op(uv.x+iTime*a))+vec2(-eps,eps);if(uv.y>l.x&&uv.y<l.y)b+=D(uv.y, l);\nvec2 R=iResolution.xy;\nfloat s=sin(iTime),eps =.1+.25*s*s;\n\nvoid mainImage(out vec4 C,in vec2 U)\n{\n\tvec2 uv=3.*U/R-1.5,l;\n    uv.x*=2.*R.x/R.y;\n    uv*=pow(5./length(uv),2.);\n    vec3 c=vec3(0);\n    S(sin,.25,c.r)\n    S(sin,.5,c.g)\n    S(sin,.75,c.b)\n    S(cos,.25,c.rg)\n    S(cos,.5,c.rb)\n    S(cos,.75,c.gb)\n    C.xyz= min(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "MdtGRM", "name": "Terrain by Perlin Noise", "author": "battal", "description": "Procedurally generated terrain using Perlin Noise", "tags": ["raymarching", "terrain"], "likes": 4, "viewed": 252, "published": "Public", "date": "1448692150", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* ----- Constants ----- */\n\n#define PI 3.14159265359\n\n#define AUTO_REPEAT 256.0\n#define TERRAIN_OCTAVES 5\n\n#define FAR_PLANE 100.0\n\n#define MIN_T 0.5\n#define MAX_T 50.0\n\n#define EPS 0.001\n\n\n/* ----- Specification ----- */\n\n/* Noise functions */\nfloat hash(float x, float y);\nfloat fade(float t);\n\nint get_gradient(float xi, float yi, int repeat);\nfloat get_dot(int gradient, float x, float y);\n\nfloat noise(float x, float y, int repeat);\nfloat octave_noise(float x, float y, int repeat, float frequency, float max_amplitude, float persistence);\n\n/* Distance fields and ray marching */\nfloat terrain(vec3 p);\nfloat sphere(vec3 p);\n\nfloat castRay(vec3 eye, vec3 ray);\n\n/* Lighting */\nfloat get_shadow(vec3 terrain_p, vec3 light_ray);\nvec4 get_terrain_color(vec3 eye, vec3 ray, float t, vec3 sun_dir);\n\nvec4 get_fog_color(vec3 ray, vec3 sun_dir);\nfloat get_fog_amount(vec3 eye, vec3 ray, float t);\nfloat get_fog_amount_const(float t);\n\nvec4 get_lighting(vec3 eye, vec3 ray, float t);\n\n/* Transformation */\nmat4 inverse_view_matrix(vec3 look, vec3 up, vec3 pos);\nmat4 inverse_projection_matrix(float width_angle, float height_angle, float far);\n\n\n/* ----- Functions ----- */\n\n/* Pseudo-random number generator */\nfloat hash(float x, float y) {\n    return fract(sin(floor(x) * 127.1 + floor(y) * 311.7) * 43758.5453123);\n}\n\n/* Interpolation function */\nfloat fade(float t)\n{\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n/* Integer representation of the gradient */\nint get_gradient(float xi, float yi, int repeat)\n{\n    /* Take modulus to wrap overflowed numbers */\n    if(repeat > 0)\n    {\n    \txi = mod(xi, float(repeat));\n    \tyi = mod(xi, float(repeat));\n    }\n    \n    xi = mod(xi, AUTO_REPEAT);\n    yi = mod(yi, AUTO_REPEAT);\n    \n    /* Random gradient in last four bits */\n    float val = hash(xi, yi);\n\treturn int(mod(val * 256.0, 256.0));\n}\n\n/* Dot product between gradient and location vector */\nfloat get_dot(int gradient, float x, float y)\n{\n\tint grad_bits = int(mod(float(gradient), 4.0));\n    \n    if(grad_bits == 0x0)\n    {\n    \treturn x + y;\n    }\n    else if(grad_bits == 0x1)\n    {\n    \treturn x - y;\n    }\n    else if(grad_bits == 0x2)\n    {\n    \treturn -x + y;\n    }\n    else if(grad_bits == 0x3)\n    {\n    \treturn -x - y;\n    }\n}\n\n/* Perlin noise function */\nfloat noise(float x, float y, int repeat)\n{   \n    /* Get inputs */\n    if(repeat > 0)\n    {\n    \tx = mod(x, float(repeat));\n        y = mod(y, float(repeat));\n    }\n    \n    \n    /* Closest integral coordinates */\n    float xi = mod(floor(x), AUTO_REPEAT);\n    float yi = mod(floor(y), AUTO_REPEAT);\n    \n    /* Coordinates within unit box */\n    float xf = fract(x);\n    float yf = fract(y);\n    \n    /* Interpolation factors */\n    float u = fade(xf);\n    float v = fade(yf);\n    \n    /* Calculate gradients */\n    int aa = get_gradient(xi, yi, repeat);\n    int ab = get_gradient(xi + 1.0, yi, repeat);\n    int ba = get_gradient(xi, yi + 1.0, repeat);\n    int bb = get_gradient(xi + 1.0, yi + 1.0, repeat);\n    \n    /* Calculate influence */\n    float g1 = get_dot(aa, xf, yf);\n    float g2 = get_dot(ab, xf - 1.0, yf);\n    float g3 = get_dot(ba, xf, yf - 1.0);\n    float g4 = get_dot(bb, xf - 1.0, yf - 1.0);\n    \n    return mix(mix(g1, g2, u), mix(g3, g4, u), v);\n}\n\n/* Perlin noise with octaves, adjustable frequency and amplitude */\nfloat octave_noise(float x, float y, int repeat, float frequency, float max_amplitude, float persistence)\n{\n    float total = 0.0;\n    float amplitude = max_amplitude;\n    \n    for(int i = 0; i < TERRAIN_OCTAVES; i++)\n    {\n        /* Accumulate noise */\n        total += amplitude * noise(x * frequency, y * frequency, repeat);\n        \n        /* Update frequency, amplitude */\n        frequency = frequency * 2.0;\n        amplitude = amplitude * persistence;\n    }\n    \n    return total;\n}\n\n/* Terrain height function */\nfloat terrain(vec3 p)\n{\n\treturn octave_noise(p.x, p.z, 0, 1.0 / 4.0, 1.5, 0.4);\n}\n\n/* Sphere distance function */\nfloat sphere(vec3 p)\n{\n\treturn length(p - vec3(0.0, 1.0, -10.0)) - 0.5;\n}\n\n/* Ray march, return time of intersection */\nfloat castRay(vec3 eye, vec3 ray)\n{   \n    float t = MIN_T;\n    \n    vec3 p = eye + t * ray;\n    float h;\n    \n    for(int i = 0; i < 400; i++)\n    {\n        /* Get height to terrain */\n        h = p.y - terrain(p);\n        \n        /* Return t if close enough */\n        if(h < 0.001)\n        {\n        \treturn t;\n        }\n        \n        if(t > MAX_T)\n            return -1.0;\n        \n        /* Decrease precision */\n        t += h * 0.75;\n        \n        /* Calculate next point */\n        p = eye + ray * t;\n    }\n    \n    return -1.0;\n}\n\n\n/* Get shadow from terrain point and light ray to point*/\nfloat get_shadow(vec3 op, vec3 light_ray)\n{\n\tfloat t = MIN_T;\n    \n    vec3 p = op + light_ray * t;\n    float h;\n    float shadow = 1.0;\n    \n    for(int i = 0; i < 400; i++)\n    {\n    \th = p.y - terrain(p);\n        \n        if(h < 0.001)\n        {\n            return 0.0;\n        }\n        \n        if(t > MAX_T)\n        {\n            return shadow;\n        }\n        \n        shadow = min(shadow, 10.0 * h / t);\n        \n        t += h * 0.75;\n        p = op + light_ray * t;\n    }\n    \n    return shadow;\n}\n\n/* Get terrain color */\nvec4 get_terrain_color(vec3 eye, vec3 ray, float t, vec3 sun_dir)\n{    \n    float shadow = get_shadow(eye + ray * t, -sun_dir);\n    \n    /* Base terrain color (brown) */\n    vec3 base_color = vec3((150.0 / 256.0),\n                            (126.0 / 256.0),\n                            (109.0 / 256.0));\n    \n    /* Normal */\n    vec3 p = eye + ray * t;\n    vec3 normal = normalize(vec3(terrain(p + vec3(-EPS, 0.0, 0.0)) - terrain(p + vec3(EPS, 0.0, 0.0)),\n                       2.0 * EPS,\n                       terrain(p + vec3(0.0, 0.0, -EPS)) - terrain(p + vec3(0.0, 0.0, EPS))));\n    \n    /* Ambient lighting */\n    float ka = 0.2;\n    vec3 ambient_color = base_color;\n        \n    /* Diffuse lighting */\n    float kd = 0.6;\n    float diffuse_dot = dot(normal, -sun_dir);\n    vec3 diffuse_color = base_color;\n    \n    /* Specular lighting */\n    float ks = 0.2;\n    vec3 specular_color = base_color;\n    \n    return vec4(ka * ambient_color + kd * shadow * diffuse_dot * diffuse_color, 1.0);\n}\n\n/* Get fog color */\nvec4 get_fog_color(vec3 ray, vec3 sun_dir)\n{\n    vec4 blue_fog = vec4(0.5, 0.6, 0.7, 1.0);\n    vec4 yellow_fog = vec4(1.0, 0.9, 0.7, 1.0);\n    \n    float sun_amount = max(dot(ray, -sun_dir), 0.0);\n    return mix(blue_fog, yellow_fog, pow(sun_amount, 8.0));\t\n}\n\n/* Non-constant fog density (varying with height) */\nfloat get_fog_amount(vec3 eye, vec3 ray, float t)\n{\n    float a = 0.09;\n    float b = 1.0;\n\treturn a * exp(-b * eye.y) * (1.0 - exp(-b * ray.y * t)) / (b * ray.y);\n}\n\n/* Constant fog density */\nfloat get_fog_amount_const(float t)\n{\n    float b = 0.05;\n\treturn 1.0 - exp(-b * t);\n}\n\n/* Get lighting for pixel */\nvec4 get_lighting(vec3 eye, vec3 ray, float t)\n{\n    vec3 sun_dir = normalize(vec3(1.0, -0.3, -1.0));\n    vec4 terrain_color = get_terrain_color(eye, ray, t, sun_dir);\n    vec4 fog_color = get_fog_color(ray, sun_dir);\n    \n    return mix(terrain_color, fog_color, get_fog_amount(eye, ray, t));\n}\n\n/* Inverse of the view matrix */\nmat4 inverse_view_matrix(vec3 look, vec3 up, vec3 pos)\n{\n\tvec3 w = -normalize(look);\n    vec3 v = normalize(up - w * dot(up, w));\n    vec3 u = cross(v, w);\n    return mat4(\n    \tu.x, v.x, w.x, 0.0,\n        u.y, v.y, w.y, 0.0,\n       \tu.z, v.z, w.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n/* Inverse projection matrix */\nmat4 inverse_projection_matrix(float width_angle, float height_angle, float far)\n{\n    return mat4(\n    \tfar * tan(width_angle / 2.0), 0.0, 0.0, 0.0,\n        0.0, far * tan(height_angle / 2.0), 0.0, 0.0,\n        0.0, 0.0, far, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /* Set up camera */\n \tvec3 look = normalize(vec3(0.0, 0.01, -1.0));\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 worldCameraPos = vec3(0.0, 3.0, 0.0);\n\n    /* Get point on film plane */\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 normalizedFilmPoint = vec3(2.0 * uv.x - 1.0, uv.y * 2.0 - 1.0, -1.0);\n    normalizedFilmPoint.x *= iResolution.x / iResolution.y;\n\n    /* Transform to world space */\n    mat4 ivm = inverse_view_matrix(look, up, worldCameraPos);\n    mat4 ipm = inverse_projection_matrix(PI / 4.0, PI / 4.0, FAR_PLANE);\n    vec3 filmPoint = vec3(ivm * ipm * vec4(normalizedFilmPoint, 1.0));\n    \n    /* Get ray */\n    vec3 eye = vec3(worldCameraPos.xy, -iTime);\n    vec3 ray = normalize(filmPoint - worldCameraPos);\n    \n    /* Ray march */\n    float t = castRay(eye, ray);\n    \n    /* Lighting */\n    if(t > 0.0)\n    {\n    \tfragColor = get_lighting(eye, ray, t);\n    }\n    else\n    {\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1173, 1210, 1240, 1240, 1318], [1320, 1349, 1370, 1370, 1423], [1425, 1470, 1520, 1570, 1855], [1857, 1912, 1959, 1959, 2256], [2258, 2286, 2329, 2353, 3256], [3258, 3326, 3433, 3433, 3818], [3820, 3850, 3873, 3873, 3931], [3933, 3964, 3986, 3986, 4037], [4039, 4084, 4119, 4119, 4630], [4633, 4691, 4734, 4734, 5200], [5202, 5226, 5293, 5293, 6225], [6227, 6247, 6291, 6291, 6506], [6508, 6561, 6612, 6612, 6726], [6728, 6755, 6792, 6792, 6841], [6843, 6872, 6920, 6920, 7167], [7169, 7202, 7258, 7258, 7491], [7493, 7525, 7607, 7607, 7792], [7794, 7794, 7851, 7875, 8809]], "test": "error"}
{"id": "MdtGRn", "name": "Carbon", "author": "sixstring982", "description": "Carbon atom, first attempt at raymarching", "tags": ["raymarching", "spheres", "atom"], "likes": 4, "viewed": 208, "published": "Public", "date": "1447824980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAY_DIST 60.0\n#define CAMERA_DIST 4.0\n#define AUTOSPIN_SPEED 0.5\n#define MOUSE_SENSITIVITY 0.01\n#define EPSILON 0.0001\n#define BG_COLOR vec3(0.2, 0.2, 0.2)\n#define SPEC_POW 8.0\n\n#define PI 3.14159\n#define TAU 6.28318\n\nfloat box(in vec3 pos, in vec3 b) {  \n  vec3 d = abs(pos) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sphere(in vec3 pos, in float radius) {\n    return length(pos) - radius;\n}\n\nfloat opU(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2) {\n    return max(d1, -d2);\n}\n\nfloat opI(in float d1, in float d2) {\n    return max(d1, d2);\n}\n\nfloat map(in vec3 pos) {\n    const float SPHERE_COUNT = 6.0;\n    float m2 = 1e20;\n    \n    for (float i = 0.0; i < SPHERE_COUNT; i++) {\n        float dy = sin(i * (TAU / SPHERE_COUNT));\n        float dz = cos(i * (TAU / SPHERE_COUNT));\n        m2 = opU(m2, sphere(pos + vec3(0.25, 0.25 * dy, 0.25 * dz), 0.25));\n        m2 = opU(m2, sphere(pos + vec3(0.0, 0.25 * dz, 0.25 * dy), 0.25));\n    }\n    \n    for (float i = 0.0; i < SPHERE_COUNT; i++) {\n        float theta = mod(iTime * 2.0 + i * 2.0, TAU);\n        float phi = (TAU / SPHERE_COUNT) * (i * 0.75);\n        float r = 2.0;\n        \n        m2 = opU(m2, sphere(pos + vec3(r * sin(theta) * sin(phi),\n                                       r * sin(theta) * cos(phi),\n                                       r * cos(theta)), 0.2));\n    }\n    \n    return m2;\n}\n\nvec3 colorMap(in vec3 pos) {\n    if (length(pos) < 1.0) {\n        float gb = mix(0.0, 0.75, pos.x * 3.0 + 0.75);\n        return vec3(0.75, gb, gb);\n        \n    } else {\n    \treturn vec3(length(pos) * 0.15,\n\t                length(pos) * 0.2,\n\t                length(pos) * 0.2);\n    }\n}\n\nvec3 normalAt(in vec3 ro) {\n    vec2 ep = vec2(EPSILON, 0.0);\n    return normalize(vec3(map(ro + ep.xyy) - map(ro - ep.xyy),\n                          map(ro + ep.yxy) - map(ro - ep.yxy),\n                          map(ro + ep.yyx) - map(ro - ep.yyx)));\n}\n\nvec3 lighting(in vec3 ro, in vec3 rd) {\n    vec3 n = normalAt(ro);\n    float diffuse = max(0.0, dot(-rd, n));\n    float specular = pow(diffuse, SPEC_POW);\n    vec3 color = colorMap(ro);\n    return color * (diffuse + specular);\n}\n\nvec3 marchRay(in vec3 ro, in vec3 rd) {\n    const int MAX_ITERS = 100;\n    float dist = EPSILON;\n    float totalDist = 0.0;\n    \n    for (int i = 0; i < MAX_ITERS; i++) {\n        if (abs(dist) < EPSILON || totalDist > MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = map(ro);\n        ro += rd * dist;\n        totalDist += dist;\n    }\n    \n    if (abs(dist) < EPSILON) {\n        return lighting(ro, rd);\n    } else {\n        return BG_COLOR;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ((fragCoord / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cop = vec3(-CAMERA_DIST * sin(iMouse.x * MOUSE_SENSITIVITY + iTime * AUTOSPIN_SPEED), \n                    CAMERA_DIST * cos(iMouse.y * MOUSE_SENSITIVITY), \n                    CAMERA_DIST * cos(iMouse.x * MOUSE_SENSITIVITY + iTime * AUTOSPIN_SPEED));\n    vec3 target = vec3(0, 0, 0);\n    vec3 up = normalize(vec3(cos(iTime + 1.0), \n                   \t\t\t sin(iTime), \n                             sin(iTime - 1.0)));\n    \n    vec3 cDir = normalize(target - cop);\n    vec3 cRight = normalize(cross(up, cop));\n    vec3 cUp = normalize(cross(cRight, cDir));\n    \n    vec3 rayDir = uv.x * cRight + uv.y * cUp + cDir;\n    \n\tfragColor = vec4(marchRay(cop, rayDir), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 265, 265, 365], [367, 367, 411, 411, 446], [448, 448, 485, 485, 511], [513, 513, 550, 550, 577], [579, 579, 616, 616, 642], [644, 644, 668, 668, 1455], [1457, 1457, 1485, 1485, 1744], [1746, 1746, 1773, 1773, 2000], [2002, 2002, 2041, 2041, 2230], [2232, 2232, 2271, 2271, 2700], [2702, 2702, 2759, 2759, 3548]], "test": "ok"}
{"id": "MdtGz4", "name": "Sphield", "author": "haptix", "description": "fuggin around", "tags": ["raymarching"], "likes": 3, "viewed": 312, "published": "Public API", "date": "1448441008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float glow = 0.;  //GLOW baby\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nvec3 twist(vec3 pos)\n{\n    float c = cos(0.33 * pos.y + iTime*1.2);\n    float s = sin(0.33 * pos.y + iTime*1.2);\n    mat2  m = mat2(c, -s, s, c);\n    return vec3(m * pos.xz, pos.y);\n}\n\nvec3 repeat(vec3 pos, float spacing)\n{\n\treturn mod(pos, spacing) - 0.5 * spacing;\n}\n\nfloat unionSDF(float distA, float distB)\n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB)\n{\n    return max(distA, -distB);\n}\n\nfloat hollowBox(vec3 pos, float radius)\n{\n    return differenceSDF(box(pos, vec3(radius)), sphere(pos, radius*1.3));\n}\n\nfloat distfunc(vec3 pos, float radius)\n{\n    float hollowB = hollowBox(twist(repeat(pos, 10.0)), radius);\n    float sphereB = sphere(repeat(pos, 10.0), radius*0.75);\n    float shape = unionSDF(hollowB, sphereB);\n    glow += 0.1 / (0.1 + hollowB*hollowB);\n    return shape;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cameraOrigin = vec3(0.0, 0.0, fract(iTime) * 10.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(sin(iTime * 0.2), cos(iTime * 0.2), 0.0);\n    vec3 cameraDir = normalize(cameraOrigin - cameraTarget);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const int MAX_ITER = 128;\n    const float MAX_DIST = 275.0;\n    const float EPSILON = 0.001;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n\n    float radius = 1.4;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distfunc(pos, radius);\n        totalDist += dist;\n        pos += dist * rayDir * 0.4;\n    }\n    \n    if (dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx, radius) - distfunc(pos - eps.yxx, radius),\n            distfunc(pos + eps.xyx, radius) - distfunc(pos - eps.xyx, radius),\n            distfunc(pos + eps.xxy, radius) - distfunc(pos - eps.xxy, radius)));\n\n        float diffuse = max(0.0, dot(-rayDir, normal));\n        float specular = pow(diffuse, 32.0);\n        vec3 color = vec3(.2*sin(iTime*0.2) + 0.45,\n                          .2*cos(iTime*0.3) + 0.45,\n                          .2*sin(iTime*0.5) + 0.45) * (diffuse + specular) / (1. + totalDist * 0.05);\n\n        fragColor = vec4(color + glow*.01, 1.0);\n    }\n    else\n        fragColor = vec4(0.) + glow*.02;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 69, 69, 104], [106, 106, 138, 138, 186], [188, 188, 210, 210, 371], [373, 373, 411, 411, 456], [458, 458, 500, 500, 532], [534, 534, 581, 581, 614], [616, 616, 657, 657, 734], [736, 736, 776, 776, 1010], [1012, 1012, 1069, 1069, 2846]], "test": "ok"}
{"id": "Ml2XDK", "name": "SphereNoise", "author": "jt", "description": "Iterated spheres in voronoi-cells placed on a grid with random offsets ([url]https://www.shadertoy.com/view/Ml2XWK[/url])", "tags": ["voronoi", "noise", "grid", "random"], "likes": 13, "viewed": 274, "published": "Public", "date": "1446656700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SphereNoise (superposition of spheres in displaced-grid voronoi-cells) by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// iq's hash function from https://www.shadertoy.com/view/MslGD8\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nfloat simplegridnoise(vec2 v)\n{\n    // NOTE: Setting s = 0.01 causes horizontal-lines-artifact with texture-lookup.\n    //       Use s = 1.0 / 256.0 (thanks iq) or switch filtering to linear (thanks tomkh).\n    //float s = 0.01;\n    float s = 1.0 / 256.0;\n    vec2 fl = floor(v);\n    vec2 fr = fract(v);\n    float mindist = 1000.0;\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offset = vec2(x, y);\n    \t\t//vec4 r = texture(iChannel0, (fl + offset) * s + iTime * 0.001);\n            //vec2 pos = r.xy;\n            //vec4 r = texture(iChannel0, (fl + offset) * s);\n            //float phi = 3.1415926 * 2.0 * (iTime * 0.1 + r.z);\n            float phi = 3.1415926 * 2.0 * (iTime * 0.1 + hash(fl + offset).x);\n            vec2 pos = 0.5 + 0.5 * vec2(cos(phi), sin(phi));\n            float d = length(fr - (pos + offset));\n            mindist = min(mindist, d);\n        }\n    }\n    \n    return mindist;\n}\n\nfloat spherenoise(vec2 v)\n{\n    return (1.0 - pow(simplegridnoise(v) / sqrt(2.0), 2.0));\n}\n\nvec3 spherenoisenrm(vec2 v)\n{\n    float d = 0.01;\n    return normalize(\n           vec3(spherenoise(v + vec2(  d, 0.0)) - spherenoise(v + vec2( -d, 0.0)),\n                spherenoise(v + vec2(0.0,   d)) - spherenoise(v + vec2(0.0,  -d)),\n                d));\n}\n\nfloat fractalspherenoise(vec2 v)\n{\n    float val = 0.0;\n    const float n = 4.0;\n    for(float i = 0.0; i < n; i++)\n    {\n    \tval += pow(0.5, i + 1.0) * spherenoise(pow(2.0, i) * v);\n    }\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float val = pow(fractalspherenoise(uv * 10.0), 5.0);\n    fragColor = vec4(vec3(val), 1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2XDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[179, 244, 265, 265, 356], [358, 358, 389, 586, 1328], [1330, 1330, 1357, 1357, 1420], [1422, 1422, 1451, 1451, 1682], [1684, 1684, 1718, 1718, 1891], [1893, 1893, 1950, 1950, 2089]], "test": "ok"}
{"id": "Ml2XWd", "name": "Paris, debout", "author": "Nrx", "description": ":(", "tags": ["paris"], "likes": 18, "viewed": 476, "published": "Public API", "date": "1447490647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = vec2 (1.3, 0.8) * (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfloat d1 = abs (length (uv - vec2 (0.0, -1.0)) - 0.55);\n\tfloat d2 = abs (length (uv - vec2 (-1.95, 0.8)) - 1.95);\n\tfloat d3 = max (abs (length (uv - vec2 (1.95, 0.8)) - 1.95), 0.075 - uv.x);\n\tfloat d = max (min (d1, min (d2, d3)), abs (uv.y) - 0.65);\n\tvec3 color = mix ((d1 < d2 && d1 < d3) ? vec3 (0.9) : d2 < d3 ? vec3 (0.4, 0.4, 1.0) : vec3 (1.0, 0.4, 0.4), vec3 (0.2 * (uv.y + 0.5) * (0.7 + 0.3 * cos (iTime))), smoothstep (0.02 - 0.01 * uv.y, 0.04, d));\n\tfragColor = vec4 (color * smoothstep (1.2, 0.0, abs (uv.x)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2XWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 670]], "test": "ok"}
{"id": "Ml2XWK", "name": "GridNoise", "author": "jt", "description": "Voronoi-cells placed on a grid with random offsets\n (for a variant placing spheres inside cells see [url]https://www.shadertoy.com/view/Ml2XDK[/url]).", "tags": ["voronoi", "grid", "random"], "likes": 8, "viewed": 283, "published": "Public", "date": "1446649194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// GridNoise (randomly assigned colors to displaced-grid voronoi-cells) by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// iq's hash function from https://www.shadertoy.com/view/MslGD8\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nfloat simplegridnoise(vec2 v)\n{\n    //float s = 0.01; // NOTE: this setting causes the horizontal-line-artifacts (thanks, iq!)\n    float s = 1.0 / 256.0;\n    vec2 fl = floor(v);\n    vec2 fr = fract(v);\n    float mindist = 1000.0;\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offset = vec2(x, y);\n    \t\t//vec4 r = texture(iChannel0, (fl + offset) * s + iTime * 0.001);\n            //vec2 pos = r.xy;\n            //vec4 r = texture(iChannel0, (fl + offset) * s);\n            //float phi = 3.1415926 * 2.0 * (iTime * 0.1 + r.z);\n            float phi = 3.1415926 * 2.0 * (iTime * 0.1 + hash(fl + offset).x);\n            vec2 pos = 0.5 + 0.5 * vec2(cos(phi), sin(phi));\n            float d = length(fr - (pos + offset));\n            mindist = min(mindist, d);\n        }\n    }\n    \n    return mindist;\n}\n\nvec3 gridnoise(vec2 v)\n{\n    //float s = 0.01; // NOTE: this setting causes the horizontal-line-artifacts (thanks, iq!)\n    float s = 1.0 / 256.0;\n    vec2 fl = floor(v);\n    vec2 fr = fract(v);\n    vec2 nearest = vec2(0.0, 0.0);\n    float mindist = 1.0;\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offset = vec2(x, y);\n    \t\t//vec4 r = texture(iChannel0, (fl + offset) * s + iTime * 0.001);\n            //vec2 pos = r.xy;\n            //vec4 r = texture(iChannel0, (fl + offset) * s);\n            //float phi = 3.1415926 * 2.0 * (iTime * 0.1 + r.z);\n            float phi = 3.1415926 * 2.0 * (iTime * 0.1 + hash(fl + offset).x);\n            vec2 pos = 0.5 + 0.5 * vec2(cos(phi), sin(phi));\n            float d = length(fr - (pos + offset));\n            if(d < mindist)\n            {\n                mindist = d;\n                nearest = offset;\n            }\n        }\n    }\n    \n    return vec3(fl + nearest, mindist);\n}\n\nvec4 gridNoise(vec2 v)\n{\n    return texture(iChannel1, gridnoise(v).xy * 0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\t//fragColor = vec4(vec3(simplegridnoise(uv * 10.0)), 1.0);\n    //fragColor = vec4(vec3(fract(gridnoise(uv * 10.0) / 2.0).xy * 2.0, 0.0), 1.0);\n    //fragColor = vec4(fract(gridnoise(uv * 10.0) / 2.0) * 2.0, 1.0);\n    //fragColor = gridNoise(uv * 10.0);\n    fragColor = mix(vec4(simplegridnoise(uv * 10.0)), gridNoise(uv * 10.0), vec4(0.5 + 0.5 * cos(3.1415926 * 2.0 * iTime * 0.2)));\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2XWK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[177, 242, 263, 263, 354], [356, 356, 387, 482, 1224], [1226, 1226, 1250, 1345, 2219], [2221, 2221, 2245, 2245, 2302], [2304, 2304, 2361, 2361, 2833]], "test": "error"}
{"id": "MlBSD3", "name": "2d experiment #9 - pii", "author": "public_int_i", "description": "lsdjlfjsdl", "tags": ["ksdjflj"], "likes": 5, "viewed": 468, "published": "Public API", "date": "1446904768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//#define VISUALIZE_UV\n//#define VISUALIZE_CIRCLE_DF\n//#define VISUALIZE_COOL\n\n#define SAMPLES 5\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv *= 3.;//4.5+sin(iTime*.25)*2.;\n    vec2 ruv = uv;\n    \n    fragColor = vec4(0.);\n    \n    for (int b = 0; b < SAMPLES; b++) {\n    \n        uv = ruv+(cos(uv*.7521+float(b)*.42)+cos(uv.yx*.2234+float(b)*2.42))*.3;\n        \n        for (int i = 0; i < 14; i++) {\n            vec2 dir = -normalize(abs(mod(uv,.5)-.25));\n            uv = uv.yx + dir * .2 * sin(atan(uv.y,uv.x)+ (cos(iTime*.14)+4.) );\n            uv = abs(uv);\n        }\n\n       // #ifdef VISUALIZE_UV\n       // fragColor += vec4(cos(normalize(abs(uv))*12.)*.5+.5,0.,1.0);\n       // #endif\n\n      //  #ifdef VISUALIZE_CIRCLE_DF\n      //  float dist = (length(uv)-.5) + iTime*.03;\n      /*  fragColor += vec4(sin(dist*3.5+.46),\n                         cos(dist*4.6),\n                         -sin(dist*8.6), 1.)*.5+.5;\n     //   #endif\n*/\n       // #ifdef VISUALIZE_COOL\n        fragColor += vec4(cos(uv*10.)*.5+.5\n                        ,cos(length(uv)*4.)*.5+.5,1.);\n       // #endif\n        \n    }\n    \n    fragColor /= float(SAMPLES);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 157, 157, 1214]], "test": "ok"}
{"id": "MlBSDd", "name": "gradient_shader_Test", "author": "shanemarks", "description": "gradient shader test", "tags": ["gradient"], "likes": 1, "viewed": 118, "published": "Public", "date": "1447326431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float whiteStreak(vec2 p1, vec2 p2, vec2 point) {\n    float radius =0.2;\n    float AA = 0.1;\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    float distance =  abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n    return smoothstep (radius/2.,radius/2.-AA,distance);\n\n}\n\nfloat buildColorRegion(vec2 p1, vec2 p2, vec2 point) {\n    float radius =0.0;\n    float AA = 0.0;\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n   float  distance = -(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n    return smoothstep (radius/2.,radius/2.-AA,distance);\n\n}\n\nfloat darkeningGradient (float falloff, in vec2 uv)\n{\n    return pow(uv.y,falloff);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //constants we need\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 brownColor = vec4(162.0/255.0,143.0/255.0,100.0/255.0,1.0);\n    vec4 orangeColor = vec4(1.0,154.0/255.0,4.0/255.0,1);\n    vec2 whiteStreakStart = vec2(-1.0,1.0);\n    vec2 whiteStreakEnd = vec2(0.0,-0.0);\n    \n    \n\n    float offset = iMouse.y/iResolution.y;\n    \n    if (iMouse.y == 0.0){\n        offset = abs(sin(iTime/10.0));\n    }\n       \n    \n    float colorRegion =  buildColorRegion(whiteStreakStart+offset,whiteStreakEnd+offset,uv);\n\tvec4 basecolor = mix (brownColor,orangeColor,colorRegion);\n    \n    float streak = whiteStreak (whiteStreakStart+offset,whiteStreakEnd+offset,uv);\n    float gradient = mix(1.0, darkeningGradient(0.2,uv),1.0);\n     \n   // fragColor = vec4(buildColorRegion (whiteStreakStart+offset,whiteStreakEnd+offset,uv));\n    \n\tfragColor =mix (basecolor*gradient,vec4(1),streak) ;\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 286], [288, 288, 342, 342, 576], [578, 578, 631, 631, 663], [667, 667, 724, 748, 1609]], "test": "ok"}
{"id": "MlBSWt", "name": "LineSegments", "author": "jt", "description": "Bouncing line segments (re-creating the classic screensaver as shader).", "tags": ["linesegments"], "likes": 8, "viewed": 221, "published": "Public", "date": "1447263326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Line Segments (bouncing) \"screensaver\" written 2015 by Jakob Thomsen\n\n// mirror/bounce inside -1,+1\nvec2 mirror(vec2 pos)\n{\n    return (2.0 * abs(2.0 * fract(pos) - 1.0) - 1.0);\n}\n\nfloat PointLineAlong2d(vec2 a, vec2 n, vec2 p)\n{\n    return dot(p - a, n) / dot(n, n);\n}\n\nfloat PointLineDist2d(vec2 a, vec2 n, vec2 p)\n{\n    //return length(p - (a + n * dot(p - a, n) / dot(n, n)));\n    return length(p - (a + n * PointLineAlong2d(a, n, p)));\n}\n\nfloat PointLineSegDist2d(vec2 a, vec2 n, vec2 p)\n{\n    float q = PointLineAlong2d(a, n, p);\n    return length(p - (a + n * clamp(q, 0., 1.)));\n}\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    vec2 speed0 = vec2(0.0432, 0.0123);\n    vec2 speed1 = vec2(0.0257, 0.0332);\n    I = 2. * I / iResolution.xy - 1.;\n    o -= o;\n    const float n = 20.0;\n    for(float i = 0.0; i < n; i++)\n    {\n    \tvec2 a = mirror((iTime - i * .2) * speed0);\n    \tvec2 b = mirror((iTime - i * .2) * speed1);\n    \tfloat d = PointLineSegDist2d(a, b - a, I);\n\t\to = max(o, vec4(1.0 - smoothstep(0.0, 0.01, d))); // lines\n        //o = max(o, vec4(pow(1.0 - d, 17.0))); // glow\n        //o = mix(max(o, vec4(1.0 - smoothstep(0.0, 0.01, d))), max(o, vec4(pow(1.0 - d, 17.0))), 0.5 + 0.5 * sin(iTime)); // blinking\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 103, 126, 126, 182], [184, 184, 232, 232, 272], [274, 274, 321, 383, 445], [447, 447, 497, 497, 591], [593, 593, 634, 634, 1237]], "test": "ok"}
{"id": "MljGzK", "name": "OSCILOSCOPER2", "author": "Branch", "description": "OSCILOSCOPER2", "tags": ["osciloscoper2"], "likes": 10, "viewed": 232, "published": "Public", "date": "1446757184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return -min(max(100.0*(length( pa - ba*h ) - r),-1.),0.);\n}\n\nfloat circle(vec2 coord, vec2 pos, float size){\n    return -min(floor(distance(coord,pos)-size),0.);\n}\n\n\nmat2 rotate(float Angle){\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat vasenKulmakarva=floor(mod(iTime*0.8,2.0))*0.1;\n\tfloat oikeaKulmakarva=floor(mod(iTime*0.3,2.0))*0.1;\n\tfloat vasenSilma=min(max(0.24*sin(iTime),0.006),0.06);\n\tfloat oikeaSilma=min(max(0.24*sin(iTime),0.006),0.06);\n\tfloat suu=iTime*10.0;\n\tvec4 tulos;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n    \n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 nc=coord;\n\ttulos=vec4(vec3(0.0/255.0, 23.0/255.0, 12.0/255.0),1.0);\n    coord *= rotate(iTime/8.+length(coord)*1.);\n    coord *= 1.1;\n    coord.y += sin(coord.x*3.+iTime+sin(iTime/8.)*3.)/32.;\n    coord.x += iTime;\n    for(float i=0.0; i<64.0; i++) {\n    \tcoord.y += cos(i+iTime)/32. + sin(sin(coord.x+i*sin(iTime)/32.)*3.+coord.x*1.3+iTime+i+sin(i+iTime)/(8.+sin(iTime)*2.))/3.;\n    \ttulos.rgb += sdCapsule(coord,vec2( 888.0, 0.0),vec2(-888.0,0.0),0.02+sin(iTime+i)/666.0);\n    \t\n    }\n    \n\ttulos.xyz+=floor(mod(nc.y*1000.0,32.0)/32.0 + 2./32.0) / 12.0;\n\ttulos.xyz+=floor(mod(nc.x*1000.0,32.0)/32.0 + 2./32.0) / 12.0;\n    tulos.rgb-=rand(coord*iTime)/12.0;\n\ttulos.xyz=tulos.xyz/1.3 * mod(fragCoord.y,2.0);\n    tulos.rgb*=vec3(0.0,1.0,0.4);\n\tfragColor = tulos;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 93], [94, 94, 145, 145, 298], [300, 300, 347, 347, 402], [405, 405, 430, 430, 562], [563, 563, 620, 620, 1863]], "test": "ok"}
{"id": "MlSSD3", "name": "04", "author": "yiwenl", "description": "04", "tags": ["raymarching"], "likes": 2, "viewed": 804, "published": "Public API", "date": "1446823990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\tTOOLS\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\n//\tGEOMETRY\nfloat sphere(vec3 pos, float radius) {\treturn length(pos) - radius;\t}\nfloat displacement(vec3 p) {\treturn sin(2.0*p.x+iTime*.983265)*sin(2.0*p.y+iTime*.57834)*sin(1.0*p.z+iTime*0.857834) * .5 + .5;\t}\n\nfloat map(vec3 pos) {\n\tpos.xz = rotate(pos.xz, iTime+pos.y*2.0 + pos.x*.5);\n\n\tfloat sphereSize = 2.5;\n\tfloat d1 = sphere(pos, sphereSize);\n\tfloat d2 = displacement(pos)*.1;\n\tfloat d3 = sphere(pos+vec3(.15, 0.0, 0.0), sphereSize);\n\n\treturn max(d3, -(d1+d2));\n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.01, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n\t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n\t\tmap(pos + eps.yyx) - map(pos - eps.yyx)\n\t);\n\treturn normalize(normal);\n}\n\n\n//\tLIGHTING\n\nfloat diffuse(vec3 normal, vec3 lightDirection) {\n\treturn max(dot(normal, normalize(lightDirection)), 0.0);\n}\n\nvec3 diffuse(vec3 normal, vec3 lightDirection, vec3 lightColor) {\n\treturn lightColor * diffuse(normal, lightDirection);\n}\n\nfloat specular(vec3 normal, vec3 dir) {\n\tvec3 h = normalize(normal - dir);\n\treturn pow(max(dot(h, normal), 0.0), 40.0);\n}\n\n\nconst vec3 lightPos0 = vec3(1.0, .75, -1.0);\nconst vec3 lightColor0 = vec3(1.0, 1.0, .96);\nconst float lightWeight0 = 0.75;\n\nconst vec3 lightPos1 = vec3(-1.0, -0.75, 0.0);\nconst vec3 lightColor1 = vec3(.96, .96, 1.0);\nconst float lightWeight1 = 0.0;\n\n\nvec4 getColor(vec3 pos, vec3 dir, vec3 normal) {\n\tfloat ambient = .2;\n\tvec3 diff0 = diffuse(normal, lightPos0, lightColor0) * lightWeight0;\n\tvec3 diff1 = diffuse(normal, lightPos1, lightColor1) * lightWeight1;\n\n\tfloat spec = specular(normal, dir) * .25;\n\tvec3 color = vec3(ambient) + diff0 + diff1 + spec;\n\n\tif(pos.z > 0.0) {\n\t\tcolor *= vec3(.25);\n\t}\n\n\treturn vec4(color, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focus = 2.25;\n    vec3 pos = vec3(0.0, 0.0, -10.0);\n    vec3 dir = normalize(vec3(uv, focus));\n    float prec = 0.001;\n    vec4 color = vec4(.1, .1, .1, 1.0);\n    float d;\n    \n    const int NUM_ITER = 64;\n    const float maxDist = 4.0;\n    for(int i=0; i<NUM_ITER; i++) {\n\t\td = map(pos);\t\t\t\t\t\t//\tdistance to object\n\n\t\tif(d < prec) {\t\t\t\t\t\t// \tif get's really close, set as hit the object\n\t\t\tcolor       = vec4(1.0);\n\t\t\tvec3 normal = computeNormal(pos);\n\t\t\tcolor       = getColor(pos, dir, normal);\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += d * dir;\t\t\t\t\t\t//\tmove forward by\n\t\tif(length(pos) > maxDist) break;\n\t}\n\t\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 10, 46, 46, 128], [130, 142, 180, 180, 211], [212, 212, 240, 240, 341], [343, 343, 364, 364, 602], [604, 604, 634, 634, 846], [862, 862, 911, 911, 971], [973, 973, 1038, 1038, 1094], [1096, 1096, 1135, 1135, 1217], [1472, 1472, 1520, 1520, 1851], [1854, 1854, 1911, 1911, 2657]], "test": "ok"}
{"id": "MlSSDV", "name": "plop 2", "author": "FabriceNeyret2", "description": "fantomas wana be a chicken ( see his shader https://www.shadertoy.com/view/ltSSDV )\n\nNB: better seen in full size.", "tags": ["2d", "2tweets", "short"], "likes": 6, "viewed": 1103, "published": "Public API", "date": "1446496738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simplified from https://www.shadertoy.com/view/ltSSDV\n\nvoid mainImage( out vec4 O,  vec2 U ) {\n    float t = iTime/10.;\n    U = 8.* U / iResolution.xy - 4.;\n    O -= O;\n    \n    for (int i=0; i<8; i++)\n    \tU += cos( U.yx *3. + vec2(t,1.6)) / 3.,\n        U += sin( U.yx + t + vec2(1.6,0)) / 2.,\n        U *= 1.3;\n    \n\t//o += length(mod(U,2.)-1.);  // black & white\n\tO.xy += abs(mod(U,2.)-1.); // color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 97, 97, 407]], "test": "ok"}
{"id": "MlSSW3", "name": "julia dojo 2", "author": "pmilian", "description": "julia fractal", "tags": ["fractal"], "likes": 1, "viewed": 94, "published": "Public", "date": "1446811370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 pow2(vec2 z) {\n  //xÂ² - yÂ² + 2ixy\n  return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n}\n\nvec3 julia(vec2 c, vec2 z) {\n    int i = 0;\n    for (int j = 0; j < 100; j++) {\n     \tz = pow2(z) + c;\n        \n        if (length(z) > 2.0) {\n            i = j;\n            break;\n        }\n    }\n    \n    \n    if (i < 1) return vec3(1.0, 0.0, 0.0);\n    if (i <= 3) return vec3(0.2, 0.368, 0.536);\n    if (i <= 5) return vec3(0.4, .568, 0.836);\n    if (i <= 10) return vec3(0.6, .768, 0.936);\n    \n    if (i <= 15) return vec3(0.0, 0.4, 0.4);\n    if (i <= 20) return vec3(0.0, 0.6, 0.6);\n    if (i <= 25) return vec3(0.0, 0.8, 0.8);\n    if (i <= 30) return vec3(0.0, 1.0, 1.0);\n    if (i <= 35) return vec3(0.8, 0.8, 0.0);\n    if (i <= 50) return vec3(0.6, 0.6, 0.0);\n    if (i <= 70) return vec3(1., 0.8, 0.0);\n    if (i <= 85) return vec3(0.8, 0.0, 0.0);\n    \n    return vec3(0.6, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5);\n    \n    float zoom = 1.0;\n    \n    uv *= zoom;\n    \n    vec2 c = vec2(0.285 + cos(iTime * 0.5) * 0.005, -0.01);\n    //vec2 c = vec2(0.235, -0.01);\n\tfragColor = vec4(julia(c, uv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 44, 101], [103, 103, 131, 131, 898], [900, 900, 957, 957, 1254]], "test": "ok"}
{"id": "MlSXWd", "name": "hue shift tunnels", "author": "macbooktall", "description": "forked from cail's https://www.shadertoy.com/view/lt2SRt", "tags": ["tunnel", "hue"], "likes": 31, "viewed": 1510, "published": "Public API", "date": "1447302075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tweaked copy of https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdOcta( vec3 p, float h, float w ){\n    p.xz = abs(p.xz);\n    p.y = abs(p.y)-h;\n    return max(p.z,p.x)+(p.y*w);    \n}\n\nvec2 map( in vec3 pos )\n{\n    pos.x += sin(pos.z+25.0+iTime)*0.2;\n    pos.y += cos(pos.z+25.0+iTime)*0.2;\n    \n    float size = .33;\n    vec3 p = abs(mod(pos.xyz+size,size*2.)-size);\n    float box = sdBox( p, vec3(.3));\n    float cyl = sdCappedCylinder( p, vec2(.31, .32));\n     \n    vec2  res = vec2(opS(cyl, box) ,1.5); \n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 60.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n   vec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n   m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\nvec3 eps = vec3( 0.01, 0.0, 0.0 );\nvec3 nor = vec3(\n   map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n   map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n   map(pos+eps.yyx).x - map(pos-eps.yyx).x );\nreturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        float occ = calcAO( pos, nor );\n\t\tcol = hue(vec3(0.0,1.0,1.0),iTime+pos.z)*occ;\n    }\n\nreturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n \n\t// camera\n\tvec3 ro = vec3(0., 0.,iTime );\n\t\n    vec3 ta = ro+vec3( 0., 0.,1. );\n\t\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0. );\n\n    // ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy,1.5));\n\n    // render\n    vec3 col = render( ro, rd );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSXWd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[171, 171, 206, 206, 1155], [1157, 1157, 1188, 1188, 1284], [1286, 1286, 1328, 1328, 1427], [1429, 1429, 1462, 1462, 1488], [1490, 1490, 1531, 1531, 1614], [1616, 1616, 1641, 1641, 1961], [1963, 1963, 2003, 2003, 2551], [2553, 2553, 2585, 2585, 2796], [2798, 2798, 2840, 2840, 3137], [3142, 3142, 3181, 3181, 3592], [3594, 3594, 3646, 3646, 3819], [3821, 3821, 3878, 3878, 4329]], "test": "ok"}
{"id": "Ms33RM", "name": "Example of sprite manipulations", "author": "prozacgod", "description": "I'm still noobing it up a bit, but here's my take on creating sprites, we first map the uv to sprite location then map a uv coordinate system for that over a function to generate color data for that uv, scaled and combined in the output.", "tags": ["numbers", "sprites", "examples"], "likes": 0, "viewed": 241, "published": "Public", "date": "1448553673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float simpleBitmap(float data, float w, float h, vec2 bitCoord) {\n    // 0..1.0\n    float x = floor(bitCoord.x / (1.0 / w));\n    float y = floor(bitCoord.y / (1.0 / h));\n     \n    float i = y * w + x;\n    \n    float datum = float(data) / pow(2.0, i);\n\n    datum = mod(datum, 2.0);\n        \n    return floor(datum);\n}\n\nfloat digitBitmaps(const in int x) {\n\treturn x==0?961198.0:x==1?279620.0:x==2?953902.0:x==3?953998.0:x==4?700040.0:x==5?929422.0:x==6?929454.0:x==7?952456.0:x==8?962222.0:x==9?962184.0:0.0;\n}\n\n// resolves sprite texture data for entire uv space\nvec3 resolveSpriteUV(const in int x, vec2 uv) {\n    if (x < 10) {\n        return simpleBitmap(digitBitmaps(x), 4.0, 5.0, uv) == 1.0 ? vec3(1.0, 1.0, 1.0) : vec3(-1.0, -1.0, -1.0);\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 resolveScaledSprite(vec2 pos, vec2 size, vec2 uv, float rotz, int sprite) {\n    vec2 tl = pos - (size/2.0);\n    vec2 br = tl + size;\n    \n    vec2 uvr = uv - tl - (size/2.0);\n   \tuvr = vec2(\n        cos(rotz) * uvr.x - sin(rotz) * uvr.y,\n        sin(rotz) * uvr.x + cos(rotz) * uvr.y\n\t);\n    uvr += tl+size/2.0;\n    \n    // if this uv coordinate is within the sprites projected uv coordinates\n    if ((uvr.x >= tl.x) && (uvr.y >= tl.y) && (uvr.x < br.x) && (uvr.y < br.y)) {\n        vec2 sprite_uv = (uvr - tl) / size;\n        return resolveSpriteUV(sprite, sprite_uv);\n    }\n    return vec3(-1.0, -1.0, -1.0);\n}\n\nvec3 spriteMix(vec3 a, vec3 b) {\n    if (b.x == -1.0) {\n        return a;\n    }\n    return b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float t = iTime;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    int i = int(floor(mod(t, 10.0)));\n\n    //fragColor = vec4(simpleBitmap(digitBitmaps(i), 4.0, 5.0, uv), 0.0, 0.0, 0.0);\n    vec3 color = vec3(0.2, 0.2, 0.15);\n    \n    color = spriteMix(color, resolveScaledSprite(vec2(-0.5, 0), vec2(0.5, 0.5), uv, mod(t, 6.0), 0));\n    color = spriteMix(color, resolveScaledSprite(vec2(0.5, 0), vec2(0.5, 0.5), uv, mod(t, 6.0), 1));\n    \n    fragColor = vec4(color, 1.0);\n    \n    //fragColor = vec4(uv.x, 0.0, 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms33RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 65, 79, 316], [784, 784, 864, 864, 1401], [1403, 1403, 1435, 1435, 1498], [1500, 1500, 1556, 1556, 2151]], "test": "error"}
{"id": "Ms33zM", "name": "Harassment", "author": "twbmsp", "description": "Hello all ! This is my very first shader ! Not exactly what I wanted to do but I promoted some bugs as features to do something else. ;)", "tags": ["random"], "likes": 0, "viewed": 93, "published": "Public", "date": "1448569401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\nconst float TIME_STEP = 1.0;\n\nconst vec3 BLUE = vec3(0.0, 0.4, 1.0);\nconst vec3 PINK = vec3(1.0, 0.2, 0.6);\nconst vec3 BACK = vec3(0.1, 0.25, 0.1);\n\nfloat rand(const float timeShift, const float index)\n{\n    float f = floor((iTime + timeShift) / TIME_STEP);\n    vec2 v = vec2(mod(f + index, iResolution.y)  , mod(f - index, iResolution.x));\n    return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p0 = vec2(rand(0.0, 0.0), rand(0.0, 1.0));\n    vec2 p1 = vec2(rand(1.0, 0.0), rand(1.0, 1.0));\n    vec2 p2 = vec2(rand(2.0, 0.0), rand(2.0, 1.0));\n    \n    float t = 0.5 + 0.5 * sin(PI * (fract(iTime) - 0.5));\n    \n    vec2 p01 = (1.0 - t) * p0 + t * p1;\n    vec2 p12 = (1.0 - t) * p1 + t * p2;\n    \n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n\tfloat h = smoothstep(0.04, 0.025, length(p - p01));\n    float g = smoothstep(0.03, 0.015, length(p - p12));\n    \n    vec3 v = BLUE * h + PINK * g + BACK * (1.0 - clamp(h - g, 0.0, 1.0)) ;\n    \n    fragColor = vec4(v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms33zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 229, 229, 437], [439, 439, 496, 496, 1076]], "test": "ok"}
{"id": "Ms3GRN", "name": "Prime visualization", "author": "RenoM", "description": "prime numbers", "tags": ["prime"], "likes": 2, "viewed": 218, "published": "Public", "date": "1448321932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float lim=1000.;\nvec2 R=iResolution.xy;\nfloat zoom=3.;\n\n/*\n\tEach pixel represents a value placed like so :\n\t\n\t7\n\t4  8\n\t2  5  9\n\t1  3  6  10      etc...\n\t\n\tPrime values are represented by green pixels.\n\tSimilarly to Ulam spiral we can see that some diagonals contain much more primes than others.\n*/\n\nbool isPrime(float n)\n{\n    n=floor(n);\n    if(n==2.)return true;\n    if (n==1.||mod(n,2.)==.0)return false;\n    for(float i=3.;i<=6000.;i+=2.)\n    {\n        if(i*i>n)\n            break;\n        if(mod(n,i)==.0)\n            return false;\n    }\n    return true;\n}\n\n/*float isPrime( float x )\n{\n\tif( x==1.0 ) return 0.0;\n\tif( x==2.0 ) return 1.0;\n\tif( x==3.0 ) return 1.0;\n\tif( x==5.0 ) return 1.0;\n\tif( x==7.0 ) return 1.0;\n\t\n\tif( mod(x,2.0)==0.0 ) return 0.0;\n\tif( mod(x,3.0)==0.0 ) return 0.0;\n\tif( mod(x,5.0)==0.0 ) return 0.0;\n\n\tfloat y = 7.0;\n\tfor( int i=0; i<200; i++ ) // count up to 6000\n\t{\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 6.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 6.0; if( y>=x ) return 1.0;\n        \n        \n        \n        // speeds up, slows down, or crashes your compiler, \n        // depending on your GLSL implementation:\n        \n        //if( (y*y) > x ) break; \n\t}\n\t\n\treturn 1.0;\n}*/\n\nvoid mainImage(out vec4 C,in vec2 U)\n{\n    vec2 u=floor(U/zoom);\n\tfloat n=(u.x+u.y+1.)*(u.x+u.y+2.)/2.-u.y;\n    C=vec4(0,isPrime(n)&&n<500.*iTime,0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3GRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 329, 329, 568], [1668, 1668, 1706, 1706, 1821]], "test": "ok"}
{"id": "Ms3GRr", "name": "Sine Light", "author": "NylonGamer_", "description": "Just a test, trying to get comfortable with this stuff... Feedback appreciated!", "tags": ["testing"], "likes": 13, "viewed": 222, "published": "Public", "date": "1447678199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.1415926535;\n\nfloat getYA(float x) {\n    return 0.5*iResolution.y+sin((x/30.)+(20.*iTime))*(20.);\n}\n\nfloat getYB(float x) {\n    return 0.8*0.55*iResolution.y+sin((x/30.)+(10.*iTime))*(10.) + 0.2*getYA(x*3.-4.);\n}\n\nfloat getYC(float x) {\n    return 0.2*0.45*iResolution.y+sin((x/10.)+(40.*iTime))*(20.) + 0.8*getYB(x*1.1+9.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float distA = sqrt(abs(fragCoord.y - getYA(fragCoord.x)));\n    vec4 colA = vec4(1.-distA*0.15, 1.-distA*0.7, 1.-distA*0.7, 1.);\n    \n    colA = vec4(clamp(colA.x, 0.0, 1.0), clamp(colA.y, 0.0, 1.0), clamp(colA.z, 0.0, 1.0), clamp(colA.w, 0.0, 1.0));\n    \n    \n    float distB = sqrt(abs(fragCoord.y - getYB(fragCoord.x)));\n    vec4 colB = vec4(1.-distB*0.7, 1.-distB*0.16, 1.-distB*0.7, 1.);\n    \n    colB = vec4(clamp(colB.x, 0.0, 1.0), clamp(colB.y, 0.0, 1.0), clamp(colB.z, 0.0, 1.0), clamp(colB.w, 0.0, 1.0));\n    \n    \n    float distC = sqrt(abs(fragCoord.y - getYC(fragCoord.x)));\n    vec4 colC = vec4(1.-distC*0.7, 1.-distC*0.7, 1.-distC*0.162, 1.);\n    \n    colC = vec4(clamp(colC.x, 0.0, 1.0), clamp(colC.y, 0.0, 1.0), clamp(colC.z, 0.0, 1.0), clamp(colC.w, 0.0, 1.0));\n    \n    vec4 col = vec4(colA + colB + colC);\n    \n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3GRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 111], [113, 113, 135, 135, 224], [226, 226, 248, 248, 338], [340, 340, 397, 397, 1260]], "test": "ok"}
{"id": "Ms3Gz4", "name": "mandelbrot3", "author": "lovelyH", "description": "just another mandelbroot zooming in and out.", "tags": ["mandelbrot"], "likes": 2, "viewed": 129, "published": "Public", "date": "1448312061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float m(vec2 p0){\n    vec2 p=p0;\n    //vec2 h;\n    float r= 0.0;\n    for( float a=0.;a<256.;a++){\n        //h.x= p.x*p.x-p.y*p.y+p0.x;\n        //h.y= 2.0*p.x*p.y+p0.y;\n        //p= h;\n        p= vec2( p.x*p.x-p.y*p.y, 2.0*p.x*p.y ) + p0;\n        \n        //if( 8.0 < length(p) )\n        if( 64.0 < dot(p,p) )\n            break;\n        else\n        \t// r += 1.0;\n            r= a;\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pkt= vec2( -0.5901, 0.63029 );\n    float size= 4.0 / pow(2.0,8.0*(1.0+sin(iTime)));\n    \n\t//vec2 uv = fragCoord.xy / iResolution.xy - vec2( 0.5,0.5 );\n    vec2 uv = ( fragCoord.xy - iResolution.xy / 2.0 ) / iResolution.y;\n    \n    float r= m(pkt+ size*uv) / 128.0;\n    //fragColor = vec4(max(0.0,-1.0+r),max(0.0,-0.5+r),r,1.0);\n    fragColor = vec4(  -1.0+r,  -0.5+r,  r,   1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3Gz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 402], [404, 404, 461, 461, 852]], "test": "ok"}
{"id": "Msc3Rn", "name": "quasicrytals", "author": "charmless", "description": "As described at http://mainisusuallyafunction.blogspot.ca/2011/10/quasicrystals-as-sums-of-waves-in-plane.html", "tags": ["learning", "quasicrystals"], "likes": 8, "viewed": 911, "published": "Public API", "date": "1447653479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// try changing LAYERS - 3,5,7 are nice.\n// try changing the wrap function (wrap1, wrap2, wrap3) used at the end of quasicrystal()\n\n#define PI 3.14159265359\n#define LAYERS 7.\n\nfloat wave(float theta, vec2 p) {\n\treturn (cos(dot(p,vec2(cos(theta),sin(theta)))) + 1.) / 2.;\n}\n\n\n// triangular wrapping\nfloat wrap1(float val) {\n    float v_int = floor(val), \n          v_frac = fract(val);\n\n    bool even = fract(v_int / 2.) < 1e-4;\n\treturn even ? v_frac : 1. - v_frac;\n}\n\n// sawtooth wrapping\nfloat wrap2(float val) {\n    return fract(val);\n}\n\n// sinusoidal wrapping\nfloat wrap3(float val) {\n    return (1. + sin(val)) / 2.;\n}\n\n\nfloat quasicrystal(vec2 p) {\n    float sum = 0.;\n    for(float theta = 0.; theta < PI; theta += PI/LAYERS) \n        sum += wave(theta, p);\n\n    return wrap1(sum);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy/iResolution.y;\n    vec2 target = vec2(mix(-.3, .7, cos(iTime*.02)),\n                       mix(-.2, .4, sin(iTime*.012)));\n    uv -= vec2(target.x * ratio, target.y);\n    uv *= mix(128., 180., sin(iTime*.2));\n\n\n    fragColor = vec4(quasicrystal(uv));  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msc3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 209, 209, 272], [275, 298, 322, 322, 466], [468, 489, 513, 513, 538], [540, 563, 587, 587, 622], [625, 625, 653, 653, 789], [791, 791, 846, 846, 1169]], "test": "ok"}
{"id": "Msc3z8", "name": "Shadering Chameleon V2.0", "author": "iapafoto", "description": "Antialiasing only on edges - use 2 technics to find inner and outter edge pixels\nDecomment \"#define SHOW_EDGES\" to see where antialiasing is applied\n", "tags": ["cute", "mandelbrot", "spiral", "antialiasing", "checkerboard", "animation", "edge", "chameleon"], "likes": 107, "viewed": 5308, "published": "Public API", "date": "1448013358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by sebastien durand - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n// Change this to improve quality - Rq only applied on edge\n#define ANTIALIASING 5\n\n// decomment this to see where antialiasing is applied\n//#define SHOW_EDGES\n\n#define RAY_STEP 48\n//#define NOISE_SKIN\n\n#define PI 3.14159279\n\n\nbool WithChameleon;\t    // for optim : true if the ray intersect the bounding sphere of the chameleon\n\nfloat Anim;\t\t\t\t// pos in animation\nmat2 Rotanim, Rotanim2, Rot3; // rotation matrix\nfloat ca3, sa3;         // pre calculater sin and cos\nfloat closest;\t\t\t// min distance to chameleon on the ray (use for glow light) \n\n// ----------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n\n#ifdef NOISE_SKIN\n// By Shane -----\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    float ref = (tex3D(tex,  p , nor)).x;                 \n    vec3 grad = vec3( (tex3D(tex, vec3(p.x-eps, p.y, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y-eps, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y, p.z-eps), nor).x)-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n}\n\n#endif\n\n\n// ----------------------------------------------------\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n\treturn (d>0. && -sqrt(d)-b > 0.);\n}\n\n// ----------------------------------------------------\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  \treturn length(max(abs(p)-b,0.))-r;\n}\n\n// capsule with bump in the middle -> use for arms and legs\nvec2 sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    float dd = cos(3.14*h*2.5);  // Little adaptation\n    return vec2(length(pa - ba*h) - r*(1.-.1*dd+.4*h), 30.-15.*dd); \n}\n\nvec2 smin(in vec2 a, in vec2 b, in float k ) {\n\tfloat h = clamp( .5 + (b.x-a.x)/k, 0., 1. );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n\tfloat h = clamp( .5 + (b-a)/k, 0., 1. );\n\treturn mix(b, a, h) - k*h*(1.-h);\n}\n\nvec2 min2(in vec2 a, in vec2 b) {\n\treturn a.x<b.x?a:b;\n}\n\n// ----------------------------------------------------\n\nvec2 spiralTail(in vec3 p) {\n    float a = atan(p.y,p.x)+.2*Anim;\n\tfloat r = length(p.xy);\n    float lr = log(r);\n    float th = 0.475-.25*r; // thickness according to distance\n    float d = fract(.5*(a-lr*10.)/PI); //apply rotation and scaling.\n\t\n    d = (0.5-abs(d-0.5))*2.*PI*r/10.;\n  \td *= 1.1-1.1*lr;  // space fct of distance\n   \n    r+=.05*cos(a*60.); // radial bumps\n    r+=(.2-.2*(smoothstep(0.,.08, abs(p.z))));\n\n    return vec2(\n        max(max(sqrt(d*d+p.z*p.z)-th*r, length(p.xy-vec2(.185,-.14))-1.05), -length(p.xy-vec2(.4,1.5))+.77),\n        abs(30.*cos(10.*d)) + abs(20.*cos(a*10.)));\n}\n\nvec2 body(in vec3 p) {\n    const float scale = 3.1;\n    \n    p.y=-p.y;\n    p.x += 2.;\n    p/=scale;\n    \n    float a = atan(p.y,p.x);\n\tfloat r = length(p.xy);\n    float d = (.5*a-log(r))/PI; //apply rotation and scaling.\n    float th = .4*(1.-smoothstep(.0,1.,abs(a+.35-Anim*.05)));    \n \n    d = (1.-2.*abs(d-.5))*r*1.5;\n    \n   // r +=.005*cos(80.*d); // longitudinal bumps\n    r+=.01*cos(a*200.); // radial bumps\n    r-=.2*(smoothstep(0.,.1,abs(p.z)));\n    \n    float dis = sqrt(d*d+p.z*p.z)-th*r;\n \tdis *= scale;\n    dis = max(dis, length(p.xy-vec2(.86,-.07))-.7);\n    return vec2(dis, abs(30.*cos(17.*d)) + abs(20.*cos(a*20.)));\n}\n\nvec2 head(in vec3 p) {\n //   p.yz *= Rotanim;  // small rotation of head \n   \n   \n    p.z = abs(p.z);\n    \n    p.y += .25+.03*Anim;\n    p.x += .03+.03*Anim;\n    p.xy *= Rotanim;\n\n    vec3 pa1 = p, ba = vec3(1.,-.2,-.3);\n    pa1.z = p.z-.22;\n    \n    float h = clamp(dot(pa1, ba), 0.0, 1.0 );\n    pa1.x -= h;\n\n    // Head\n\tfloat dh = length(pa1) - .8*(-.5+1.3*sqrt(abs(cos(1.5701+h*1.5701))))+.08*(1.+h)*smoothstep(0.,.2,abs(p.z));\n    dh = max(-p.y-.2, dh); \n    dh += -.04+.04*(smoothstep(0.,.2,abs(p.z)));\n    dh = min(dh, max(p.x-1.35,max(p.y+.3, length(p-vec3(1.-.035*Anim,.25,-.1))-.85)));\n    dh += .01*cos(40.*h) -.06;\n    \n    // Eyes\n    vec3 eye = vec3(-.2,-.0105,.15);\n  \teye.zy *= Rotanim2;\n    float de = max(length(p-vec3(.7,.26,.45))-.3, -(length(p-vec3(.7,.26,.45) - eye)-.13*clamp(Anim+.2,.7,1.1)));\n    vec2 dee = min2(vec2(de,20.+1000.*abs(dot(p,eye))), vec2(length(p-vec3(.7,.26,.45))-.2, -102.));\n  \n    return smin(dee, vec2(dh*.8, 40.- abs(20.*cos(h*3.))) ,.06); \n}\n    \nvec2 support(vec3 p, vec2 c, float th) {\n    p-=vec3(-2.5,-.7,0);\n    float d1 = length(p-vec3(0,-6.5,0)) - 3.;          \n    float d = length(max(abs(p-vec3(0,-2,.75))-vec3(.5,2.5,.1),0.))-.11;     \n    p.xy *= Rot3; \n    d = min(d, max(length(max(abs(p)-vec3(4,3,.1),0.))-.1,\n                  -length(max(abs(p)-vec3(3.5,2.5,.5),0.))+.1));\n    return min2(vec2(d1,-105.),\n        min2(vec2(d,-100.), \n                 vec2(length(max(abs(p-vec3(0,0,.2))-vec3(3.4,2.4,.01),0.))-.3, -103.)));\n}\n\n\n//----------------------------------------------------------------------\n\nvec2 map(in vec3 pos) {\n    // Ground\n    vec2 res1 = vec2( pos.y+4.2, -101.0 );\n    // Screen\n\tres1 = min2(support(pos+vec3(2.5,-0.56,0), vec2(.1,15.), 0.05), res1);\n    \n    if (WithChameleon) {\n        // Tail + Body\n        vec2 res = smin(spiralTail(pos.xyz-vec3(0,-.05-.05*Anim,0)), body( pos.xyz-vec3(-.49,1.5,0)),.1 ); \n        // Head\n        res = smin(res, head(pos - vec3(-2.8,3.65,0)), .5);\n        pos.z = abs(pos.z);\n        // legs\n        res = min2(res, min2(sdCapsule(pos, vec3(.23,-.1*Anim+1.3,.65), vec3(.75,-.1*Anim+.6,.05),.16),\n                             sdCapsule(pos, vec3(.23,-.1*Anim+1.3,.65), vec3(-.35,1.35,.3),.16)));\n        res = min2(res, vec2(length(pos-vec3(-.35,1.35,.1))- .33, 30.));   \n        // arms \n        res = smin(res, min2(sdCapsule(pos, vec3(-.8+.06*Anim,2.5,.85),vec3(-1.25+.03*Anim,3.,.2), .16),\n                             sdCapsule(pos, vec3(-.8+.06*Anim,2.5,.85), vec3(-1.25,2.1,.3),.16)),.15);\n        res = min2(res, vec2(length(pos-vec3(-1.55,1.9,.1))- .3, 30.));\n        \n        if (res.x < closest) {\n            closest = abs(res.x);\n        }\n        return min2(res, res1);\n    }\n    else {\n        return res1;\n    }\n}\n\n\n//----------------------------------------------------------------------\n#define EDGE_WIDTH 0.15\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxd, inout float hmin) {\n    closest = 9999.; // reset closest trap\n\tfloat precis = .0006, h = EDGE_WIDTH+precis, t = 2., m = -1.;\n    hmin = 0.;\n    for( int i=0; i<RAY_STEP; i++) {\n        if( abs(h)<t*precis || t>maxd ) break;\n        t += h;\n\t    vec2 res = map(ro+rd*t);\n        if (h < EDGE_WIDTH && res.x > h + 0.001) {\n\t\t\thmin = 10.0;\n\t\t}\n        h = res.x;\n\t    m = res.y;\n    }\n    \n\t//if (hmin != h) hmin = 10.;\n    if( t>maxd ) m = -200.0;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<26; i++ ) {\n\t\tif( t>maxt ) break;\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp( res, 0., 1.);\n}\n\n// normal with kali edge finder\nfloat Edge=0.;\nvec3 calcNormal(vec3 p, vec3 rd, float t) { \n    float pitch = .2 * t / iResolution.x; \n\tpitch = max( pitch, .015 );\n\n\tvec3 e = vec3(0.0,2.*pitch,0.0);\n\tfloat d1=map(p-e.yxx).x,d2=map(p+e.yxx).x;\n\tfloat d3=map(p-e.xyx).x,d4=map(p+e.xyx).x;\n\tfloat d5=map(p-e.xxy).x,d6=map(p+e.xxy).x;\n\tfloat d=map(p).x;\n    \n\tEdge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5)); //edge finder\n\tEdge=min(1.,pow(Edge,.55)*15.);\n    \n    vec3 grad = vec3(d2-d1,d4-d3,d6-d5);\n\treturn normalize(grad - max(.0,dot (grad,rd ))*rd);\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= .75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 mandelbrot(in vec2 uv, vec3 col) {\n    uv.x += 1.5;\n    uv.x = -uv.x;\n\n    float a=.05*sqrt(abs(Anim)), ca = cos(a), sa = sin(a);\n    mat2 rot = mat2(ca,-sa,sa,ca);\n    uv *= rot;\n\tfloat kk=0., k = abs(.15+.01*Anim);\n    uv *= mix(.02, 2., k);\n\tuv.x-=(1.-k)*1.8;\n    vec2 z = vec2(0);\n    vec3 c = vec3(0);\n    for(int i=0;i<50;i++) {\n        if(length(z) >= 4.0) break;\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.y*z.x) + uv;\n        if(length(z) >= 4.0) {\n            kk = float(i)*.07;\n            break; // does not works on some engines !\n        }\n    }\n    return clamp(mix(vec3(.1,.1,.2), clamp(col*kk*kk,0.,1.), .6+.4*Anim),0.,1.);\n}\n\nvec3 screen(in vec2 uv, vec3 scrCol) {\n    // tv effect with horizontal lines and color switch\n    vec3 oricol = mandelbrot(vec2(uv.x,uv.y), scrCol);\n    vec3 col;\n\tfloat colorShift = .2*cos(.5*iTime);\n    col.r = mandelbrot(vec2(uv.x,uv.y+colorShift), scrCol).x;\n    col.g = oricol.y;\n    col.b = mandelbrot(vec2(uv.x,uv.y-colorShift), scrCol).z;\n    \n\tuv *= Rot3;\t\n\tcol =(.5*scrCol+col)*(.5+.5*cos(iTime*5.))*cos(iTime*10.+40.*uv.y);  \n    return col*col;\n}\n\n// clean lines on the ground\nfloat isGridLine(vec2 p, vec2 v) {\n    vec2 k = smoothstep(.1,.9,abs(mod(p+v*.5, v)-v*.5)/.08);\n    return k.x * k.y;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, inout float hmin) { \n    // Test bounding sphere (optim)\n    WithChameleon = intersectSphere(ro,rd,vec3(-.5,1.65,0),3.15); //2.95);\n    \n    vec2 res = castRay(ro,rd,60.0, hmin);\n    float distCham = abs(closest);\n    \n#ifdef SHOW_EDGES\n     if( res.y>-150.)  {\n           vec3 pos = ro + res.x*rd;\n     \tvec3 nor = calcNormal(pos, rd, res.x);\n     }\n    return vec3(1);\n#else\n    \n    float t = res.x;\n\tfloat m = res.y;\n    vec3 cscreen = vec3(sin(.1+1.1*iTime), cos(.1+1.1*iTime),.5);\n    cscreen *= cscreen;\n \n    vec3 col;\n\tfloat dt;\n    float glow = 1.-smoothstep(Anim + cos(iTime),.9+1.15,2.2);\n    glow *= step(.3, hash(iTime)); //floor(.01+10.5*iTime)));\n    \n    if( m>-150.)  { \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, rd, t);\n\n        if( m>0. ) { // Chameleon\n\t\t\tcol = vec3(.4) + .35*cscreen + .3*sin(1.57*.5*iTime + vec3(.05,.09,.1)*(m-1.) );\n#ifdef NOISE_SKIN\n            nor = doBumpMap(iChannel0, pos*.5, nor, 0.05);\n#endif            \n        } else if (m<-104.5) {  // bottom of screen\n            col = vec3(.92);\n            dt = dot(normalize(pos-vec3(-4,-4,0)), vec3(0,0,-1));\n            col += (dt>0.) ? (.75*glow+.3)*dt*cscreen: vec3(0); \n        } else if (m<-102.5) {\n           \tif (pos.z<0.) { // screen\n            \tcol = screen(pos.xy,cscreen);\n                col += 20.*glow*col;\n            } else { // back of screen\n                col = vec3(.92);\n            \tdistCham *= .25; // Hack for chameleon light on screen\n            }\n        } else if (m<-101.5) {\n            col = .2+3.5*cscreen*glow;\n            \n        } else if(m<-100.5) {  // Ground\n            float f = mod( floor(2.*pos.z) + floor(2.*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.);\n            col = .1+.9*col*isGridLine(pos.xz, vec2(2.));\n            dt = dot(normalize(pos-vec3(-4,-4,0)), vec3(0,0,-1));\n \t\t\tcol += (dt>0.) ? (.75*glow+.3)*dt*cscreen: vec3(0);     \n    \t\t//col = clamp(col,0.,1.);\n        } else {  // Screen\n            col = vec3(.92);\n            distCham *= .25; // Hack for chameleon light on screen\n        }\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { \n            WithChameleon = intersectSphere(pos,lig,vec3(-.5,1.65,0),2.95);\n            sh = softshadow( pos, lig, 0.02, 13., 8.0 ); \n            dif *= sh; \n        }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.80*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += 1.80*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 0.8*dif*vec3(1.00,0.90,0.70)*ao;\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = 1.2*sh*pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf*(.5+.5*sh) + vec3(.25)*col*spe + 0.2*fre*(0.5+0.5*col);\n        \n        float rimMatch =  1. - max( 0. , dot( nor , -rd ) );\n        col += vec3((.1+cscreen*.1 )* pow( rimMatch, 10.));\n\t}\n\n\tcol *= 2.5*exp( -0.01*t*t );\n    float BloomFalloff = 15000.; //mix(1000.,5000., Anim);\n \tcol += .5*glow*cscreen/(1.+distCham*distCham*distCham*BloomFalloff);\n    \n\treturn vec3( clamp(col,0.0,1.0) );\n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // animation\n    float GlobalTime = iTime; // + .1*hash(iTime);\n    \n    Anim = clamp(5.6*cos(GlobalTime)*cos(4.*GlobalTime),-2.5,1.2);\n    ca3 = cos(.275+.006*Anim); sa3 = sin(.275+.006*Anim);   \n\tRot3 = mat2(ca3,-sa3,sa3,ca3);\n    float a=.1+.05*Anim, ca = cos(a), sa = sin(a);\n    Rotanim = mat2(ca,-sa,sa,ca);\n    float b = mod(GlobalTime,12.)>10.?cos(8.*GlobalTime):.2*cos(4.*GlobalTime), cb = cos(b), sb = sin(b);\n    Rotanim2 = mat2(cb,-sb,sb,cb);\n    float time = 17. + /*14.5 +*/ GlobalTime;\n    \n    // mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    // camera\t\n    float dist = 13.;\n    vec3 ro = vec3( -0.5+dist*cos(0.1*time + 6.0*mo.x), 3.5 + 10.0*mo.y, 0.5 + dist*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -3.5, .5, 0. );\n\n    // camera tx\n    vec3 cw = normalize( ta-ro );\n    vec3 cp = vec3( 0.0, 1.0, 0.0 );\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n\n    // render\n    vec3 colorSum = vec3(0);\n    int nbSample = 0;\n    \n #if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float randPix = 0.; //hash(iTime); // Use frame rate to improve antialiasing ... not sure of result\n\t\tvec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));\n\t\t//vec3 ray = Ray(2.0,fragCoord.xy+subPix);\n\t\tvec2 q = (fragCoord.xy+subPix)/iResolution.xy;\n\t\t//vec2 q = (fragCoord.xy+.4*vec2(cos(6.28*float(i)/float(ANTIALIASING)),sin(6.28*float(i)/float(ANTIALIASING))))/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n        \n        nbSample++;\n        float hmin = 100.;\n        colorSum += sqrt(render( ro, rd, hmin));\n        \n#ifdef SHOW_EDGES\n \t\tcolorSum = vec3(1);\n        if (Edge>0.3) colorSum = vec3(.6);  \n        if (hmin>0.5) colorSum = vec3(0,0,0);   \n        break;\n#endif\n        \n#if (ANTIALIASING > 1)\n        // optim : use antialiasing only on objects edges //exit if far from objects\n        if (Edge<0.3 && hmin<0.5 ) break;\n\t}\n#endif\n    \n    fragColor = vec4(colorSum/float(nbSample), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msc3z8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[787, 787, 810, 810, 848], [1782, 1782, 1851, 1851, 1952], [2011, 2011, 2055, 2055, 2095], [2097, 2157, 2208, 2208, 2419], [2421, 2421, 2467, 2467, 2552], [2554, 2554, 2603, 2603, 2682], [2684, 2684, 2717, 2717, 2740], [2799, 2799, 2827, 2827, 3401], [3403, 3403, 3425, 3425, 4038], [4040, 4040, 4062, 4113, 5028], [5034, 5034, 5074, 5074, 5529], [5606, 5606, 5629, 5643, 6791], [6892, 6892, 6963, 6963, 7417], [7419, 7419, 7504, 7504, 7723], [7772, 7772, 7815, 7815, 8291], [8296, 8296, 8337, 8337, 8637], [8639, 8639, 8678, 8678, 9282], [9284, 9284, 9322, 9378, 9743], [9745, 9774, 9808, 9808, 9893], [9895, 9895, 9951, 9988, 13270]], "test": "timeout"}
{"id": "Msc3zN", "name": "(CLEAN) first shader/sdf ", "author": "sagarpatel", "description": "This is a clean/from scratch re-implementation of my first shdaer/sdf, which was based on @cabbibo's awesome SDF tutorial and iq's Raymarching Primitives.\nTons of comments explaining how I derived stuff.", "tags": ["procedural", "3d", "raymarching", "distancefields", "sdf", "tutorial"], "likes": 19, "viewed": 1035, "published": "Public API", "date": "1448450817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 1.0\n// @sagzorz\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n// \tpositive means outside of sphere\n// \tnegative means ray is inside\n// \t0 means its exactly on the surface\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*/\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 map(vec3 p)\n{\n    // results container\n    vec2 res;    \n    \n    // define objects\n    \t// sphere 1\n    \t// sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t//\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iTime);\n    \t// to twist the torus (or any object), we actually distort p/space (domain) itself,\n    \t// this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        // \tdomain distortion correction:\n        // \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    // combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    //res.x = torus_1.x;\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n// .y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t// variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; // travelled distance by ray\n    float id = -1.0; // object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    // hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    // camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msc3zN.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1343, 1478, 1511, 1511, 1539], [1541, 2768, 2797, 2797, 3021], [3171, 3586, 3617, 3617, 3740], [3862, 4109, 4142, 4142, 4261], [4263, 4440, 4476, 4476, 4509], [4511, 4750, 4794, 4794, 4926], [4928, 5100, 5128, 5128, 5198], [5200, 5404, 5422, 5447, 6598], [6600, 6822, 6855, 6906, 7900], [8192, 8192, 8222, 8222, 8548], [8550, 8737, 8768, 8768, 9770], [9772, 10011, 10076, 10076, 10270], [10272, 10272, 10329, 10329, 11140]], "test": "ok"}
{"id": "Msc3zr", "name": "Sierpinski Pyramid 1", "author": "Densen90", "description": "Rendering a Sierpinski Pyramid with Raymarching.", "tags": ["raymarching", "sierpinski", "pyramid"], "likes": 10, "viewed": 298, "published": "Public", "date": "1447708081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define MAXSTEPS 256\n#define EPSILON 0.001\n#define AMBIENT 0.2\n#define MAXDEPTH 100.0\n#define SHADOWDEPTH 32.0\n#define SOFTSHADOWFAC 32.0\n#define FRACTALITERATIONS 16\n#define AOSAMPLES 5.0\n\nconst vec3 lightCol = vec3(0.7, 0.5, 0.8);\nconst vec3 diffuse = vec3(1, 1, 1);\n\nvec3 lightDir;\n\nstruct Camera\n{\n\tvec3 pos;\n\tvec3 dir;\n} cam;\n\n// Rotation / Translation of a point p with rotation r\nvec3 rotate( vec3 p, vec3 r )\n{\n\tr.x *= PI/180.0;\n\tr.y *= PI/180.0;\n\tr.z *= PI/180.0;\n\n\tmat3 xRot = mat3 (\t1,\t0,\t\t\t\t0,\n\t\t\t\t\t\t0,\tcos(r.x),\t-sin(r.x),\n\t\t\t\t\t\t0,\tsin(r.x),\tcos(r.x) );\n\tmat3 yRot = mat3 ( \tcos(r.y),\t\t0,\tsin(r.y),\n\t\t\t\t\t\t0,\t\t\t\t\t1,\t0,\n\t\t\t\t\t\t-sin(r.y),\t\t0,\tcos(r.y) );\n\tmat3 zRot = mat3 (\tcos(r.z),\t-sin(r.z),\t0,\n\t\t\t\t\t\tsin(r.z),\tcos(r.z),\t0,\n\t\t\t\t\t\t0,\t\t\t\t0,\t\t\t\t1 );\n\treturn xRot * yRot * zRot * p;\n}\n\n// give the distance to a plane from a point p and normal n, shifted by y\nfloat distPlane( vec3 p, vec3 n, float y )\n{\n\treturn dot(p-vec3(0,y,0),n);\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat distFrac(vec3 p)\n{\n\tconst float scale = 1.8;\n\tconst float offset = 2.0;\n\n\tfor(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n\t\tp.xy = (p.x+p.y < 0.0) ? -p.yx : p.xy;\n\t\tp.xz = (p.x+p.z < 0.0) ? -p.zx : p.xz;\n\t\tp.zy = (p.z+p.y < 0.0) ? -p.yz : p.zy;\n\n\t\tp = scale*p-offset*(scale-1.0);\n\t}\n \n\treturn length(p) * pow(scale, -float(FRACTALITERATIONS));\n}\n\n// return positive values when outside and negative values inside,\n// --> distance of the nearest surface.\nfloat distanceField(vec3 p)\n{\n\t//Rotate scene around y-axis\n\tvec3 rotP = rotate(p, vec3(0, mod(iTime*20.0, 360.0),0));\n\trotP = rotate(rotP-vec3(0,-0.6,0), vec3(0, 45,55));\n\t\n\n\tfloat dPlane = distPlane(p, vec3(0,1,0), -2.0);\n\tfloat dFrac = distFrac(rotP);\n\treturn min(dFrac, dPlane);\n}\n\n// marching along the ray at step sizes, \n// and checking whether or not the surface is within a given threshold\nvec4 raymarch(vec3 rayOrigin, vec3 rayDir)\n{\n\tfloat totalDist = 0.0;\n\tfor(int j=0; j<MAXSTEPS; j++)\n\t{\n\t\tvec3 p = rayOrigin + totalDist*rayDir;\n\t\tfloat dist = distanceField(p);\n\t\tif(abs(dist)<EPSILON)\t//if it is near the surface, return an intersection\n\t\t{\n\t\t\treturn vec4(p, 1.0);\n\t\t}\n\t\ttotalDist += dist;\n\t\tif(totalDist>=MAXDEPTH) break;\n\t}\n\treturn vec4(0);\n}\n\n// Approximates the (normalized) gradient of the distance function at the given point.\n// If p is near a surface, the function will approximate the surface normal.\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\n// calculate shadow, ro=origin, rd=dir\n// look for nearest point when raymarching, factor k gives smoothnes, 2=smooth, 128=hard\n// dl is distance to light, so only return if distance is smaller\nfloat shadow(vec3 ro, vec3 rd, float k)\n{\n\tfloat res = 1.0;\n    float t = EPSILON;\n    for( int i=0; i<1000; i++)\n    {\n        float h = distanceField(ro + rd*t);\n        if( h<EPSILON )\n            return AMBIENT;\n        res = min( res, k*h/t );\n        t += h;\n        if(t>=SHADOWDEPTH) break;\n    }\n    return res;\n}\n\n//calculate ambient occlusion\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat res = 0.0;\n\tfloat fac = 1.0;\n\tfor(float i=0.0; i<AOSAMPLES; i++)\n\t{\n\t\tfloat distOut = i*0.3;\t//go on normal ray AOSAMPLES times with factor 0.3\n\t\tres += fac * (distOut - distanceField(p + n*distOut));\t//look for every step, how far the nearest object is\n\t\tfac *= 0.5;\t//for every step taken on the normal ray, the fac decreases, so the shadow gets brighter\n\t}\n\treturn 1.0 - clamp(res, 0.0, 1.0);\n}\n\n//calculate the color, the shadow, the lighting for a position\nvec3 shading(vec3 pos, vec3 rd, vec3 n)\n{\n\tvec3 light = max(AMBIENT, dot(n, lightDir)) * lightCol;\t//lambert light with light Color\n\tlight *= diffuse;\t//diffuse lighting, area lit lighting\n\tlight *= shadow(pos, lightDir, SOFTSHADOWFAC);\t//add shadow\n\tlight += ambientOcclusion(pos, n) * AMBIENT;\n\treturn light;\n}\n\nvec4 renderImage()\n{\n\tfloat fov = 60.0;\n\tfloat tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / iResolution.x;\n\tvec2 p = tanFov * (gl_FragCoord.xy * 2.0 - iResolution.xy);\n\n\tcam.pos = vec3(0,0,-8);\n\tcam.dir = normalize(vec3( p.x, p.y, 1 ));\n    \n    lightDir = normalize(vec3(-1,0.8,-1));\n\n\tvec4 res;\n\n\tres = raymarch(cam.pos, cam.dir);\n\tres.xyz = (res.a==1.0) ? clamp(shading(res.xyz, cam.dir, getNormal(res.xyz)), 0.0, 1.0) : vec3(0);\n\n\treturn vec4(res.xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = renderImage();\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msc3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 406, 437, 437, 812], [814, 888, 932, 932, 964], [966, 1065, 1089, 1089, 1411], [1413, 1520, 1549, 1579, 1804], [1806, 1919, 1963, 1963, 2279], [2281, 2445, 2469, 2469, 2729], [2731, 2925, 2966, 2966, 3247], [3249, 3279, 3319, 3319, 3724], [3726, 3789, 3830, 3830, 4101], [4103, 4103, 4123, 4123, 4565], [4567, 4567, 4624, 4624, 4654]], "test": "ok"}
{"id": "MscGzH", "name": "2001", "author": "sixstring982", "description": "My god, it's full of stars!", "tags": ["star", "space", "trippy", "gate", "2001", "odyssey"], "likes": 7, "viewed": 304, "published": "Public", "date": "1448063745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**  \"2001\" - Sixstring982/2015\n  *\n  *  Inspired by one of my favorite films. Some\n  *  raymarching primitive code was taken from\n  *  iq's distfunctions page:\n  *\n  *  http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n  *\n  *  License: Attribution-NonCommercial-ShareAlike 4.0 International\n  */\n\n// Whelp, this thing is getting big. I'll need to refactor\n// later.\n\n#define MAX_RAY_DIST 100.0\n#define MAX_RAY_ITERS 10000\n#define FOG_START 20.0\n#define EPSILON 0.001\n#define SPEC_POW 32.0\n#define AUTOSPIN_SPEED 0.2\n#define CAM_DIST 10.0\n#define MOUSE_SPEED 0.01\n#define FOG_POW 0.5\n\n// sqrt(2) / 2\n#define STOT 0.7071\n\n// ================ SCENE SELECTION ====================\n\nint sceneSelect() {\n    // return 2;\n    return int(mod(iTime, 15.0) / 5.0);\n}\n\n// ================ COLORS =============================\nmat3 material() {\n    float c = floor(mod(iTime, 75.0) / 15.0);\n    \n    if (c < 1.0) {\n        return mat3(124.0, 36.0, 107.0,\n                    99.0, 100.0, 50.0,\n                    221.0, 95.0, 67.0) / 255.0;\n    } else if (c < 2.0) {\n        return mat3(205.0, 138.0, 111.0,\n                    0.0, 51., 94.0,\n                    13.0, 1.0, 45.0) / 255.0;\n    } else if (c < 3.0) {\n        return mat3(0.0, 19.0, 152.0,\n                    57.0, 5.0, 68.0,\n                    139.0, 5.0, 33.0) / 255.0;\n    } else if (c < 4.0) {\n        return mat3(25.0, 96.0, 142.0,\n                    65.0, 87.0, 23.0,\n                    192.0, 154.0, 0.0) / 255.0;\n    } else {\n        return mat3(167.0, 0.0, 169.0,\n                    41.0, 4.0, 67.0,\n                    17.0, 98.0, 167.0) / 255.0;\n    }\n}\n\n// ================ GEOMETRY ===========================\n\nfloat plane(in vec3 pos) {\n    float d = pos.y;\n    d += 1.0 * texture(iChannel1, pos.xz / vec2(100.0)).r;\n    d += 2.0 * cos(0.2 * pos.x + 0.00002 * sin(pos.z * 0.3) + cos(pos.z * 0.2)) +\n         4.0 * sin(cos(pos.z * 0.03) + pos.x * 0.02);\n    d += 8.0 * texture(iChannel1, pos.xz / vec2(250.0)).r;\n    return d;\n}\n\nfloat sphere(in vec3 pos, in float r) {\n    return length(pos) - r;\n}\n\nfloat texSphere(in vec3 pos, in float r) {\n    return length(pos) - r +\n           texture(iChannel0, pos.xy * vec2(0.01)).r;\n}\n\nfloat box(in vec3 pos, in vec3 dims) {\n    vec3 d = abs(pos) - dims;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n               length(max(d,0.0));\n}\n\nfloat cylinder(in vec3 p, in vec3 c) {\n    return length(p.xz - c.xz) - c.z;\n}\n\nfloat bentCylinder(in vec2 bp, in vec3 pos, in vec3 cyl) {\n    float c = cos(bp.x * pos.y);\n    float s = sin(bp.y * pos.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xy,pos.z);\n    return cylinder(q, cyl);\n}\n\nfloat opI(in float d1, in float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2) {\n    return max(d1, -d2);\n}\n\nfloat terrainMap(in vec3 pos) {\n    float d = plane(pos + vec3(1.0));\n    return d;\n}\n\n// =================== TERRAIN SCENE =================\n\n// =====  LIGHTING =====\n\nvec3 terrainNormalAt(in vec3 ro) {\n    const vec2 ev = vec2(EPSILON, 0.0);\n    return normalize(vec3(terrainMap(ro + ev.xyy) - terrainMap(ro - ev.xyy),\n                          terrainMap(ro + ev.yxy) - terrainMap(ro - ev.yxy),\n                          terrainMap(ro + ev.yyx) - terrainMap(ro - ev.yyx)));\n}\n\n\nvec3 terrainLighting(in vec3 ro, in vec3 rd, in float dist) {\n    vec3 n = terrainNormalAt(ro);\n    mat3 mat = material();\n    float diffC = max(0.0, dot(n, -rd));\n    float specC = pow(diffC, SPEC_POW);\n    \n    float ambC = 0.25;\n    \n    vec3 light;\n    if (ambC > max(diffC, specC)) {\n        light = mix(mat[0], mat[1], ambC - diffC);\n    } else if (diffC > specC * 100.0) {\n        light = mix(mat[1], mat[2], diffC - specC);\n    } else {\n        light = mat[2];\n    }\n    \n    if (dist < FOG_START) {\n        return light;\n    } else {\n        return mix(light, \n                   mat[0], \n                   pow((dist - FOG_START) / (MAX_RAY_DIST - FOG_START), FOG_POW));\n    }\n}\n\n// =====  MARCHING =====\n\nvec3 marchTerrain(in vec3 ro, in vec3 rd) {\n    float dist = EPSILON;\n    float totalDist = 0.0;\n    \n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (dist < EPSILON ||\n            totalDist > MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = terrainMap(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n    \n    if (dist < EPSILON) {\n        return terrainLighting(ro, rd, totalDist);\n    } else {\n        return material()[0];\n    }\n}\n\nvec4 terrainScene(in vec2 fragCoord) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5));\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float camTheta = iMouse.x * MOUSE_SPEED;\n    float camPhi   = iMouse.y * MOUSE_SPEED;\n    \n    \n    vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 cop = vec3(100.0 * sin(iTime * 0.03), 0.0, 100.0 * cos(iTime * 0.03));\n    \n    float height = (terrainMap(cop - vec3(0.1, 0.0, 0.0)) + \n                    terrainMap(cop) + \n                    terrainMap(cop + vec3(0.1, 0.0, 0.0))) / -3.0;\n    cop.y += height + 5.0;\n    \n    vec3 target = cop + normalize(cross(-cop, up)) +\n                  vec3(0.0, -0.3, 0.0);\n    \n    vec3 cdir = normalize(target - cop);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cright, cdir);\n    \n    vec3 rd = uv.x * cright + uv.y * cup + cdir;\n    \n    return vec4(marchTerrain(cop, rd), 1.0);\n}\n\n\n// =================== EYE SCENE =================\n\nfloat eyeMap(in vec3 pos) {\n    float d = sphere(pos, 3.0);\n    // 45 degrees around x axis\n    const mat3 xrot = mat3(1.0, 0.0, 0.0,\n                           0.0, STOT, -STOT,\n                           0.0, STOT, STOT);\n    \n    const mat3 zrot = mat3(0.0, -1.0, 0.0,\n                           1.0, 0.0, 0.0,\n                           0.0, 0.0, 1.0);\n    \n    const float maxEyelidDist = -4.8;\n    const float minEyelidDist = -6.0;\n    float eyelidDist = maxEyelidDist;\n    \n    const float maxLowerLid = 0.7;\n    const float maxLowerCurv = -0.3;\n    const float maxUpperLid = -0.45;\n\tconst float maxUpperCurv = 0.3;\n    const float minCurv = 0.0;\n    const float minLid = 0.0;\n    float lowerLid = maxLowerLid;\n    float lowerCurv = maxLowerCurv;\n    float upperLid = maxUpperLid;\n    float upperCurv = maxUpperCurv;\n    \n    const float EYELID_SPEED = 200.0;\n    float lidDisplacement = 0.003 * (sin(pos.x * 50.0) + cos(pos.y * 50.0));\n    \n    float eyeState = mod(iTime * EYELID_SPEED, 4.0 * EYELID_SPEED);\n    if (eyeState < 10.0) {\n        eyelidDist = mix(maxEyelidDist, minEyelidDist, eyeState / 10.0);\n        lowerLid   = mix(maxLowerLid,   minLid, eyeState / 10.0);\n        upperLid   = mix(maxUpperLid,   minLid, eyeState / 10.0);\n        lowerCurv  = mix(maxLowerCurv,  minCurv, eyeState / 10.0);\n        upperCurv  = mix(maxUpperCurv,  minCurv, eyeState / 10.0);\n    } else if (eyeState < 20.0) {\n        eyelidDist = mix(minEyelidDist, maxEyelidDist, (eyeState - 10.0) / 10.0);\n        lowerLid   = mix(minLid, maxLowerLid, (eyeState - 10.0) / 10.0);\n        upperLid   = mix(minLid, maxUpperLid, (eyeState - 10.0) / 10.0);\n        lowerCurv  = mix(minCurv, maxLowerCurv, (eyeState - 10.0) / 10.0);\n        upperCurv  = mix(minCurv, maxUpperCurv, (eyeState - 10.0) / 10.0);\n    }\n    \n    d = opI(d, box((xrot * (pos + vec3(0.0, 0.0, eyelidDist))) + \n                   vec3(0.0, 0.0, 0.0), vec3(2.0)));\n    \n    d = opU(d, bentCylinder(vec2(upperCurv),\n                            zrot * (pos + vec3(0.0, upperLid, 0.0)) + \n                            vec3(0.0, 0.0, -2.9), vec3(0.1)) +\n               lidDisplacement);\n    \n    d = opU(d, bentCylinder(vec2(lowerCurv),\n                            zrot * (pos + vec3(0.0, lowerLid, 0.0)) + \n                            vec3(0.0, 0.0, -2.9), vec3(0.1)) +\n               lidDisplacement);\n    return d;\n}\n\nvec3 eyeColoring(in vec3 pos) {\n    mat3 mat = material();\n    if (length(pos) < 3.02) {\n        // Eyeball\n\n        // Iris texture\n        float theta = atan(pos.x, pos.y);\n        float tc = texture(iChannel0,\n                             vec2(sin(theta * 4.0), \n                                  cos(theta * 0.25)) * \n                             1.0 / length(pos.xy)).g;\n        tc = tc * 2.0 + 0.5;\n        const float IRIS_VARIANCE = 0.004;\n        float irisDist = 0.5 + IRIS_VARIANCE * (cos(sin(theta * 1.0)) + \n                                                sin(theta * 10.0));\n\n        vec3 pupilCenter = mat[1];\n        vec3 innerIris = mat[1] * tc;\n        vec3 midIris = mat[2] * tc * 0.75;\n        vec3 outerIris = mat[2];\n        vec3 sclera = mix(mat[0], vec3(texture(iChannel0, pos.xy).r), 0.07);\n        if (length(pos.xy) < 0.25) {\n            return mix(pupilCenter, innerIris, pow(4.25 * length(pos.xy), 4.0));\n        } else if (length(pos.xy) < 0.4) {\n            return mix(innerIris, midIris, (length(pos.xy) - 0.25) / (0.4 - 0.25));\n        } else if (length(pos.xy) < irisDist) {\n            return mix(midIris, outerIris, pow((length(pos.xy) - 0.4) / (irisDist - 0.4), 0.5));\n        } else {\n            return mix(outerIris, sclera, pow((length(pos.xy) - irisDist), 0.2));\n        }\n    } else {\n        //Eyelid\n        return mix(vec3(0.0), mat[2], 1.0);\n    }\n}\n\nvec3 eyeNormalAt(in vec3 ro) {\n    vec2 ev = vec2(EPSILON, 0.0);\n    return normalize(vec3(eyeMap(ro + ev.xyy) - eyeMap(ro - ev.xyy),\n                          eyeMap(ro + ev.yxy) - eyeMap(ro - ev.yxy),\n                          eyeMap(ro + ev.yyx) - eyeMap(ro - ev.yyx)));\n}\n\nvec3 eyeLighting(in vec3 ro, in vec3 rd, in float dist) {\n    vec3 LIGHT_DIR = normalize(vec3(-0.1, 0.2, 6.0));\n    vec3 n = eyeNormalAt(ro);\n    vec3 colors = eyeColoring(ro + \n                              0.01 - 0.02 * \n                              texture(iChannel3, \n                                        vec2(0.5 * sin(iTime * 0.2),\n                                             0.5 * cos(iTime * 0.2))).rgb);\n    float diffC = max(0.0, dot(n, LIGHT_DIR));\n    float specC = pow(diffC, 10000.0);\n    vec3 fcolor = colors * (diffC + specC);\n    if (length(ro) > 3.001) {\n        mat3 mat = material();\n        fcolor = mix(mat[2], mat[1], diffC);\n        fcolor = mix(mat[0], fcolor, pow((length(ro) - 3.001) / (0.15), 0.1));\n    }\n    return fcolor;\n}\n\nvec3 skinLighting(in vec3 ro, in vec3 rd, in float dist) {\n    mat3 mat = material();\n\n    return mix(mat[1], texture(iChannel0, rd.xy).rrr, 0.1);\n}\n\n// =====  MARCHING =====\n\nvec3 marchEye(in vec3 ro, in vec3 rd) {\n    float dist = EPSILON;\n    float totalDist = 0.0;\n\n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (dist < EPSILON ||\n            totalDist > MAX_RAY_DIST) {\n            break;\n        }\n\n        dist = eyeMap(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n\n    if (dist < EPSILON) {\n        return eyeLighting(ro, rd, totalDist);\n    } else {\n        // Eyelid\n        return skinLighting(ro, rd, totalDist);\n    }\n}\n\n\nvec4 eyeScene(in vec2 fragCoord) {\n    vec2 uv = ((fragCoord / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 tremor = 0.01 - 0.02 * \n                  texture(iChannel3, \n                            vec2(0.25 * sin(iTime * 0.1),\n                                 0.25 * cos(iTime * 0.1))).rgb;\n    vec3 cop = vec3(tremor.xy, 0.0) + vec3(0.0, 0.05, 3.35);\n    // vec3 cop = vec3(0.0, 0.0, 5.0);\n    vec3 target = vec3(0.0);\n    vec3 up = normalize(vec3(1.0, 13.0, 0.0));\n    \n    vec3 cDir = normalize(target - cop);\n    vec3 cRight = normalize(cross(cDir, up));\n    vec3 cUp = cross(cRight, cDir);\n    \n    vec3 rd = uv.x * cRight + uv.y * cUp + cDir;\n    \n    return vec4(marchEye(cop, rd), 1.0);\n}\n\n// =========================== SQUISH SCENE ========================\n\nvec3 squishColorRight(in vec2 pos) {\n    return vec3(pos.x * sin(iTime * 0.4) * 0.5 + 0.5,\n                pos.y * cos(iTime * 1.3) * 0.5 + 0.5,\n                length(pos) * sin(cos(iTime)) * 0.5 + 0.5);\n}\n\nvec3 squishColorLeft(in vec2 pos) {\n    return vec3(pos.y * sin(iTime * 0.2) * 0.5 + 0.5,\n                pos.x * cos(iTime * 0.9) * 0.5 + 0.5,\n                length(pos) * sin(cos(iTime)) * 0.5 + 0.5);\n}\n\nvec3 colorSampleLeft(in vec2 pos) {\n    float d = texture(iChannel2, vec2(pos.x + iTime * 0.5, pos.y)).r;\n    \n    if (d > 0.45) {\n        return squishColorLeft(pos);\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec3 colorSampleRight(in vec2 pos) {\n    float d = texture(iChannel1, vec2(pos.x + iTime * 0.5, pos.y)).r;\n    \n    if (d < 0.3) {\n        return squishColorRight(pos);\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec2 deform(in vec2 v) {\n    float r = length(v);\n    float a = atan(v.y, v.x);\n    return vec2(0.25 / abs(v.y), 0.2 * v.x / abs(v.y));\n}\n\nvec4 squishScene(in vec2 fragCoord) {\n    vec2 uv = ((fragCoord / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv.yx;\n    vec2 dv = deform(uv);\n    //vec2 dv = uv;\n    if (uv.y < 0.0) {\n        return vec4(colorSampleLeft(dv), 1.0);\n    } else {\n        return vec4(colorSampleRight(dv), 1.0);\n    }\n}\n\n// ================== PUT IT ALL TOGETHER =====================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if (sceneSelect() == 1) {\n       fragColor = terrainScene(fragCoord);\n    } else if (sceneSelect() == 2) {\n       fragColor = eyeScene(fragCoord);\n    } else {\n       fragColor = squishScene(fragCoord);\n    }\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscGzH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-2.0", "functions": [[701, 701, 720, 737, 779], [781, 838, 855, 855, 1645], [1705, 1705, 1731, 1731, 2022], [2024, 2024, 2063, 2063, 2093], [2095, 2095, 2137, 2137, 2222], [2224, 2224, 2262, 2262, 2373], [2375, 2375, 2413, 2413, 2453], [2455, 2455, 2513, 2513, 2676], [2678, 2678, 2715, 2715, 2741], [2743, 2743, 2780, 2780, 2806], [2808, 2808, 2845, 2845, 2872], [2874, 2874, 2905, 2905, 2959], [3043, 3043, 3077, 3077, 3352], [3355, 3355, 3416, 3416, 4043], [4071, 4071, 4114, 4114, 4548], [4550, 4550, 4588, 4588, 5451], [5506, 5506, 5533, 5533, 7880], [7882, 7882, 7913, 7913, 9278], [9280, 9280, 9310, 9310, 9555], [9557, 9557, 9614, 9614, 10316], [10318, 10318, 10376, 10376, 10466], [10494, 10494, 10533, 10533, 10979], [10982, 10982, 11016, 11016, 11723], [11795, 11795, 11831, 11831, 12001], [12003, 12003, 12038, 12038, 12208], [12210, 12210, 12245, 12245, 12424], [12426, 12426, 12462, 12462, 12641], [12643, 12643, 12667, 12667, 12780], [12782, 12782, 12819, 12819, 13126], [13193, 13193, 13250, 13250, 13470]], "test": "error"}
{"id": "Msd3RN", "name": "Glowing Teapot", "author": "834144373", "description": "The model copy form  iapafoto:[url]https://www.shadertoy.com/view/4d33RN[/url]and [url]https://www.shadertoy.com/view/XsSGzG[/url],with iapafoto's permission.here thanks his support.:)\nMove mouse change color and full screen to get a good effect.", "tags": ["3d", "raymarching", "teapot", "glowing", "density"], "likes": 35, "viewed": 1910, "published": "Public API", "date": "1448466820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------------------------------------------\n//Glowing Teapot.glsl\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//Created by 834144373 2015/11/25\n//Tags: density, 3D, Raymarching, Glowing, Teapot.\n//Original: https://www.shadertoy.com/view/Msd3RN\n//-----------------------------------------------------------------------------------------\n/*\nThe model copy form  iapafoto: https://www.shadertoy.com/view/4d33RN\n\t\t\t\t\t\t\t   https://www.shadertoy.com/view/XsSGzG,\n\twith iapafoto's permission.here thanks his support.:)\n*/\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\n///some tools for blend model\nvec3 Rot(vec3 p,vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\t    \n    return p*rotX * rotY * rotZ;\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n//set values for teapot\nvoid SetValue(){\n\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n\tA[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n}\n\n///Bezier \nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\n\nfloat M(vec3 p) {\n\t\n\tp.y -= - 0.5;\n\n    // Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n\t\tr = length(p), \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n\tvec3 qq = vec3(r * sin(acos(p.y / r)), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .8); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.02);\n\n    return dTeapot;\n}\n\n\nfloat dis(vec3 campos,vec3 p){\n\tfloat d = 0.;\n\tfloat dd = 1.;\n\tfor(int i = 0;i<54;++i){\n\t\tvec3 sphere = campos + dd*p;\n\t\td = M(sphere);\n\t\tdd += d;\n\t\tif(d<0.02 || dd>10.)break;\n\t}\n\treturn dd;\n}\n\nvec3 normal(vec3 p){\n\tvec2 offset = vec2(0.,0.01);\n\tvec3 nDir = vec3(\n\t\tM(p+offset.yxx),\n\t\tM(p+offset.xyx),\n\t\tM(p+offset.xxy)\n\t)-M(p);\n\treturn normalize(nDir);\n}\n\nfloat objdetal(in vec3 p) {\n  \tfloat res = 0.;\n    vec3 c = p;\n  \tfor (int i = 0; i < 10; ++i) {\n        p =1.7*abs(p)/dot(p,p) -0.8;\n        p=p.zxy;\n        res += exp(-20. * abs(dot(p,c)))*.5;        \n  }\n  return res;\n}\n\nvec4 objdensity(vec3 pointpos,vec3 dir,float finaldis){\n    vec4 color=vec4(0.);\n    float den = 0.;\n    vec3 sphere = pointpos + finaldis*dir;\n    float dd = 0.;\n   \n    for(int j = 0;j<45;++j){\n        vec4 col;\n        col.a = objdetal(sphere);\n\n        float c = col.a/200.;\n        col.rgb = vec3(c,c,c);\n        col.rgb *= col.a;\n        col.rgb *= exp(-float(j)/20.);\n        dd = 0.01*exp(-2.*col.a);\n        //float dd = max(0.1,col.a);\n        sphere += dd*dir;\n\n        color += col;//*0.8;\n        if(c>.9 || dd >0.014)break;\n    }\n \n    return color*4.5;\n}\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = ( fragCoord.xy - iResolution.xy/2. )/iResolution.y;\n\n\t///set values for teapos\n\tSetValue();\n\t\n\tfloat t1 = -.5;// - min(mo.y*1.3,.4);\n\tfloat t2 = time*0.1+2.2;\n\tfloat t3 = 0.;\n\t\n\tvec2 Mo = (iMouse.xy/iResolution.xy)*vec2(0.5,1.5);\n\t\n\t//directiong\n\tvec3 p = normalize(vec3(uv,2.3));\n\t\tp = Rot(p,vec3(t1,t2,t3));\n\t//camera position\n\tvec3 campos = vec3(0.,0.,-4.2);\n\t\tcampos = Rot(campos,vec3(t1,t2,t3));\n\t//return surface distance\n\tfloat dd = dis(campos,p);\n////////-------with VoidChichen's Suggestion :-😁-------//////////////////\n\tvec4 col = vec4(0.);\n\tif(dd<10.){\n\t\tvec3 surface = campos + dd*p;\n\t\tvec3 nDir = normal(surface);\n\t\t\tnDir = max(abs(nDir-0.13)-0.1,0.);\n\t\tcol = objdensity(campos,p,dd).rgba;\n\t\t//col.rgb *= col.a/300.;\n\t\tcol.rgb = 1.6*col.rgb*vec3(0.7+Mo.y,0.8+Mo.x,0.5);\n\t\tcol.rgb += nDir.yyy*nDir.xxx;\n\t}\n\t\n\tfragColor = vec4( col.rgb, 1.0 );\n\n}\n", "image_inputs": [{"id": "MdB3DD", "previewfilepath": "https://soundcloud.com/aristoquartet/enya-orinoco-flow", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/aristoquartet/enya-orinoco-flow", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msd3RN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[678, 708, 738, 738, 1034], [1036, 1036, 1074, 1074, 1154], [1155, 1179, 1195, 1241, 1818], [1820, 1831, 1871, 1871, 2337], [2340, 2340, 2357, 2357, 3626], [3629, 3629, 3659, 3659, 3821], [3823, 3823, 3843, 3843, 3984], [3986, 3986, 4013, 4013, 4209], [4211, 4211, 4266, 4266, 4780], [4800, 4800, 4857, 4857, 5730]], "test": "ok"}
{"id": "Msd3zH", "name": "Inverted circle grid", "author": "RenoM", "description": "right screen is left screen after circle inversion of origin 0,0\nnow i just wait for fabrice to optimize my code ;)", "tags": ["circleinversionfractal2d"], "likes": 13, "viewed": 271, "published": "Public", "date": "1448228338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185\n#define A(a) if(a>.25)a=.5-a;\n#define B(a,b) sqrt(max(.0,1.-a*length(uv-vec2(b))))\n\nvec2 rot(vec2 uv,float theta)\n{\n    vec2 t=sin(vec2(1.57, 0) + theta);\n    return uv*mat2(t,-t.y,t.x);\n}\n\nvec3 image(vec2 uv,bool inv,out float d)\n{\n    uv.x*=iResolution.x/iResolution.y;\n    d=length(uv);\n    uv/=4.5*sin(iTime)+5.5;\n    uv=rot(uv,mod(iTime,TAU));\n    if(inv)\n        uv*=pow(.4/length(uv),2.);\n    uv=mod(abs(uv),.5);\n    A(uv.x) A(uv.y)\n    return vec3(B(4.,.0)+B(1./(sqrt(0.125)-.25),.25));\n}\n\nvoid mainImage(out vec4 C,in vec2 U)\n{\n    vec2 uv=2.*U/iResolution.xy-1.;\n    float d;\n    // split screen\n    C.xyz=uv.x<.0?image(2.*uv+vec2(1,0),false,d):image(uv-vec2(.5,0),true,d)*min(d,1.);\n    // full screen\n    \t// before inversion\n    //C.xyz=image(2.*uv,false,d);\n    \t// after inversion\n    //C.xyz=image(uv,true,d)*min(d,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msd3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 136, 136, 209], [519, 519, 557, 557, 858]], "test": "ok"}
{"id": "MsdGRM", "name": "ShapesnColors", "author": "RenoM", "description": "shapes ... and colors", "tags": ["sine2dcolors"], "likes": 6, "viewed": 158, "published": "Public", "date": "1448701139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 sFract(vec2 x) // sFract function by Shane\n{\n\tx = fract(x);\n\treturn min(x, x*(1.-x)*16.);\n}\n\nvoid mainImage(out vec4 C,vec2 U)\n{\n    vec2 R=iResolution.xy,\n         p=abs(U+U-R)/R.y;   \n    float b=length(p*=length(p)),\n          a=length(--p),\n          t=iTime;    \n    p*=20.*(p+1.)*abs(sin((a-t)/2.)*sin(b+t/4.))+abs(sin(a*b+2.*t/3.));\n    C=length(sFract(p))*(1.-b)*(.5+.5*sin(t/vec4(3,7,17,1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 96], [98, 98, 133, 133, 408]], "test": "ok"}
{"id": "MstGRn", "name": "Smooth Terrain Mesh", "author": "huwb", "description": "Collaboration with Beibei Wang. View adaptive mesh suitable for terrain rendering. LOD levels are smoothly transitioned (turns on and off every 5s). Inspired by McGuire's nice terrain rendering blog post (see comments). Click mouse to move detail focus.", "tags": ["terrain", "lod", "sampling", "smooth"], "likes": 42, "viewed": 834, "published": "Public", "date": "1447803503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2015 Huw Bowles & Beibei Wang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// Some work I did recently in collaboration with Beibei Wang.\n//\n// This is follow up work to Morgan McGuire's excellent blog post on best practices in terrain\n// rendering:\n// http://casual-effects.blogspot.co.uk/2014/04/fast-terrain-rendering-with-continuous.html\n//\n// The problem we address is that the transitions between lods are not perfect. there are verts\n// in a LOD level that are located in the middle of an edge in the next LOD. this can lead to\n// artifacts in the render. to combat this one can manually sample at both LOD levels and\n// then interpolate the result. this still doesn't get a 100% accurate result - to get a vert\n// to match the middle of an edge, it needs to take the average of the 2 verts that are connected\n// by the edge, not the average of all 4 surrounding verts.\n//\n// We eliminate this issue by gradually transitioning the vert layout. just before LODs change,\n// the verts match exactly. this means that one can simply do a single trilinear sample from the\n// terrain data texture and know the the transition will be 100% smooth.\n//\n// Most of the complexity in this shader comes from drawing a mesh. the novel code here\n// is small and concise - see the lod transition function smoothTransVert and surrounding\n// comments. this can be added to a vertex shader, leading to a very nice, simple and robust\n// terrain renderer. \n//\n\nbool doSmoothLods;\n\nfloat vert_spacing_at_1m = 0.1;\nfloat min_vert_spacing = exp2(-5.);\n// interpolation to next lod\nfloat frac_high;\n\nfloat line( vec2 p, vec2 start, vec2 end, float wp );\nvoid smoothTransVert( inout vec2 v, float ss );\n\n#define SCALE 10.\nvec2 uvToWorld( vec2 uv );\n\n// this function just generates geometry - not necessary with a mesh\nvoid emit( vec2 uv, vec2 v0, float ss, inout float l )\n{\n    vec2 v1 = v0+vec2(ss,0.);\n    vec2 v2 = v0+vec2(0.,ss);\n    vec2 v3 = v0+vec2(ss,ss);\n\n    bool odd = mod( v0.y, 2. * ss ) > 0.25*ss;\n    if( mod( v0.x, 2. * ss ) > 0.25*ss )\n        odd = !odd;\n    \n    // the magic sauce to transition lod levels is in this fn\n    smoothTransVert( v0, ss );\n    smoothTransVert( v1, ss );\n    smoothTransVert( v2, ss );\n    smoothTransVert( v3, ss );\n\n    float w = 3.;\n    l = max( l, line( uv, v0, v1, w ) );\n   \tl = max( l, line( uv, v2, v3, w ) );\n    l = max( l, line( uv, v0, v2, w ) );\n    l = max( l, line( uv, v1, v3, w ) );\n\n    if( odd )\n\t    l = max( l, line( uv, v1, v2, w ) );\n    else\n\t    l = max( l, line( uv, v0, v3, w ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    doSmoothLods = mod(iTime, 10.) < 5.;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uvToWorld( uv );\n    \n    vec2 camPos = vec2(SCALE/2.,SCALE/4.)+vec2(cos(iTime),sin(iTime));\n    \n    // player can posess detail center using mouse action\n    if( iMouse.z > 0. )\n        camPos = uvToWorld( iMouse.xy/iResolution.xy);\n    \n    float dist = max( abs(camPos.x-uv.x),abs(camPos.y-uv.y) );\n    \n    float desSS = max( dist * vert_spacing_at_1m, min_vert_spacing );\n    float desSS2 = exp2( floor( log2( desSS ) ) );\n    \n    // this is pure hackery to make the output look like a mesh when smoothing is\n    // NOT enabled (this can be knocked out for simplicity)\n    if( !doSmoothLods )\n    {\n        // trial and error programming at its best\n        vec2 camPos2 = camPos - mod( camPos, desSS2*2. );\n        float dist2 = max( abs(camPos2.x-uv.x),abs(camPos2.y-uv.y) );\n        if( \n            !(exp2(floor(log2(max(dist2*vert_spacing_at_1m, min_vert_spacing )))) > desSS2\n           ||exp2(floor(log2(max((dist2+desSS2*2.)*vert_spacing_at_1m, min_vert_spacing )))) > desSS2 ))\n            desSS2 /= 2.;\n    }\n    \n    // blend factor between LODs\n    frac_high = doSmoothLods ? clamp( desSS/desSS2-1.,0.,1.) : 1.;\n    \n    desSS = desSS2;\n    \n    vec2 uvf = desSS*floor(uv/desSS);\n    vec2 v0 = uvf;\n\n    float l = 0.;\n    \n    // emit the local neighbourhood of \"quads\" (sets of 2 triangles)\n    emit( uv, v0, desSS, l );\n    emit( uv, v0-vec2(desSS,0.), desSS, l );\n    emit( uv, v0+vec2(desSS,0.), desSS, l );\n    emit( uv, v0-vec2(0.,desSS), desSS, l );\n    emit( uv, v0+vec2(0.,desSS), desSS, l );\n    emit( uv, v0+vec2( desSS, desSS), desSS, l );\n    emit( uv, v0+vec2(-desSS, desSS), desSS, l );\n    emit( uv, v0+vec2( desSS,-desSS), desSS, l );\n    emit( uv, v0+vec2(-desSS,-desSS), desSS, l );    \n    \n    fragColor.rgb = 1. - mix( vec3(.8), vec3(.1), l );\n}\n\n// this does the smooth transitions between lods. for each set of 4x4 patches\n// as shown below, the close neighbour verts labelled N will be transitioned\n// towards the center vert labelled C:\n// x--x--x--x--x\n// |  |  |  |  |\n// x--N--N--N--x\n// |  |  |  |  |\n// x--N--C--N--x\n// |  |  |  |  |\n// x--N--N--N--x\n// |  |  |  |  |\n// x--x--x--x--x\nvoid smoothTransVert( inout vec2 v, float desSS )\n{\n    // size of 4x4 patch\n\tfloat squareSize_4 = 4. * desSS;\n    // vert fractional position in patch (0-1)\n\tvec2 m = fract(v/squareSize_4);\n    // offset from center of patch (at 0.5 fractionally)\n\tvec2 offset = m - 0.5;\n    // if offset is less than a radius of ~1 square, shift it towards the center\n\tfloat minRadius = 0.25*1.1; //1.1 is \"epsilon\" for numerical issues\n\tif( abs(offset.x) < minRadius ) v.x += offset.x*frac_high*squareSize_4;\n\tif( abs(offset.y) < minRadius ) v.y += offset.y*frac_high*squareSize_4;\n    // thats it!\n}\n\n// distance from p to line from v to w. sorry i've lost the reference, if this looks\n// like your code let me know and i'll cite you!\n// iq gives a condensed version in the comments.\nfloat line_d(vec2 p, vec2 v, vec2 w)\n{\n  // Return minimum distance between line segment vw and point p\n  float l2 = dot(v-w, v-w);  // i.e. |w-v|^2 -  avoid a sqrt\n  if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  float t = dot(p - v, w - v) / l2;\n  if (t < 0.0) return distance(p, v);       // Beyond the 'v' end of the segment\n  else if (t > 1.0) return distance(p, w);  // Beyond the 'w' end of the segment\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  return distance(p, projection);\n}\n// line helper\nfloat line( vec2 p, vec2 start, vec2 end, float wp )\n{\n    float d = line_d( p, start, end );\n    float w = wp/iResolution.x;\n    return smoothstep(w+5./iResolution.x,w,d);\n}\n\nvec2 uvToWorld( vec2 uv )\n{\n    uv.y *= iResolution.y/iResolution.x;\n    uv *= SCALE;\n    return uv;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstGRn.jpg", "access": "shaders20k", "license": "mit", "functions": [[2753, 2822, 2878, 2878, 3561], [3563, 3563, 3620, 3620, 5504], [5506, 5853, 5904, 5929, 6439], [6441, 6624, 6662, 6727, 7331], [7332, 7347, 7401, 7401, 7521], [7523, 7523, 7550, 7550, 7625]], "test": "error"}
{"id": "MstGRr", "name": "transition morph 2D", "author": "nilspin", "description": "transition morphing of 2D primitives", "tags": ["2d", "sdf", "morphing"], "likes": 8, "viewed": 262, "published": "Public", "date": "1447859474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float between = abs(sin(iTime*0.5));//0.3;//clamp(iTime*0.0001, 0.0, 1.0);\n    vec2 p = fragCoord.xy;\n    float C = circleDist(translate(p, vec2(300, 200)), 90.0);\n\tfloat S =  boxDist(translate(p, vec2(300, 200)), vec2(90, 90), \t10.0);\n\t\n    float d = (1.0 - between)*S+C*between;\n    fragColor = vec4(vec3(d),1.0);//mix(vec4(0), vec4(1), fillMask(d));//\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 70], [73, 73, 105, 105, 122], [125, 125, 173, 173, 289], [292, 292, 320, 320, 354], [356, 356, 413, 413, 774]], "test": "ok"}
{"id": "MstGz4", "name": "Just Sun & Water", "author": "MrASL", "description": ".......", "tags": ["2d"], "likes": 13, "viewed": 1085, "published": "Public API", "date": "1448445727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 drawHolo(vec2 pos,vec2 uv, float range,float power,float aspect){\n \tuv.x*=aspect; \n    float dis = distance(uv.xy,pos.xy);\n    vec3 result = vec3(0.0,0.0,0.0);\n    if(dis<range)\n        result = mix(vec3(0.36,0.174,0.119),vec3(0.0,0.0,0.0),pow(dis/range,power));\n    return result;\n}\n\nvec3 drawSun(vec2 pos,vec2 uv, float range,float sunrange,float power,float aspect){\n    uv.x*=aspect;\n    float dis = distance(uv.xy,pos.xy);\n    vec3 result = vec3(0.0,0.0,0.0);\n    if(dis<range)\n        result = vec3(1.0,0.974,0.647);\n    else if(dis>=range && dis<range+sunrange)\n        result = mix(vec3(1.0,0.974,0.007),vec3(0.0,0.0,0.0),pow((dis-range)/sunrange,power));\n    return result;\n}\n\nvec3 drawWave(float speed, float range, float height,float offset, float power, vec2 uv, float dis){\n \tvec3 finb = mix(vec3(0.796,0.796,0.745),vec3(0.513,0.513,0.486),dis);\n    float siny = offset + height*pow(sin(uv.x * range + iTime * speed)+1.0,power);\n    if(uv.y>siny)\n        finb = vec3(1.0,1.0,1.0);\n    return finb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float dis = distance(uv.xy,vec2(0.5,0.5));\n    vec4 fin = mix(vec4(0.91,0.91,0.87,1),vec4(0.65,0.65,0.517,1),dis);\n    fin.rgb += drawHolo(vec2(0.5,0.7),uv,0.7,0.7,aspect);\n    fin.rgb *= drawWave(1.4,70.0,0.017,0.5,1.3,uv,dis);\n    fin.rgb *= drawWave(1.8,60.0,0.015,0.487,1.3,uv,dis);\n    fin.rgb *= drawWave(2.2,50.0,0.013,0.462,1.3,uv,dis);\n    fin.rgb *= drawWave(2.5,35.0,0.011,0.45,1.3,uv,dis);\n    //vec3 sunc = drawSun(vec2(0.5,0.7),uv,0.03,0.03,0.3,aspect);\n    //fin.rgb = fin.rgb * (1.0 - sunc.a) + sunc.rgb*sunc.a;\n    fin.rgb += drawSun(vec2(0.5,0.7),uv,0.03,0.03,0.02,aspect);\n    fragColor = fin;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 70, 70, 288], [290, 290, 374, 374, 689], [691, 691, 791, 791, 1017], [1019, 1019, 1076, 1076, 1836]], "test": "ok"}
{"id": "Mt2XD3", "name": "Amoebas", "author": "lejeunerenard", "description": "Practicing making lines and converting to polar coordinates.", "tags": ["blackandwhite", "polar", "parametric"], "likes": 7, "viewed": 182, "published": "Public", "date": "1447045031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float TAU = 6.28318530718;\n\nfloat xyToR(vec2 uv, float r) {\n    float variance = 55./iResolution.y; // via @FabriceNeyret2\n    float mag = length(uv);\n    \n    // Draw as a smoothed line\n    return smoothstep(r - variance, r , mag)\n        - smoothstep(r, r + variance, mag);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - .5*R) / R.y;\n    uv *= 8.; // Scale\n    \n\tfragColor = vec4(vec3(xyToR(uv,\n       1.\n       + sin(TAU/2. * uv.x)*sin(iTime)\n       + sin(TAU * uv.y) * sin(2.*iTime)\n       + cos(TAU/4.*uv.x*uv.y) * sin(3.*iTime)\n    )), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 59, 59, 277], [278, 278, 335, 335, 615]], "test": "ok"}
{"id": "Mt2XDc", "name": "tritree", "author": "FabriceNeyret2", "description": "the tri-tree variant of quad-tree [url]https://www.shadertoy.com/view/lljSDy[/url]\nindeed, this is another kind of 4trees ;-)\n(NB: subdivision if the object intersect the node bounding sphere).", "tags": ["triangle", "short", "hexa", "quadtree", "tritree", "3tree"], "likes": 47, "viewed": 2666, "published": "Public API", "date": "1447095936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o,  vec2 U )\n{\n    o = vec4(0.0);\n    float r=.2, z=4., t=iTime, H = iResolution.y, uz;\n    U /=  H;                              // object : disc(P,r)\n    vec2 P = .5+.5*vec2(cos(t),sin(t*.7)), C=vec2(-.7,0), fU;  \n    U =(U-C)/z; P=(P-C)/z; r/= z;         // unzoom for the whole domain falls within [0,1]^n\n    \n    mat2 M = mat2(1,0,.5,.87), IM = mat2(1,0,-.577,1.155);\n    U = IM*U;         // goto triangular coordinates (there, regular orthonormal grid + diag )\n    \n    o.b = .25;                            // backgroud = cold blue\n\n    for (int i=0; i<7; i++) {             // to the infinity, and beyond ! :-)\n        fU = min(U,1.-U); uz = 1.-U.x-U.y;\n        if (min(min(fU.x,fU.y),abs(uz)) < z*r/H) { o--; break; } // cell border\n    \tif (length(P-M*vec2(.5-sign(uz)/6.)) - r > .6) break;    // cell is out of the shape\n\n                // --- iterate to child cell\n        fU = step(.5,U);                  // select grid-child\n        U = 2.*U - fU;                    // go to new local frame\n        P = 2.*P - M*fU;  r *= 2.;\n        \n        o += .13;                         // getting closer, getting hotter\n    }\n               \n\to.gb *= smoothstep(.9,1.,length(P-M*U)/r); // draw object\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 1237]], "test": "ok"}
{"id": "Mt2XDK", "name": "Linear Gradient with Rotation", "author": "smack0007", "description": "Implements a linear gradient with rotation.", "tags": ["gradient", "rotation"], "likes": 16, "viewed": 1798, "published": "Public", "date": "1446656215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 startColor = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 endColor = vec4(1.0, 1.0, 0.0, 1.0);\n    float currentAngle = -(iTime * 36.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 origin = vec2(0.5, 0.5);\n    uv -= origin;\n    \n    float angle = radians(90.0) - radians(currentAngle) + atan(uv.y, uv.x);\n\n    float len = length(uv);\n    uv = vec2(cos(angle) * len, sin(angle) * len) + origin;\n\t    \n    fragColor = mix(startColor, endColor, smoothstep(0.0, 1.0, uv.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 552]], "test": "ok"}
{"id": "Mt2XDt", "name": "RayMarching Notes", "author": "gilesruscoe", "description": "Further learning of ray marching. Keeping notes of what everything does.", "tags": ["raymarchingnotes"], "likes": 8, "viewed": 187, "published": "Public", "date": "1447457301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 100 //Maximum raymarch loop iterations  \n#define MAX_DIST 200.0 //Max distance before it is assumed the ray hit nothing\n#define EPSILON  0.01 //Minimum distance\n\n//borrowed from somewhere.. i forgot...\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n//Sphere distance function\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat maggot(vec3 pos)\n{\n    pos.y -= 0.5;\n    pos.y *= 0.3;\n    pos.xz *= 1.0 + smoothstep(0.0, 3.0, sin(pos.y * 120.0)) * 0.055;\n    pos.x += sin(iTime * 5.0 - pos.y * 10.0) * 0.1;\n\tfloat nl = noise(pos * 6.0) * 0.3;\n    float endMask = smoothstep(0.1, 0.2, pos.y);\n    return (length(pos) - 1.0 + clamp(pos.y * 3.0, 0.5, 1.0)) + nl * endMask;\n}\n\n//Box distance function\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n//Torus distance funciton\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Smooth polynominal min function, smoothly joins objects\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n//Distance function\nfloat distfunc(vec3 pos)\n{\n    float st = sin(iTime);\n    float ct = cos(iTime);\n    mat2 rotMat = mat2(st, ct, -ct, st); \n    //pos.xy *= rotMat;\n    //float n = noise(pos * 6.0) * 0.3;    \n    //float s = sphere(pos, 1.0 + n);\n    float s = maggot(pos);\n    return s;\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    /////SCENE SETUP/////\n    //Uv coordinates in -1 to 1 space\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    //Aspect ratio correction\n    uv.x *= iResolution.x / iResolution.y;\n    //Camera Position with some tilting animation\n    vec3 cameraOrigin = vec3(0.0, 0.0, 2.0);\n    //Camera Target\n    vec3 cameraTarget = vec3(0.0);\n    //World Up Direction\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    //Camera Direction\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    //Camera Right Direction\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    //Camera Up Direction\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    //Ray Direction\n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDir);\n    \n    /////RAY MARCHING////\n    //How far the ray has travelled so far\n    float totalDist = 0.0;\n    float dist = EPSILON;\n    //Point to start at\n    vec3 pos = cameraOrigin;\n    \n    for(int i = 0; i < 32; i++)\n    {\n        //If the object has been hit or the ray has gone out of bounds, break.\n        if(dist < EPSILON || totalDist > 20.0)\n            break;\n        //Evaluate the distance at current point using a distance function\n        dist = distfunc(pos);\n        //Progress the total distance covered\n        totalDist += dist;\n        //Progress the point along the ray vector by the distance travelled\n        pos += dist * rayDir;\n    }\n    \n    /////Lighting/////\n    //Check if object was hit\n    if(dist < EPSILON)\n    {\n        //Calculate the surface normal by sampling fragments of EPSILON distance from this fragment \n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n        \tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n        //NDotL lighting, assuming the light source is the camera\n        float brightness = 0.5;\n        vec3 lightSource = normalize(vec3(1.0, 0.0, 2.0)) * brightness;\n        float diffuse = max(0.0, dot(lightSource, normal));\n        float specular = pow(diffuse, 32.0) * 0.15;\n        vec3 baseColor = vec3(0.8, 0.3, 0.0);\n        vec3 result = baseColor + vec3(diffuse + specular);\n        //Final frag result\n\t\tfragColor = vec4(result, 1.0);\n        \n    }\n    //If not hit, use background colour\n    else\n    {\n        fragColor = vec4(0.1,0.15,0.25,0.1);\n    }\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 219, 242, 242, 278], [279, 279, 305, 305, 674], [677, 704, 742, 742, 777], [779, 779, 803, 803, 1126], [1128, 1152, 1184, 1184, 1232], [1233, 1259, 1292, 1292, 1357], [1358, 1416, 1457, 1457, 1550], [1551, 1571, 1597, 1597, 1842], [1844, 1851, 1908, 1973, 4369]], "test": "ok"}
{"id": "Mt2XDV", "name": "Distorted TV (Fast)", "author": "RafaSKB", "description": "This shader a modification of ehj1's shader (www.shadertoy.com/view/ldXGW4) with a faster algorithm to generate noise.\nNote the original version is much better than this one, but also a bit slower on old computers.", "tags": ["noise", "distortion", "perlin", "scanlines", "tv", "crt", "monitor", "static", "analog"], "likes": 34, "viewed": 1521, "published": "Public", "date": "1446686946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// change these values to 0.0 to turn off individual effects\nfloat vertJerkOpt = 1.0;\nfloat vertMovementOpt = 1.0;\nfloat bottomStaticOpt = 1.0;\nfloat scalinesOpt = 2.0;\nfloat rgbOffsetOpt = 1.0;\nfloat horzFuzzOpt = 4.0;\n\n// Noise generation functions borrowed from: \n// https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat fnoise(vec2 v) {\n\treturn fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453) * 0.55;\n}\n\nfloat staticV(vec2 uv) {\n    float staticHeight = fnoise(vec2(9.0,iTime*1.2+3.0))*0.3+5.0;\n    float staticAmount = fnoise(vec2(1.0,iTime*1.2-6.0))*0.1+0.3;\n    float staticStrength = fnoise(vec2(-9.75,iTime*0.6-3.0))*2.0+2.0;\n\treturn (1.0-step(fnoise(vec2(5.0*pow(iTime,2.0)+pow(uv.x*7.0,1.2),pow((mod(iTime,100.0)+100.0)*uv.y*0.3+3.0,staticHeight))),staticAmount))*staticStrength;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv =  fragCoord.xy/iResolution.xy;\n\t\n\tfloat fuzzOffset = fnoise(vec2(iTime*15.0,uv.y*80.0))*0.003;\n\tfloat largeFuzzOffset = fnoise(vec2(iTime*1.0,uv.y*25.0))*0.004;\n    \n    float vertMovementOn = (1.0-step(snoise(vec2(iTime*0.2,8.0)),0.4))*vertMovementOpt;\n    float vertJerk = (1.0-step(fnoise(vec2(iTime*1.5,5.0)),0.6))*vertJerkOpt;\n    float vertJerk2 = (1.0-step(fnoise(vec2(iTime*5.5,5.0)),0.2))*vertJerkOpt;\n    float yOffset = abs(sin(iTime)*4.0)*vertMovementOn+vertJerk*vertJerk2*0.3;\n    float y = mod(uv.y+yOffset,1.0);\n\t\n\tfloat xOffset = (fuzzOffset + largeFuzzOffset) * horzFuzzOpt;\n    \n    float staticVal = 0.0;\n   \n    for (float y = -1.0; y <= 1.0; y += 1.0) {\n        float maxDist = 5.0/200.0;\n        float dist = y/200.0;\n    \tstaticVal += staticV(vec2(uv.x,uv.y+dist))*(maxDist-abs(dist))*1.5;\n    }\n        \n    staticVal *= bottomStaticOpt;\n\t\n\tfloat red \t=   texture(\tiChannel0, \tvec2(uv.x + xOffset -0.01*rgbOffsetOpt,y)).r+staticVal;\n\tfloat green = \ttexture(\tiChannel0, \tvec2(uv.x + xOffset,\t  y)).g+staticVal;\n\tfloat blue \t=\ttexture(\tiChannel0, \tvec2(uv.x + xOffset +0.01*rgbOffsetOpt,y)).b+staticVal;\n\t\n\tvec3 color = vec3(red,green,blue);\n\tfloat scanline = sin(uv.y*800.0)*0.04*scalinesOpt;\n\tcolor -= scanline;\n\t\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 359, 359, 408], [410, 410, 431, 431, 480], [482, 482, 504, 504, 541], [543, 543, 567, 567, 2073], [2075, 2075, 2097, 2097, 2170], [2172, 2172, 2196, 2196, 2556], [2558, 2558, 2615, 2615, 3896]], "test": "error"}
{"id": "Mt2XDy", "name": "derppppp", "author": "lycium", "description": "test", "tags": ["circles"], "likes": 19, "viewed": 275, "published": "Public", "date": "1446333781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circleedge(vec2 p, vec2 o, float radius)\n{\n    float s = length(p - o) - radius;\n    return 1.0 - exp2(-28000.0 * s*s);\n}\n\n// polynomial smooth min (k = 0.1) from inigo quilez:\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat circlething(vec2 p)\n{\n    float a0 = iTime * 0.065;\n    float r_sin = sin(iTime * 0.35);\n\n    float result = 1.0;\n\n    const float num_a_circles = 2.0 * 7.0, inv_num_a_circles = 1.0 / num_a_circles;\n    const float num_r_circles = 1.0 * 5.0, inv_num_r_circles = 1.0 / num_r_circles;\n    for (float i = 0.0; i < num_r_circles; i += 1.0)\n    for (float j = 0.0; j < num_a_circles; j += 1.0)\n    {\n        float a = a0 + j * 6.283185307179586476925286766559 * inv_num_a_circles;\n\n        float r = (i + 1.0) * inv_num_r_circles * 0.5;\n        vec2 o_i = vec2(cos(a), sin(a)) * r;\n        \n        float r2 = 0.13 + (1.0 - r) * (1.0 + r_sin * r_sin * r_sin) * 0.136;\n        float r_ = sqrt(r2);\n        result = smin(result, circleedge(p, o_i, r_), 0.75);\n    }\n    \n    return max(0.0, result);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 pixel_scale = vec2(0.75 / iResolution.x);\n\n   \tfloat s = 0.0;\n    const float samples = 5.0;\n    const float norm = 1.0 / samples;\n\tfor (float z = 0.0; z < samples; z += 1.0)\n    {\n\t\tfloat a = z * norm * 3.0 * 6.283185307179586476925286766559;\n        float r0 = sqrt(z * norm);\n        float r = r0 * 1.15;\n        vec2 aa = vec2(cos(a), sin(a)) * r;\n        float w = 1.0 - r0;\n\n\t\ts += circlething((fragCoord - iResolution.xy * 0.5 + aa) * pixel_scale) * w;\n    }\n    s *= norm;\n    \n    vec3 c = vec3(15.8, 1.9, 0.4) * (s * 64.0);\n\n    float gamma_r = sqrt(c.x);\n    float gamma_g = sqrt(c.y);\n    float gamma_b = sqrt(c.z);\n    fragColor = vec4(gamma_r, gamma_g, gamma_b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2XDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 127], [129, 183, 222, 222, 325], [327, 327, 354, 354, 1127], [1129, 1129, 1184, 1184, 1874]], "test": "ok"}
{"id": "MtjGzK", "name": "OSCILOSCOPER1", "author": "Branch", "description": "OSCILOSCOPER1", "tags": ["osciloscoper1"], "likes": 9, "viewed": 143, "published": "Public", "date": "1446757173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return -min(max(100.0*(length( pa - ba*h ) - r),-1.),0.);\n}\n\nfloat circle(vec2 coord, vec2 pos, float size){\n    return -min(floor(distance(coord,pos)-size),0.);\n}\n\n\nmat2 rotate(float Angle){\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat vasenKulmakarva=floor(mod(iTime*0.8,2.0))*0.1;\n\tfloat oikeaKulmakarva=floor(mod(iTime*0.3,2.0))*0.1;\n\tfloat vasenSilma=min(max(0.24*sin(iTime),0.006),0.06);\n\tfloat oikeaSilma=min(max(0.24*sin(iTime),0.006),0.06);\n\tfloat suu=iTime*10.0;\n\tvec4 tulos;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n    \n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 nc=coord;\n\ttulos=vec4(vec3(0.0/255.0, 23.0/255.0, 12.0/255.0),1.0);\n    coord *= rotate(iTime+length(coord)/2.*sin(iTime));\n    coord *= 0.3 + sin(length(coord)+iTime*3.) * 1.6;\n    coord.y += sin(coord.x*3.+iTime)/32.;\n    for(float i=0.0; i<40.0; i++) {\n    \ttulos.rgb += sdCapsule(coord,vec2( 0.0, 0.0),vec2(sin(3.14159*i/16.0),cos(3.14159*i/16.0))*(1.0+sin(iTime+i/(1.2+sin(iTime/10.+i)) )*0.7) ,0.2+sin(iTime+i)/30.0);\n    \ttulos.rgb -= sdCapsule(coord,vec2( 0.0, 0.0),vec2(sin(3.14159*i/16.0),cos(3.14159*i/16.0))*(1.0+sin(iTime+i/(1.2+sin(iTime/10.+i)))*0.7) ,0.17+sin(iTime+i)/30.0);\n    }\n    \n\ttulos.xyz+=floor(mod(nc.y*1000.0,32.0)/32.0 + 2./32.0) / 12.0;\n\ttulos.xyz+=floor(mod(nc.x*1000.0,32.0)/32.0 + 2./32.0) / 12.0;\n    tulos.rgb-=rand(coord*iTime)/12.0;\n\ttulos.xyz=tulos.xyz/1.3 * mod(fragCoord.y,2.0);\n    tulos.rgb*=vec3(0.0,1.0,0.4);\n\tfragColor = tulos;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 93], [94, 94, 145, 145, 298], [300, 300, 347, 347, 402], [405, 405, 430, 430, 562], [563, 563, 620, 620, 1974]], "test": "ok"}
{"id": "MtjSDV", "name": "SAT Collision Test", "author": "kuvkar", "description": "Shader implementation of SAT(Separating axis test). Can be used to detect collisions between convex polygons. Mouse to move the other object. Object vertex count can be changed from code.", "tags": ["collision", "sat"], "likes": 16, "viewed": 286, "published": "Public", "date": "1446764691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////\n// Implementation of Separating Axis Test (SAT)\n// SAT test can be used to find collision between convex polygons. Visualization a bit lacking,\n// basicly the black lines coming out of the objects are showing the axis that were found to separate the objects, and \n// the gap between the objects in that axis.\n// reference: http://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n///////////////////////////////////////////////\n\n// change this to have more vertices in the objects (more vertices will create more round objects)\n#define POINTS 3\n\n#define COL1 vec4(0.0, 1.0, 1.0, 0.0)\n#define COL2 vec4(1.0, 0.0, 1.0, 0.0)\n\n\nvec2 g_uv;    \nstruct Poly\n{\n    vec2 origin;\n\tvec2 points[POINTS];\n    vec2 normals[POINTS];\n};\n\nPoly polys[2];\n\nfloat drawvec(vec2 from, vec2 to)\n{\n    vec2 uvv = g_uv - from;\n    vec2 a = to - from;\n    if(dot(uvv, uvv) - dot(a, a) > 0.0) return 0.0;\n    float d = dot(normalize(uvv), normalize(a)) * length(uvv);\n    if(d < 0.0) return 0.0;\n    float b = length((d * normalize(a)) - uvv);\n    float w = 0.002;\n    return max(w - b, 0.0) / w;\n}\n\nfloat drawPoly(in Poly p)\n{\n    float x = 0.0;\n    for (int i = 0; i < POINTS - 1; ++i)\n    {\n\t    x += drawvec(p.origin + p.points[i], p.origin + p.points[i + 1]);\n    }\n    x += drawvec(p.origin + p.points[POINTS - 1], p.origin + p.points[0]);\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 rotate(vec2 point, float angle)\n{\n    float x = point.x; float y = point.y;\n    point.x = x * cos(angle) - y * sin(angle);\n    point.y = y * cos(angle) + x * sin(angle);\n    return point;\n}\n\nvoid rotate(inout Poly p, float angle)\n{\n    for (int i = 0; i < POINTS; ++i)\n    {\n\t    p.points[i] = rotate(p.points[i], angle);\n    }\n}\n\n// finds minimum and maximum values \n// (dot product between axis and the vertex position gives the projected length on that axis)\nvec2 minmax(in Poly p, in vec2 axis)\n{\n    float m = dot(p.origin + p.points[0], axis);\n    vec2 mm = vec2(m, m);\n    for (int i = 1; i < POINTS; ++i)\n    {\n        float d = dot(p.origin + p.points[i], axis);\n        mm.y = max(mm.y, d);\n        mm.x = min(mm.x, d);\n    }\n    return mm;\n}\n\nvoid calcNormals(inout Poly p)\n{\n    for (int i = 0; i < POINTS - 1; ++i)\n    {\n        p.normals[i] = (normalize(p.points[i] - p.points[i+1])).yx * vec2(-1.0, 1.0);\n    }\n    p.normals[POINTS - 1] = (normalize(p.points[POINTS - 1] - p.points[0])).yx * vec2(-1.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    g_uv = uv;\n    \n\tconst int GRID = 30;\n    for (int i = 0; i < GRID; ++i)\n    {\n        float x = -0.5 + float(i) * 1.0 / float(GRID); \n        fragColor -= drawvec(vec2(x, -0.5), vec2(x, 0.5)) * (i == GRID / 2 ? 0.4 : 0.2);\n        fragColor -= drawvec(vec2(-0.5, x), vec2(0.5, x)) * (i == GRID / 2 ? 0.4 : 0.2);\n    }\n    \n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= 0.5;\n    m.y /= iResolution.x / iResolution.y;\n    \n    if(iMouse.xy == vec2(0.0)) { m = vec2(0.0);}\n    \n    // creating polygons\n    float size = 0.1;\n    polys[0].origin = vec2(sin(iTime * 0.15) * 0.2, cos(iTime * 0.15) * 0.2);\n    polys[1].origin = m;\n\t    \n    float stp = (3.14159 * 2.0) / float(POINTS);\n    \n    for (int i = 0; i < POINTS; ++i)\n    {\n        polys[0].points[i] = vec2(rotate(vec2(size, size), float(i) * stp));\n        polys[1].points[i] = vec2(rotate(vec2(size, size), float(i) * stp));\n    }\n    \n    rotate(polys[0], iTime * 0.1);\n    rotate(polys[1], iTime * 0.2);\n    \n    calcNormals(polys[0]);\n    calcNormals(polys[1]);\n    \n    // the actual SAT test happens here.\n    bool hit = true;\n    float gap = 0.0;\n    for (int j = 0; j < 2; ++j)\n    {\n        for (int i = 0; i < POINTS; ++i)\n        {\n            vec2 axis = polys[j].normals[i];\n\n            vec2 minm1 = minmax(polys[0], axis);\n            vec2 minm2 = minmax(polys[1], axis);\n            \n            // values need to be swapped\n            // if maximum of first object is smaller than minimum of second object\n            if(minm1.y > minm2.x)\n            {\n                vec2 tmp = minm2;\n                minm2 = minm1;\n                minm1 = tmp;\n            }\n\n            float gap = minm2.x - minm1.y;\n            gap = max(gap, 0.0);\n            \n            \n            if(gap > 0.0)\n            {\n                hit = false;    \n            }\n            \n\t\t\t// some visualization         \n            fragColor -= drawvec(polys[j].origin, polys[j].origin + axis * gap);\n        }\n    }\n    \n    fragColor -= drawPoly(polys[0]) * (hit ? COL1 : COL2);\n    fragColor -= drawPoly(polys[1]) * (hit ? COL1 : COL2);        \n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[841, 841, 876, 876, 1174], [1176, 1176, 1203, 1203, 1454], [1456, 1456, 1494, 1494, 1650], [1652, 1652, 1692, 1692, 1790], [1792, 1923, 1961, 1961, 2213], [2215, 2215, 2247, 2247, 2486], [2488, 2488, 2545, 2545, 4810]], "test": "ok"}
{"id": "MtjXW3", "name": "BinaryTree3d", "author": "jt", "description": "(double) binary tree/quaternary tree as ray-traced closed-form expression implicit surface.\nNO recursion, NO iteration - using only fract,exp2,ceil,log2 for branching.\n", "tags": ["raytracing", "implicitsurface", "binarytree"], "likes": 9, "viewed": 282, "published": "Public", "date": "1447185429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Double Binary Tree/Quaternary Tree as Ray-Traced Implicit Surface - written 2015-11-10 by Jakob Thomsen\n// Closed-form expression Implicit Surface Tree - NO recursion/iteration, using only fract,exp2,ceil,log2 for branching.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n// NOTE: the name was choosen to avoid confusion with the quad-tree data-structure.\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nvec2 mirror2(vec2 v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nvec3 BinarySubDiv(vec3 v )\n{\n    v = fract(exp2(ceil(-log2(v.z))) * v * vec3(.5, .5, 1.));\n    v.xy = mirror2(2. * v.xy);\n    return v;\n}\n\nfloat fn(vec3 v)\n{\n    v.z *= -1.0;\n    v = 0.5 * v + 0.5;\n    vec3 p = vec3(0.5, .5, 0.);\n    vec3 n = vec3(1.0, 1.0, 1.) - p;\n    v = BinarySubDiv(v);\n    v.xy = mirror2(v.xy);\n    return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01;\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * ceil(-log2(1.0-v.z));\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * exp2(ceil(-log2(1.0-v.z)));\n    //return length((v - p) - dot(v - p, n) * n / dot(n, n)) - .01 * exp2(ceil(-log2(v.z)));\n}\n\nvec3 nrm(vec3 v)\n{\n    vec3 n;\n    float d = 0.01;\n    n.x = fn(v + vec3(d, 0.0, 0.0)) - fn(v + vec3(-d, 0.0, 0.0));\n    n.y = fn(v + vec3(0.0, d, 0.0)) - fn(v + vec3(0.0, -d, 0.0));\n    n.z = fn(v + vec3(0.0, 0.0, d)) - fn(v + vec3(0.0, 0.0, -d));\n    return normalize(n);\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec3 tex(vec3 v)\n{\n    float d = abs(v.z * 20. + sfract(-iTime, 4.) * 5.); \n    vec3 c = 0.5 + 0.5 * nrm(v);\n    return exp(-d*d) + c * abs(nrm(v).x);\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float t = iTime * 0.1;\n    vec3 v;\n    //v.x = uv.x * cos(t) + uv.y * sin(t);\n    //v.y = uv.x * -sin(t) + uv.y * cos(t);\n    //v.z = depth;\n    \n    // isometry\n    vec3 iso;\n//    iso.x =  v.x - v.y - v.z;\n//    iso.y = -v.x - v.y - v.z;\n//    iso.z =        v.y - v.z;\n\n//    return iso;\n    iso.x =  uv.x - uv.y - depth;\n    iso.y = -uv.x - uv.y - depth;\n    iso.z =         uv.y - depth;\n\n    v.x = iso.x * cos(t) + iso.y * sin(t);\n    v.y = iso.x * -sin(t) + iso.y * cos(t);\n    v.z = iso.z;\n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 0.1;\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    const int depth = 256;//128;\n    float m = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for(int layer = 0; layer < depth; layer++) // slow...\n    {\n        vec3 v = camera(uv, 2.0 * float(layer) / float(depth) - 1.0);\n\n        if(abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0)\n            continue;\n\n        if(abs(fn(v)) < 0.05)\n        {\n            //m = 2.0 * float(layer) / float(depth) - 1.0;\n            color = tex(v);\n        }\n    }\n    \n    //fragColor = vec4(color * vec3(m), 1.0);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjXW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[484, 484, 522, 522, 589], [591, 591, 613, 613, 659], [661, 661, 689, 689, 798], [800, 800, 818, 818, 1327], [1329, 1329, 1347, 1347, 1604], [1606, 1606, 1636, 1636, 1688], [1690, 1690, 1708, 1708, 1842], [1844, 1844, 1879, 1879, 2398], [2400, 2400, 2457, 2457, 3126]], "test": "ok"}
{"id": "MtSSDV", "name": "[LLCS]#1 I won !", "author": "Eybor", "description": "A 2d fractal", "tags": ["2d", "fractal"], "likes": 5, "viewed": 846, "published": "Public API", "date": "1446491179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rot(vec2 v, float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a))*v;\n}\n\nfloat scene(vec2 uv)\n{\n    \n    for(int i = 0; i < 10; ++i)\n    {\n        uv = rot(uv, iTime);\n    \tuv = abs(uv)-1.;\n    \n    \tuv *= length(uv);\n    }\n    \n    return length(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.+2.*fragCoord.xy / iResolution.xy;\n    \n    uv*=3.5;\n\n    float eps = .01;\n      \n    vec2 g = abs(vec2(scene(uv+vec2(eps, 0.))-scene(uv-vec2(eps, 0.)),\n                  scene(uv+vec2(0., eps))-scene(uv-vec2(.0, eps))));\n    \n  \t\n    fragColor = vec4(g.x,2.*sqrt(g.x*g.y),g.y,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 81], [83, 83, 105, 105, 263], [265, 265, 322, 322, 620]], "test": "ok"}
{"id": "Xd33zr", "name": "Air Glider", "author": "jameswilddev", "description": "Hipster comment about Kirby Air Ride\nWas meant to be something else, ended up here.", "tags": ["skyroad"], "likes": 5, "viewed": 151, "published": "Public", "date": "1447631146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// NDC, expanded to match the aspect ratio.\nvec2 aspectNdc;\n\n#define BUILDING_SIDE_GAPS 2.0\n#define BUILDING_WIDTH 0.25\n#define CHECKER_DENSITY 4.0\n\n#define SEA_LEVEL -8.0\n\nvec2 onPlane() {\n    float dist = abs(aspectNdc.x) / BUILDING_SIDE_GAPS;\n    \n    return vec2((1.0 / abs(dist)) + fract((iTime * 0.3) / 1.0) * 1.0, aspectNdc.y / (dist));\n}\n\nfloat onPlaneX() {\n    float dist = abs(aspectNdc.x) / BUILDING_SIDE_GAPS;\n    \n    return (1.0 / abs(dist)) + ((iTime * 0.3) / 1.0) * 1.0;\n}\n\nfloat trueBuildingId() {\n    float temp = floor(onPlaneX() - BUILDING_WIDTH);\n    return temp;\n}\n\nfloat buildingTop() {\n    return ceil(sin(trueBuildingId() * 101.0) * 8.0 + 8.0);\n}\n\nfloat buildingBottom() {\n    return floor(sin(trueBuildingId() * 131.0) * 8.0 - 8.0);\n}\n\nfloat buildingLocation() {\n    return onPlane().x / 1.0;\n}\n\nfloat buildingId() {\n    return floor(buildingLocation());\n}\n\nfloat withinBuilding() {\n    return fract(buildingLocation());\n}\n\nbool onSideOfBuilding() {\n    return withinBuilding() > BUILDING_WIDTH;\n}\n\nvec3 checker(vec2 uv) {\n    uv = fract(uv);\n    return uv.x > 0.5 != uv.y > 0.5 ? vec3(1.0, 1.0, 0.6) : vec3(0.6, 0.6, 1.0);\n}\n\nvec2 checkerFront() {\n    vec2 offset = aspectNdc;\n\treturn CHECKER_DENSITY*(offset * ((buildingId() + 1.0) - fract(iTime * 0.3)));\n}\n\nvec2 checkerSide() {\n    return onPlane() * CHECKER_DENSITY;\n}\n\nbool onFrontOfBuilding() {\n    return abs(checkerFront().x) > (BUILDING_SIDE_GAPS * CHECKER_DENSITY)+ (CHECKER_DENSITY * BUILDING_WIDTH);\n}\n\n#define SKY_ZENITH vec3(0.1, 0.3, 0.6)\n#define SKY_HORIZON vec3(0.8, 0.8, 1.0)\n\nvec3 sky() {\n    return mix(SKY_ZENITH, SKY_HORIZON, 1.0 / (1.0 + abs(aspectNdc.y * 3.0)));\n}\n\n#define CHECKER_SIDE_COLOR 1.0\n#define CHECKER_FRONT_COLOR 0.6\n#define SEA_REFLECTION_COLOR vec3(0.6, 0.7, 0.8)\n#define SEA_BASE_COLOR vec3(0.05, 0.1, 0.12)\n\nvec3 color() {    \n    vec2 uv = onSideOfBuilding() ? checkerFront() : checkerSide();\n    \n    bool inSky = (onFrontOfBuilding() && onSideOfBuilding()) || uv.y > buildingTop() || uv.y < buildingBottom();\n    vec3 preColor = inSky? sky() : mix(checker(uv) * (onSideOfBuilding() ? CHECKER_SIDE_COLOR : CHECKER_FRONT_COLOR), sky(), 1.0 / (abs(aspectNdc.x * 5.0) + 1.0));\n    return preColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\taspectNdc = (fragCoord.xy - (iResolution.xy / 2.0)) / (min(iResolution.x, iResolution.y) / 2.0);\n    \n    \n    \n\tfragColor = vec4(pow(color(), vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd33zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 189, 189, 345], [347, 347, 365, 365, 488], [490, 490, 514, 514, 586], [588, 588, 609, 609, 671], [673, 673, 697, 697, 760], [762, 762, 788, 788, 820], [822, 822, 842, 842, 882], [884, 884, 908, 908, 948], [950, 950, 975, 975, 1023], [1025, 1025, 1048, 1048, 1151], [1153, 1153, 1174, 1174, 1285], [1287, 1287, 1307, 1307, 1349], [1351, 1351, 1377, 1377, 1490], [1572, 1572, 1584, 1584, 1665], [1825, 1825, 1839, 1839, 2215], [2217, 2217, 2274, 2274, 2444]], "test": "ok"}
{"id": "Xd3GzM", "name": "stripify", "author": "FabriceNeyret2", "description": "try on various images or videos :-)", "tags": ["video", "filter", "2tweets", "short", "strips"], "likes": 20, "viewed": 1084, "published": "Public API", "date": "1448512057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define L 8.  // interline distance\n#define A 2.  // amplification factor\n\nvoid mainImage( out vec4 o,  vec2 uv )\n{\n    uv /= L;\n // float t = -10.*iMouse.y/iResolution.y;  // strips move with mouse   \n    float t = 1.*iTime;               // strips move with time  \n    t=fract(t); \n    float  y = floor(uv.y+.5+t)-t;\n\n    #define T texture(iChannel0,L*vec2(uv.x,y)/iResolution.xy)   // add .g or nothing \n\n // o += 1.-cos(6.28*(uv.y-y)*(1.+A*(2.*T-1.))) -o;\n // o += cos( 6.28*(uv.y-y) * (1.-A*(2.*T-1.)) ) -o; // modulates line thickness\n    o += cos( 6.28*(uv.y-y) + A*(2.*T-1.) ) -o;      // modulates line offset\n    \n    if ( L*uv.x < .5*iResolution.x ) o += o.g - o;\n        \n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3GzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 115, 115, 685]], "test": "error"}
{"id": "Xd3GzN", "name": "DropTheBass", "author": "H3LLbot", "description": "DropTheBass", "tags": ["dropthebass"], "likes": 2, "viewed": 636, "published": "Public API", "date": "1448279882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n\tfloat cameraX = 250.0; \n    float cameraY = 150.0;\n    float x = pixCoords.x - cameraX;\n    float y = pixCoords.y - cameraY;\n    \n    float distance1 = sqrt((x * x) + (y * y));\n    \n    float circle2X = 0.0;\n    float circle2Y = 0.0;\n    float differenceX = x - circle2X;\n    float differenceY = y - circle2Y;\n    \n    float distance2 = sqrt((differenceX * differenceX) + (differenceY * differenceY));\n    \n    if (1.0+cos(distance2 /10.0 + (1.0+cos(50.0 * iTime)/4.0)) >0.5){\n        color = vec4(.0,.0,.0,1.0);\n    }\n    \n    \n    else {\n        color = vec4(1.0,0.0,0.0,1.0); \n    }\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3GzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 646]], "test": "ok"}
{"id": "XdcGRN", "name": "Shuriken", "author": "H3LLbot", "description": "shuriken made at school", "tags": ["shuriken", "gdp1"], "likes": 0, "viewed": 533, "published": "Public API", "date": "1448271457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat distanceTo(float x, float y, float centerX, float centerY) {\n\tfloat deltaX = x - centerX;\n    float deltaY = y - centerY;\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{\n    float zoom = (iResolution.x / 100.0);\n    float cameraX = 5.0 + 4.0;\n    float cameraY = 2.0 + 4.0;\n    \n    float xBeforeRot = pixCoords.x / zoom - cameraX;\n    float yBeforeRot = pixCoords.y / zoom - cameraY;\n    float vitesseRot = -1.0;\n    float angle = 20.0*(3.14/180.0);\n    \n    float x = pixCoords.x - cameraX;\n    float y = pixCoords.y - cameraY;\n    \n    float circle2X = 250.0;\n    float circle2Y = 140.0;\n    float differenceX = x - circle2X;\n    float differenceY = y - circle2Y;\n    \n    float distance2 = sqrt((differenceX * differenceX) + (differenceY * differenceY));\n    \n    float PI = 3.1415;\n    float angle2 = atan(differenceY, differenceX)+ iTime*10.0 + 0.01*distance2;\n    float radius = 0.9 * (1.0 + 0.05*cos(angle2*10.0));\n    \n    color = vec4(0.9,0.9,0.9,0.9);\n    \n    if (distance2 <100.0 && mod(angle2, PI/2.0)>0.8){\n        return;\n    }\n    \n   /* if (distanceTo(x,y,0.0,0.0) > radius) {\n        return;\n\t}*/\n    \n  \n    \n    x = xBeforeRot * cos(angle) + yBeforeRot*sin(angle); \n    y = -xBeforeRot * sin(angle) + yBeforeRot*cos(angle);\n    \n    \n\ty = mod(y, 7.0);\n    \n\n    float hauteurMoyenne = 2.0;\n    float amplitude = 2.0;\n    float phase = iTime * 1.5;\n    float periode = cos(iTime)+20.0;\n\n    float fx =  hauteurMoyenne + cos(x * 2.0 * PI/ periode + phase) * amplitude;\n \tfloat fx2 = hauteurMoyenne+3.0 + cos(x * 2.0 * PI/ periode + phase) * amplitude;\n\n    if (y < fx2 && y > fx) {\n        color = vec4(0.5, 0.0, 0.0, 0.0);\n        return;\n    }\n\n   \tcolor = vec4(0.0,0.0,0.0,0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 160, 160, 275], [277, 277, 330, 330, 1868]], "test": "ok"}
{"id": "XdcGzH", "name": "Koch Curve", "author": "knighty", "description": "Koch curves using foldings.", "tags": ["kifs", "kochcurve"], "likes": 44, "viewed": 1537, "published": "Public API", "date": "1447944075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Public domain\n#define PI 3.14159\n#define A2B PI/360.\n#define MaxIter 14\n//Constants\nconst float DRadius=0.7, Width=1.4, Gamma=2.2;\nconst vec3 BackgroundColor = vec3(1.);\nconst vec3 CurveColor = vec3(0.);\n\n//Global variables\nfloat lambda,ca,sa,lscl;\nfloat aaScale;\nfloat Angle=60.;\nvec2 csa;\n\nvoid init() {\n    Angle = 90.*0.5*(1.+sin(iTime+0.1*PI));\n\tfloat ang=A2B*Angle;\n\tca=cos(ang),sa=sin(ang);\n\tcsa=vec2(ca,-sa);\n\tlambda=0.5/(ca*ca);\n\tlscl=2./lambda;\n}\n\nfloat d2hline(vec2 p){\n   float t=max(-1.,min(1.,p.x));\n   p.x-=t;\n   return length(p);\n}\nfloat DE(vec2 p) {\n\tfloat d=1., r=dot(p,p);\n\tfor(int i=0; i<MaxIter; i++) {\n\t\tp.x=abs(p.x);\n\t\tp.x-=1.-lambda;\n\t\tfloat t=2.*min(0.,dot(p,csa));\n\t\tp-=csa*t;\n\t\tp.x-=lambda;\n\t\tp*=lscl; d*=lscl;\n\t\tp.x+=1.;\n\t\t r=dot(p,p);\n\t}\n\treturn d2hline(p)/d;//length(p)-1.;\n}\n\nfloat coverageFunction(float t){\n\t//this function returns the area of the part of the unit disc that is at the rigth of the verical line x=t.\n\t//the exact coverage function is:\n\t//t=clamp(t,-1.,1.); return (acos(t)-t*sqrt(1.-t*t))/PI;\n\t//this is a good approximation\n\treturn 1.-smoothstep(-1.,1.,t);\n\t//a better approximation:\n\t//t=clamp(t,-1.,1.); return (t*t*t*t-5.)*t*1./8.+0.5;//but there is no visual difference\n}\n\nfloat coverageLine(float d, float lineWidth, float pixsize){\n\td=d*1./pixsize;\n\tfloat v1=(d-0.5*lineWidth)/DRadius;\n\tfloat v2=(d+0.5*lineWidth)/DRadius;\n\treturn coverageFunction(v1)-coverageFunction(v2);\n}\n\nvec3 color(vec2 pos) {//getColor2D(vec2 pos) {\n\tfloat pixsize=dFdx(pos.x);\n\tfloat v=coverageLine(abs(DE(pos)), Width, pixsize);\n\treturn pow(mix(pow(BackgroundColor,vec3(Gamma)),pow(CurveColor,vec3(Gamma)),v),vec3(1./Gamma));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float scaleFactor=1.4;\n\tvec2 uv = scaleFactor*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    uv.y+=0.5;\n\tinit(); \n\tfragColor = vec4(color(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcGzH.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[294, 294, 307, 307, 458], [460, 460, 482, 482, 549], [550, 550, 568, 568, 807], [809, 809, 841, 1075, 1227], [1229, 1229, 1289, 1289, 1433], [1435, 1435, 1457, 1481, 1661], [1662, 1662, 1719, 1719, 1884]], "test": "ok"}
{"id": "XdcGzr", "name": "Matrix rain < 200 char", "author": "reinder", "description": "Compacting [url=https://www.shadertoy.com/view/4tlXR4]matrix - 255 char[/url] by FabriceNeyret2 even more and added some color. All credits go to FabriceNeyret2.", "tags": ["font", "2tweets", "short", "pseudofont"], "likes": 40, "viewed": 2442, "published": "Public API", "date": "1447614697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Reinder Nijhoff 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XdcGzr\n//\n// Based on matrix - 255 char by FabriceNeyret2: https://www.shadertoy.com/view/4tlXR4\n// compacting to 2-tweets patriciogv's Matrix shader https://www.shadertoy.com/view/MlfXzN ( 819 -> 255 chars ) \n// But first go see patriciogv's comments and readable sources :-D\n//\n// All credits go to FabriceNeyret2\n//\n\n#define R fract(43.*sin(dot(p,p)))\n\nvoid mainImage( out vec4 o, vec2 i) {\n    vec2 j = fract(i*=.1), \n         p = vec2(9,int(iTime*(9.+8.*sin(i-=j).x)))+i;\n    o-=o; o.g=R; p*=j; o*=R>.5&&j.x<.6&&j.y<.8?1.:0.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcGzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[531, 531, 568, 568, 707]], "test": "ok"}
{"id": "XddGRN", "name": "3d color space visualization", "author": "nmz", "description": "Not very efficient at all, but a nice method to visualize various color spaces in 3d.", "tags": ["3d", "lab", "xyz", "colorspace"], "likes": 19, "viewed": 2228, "published": "Public", "date": "1448386398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//3D color space visualization by nmz (@stormoid)\n\n/*\n\tI needed to to proper CIE Lch blending for some project and\n\tI couldn't find quality code on the net for the conversions\n\tso I decided to write my own.\n\n\tThen as I was displaying the spaces in 2d to show them off\n\tI thought that it should be possible to use the hardware \n\tderivatives (fwidth) in order to show only the sRGB usable\n\tcolors of said spaces.\n\n\tThen I realized I could push this a little further by doing\n\tthis gradient check along a ray in the native 3d space of\n\tthose manifolds!\n\n\tI start by raymarching a bounding box to the relevant spaces\n\tand then perform gradient checking at every linear step in\n\torder to get the boundaries of the usable sRGB space.\n\n\n\tI inlcuded the forward and reverse transformations for sRGB, \n\tXYZ, Lab and Lch to linear rgb (see second text block) in \n\tthis shader (most are unused)\n*/\n\n\n/*\n\tA little more info about color-space linearity.\n\n\tin order to avoid confusion, I'm using srgb and rgb to represent\n\tsRGB and \"Linear RGB\" color spaces respectively.\n\n\t\"srgb\" color space is inversely correlated to the non-linear response of\n\tcomputer monitors, this should only be applied at the end of your shaders\n\tbecause working in sRGB (doing calculations in that space) will result\n\tin as much color distortion as failing to account for its existence!\n\n\t\"rgb\", is simply non \"monitor corrected\" colors, behaving linearly as you\n\tapply calculations.  Failling to inversely correct these colors (to sRGB)\n\tbefore sending the image to be displayed will result in you tweaking the colors\n\tof your images to compensate for the non-linearity and innacuraties of your\n\tcalculations.\n\n\tThis means that having your XYZ conversions perform RGB linearization\n\tand de-linearization is pointless when working in linear space (as we\n\tshould in all our shaders). That being said, it can indeed be needed\n\twhen working with sRGB corrected material (like most images)\n*/\n\n//Here you can define the color space you want to visualize\n//TYPE 1 = CIE Lab,  TYPE 2 = XYZ (CIE 1931), TYPE 3 = RGB\n#define TYPE 1\n\n//This is only used for the Lab and Lch spaces\n//You can radically change the mapping by varying those values\nconst vec3 wref =  vec3(.95047, 1.0, 1.08883); \n//const vec3 wref =  vec3(1.0,1.,1.);\n\n//If showing Lab space (Type 1), you can use this define to \n//see the difference betweem sRGB mapping and \"Adobe RGB\" mapping\n//#define ABODE_RGB\n\n#define MOUSE_Y_CUTS_SPACE\n\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nvec2 mo;\n\n//---------------------------------------------------------------------------------\n//--------------------------------Color Functions----------------------------------\n//---------------------------------------------------------------------------------\n\n//I'm keeping the functions self-contained, so that will inlcude subsets of each other\n//Example: the forward Lch function includes RGB->XYZ, XYZ->Lab and Lab-Lch\n\n//Equations from: https://en.wikipedia.org/wiki/Lab_color_space\n//and: https://en.wikipedia.org/wiki/SRGB\n//sRGB matrices from: http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n\n//----------------------sRGB----------------------\nfloat sRGB(float t){ return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n//This is only useful if you have non-linear (sRGB) inputs and \n//want to convert them to linear for in-shader calculations\nfloat linearize(float t){ return mix(pow(((t + 0.055)/1.055), 2.4), t / 12.92, step(t, 0.04045)); }\nvec3 linearize(in vec3 c){ return vec3(linearize(c.x), linearize(c.y), linearize(c.z)); }\n\n//----------------------XYZ----------------------\nvec3 rgb2xyz(in vec3 c)\n{\n    return c*mat3(0.4124, 0.3576, 0.1805,\n          \t\t  0.2126, 0.7152, 0.0722,\n                  0.0193, 0.1192, 0.9505);\n}\n\nvec3 xyz2rgb(in vec3 c)\n{\n    vec3 rgb = c*mat3( 3.2406, -1.5372,-0.4986,\n          \t\t      -0.9689,  1.8758, 0.0415,\n    \t\t\t\t   0.0557,  -0.2040, 1.0570);\n    return rgb;\n}\n\n//These are used for Lab and Lch functions\nfloat xyzF(float t){ return mix(pow(t,1./3.), 7.787037*t + 0.139731, step(t,0.00885645)); }\nfloat xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }\n\n//----------------------CIE Lab----------------------\nvec3 rgb2lab(in vec3 c)\n{\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n    \n    c.x = xyzF(c.x/wref.x);\n\tc.y = xyzF(c.y/wref.y);\n\tc.z = xyzF(c.z/wref.z);\n\t\n\treturn vec3(max(0.,116.*c.y - 16.0), 500.*(c.x - c.y), 200.*(c.y - c.z));\n}\n\nvec3 lab2rgb(in vec3 c)\n{   \n    float lg = 1./116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n    \t\t\t\twref.y*xyzR(lg),\n    \t\t\t\twref.z*xyzR(lg - 0.005*c.z));\n    #ifndef ABODE_RGB\n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n          \t\t        -0.9689,  1.8758, 0.0415,\n                \t     0.0557,  -0.2040, 1.0570);\n\t#else\n    vec3 rgb = xyz*mat3( 2.0413690, -0.5649464, -0.3446944,\n\t\t\t\t\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t\t\t\t\t0.0134474, -0.1183897,  1.0154096);\n    #endif\n    return rgb;\n}\n\n//----------------------CIE Lch----------------------\nvec3 rgb2lch(in vec3 c)\n{\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n    c.x = xyzF(c.x/wref.x);\n\tc.y = xyzF(c.y/wref.y);\n\tc.z = xyzF(c.z/wref.z);\n\tvec3 lab = vec3(max(0.,116.0*c.y - 16.0), 500.0*(c.x - c.y), 200.0*(c.y - c.z)); \n    return vec3(lab.x, length(vec2(lab.y,lab.z)), atan(lab.z, lab.y));\n}\n\nvec3 lch2rgb(in vec3 c)\n{\n    c = vec3(c.x, cos(c.z) * c.y, sin(c.z) * c.y);\n    \n    float lg = 1./116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n    \t\t\t\twref.y*xyzR(lg),\n    \t\t\t\twref.z*xyzR(lg - 0.005*c.z));\n    \n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n          \t\t        -0.9689,  1.8758, 0.0415,\n                \t     0.0557,  -0.2040, 1.0570);\n    \n    return rgb;\n}\n\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n\nfloat sbox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    float d=  sbox(p, vec3(1.));\n#ifdef MOUSE_Y_CUTS_SPACE\n#if (TYPE == 1)\n    d = max(d, -sbox(p + vec3(.9 + mo.y*0.35,0.0,0), vec3(1.)));\n#else\n    d = max(d, -sbox(p + vec3(1.4 + mo.y*0.35,0.0,0), vec3(1.)));\n#endif\n#endif\n    return d;\n} \n\nvec3 marchCol(in vec3 ro, in vec3 rd)\n{\n    float h = 1.0;\n    float d = 0.;\n    vec3 col = vec3(0);\n    vec3 colLast = vec3(0);\n    const float prc = 1e-8;\n    const float sz = 115.;\n    for( int i=0; i<240; i++ )\n    {\n        d += clamp(h,0.01,1.);\n        vec3 pos = ro+rd*d;\n    #if (TYPE == 1)\n        vec3 col2 = lab2rgb(vec3(pos.x*sz,pos.y*sz , pos.z*sz));\n    #elif (TYPE == 2)    \n        vec3 col2 = xyz2rgb(vec3(pos.x+0.5, pos.y+0.5, pos.z+0.5));\n    #else\n        vec3 col2 = vec3(pos.x+0.5, pos.y+0.5, pos.z+0.5);\n\t#endif\n        col2 = sRGB(col2);\n        \n        h = map(pos);\n        col2 = clamp(col2, 0., 1.);\n        \n        if (h < 0.)\n        if ((abs(col2.r-colLast.r) > prc)  && (abs(col2.g-colLast.g) > prc) && (abs(col2.b-colLast.b) > prc))\n        {\n        \tcol= col2;\n            break;\n        }\n        colLast = col2;\n    }\n\treturn col;\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tmo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.15,1.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\tmo *= 4.;\n    \n    #if (TYPE == 1)\n\tvec3 ro = vec3(0.,-0.1,3.5);\n    #elif (TYPE == 2)\n    vec3 ro = vec3(0.,0.0,2.5);\n    #else\n    vec3 ro = vec3(0.,0.0,3.0);\n    #endif\n    vec3 rd = normalize(vec3(p,-1.5));\n    float rx = mo.x+time*0.1;\n    float ry = sin(time*0.6)*0.2;\n    ro = rotx(ro,ry), rd = rotx(rd, ry);\n    ro = roty(ro, rx), rd = roty(rd, rx);\n\t\n    vec3 col = marchCol(ro, rd);\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2481, 2481, 2502, 2502, 2554], [3177, 3228, 3248, 3248, 3321], [3322, 3322, 3344, 3344, 3393], [3395, 3519, 3544, 3544, 3618], [3619, 3619, 3645, 3645, 3708], [3710, 3760, 3785, 3785, 3910], [3912, 3912, 3937, 3937, 4085], [4087, 4130, 4150, 4150, 4221], [4222, 4222, 4242, 4242, 4310], [4312, 4366, 4391, 4391, 4667], [4669, 4669, 4694, 4694, 5193], [5195, 5249, 5274, 5274, 5622], [5624, 5624, 5649, 5649, 6026], [6281, 6281, 6310, 6310, 6397], [6399, 6399, 6418, 6418, 6660], [6663, 6663, 6702, 6702, 7535], [7537, 7537, 7564, 7564, 7652], [7653, 7653, 7680, 7680, 7769], [7771, 7771, 7826, 7826, 8454]], "test": "ok"}
{"id": "XddGzn", "name": "Colorful Abyss", "author": "dirkadirkadan", "description": "Wheeeeeeeeeee!", "tags": ["tunnel"], "likes": 7, "viewed": 162, "published": "Public", "date": "1447733475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS .008\n#define X_EPS vec2(EPS,0.)\n#define Y_EPS vec2(0., EPS)\n\nvec3 col(vec2 uv)\n{\n    float time = iTime *.75;\n\n    float x = atan(uv.y,uv.x)/3.14159*3.;\n    float d = dot(uv,uv);\n    float y=.5/d+time; \n    vec2 s = sin(3.14159*vec2(x,y)/.1);\n    float v1=step(s.x*s.y,0.);\n    float v2=cos(x+2.*y);\n    float v=mix(v1,v2,smoothstep(1.,13.,mod(time,16.)));\n    v*=1.-smoothstep(1.2,0.,.8*length(uv)); \n    \n    return vec3(v,v*.2*x,v*v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 c = col(uv)+\n             col(uv+X_EPS)+\n             col(uv+Y_EPS)+\n             col(uv-X_EPS)+\n             col(uv-Y_EPS);\n    c /= 4.;\n    \n    \n    fragColor = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddGzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 92, 92, 451], [453, 453, 510, 510, 765]], "test": "ok"}
{"id": "XdtGRr", "name": "My 21st Birthday", "author": "834144373", "description": "Some bug,it's diffirent between shadertoy and glslsandbox.      My dream is to become a organic chemist,but I can only be seen.\n[url]http://www.glslsandbox.com/e#28924.0[/url]\n[url]http://www.glslsandbox.com/e#28925.0[/url]", "tags": ["3d", "distancefield", "raymarch", "birthday", "happybirthday"], "likes": 4, "viewed": 1130, "published": "Public API", "date": "1447759532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//My 21st Birthday.glsl\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//Created by 834144373 (æ¬çº³å¾®æ™°) ç¥å…ƒæ´ª 2015/11/17\n//Tags: Birthday, 3D, Raymarching,Happy Birthday,Milk and Edge.\n//Original: https://www.shadertoy.com/view/XdtGRr\n//\n//-------Birthday(ç”Ÿæ—¥):11/18\n//-----------------------------------------------------------------------------------------\n#define PI 3.1415\n//#define _PI 3.1415\n#define _2PI 6.2830\n\nfloat scale = 1.5 / 1000.0;\n////////////////////\nvec3 Rot(vec3 p,vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\t    \n    return p*rotX * rotY * rotZ;\n}\nvec3 Rotx(vec3 p,float angle){\n    float c = cos(angle);\n    float s = sin(angle);\t\n    return p*   mat3( c, s, 0.0,-s,c,0.0, 0.0, 0.0, 1.0);\n}\nvec3 Roty(vec3 p,float angle){\n    float c = cos(angle);\n    float s = sin(angle);\t\n    return p*mat3( c, 0.0,-s, 0.0,1.0,0.0, s, 0.0, c);\n    //return p*mat3( c, s, 0.0,-s,c,0.0, 0.0, 0.0, 1.0);\t\n}\n\nvec3 Twist( vec3 p ,float a,float b)\n  {\n      float c = cos(a*p.y);\n      float s = sin(b*p.y);\n      mat2  m = mat2(c,-s,s,c);\n      vec3  q = vec3(m*p.xz,p.y);\n      return q;\n  }\nvec2 plane(vec3 pos,float id){\n\t\n\treturn vec2(pos.y,id);\n}\n\nvec2 plane_x(vec3 pos,float id){\n\treturn vec2(pos.x,id);\n}\nvec2 plane_y(vec3 pos,float id){\n\treturn vec2(pos.z,id);\n}\nvec2 sdPlane( vec3 p, vec4 n, float id )\n{\n  float d =  dot(p,n.xyz) + n.w;\n  return vec2(d,id);\n}\n\nvec2 sphere( vec3 pos,float r,float id){\n\tfloat d = length(pos)-r;\n\treturn vec2(d,id);\n}\n\nvec2 box( vec3 pos,vec3 xyz,float o,float id){\n\tfloat d = length( max(abs(pos)-xyz,0.0))-o;\n\treturn vec2(d,id);\n}\n\nvec2 cylinder(vec3 pos,vec2 h,float id){\n\n\tvec2 d = abs(vec2(length(pos.xz),pos.y)) - h;\n\t\n\treturn vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)),id);\n}\n\nvec2 torus(vec3 pos,vec2 h){\n  vec2 q = vec2(length(pos.xz)-h.x,pos.y);\n  return vec2(length(q)-h.y,1.);\n}\n//------------\n\nfloat dfLine(vec2 start, vec2 end, vec3 p){\n\tstart *= scale;\n\tend *= scale;\n\tvec2 line = end - start;\n\tfloat frac = dot(p.xy - start,line) / dot(line,line);\n\t\n\tfloat d = distance(start + line * clamp(frac, 0.0, 1.0), p.xy);\n\t\n\tfloat dd = length(vec2(d-0.,p.z-0.))-0.01;\n\treturn dd;\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec3 p)\n{\n\torigin *= scale;\n\tradius *= scale;\n\t\n\tfloat d =  abs(length(p.xy - origin) - radius);\n\t\n\tfloat dd = length(vec2(d,p.z))-0.01;\n\treturn dd;\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec3 p)\n{\n\torigin *= scale;\n\tradius *= scale;\n\tp.xy -= origin;\n\tp.xy *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - 3.14);\n\tfloat ang = mod(atan(p.y, p.x) - offs, 6.28) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\tfloat d =  distance(radius * vec2(cos(ang), sin(ang)), p.xy);\n\t\n\tfloat dd = length(vec2(d,p.z))-0.01;\n\treturn dd;\n\t\n}\n//------------\n\n\n\n/////////////////////////////////\nvec2 Min( vec2 d1, vec2 d2 ){\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 Smin(vec2 d1,vec2 d2,float c){\n\tfloat a = abs(1. - abs(d1.x-d2.x));\n\tvec2 b = Min(d1,d2);\n\tfloat d = b.x - exp(-a)/c;\n\treturn vec2(d,b.y);\n}\nvec2 smin(vec2 a, vec2 b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b.x - a.x) / k, 0.0, 1.0);\n\tfloat id = Min(a,b).y;\n\tfloat d = mix(b.x, a.x, h) - k * h * (1.0 - h);\n\treturn vec2(d,id);\n}\n\nvec2 smooth_min (vec2 d1, vec2 d2, float k) {    //inigo quile's min\n    \tfloat a = pow(d1.x, k), b= pow(d2.x, k);\n    \tfloat d = pow((a*b)/(a + b), 1.0/k);\n\treturn vec2(d,Min(d1,d2).y);\n}\n\nvec2 Max( vec2 d1, vec2 d2 )\n{\n  return (d1.x > d2.x) ? d1 : d2;\n}\n\nvec2 Smax( vec2 d1, vec2 d2 )\n{\n  return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n/////////////////////////////////\n\nvec3 opAngRep( vec3 p, float a, float off){\n\tvec2 polar   = vec2(atan(p.y, p.x), length(p.xy));\n\t     polar.x = mod (polar.x + a / 2.0 + off, a) - a / 2.0;\n\treturn vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 insAngObj(vec3 p,vec3 to,float r,float k){\n\tfloat an = atan(p.z,p.x)*4.;\n\t\n\tp.xz = abs(p.xz);\n\tp -= vec3(1.4);\n\treturn p;\n}\n\nvec2 _6( vec3 p, vec2 h ,float id)\n{\n    vec3 q = abs(p);\n    return vec2(max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x),id);\n}\n//////////////////////////\n\n\nvec2 superTwist(vec3 p,float r,float Vertics,float Edges,float id){\n\tfloat edgeAngle  = _2PI / Edges;\n\tfloat vertexAngle  = _2PI / Vertics;\n\tvec3 angrep = opAngRep(p, vertexAngle, 0.0);\t\n\t     angrep = opAngRep(angrep.xzy - vec3(r,0,0), edgeAngle, atan(p.y,p.x) * 2. );\n\tvec2 d = sdPlane(angrep, normalize(vec4(2., .0, 0.0, -0.1)),id);\n\treturn vec2(d.x,id);\n}\n\nvec2 candle(vec3 pos){\n\tvec3 p0,p1,p2,p3,p4;\n\t\n\tp0 = pos;\n\t\tp0.xz = abs(p0.xz)-0.5;\n\tp1 = Roty(pos,PI/3.);\n\t\tp1.xz = abs(p1.xz)-0.5;\n\tp2 = Roty(pos,PI/6.);\n\t\tp2.xz = abs(p2.xz)-0.5;\n\t\n\tp3 = pos;\n    \tp3.xz = abs(p3.xz)-0.21;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //p3.xz = abs(p3.xz)-0.3;\n\tp4 = Roty(pos,PI/4.);\n\t\tp4.xz = abs(p4.xz)-0.21;\n\t\n\tvec2 d0 = box\t   ( p0\t,vec3(0.,0.4,0.)*0.4,0.00, \t1.);\n\tvec2 d1 = box\t   ( p1\t,vec3(0.,0.4,0.)*0.4,0.00, \t1.1); \n\tvec2 d2 = box\t   ( p2\t,vec3(0.,0.4,0.)*0.4,0.00, \t1.2);\n\t\n\tvec2 d3 = box\t   ( p3\t,vec3(0.,0.65,0.)*0.4,0.004, \t1.3);\n\tvec2 d4 = box\t   ( p4\t,vec3(0.,0.65,0.)*0.4,0.004, \t1.4);\n\t\n\tvec2 d;\n\t\td = Min(d0,d1);\t\n\t\td = Min(d,d2);\n\t\n\t\td = Min(d,d3);\n\t\td = Min(d,d4);\n\n\t\td = Min(d,box( pos,vec3(0.,0.9,0.)*0.4,0.008, 1.5));\n\treturn d;\n}\n\nfloat _2_1(vec3 p){\n\tfloat dist = 1.;\n\tp *= 0.4;\n\tp.xy -= vec2(-0.5,.2);\n\t\t\n\tdist = min(dist, dfLine( vec2(300.000,0.000),vec2(200.000,0.000), p));\n\tdist = min(dist, dfLine(vec2(216.371,26.726), vec2(272.714,55.457), p));\n\tdist = min(dist, dfArc(vec2(250.000,100.000),5.184, 4.241, 50.000, p));\n\tdist = min(dist, dfArc(vec2(230.000,0.000),2.042, 1.099, 30.000, p));\n\t\n\tp.xy -= vec2(0.4,0.);\n\tdist = min(dist, dfLine(vec2(150.000,150.000),vec2(150.000,0.000), p));\n\treturn dist;\n}\n\n//85654359\nvec2 otherthing(vec3 pos){\n\t//pos.y *= 2.2;\n\t\n\t//vec2 d = sphere(pos-vec3(0.,-0.45,0.1),.06,8.);\n\tfloat d = _2_1(pos);\n\treturn vec2(d,8.);\n}\n\nvec2 thing(vec3 pos){\n\t//lifang red\n\tvec2 d1 = candle(pos-vec3(0.,-0.022,0.)); \n\t//cylinder  table\n\tvec2 d2 = cylinder(pos-vec3(0.,-1.,0.),\tvec2(1.8,.001),\t\t2.) - vec2(0.01*sin(pos.x*_2PI*6.)+0.01*sin(pos.z*_2PI*4.),0.);\n\t//lifang blue\n\t//vec2 d3 = box     (pos-vec3(1.,-0.7,1.),\t\tvec3(1.,1.,1.)*0.2,  0.,  \t3.);\n\t\n\t//yuanzhu  zi se \n\tvec2 d5 = cylinder(pos-vec3(0.,-.6,0.),\tvec2(0.7,.28),\t\t\t5.);\n\tvec2 d5_1= cylinder(pos-vec3(0.,-1.,0.),\tvec2(0.8,0.1),\t\t\t5.);\n\t\n\t//table\n\tvec2 d6 = cylinder(pos-vec3(0.,-1.02,0.),\tvec2(1.85,0.02),\t\t6. );\n\t\n\t//super\n\tvec2 d7 = superTwist(pos.xzy-vec3(0.,0.,-0.35),0.67,16.,8.,7.);\n\t\t//s.x += 0.01*sin(pos.x*3.*_2PI);\n\t\td5 = Min(d7,d5);\n\t//cho\n\t//vec2 d8 = otherthing(pos);\n\t/////\n\tvec2 d =  Min(d1,d2);\n\t\n\t     d = Min(d,d6);\n\t    // d = Min(d,superTwist(pos.xzy-vec3(0.,1.,0.),0.7,10.,6.,1.));\n\t    //d = Max(d,s);\n\t     //d = Min(d,d8);\n\treturn Min(d,Smin(d5,d5_1,8.));\n}\n\nvec2 evp(vec3 pos){\n\tvec2 d = vec2(1.);\n\t\n\t//plane blue\n\tvec2 d0 = sdPlane (pos-vec3(0.,-4.,0.),normalize(vec4(0.,1.,0.,0.)),\t\t4. );\n\tvec2 d0_1 = plane_x(pos-vec3(-6.4,0.,0.),\t\t\t\t\t4.1);\n\tvec2 d0_2 = plane_y(pos-vec3(0.,0.,-6.4),\t\t\t\t\t4.2);\n\t\t\n\td = Min(Min(d0,d0_1),d0_2);\n\t\n\t//d = Min(d,d1);\n\t\n\treturn d;\n}\n\t\nvec2 obj(vec3 pos){\n\t\n\tvec2 d0 = thing(pos-vec3(0.,0.5,0.));\n\tvec2 d1 = evp(pos);\n\tvec2 d  = Min(d0,d1);\n\treturn d;\n}\n\nvec2 dis(vec3 pos,vec3 p){\n\tfloat dd = 1.;\n\tvec2 d  ;\n\tfor(int i = 0;i<64;++i){\n\t\tvec3 sphere = pos+dd*p;\n\t\td = obj(sphere);\n\t\tdd += d.x;\n\t\tif(d.x<0.02 || dd>20.)break;\n\t}\n\treturn vec2(dd,d.y);\n}\n\nvec3 normal(in vec3 surface){\n\tvec2 offset = vec2(0.01,0.);\n\tvec3 nDir   = vec3(\n\t\tobj(surface + offset.xyy).x,\n\t\tobj(surface + offset.yxy).x,\n\t\tobj(surface + offset.yyx).x\n\t)-obj(surface).x;\n\t\n\treturn normalize(nDir);\n}\n////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat My_edge_shadow(vec3 surface, vec3 lig_p,float mintd, float maxdd, float k0,float k1) {\n\tfloat start_d = mintd;\n\tfloat d = 0.0;\n\tfloat mind = 1.0;\n\tfor(int i = 0; i < 20; i++) {\t\t\n\t\td = obj(surface + start_d*lig_p).x;\n\t\tmind = min(mind, exp(d*k0)/k1 );\n\t\tstart_d += d;\n\t\tif(start_d > maxdd) break;\n\t}\n\treturn mind;\n}\n\nfloat My_milk_shadow(vec3 surface, vec3 lig_p,float mintd, float maxdd, float k0,float k1,float k3) {\n\tfloat start_d = mintd;\n\tfloat d = 0.0;\n\tfloat mind = 1.0;\n\tfor(int i = 0; i < 20; i++) {\t\t\n\t\td = obj(surface + start_d*lig_p).x;\n\t\tmind = min(mind, abs(log(d*k0+k3))/k1 );\n\t\tstart_d += d;\n\t\tif(start_d > maxdd) break;\n\t}\n\treturn mind;\n}\n\nfloat fresnel(vec3 dir,vec3 normal,float k){\n\treturn pow(max(0.,dot(dir,normal)),k);\n}\nfloat My_specular(vec3 vDir,vec3 lig, vec3 normal,float k){\n\tvec3 h = normalize(-vDir+lig);\n\t\tfloat spe = fresnel(h,normal,k);\n\treturn spe;\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 color,in vec2 coord) {\n\n\tvec2 uv = (coord.xy - iResolution.xy/2.)/iResolution.y;\n\tvec2 mo = (iMouse.xy/iResolution.xy-vec2(0.5,0.))*vec2(10.,1.);\n\t\n\tfloat t1 = -.4;// - min(mo.y*1.3,.4);\n\tfloat t2 = iTime*0.1;\n\tfloat t3 = 0.;\n\n\t//ppppp\n\tvec3 p = normalize(vec3(uv,2.));\n\t\tp = Rot(p,vec3(t1,t2+mo.x,t3));\n\t\t//p = Rotx(p,mo.y);\n\t//\n\tvec3 campos = vec3(0.,0.,-6.8);\n\t\tcampos = Rot(campos,vec3(t1,t2+mo.x,t3));\t\n\t\t//campos = Rotx(campos,mo.y);\n\t//\n\tvec2 dd = dis(campos,p);\n\t\n\tvec3 col = vec3(0.8);\n\tif(dd.x<20.){\n\t\tvec3 surface = campos + dd.x*p;\n\t\tvec3 lig  \t= normalize(vec3(1.,1.,-1.));\n\t\t//vec3 lig2 \t= normalize(vec3(-1.,1.,-1.));\n\t\t\n\t\t//vec3 nDir \t= normal(surface);\n\t\t//float diff  \t= max(0.,dot(lig2 ,nDir));\n\t\t//float diff2 \t= max(0.,dot(lig,nDir));\n\t\t//float spe \t= My_specular(p,lig,nDir,5.);\n\t\t//float sh  \t= My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t//float ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n        float sh,ssh;\n\t\tif(dd.y == 1. ){\n\t\t\t sh  = My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t\t ssh = My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(1.,1.,.9)*max(sh,ssh);\n\t\t}\n\t\telse if(dd.y == 1.1){\n\t\t\t sh  = My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t\t ssh = My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(.9,1.,1.)*max(sh,ssh);\n\t\t}\n\t\telse if(dd.y == 1.2){\n\t\t\t sh  \t= My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t\t ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(1.,.9,1.)*max(sh,ssh);\n\t\t}\n\t\telse if(dd.y == 1.3){\n\t\t\t sh  \t= My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t\t ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(1.,1.,1.)*max(sh,ssh);\n\t\t}\n\t\telse if(dd.y == 1.4){\n\t\t\t sh  \t= My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t\t ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(0.9,.9,1.)*max(sh,ssh);\n\t\t}\n\t\telse if(dd.y == 1.5){\n\t\t\t sh  \t= My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t\t ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(0.9,1.+(sin(iTime)+1.)*0.8,0.9)*max(sh,ssh);\n\t\t}\n\t\telse if(dd.y == 2.){\n\t\t\t ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\t\t\t\n\t\t\tcol = vec3(0.6,0.6,0.6)*ssh;\n\t\t}\n\t\t//if(dd.y == 3.){col = vec3(0.,1.,1.)*sh;}\n\t\t\n\t\telse if(dd.y == 4.){\n\t\t\t ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(.7,0.6,.7)*ssh/1.2;\n\t\t}\n\t\telse if(dd.y == 4.1){col = vec3(1.,.5,0.);}\n\t\telse if(dd.y == 4.2){col = vec3(.5,.5,0.);}\n\t\n\t\telse if(dd.y == 5.){\n\t\t\t sh  \t= My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t\t ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(1.,1.,1.)*max(ssh,sh);\n\t\t}\n\t\t\t\t\n\t\telse if(dd.y == 6. ){\n\t\t\tvec3  nDir \t= normal(surface);\n\t\t\tfloat diff  \t= max(0.,dot(lig,nDir));\n\t\t\tfloat spe \t= My_specular(p,lig,nDir,5.);\n\t\t\t sh  \t= My_edge_shadow(surface,lig,.13,1.,8.,3.);\t\n\t\t\tfloat c = mix(diff,pow(1.-diff,2.),0.7);\n\t\t\t      c = mix(c,spe,.7);\n\t\t\tcol = vec3(1.)*mix(c,sh,0.2);\n\t\t}\n\t\telse if(dd.y == 7.){\n\t\t\tssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(0.94,1.,1.)*(ssh);\t\t\t\t\n\t\t}\n\t\telse if(dd.y == 8.){\n\t\t\t//col = vec3(1.,0.,0.)*(spe+diff);\n\t\t\t//surface.xz *= 10.;\n\t\t    ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t\tcol = vec3(1.1,1.,1.4)*ssh;//0.2*mix(vec3(1.7,0.6,0.2),vec3(1.8,1.8,1.2)*2.0,smoothstep(0.7,0.9,0.5+0.7*cos(surface.x*10.0+sin(surface.z*5.0))))+0.06*vec3(1.0,1.0,0.5);\n\t\t\t//col *= diff;\n\t\t\t\n\t\t}\n\t\t\n\t\t//you can uncomment this to see the milk_edge rend\n        //float sh  = My_edge_shadow(surface,lig,.13,1.,8.,3.);\n\t\t//float ssh\t= My_milk_shadow(surface-vec3(0.01,-0.,-0.0),lig,.13,1.,20.,2.5,6.3);\n\t\t//col = vec3(max(sh,shh));\n\t}\n\t\n\tcolor = vec4(col, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtGRr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[529, 550, 580, 580, 876], [877, 877, 907, 907, 1020], [1021, 1021, 1051, 1051, 1219], [1221, 1221, 1261, 1261, 1403], [1404, 1404, 1434, 1434, 1462], [1464, 1464, 1496, 1496, 1522], [1523, 1523, 1555, 1555, 1581], [1582, 1582, 1624, 1624, 1680], [1682, 1682, 1722, 1722, 1770], [1772, 1772, 1818, 1818, 1885], [1887, 1887, 1927, 1927, 2040], [2042, 2042, 2070, 2070, 2148], [2165, 2165, 2208, 2208, 2448], [2450, 2486, 2537, 2537, 2678], [2680, 2702, 2776, 2776, 3158], [3177, 3211, 3240, 3240, 3276], [3278, 3278, 3313, 3313, 3423], [3424, 3424, 3460, 3460, 3612], [3614, 3614, 3659, 3682, 3802], [3804, 3804, 3834, 3834, 3870], [3872, 3872, 3903, 3903, 3951], [3987, 3987, 4030, 4030, 4206], [4208, 4208, 4255, 4255, 4336], [4338, 4338, 4374, 4374, 4467], [4497, 4497, 4564, 4564, 4856], [4858, 4858, 4880, 4880, 5642], [5644, 5644, 5663, 5663, 6123], [6125, 6136, 6162, 6232, 6276], [6278, 6278, 6299, 6313, 7185], [7187, 7187, 7206, 7206, 7492], [7495, 7495, 7514, 7514, 7612], [7614, 7614, 7640, 7640, 7809], [7811, 7811, 7840, 7840, 8031], [8074, 8186, 8278, 8278, 8507], [8509, 8509, 8610, 8610, 8847], [8849, 8849, 8893, 8893, 8935], [8936, 8936, 8995, 8995, 9077], [9078, 9193, 9239, 9239, 13072]], "test": "timeout"}
{"id": "Xl2SW3", "name": "fork of \"Sculpture III\"", "author": "mattdesl", "description": "fork of iq' https://www.shadertoy.com/view/XtjSDK with small camera changes", "tags": ["raymarch", "sphere", "fork", "sculpture"], "likes": 1, "viewed": 897, "published": "Public API", "date": "1446914468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat hash1( in vec2 f ) \n{ \n    return fract(sin(f.x+131.1*f.y)*43758.5453123); \n}\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat sca = 0.5 + 0.15*sin(iTime-10.0);\nvec4 grow = vec4(1.0);\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += 1.000*sin(  2.0*p.yzx )*grow.x;\n    p.xyz += 0.500*sin(  4.0*p.yzx )*grow.y;\n    p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;\n    p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;\n    return p;\n}\n\nfloat map( vec3 q )\n{\n    vec3 p = mapP( q );\n    float d = length( p ) - 1.5;\n\treturn d * 0.05;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<1256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.005,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*1.0 )*32.0, 0.0, 1.0 );\n    }\n\tao /= 64.0;\n\t\n    return clamp( ao*ao, 0.0, 1.0 );\n}\n\nfloat calcAO2( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*0.2 )*100.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 q = fragCoord/iResolution.xy;\n\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n\n    \n    grow = smoothstep( 0.0, 1.0, (iTime-vec4(0.0,1.0,2.0,3.0))/3.0 );\n\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = 1.1 + 0.05*(iTime-10.0) - 7.0*m.x;\n\n\tvec3 ro = vec3(6.5*sin(an),1.0,6.5*cos(an));\n    vec3 ta = vec3(0.0,-0.0,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n\t// raymarch\n    float t = intersect(ro,rd);\n\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        vec3 sor = nor;\n        \n        vec3 q = mapP( pos );\n        float occ = calcAO( pos, nor, fragCoord ); occ = occ*occ;\n\n        // materials\n\t\tcol = vec3(0.04);\n        float ar = clamp(1.0-0.7*length(q-pos),0.0,1.0);\n        col = mix( col, vec3(2.1,2.0,1.2), ar);\n        col  *= 0.3;          \n        col *= mix(vec3(1.0,0.4,0.3), vec3(0.8,1.0,1.3), occ);\n        float occ2 = calcAO2( pos, nor, fragCoord );\n        \n        \n        col *= 1.0*mix( vec3(2.0,0.4,0.2), vec3(1.0), occ2*occ2*occ2 );\n        float ks = texCube( iChannel0, pos*1.5, nor, 4.0 ).x;\n        ks = 0.5 + 1.0*ks;\n        ks *= (1.0-ar);\n        \n        // lighting\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = pow(max( dot(-rd,nor),0.0),8.0);\n\t\t// lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky*occ;\n             lin += 1.0*fre*vec3(1.2,0.70,0.60)*(0.1+0.9*occ);\n        col += 0.3*ks*4.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.05+0.95*pow(fre,5.0))*(0.5+0.5*nor.y)*occ;\n        col += 4.0*ks*1.5*spe*occ*col.x;\n        col += 2.0*ks*1.0*pow(spe,8.0)*occ*col.x;\n        col = col * lin;\n\n        // dust\n        col = mix( col, 0.2*fre*fre*fre+0.6*vec3(0.6,0.55,0.5)*sky*(0.8+0.4*texCube( iChannel0, pos*8.0, nor, 4.0 ).xyz), 0.6*smoothstep(0.3,0.7,nor.y)*sqrt(occ) );\n        \n        col *= 2.6*exp(-0.2*t);\n    }\n\n\tcol = pow(col,vec3(0.4545));\n\n    col = pow( col, vec3(1.0,1.0,1.4) ) + vec3(0.0,0.02,0.14);\n    \n    col += (1.0/255.0)*hash1( fragCoord );\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2SW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[126, 126, 150, 150, 192], [194, 194, 221, 221, 277], [386, 386, 422, 422, 598], [664, 664, 685, 685, 881], [883, 883, 904, 904, 981], [983, 983, 1026, 1026, 1281], [1283, 1283, 1315, 1315, 1526], [1528, 1528, 1583, 1583, 1860], [1862, 1862, 1918, 1918, 2193], [2195, 2195, 2260, 2260, 2444], [2446, 2446, 2503, 2503, 5207]], "test": "error"}
{"id": "XlBSD3", "name": "2d experiment #7 - pii", "author": "public_int_i", "description": "lejljh", "tags": ["sjkldhfh"], "likes": 0, "viewed": 300, "published": "Public API", "date": "1446744160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv *= 7.+sin(iTime*.1)*4.;\n    uv += vec2(sin(iTime*.33),cos(iTime*.2))*3.;\n\t\n    for (int i = 0; i < 4; i++) {\n        float ang = abs(atan(uv.y,uv.x))/4.+\n            cos((abs(uv.x)+abs(uv.y))/1.5);\n        uv *= mat2(sin(ang), cos(ang), -cos(ang), sin(ang));\n    }\n    \n    float dst = max(0., 1.-(length(max(abs(sin(uv))-.1,0.))));\n    fragColor = vec4(cos(dst*16.+iTime)*.5+.5,\n                     dst,\n                     dst,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 549]], "test": "ok"}
{"id": "XlBSzd", "name": "dancing light orbs", "author": "public_int_i", "description": "dancing light orbs", "tags": ["3d", "light", "dancing", "orbs"], "likes": 11, "viewed": 232, "published": "Public", "date": "1447262795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy,\n        uv = (fragCoord - .5*R) / iResolution.y;\n    \n    vec3 rp = vec3(0.,0.,iTime);\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    vec3 c = vec3(0.);\n    float s = 0.;\n    \n    for (int i = 0; i < 74; i++) {\n        vec3 hp = rp+rd*s;\n        float d = length(cos(hp*.6+\n                             cos(hp*.3+iTime*.5)))-.2;\n        float cc = clamp(1.-(d*.5+(d*5.)/s),-1.,1.);\n        \n        c += (cos(vec3(hp.xy,s))*.5+.5 + cos(vec3(s+iTime,hp.yx)*.1)*.5+.5 + 1.)/3.\n              *cc*.02;\n        \n        s += d;\n        rd = normalize(rd+vec3(d*.01,d*-.006,0.));\n    }\n    \n    fragColor = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 698]], "test": "ok"}
{"id": "XlBXDw", "name": "Future_", "author": "shezard", "description": "f", "tags": ["f"], "likes": 21, "viewed": 294, "published": "Public", "date": "1447185315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define TAU 6.28318530718\n\nconst float MAT0 = 0.0;\nconst float MAT1 = 1.0;\nconst float MAT2 = 2.0;\nconst float MAT3 = 3.0;\n\nfloat smin(float a, float b) {\n    \n    float k = 0.05;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat noise(in vec2 uv) {\n\treturn sin(1.5*uv.x)*sin(1.5*uv.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n    f += 0.5000*noise(uv); uv = m*uv*2.02;\n    f += 0.2500*noise(uv); uv = m*uv*2.03;\n    f += 0.1250*noise(uv); uv = m*uv*2.01;\n    f += 0.0625*noise(uv);\n    return f/0.9375;\n}\n\nfloat fbm2(in vec2 uv) {\n   vec2 p = vec2(fbm(uv + vec2(0.0,0.0)),\n                 fbm(uv + vec2(5.2,1.3)));\n\n   return fbm(uv + 4.0*p);\n}\n\nfloat rand(in vec2 uv) {\n    return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat voronoi(vec2 coord) {\n    vec2 coordInt = floor(coord);\n    vec2 coordFraction = fract(coord);\n    \n\tfloat result = 8.0;\n    for (int i = -1; i <= 1; i++)\n    \tfor (int j = -1; j <= 1; j++)\n        {\n         \tvec2 cellPoint = vec2(float(i), float(j));\n            \n            float offset = rand(coordInt + cellPoint);\n            offset = 0.5 + 0.5*sin( iTime + 6.2831*offset );\n            \n            vec2 randomPoint = cellPoint + offset - coordFraction;\n            float d = dot(randomPoint, randomPoint);\n            \n            result = min(result, d);\n            \n        } \n    return (sqrt(result));\n}\n\nvec2 add(in vec2 a, in vec2 b) {\n \n    float mat;\n    if(a.x < b.x) {\n      mat = a.y;\n    } else {\n      mat = b.y;\n    }\n    \n    return vec2(smin(a.x,b.x), mat);\n}\n\nvec2 sub(in vec2 a, in vec2 b) {\n    \n    float mat;\n    if(a.x < b.x) {\n      mat = b.y;\n    } else {\n      mat = a.y;\n    }\n    \n    return vec2(max(a.x, b.x), mat);\n}\n\nvec3 rep(in vec3 p, in vec3 c) {\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec2 rotate(in vec2 p, in float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 torus(in vec3 p, in vec2 t, in float mat) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec2(length(q)-t.y, mat);\n}\n\nvec2 sphere(in vec3 p, in float r, in float mat) {\n    return vec2(length(p) - r, mat);\n}\n\nvec2 plane(in vec3 p, in vec4 n, in float mat) {\n  return vec2(dot(p,n.xyz) + n.w, mat);\n}\n\nvec2 cylinder(in vec3 p, in vec3 c, in float mat) {\n  return vec2(length(p.xz-c.xy)-c.z, mat);\n}\n\nvec2 box(in vec3 p, in vec3 b, in float mat) {\n  return vec2(\n      length(\n          max(abs(p)-b,0.0)\n      ) * length(p*.05)\n  , mat);\n}\n\nfloat map(in vec3 p, inout float mat) {\n   \n\tvec2 scene = vec2(999.0, MAT0);\n\n    float lp = length(p);\n    \n\tvec2 s1 = box(p, vec3(.25), MAT0);\n\n\tscene = add(scene, s1);\n\n    p = rep(p, vec3(.5));\n    \n    vec2 s = sphere(p, length(p) * .5, MAT1);\n    scene = add(scene, s);\n    \n\tmat = scene.y;\n    \n \treturn scene.x;\n}\n\nmat3 setLookAt(in vec3 ro, in vec3 ta,in float cr) {\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    \n    float mat = MAT3;\n    for( int i = 0; i < 16; i++ ) {\n\t\tfloat h = map(ro + rd*t, mat);\n        res = min( res, 4.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // camera\t\n    vec3 ro = vec3(\n        -1.7*cos(iTime * .5),\n        .0,\n        1.7*sin(iTime * .5)\n   \t);\n    vec3 ta = vec3(0.0);\n    float roll = 0.0;\n\n    // camera tx\n    mat3 ca = setLookAt( ro, ta, roll );\n    vec3 rd = normalize( ca * vec3(p.xy,1.75) );\n\n    float t = 0.001;    // Near\n    float tmax = 120.0; // Far\n   \t\n    float h = 0.001;\n    float hmax = 0.001;\n    \n    float mat = MAT0;\n    \n    vec3 c = vec3(0.0);\n    vec3 ao = vec3(0.0);\n    \n    const int steps = 100;\n    for(int i = 0 ; i < steps ; i++) {\n        \n        if(h < hmax || t > tmax ) {\n        \tao = vec3(1.0) - float(i)/float(steps);\n            break;\n        }\n        \n        h = map(ro + t *rd, mat);\n        t += h;\n    }\n    \n    if(t < tmax) {\n        vec3 pos = ro+rd*t;\n        \n        vec2 r = vec2(0.001,0.0);\n        vec3 nor = normalize(vec3(map(pos+r.xyy, mat)-map(pos-r.xyy, mat),\n                                  map(pos+r.yxy, mat)-map(pos-r.yxy, mat),\n                                  map(pos+r.yyx, mat)-map(pos-r.yyx, mat)));\n      \tvec3 ref = reflect(rd,nor);\n        \n        if(mat == MAT0) {\n          c = vec3(1.0,0.0,0.0);\n        }\n        \n        if(mat == MAT1) {\n          c = vec3(1.0); \n        }\n        \n        vec3 lig = vec3(0.5773);\n        c *= softshadow(pos, lig, 0.03, 4.0);\n        c *= clamp(dot(nor,lig), 0.1, 1.0);\n        \n        c *= 1.0 + clamp(dot(ref,lig), 0.0, .5) * .3;\n        \n        c *= 1.0 + ao * 20.;\n        \n        c += vec3(.1,.5,.9) * abs(pos.x * pos.y * pos.z) * .5 * length(1.0 / p * p);\n        \n        c = rgb2hsv(c);\n        \n        c.y *= 1.01;\n        c.z *= 1.5;\n        \n        c.x += length(p) + fbm2(pos.xy) *.1;\n        \n        c = hsv2rgb(c);\n    } \n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 170, 170, 288], [290, 290, 312, 312, 643], [645, 645, 667, 667, 836], [838, 838, 863, 863, 902], [955, 955, 975, 975, 1173], [1175, 1175, 1199, 1199, 1314], [1316, 1316, 1340, 1340, 1412], [1414, 1414, 1441, 1441, 2037], [2039, 2039, 2071, 2071, 2205], [2207, 2207, 2239, 2239, 2376], [2378, 2378, 2410, 2410, 2455], [2457, 2457, 2495, 2495, 2582], [2584, 2584, 2632, 2632, 2708], [2710, 2710, 2760, 2760, 2799], [2801, 2801, 2849, 2849, 2891], [2893, 2893, 2944, 2944, 2989], [2991, 2991, 3037, 3037, 3130], [3132, 3132, 3171, 3171, 3453], [3455, 3455, 3507, 3507, 3688], [3690, 3690, 3762, 3762, 4050], [4052, 4052, 4109, 4109, 5990]], "test": "ok"}
{"id": "XlBXWK", "name": "for coco_gigpn", "author": "Dermenslof", "description": "comment", "tags": ["polaire"], "likes": 1, "viewed": 146, "published": "Public", "date": "1446377642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.004\n\n#define BUTTERFLY\n\nvec2 rot(in vec2 uv, float a)\n{\n    a = radians(a);\n    float c, s;\n    c = cos(a);\n    s = sin(a);\n    return vec2(uv.x * c + uv.y * s, uv.x * -s + uv.y * c);\n}\n\nvec3 f(in vec2 uv, in float radius)\n{\n    for (float a=0.0; a < 6.28 * 2.; a += .01)\n    {\n        float co = cos(a);\n        float co4 = cos(4. * a);\n    \tfloat p = radius * (exp(co) - 2. * co4 - pow(sin(a / 12.), 5.));\n        //vec2 xy = p * vec2(co, sin(a));\n    \tfloat x = abs(p * co);\n    \tfloat y = abs(p * sin(a));\n    \n        if (abs(uv.x) < x + EPS && abs(uv.x) > x - EPS && abs(uv.y) < y + EPS && abs(uv.y) > y - EPS)\n            return vec3(abs(rot(vec2(x, abs(x - y)), iTime * 50.)), y);\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    #ifndef BUTTERFLY\n    \tuv.x *= iResolution.x / iResolution.y;\n    #else\n    \tuv.x *= ((abs(sin(mod(iTime * 2.0, 360.))) * 2. + 1.) * iResolution.x) / iResolution.y;\n    \tuv.y += sin(uv.x + 1.56) - .8;\n\t#endif\n    fragColor = vec4(f(uv, .2), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 69, 69, 199], [201, 201, 238, 238, 730], [732, 732, 787, 787, 1092]], "test": "ok"}
{"id": "XljSWK", "name": "CSG Lichtspiel", "author": "MacSlow", "description": "Trying out some things like different colors/materials per object, skipping lights for receiving shadows...", "tags": ["raymarching", "csg"], "likes": 5, "viewed": 252, "published": "Public", "date": "1446652629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Basic raymarching-renderer\n//\n// Copyright 2015 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265358979323846;\nconst vec4 red   = vec4 (1., .0, .0, 1.);\nconst vec4 green = vec4 (.0, 1., .0, 1.);\nconst vec4 white = vec4 (1.);\nconst vec4 black = vec4 (.0, .0, .0, 1.);\nconst int MAX_STEPS = 64;\nconst float epsilon = 0.0001;\n\nmat4 trans (vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (.0, .0, 1., .0),\n                     vec4 (t.x, t.y, t.z, 1.));\n    return mat;\n}\n\nvec3 opTransf (vec3 p, mat4 m)\n{\n    return vec4 (m * vec4 (p, 1.)).xyz;\n}\n\nmat4 rotX (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (1.0, 0.0, 0.0, 0.0),\n                     vec4 (0.0,   c,   s, 0.0),\n                     vec4 (0.0,  -s,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, 0.0,  -s, 0.0),\n                     vec4 (0.0, 1.0, 0.0, 0.0),\n                     vec4 (  s, 0.0,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, 0.0, 0.0),\n                     vec4 ( -s,   c, 0.0, 0.0),\n                     vec4 (0.0, 0.0, 1.0, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nfloat opSubtract (float d1, float d2)\n{\n    return max (-d1, d2);\n}\n\nfloat opIntersect (float d1, float d2)\n{\n    return max (d1, d2);\n}\n\nfloat sphere (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat box (vec3 p, vec3 b, float r)\n{\n    return length (max (abs (p) - b + vec3 (r), .0)) - r;\n}\n\nfloat cylinder (vec3 p, vec3 n)\n{\n    return length (p.xz - n.xy) - n.z;\n}\n\nfloat wavyfloor (vec3 p, vec4 n)\n{\n    float tm = iTime;\n    return dot (p.xyz, n.xyz) + n.w - .1 * sin (4. * p.x) * cos (4. * p.z);\n}\n\nfloat csgdice (vec3 p)\n{\n    float d1 = .0;\n    float d2 = .0;\n\n    // dice with holes\n    mat4 m = trans (vec3 (.0, .0, .0));\n    mat4 m1 = rotX (90.) * trans (vec3 (.35, .5, 2.75));\n    mat4 m2 = trans (vec3 (.35, .2, .5));\n    d1 = opIntersect (box (opTransf (p, m), vec3 (.55), .0),\n                      sphere (opTransf (p, m), .7));\n    d2 = opSubtract (cylinder (opTransf (p, m1), vec3 (.35, .5, .35)),\n                     d1);\n    d1 = opSubtract (cylinder (opTransf (p, m2), vec3 (.35, .5, .35)),\n                     d2);\n    m1 = rotZ (90.) * trans (vec3 (1.25, -.35, .5));\n    d2 = opSubtract (cylinder (opTransf (p, m1), vec3 (.35, .5, .35)), d1);\n\n    return d2;\n}\n\nfloat map (vec3 p, inout int index, bool withoutlights)\n{\n    float d = .0;\n    float ground = .0;\n    float dicea = .0;\n    float diceb = .0;\n    float lighta = .0;\n    float lightb = .0;\n    float t = iTime;\n\n    // floor\n    ground = wavyfloor (p, normalize (vec4 (.0, -1., .0, 1.)));\n\n    // first dice\n    mat4 m = rotX (30. * t) * rotY (40. * t) * rotZ (50. * t) * trans (vec3 (.0, .5, 1.));\n    dicea = csgdice (opTransf (p, m));\n\n    // second dice\n    m = rotX (40. * t) * rotY (50. * t) * rotZ (30. * t) * trans (vec3 (-2., .5, 1.));\n    diceb = csgdice (opTransf (p, m));\n\n    d = min (ground, min (dicea, diceb));\n\n    // \"lightsources\"\n    if (!withoutlights) {\n        m = trans (vec3 (.0, .5, 1.));\n        lighta = sphere (opTransf (p, m), .05);\n        m = trans (vec3 (-2., .5, 1.));\n        lightb = sphere (opTransf (p, m), .05);\n        d = min (d, min (lighta, lightb));\n        if (d == lighta || d == lightb) {\n            index = 4;\n        }\n    }\n\n    // assign \"color/material\"-index\n    if (d == ground) {\n        index = 1;\n    } else if (d == dicea) {\n        index = 2;\n    } else if (d == diceb) {\n        index = 3;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec3 e = vec3 (.0001, .0, .0);\n    int index = 0;\n\n    vec3 n = vec3 (map (p + e.xyy, index, false) - map (p - e.xyy, index, false),\n                   map (p + e.yxy, index, false) - map (p - e.yxy, index, false),\n                   map (p + e.yyx, index, false) - map (p - e.yyx, index, false));\n\n    return normalize (n);\n}\n\nfloat shadow (vec3 ro, vec3 rd, float tmin, float k)\n{\n    float s = 1.;\n    float d = .0;\n    float t = tmin;\n    int index = 0;\n    for (int i = 0; i < 64; i++) {\n        d = map (ro + rd * t, index, true);\n        if (d < epsilon) {\n            return .0;\n        }\n        s = min (s, k * d / t);\n        t += d*.75;\n    }\n    return s;\n}\n\nvec4 shade (vec3 p, vec4 color)\n{\n\t// animate the light-sources a bit\n    float t = 1.5 * iTime;\n    vec3 lPos0 = vec3 (.0, -.5, -1.);\n    vec3 lPos1 = vec3 (4. * cos (radians (1.)), -4., 4. * sin (radians (1.)));\n    vec3 lPos2 = vec3 (2., -.5, -1.);\n\n    vec4 lCol = white;\n    vec3 n = normal (p);\n    vec3 lDir0 = normalize (lPos0 - p);\n    vec3 lDir1 = normalize (lPos1 - p);\n    vec3 lDir2 = normalize (lPos2 - p);\n    vec4 lInt0 = lCol * max (dot (n, lDir0), .0);\n    vec4 lInt1 = lCol * max (dot (n, lDir1), .0);\n    vec4 lInt2 = lCol * max (dot (n, lDir2), .0);\n    vec4 col = shadow (p+.001*normalize (lPos0 - p), normalize (lPos0 - p), .001, 64.) * .7 * lInt0 * color;\n    col += shadow (p+.001*normalize (lPos1 - p), normalize (lPos1 - p), .001, 64.) * .7 * lInt1 * color;\n    col += shadow (p+.001*normalize (lPos2 - p), normalize (lPos2 - p), .001, 64.) * .7 * lInt1 * color;\n\n    return col;\n}\n\nmat3 camera (vec3 eye, vec3 aim, float r)\n{\n    vec3 cw = normalize (aim - eye);\n    vec3 cp = vec3 (sin (r), cos (r), .0);\n    vec3 cu = normalize (cross (cw, cp));\n    vec3 cv = normalize (cross (cu, cw));\n    return mat3 (cu, cv, cw);\n}\n\nfloat march (vec3 ro, vec3 rd, float pixelSize, inout int index)\n{\n    bool forceHit = true;\n    float infinity = 10000.0;\n    float t_min = .00001;\n    float t_max = 100.0;\n    float t = t_min;\n    float candidate = t_min;\n    float candidate_error = infinity;\n    float w = .5;\n    float lastd = .0;\n    float stepSize = .0;\n    int mindex = 0;\n    float sign = map (ro, mindex, false) < .0 ? -1. : 1.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n\t{\n        float signedd = sign * map (ro + rd * t, index, false);\n        float d = abs (signedd);\n        bool fail = w > 1. && (d + lastd) < stepSize;\n\n        if (fail) {\n            stepSize -= w * stepSize;\n            w = .25;\n        } else {\n            stepSize = signedd * w;\n        }\n\n\t\tlastd = d;\n\n        float error = d / t;\n        if (!fail && error < candidate_error) {\n            candidate_error = error;\n            candidate = t;\n        }\n\n        if (!fail && error < pixelSize || t > t_max) {\n        \tbreak;\n\t\t}\n\n        t += stepSize;\n \n\t}\n\n    if ((t > t_max || candidate_error > pixelSize) && !forceHit) {\n        return infinity;\n    }\n\n\treturn candidate;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (8. * mouse.x + 25.) * 9.,\n\t\t\t\t\t -6.,\n\t\t\t\t\t sin (8. * mouse.x + 25.) * 9.);\n    vec3 aim = vec3 (.0, .0, .0);\n    mat3 cam = camera (eye, aim, .0);\n    vec2 uv = vec2 (-.75 + fragCoord.x / iResolution.y, .5 - fragCoord.y / iResolution.y);\n\n    vec3 ro = eye;\n    vec3 rd = cam * normalize (vec3 (uv, 1.8));\n    vec4 bg = vec4 (.0);\n    float pixelSize = 1. / iResolution.x;\n    int index = 0;\n    float t = march (ro, rd, pixelSize, index);\n    vec4 color;\n    if (index  == 1) {\n\t    color = mix (shade (ro + rd * t, white), bg, length (rd * t) / 30.);\n    } else if (index == 2) {\n    \tcolor = mix (shade (ro + rd * t, red), bg, length (rd * t) / 30.);\n    } else if (index == 3) {\n    \tcolor = mix (shade (ro + rd * t, green), bg, length (rd * t) / 30.);\n    } else if (index == 4) {\n    \tcolor = white;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljSWK.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1164, 1164, 1185, 1185, 1383], [1385, 1385, 1417, 1417, 1459], [1461, 1461, 1489, 1489, 1785], [1787, 1787, 1815, 1815, 2111], [2113, 2113, 2141, 2141, 2437], [2439, 2439, 2478, 2478, 2506], [2508, 2508, 2548, 2548, 2575], [2577, 2577, 2609, 2609, 2638], [2640, 2640, 2677, 2677, 2737], [2739, 2739, 2772, 2772, 2813], [2815, 2815, 2849, 2849, 2949], [2951, 2951, 2975, 2975, 3631], [3633, 3633, 3690, 3690, 4805], [4807, 4807, 4829, 4829, 5160], [5162, 5162, 5216, 5216, 5504], [5506, 5506, 5539, 5575, 6414], [6416, 6416, 6459, 6459, 6655], [6657, 6657, 6723, 6723, 7791], [7793, 7793, 7849, 7849, 8758]], "test": "timeout"}
{"id": "XljXDV", "name": "2015/11/07", "author": "hughsk", "description": "Expanding on 2015/11/04: https://www.shadertoy.com/view/Xt2SDV\n\nThis adds multiple colored point lights, makes the circles a little more disorderly and blobs them in from the edges.", "tags": ["2d", "shadow", "light", "point"], "likes": 10, "viewed": 1074, "published": "Public API", "date": "1446950350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 80\n\n#define sr(a) (a * 2.0 - 1.0)\n#define rs(a) (a * 0.5 + 0.5)\n#define sq(a) (a * vec2(1, iResolution.y / iResolution.x))\n\nfloat random(vec2 co) {\n   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat t = iTime * 1.;\n\nfloat map(vec2 p, vec4 ro) {\n    vec2 P = p;\n    \n    float w = 0.15;\n    float r = 0.03125;\n    float a = t;\n    float d = 0.0;\n    \n    p.y += iTime * 0.15;\n    \n    vec2 idx = floor(p / w * 0.5 + 0.5);\n    \n    r += sin((idx.x + idx.y) * 2. + t * 5.) * 0.009;\n    a += sin((idx.x + idx.y) * 2.);\n    a += random(idx) * 5.;\n    \n    p = mod(p + w, w * 2.) - w;\n    d = length(p - 0.095 * vec2(sin(a), cos(a))) - r;\n    d = smin(d, length(P) - 0.25, 0.05);\n    \n    // \"push\" away any surfaces close to the lights\n    d = -smin(-d, length(P - ro.xy) - 0.05, 0.05);\n    d = -smin(-d, length(P - ro.zw) - 0.075, 0.05);\n    d = smin(d, -sdBox(P, sq(vec2(1))), 0.065);\n    \n\treturn d;\n}\n\nfloat shadow(vec2 uv, vec2 ro, vec2 rd, vec4 lights) {\n    float lim = 0.0005;\n    float res = -1.0;\n    float inc = lim * 2.0;\n    float t = inc;\n    float maxt = length(ro - uv);\n    \n    if (map(uv, lights) < 0.0) return 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        if (t >= maxt) return -1.0;\n        float d = map(uv - rd * t, lights);\n        if (d <= 0.0) return 0.0;\n        \n        t = min(t + d * 0.2, maxt);\n        res = t;\n    }\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = sq(sr(fragCoord.xy / iResolution.xy));\n    vec2 ro1 = (iMouse.z > 0.\n        ? sq(sr(iMouse.xy / iResolution.xy))\n        : 0.5 * vec2(\n            sin(iTime),\n            cos(iTime)\n        ));\n    \n    vec2 ro2 = (sin(iTime * 0.2) + 2.5) * 0.15 * vec2(cos(iTime), sin(iTime));\n    vec4 lights = vec4(ro1, ro2);\n    \n    vec2 rd1 = normalize(uv - ro1);\n    vec2 rd2 = normalize(uv - ro2);\n    float s1 = shadow(uv, ro1, rd1, lights) > -0.5 ? 0.35 : 1.0;\n    float s2 = shadow(uv, ro2, rd2, lights) > -0.5 ? 0.35 : 1.0;\n    float l1 = s1 * pow(max(0.0, 1.0 - length(ro1 - uv) * 0.8), 2.5);\n    float l2 = s2 * pow(max(0.0, 1.0 - length(ro2 - uv) * 0.8), 2.5);\n    float d = map(uv, lights);\n    \n    vec3 lcol1 = vec3(1, 0.5, 0.3);\n    vec3 lcol2 = vec3(0, 1, 1);\n    \n    bool inside = d < 0.0;\n    bool stroke = d > -0.005 && inside; \n    vec3 m = inside ? vec3(stroke ? 0 : 5) : vec3(1, 0.9, 0.7);\n    \n\tfragColor = vec4(m * (l1 * lcol1 + l2 * lcol2), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 161, 161, 231], [233, 233, 272, 272, 371], [373, 373, 404, 404, 482], [507, 507, 535, 535, 1190], [1192, 1192, 1246, 1246, 1668], [1671, 1671, 1728, 1728, 2700]], "test": "ok"}
{"id": "XljXWV", "name": "Strange Water", "author": "LucaHofmann", "description": "Strange water", "tags": ["water"], "likes": 3, "viewed": 162, "published": "Public", "date": "1446581677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// This is the noise algorithm that I used:\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 div = vec2(10, 10);\n\tvec2 uv = fragCoord.xy / iResolution.xy * div.xy;\n\tvec3 v = vec3(\n        uv.x + sin(iTime) * 0.2, \n        uv.y + cos(iTime) * 0.2, \n        iTime / 10.0);\n\n    \n\n    float noise = snoise(v);\n\tuv = fragCoord.xy / iResolution.xy * div.xy;\n    vec3 v2 = vec3(uv.x , uv.y, iTime / 5.0);\n    noise = sin(noise * 3.14 * (sin(iTime) + snoise(v2)) * 10.75);\n    \n    float darkenFactor = 0.2;\n    float darkenValue = darkenFactor;\n\n    div = vec2(5, 5);\n    uv = fragCoord.xy / iResolution.xy * div.xy;\n    vec3 v3 = vec3(uv.x, uv.y, iTime / 2.0);\n    darkenValue = darkenValue * snoise(v3);\n    \n    vec3 v4 = vec3(uv.x * 1000.0, uv.y * 1000.0, iTime);  \n\n    float b = snoise(v4) * 0.1;\n     \n    fragColor = vec4(b,\n                     noise - b,\n                     1.0 - darkenValue + (noise * (darkenValue + 0.2)) - b,\n                     1.0);\n    \n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXWV.jpg", "access": "shaders20k", "license": "mit", "functions": [[439, 439, 460, 460, 509], [511, 511, 532, 532, 581], [583, 583, 605, 605, 645], [647, 647, 675, 675, 727], [729, 729, 753, 753, 2899], [2902, 2902, 2959, 2959, 3846]], "test": "ok"}
{"id": "XlSGR3", "name": "Raycasted spheres", "author": "Aj_", "description": "My first attempt at creating a raycasted scene using intersection equations and all. Not optimized. \nAlso could anyone tell me why lines 80 and 89 doesn't work (when uncommented)?", "tags": ["raycast"], "likes": 3, "viewed": 2014, "published": "Public API", "date": "1446991137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_PRIMS = 4;\t//number of spheres in the scene\nconst int NUM_LIGHTS = 4; //number of lights in the scene\nconst float FAR = 100.;\t//far clipping plane distance\n\n#define MRX(X) mat3(1., 0., 0. ,0., cos(X), -sin(X) ,0., sin(X), cos(X))\t//x axis rotation matrix\n#define MRY(X) mat3(cos(X), 0., sin(X),0., 1., 0.,-sin(X), 0., cos(X))\t//y axis rotation matrix\t\n#define MRZ(X) mat3(cos(X), -sin(X), 0.\t,sin(X), cos(X), 0.\t,0., 0., 1.)\t//z axis rotation matrix\n#define MRF(X,Y,Z) MRZ(Z)*MRY(Y)*MRX(X)\t//x,y,z combined rotation macro\n\nstruct Primitive {\t//structure for representing primitves\n    vec3 forward;\t//forward of the primitive. Only applicable to planes\n    float id;\t//id for indentifying the object\n    vec3 pos;\t//positionof the object in the world space\n    vec3 normal;\t//surface normal at the point of intersection\n    float size;\t//size of the object. only applicable to some primitive like spheres\n    bool isIntersected ;\t//used to store ray intersection status\n    vec3 intersecPoint;\t//point of intersection by the ray\n    float specular;  //specular reflection value for the primitive\n};  \n    \n\nstruct Light {\t//structuer for storing light info\n    vec3 pos;\t//position of the light\n    vec3 col;\t//color of the light\n};\n\n\n//sphere-ray intersection solver\n/*\tsph -> reference to the primitive object. (sphere in this case)\n *\trayOr -> origin position of the ray\n *\trayDir -> direction of the ray\n *\tsmooth -? extra smoothing boundary for calculating intersection.\n */\n\t\nvoid getSphereIntersec(inout Primitive sph, vec3 rayOr, vec3 rayDir, float smoothVal) {\n    vec3 rx = rayOr-sph.pos;\n    float vrx = dot(rayDir, rx);\n    float drx = distance(rayOr,sph.pos);\n    float v = vrx*vrx \n         - (drx*drx - (sph.size+smoothVal)*(sph.size+smoothVal)); //sphere line intersection equation    \n    float ld = -vrx; //sphere line intersection equation\n\tfloat sqrtv = sqrt(abs(v)); \n    float dist1 = ld + sqrtv; //dist to intersection point1\n    float dist2 = ld - sqrtv; //dist to intersection point2\n    sph.intersecPoint =rayOr+ min(dist1, dist2) * rayDir; //calculating the closest intersection point   \t\n    sph.isIntersected = v<0.?false:true;\t//set whether the sphere was interseced \n    sph.normal =normalize(sph.intersecPoint - sph.pos); //set the surface normal at the intersection point\n      \n}\n//plane-ray intersection solver\n/*\tplane -> reference to the plane object. \n *\trayOr -> origin position of the ray\n *\trayDir -> direction of the ray\t\n */\nvoid getPlaneIntersec(inout Primitive plane, vec3 rayOr, vec3 rayDir) {\n    float rdn = dot( rayDir, plane.normal); //plane line intersection\n    float frdn = rdn==0.?1.:rdn; \n    float dfc = dot(plane.normal, (plane.pos - rayOr))/frdn; //dist of plane from ray origin\n     plane.intersecPoint = rayOr + dfc*rayDir; //intersection point of plane and ray\n   \n    plane.isIntersected = rdn==0.?false:true; //whether or not the plane was intersected, without considering its size\n    vec3 dVec = vec3(plane.intersecPoint - plane.pos); //distance from the center of the plane to the point of intersection\n    plane.isIntersected = (plane.isIntersected&&(abs(dVec.x)\t//if the point of intersection is outside the plane \n                          +abs(dVec.y)+abs(dVec.z)<=plane.size))?true:false;\t//set as not intersected, otherwise intersected\n    \n    \n}\n\n\nfloat minLen; //distance from the ray origin to the closest intersection point\nPrimitive nope; //dummy 'null' equivalent object\nPrimitive prim ; //temporary primitive object representing the intersected object\n    \n//Checks which primitive in prims is first intersected by the ray and returns it\n//rayOr -> Origin of the ray\n//rayDir -> direction of the ray\n//prims -> primitive array\n //smooth -> smoothness value to send to the intersection solver function\nPrimitive processRayIntersect(vec3 rayOr, vec3 rayDir,inout Primitive prims[NUM_PRIMS], float smoothVal) {\n     \n    minLen = FAR+1.; //initialize minLen to the farthest possible distance   \n    prim = nope;   //no object has been intersected yet\n    \n       float tl; \n    for(int i=1;i<NUM_PRIMS;i++) { //for every primitive in prims\n       \n    \tprims[i].id = float(i);\n        getSphereIntersec(prims[i], rayOr, rayDir, smoothVal); //process sphere-ray intersection\n        tl = distance(rayOr, prims[i].intersecPoint);\t//get distance from the ray origin to the intersection point\n        minLen = prims[i].isIntersected&&tl<=minLen?tl:minLen; //if the current primitive was intersected, and t1 is less than minLen, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//set minLen as t1\n        \n        if(tl==minLen) {\t//if minLen is same as t1\n            prim = prims[i];\t//this is the first primitive the ray has encountered\n        }\n    }\n    \n    getPlaneIntersec(prims[0], rayOr ,rayDir); // process plane-ray intersection\n    tl = distance(rayOr, prims[0].intersecPoint); // distance from ray origin to point of intersection on plane\n    minLen = prims[0].isIntersected&&tl<=minLen?tl:minLen; //if the plane has been intersected and if t1 is less than minLen\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// then set t1 as minLen\n        \n    if(tl==minLen) {    //if t1 is minLen\n        prim = prims[0]; //the object that is interected first is the plane\n\n    }\n    return prim; //return the primitive that was that is first intersected by the ray\n    \n   \n    }\n\n\n\t\n\t//Creates a scene containing 3 spheres, a plane and some lights and then calls ray-primitive intersection\n\t// solvers, calculates reflection value for the intersection point and then sets the pixel color\n\t//rayOr -> ray origin\n\t//rayDir -> ray direction\n\t//vec3 sphPos -> pre defined position for center sphere\n\t\nvec3 makeScene(vec3 rayOr,vec3 rayDir, vec3 sphPos) {\n   \n  \n    Primitive sph1, plane1, sph2, sph3, sph4, sph5; //Spheres\n    sph3.size = .18;  //setting sphere size\n    sph3.pos =sphPos + vec3(0., 0., sph3.size);\t//sphere position\n    \n    sph1.size = .08;\n    sph1.pos = vec3(sph3.pos.x-(sph1.size+sph3.size)*1.02,sph3.pos.y, sph1.size-.001);\n    sph2.size =.18;\n    sph2.pos = vec3(sph3.pos.x+(sph3.size+sph2.size)*1.02,sph3.pos.y, sph3.size-.001);\n    sph1.specular = sph2.specular = sph3.specular = .5;    //specular reflection values for spheres\n    \n    plane1.pos = vec3(vec2(sph3.pos.xy), sph1.pos.z - sph1.size+.005); //plane position\n    plane1.normal = normalize(vec3(0., 0., .1)); //plane surface normal\n    plane1.size = 1.;  //plane's side length\n    \n    Primitive prims[NUM_PRIMS];\n    \n    prims[0] = plane1; //adding primitives into an array\n    prims[1] = sph1;\n    prims[2] = sph2;\n    prims[3] = sph3;    \n    //prims[4] = sph4;\n    //prims[5] = sph5;\n       \n    \n  \n    Primitive rayPrim = processRayIntersect(rayOr, rayDir, prims, 0.); //perform camera ray intersection check on all primitives\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //rayPrim is the primitive that was first intersected by the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //camera ray\n    Light lights[NUM_LIGHTS]; //lights array\n    lights[0].pos = vec3(sph2.pos.x, sph2.pos.y+.9, .9);//pos of light1;\n    lights[0].col = vec3(.1, .4, .2)*2.; //set light color\n    lights[1].pos =  vec3(-.8, .3, .4);\n    lights[1].col = vec3(.4, .1, .1)*3.;\n    lights[2].pos = vec3(1.8, .2, .5);\n    lights[2].col = vec3(.2, .1, .4)*4.;\n    lights[3].pos = vec3(.5, .2, 7.2);\n    lights[3].col = vec3(.3, .3, .8);\n    Primitive lightPrim;\n    vec3 finalCol = vec3(0.,0.,0.); //initialize final pixel color to zero vector\n    vec3 lRefl;\t//\n    float str;\n    for(int i=0;i<NUM_LIGHTS;i++) {\n        lightPrim = processRayIntersect(lights[i].pos\n                        , normalize(rayPrim.intersecPoint - lights[i].pos), prims, .001); //check if a light ray from this light\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//reaches the point intersected by the camera ray and set lightPrim\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//as the primitive first intersected by the light ray\n        if(lightPrim.id == plane1.id) { //if the light ray towards the primitive intersection point intersects the plane\n\t\t\t\t\t\t\t\t\t\t\n        finalCol+= lightPrim.id==rayPrim.id?max(dot(rayPrim.normal //if the ray from the light and the ray from the camera intersect\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n               , normalize( -(rayPrim.intersecPoint) + lights[i].pos))\t//the aame primitive, calculate diffuse shading color value for the\n               *lights[i].col*.4, 0.):vec3(0., 0., 0.);\t\t\t\t\t//current light and add it to the pixel color\n            \n        }\n        else { //if the light ray didn't intersect the plane\n        lRefl = reflect(rayPrim.intersecPoint - lights[i].pos //calculate the reflection vector at the intersected surface\n                            , rayPrim.normal);\t\t\t\t  //point for the light ray\n        str = max((-1.*dot(normalize(lRefl), rayDir)-rayPrim.specular), 0.0) *5.; //calculate specular reflection value\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  //for the light ray\n\t\t\t\t\t\t\t\t\t\t\t\t\n        finalCol += mix(finalCol,                  //if the light ray and the camera ray hit the same point,\t\t\n                       lightPrim.id==rayPrim.id?   //add the light value vector to the final pixel color\n                        str*lights[i].col\t\t   //else add a zero vector\n            :vec3(0., 0., 0.)\n                        , .9 );\n       }\n    }\n\n    \n    return finalCol;\t//return the final pixel color\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    nope.normal = vec3(0., 0., 0.); //set the normal for the nope object\n    nope.id = -1.;\n\tfloat t = iTime;\n\tvec2 uv = (fragCoord.xy )/max(iResolution.x, iResolution.y); //normalized uv co-ordinates\n    vec3 center = vec3(vec2(iResolution.xy/2./max(iResolution.x, iResolution.y)), -3.0); //get the center of the uv co-ordinate\n    uv -=center.xy; //offset the uv co-ordinates so that the new center will be at (0, 0)\n    mat3 rotM = MRZ(t); //create a x axis rotation matrix whose angle varies by time\n    vec3 camPos = vec3(0, -4., 3.0);//vec3(0.5, .25, 15.25); //position the camera\n    camPos = rotM*(camPos); //apply rotation to camera\n    vec3 sph1Pos = vec3 (0., 0., 0.); //place sphere 1 at (0, 0, 0)\n    vec3 forward = normalize(sph1Pos - camPos); //set the camera to look at sphere 1\n    vec3 upVec = normalize(cross(cross(forward, vec3(0., 0., 1.)), forward)); //set a vector perpendicular to\n\t\t\t\t\t\t\t\t\t\t\t\t// the both z-axis and the camera forwars as the camera up vector\n   \n    vec3 scrnPos = camPos+forward*2.; //position the screen plane\n    vec3 planeLeft = normalize(cross(forward, upVec)); //calculate the left direction vector of the screen plane\n\tvec3 planeUV =upVec * uv.y + planeLeft*uv.x; //find out a point on the plane for the current pixel\n    vec3 rayDirUV = normalize(scrnPos + planeUV - camPos); //calculate the ray direction as the direction from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //the camera position to the point on the screen\n    vec3 val = makeScene(camPos,rayDirUV, sph1Pos); //get the color value for the current pixel\n    fragColor = vec4(vec3(val), 1.); //set the pixel color\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1496, 1496, 1583, 1583, 2327], [2328, 2482, 2553, 2553, 3333], [3551, 3795, 3901, 3901, 5307], [5626, 5626, 5679, 5679, 9205], [9209, 9209, 9266, 9266, 10871]], "test": "error"}
{"id": "Xs33Dr", "name": "LineSegmentWaves", "author": "jt", "description": "An obscure version of line-segments [url]https://www.shadertoy.com/view/MlBSWt[/url]", "tags": ["small", "linesegments"], "likes": 6, "viewed": 136, "published": "Public", "date": "1448895310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Line Segment \"Waves\" written 2015 by JT\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    I = 2. * I / iResolution.xy - 1.;\n    o -= o;\n    const float n = 20.;\n    for(float i = 0.; i < n; i++)\n    {\n        vec4 Q = 2. * abs(2. * fract((iTime - i * .2) * vec4(.0432, .0123, .0257, .0332)) - 1.) - 1.;\n        Q.wz -= Q.xy;\n        o += cos(length(I - (Q.xy + Q.wz * clamp(dot(I - Q.xy, Q.wz) / dot(Q.wz, Q.wz), 0., 1.)))*50.);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs33Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 85, 85, 436]], "test": "ok"}
{"id": "Xs33z8", "name": "just another metaball", "author": "sepehr", "description": "a very simple metaball shader", "tags": ["metaball", "morph"], "likes": 9, "viewed": 197, "published": "Public", "date": "1447895315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const struct ShaderSettings\n{\n    float\tminRadius;\n    float \tverticalFreedom;\n    float \thorizontalFreedom;\n    float \tviscosity;\n    float\tsmoothness;\n    vec4\tclearColor;\n}\n\nSettings = ShaderSettings( .1, .3, .6, .4, 2., vec4( 0., 0., 0., 1. ) );\n\nconst vec4 background = vec4(.14, .16, .22, 1.);\nconst vec4 foreground = vec4(.95, .71, .19, 1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = Settings.clearColor;\n    \n    float\ttimeCos\t= cos(iTime),\n        \ttimeSin = sin(iTime);\n    \n\tvec2 \tar\t\t= vec2( iResolution.x / iResolution.y, 1.),\n\t\t\tuv\t\t= ( fragCoord / iResolution.xy ) * ar,\n        \tcenter\t= vec2( .5, .5 ) * ar,\n        \toffset \t= vec2(\n                timeSin * timeCos * Settings.horizontalFreedom,\n                timeSin * Settings.verticalFreedom ) * ar;\n\t\n    float \td1 \t\t= length(center - uv),\n         \td2 \t\t= length(center + offset - uv),\n        \tavg\t\t= mix(d1, d2, smoothstep(-Settings.viscosity, Settings.viscosity, d1-d2)),\n    \t\tcolfact\t= smoothstep(0., Settings.smoothness / iResolution.y, avg - Settings.minRadius);\n    \n    fragColor = mix( background, foreground, 1. - colfact );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs33z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 350, 407, 407, 1145]], "test": "ok"}
{"id": "Xs3GRM", "name": "SDF basics (Work In Progress)", "author": "sagarpatel", "description": "Building on basic concepts and helper functions", "tags": ["sdf"], "likes": 4, "viewed": 778, "published": "Public API", "date": "1448510823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 1.0\n// @sagzorz\n \nconst bool isPseudoAA = false;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    // visualize light pos, but blocks light :/\n    //res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3GRM.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1507, 1728, 1757, 1757, 2660], [2663, 2798, 2831, 2831, 2859], [2861, 4088, 4117, 4117, 4341], [4491, 4907, 4938, 4938, 5061], [5182, 5395, 5418, 5418, 5436], [5438, 5713, 5755, 5755, 5856], [5858, 6156, 6199, 6199, 6490], [6492, 6731, 6775, 6775, 6907], [6909, 7081, 7109, 7109, 7179], [7181, 7406, 7438, 7438, 7467], [7470, 7561, 7586, 7586, 7839], [7841, 8119, 8137, 8162, 10044], [10046, 10367, 10424, 10478, 11655], [11658, 11863, 11907, 11907, 12557], [12559, 12842, 12886, 12886, 13601], [13603, 13806, 13857, 13857, 14317], [14609, 14609, 14639, 14639, 14965], [14967, 15176, 15217, 15239, 15774], [15776, 15992, 16027, 16027, 16065], [16067, 16520, 16595, 16595, 16786], [16790, 17113, 17178, 17178, 17246], [17248, 17473, 17521, 17521, 20151], [20154, 20326, 20375, 20375, 20689], [20692, 20987, 21036, 21036, 22763], [22765, 23004, 23069, 23069, 23275], [23277, 23277, 23334, 23397, 24099]], "test": "ok"}
{"id": "Xs3GzH", "name": "Horizon Bender", "author": "jameswilddev", "description": "Typical cliche beginner GLSL.", "tags": ["infinite"], "likes": 6, "viewed": 151, "published": "Public", "date": "1448059040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 chequer(vec2 uv) {\n    uv = fract(uv);\n    return uv.x > 0.5 != uv.y > 0.5 ? vec3(0.6, 0.6, 1.0) : vec3(1.0, 1.0, 0.6);\n}\n\n#define PI 3.14159265359\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n/* \n   These functions take a \"camera\" variable specifying:\n     X/Y: Where on the screen we are rendering.\n     Z: How far forwards we are.\n   And return:\n     X/Y: UVs you can use for texture mapping.\n     Z: How far the pixel is.\n   These are designed so that planeX/planeY line up nicely with tunnel so you can lerp between them.\n*/\n\n/* A wall directly in front of you. */\nvec3 planeZ(float z, vec3 camera) {\n    z -= camera.z;\n    return vec3(camera.xy * z, z);\n}\n\n/* Parallel walls to the left/right of you. */\nvec3 planeX(float x, vec3 camera) {\n    float divisor = x / camera.x;\n    return vec3(camera.y * divisor + (camera.x > 0.0 ? 0.0 : (camera.y > 0.0 ? 2.0 : -2.0)), abs(divisor) + camera.z, abs(divisor));\n}\n        \n/* Parallel floor and ceiling. */\nvec3 planeY(float y, vec3 camera) {\n    float divisor = y / -camera.y;\n    return vec3(camera.x * divisor + (camera.y > 0.0 ? 1.0 : -1.0), abs(divisor) + camera.z, abs(divisor));\n}\n\n/* A round tunnel. */\nvec3 tunnel(float radius, vec3 camera) {\n    float dist = radius / length(camera.xy);\n    return vec3(atan(camera.y, camera.x) * radius / HalfPI, dist + camera.z, dist);\n}\n\n/* Similar to planeZ, but matches up with tunnel. */\nvec3 tunnelEnd(float z, float radius, vec3 camera) {\n    float angle = atan(camera.x, camera.y);\n    float dist = length(camera.xy);\n    return vec3(angle * radius / HalfPI, dist * (z - camera.z), z - camera.z);\n}\n\n/* -------------------------------------------------------- */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectNdc = (fragCoord.xy - (iResolution.xy / 2.0)) / (min(iResolution.x, iResolution.y) / 2.0);\n    \n    vec3 camera = vec3(aspectNdc, iTime);\n    \n\tvec3 _tunnel = tunnel(1.0, camera);\n    vec3 _planeX = planeX(1.0, camera);\n    vec3 _planeY = planeY(1.0, camera);\n    \n    float ofThisLoop = mod(iTime * 0.5, 3.0);\n    \n    ofThisLoop = sin(HalfPI * fract(ofThisLoop)) + floor(ofThisLoop);\n    \n    vec3 compute = mix(_planeX, _tunnel, clamp(ofThisLoop, 0.0, 1.0));\n    compute = mix(compute, _planeY, clamp(ofThisLoop - 1.0, 0.0, 1.0));\n    compute = mix(compute, _planeX, clamp(ofThisLoop - 2.0, 0.0, 1.0));\n    \n\tfragColor = vec4(mix(vec3(0.8, 0.9, 1.0), mix(vec3(0.6, 0.7, 1.0), texture(iChannel0, compute.xy).rgb, 1.0 / (1.0 + compute.z * 0.5)), 1.0 / (1.0 + compute.z * 0.1)), 1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3GzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 126], [574, 613, 648, 648, 704], [706, 753, 788, 788, 957], [967, 1001, 1036, 1036, 1181], [1183, 1205, 1245, 1245, 1376], [1378, 1431, 1483, 1483, 1644], [1710, 1710, 1767, 1767, 2569]], "test": "error"}
{"id": "Xsc3R4", "name": "Cheap Cloud Flythrough", "author": "Shane", "description": "This is an attempt to give the impression of a cloud flythrough, whilst maintaining a reasonably acceptable framerate.", "tags": ["noise", "cloud", "volumetric", "sinusoidal", "flythrough"], "likes": 188, "viewed": 9758, "published": "Public API", "date": "1448283909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tCheap Cloud Flythrough \n\t----------------------\n\t\n\t\"Cheap\" should probably refer to the quality of the physics in this shader, which is\n\tvirtually non-existent, but it actually refers to the fake cloud algorithm... if you could \n\tcall it that. :)\n\t\n\tThis is merely an attempt to give the impression of a cloud flythrough, whilst maintaining\t\n\ta reasonably acceptable framerate. The key to that is keeping the distance field as simple \n\tas possible.\n\n\tDue to the amount of cost cutting, it's far from  perfect. However, there's still plenty \n\tof room for improvement.\n\n    I've used density based accumulation, which in one way or another, uses concepts from many \n\tvolumetric examples, but particularly from the following:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n    \n    Other shaders worth looking at:\n\n\tClouds - IQ: One of my favorite shaders, and everyone elses, it seems.\n\thttps://www.shadertoy.com/view/XslGRr\n\t\t\n\tSample Pinning - huwb: Fast, and pretty.\n\thttps://www.shadertoy.com/view/XdfXzn\n\t\n\tFakeVolumetricClouds - Kuvkar: Fast, using parallax layers. Really cool.\n\thttps://www.shadertoy.com/view/XlsXzN\n\n    Emission clouds - Duke: Nice, and straight forward.\n    https://www.shadertoy.com/view/ltBXDm\n\n\n*/\n\n// Hash function. This particular one probably doesn't disperse things quite \n// as nicely as some of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat pn( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    \n    float res = 0., sum = 0.;\n    \n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = pn(p*8. + iTime*2.);\n\n\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\n// Distance function.\nfloat map(vec3 p) {\n\n    return trigNoise3D(p*0.5);\n    \n    // Three layers of noise, for comparison.\n    //p += iTime;\n    //return pn(p*.75)*0.57 + pn(p*1.875)*0.28 + pn(p*4.6875)*0.15;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty easy to please,\n    // but I thought it was pretty cool.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \n\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime*4.);\n\n    // Cheap camera rotation.\n    //\n    // 2D rotation matrix. Note the absence of a cos variable. It's there, but in disguise.\n    // This one came courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.1875); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xy = rd.xy*rM; // Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    rd.xz = rd.xz*rM;\n\n    // Placing a light in front of the viewer and up a little, then rotating it in sync\n    // with the camera. I guess a light beam from a flying vehicle would do this.\n    vec3 lp = vec3( 0, 1, 4);\n    lp.xy = lp.xy*rM;\n    lp.xz = lp.xz*rM;\n    lp += ro;\n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    rd = (rd + (hash33(rd.zyx)*.006 - .003)); \n    // Randomizing the length also. \n    rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.06-0.03);      \n\n    // Local density, total density, and weighting factor.\n    float lDe = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = 0.;\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if((td>1.) || d<.001*t || t>80.)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        lDe = (h - d)*step(d, h); \n        w = (1. - td)*lDe;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1./64.; //w*w*5. + 1./50.;\n        //td += w*.4 + 1./45.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), .001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 1./(1. + lDist*.125 + lDist*lDist*.05);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations. Note the \"d*3. - .1\" term. It's there as a bit\n        // of a fudge to make the clouds a bit more shadowy.\n        col += w*(d*3. - .1)*(.5 + diff + spec*.5)*atten;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        //col += w*atten*1.25;\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t +=  max(d*.5, .02); //\n        // t += .2; // t += d*.5;// These also work, but don't seem as efficient.\n\n    }\n\n    col = max(col, 0.);\n\n    // trigNoise3D(rd*1.)\n    col = mix(pow(vec3(1.5, 1, 1)*col,  vec3(1, 2, 8)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.35 + .65);\n    col = mix(col.zyx, col, dot(cos(rd*9. +sin(rd.yzx*9.)), vec3(.333))*.15 + .85);//xzy\n    \n\n    //col = mix(col.zyx, col, dot(rd, vec3(.5))+.5);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsc3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1369, 1530, 1550, 1550, 1654], [1657, 2003, 2025, 2025, 2193], [2197, 2345, 2374, 2374, 3186], [3188, 3210, 3229, 3229, 3400], [3404, 3404, 3461, 3671, 8973]], "test": "error"}
{"id": "XscGRn", "name": "Sound Experiment 4", "author": "aiekick", "description": "Sound Experiment 4", "tags": ["sound", "experiment", "4"], "likes": 16, "viewed": 824, "published": "Public API", "date": "1447545146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// based on https://www.shadertoy.com/view/4ljSDt from gilesruscoe \n\nvec4 freq1, freq2, freq3;\n\nfloat map(vec3 p)\n{\n    p.xy += vec2(cos(p.z),sin(p.z));\n\t\n    float tube = 10.;\n    \n    float cz = p.z, sz = p.z;\n    \n    cz += freq1.x; sz -= freq3.w;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.5));\n\tcz += freq1.y; sz -= freq3.z;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.4));\n\tcz += freq1.z; sz -= freq3.y;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.3));\n\tcz += freq1.w; sz -= freq3.x;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.2));\n\tcz += freq2.x; sz -= freq2.w;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.1));\n\tcz += freq2.y; sz -= freq2.z;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*.0));\n\tcz += freq2.z; sz -= freq2.y;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.1));\n\tcz += freq2.w; sz -= freq2.x;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.2));\n\tcz += freq3.x; sz -= freq1.w;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.3));\n\tcz += freq3.y; sz -= freq1.z;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.4));\n\tcz += freq3.z; sz -= freq1.y;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.5));\n\tcz += freq3.w; sz -= freq1.x;\n\ttube = min(tube, length(p.xy + vec2(cos(cz),sin(sz))*-.6));\n    \n\treturn tube - 0.01;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 40; ++i)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from CubeScape : https://www.shadertoy.com/view/Msl3Rr\n    freq1.x = texture( iChannel0, vec2( 0.075, 0.25 ) ).x;\n\tfreq1.y = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreq1.z = texture( iChannel0, vec2( 0.225, 0.25 ) ).x;\n\tfreq1.w = texture( iChannel0, vec2( 0.3, 0.25 ) ).x;\n    \n    freq2.x = texture( iChannel0, vec2( 0.375, 0.25 ) ).x;\n\tfreq2.y = texture( iChannel0, vec2( 0.45, 0.25 ) ).x;\n\tfreq2.z = texture( iChannel0, vec2( 0.525, 0.25 ) ).x;\n\tfreq2.w = texture( iChannel0, vec2( 0.6, 0.25 ) ).x;\n    \n    freq3.x = texture( iChannel0, vec2( 0.675, 0.25 ) ).x;\n    freq3.y = texture( iChannel0, vec2( 0.75, 0.25 ) ).x;\n    freq3.z = texture( iChannel0, vec2( 0.825, 0.25 ) ).x;\n    freq3.w = texture( iChannel0, vec2( 0.9, 0.25 ) ).x;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 2.0));\n    \n    vec3 o = vec3(0.0, 0.0, iTime * 2.);\n    \n    float t = trace(o, r);\n    \n    float fog = 2. / (1. + t * t * 0.1);\n    \n\tfragColor = vec4(fog);\n}\n\n", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscGRn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[234, 234, 253, 253, 1483], [1485, 1485, 1514, 1514, 1670], [1672, 1672, 1729, 1791, 2806]], "test": "error"}
{"id": "Xsd3RH", "name": "4x3", "author": "rcread", "description": "abandoned attempt at something else", "tags": ["3d"], "likes": 7, "viewed": 262, "published": "Public", "date": "1448094604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define N normalize\n\nfloat min3( vec3 a ) { return min( a.x, min( a.y, a.z ) ); }\nfloat max3( vec3 a ) { return max( a.x, max( a.y, a.z ) ); }\n\nvec3 make_rd( vec2 p, vec3 c ) {\n    vec2 r = iResolution.xy;\n    vec3 b = vec3( 0, 1, 0 ), a = cross( b, c );\n    p = ( p - r / 2. ) / r;\n    b = cross( a, c );\n    return N( p.x * a + p.y * b + c );\n}\n\nvoid mainImage( out vec4 o, vec2 i )\n{\n\tfloat ti = iTime, c = .96;\n\tvec3 t, ip, \n        cl = vec3( 1 ), \n        ro = 11. * vec3( sin( ti * ( .1 + cos( ti / 1e6 ) / 4. ) ), sin( ti * .2 ), cos( ti * .5 ) ), \n        rd = make_rd( i, N( -ro ) );\n\n\tt = ( c - ro ) / rd;\n\tfor ( int i = 0 ; i < 3 ; i++ ) {\n\t\tif ( t[i] >= 0. ) {\n\t\t\tip = abs( ro + rd * t[i] );\n\t\t\tif ( max3( ip ) <= 4. * c ) {\n\t\t\t\tip[i] = 1.;\n\t\t\t\tcl[i] = 1. - min3( ip );\n\t\t\t}\n\t\t}\n\t}\n\to.rgb = smoothstep( .04, 0., cl );\n    //*\n    float d = max3( o.rgb );\n    o.rgb = vec3( o.r + o.g, o.r + o.b, o.g + o.b );\n    o.rgb = o.rgb * d / max3( o.rgb );\n\t//*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsd3RH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[148, 148, 170, 170, 208], [209, 209, 231, 231, 269], [271, 271, 303, 303, 473], [475, 475, 513, 513, 1094]], "test": "ok"}
{"id": "Xsd3Rn", "name": "Holcombe's Variaton", "author": "mikepfrank", "description": "Make sounds and watch it change", "tags": ["fractal", "audio"], "likes": 5, "viewed": 1031, "published": "Public API", "date": "1447728889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265359\n\n//#define iTime tan(iTime*.1)+iTime*.1\n\nfloat bassBoostLow = 0.0;\nfloat bassBoostHigh = 0.0;\nfloat time = 0.0;\n\nvec3 hsv(in float h, in float s, in float v)\n{\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 formula(in vec2 p, in vec2 c)\n{\n\tconst float n = 2.0;\n\tconst int iters = 5;\n\n\t//float time = iTime*0.1;\n\tvec3 col = vec3(0);\n\tfloat t = 1.0;\n\tfloat dpp = dot(p, p);\n\tfloat lp = sqrt(dpp);\n\tfloat r = smoothstep(0.0, 0.2, lp);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t// The transformation\n        //p+=vec2(sin(c.x+p.x)*.01,\n        //        cos(c.y+p.y)*.01);\n        float to = bassBoostHigh;\n        float index = mod(float(i)*1234.1234, 2.0);\n        \n        \n        if(index < .1)\n        {\n        \tp = p*mat2(cos(cos(time+to)+time+to), -sin(cos(time+to)+time+to),\n                   sin(cos(time+to)+time+to), cos(cos(time+to)+time+to));\n\t\t\tp = abs(mod(p*(1.0) + c, n) - (n)/2.0);\n        }\n        else if(index < 1.1)\n\t\t\tp = abs(mod(p*(1.0) + c, n) - (n)/2.0);//mod(p/dpp + c, n) - n/2.0;\n        else if(index < 2.1)\n\t\t\tp = p+to;\n\t\t\n\t\tdpp = dot(p, p);\n        p /= dpp;\n\t\tlp = pow(dpp, 1.5);\n        \n        \n        //if(int(14.0*sin(iTime))+iters < i) break;\n\n\t\t//Shade the lines of symmetry black\n#if 0\n\t\t// Get constant width lines with fwidth()\n\t\tfloat nd = fwidth(dpp);\n\t\tfloat md = fwidth(lp);\n\t\tt *= smoothstep(0.0, 0.5, abs((n/2.0-p.x)/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs((n/2.0-p.y)/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs(p.x/md))\n\t\t   * smoothstep(0.0, 0.5, abs(p.y/md));\n#else\n\t\t// Variable width lines\n\t\tt *= smoothstep(0.0, 0.01, abs(n/2.0-p.x)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(n/2.0-p.y)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(p.x)*2.0) \n\t\t   * smoothstep(0.0, 0.01, abs(p.y)*2.0);\n#endif\n\n\t\t// Fade out the high density areas, they just look like noise\n\t\tr *= smoothstep(0.0, 0.2, lp);\n\t\t\n\t\t// Add to colour using hsv\n\t\tcol += lp+bassBoostHigh;\n\t\t\n\t}\n\t\n\tcol = vec3(sin(col.x+time*.125),\n\t\t\t   cos(col.y+time*.125+4.0*pi/3.0),\n\t\t\t   sin(col.z+time*.125+2.0*pi/3.0))*.5+.5;\n    \n\treturn col*t;\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 1; i < iters/2; i++)\n    {\n        next = length(texture(iChannel0, vec2(float(i)/float(iters), 0.0)));\n        sum += last;//pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum/float(iters)*2.0;\n}\n\nfloat highAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 17; i < iters; i++)\n    {\n        next = length(texture(iChannel0, vec2(float(i)/float(iters), 0.0)));\n        sum += last;//pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum/float(iters)*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    bassBoostLow += lowAverage()*1.0;\n    bassBoostHigh += highAverage()*1.0;\n    time = iTime+bassBoostLow*8.0*pi;\n    \n    p += .125;\n    \n    p += .5*vec2(cos(time), sin(time));\n    \n\tp.x *= iResolution.x / iResolution.y;\n\tp *= 1.5+1.125*sin(time*.25);\n    \n\tconst vec2 e = vec2(0.06545465634, -0.05346356485);\n\tvec2 c = time*e;\n\t//c = 8.0*iMouse.xy/iResolution.xy;\n\tfloat d = 1.0;\n\tvec3 col = vec3(0.0);\n\tconst float blursamples = 4.0;\n\tfloat sbs = sqrt(blursamples);\n\tfloat mbluramount = 1.0/iResolution.x/length(e)/blursamples*2.0;\n\tfloat aabluramount = 1.0/iResolution.x/sbs*4.0;\n\tfor (float b = 0.0; b < blursamples; b++) {\n\t\tcol += formula(\n\t\t\tp + vec2(mod(b, sbs)*aabluramount, b/sbs*aabluramount), \n\t\t\tc + e*mbluramount*b);\n\t}\n\tcol /= blursamples;\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsd3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 184, 184, 292], [294, 294, 330, 330, 2124], [2126, 2126, 2146, 2146, 2500], [2502, 2502, 2523, 2523, 2876], [2878, 2878, 2935, 2935, 3784]], "test": "error"}
{"id": "Xsd3zM", "name": "Screen Flicker", "author": "chipbell4", "description": "Simple Screen Flicker effect", "tags": ["flicker"], "likes": 8, "viewed": 278, "published": "Public", "date": "1448643019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat randInRange(vec2 range, vec2 seed) {\n    float randBetweenZeroAndOne = (rand(seed) + 1.) / 2.;\n    \n    return range.x + randBetweenZeroAndOne * (range.y - range.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t// The \"strength\" of the flicker is randomly based on time\n    float flickerPeriod = randInRange(vec2(1.5, 3.0), vec2(iTime, iTime));\n    float noiseScale = 0.01;\n    if(fract(iTime / flickerPeriod) > 0.95) {\n        noiseScale = 0.2;\n    }\n    \n    // A seed for the random number generation\n\tvec2 seed = vec2(iTime, uv.y);\n    \n    // Add the texture, but with an x-based offset to provide some CRT-style effect\n    uv.x += randInRange(vec2(-0.01, 0.01), seed);\n\tfragColor = texture(iChannel0, uv);\n    \n    // Add some noise to generate the flicker based on the time-based noise scale and a seed\n    float noise = randInRange(vec2(0.0, noiseScale), seed);\n    fragColor.xyz += vec3(noise, noise, noise);\n    \n}\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsd3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 136, 136, 267], [269, 269, 326, 326, 1088]], "test": "error"}
{"id": "XsdGR7", "name": "ColorPalettes", "author": "jt", "description": "Functions calculating a palette of rainbow-colors (variants smooth/crisp).\nTweaking the multiplier yields different palettes:\n1/1 black-white, 1/2 magenta-green, 1/3 rainbow (approx. 1/4 to 1/6 \"sunset\" colors)", "tags": ["colorpalette"], "likes": 12, "viewed": 196, "published": "Public", "date": "1448651662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Color-Palettes Visualization - written 2015 by Jakob Thomsen\n\n#define draw(c,q) O = mix(vec4(c, 1.), O, vec4(smoothstep(.0,.02,abs(I.y - q))))\n\n// NOTE: tweaking the multiplier results in different palette-types:\n// 1/1 black-white, 1/2 magenta-green, 1/3 rainbow (approx. 1/4 to 1/6 \"sunset\" colors)\n\nvec3 rainbow(float value) // smooth\n{\n    //return .5 + .5 * cos(2. * 3.1415926 * (value + vec3(0,1,2) / 3.)); // original\n    // variants based on the fake-sine function https://www.shadertoy.com/view/4sd3zM\n    //vec3 v = 2.*(.25 + value + vec3(0,1,2) / 3.);\n    vec3 v = 2.*(.25 + value + vec3(0,1,2) * fract(iTime * .1));\n    //return 0.5 + 0.5 * sign(.5-fract(v*.5))*(1.-pow(abs(2. * fract(v) - 1.),vec3(1.75)));\n    vec3 w = abs(2. * fract(v) - 1.);\n    return 0.5 + 0.5 * sign(.5-fract(v*.5))*(1.-w*w);\n    //vec3 m = mirror(value + vec3(0,1,2) / 3.);\n    //return m * m;\n}\n\nvec3 rainbow2(float value) // crisp\n{\n    //return abs(2. * fract(value + vec3(0,1,2) / 8.) - 1.);\n    return abs(2. * fract(value + vec3(0,1,2) * fract(iTime * .1)) - 1.);\n    //return m * m;\n}\n\nvec3 rainbow3(float value) // crisp\n{\n    return clamp(2.0 * abs(2. * fract(value + vec3(0,1,2) * fract(iTime * .1)) - 1.) - 0.5, 0.0, 1.0); \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n\tI /= iResolution.xy;\n    O = vec4(mix(rainbow(I.x), rainbow2(I.x), step(0.5, I.y)), 1.);\n    //O = vec4(1);\n    draw(vec3(1,0,0),.5*rainbow2(I.x).x-.5);\n    draw(vec3(0,1,0),.5*rainbow2(I.x).y-.5);\n    draw(vec3(0,0,1),.5*rainbow2(I.x).z-.5);\n    draw(vec3(1,0,0),.5*rainbow(I.x).x);\n    draw(vec3(0,1,0),.5*rainbow(I.x).y);\n    draw(vec3(0,0,1),.5*rainbow(I.x).z);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 342, 565, 885], [887, 887, 924, 985, 1081], [1083, 1083, 1120, 1120, 1226], [1228, 1228, 1269, 1269, 1638]], "test": "ok"}
{"id": "XsdGR8", "name": "tunnel2", "author": "macbooktall", "description": "small mod of my tunnel https://www.shadertoy.com/view/MlSXWd\nbased on iq's primitives https://www.shadertoy.com/view/Xds3zN", "tags": ["fun", "spirals"], "likes": 26, "viewed": 1183, "published": "Public API", "date": "1448061530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tweaked copy of https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdOcta( vec3 p, float h, float w ){\n    p.xz = abs(p.xz);\n    p.y = abs(p.y)-h;\n    return max(p.z,p.x)+(p.y*w);    \n}\n\nvec2 map( in vec3 pos )\n{\n    pos.x += sin(pos.z+iTime*0.5)*0.275*2.;\n    pos.y += cos(pos.z+iTime*0.5)*0.275*2.;\n    \n    float size = .27;\n    \n    vec3 p = abs(mod(pos.xyz+size,size*2.)-size);\n  \n    float box = sdBox( p, vec3(.34));\n    float cyl = sdCappedCylinder( p, vec2(.31, .34));\n     \n    vec2  res = vec2(opS(cyl, box) ,1.5); \n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 250.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<250; i++ )\n    {\n   vec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n   m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\nvec3 eps = vec3( 0.01, 0.0, 0.0 );\nvec3 nor = vec3(\n   map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n   map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n   map(pos+eps.yyx).x - map(pos-eps.yyx).x );\nreturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        float occ = calcAO( pos, nor );\n\t\tcol = hue(vec3(1.0,1.0,.0),iTime*0.5+pos.z)*occ;\n    \tcol = mix( col, vec3(1.0), 1.0-exp( -0.005*t*t ) );\n    }\n\nreturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\n    vec2 p = -1.0+2.0*q;\n\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n \n\t// camera\n\tvec3 ro = vec3(0., 0.,iTime );\n\t\n    vec3 ta = ro+vec3( 0., 0.,1. );\n\t\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0. );\n\n    // ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy,12.5));\n\n    // render\n    vec3 col = render( ro, rd );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[171, 171, 206, 206, 1155], [1157, 1157, 1188, 1188, 1284], [1286, 1286, 1328, 1328, 1427], [1429, 1429, 1462, 1462, 1488], [1490, 1490, 1531, 1531, 1614], [1616, 1616, 1641, 1641, 1978], [1980, 1980, 2020, 2020, 2300], [2302, 2302, 2334, 2334, 2545], [2547, 2547, 2589, 2589, 2886], [2891, 2891, 2930, 2930, 3401], [3403, 3403, 3455, 3455, 3628], [3630, 3630, 3687, 3687, 4144]], "test": "ok"}
{"id": "XsdGzM", "name": "Maze Explorer", "author": "fizzer", "description": "A procedural maze which happens to have a nice way to know if a given path is blocked. This was created to accompany [url=http://amietia.com/slashmaze.html]an article[/url].", "tags": ["procedural", "maze", "stateless"], "likes": 30, "viewed": 604, "published": "Public", "date": "1448637191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define TL  30.0\n#define TL2 33.0\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    float n0=noise(floor(p)+vec2(0,0));\n    float n1=noise(floor(p)+vec2(1,0));\n    float n2=noise(floor(p)+vec2(0,1));\n    float n3=noise(floor(p)+vec2(1,1));\n    float u=fract(p.x),v=fract(p.y);\n    return mix(mix(n0,n1,u),mix(n2,n3,u),v);\n}\n\nbool blocked(vec2 p)\n{\n    float r=acos(-1.)*2./8.;\n    vec2 p2=(p-.5)*mat2(cos(r),sin(r),sin(r),-cos(r))*length(vec2(1));\n    vec2 c=floor(p2); \n    bool s=step(.5,noise(c))>.5;\n    bool hv=mod(c.x+c.y,2.)>.5;\n    return hv==s;\n}\n\nfloat mazeDist(vec3 p)\n{\n    vec3 cp=fract(p)-vec3(.5),acp=abs(cp);\n    float r=acos(-1.)*2./8.;\n    vec2 p2=(p.xz-.5)*mat2(cos(r),sin(r),sin(r),-cos(r))*length(vec2(1));\n    vec2 c=floor(p2),f=fract(p.xz);\n    float a=step(.5,noise(c));\n    float s=.1;\n    if(a>.5)\n        return acp.x-s;\n    return acp.z-s;\n}\n\nfloat f(vec3 p)\n{\n    return min(length(vec2(max(0.,mazeDist(p)),p.y-.04))-.08,p.y);\n}\n\nvec2 startPoint(float t)\n{\n    return vec2(floor(t)*7., floor(t)*3.);\n}\n\nvec2 startDirection(float t)\n{\n    return vec2(-1.+mod(t*2.,2.),0.);\n}\n\nfloat cubic(float x)\n{\n    return (3.*x-2.*x*x)*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=iTime;\n    vec2 c=vec2(fragCoord/iResolution.xy-.5)*2.;\n    c.x*=iResolution.x/iResolution.y;\n    float time2=time*.7;\n    float tsec=floor(time2/TL2);\n    vec2 bp=startPoint(tsec),pbp=bp;\n    vec2 bd=startDirection(tsec),pbd=bd;\n\n    float st=mod(time2,TL2);\n\n    for(int i=0;i<int(TL);++i)\n    {\n        if(i>int(floor(st)))\n            break;\n        vec2 od=bd.yx*vec2(1.,-1.)*(1.-2.*step(.5,hash(float(i))));\n        pbp=bp;\n        pbd=bd;\n        if(!blocked(bp+bd/2.))\n        {\n            bp+=bd;\n            if(!blocked(bp+od/2.))\n                bd=od;\n        }\n        else\n            bd=bd.yx*vec2(1,-1);\n    }\n\n    bp=mix(pbp,bp,fract(min(st,TL-1e-4)));\n    bd=normalize(mix(pbd,bd,fract(min(st,TL-1e-4))));\n    float ry=.5;\n\n    if(floor(st)>=TL)\n    {\n        float t=(st-TL)/(TL2-TL);\n        bp=mix(bp,startPoint(tsec+1.),cubic(t));\n        float ba=mix(atan(bd.y,bd.x),atan(startDirection(tsec+1.).y,startDirection(tsec+1.).x),cubic(t));\n        bd=vec2(cos(ba),sin(ba));\n        ry+=1.*sin(t*acos(-1.));\n    }\n\n    vec3 up=vec3(0,1,0);\n    float p=-.3;\n    vec2 yz=vec2(c.y,1.8)*mat2(cos(p),sin(p),-sin(p),cos(p));;\n        vec3 rd=normalize(yz.x*up+yz.y*vec3(bd.x,0,bd.y)-cross(up,vec3(bd.x,0,bd.y))*c.x);\n    vec3 ro=vec3(bp.x,ry,bp.y);\n\n    float t=0.,d=0.;\n    for(int i=0;i<120;++i)\n    {\n        d=f(ro+rd*t);\n        if(d<1e-3||t>18.)\n            break;\n        t+=d;\n    }\n\n    if(t>18.)\n    {\n        fragColor.rgb=mix(vec3(1),vec3(.6,.6,1),rd.y);\n        return;\n    }\n\n    vec3 rp=ro+rd*t;\n    float eps=1e-1;\n    float d2=clamp((f(rp+normalize(vec3(-1,1,1.5))*eps)-d)/eps,-1.,1.);\n\n    float eps2=1e-3;\n    float d22=clamp((f(rp+normalize(vec3(-1,1,1.5))*eps2)-d)/eps2,-1.,1.);\n\n    float eps3=2e-1;\n    float d23=clamp((f(rp+normalize(vec3(0,1,0))*eps3)-d)/eps3,-1.,1.);\n\n    float eps4=2e-1;\n    float d24=clamp((f(rp+normalize(rd)*eps4)-d)/eps4,-1.,1.);\n\n    vec3 irr=.5*vec3(1,1,.8)*(mix(.5,1.,1.-clamp(d22-d2,0.,1.)))*(.5+.5*d22);\n\n    irr+=.5*vec3(.8,.85,1.)*pow(.5+.5*d23,3.);\n\n    vec3 alb=mix(vec3(1.),vec3(.4,.35,.3)*1.4,step(rp.y,.1e-2))*mix(.7,1.,step(fract(rp.x*2.+.5*step(.5,fract(rp.z*2.))),.5));\n\n    vec3 spec=vec3(pow(clamp(.6+.25*d24,0.,1.)*1.4,16.))*14.*\n        (smoothNoise(rp.xz*256.)/2.+smoothNoise(rp.xz*512.)/3.);\n\n    fragColor.rgb=sqrt(mix(vec3(1),alb*irr+spec,exp2(-t/25.)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 57, 57, 96], [98, 98, 119, 119, 154], [156, 156, 183, 183, 427], [429, 429, 451, 451, 659], [661, 661, 685, 685, 973], [975, 975, 992, 992, 1061], [1063, 1063, 1089, 1089, 1134], [1136, 1136, 1166, 1166, 1206], [1208, 1208, 1230, 1230, 1260], [1262, 1262, 1319, 1319, 3676]], "test": "ok"}
{"id": "Xst3R7", "name": "BinaryTreeVar", "author": "jt", "description": "A variant of [url]https://www.shadertoy.com/view/Mt2XW3[/url] with cosine-distortion\n(a cleaner version of [url]https://www.shadertoy.com/view/MljXDV[/url])", "tags": ["branching", "binarytree"], "likes": 5, "viewed": 127, "published": "Public", "date": "1448661676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Binary Tree variant with (almost) fix line-size - written 2015 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat C01(float v)\n{\n    v += .25;\n    float w = abs(2. * fract(v*2.) - 1.);\n    return 0.5 + 0.5 * sign(.5-fract(v))*(1.-w*w);\n}\n/*\nfloat c01(float v)\n{\n    return 0.5 + 0.5 * cos(2.0 * 3.1415926 * v);\n}\n*/\nvoid mainImage( out vec4 o, in vec2 U )\n//void mainImage( inout vec4 o, vec2 U ) // ERROR: overloaded functions must have the same parameter qualifiers\n{\n    U /= iResolution.xy;\n    U.y = mirror(U.y+1.);\n    //U.y = 2./(2.-U.y) - 1.;\n    U.y = 1.-log2(2.-U.y);\n    float y = (1.-U.y);\n    //float f = 7.*(1.-mirror(iTime*.1));\n    float f = 7.*(1.-C01(iTime*.05));\n    U.y *= f;\n    U.x *= exp2(ceil(U.y))/2.;\n    U = fract(U);\n    o -= o;\n    //o += 1. - smoothstep(0., (.4 - .2 * U.y), abs(4. * abs(U.x - .5) - C01(.5 * (U.y + 1.0)))); // \"plant\"\n    o += 1. - smoothstep(0., f*(.02 - .01 * U.y)/y, abs(4. * abs(U.x - .5) - C01(.5 * (U.y + 1.0)))); // fixed size\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xst3R7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[219, 219, 239, 239, 348], [349, 427, 580, 580, 1094]], "test": "ok"}
{"id": "Xst3zN", "name": "Plasma Effect", "author": "emilysquid", "description": "Used a few tutorials and combined them", "tags": ["test", "plasma", "water", "fakereflection"], "likes": 2, "viewed": 718, "published": "Public", "date": "1448408285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//This was an experiment so I could learn some GLSL.\n//Thanks to vug for his tutorial!  I also referenced swellbastion to use a texture for noise. Thank you!\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2(fragCoord.xy / iResolution.xy); \n\t//aspect ratio\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    //coordinates [0,1]  origin is the bottom left\n    \n\t//animate\n    float t = iTime;\n    r = r * 8.0;\n\t\n //https://www.shadertoy.com/view/Md23DV   \n    //vertical lines\n    float v1 = sin(r.x +t);\n    //vertical waves\n    float v2 = sin(r.y +t);\n    //diagonal\n    float v3 = sin(r.x+r.y +t);\n    //rings\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) +5.0*t);\n    //blobs\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\t\n\t// mix colors\n\tv *= 1.0;\n\tret = vec3(sin(v), sin(v+(.5+t)*PI), sin(v+1.0*PI)-.5);\n\t\t\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n      \n    \n    if (p.y > 0.5) { // if top half of screen\n        p.y -= 0.5;\n        fragColor = vec4(pixel, 1.0);\n    }\n //https://www.shadertoy.com/view/ld33RN#   \n    else { // if bottom half of screen\n                p.y = 0.5 - p.y;\n        \n        vec2 noiseStretch = vec2(10000.0, 1500.0);\n        float distanceRiverTraveled = t * -0.02;\n        \n        vec2 noisePosition = fragCoord / noiseStretch;\n        noisePosition.x += distanceRiverTraveled;\n        \n    \tfloat noise = texture(iChannel0, noisePosition).r;\n    \n    \tfloat xMove = noise * 0.15 - 0.075;\n    \n    \tvec2 imagePosition = vec2(\n    \t\tp.x + xMove,\n        \tp.y\n    \t);\n        \n        pixel.x += noise;\n        pixel.y +=  noise;\n        pixel.z += v1 *noise;\n        vec4 image = vec4(pixel, imagePosition);\n\n    \n        float waterBrightness = 0.95;\n\t\tfragColor = image * waterBrightness;\n\n        \n    }\n\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xst3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 242, 242, 1816]], "test": "error"}
{"id": "XstGR7", "name": "BeatCircle", "author": "ingarsmakareni", "description": "Ingars Makareni ", "tags": ["it"], "likes": 0, "viewed": 98, "published": "Public", "date": "1448897319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n    \n    vec2 diff = center-uv;\n\tfloat distan = sqrt(dot(diff, diff));\n    float circle = smoothstep(rad-width, rad, distan) - smoothstep(rad, rad+width, distan);\n    return vec3(circle);\n}\n\nfloat chessboard(vec2 uv)\n{\n    uv = floor(uv*12.0); \n    return mod(uv.y + uv.x, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 backgroundColour = vec4(chessboard(uv));\n    \n    vec2 center = vec2(0.5);\n    float radius = 1.0;    \n    vec3 color = paintCircle(uv, center, radius, 0.1);\n    vec4 circleColour = vec4(uv, 0.3 + 0.8 * tan(iTime), 1.5);\n    \n    \n    float beat = texture( iChannel0, vec2(0.0, 0.01 ) ).x;\n    vec4 circle = vec4(paintCircle(uv, center, beat * 0.65, 0.05), 0.01);\n    \n    fragColor = mix(backgroundColour,circleColour*1.0, circle*4.0);\n\t\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 65, 65, 255], [257, 257, 284, 284, 346], [348, 348, 405, 405, 905]], "test": "error"}
{"id": "XstGR8", "name": "Sine Flame", "author": "epicabsol", "description": "Just a quick adaptation of my previous rainbow shader to give a flame effect.", "tags": ["procedural", "fire", "sine"], "likes": 14, "viewed": 1722, "published": "Public API", "date": "1448057224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\n{\n    float glow = 0.01 * iResolution.x;\n    fragCoord.x += vscale * 100.0;\n    float twopi = 6.28318530718;\n    float curve = 1.0 - abs(fragCoord.x - (sin(mod(fragCoord.y * hscale / 100.0 / iResolution.y * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.x * 0.25 * vscale + iResolution.x / 2.0));\n    float i = clamp(curve, 0.0, 1.0) * 0.3;\n    i += clamp((glow * 2.0 + curve) / (glow * 2.0), 0.0, 1.0) * 0.3 ;\n    i += clamp((glow * 8.03 + curve) / (glow * 8.03), 0.0, 1.0) * 0.25 ;\n    i += clamp((glow * 50.03 + curve) / (glow * 50.03), 0.0, 1.0) * 0.05 ;\n\t\n\tfloat len = sin(hoffset * timescale * 0.01 + hscale * timescale * 0.0001) * 10.0 + sqrt(pow(fragCoord.x - iResolution.x * 0.5, 2.0) + pow(fragCoord.y * 0.5, 2.0));\n    float d = (len + (vscale * 3.0 - 0.5) * iResolution.y) / (0.1 * iResolution.y);\n    return clamp(i, 0.0, 1.0) * (3.0 - d) * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timescale = -5.0;\n\tvec3 c = vec3(0, 0, 0);\n    c += Strand(fragCoord, vec3(1.0, 0.25, 0), 0.7934 + iTime * 30.0, 1.0, 0.05, 10.0 * timescale);\n    c += Strand(fragCoord, vec3(0.9, 0.21, 0), 0.645 + iTime * 30.0, 1.5, 0.2, 10.3 * timescale);\n    c += Strand(fragCoord, vec3(0.85, 0.3, 0), 0.735 + iTime * 30.0, 1.3, 0.19, 8.0 * timescale);\n    c += Strand(fragCoord, vec3(0.93, 0.23, 0.0), 0.9245 + iTime * 30.0, 3.0, 0.14, 12.0 * timescale);\n    c += Strand(fragCoord, vec3(0.97, 0.19, 0), 0.7234 + iTime * 30.0, 1.9, 0.23, 14.0 * timescale);\n    c += Strand(fragCoord, vec3(0.83, 0.24, 0), 0.84525 + iTime * 30.0, 1.2, 0.29, 9.0 * timescale);\n    \n    \n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 119, 119, 993], [995, 995, 1052, 1052, 1757]], "test": "ok"}
{"id": "XstGRr", "name": "Floating Circles #2", "author": "nonlogical", "description": "Just a modification of my first shader cause I'm bored. Looks best fullscreen as a screensaver.", "tags": ["2d"], "likes": 9, "viewed": 157, "published": "Public", "date": "1447756165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nfloat hash(float n) {return fract(sin(n * 0.021) * 43758.5453123);}//from iq\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    mo -= 0.5;\n    mo.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * 0.5;\n    \n    uv.x += 0.1 * sin(time * 0.1);\n    uv.y += 0.05 * sin(time * 0.2);\n    \n    uv.x *= (1.0 - 0.001 * abs(sin(time * 20.0)));\n    \n    float subd = 25.0 + 2.0 * sin(time * 0.1);\n    float radius = 0.1 + 0.45 + 0.05 * abs(sin(time));\n    vec3  color = vec3(0.0);\n    \n    float hsub = subd*2.0;\n    vec2 grid = uv * subd;\n    grid = vec2(floor(grid.x)/subd, floor(grid.y)/subd);\n    vec2 gridC = vec2(grid.x + 1.0/hsub, grid.y+1.0/hsub);\n    \n    vec2 mDist = vec2(sin(time)*(0.7 + 0.3 * cos(time * 0.5)), cos(time)*0.3) - grid;\n    \n    float weight = 0.0;\n    if(length(mDist) < radius) {\n        weight = smoothstep(0.0, 0.3, max(0.0, radius - length(mDist)));\n    }\n    \n    float qbRadius = clamp(0.5*smoothstep(0.5, 0.1, length(mDist)), 0.2, 0.5);\n    float qbWeight = 0.85*smoothstep(0.5, 0.1, length(mDist));   \n    \n    vec2 cellD = uv - gridC;\n\tfloat finalRadius = qbRadius/subd;\n    float rings = 0.0;\n    if(length(cellD) < qbRadius/subd) {\n        float col = 0.0;\n        col = smoothstep(0.9,0.85,length(cellD)/(qbRadius/subd));\n        col -= 0.93*smoothstep(1.0,0.9,length(cellD)/(qbRadius/subd*qbWeight));\n        \n        rings += col;\n    }\n       \n    float r = 0.5 + 0.5*((grid.x+0.5) * cos(time * 3.0));\n    float b = 0.7;\n    float g = 0.5 + 0.5*((grid.y+0.5) * sin(time * 2.0));\n    \n    color = \n        vec3(0.03) \n        + rings*vec3(r, g, b)*0.05\n        + rings*weight*vec3(r, g, b)*2.5\n        + weight*vec3(r, g, b)*0.3\n        + vec3(hash(uv.x * 0.05), hash(uv.y* 0.05), hash(uv.x + uv.y))* 0.01;\n    \n    fragColor = vec4(color.rgb, 1.0);\n    //fragColor = vec4(r,g,b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 42, 42, 88], [99, 99, 156, 156, 2014]], "test": "ok"}
{"id": "Xt2SDc", "name": "Everything Glowing II", "author": "834144373", "description": "the tutorial for young coder and students to easy undersand.\nhere you see a good effect : http://www.glslsandbox.com/e#28742.0\nmove the mouse to change the color", "tags": ["3d", "raymarching", "distancefield", "glowing", "density"], "likes": 30, "viewed": 1696, "published": "Public API", "date": "1446984670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Everythng Glowing.glsl\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//Created by 834144373  2015/11/8\n///////////////////////////////////////////////////////////////////////////////////////\nvec3 roty(vec3 p,float angle){\n  float s = sin(angle),c = cos(angle);\n    mat3 rot = mat3(\n      c, 0.,-s,\n        0.,1., 0.,\n        s, 0., c\n    );\n    return p*rot; \n}\n///////////////////////////////////\n//raymaching step I for normal obj\n///////////////////////////////////\nfloat obj(vec3 pos){\n    pos -= vec3(0.,-.6,0.);\n    //here you can see \"inigo quilez's particles about the distance field function\" who's id named \"iq\"....\n    float res =  length(max(abs(pos)-vec3(0.8,0.2,0.35),0.0))-0.1;\n\tres = min(res,length(abs(pos-vec3(0.,0.7,0.))-vec3(0.7,0.4,0.4))-.3);\n    return res;\n}\n\n//raymarching step I\n//find object\nfloat disobj(vec3 pointpos,vec3 dir){\n    float dd = 1.;\n    float d = 0.;\n    for(int i = 0;i<45;++i){\n      vec3 sphere = pointpos + dd*dir;\n          d = obj(sphere);\n      dd += d;\n\tif(d<0.02)break;\n    }\n    return dd;\n}\n\n//////raymarching step II for detail obj\n/////////////////////////////////////////////////////////////\n//Inspired form guil https://www.shadertoy.com/view/MtX3Ws\n//and I changed something\nfloat objdetal(in vec3 p) {\n  \tfloat res = 0.;\n    vec3 c = p;\n  \tfor (int i = 0; i < 10; ++i) {\n        p =1.7*abs(p)/dot(p,p) -0.8;\n        p=p.zxy;\n        res += exp(-20. * abs(dot(p,c)));        \n  }\n  return res/2.;\n}\n////////////////////////////////////////////////////\n//raymarching step II \n//raymarching  inside of the objects\n//and sample the \"density\"=\"min distance\" with the raymarching\nvec4 objdensity(vec3 pointpos,vec3 dir,float finaldis){\n  vec4 color=vec4(0.);\n    float den = 0.;\n    vec3 sphere = pointpos + finaldis*dir;\n    float dd = 0.;\n    for(int j = 0;j<45;++j){\n        vec4 col;\n        col.a = objdetal(sphere);\n        float c = col.a/200.;\n        col.rgb = vec3(c,c,c*c);\n        col.rgb *= col.a;\n        col.rgb *= float(j)/20.;\n        dd = 0.01*exp(-2.*col.a);\n        sphere += dd*dir;\n        color += col*0.8;\n        if(color.a/200.>.9 || dd>200.)break;\n    }\n    return color*4.5;\n}\n/////////////////////////////////////////\n/////////////////////////////////////////\n#define time iTime*0.3\nvoid mainImage(out vec4 color,in vec2 PixelUV)\n{\n    vec2 uv = (PixelUV.xy / iResolution.xy-0.5)*2.;\n         uv.x *= iResolution.x/iResolution.y;\n    vec2 Mo = iMouse.xy/iResolution.xy;\n\t\t Mo = (vec2(1.-Mo.x,Mo.y)-0.5)*2.2;\n    ///////////////////\n    vec3 dir = normalize(vec3(uv,2.));\n         dir = roty(dir,time);\n    ///////////////////\n    vec3 campos = vec3(0.,0.,-2.8);\n         campos = roty(campos,time);\n    //raymarching step I\n    float finaldis = disobj(campos,dir);\n    vec4 col = vec4(0.061,0.06,0.061,1.);\n    if(finaldis < 20.){\n        //raymarching step II\n        //raymarching in raymarching, no raymarching and raymarching\n        col = objdensity(campos,dir,finaldis);\n        col += 0.6*col*vec4(0.7+Mo.x,0.8+Mo.y,0.5,1.);\n    }\n    color = vec4(col.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2SDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 233, 263, 263, 403], [404, 511, 531, 531, 823], [825, 860, 897, 897, 1085], [1087, 1275, 1302, 1302, 1498], [1499, 1675, 1730, 1730, 2199], [2307, 2307, 2355, 2355, 3094]], "test": "ok"}
{"id": "Xt2SDd", "name": "SwegShit2", "author": "TinoPit", "description": "Have som' LSD", "tags": ["drugd"], "likes": 1, "viewed": 122, "published": "Public", "date": "1447408670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat distanceTo(float x, float y, float centerX, float centerY) {\n\tfloat deltaX = x - centerX;\n    float deltaY = y - centerY;\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{\n    float zoom = (iResolution.x / 10.0) * (1.0 + 0.1 * cos(20.0 * iTime));\n    float cameraX = 5.0 + 3.0 * cos(iTime * 0.5);\n    float cameraY = 2.0 + 3.0 * sin(iTime * 1.1);\n    \n    float cameraAngle = 20.0*(3.14/180.0)+iTime*3.0;\n    \n    float xBeforeRot = (pixCoords.x / zoom) - cameraX;\n    float yBeforeRot = (pixCoords.y / zoom) - cameraY;\n    \n    float x = (xBeforeRot*cos(cameraAngle))+(yBeforeRot*sin(cameraAngle));\n    float y = (-xBeforeRot*sin(cameraAngle))+(yBeforeRot*cos(cameraAngle));\n\n    \n    float radius = 0.3 + 0.2 * rand(vec2(floor(x), floor(y)));// * cos(3.0 * iTime + x + y);\n    radius *= 0.8 + 0.3 * cos(10.0 * rand(vec2(floor(x), floor(y))) * iTime);\n    float distance = distanceTo(mod(x, 1.0), mod(y, 1.0), 0.5, 0.5);\n    if (distance < radius) {\n        color = vec4(cos(20.0 * distance / radius), sin(iTime*10.0), cos(iTime*20.0), 1.0);\n        return;\n    }\n    \n    float light = (cos(y * 3.0 + 6.0 * iTime) + 1.0) * 0.5;\n    color = vec4(cos(iTime*20.0), light, light * (0.5 + 0.5 * cos(x * 30.0)), 1.0);\n    \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2SDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 160, 160, 275], [277, 277, 330, 330, 1379]], "test": "ok"}
{"id": "Xt2SDV", "name": "2015/11/04", "author": "hughsk", "description": "2D light/shadows with a single point light â€“ I'm sure there's a faster/simpler way to do this, but it does the trick! Click and drag to move the light. Note that it'll clear out solids in close proximity to it.", "tags": ["2d", "lighting", "shadows"], "likes": 33, "viewed": 3047, "published": "Public API", "date": "1446680326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 80\n\n#define sr(a) (a * 2.0 - 1.0)\n#define rs(a) (a * 0.5 + 0.5)\n#define sq(a) (a * vec2(1, iResolution.y / iResolution.x))\n\nfloat random(vec2 co) {\n   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat t = iTime * 1.;\n\nfloat map(vec2 p, vec2 ro) {\n    vec2 P = p;\n    \n    float w = 0.15;\n    float r = 0.03125;\n    float a = t;\n    float d = 0.0;\n    \n    p.y += iTime * 0.15;\n    \n    vec2 idx = floor(p / w * 0.5 + 0.5);\n    \n    r += sin((idx.x + idx.y) * 2. + t * 5.) * 0.009;\n    a += sin((idx.x + idx.y));\n    \n    p = mod(p + w, w * 2.) - w;\n    d = length(p - 0.095 * vec2(sin(a), cos(a))) - r;\n    d = smin(d, length(P) - 0.25, 0.05);\n    d = -smin(-d, length(P - ro) - 0.05, 0.05);\n    \n\treturn d;\n}\n\nfloat shadow(vec2 uv, vec2 ro, vec2 rd) {\n    float lim = 0.0005;\n    float res = -1.0;\n    float inc = lim * 2.0;\n    float t = inc;\n    float maxt = length(ro - uv);\n    \n    if (map(uv, ro) < 0.0) return 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        if (t >= maxt) return -1.0;\n        float d = map(uv - rd * t, ro);\n        if (d <= 0.0) return 0.0;\n        \n        t = min(t + d * 0.2, maxt);\n        res = t;\n    }\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = sq(sr(fragCoord.xy / iResolution.xy));\n    vec2 ro = (iMouse.z > 0.\n        ? sq(sr(iMouse.xy / iResolution.xy))\n        : 0.5 * vec2(\n            sin(iTime),\n            cos(iTime)\n        ));\n    \n    vec2 rd = normalize(uv - ro);\n    float s = shadow(uv, ro, rd) > -0.5 ? 0.35 : 1.0;\n    float l = s * pow(max(0.0, 1.0 - length(ro - uv) * 0.8), 2.5);\n    float d = map(uv, ro);\n    \n    bool inside = d < 0.0;\n    bool stroke = d > -0.005 && inside; \n    vec3 m = inside ? vec3(stroke ? 0 : 5) : vec3(1, 0.9, 0.7);\n    \n\tfragColor = vec4(m * l, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2SDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 161, 161, 231], [233, 233, 272, 272, 371], [396, 396, 424, 424, 887], [889, 889, 930, 930, 1344], [1347, 1347, 1404, 1404, 1969]], "test": "ok"}
{"id": "XtBSW3", "name": "SineTree3d", "author": "jt", "description": "A tree-like structure without recursion, using trigonometric functions with fract for branching - suitable for ray-tracing :-)\n(see [url]https://www.shadertoy.com/view/MljXDV[/url], [url]https://www.shadertoy.com/view/ll2XDV[/url] for 2d variants).", "tags": ["raytracer", "implicitsurface", "floor", "fract", "ceil", "trigonometricfunctions", "pow", "sign", "sinetree"], "likes": 16, "viewed": 367, "published": "Public", "date": "1446692817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SineTree3d (a ray-traced Sine Tree) - written 2015-11-05 by Jakob Thomsen\n// A tree-like structure without recursion, using trigonometric functions with fract for branching - suitable for ray-tracing :-)\n// Thanks to FabriceNeyret2 for streamlining the functions.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat mirror(float v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nfloat sinetree2d(vec2 v)\n{\n    v.x = mirror(v.x);\n    float n = 3.0; // fract(t / 6.0) * 6.0;\n    float br = exp2(ceil(v.y * n));\n    float fr = fract(v.y * n);\n    float val = cos(pi * (v.x * br + pow(fr, 1.0 - fr) * 0.5 * sign(sin(pi * v.x * br))));\n    return 1.0 - pow(0.5 - 0.5 * val, (fr * 1.5 + 0.5) * 1.0);\n}\n\nfloat fn(vec3 v)\n{\n    return max(sinetree2d(vec2(length(v.xy), v.z)), sinetree2d(vec2(atan(v.x, v.y), v.z))); // JT's SineTree 3d (original)\n    // Variations by FabriceNeyret2\n    //return sinetree2d(vec2(atan(v.x, v.y), v.z));\n    //return sinetree2d(vec2(length(v.xy), v.z));\n}\n\nvec3 nrm(vec3 v)\n{\n    vec3 n;\n    float d = 0.01;\n    n.x = fn(v + vec3(d, 0.0, 0.0)) - fn(v + vec3(-d, 0.0, 0.0));\n    n.y = fn(v + vec3(0.0, d, 0.0)) - fn(v + vec3(0.0, -d, 0.0));\n    n.z = fn(v + vec3(0.0, 0.0, d)) - fn(v + vec3(0.0, 0.0, -d));\n    return normalize(n);\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec4 tex(vec3 v)\n{\n    float d = abs(v.z * 20. + sfract(-iTime, 4.) * 5.); \n    vec4 c0 = clamp(vec4(0, v.z, 1. - v.z, 0), 0.,1.);\n    vec4 c1 = vec4(0.5 + 0.5 * nrm(v), 1.0);\n    vec4 c = mix(c0, c1, vec4(0.5 - 0.5 * cos(0.05 * iTime * 2.0 * pi))); // change color-palette to enhance branching structure visibility\n    return exp(-d*d) + c * abs(nrm(v).x);\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float phi = iTime*.1,  C=cos(phi), S=sin(phi);\n\n    vec3 v = vec3(uv, depth);\n    \n    v *= mat3( 0, 1,-1,\n              -1,-1,-1, \n               1,-1,-1 );\n\n    v.zy *=  mat2 (C,S,-S,C); // could be mixed above\n    \n    return v;\n}\n\nvoid mainImage( out vec4 o,  vec2 uv )\n{\n    float t = iTime * 0.1;\n    vec2 R  = iResolution.xy;\n        uv = ( 2. * uv - R)  / R.y;\n\n    vec3 w = vec3(0), v;\n    \n    for(float layer = 0.; layer < 1.; layer += 1./256.) \n        v = camera(uv, 2. * layer - 1.),\n        abs(v.x) < 1. && abs(v.y) < 1. && abs(v.z) < 1. && abs(fn(v)) < .05 ?  w = v : w;\n    \n    // o = tex(w);\n    o = all(equal(w, vec3(0))) ? vec4(0.0) : tex(w); // avoids flashing background\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBSW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[438, 438, 476, 476, 543], [545, 545, 568, 568, 614], [616, 616, 642, 642, 932], [934, 934, 952, 952, 1215], [1217, 1217, 1235, 1235, 1492], [1494, 1494, 1524, 1524, 1576], [1578, 1578, 1596, 1596, 1937], [1939, 1939, 1974, 1974, 2212], [2214, 2214, 2254, 2254, 2675]], "test": "ok"}
{"id": "XtBSWt", "name": "Starfield Math", "author": "AstronautStr", "description": "win95 screensaver cover :) \nthe goal was to recreate famous screensaver WITHOUT using ANY BUFFERS/structs for storing particles. only math)", "tags": ["procedural", "math", "stars"], "likes": 25, "viewed": 1434, "published": "Public", "date": "1447091739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_2PI 6.28318530718\nvec2 polar(vec2 dPoint)\n{\n    return vec2(sqrt(dPoint.x * dPoint.x + dPoint.y * dPoint.y), atan(dPoint.y, dPoint.x));\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 decart(vec2 pPoint)\n{\n    return vec2(pPoint.x * cos(pPoint.y), pPoint.x * sin(pPoint.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen = iResolution.xy;\n    vec2 center = screen / 2.0;\n    vec2 frag = fragCoord.xy - center;\n    vec2 fragPolar = polar(frag);\n    float lenCenter = length(center);\n    \n\tconst float bandPass = 720.0;\n    const float angleDisp = M_2PI / (bandPass + 1.0);\n    \n    const float particlesCount = 200.0;\n    const float particleLifetime = 10.0;\n    const float particleMaxSize = 7.5;\n    float particleMaxSizeNorm = particleMaxSize / lenCenter;\n    \n    float globTime = iTime / particleLifetime;\n    float timeDelta = bandPass;\n    \n    const float polarRadiusClip = 0.05;\n    const float polarRadiusMax = 0.75;\n    float polarRadiusDelta = polarRadiusMax - polarRadiusClip; \n    \n    float presence = 0.0;\n    vec2 pPoint;\n    \n    for (float i = 0.0; i < particlesCount; i += 1.0)\n    {\n        float phase = i / particlesCount;\n        \n        float localTime = globTime + timeDelta * (2.0 * phase - 1.0) + phase;\n        float particleTime = fract(localTime);\n        float spaceTransform = pow(particleTime, 8.0);\n        \n        pPoint.x = lenCenter * ((polarRadiusClip + polarRadiusDelta * phase) + spaceTransform);\n        \n        // +30 FPS :)\n        if (abs(pPoint.x - fragPolar.x) > particleMaxSize) continue;\n        \n        pPoint.y = floor(particleTime + bandPass * rand(vec2(floor(localTime), 1))) * angleDisp;\n        \n        vec2 dPoint = decart(pPoint);        \n        float particleSize = particleMaxSize * spaceTransform;\n        float localPresence = particleSize * (1.0 - clamp(length(dPoint - frag), 0.0, 1.0));\n        presence += localPresence;\n    }\n    presence = clamp(presence, 0.0, 1.0);\n    fragColor = vec4(presence, presence, presence, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 53, 53, 147], [149, 149, 170, 170, 242], [244, 244, 270, 270, 341], [343, 343, 400, 400, 2093]], "test": "ok"}
{"id": "XtBXWK", "name": "01", "author": "yiwenl", "description": "Learning ray tracing, homework 01", "tags": ["raytracing"], "likes": 2, "viewed": 803, "published": "Public API", "date": "1446375382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat smin( float a, float b )\n{\n    return smin(a, b, 3.0);\n}\n\nfloat iPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat iSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n\nfloat map(vec3 pos) {\n    float dPlane = iPlane(pos);\n    float dSphere = iSphere(pos, 2.0);\n    \n    float s1 = iSphere(pos - vec3(sin(iTime*.55)*1.85, cos(iTime*.19) * 0.95, sin(iTime*.91) * 1.21) * 1.0, 2.6451);\n    float s2 = iSphere(pos - vec3(cos(iTime*.43)*1.55, sin(iTime*.38) * 1.12, cos(iTime*.76) * 1.67) * 1.4, 2.564821);\n    float s3 = iSphere(pos - vec3(sin(iTime*.26)*2.52, cos(iTime*.57) * 0.56, sin(iTime*.12) * 1.58) * 1.2, 2.98441);\n    float s4 = iSphere(pos - vec3(sin(iTime*.97)*1.72, sin(iTime*.22) * 0.81, cos(iTime*.34) * 0.97) * 1.5, 2.12373);\n    float s5 = iSphere(pos - vec3(sin(iTime*.62)*1.47, cos(iTime*.76) * 0.73, sin(iTime*.75) * 1.45) * 1.7, 2.2748186);\n    \n    return smin(s1, smin(s2, smin(s3, smin(s4, s5))));\n}\n\nconst float PI = 3.141592657;\nconst vec3 lightDirection = vec3(1.0, 1.0, -1.0);\nconst vec4 lightBlue = vec4(186.0, 209.0, 222.0, 255.0)/255.0;\n\nfloat diffuse(vec3 normal) {\n    return max(dot(normal, normalize(lightDirection)), 0.0);   \n}\n\nfloat specular(vec3 normal, vec3 dir) {\n\tvec3 h = normalize(normal - dir);\n\treturn pow(max(dot(h, normal), 0.0), 40.0);\n}\n\nvec3 getColor(vec3 pos, vec3 normal, vec3 dir) {\n    pos.xz = rotate(pos.xz, sin(iTime*.25)*.2);\n    pos.yz = rotate(pos.yz, cos(sin(iTime*.25)*.2)+iTime*.1) * .3;    \n    float zOffset = 200.0 + sin(cos(iTime*0.443256)*0.716786) * 200.0;\n    zOffset = 1.0 + zOffset*.05;\n    float grey = fract(pos.z*zOffset - iTime*.1);\n    grey = 1.0 - sin(grey * PI);\n    grey *= mix(1.0 + sin(pos.z*50.0 - iTime*.1) * 0.5, 0.0, .25);\n    grey = grey * grey;\n    \n    float diff = diffuse(normal);\n    float spec = specular(normal, dir);\n    \n//    return vec3(grey+diff*.75);\n    return vec3(grey+spec*.75+diff*.5);\n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.01, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n\t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n\t\tmap(pos + eps.yyx) - map(pos - eps.yyx)\n\t);\n\treturn normalize(normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focus = 1.25;\n    vec3 pos = vec3(0.0, 0.0, -10.0);\n    vec3 dir = normalize(vec3(uv, focus));\n    \n    vec4 color = vec4(.0);\n    float d;\n    \n    const int NUM_ITER = 64;\n    for(int i=0; i<NUM_ITER; i++) {\n        d = map(pos);\n        if(d < 0.0001) {\n            vec3 normal = computeNormal(pos);\n            color.rgb = getColor(pos, normal, dir);\n            color.a = 1.0;\n            break;\n        }\n        \n        pos += d * dir;\n        if(length(pos) > 10.0) break;\n    }\n    \n    color = color;\n    \n\tfragColor = vec4(color) * lightBlue;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 118], [120, 120, 161, 161, 232], [234, 234, 266, 266, 296], [298, 298, 322, 322, 342], [344, 344, 383, 383, 418], [421, 421, 442, 442, 1172], [1318, 1318, 1346, 1346, 1412], [1414, 1414, 1453, 1453, 1535], [1537, 1537, 1585, 1585, 2142], [2144, 2144, 2174, 2174, 2386], [2389, 2389, 2446, 2446, 3129]], "test": "ok"}
{"id": "XtjSDK", "name": "Sculpture III", "author": "iq", "description": "Another sine/cosine deformation of a sphere.", "tags": ["3d", "raymarching", "noise", "trigonometry"], "likes": 175, "viewed": 11456, "published": "Public API", "date": "1446586286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat hash1( in vec2 f ) \n{ \n    return fract(sin(f.x+131.1*f.y)*43758.5453123); \n}\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nvec4 grow = vec4(1.0);\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += 1.000*sin(  2.0*p.yzx )*grow.x;\n    p.xyz += 0.500*sin(  4.0*p.yzx )*grow.y;\n    p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;\n    p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;\n    return p;\n}\n\nfloat map( vec3 q )\n{\n    vec3 p = mapP( q );\n    float d = length( p ) - 1.5;\n\treturn d * 0.05;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<1256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.005,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*1.0 )*32.0, 0.0, 1.0 );\n    }\n\tao /= 64.0;\n\t\n    return clamp( ao*ao, 0.0, 1.0 );\n}\n\nfloat calcAO2( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*0.2 )*100.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#define ZERO (min(iFrame,0))\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\t\tvec2 q = (fragCoord+o)/iResolution.xy;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\tvec2 q = fragCoord/iResolution.xy;\n#endif\n\n    \n        grow = smoothstep( 0.0, 1.0, (iTime-vec4(0.0,1.0,2.0,3.0))/3.0 );\n\n\n        //-----------------------------------------------------\n        // camera\n        //-----------------------------------------------------\n\n        float an = 1.1 + 0.05*(iTime-10.0);\n\n        vec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n        vec3 ta = vec3(0.0,0.2,0.0);\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n        //-----------------------------------------------------\n        // render\n        //-----------------------------------------------------\n\n        vec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n        // raymarch\n        float t = intersect(ro,rd);\n\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n            vec3 sor = nor;\n\n            vec3 q = mapP( pos );\n            float occ = calcAO( pos, nor, fragCoord ); occ = occ*occ;\n\n            // materials\n            col = vec3(0.04);\n            float ar = clamp(1.0-0.7*length(q-pos),0.0,1.0);\n            col = mix( col, vec3(2.1,2.0,1.2), ar);\n            col  *= 0.3;          \n            col *= mix(vec3(1.0,0.4,0.3), vec3(0.8,1.0,1.3), occ);\n            float occ2 = calcAO2( pos, nor, fragCoord );\n\n\n            col *= 1.0*mix( vec3(2.0,0.4,0.2), vec3(1.0), occ2*occ2*occ2 );\n            float ks = texCube( iChannel0, pos*1.5, nor, 4.0 ).x;\n            ks = 0.5 + 1.0*ks;\n            ks *= (1.0-ar);\n\n            // lighting\n            float sky = 0.5 + 0.5*nor.y;\n            float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n            float spe = pow(max( dot(-rd,nor),0.0),8.0);\n            // lights\n            vec3 lin  = vec3(0.0);\n                 lin += 3.0*vec3(0.7,0.80,1.00)*sky*occ;\n                 lin += 1.0*fre*vec3(1.2,0.70,0.60)*(0.1+0.9*occ);\n            col += 0.3*ks*4.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.05+0.95*pow(fre,5.0))*(0.5+0.5*nor.y)*occ;\n            col += 4.0*ks*1.5*spe*occ*col.x;\n            col += 2.0*ks*1.0*pow(spe,8.0)*occ*col.x;\n            col = col * lin;\n\n            // dust\n            col = mix( col, 0.2*fre*fre*fre+0.6*vec3(0.6,0.55,0.5)*sky*(0.8+0.4*texCube( iChannel0, pos*8.0, nor, 4.0 ).xyz), 0.6*smoothstep(0.3,0.7,nor.y)*sqrt(occ) );\n\n            col *= 2.6*exp(-0.2*t);\n        }\n\n        col = pow(col,vec3(0.4545));\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    tot = pow( tot, vec3(1.0,1.0,1.4) ) + vec3(0.0,0.02,0.14);\n    \n    tot += (1.0/255.0)*hash1( fragCoord );\n    \n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjSDK.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[749, 749, 773, 773, 815], [817, 817, 844, 844, 900], [1009, 1009, 1045, 1045, 1221], [1247, 1247, 1268, 1268, 1464], [1466, 1466, 1487, 1487, 1564], [1566, 1566, 1609, 1609, 1864], [1866, 1866, 1898, 1898, 2109], [2111, 2111, 2166, 2166, 2443], [2445, 2445, 2501, 2501, 2776], [2778, 2778, 2843, 2843, 3027]], "test": "error"}
{"id": "XtjXDc", "name": "06", "author": "yiwenl", "description": "06\nDiffuse / Specular Function from hughsk : https://www.shadertoy.com/view/4tjXDV", "tags": ["raymarch"], "likes": 3, "viewed": 778, "published": "Public API", "date": "1446994627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//float time = iTime*2.0;\n\n//\tTOOLS\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\n//\tGEOMETRY\nfloat sphere(vec3 pos, float radius) {\treturn length(pos) - radius;\t}\nfloat displacement(vec3 p) {\treturn sin(2.0*p.x+iTime*.983265)*sin(2.0*p.y+iTime*.57834)*sin(1.0*p.z+iTime*0.857834) * .5 + .5;\t}\nfloat box(vec3 pos, vec3 size) {\treturn length(max(abs(pos) - size, 0.0)); }\n\nfloat substract(float d1, float d2) {\treturn max(-d1,d2);\t}\nfloat intersection(float d1, float d2) { return max(d1, d2);\t}\n\nconst float PI      = 3.141592657;\nconst float thickness = .05;\nconst float gap = .15;\nconst float numLayers = 7.0;\nconst float diff = .3;\nconst float sphereRadius = 3.0;\n\nfloat map(vec3 pos) {\n\tpos.yz = rotate(pos.yz, -PI*.15+sin(iTime*.5)*.05);\n\tpos.xz = rotate(pos.xz, -PI*.15+cos(iTime*.5)*.05);\n\tfloat d = sphere(pos, sphereRadius);\n\n\tfloat r = length(pos.xy);\n\tfloat a = atan(pos.y, pos.x);\n\tfloat dOffset = cos( (a+r*6.0)*1.0-iTime*.5) * .5 + .5;\n\tdOffset *= 1.0-r/sphereRadius;\n\td += dOffset * .2;\n\t\n\treturn d;\n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.01, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n\t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n\t\tmap(pos + eps.yyx) - map(pos - eps.yyx)\n\t);\n\treturn normalize(normal);\n}\n\n\n//\tLIGHTING\n\nfloat gaussianSpecular(vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float shininess) {\n\tvec3 H = normalize(lightDirection + viewDirection);\n\tfloat theta = acos(dot(H, surfaceNormal));\n\tfloat w = theta / shininess;\n\treturn exp(-w*w);\n}\n\nfloat orenNayarDiffuse(vec3 lightDirection,\tvec3 viewDirection,\tvec3 surfaceNormal,\tfloat roughness, float albedo) {\n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;\n}\n\nconst vec3 lightPos0 = vec3(1.0, 1.0, -1.0);\nconst vec3 lightColor0 = vec3(1.0, 1.0, .96);\nconst float lightWeight0 = 1.25;\n\nconst vec3 lightPos1 = vec3(-1.0, -0.75, -.6);\nconst vec3 lightColor1 = vec3(.96, .96, 1.0);\nconst float lightWeight1 = 0.5;\nconst float maxDist = 6.0;\n\n\nvec4 getColor(vec3 pos, vec3 dir, vec3 normal) {\n\tvec3 diff0 = orenNayarDiffuse(normalize(lightPos0), -dir, normal, 1.1, lightWeight0) * lightColor0;\n\tvec3 diff1 = orenNayarDiffuse(normalize(lightPos1), -dir, normal, 1.1, lightWeight1) * lightColor1;\n\tfloat spec = gaussianSpecular(normalize(lightPos0), -dir, normal, .1) * 1.0;\n\n\tvec3 color = vec3(diff0 + diff1 + spec);\n\n\treturn vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focus = 2.25;\n    vec3 pos   = vec3(sin(iTime*.1)*0.0, 0.0, -10.0);\t\t//\tposition of camera\n\tvec3 dir   = normalize(vec3(uv, focus));\t//\tray\n\tvec4 color = vec4(0.0);\n\tfloat bg = dot(dir, vec3(0.0, 0.0, -1.0));\n\tfloat prec = 0.0001;\n\tfloat d;\n\t\n\tfor(int i=0; i<64; i++) {\n\t\td = map(pos);\t\t\t\t\t\t//\tdistance to object\n\n\t\tif(d < prec) {\t\t\t\t\t\t// \tif get's really close, set as hit the object\n\t\t\tcolor       = vec4(1.0);\n\t\t\tvec3 normal = computeNormal(pos);\n\t\t\tcolor       = getColor(pos, dir, normal);\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += d * dir;\t\t\t\t\t\t//\tmove forward by\n\t\tif(length(pos) > maxDist) break;\n\t}\n\t\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 36, 72, 72, 154], [156, 168, 206, 206, 237], [238, 238, 266, 266, 367], [368, 368, 400, 400, 444], [446, 446, 483, 483, 505], [506, 506, 546, 546, 568], [742, 742, 763, 763, 1090], [1092, 1092, 1122, 1122, 1334], [1350, 1350, 1452, 1452, 1600], [1602, 1602, 1718, 1718, 2198], [2479, 2479, 2527, 2527, 2879], [2881, 2881, 2938, 2938, 3681]], "test": "ok"}
{"id": "XtSSWc", "name": "Motion Graphics", "author": "Branch", "description": "Motion Graphics", "tags": ["motiongraphics"], "likes": 21, "viewed": 291, "published": "Public", "date": "1446758187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct polygon{\n\tvec2 A, B, C;\n};\nfloat sgn(vec2 p1, vec2 p2, vec2 p3){\n  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nint PointInTriangle(vec2 pt, vec2 v1, vec2 v2, vec2 v3){\n\tint b1, b2, b3;\n\n\tif(sgn(pt, v1, v2) < 0.0) b1=1;\n\tif(sgn(pt, v2, v3) < 0.0) b2=1;\n\tif(sgn(pt, v3, v1) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nint PointInTriangle(vec2 pt, polygon X){\n\tint b1, b2, b3;\n\n\tif(sgn(pt, X.A, X.B) < 0.0) b1=1;\n\tif(sgn(pt, X.B, X.C) < 0.0) b2=1;\n\tif(sgn(pt, X.C, X.A) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nfloat box(vec2 coord, vec2 pos, vec2 size){\n\tif((coord.x<(pos.x+size.x)) &&\n\t   (coord.x>(pos.x-size.x)) &&\n\t   (coord.y<(pos.y+size.y)) && \n\t   (coord.y>(pos.y-size.y)) ) \n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat sun(vec2 coord, vec2 pos, float size){\n\tif(length(coord-pos)<size)\n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nfloat triangle( vec2 coord, vec2 pos, float angle, float thick, float size){\n    vec2 original_coord = coord;\n    coord += pos;\n    coord *= rotate(angle);\n    float collision = 0.0;\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2( 0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.3,-0.2)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += 3.0*texture( iChannel0, original_coord * 0.6 + vec2(iTime*0.02) ).b * 0.6;\n    collision += 2.5*texture( iChannel0, original_coord * 0.1 + vec2(iTime*0.001) ).b * 0.4;\n    return -min(max(-collision,0.0),1.0);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec4 tulos;\n\tvec4 lopullinentulos=vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 ori_coord=coord;\n\tfor(float rgbare=0.0; rgbare<2.0; rgbare++){\n\tcoord = vec2(aspectCorrection,1.0) *coordinate_entered * (1.+0.2*cos(iTime*0.05));\n\tcoord.x*=1.0+rgbare*0.02;\n\tcoord*=1.0+rand(coord+iTime)/(pow(iTime,7.0)*3.0)-length(coord)*10.0/(pow(iTime*1.1,24.0));\n\tcoord*=1.0+0.1*sin(1.01*0.1);\n\ttulos=vec4(vec3(0.0/255.0, 0.0/255.0, 0.0/255.0),1.0);\n    \n    float beat = ceil(iTime);\n    coord*=1.0+0.3*sin(iTime*10.)/(1.+33.*mod(iTime,1.));\n\t\n    if(beat>24.)\n    \tcoord+=max(2.0-(iTime-24.)/2.,0.)*vec2(rand(floor(coord*2.))-0.5,rand(floor(coord*2.+44.))-0.5);\n\tvec3 taikurivitunluttinen=vec3(0.);\n    if(beat>8.){\n    \ttaikurivitunluttinen.rb+=0.7*max(1.0-(iTime-8.)/2.,0.)*vec2(rand(floor(coord*2.))-0.5,rand(floor(coord*2.+44.))-0.5);\n    \ttaikurivitunluttinen.rg+=0.7*max(1.0-(iTime-8.)/2.,0.)*vec2(rand(floor(coord))-0.5,rand(floor(coord+44.))-0.5);\n    \ttaikurivitunluttinen.rb-=0.7*max(1.0-(iTime-8.)/2.,0.)*vec2(rand(floor(coord*1.9))-0.5,rand(floor(coord*1.9+44.))-0.5);\n    \ttaikurivitunluttinen.rg-=0.7*max(1.0-(iTime-8.)/2.,0.)*vec2(rand(floor(coord*.9))-0.5,rand(floor(coord*.9+44.))-0.5);\n    }\n    if(beat>10.){\n        coord.x+=( 0.2*sin(iTime*12.+coord.y) ) / (1.0-10.*(iTime-10.));\n        coord.y+=( 0.2*sin(iTime*12.+coord.x) ) / (1.0-22.*(iTime-10.));\n    }\n        \n    if(beat>18.){\n        coord.x+=( 0.2*sin(iTime*12.+coord.y) ) / (1.0-22.*(iTime-18.));\n        coord.y+=( 0.2*sin(iTime*12.+coord.x) ) / (1.0-22.*(iTime-18.));\n    \ttaikurivitunluttinen.rb+=0.7*max(1.0-(iTime-18.)/2.,0.)*vec2(rand(floor(coord*2.))-0.5,rand(floor(coord*2.+44.))-0.5);\n    \ttaikurivitunluttinen.rg+=0.7*max(1.0-(iTime-18.)/2.,0.)*vec2(rand(floor(coord))-0.5,rand(floor(coord+44.))-0.5);\n    \ttaikurivitunluttinen.rb-=0.7*max(1.0-(iTime-18.)/2.,0.)*vec2(rand(floor(coord*1.9))-0.5,rand(floor(coord*1.9+44.))-0.5);\n    \ttaikurivitunluttinen.rg-=0.7*max(1.0-(iTime-18.)/2.,0.)*vec2(rand(floor(coord*.9))-0.5,rand(floor(coord*.9+44.))-0.5);\n    }\n    if(beat>27.){\n        coord.x+=( 0.2*sin(iTime*12.+coord.y) ) / (1.0-10.*(iTime-27.));\n        coord.y+=( 0.2*sin(iTime*12.+coord.x) ) / (1.0-22.*(iTime-27.));\n        coord.x+=( 0.1*sin(iTime*12.+coord.y) ) * (1.0+(iTime-27.));\n        coord.y+=( 0.1*sin(iTime*12.+coord.x) ) * (1.0+(iTime-27.));\n    }\n        \n        \n        \n\ttulos.rgb+=taikurivitunluttinen;\n    if(beat>28.)\n        coord/=4.3*(iTime-27.75);\n    if(beat>10.)\n        coord*=1.0+0.3*length(coord)*length(coord)*min(max((iTime-10.)*3.,0.),1.);\n        \n    if(beat>20. && beat<22.){\n    \tfor(float i=0.; i<8.; i++){\n        \ttulos.rgb += sun(coord, vec2(0.), mod(i*(0.3-.5*(iTime-20.)),14.)/(1.+(1.+i*0.1)*0.8*(iTime-20.)*0.01))*vec3(0.9,0.3,0.4)/(1.+(iTime-20.)/8.);\n        \ttulos.rgb -= sun(coord, vec2(0.), mod(i*(0.3-0.05-.5*(iTime-20.)),14.)/(1.+(1.+i*0.1)*0.8*(iTime-20.)*0.01))*vec3(0.9,0.3,0.4)*1.2/(1.+(iTime-20.)/8.);\n        }\n    }\n    for(float i=0.; i<32.; i++){\n        float magiTime=iTime-21.;\n        float drop=0.1*pow(magiTime*(1.+rand(vec2(i*6464.))),2.);\n    \ttulos.rgb += sun(coord, 22.*magiTime*magiTime*vec2(rand(vec2(i+64.))-0.5,rand(vec2(i+199.))-0.5), max(min(.065+rand(vec2(i))*.04,0.),magiTime))*vec3(0.9,0.3,0.4);\n    }\n        \n        if(beat>14.){\n            if(beat<20.)\n            coord.y+=sin((iTime-14.)/3.);\n        \tcoord*=rotate(iTime-14.);\n        }\n    if(beat>6.)\n        coord*=rotate(min(iTime-6.,3.141*0.5)+sin(iTime*6.)/(1.+4.75*pow(iTime-6.,2.)));   \n        \n    if(beat>8.)\n        coord.y=mod(coord.y+0.5,1.)-0.5;\n    if(beat>12.)\n        coord.y=mod(coord.y+0.5-iTime*4.,1.)-0.5;\n        \n    if(beat>18.){\n        tulos.rgb-=sin(coord.x*0.1);\n        coord.x=mod(coord.x+0.5,1.)-0.5;\n    }\n        \n    if(beat>16.)\n        coord*=rotate(-(iTime-16.)*3.141);\n\tif(mod(coord.x+coord.y+1.01*0.1+iTime/4.,0.2)<0.1){\n\t\tif(box(coord,vec2(0.),vec2(4.,0.4))==1.)\n\t\t   \ttulos.xyz-=vec3(0.4,0.5,0.3)*0.1;\n\t\t\n        if(PointInTriangle(\n        \t\t\t\t\t\t\tcoord, \n        \t\t\t\t\t\t\tvec2(0.,.5),\n        \t\t\t\t\t\t\tvec2(-.5,0.),\n        \t\t\t\t\t\t\tvec2(.5,0.) ) == 1 && beat > 2.)\n\t\t   \ttulos.xyz+=vec3(1.1);\n        if(box(coord,vec2(0.,-.25),vec2(.25,0.25))==1. && beat > 4.)\n\t\t   \ttulos.xyz=vec3(1.);\n        \n\t}\n        \n    if(beat>28.)\n        tulos+=(iTime-27.75);\n        \n    float collision = 0.0;\n    if(collision<0.0)\n        tulos.xyz += vec3(0.1);\n\t\n\ttulos.xyz=tulos.xyz-vec3(min(max(-0.57+length(ori_coord)*0.2,0.0),1.0))+vec3(0.015+0.03*rand(vec2(iTime+ori_coord.x+ori_coord.y,1.01*ori_coord.y*ori_coord.x)));\n\t\n\tif(rgbare==0.0)\n\t\tlopullinentulos.r=tulos.r;\n\tif(rgbare==1.0)\n\t\tlopullinentulos.gb=tulos.gb;\n\t}\n\tlopullinentulos.xyz=lopullinentulos.xyz*(1.2-0.4*mod(fragCoord.y,2.0));\n    lopullinentulos.rgb = pow(lopullinentulos.rgb,vec3(1.0/1.4));\n\tfragColor = lopullinentulos;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSSWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 71, 71, 145], [146, 146, 202, 202, 374], [376, 376, 416, 416, 594], [596, 596, 639, 639, 797], [798, 798, 842, 842, 899], [900, 900, 920, 920, 992], [994, 994, 1020, 1020, 1152], [1153, 1153, 1204, 1204, 1346], [1347, 1347, 1423, 1423, 2026], [2031, 2031, 2087, 2087, 7105]], "test": "error"}
{"id": "XtSXWV", "name": "02 metaballs in sphere", "author": "yiwenl", "description": "metaballs in sphere", "tags": ["raytracking"], "likes": 4, "viewed": 856, "published": "Public API", "date": "1446414363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat smin( float a, float b )\n{\n    return smin(a, b, 3.0);\n}\n\nfloat iPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat iSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n\nfloat map(vec3 pos) {\n    float dSphere = iSphere(pos, 4.5);\n    \n    float s1 = iSphere(pos - vec3(sin(iTime*.55)*1.85, cos(iTime*.19) * 0.95, sin(iTime*.91) * 1.21) * 1.0, 2.6451);\n    float s2 = iSphere(pos - vec3(cos(iTime*.43)*1.55, sin(iTime*.38) * 1.12, cos(iTime*.76) * 1.67) * 1.4, 2.564821);\n    float s3 = iSphere(pos - vec3(sin(iTime*.26)*2.52, cos(iTime*.57) * 0.56, sin(iTime*.12) * 1.58) * 1.2, 2.98441);\n    float s4 = iSphere(pos - vec3(sin(iTime*.97)*1.72, sin(iTime*.22) * 0.81, cos(iTime*.34) * 0.97) * 1.5, 2.12373);\n    float s5 = iSphere(pos - vec3(sin(iTime*.62)*1.47, cos(iTime*.76) * 0.73, sin(iTime*.75) * 1.45) * 1.7, 2.2748186);\n    \n    float d = smin(s1, smin(s2, smin(s3, smin(s4, s5))));\n    \n    return max(d, dSphere);\n}\n\nconst float PI = 3.141592657;\nconst vec3 lightDirection = vec3(1.0, 1.0, -1.0);\nconst vec4 lightBlue = vec4(186.0, 209.0, 222.0, 255.0)/255.0;\n\nfloat diffuse(vec3 normal) {\n    return max(dot(normal, normalize(lightDirection)), 0.0);   \n}\n\nfloat specular(vec3 normal, vec3 dir) {\n\tvec3 h = normalize(normal - dir);\n\treturn pow(max(dot(h, normal), 0.0), 40.0);\n}\n\nvec3 getColor(vec3 pos, vec3 normal, vec3 dir) {\n    pos.xz = rotate(pos.xz, sin(iTime*.25)*.2);\n    pos.yz = rotate(pos.yz, cos(sin(iTime*.25)*.2)+iTime*.1) * .3;    \n    float zOffset = 200.0 + sin(cos(iTime*0.443256)*0.716786) * 200.0;\n    zOffset = 1.0 + zOffset*.05;\n    float grey = fract(pos.z*zOffset - iTime*.1);\n    grey = 1.0 - sin(grey * PI);\n    grey *= mix(1.0 + sin(pos.z*50.0 - iTime*.1) * 0.5, 0.0, .25);\n    grey = grey * grey;\n    \n    float diff = diffuse(normal);\n    float spec = specular(normal, dir);\n    \n//    return vec3(grey+diff*.75);\n    return vec3(grey+spec*.75+diff*.5);\n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.01, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n\t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n\t\tmap(pos + eps.yyx) - map(pos - eps.yyx)\n\t);\n\treturn normalize(normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focus = 1.25;\n    vec3 pos = vec3(0.0, 0.0, -10.0);\n    vec3 dir = normalize(vec3(uv, focus));\n    \n    vec4 color = vec4(.0);\n    float d;\n    \n    const int NUM_ITER = 64;\n    for(int i=0; i<NUM_ITER; i++) {\n        d = map(pos);\n        if(d < 0.0001) {\n            vec3 normal = computeNormal(pos);\n            color.rgb = getColor(pos, normal, dir);\n            color.a = 1.0;\n            break;\n        }\n        \n        pos += d * dir;\n        if(length(pos) > 10.0) break;\n    }\n    \n    color = color;\n    \n\tfragColor = vec4(color) * lightBlue;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 118], [120, 120, 161, 161, 232], [234, 234, 266, 266, 296], [298, 298, 322, 322, 342], [344, 344, 383, 383, 418], [421, 421, 442, 442, 1176], [1322, 1322, 1350, 1350, 1416], [1418, 1418, 1457, 1457, 1539], [1541, 1541, 1589, 1589, 2146], [2148, 2148, 2178, 2178, 2390], [2393, 2393, 2450, 2450, 3133]], "test": "ok"}
