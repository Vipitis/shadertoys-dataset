{"id": "4d23Dd", "name": "SH2014 Diffuse Cellular Broccoli", "author": "yosun", "description": "first try at shaders and shadertoy. ", "tags": ["sh2014"], "likes": 1, "viewed": 199, "published": "Public", "date": "1395286651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// added color.. o.O \n// Andrew Caudwell 2014\n// @acaudwell\n\n#define MAX_RAY_STEPS 100\n#define PI 3.14159265359\n\n#define DEGREES_TO_RADIANS 0.017453292\n\n#define IFS_ITERATIONS 12\n\nstruct IFS {\n    vec3  offset;\n    float scale;\n    vec3  axis;\n    float angle;\n    mat4  transform;\n};\n\nIFS IFS_constructor(vec3 offset, vec3 axis, float angle, float scale) {\n\tIFS ifs;\n\tifs.offset = offset;\n\tifs.axis   = axis;\n\tifs.angle  = angle;\n\tifs.scale  = scale;\n\t\n\treturn ifs;\n}\n\nmat4 calc_transform(inout IFS ifs) {\n    float angle = ifs.angle * DEGREES_TO_RADIANS;\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 t = (1.0-c) * ifs.axis;\n\n    return mat4(\n        vec4(c + t.x * ifs.axis.x, t.y * ifs.axis.x - s * ifs.axis.z, t.z * ifs.axis.x + s * ifs.axis.y, 0.0) * ifs.scale,\n        vec4(t.x * ifs.axis.y + s * ifs.axis.z, (c + t.y * ifs.axis.y),          t.z * ifs.axis.y - s * ifs.axis.x, 0.0) * ifs.scale,\n        vec4(t.x * ifs.axis.z - s * ifs.axis.y, t.y * ifs.axis.z + s * ifs.axis.x, c + t.z * ifs.axis.z, 0.0) * ifs.scale,\n        vec4(ifs.offset, 1.0)\n    );\n}\n\n#define t iTime*0.6\n\nint stage_no;\nfloat stage_t;\n\nIFS ifs_N;\nIFS ifs_lerp;\n\nvoid InitIFS() {\n\n    stage_no  = int(fract(t/float(IFS_ITERATIONS*2)) * float(IFS_ITERATIONS*2));\n    stage_t = smoothstep(0.0, 1.0, fract(t));\n\n    \n    if(stage_no >= IFS_ITERATIONS) {\n        stage_no = IFS_ITERATIONS-(stage_no-IFS_ITERATIONS)-1;\n        stage_t  = 1.0-stage_t;\n    }\n\t\n    // IFS to visualize\n    ifs_N = IFS_constructor(vec3(-1.5), normalize(vec3(-1.0)), -36.0, 1.5);\n\t\n\tifs_lerp.axis   = ifs_N.axis;\n\tifs_lerp.angle  = ifs_N.angle;\n\n\t// interpolate scale and position offset\n\tifs_lerp.offset = ifs_N.offset * stage_t;\n\tifs_lerp.scale  = 1.0 + (ifs_N.scale-1.0) * stage_t;\n\t\n\t// left mouse button disables interpolation\n\tif(iMouse.z>0.0) {\n\t\tifs_lerp = ifs_N;\n\t}\n\t\n    ifs_N.transform    = calc_transform(ifs_N);\n    ifs_lerp.transform = calc_transform(ifs_lerp);\n}\n\n// The definitive Fractal Forums thread about this class of fractals:\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-%28escape-time-ifs%29/\n\nfloat scene(vec3 p) {\n\n\tIFS ifs = ifs_N;\n\t\n\tfloat scale = 1.0;\n\t\t\t\t\n\tfor(int i=0;i<IFS_ITERATIONS;i++) {\n\n\t\tif(i==stage_no) ifs = ifs_lerp;\n\t\telse if(i>stage_no) break;\n\t\t\t\n\t\t// mirror on 2 axis to get a tree shape\n\t\tp.xy = abs(p.xy);\n\t\n\t\t// apply transform\n\t\tp = (ifs.transform * vec4(p, 1.0)).xyz;\n\t\t\n\t\tscale *= ifs.scale;\n\t}\n\t\t\n\t// divide by scale preserve correct distance\n\treturn (length(p)-2.0) / scale;\n}\n\nvec3 normal(vec3 p) {\n\n    vec2 o = vec2(0.001,0.0);\n\n\tfloat d = scene(p);\n\t\n    float d1 = d-scene(p+o.xyy);\n    float d2 = d-scene(p+o.yxy);\n    float d3 = d-scene(p+o.yyx);\n\n    return normalize(vec3(d1,d2,d3));\n}\n\nfloat AO(vec3 p, vec3 normal) {\n\n    float a = 1.0;\n\n\tfloat c = 0.0;\n    float s = 0.25;\n\n    for(int i=0; i<3; i++) {\n\t    c += s;\n        a *= 1.0-max(0.0, (c -scene(p + normal*c)) * s / c);\n    }\n\n    return clamp(a,0.0,1.0);\n}\n\nfloat map( in vec3 p )\n{\n\tfloat e = 1.0;//2.0*texture( iChannel0, vec2(0.01,0.25) ).x;\n    return min( e +  length(p) - 1.0, p.y+1.0 );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n\n\tvec3 e = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(map(p+e.xyy) - map(p-e.xyy),\n\t\t\t\t\t\t   map(p+e.yxy) - map(p-e.yxy),\n\t\t\t\t\t\t   map(p+e.yyx) - map(p-e.yyx) ) );\n\t\t\t\t\t\t   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tInitIFS();\n\t\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n    vec3 dir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), 1.0));\n\n    vec3 p = vec3(0.0,0.0,-4.1);\n\t\t\n\tfloat d = 0.0;\n\n\tfor(int i=0; i<MAX_RAY_STEPS; i++) {\n        d = scene(p);\t\t\n\t\t\n\t\tp += d * dir;\n\t\tif(d<0.001) break;\n    }\n\t\n\tvec3 c = vec3(0.0);\n\t\n\tif(d<0.001) {\n\t\tvec3 l = vec3(-3.0, 3.0, 3.0);\n\n\t\tvec3 n = -normal(p-dir*0.001);\n\t\t\n\t\tc = vec3(0.4);\n\n\t\tc += 1.5 * (max(0.0, dot(n, normalize(l-p)))/length(l-p));\n\n\t\tc *= AO(p, 0.5*(n+normalize(n+l)));\n\t\t\n\t\tc *= calcNormal(dir);\n\t}\n\t\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d23Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 286, 357, 357, 468], [470, 470, 506, 506, 1080], [1159, 1159, 1175, 1175, 1947], [1949, 2119, 2140, 2140, 2530], [2532, 2532, 2553, 2553, 2748], [2750, 2750, 2781, 2781, 2980], [2982, 2982, 3006, 3006, 3119], [3121, 3121, 3151, 3151, 3328], [3330, 3330, 3387, 3387, 3998]], "test": "ok"}
{"id": "4d2GDV", "name": "Twisty Torus", "author": "bloxard", "description": "This shader uses both of raymarching and raytracing. Intersections with the torus are carried out using raymaching while intersections with the ground-plane uses raytracing for best accuracy.", "tags": ["3d", "raymarch", "torus", "proceduraltexture"], "likes": 5, "viewed": 431, "published": "Public", "date": "1393697627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Per Bloksgaard/2014\n// Thanks to iq for letting me use his ray-marching, softshadow and ao code.\n\n#define PI 3.14159265358979\n\nfloat distPlane(in vec3 p)\n{\n\treturn p.y;\n}\n\nvec2 distTorus(in vec3 p, in vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\tfloat a = (atan(q.x,q.y)+PI)/PI*4.0;\n\tfloat b = (atan(p.z,p.x)+PI)/PI*8.0;\n\tfloat s = clamp(abs(sin(iTime*0.05))*1.8-0.7,0.0,1.0);\n\tfloat c = a * s;\n\tfloat d = b * s;\t\n\tfloat m;\n\tif (fract(d)>0.5)\n\t{\n\t\tm = -s;\n\t\tif (fract(c)>0.5)\n\t\t{\n\t\t\tm = b*(1.0-s);\n\t\t}\n\t}\n\telse\n\t{\n\t\tm = a*(1.0-s);\n\t\tif (fract(c)>0.5)\n\t\t{\n\t\t\tm = -s;\n\t\t}\n\t}\n\treturn vec2((length(q)-t.y)*0.5,m);\n}\n\nvec2 maxOfTwo(in vec2 a, in vec2 b)\n{\n\treturn (a.x<b.x)?a:b;\n}\n\nvec3 doTwist(in vec3 p)\n{\n\tfloat f = sin(iTime)*12.0;\n\tfloat c = cos(f*p.y);\n\tfloat s = sin(f*p.y);\n\tmat2  m = mat2(c,-s,s,c);\n\treturn vec3(p.y,m*p.xz);\n}\n\nvec2 map(in vec3 pos)\n{\n\treturn maxOfTwo( vec2(distPlane(pos),-2.0), distTorus(doTwist(pos-vec3(0.0,0.25,0.0)),vec2(0.20,0.05)) );\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxd)\n{\n\tfloat precis = 0.0008;\n\tfloat h = precis*2.0;\n\tfloat t = 0.0;\n\tfloat m = -1.0;\n\tfor(int i=0; i<50; i++)\n\t{\n\t\tif(abs(h)<precis||t>maxd)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tt += h;\n\t\tvec2 res = map( ro+rd*t );\n\t\th = res.x;\n\t\tm = res.y;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k)\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor(int i=0; i<30; i++)\n\t{\n\t\tif(t<maxt)\n\t\t{\n\t\t\tfloat h = map(ro + rd*t).x;\n\t\t\tres = min(res, k*h/t);\n\t\t\tt += 0.02;\n\t\t}\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\tmap(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\tmap(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\tmap(pos+eps.yyx).x - map(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat totao = 0.0;\n\tfloat sca = 1.0;\n\tfor(int aoi=0; aoi<5; aoi++)\n\t{\n\t\tfloat hr = 0.01+0.05*float(aoi);\n\t\tvec3 aopos = nor*hr+pos;\n\t\tfloat dd = map(aopos).x;\n\t\ttotao += -(dd-hr)*sca;\n\t\tsca *= 0.75;\n\t}\n\treturn clamp(1.0-4.0*totao,0.0,1.0);\n}\n\nvec3 render(in vec3 o, in vec3 d, in vec3 lig)\n{ \n\tvec3 col = vec3(0.0);\n\tvec2 res = castRay(o,d,7.0);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tvec3 pos = o + d*t;\n\tvec3 nor;\n\tif(m<-1.0)\n\t{\n\t\tnor = vec3(0.0,1.0,0.0);\n\t\tt = 7.0;\t\n\t\tif (d.y<0.0)\n\t\t{\n\t\t\tt = -o.y/d.y;\n\t\t\tpos = o + d*t;\n\t\t\tm = (fract(pos.x)>0.5)?0.0:1.0;\n\t\t\tm = (fract(pos.z)>0.5)?1.0-m:m;\n\t\t\tm -= 1.0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tnor = calcNormal(pos);\n\t}\n\tfloat factor = clamp(1.0+m,0.0,1.0);\n\tfloat ao = calcAO(pos,nor);\n\tcol = vec3(0.5)+0.5*sin(vec3(PI,PI*0.25,PI*0.5)*m);\n\tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n\tfloat bac = clamp(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0,1.0)*clamp(1.0-pos.y,0.0,1.0);\n\tfloat sh = softshadow(pos,lig,0.02,7.0,4.0); \n\tdif *= sh; \n\tvec3 brdf = dif*vec3(1.0);\n\tfloat pp = clamp(dot(reflect(d,nor),lig ),0.0,1.0);\n\tfloat fre = ao*pow(clamp(1.0+dot(nor,d),0.0,1.0),2.0);\n\tcol = col*brdf+fre*(0.5+0.5*col);\n\tcol *= factor;\n\tcol += vec3(1.5)*sh*pow(pp,8.0);\n\tt = clamp(t-3.2,0.0,10.0);\n\treturn mix(vec3(0.8,0.9,1.0),col,exp(-0.4*t*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n\tfloat u = iTime*0.5;\n\tfloat v = -PI*0.4-cos(iTime*0.7)*PI*0.10;\n\tfloat f = 0.5+abs(cos(iTime*0.1)*0.5);\n\tfloat time = -iTime*0.5;\n\tvec3 target = vec3(0.0,0.25,0.0);\n\tvec3 origin = vec3(cos(u)*sin(v)*f,cos(v)*f,sin(u)*sin(v)*f);\n\torigin += target;\n\tvec3 camForward = normalize(target-origin);\n\tvec3 wldUp = vec3(0.0,1.0,0.0);\n\tvec3 camRight = normalize(cross(camForward,wldUp));\n\tvec3 camUp = normalize(cross(camRight,camForward));\n\tvec3 d = normalize(s.x*camRight+s.y*camUp+camForward*2.1);\n\tvec3 c = render(origin,d,normalize(origin));\n\tfragColor = vec4(c,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d2GDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 141, 169, 169, 184], [186, 186, 224, 224, 629], [631, 631, 668, 668, 693], [695, 695, 720, 720, 849], [851, 851, 874, 874, 983], [985, 985, 1038, 1038, 1285], [1287, 1287, 1371, 1371, 1559], [1561, 1561, 1591, 1591, 1799], [1801, 1801, 1841, 1841, 2084], [2086, 2086, 2134, 2134, 3113], [3115, 3115, 3172, 3172, 3803]], "test": "ok"}
{"id": "4d2GW3", "name": "Infinite Gears", "author": "reuben364", "description": "I made it to use as a live wallpaper on my phone and it has gone through a few iterations for it to be feasible. ", "tags": ["2d", "fractal", "gears", "grayscale", "infinite"], "likes": 25, "viewed": 833, "published": "Public", "date": "1394318473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\n#define ENVIRONMENT 0\n#if(ENVIRONMENT == 0)\n\t#define RESOLUTION iResolution.xy\n\t#define TIME iTime\n\t#define OFFSET iMouse.xy/iResolution.xy\n\t#define POSITION fragCoord.xy\n\n\t#define DEPTH 4\n#elif(ENVIRONMENT == 1)\n\t#define RESOLUTION resolution.xy\n\t#define TIME time\n\t#define OFFSET offset\n\t#define POSITION fragCoord.yx\n\tuniform vec3 resolution;\n\tuniform float time;\n\tuniform vec2 offset;\n\n\t#define DEPTH 3\n#endif\n\n#define CHILDREN 3\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x+sin(a)*v.y, -sin(a)*v.x+cos(a)*v.y);\n}\n\nvec2 repeat_arc(vec2 pos, int n) {\n\tfloat a = atan(pos.y, pos.x);\n\tfloat s = 2.*PI/float(n);\n\treturn rotate(vec2(length(pos),0), mod(a,s)-s/2.);\n}\n\nfloat cog_teeth (float a) {\n\treturn 4.*clamp(2.*abs(mod(a/2./PI, 1.)-.5), .25, .75)-2.;\n}\n\nbool cog (vec2 pos, float r, float depth, int teeth) {\n\treturn length(pos) < r - depth*cog_teeth(float(teeth)*atan(pos.y, pos.x));\n}\n\nbool cogs(vec2 pos, float theta, float r1, float r2, float r3, float cog_depth, int cog_teeth) {\n\tfloat rm = (r2+r3)/2.;\n\tfloat ri = (r2-r3)/2.;\n\t\n\tbool result = false;\n\tfor(int i=0; i<DEPTH; i++) {\n\t\tfloat s_theta = (r2/rm)*(1.-r3/r2)*theta; // (r2/rm) is magic factor\n\t\tresult = result || cog(pos, r1, cog_depth, cog_teeth);\n\t\tresult = result &&!cog(pos, r2, cog_depth*ri/r1, int(float(cog_teeth)*r2/ri));\n\t\tresult = result || cog(rotate(pos, theta), r3, cog_depth*ri/r1, int(float(cog_teeth)*r3/ri));\n\t\tpos = rotate(repeat_arc(rotate(pos, s_theta*(r3/r2)), CHILDREN)-vec2(rm,0.), s_theta*(r3/ri))*r1/ri;\n\t}\n\treturn result;\n}\n\nbool cogs(vec2 pos, float theta) {\n\treturn cogs(pos, theta, 1., .8, .4, .1, 9);\n}\n\nbool cog_array(vec2 pos, float theta, float r, float depth, int teeth) {\n\tpos = mod(pos,4.*r);\n\tif(pos.x < 2.*r != pos.y < 2.*r) {\n\t\ttheta += PI/float(teeth);\n\t}\n\tpos = abs(pos-vec2(2.*r));\n\tpos = rotate(pos-vec2(r), theta);\n\treturn cog(pos, r, depth, teeth);\n}\n\nvec2 get_pos(vec2 fragCoord) {\n\treturn (POSITION-RESOLUTION/2.)/RESOLUTION.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfragColor = cogs(rotate(get_pos(fragCoord)+vec2(.4,0),-TIME/5.), TIME/3.) ? vec4(1) :\n\t\t\t\t\t\tcogs(rotate(get_pos(fragCoord)+vec2(-.5,+.4)-OFFSET/3., -TIME)*3., TIME) ? vec4(.5) : \n\t\t\t\t\t\tcog_array(get_pos(fragCoord)-OFFSET, TIME/3., .1, .01, 9) ? vec4(.1) : vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d2GW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 484, 484, 547], [549, 549, 583, 583, 695], [697, 697, 724, 724, 786], [788, 788, 842, 842, 920], [922, 922, 1018, 1018, 1549], [1551, 1551, 1585, 1585, 1632], [1634, 1634, 1706, 1706, 1895], [1897, 1897, 1927, 1927, 1976], [1978, 1978, 2036, 2036, 2304]], "test": "ok"}
{"id": "4d2GWc", "name": "TrivialRaytracer2", "author": "Tivi", "description": "Raytraced sphere, 2 light sources, diffuse lighting, tries to shade non-sphere pixels as if they were on the sphere for a halo effect.", "tags": ["raytracing"], "likes": 1, "viewed": 289, "published": "Public", "date": "1394478858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct traceResult {\n\tfloat d;\n\tvec3 intersection;\n\tvec3 normal;\n\tvec3 color;\n};\n\t\ntraceResult trace( vec3 orig, vec3 delta ) {\n\tvec3 spherea = vec3(0, 1, 00);\n\tfloat spherea_r = 20.0;\n\tvec3 sphereb = vec3(400, 250, 1500);\n\tfloat sphereb_r = 300.0;\n\tvec3 spherec = vec3(200, -300, 1400);\n\tfloat spherec_r = 300.0;\n\t\n\tfloat plane_y = -300.0;\n\t\n\tfloat bar, foo, d=100000.0, d2;\n\tvec3 intersection, norm, color;\n\t\n\tbar = dot(delta,orig-spherea);\n\tfoo = ( bar*bar - dot(orig-spherea,orig-spherea) + spherea_r*spherea_r );\n\td2 = - bar - sqrt(foo);\n\tif( foo>0.0 && d2 > 0.01 && d2<d ) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = normalize(spherea-intersection);\n\t\td=d2;\n\t\tcolor=vec3(0.8,0.2,0.3);\n\t}\n\t\n\treturn traceResult( d, intersection, norm, color );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat st = sin(iTime);\n\tfloat ct = cos(iTime);\n\tvec3 delta = normalize( vec3(fragCoord.xy-0.5*iResolution.xy, iResolution.x*0.5) );\n\t//delta = vec3(delta.x*ct-delta.z*st,delta.y,delta.z*ct+delta.x*st);\n    vec3 orig = vec3( 20.0*st, 0.0, -60.0-10.0*ct );\n\tvec3 lighta = vec3(100, 100, 100);\n\tvec3 lightb = vec3(-100, 200, -100);\n\t\n\ttraceResult r = trace(orig, delta);\n\t\n\t\n\t//if( ! (r.d > 0.001) ) {\n\t//\tfragColor = vec4(0,0,0,0);\n\t//}\n\t//else {\n\t\tvec3 el = normalize(r.intersection-lighta);\n        lighta = normalize(lighta);\n\t\tfloat e = dot( r.normal, lighta);//el );\n\t\tfloat es = pow( dot( delta ,normalize(2.0*dot(el,r.normal)*r.normal-el) ), 100.0);\n\t\tif( e < 0.0){ e=0.0; es=0.0;} ;\n\t\t\n\t\tvec3 fl = normalize(r.intersection-lightb);\n\t\tfloat f = dot( r.normal, normalize(r.intersection-lightb) );\n\t\tfloat fs = pow( dot( delta ,normalize(2.0*dot(fl,r.normal)*r.normal-fl) ), 100.0);\n\t\tif(f < 0.0) {f=0.0; fs=0.0;};\n\t\tfragColor = vec4( sqrt(e*e+f*f*0.f)*r.color /*+ (es+fs)*vec3(1.0,1.0,1.0)*/, 1.0 );\n\t//}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d2GWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 127, 127, 751], [753, 753, 810, 810, 1822]], "test": "ok"}
{"id": "4dB3Dd", "name": "Movings Bars", "author": "kcimc", "description": "Some animating moving lines.", "tags": ["grayscale", "blackandwhite", "minimal"], "likes": 1, "viewed": 202, "published": "Public", "date": "1394986912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sigmoid(float val, float sharpness) {\n\tval = 1./(1. + exp(-1.*(sharpness)*(val - 0.5)));\n\tval = clamp(val, 0., 1.);\n\treturn val;\n}\n\nfloat sigsin(float val, float sharpness) {\n\tval = .5+.5*sin(val);\n\treturn sigmoid(val, sharpness)*2.-1.;\n}\n\nconst float qpi =.78539816;\nconst float switchTime = .5;\nconst float switchSharpness = 100.;\nconst float frequency = 12.;\nconst float speed = .001;\nconst float displacement = 10.;\nconst float displacementSharpness = 50.;\nconst float bwSharpness = 200.;\nconst float pulseLength = 4.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// these can all go in a vertex shader\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tvec2 center = vec2(-(iResolution.x / (2. * iResolution.y)), -.5);\n\tfloat angle = qpi+qpi*sigsin(iTime * switchTime, switchSharpness);\n\tfloat sawTime = 1.-(mod(iTime, pulseLength)/pulseLength);\n\tfloat direction = sigsin(iTime, displacementSharpness);\n\tdirection *= displacement;\n\t\n\t// have to stay in the fragment shder \n\tfloat brightness = .5+.5*sin(((sin(angle)*(uv.x+center.x)+cos(angle)*(uv.y+center.y)) + iTime * speed * direction) * frequency);\n\tbrightness = sigmoid(brightness, bwSharpness);\n\tbrightness *= sawTime;\n\tfragColor = vec4(vec3(brightness),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dB3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 136], [138, 138, 180, 180, 244], [530, 530, 587, 627, 1234]], "test": "ok"}
{"id": "4dfSzn", "name": "Simple Digital Clock", "author": "MikeCAT", "description": "This is an simple digital clock.\nThe background is what Shadertoy gives us as the default \"New Shader\".\nDespite of the simpleness of the display, it does too much calculation:\nit works in about 4.2 fps in my computer(Google Chrome 30, Core2Duo 2.10GHz)", "tags": ["2d", "time", "clock", "practice"], "likes": 4, "viewed": 370, "published": "Public", "date": "1395542508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Check if coord is in display of the number.\n * @param coord The position to check (x,y)\n * @param n The number to display\n * @param numpos The position to draw the number (left-x,bottom-y,width,height)\n * @param a The thickness of the number\n * @return the check result (in -> true)\n */\nbool isInNumber(vec2 coord,float n,vec4 numpos,float a)\n{\n\t/*\n\t *  0\n\t * 5 1\n\t *  6\n\t * 4 2\n\t *  3\n\t *\n\t * n 0123456\n\t * 0 TTTTTTF\n\t * 1 FTTFFFF\n\t * 2 TTFTTFT\n\t * 3 TTTTFFT\n\t * 4 FTTFFTT\n\t * 5 TFTTFTT\n\t * 6 TFTTTTT\n\t * 7 TTTFFTF\n\t * 8 TTTTTTT\n\t * 9 TTTTFTT\n\t */\n\tn=floor(n);\n\t// 0\n\tif(n!=1.0 && n!=4.0 &&\n\tnumpos.x+a<=coord.x && coord.x<=numpos.x+numpos.z-a &&\n\tnumpos.y+numpos.w-a<=coord.y && coord.y<=numpos.y+numpos.w)return true;\n\t// 1\n\tif(n!=5.0 && n!=6.0 &&\n\tnumpos.x+numpos.z-a<=coord.x && coord.x<=numpos.x+numpos.z &&\n\tnumpos.y+numpos.w/2.0+a/2.0<=coord.y && coord.y<=numpos.y+numpos.w-a)return true;\n\t// 2\n\tif(n!=2.0 &&\n\tnumpos.x+numpos.z-a<=coord.x && coord.x<=numpos.x+numpos.z &&\n\tnumpos.y+a<=coord.y && coord.y<=numpos.y+numpos.w/2.0-a/2.0)return true;\n\t// 3\n\tif(n!=1.0 && n!=4.0 && n!=7.0 &&\n\tnumpos.x+a<=coord.x && coord.x<=numpos.x+numpos.z-a &&\n\tnumpos.y<=coord.y && coord.y<=numpos.y+a)return true;\n\t// 4\n\tif(n!=1.0 && n!=3.0 && n!=4.0 && n!=5.0 && n!=7.0 && n!=9.0 &&\n\tnumpos.x<=coord.x && coord.x<=numpos.x+a &&\n\tnumpos.y+a<=coord.y && coord.y<=numpos.y+numpos.w/2.0-a/2.0)return true;\n\t// 5\n\tif(n!=1.0 && n!=2.0 && n!=3.0 &&\n\tnumpos.x<=coord.x && coord.x<=numpos.x+a &&\n\tnumpos.y+numpos.w/2.0+a/2.0<=coord.y && coord.y<=numpos.y+numpos.w-a)return true;\n\t// 6\n\tif(n!=0.0 && n!=1.0 && n!=7.0 &&\n\tnumpos.x+a<=coord.x && coord.x<=numpos.x+numpos.z-a &&\n\tnumpos.y+numpos.w/2.0-a/2.0<=coord.y && coord.y<=numpos.y+numpos.w/2.0+a/2.0)return true;\n\treturn false;\n}\n\n/**\n * Check if coord is in the rect.\n * @param coord The position to check (x,y)\n * @param pos The position of the rect (left-x,bottom-y,width,height)\n * @return the check result (in -> true)\n */\nbool isInRect(vec2 coord,vec4 pos)\n{\n\treturn pos.x<=coord.x && coord.x<=pos.x+pos.z && pos.y<=coord.y && coord.y<=pos.y+pos.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tbool isDraw = false;\n\tfloat theTime = iDate.w;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t// draw the date\n\tisDraw = isDraw || isInNumber(uv,iDate.x/1000.0,vec4(0.05,0.575,0.07,0.3),0.015);\n\tisDraw = isDraw || isInNumber(uv,mod(iDate.x/100.0,10.0),vec4(0.15,0.575,0.07,0.3),0.015);\n\tisDraw = isDraw || isInNumber(uv,mod(iDate.x/10.0,10.0),vec4(0.25,0.575,0.07,0.3),0.015);\n\tisDraw = isDraw || isInNumber(uv,mod(iDate.x,10.0),vec4(0.35,0.575,0.07,0.3),0.015);\n\tisDraw = isDraw || isInRect(uv,vec4(0.455,0.575,0.03,0.06));\n\tisDraw = isDraw || isInNumber(uv,iDate.y/10.0,vec4(0.515,0.575,0.07,0.3),0.015);\n\tisDraw = isDraw || isInNumber(uv,mod(iDate.y,10.0),vec4(0.615,0.575,0.07,0.3),0.015);\n\tisDraw = isDraw || isInRect(uv,vec4(0.715,0.575,0.03,0.06));\n\tisDraw = isDraw || isInNumber(uv,iDate.z/10.0,vec4(0.78,0.575,0.07,0.3),0.015);\n\tisDraw = isDraw || isInNumber(uv,mod(iDate.z,10.0),vec4(0.88,0.575,0.07,0.3),0.015);\n\t// draw the time\n\tisDraw = isDraw || isInNumber(uv,theTime/36000.0,vec4(0.25,0.125,0.07,0.3),0.015);\n\tisDraw = isDraw || isInNumber(uv,mod(theTime/3600.0,10.0),vec4(0.35,0.125,0.07,0.3),0.015);\n\tisDraw = isDraw || isInRect(uv,vec4(0.455,0.185,0.03,0.06));\n\tisDraw = isDraw || isInRect(uv,vec4(0.455,0.305,0.03,0.06));\n\ttheTime = mod(theTime,3600.0);\n\tisDraw = isDraw || isInNumber(uv,theTime/600.0,vec4(0.515,0.125,0.07,0.3),0.015);\n\tisDraw = isDraw || isInNumber(uv,mod(theTime/60.0,10.0),vec4(0.615,0.125,0.07,0.3),0.015);\n\tisDraw = isDraw || isInRect(uv,vec4(0.715,0.185,0.03,0.06));\n\tisDraw = isDraw || isInRect(uv,vec4(0.715,0.305,0.03,0.06));\n\ttheTime = mod(theTime,60.0);\n\tisDraw = isDraw || isInNumber(uv,theTime/10.0,vec4(0.78,0.125,0.07,0.3),0.015);\n\tisDraw = isDraw || isInNumber(uv,mod(theTime,10.0),vec4(0.88,0.125,0.07,0.3),0.015);\n\tif(isDraw) {\n\t\tfragColor = vec4(0.0,0.0,0.0,1.0);\n\t} else {\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 294, 351, 555, 1772], [1774, 1971, 2007, 2007, 2099], [2101, 2101, 2158, 2158, 4038]], "test": "ok"}
{"id": "4dj3Dt", "name": "[SH2014]DNA", "author": "otaviogood", "description": "hydrogen bonds joining and separating in a DNA strand", "tags": ["dna"], "likes": 2, "viewed": 420, "published": "Public", "date": "1395286537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.14159265;\nvec3 sunCol = vec3(258.0, 28.0, 10.0) / 255.0;\nvec3 environmentSphereColor = vec3(0.3001, 0.501, 0.901);\nvec3 environmentGroundColor = vec3(0.4001, 0.25, 0.1) * 0.75;\n\nfloat marchingMultplier = 0.25;\n\nfloat distFromSphere;\nvec3 normal;\nvec3 texBlurry;\n\nfloat material;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nvec3 RotateX(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n\t//else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n\t//else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// exponential smooth min (k = 32);\n/*float smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}*/\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = max(0.0, 0.01 / sunIntensity - 0.025);\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tvec3 ground = mix(environmentGroundColor, environmentSphereColor,\n\t\t\t\t\t  pow(abs(localRay.y), 0.35)*sign(localRay.y) * 0.5 + 0.5);\n\treturn ground + sunCol * sunIntensity;\n}\nvec3 GetSunColorStupid(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = max(0.0, 0.01 / sunIntensity - 0.025);\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tvec3 ground = mix(environmentGroundColor, environmentSphereColor,\n\t\t\t\t\t  pow(localRay.y, 0.35)*sign(localRay.y) * 0.5 + 0.5);\n\treturn sunCol * sunIntensity;\n}\n\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\nfloat dSphere(vec3 p, float rad)\n{\n\t//vec3 center = vec3(0, 0, 0.0);\n\t//p -= center;\n\t//rad += sin(p.y * 32.0 - iTime * 8.0) * 0.01;\n\treturn length(p) - rad;\n}\nfloat dSphereWave(vec3 p, float rad)\n{\n\t//vec3 center = vec3(0, 0, 0.0);\n\t//p -= center;\n\trad -= 0.05;\n\trad += sin(p.y * 8.0 - iTime * 2.0) * 0.03;\n\treturn length(p) - rad;\n}\n\nfloat dBox(vec3 pos, vec3 b)\n{\n\treturn length(max(abs(pos)-(b),0.0));\n}\n\nfloat dBoxSigned(vec3 p)\n{\n\tfloat b = 1.0;\n\tvec3 b2 = vec3(6.0, 2.0, 2.0);\n\tvec3 center = vec3(0, -2.0, 0.0);\n\tvec3 d = abs(p - center) - b2;//*abs(cos(p.y + 0.5));\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dFloor(vec3 p)\n{\n\treturn p.y + 1.0;\n}\n\nfloat sdColumn( vec3 p, vec3 c )\n{\n\tfloat cyl = length(p.xz-c.xy)-c.z;// + abs(p.y);\n\tcyl -= cos(p.y*2.0)*0.045;\n\tfloat a = atan(p.x - c.x, p.z - c.y);\n\ta /= 2.0*PI;\n\tfloat subs = 48.0;\n\ta *= subs;\n\t//cyl *= pow(sin(a), 0.5) * 0.925 + 1.0;\n\tcyl += abs(sin(a)) * 0.015;\n\n\tcyl = max(cyl, p.y - 2.4);\n\tcyl = min(cyl, dBox(p + vec3(0.0, 1.0, 0.0), vec3(0.3, 0.2, 0.3)));\n\tcyl = min(cyl, dBox(p + vec3(0.0, -2.3, 0.0), vec3(0.3, 0.15, 0.3)));\n\treturn cyl;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tp.y += 1.0;\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\nfloat length8(vec2 v)\n{\n\treturn pow((pow(v.x,8.0) + pow(v.y, 8.0)), (1.0/8.0));\n}\nfloat length8(vec3 v)\n{\n\treturn pow((pow(v.x,8.0) + pow(v.y, 8.0) + pow(v.z, 8.0)), (1.0/8.0));\n}\nfloat sdTorus82( vec3 p, vec2 t, vec3 center, float subs )\n{\n\tp -= center;\n\tfloat a = atan(p.x, p.z);\n\ta = pow(abs(sin(a*subs)), 0.25);\n\t//a = mod(a,PI*2.0) - 0.5;\n\t//a = a *0.025 + 0.975;\n\ta = a *0.2 + 0.8;\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length8(q)-t.y*a;\n}\nfloat sdTorusArch( vec3 p, vec2 t, vec3 center, float subs )\n{\n\tp -= center;\n\tfloat a = atan(p.y, p.z);\n\ta = pow(abs(sin(a*subs)), 0.25);\n\t//a = mod(a,PI*2.0) - 0.5;\n\t//a = a *0.025 + 0.975;\n\ta = a *0.25 + 0.75;\n\tvec2 q = vec2(length(p.yz)-t.x,p.x);\n\treturn length8(q)-t.y*a;\n}\nfloat sdTorusDome( vec3 p, vec2 t, vec3 center, float subs )\n{\n\tp -= center;\n\tfloat a = atan(p.x, p.z);\n\ta = pow(abs(sin(a*subs)), 0.15);\n\t//a = mod(a,PI*2.0) - 0.5;\n\t//a = a *0.025 + 0.975;\n\ta = a *0.25 + 0.75;\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length8(q)-t.y*a;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n\tp.y += 0.5;\n    vec3 q = abs(p);\n    return max(q.y-h.y,max(q.x+q.z*0.57735,q.z*1.1547)-(h.x*(2.35 - p.y)));\n}\nfloat sdHexPrismGem( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.y-h.y,max(q.x+q.z*0.57735,q.z*1.1547)-(h.x*(0.5 - abs(p.y))*3.0));\n}\n\nfloat dGem(vec3 p)\n{\n\tfloat final = sdHexPrism(p, vec2(0.25, 1.0));\n\treturn final;\n}\n\nfloat matMin(float a, float b, float matNum)\n{\n\tfloat final = smin(a, b, 0.2);\n\tif (a < b)\n\t{\n\t\t//material = 0.0;\n\t\treturn final;\n\t}\n\telse\n\t{\n\t\tmaterial = matNum;\n\t\treturn final;\n\t}\n}\n\nfloat dTiles(vec3 p)\n{\n\tfloat subs = 16.0;\n\tfloat final = length(p) - 2.2;\n\tfloat a = atan(p.x, p.z);\n\ta /= 2.0*PI;\n\ta *= subs;\n\ta = abs((fract(a) - 0.5))*2.0;\t// triangle wave from 0.0 to 1.0\n\ta -= 0.15;\n\ta *= 6.0;\n\ta = max(0.0, a);\n\ta = min(0.75, a);\n\n\tfloat b = atan(length(p.xz), p.y);\n\tb /= 2.0*PI;\n\tb *= subs;\n\tb = abs((fract(b) - 0.5))*2.0;\t// triangle wave from 0.0 to 1.0\n\tb -= 0.15;\n\tb *= 6.0;\n\tb = max(0.0, b);\n\tb = min(0.75, b);\n\t\n\ta = a*b;\n\n\ta = a *0.2 + 0.8;\n\tb = b *0.2 + 0.8;\n\t\n\tfinal = final - a;\n\tfinal = max(final, 0.5-p.y);\n\treturn final/1.414;\n}\n\nfloat GemCut(vec3 p)\n{\n\tfloat size = 0.5;\n\tfloat f = length(p) - size;\n\tif (f <= 1.0)\n\t{\n\t\tmarchingMultplier = 0.65;\n\t\tf = max(f, p.y - size * 0.25);\n\t\t\n\t\tf = max(f, p.y + p.x - size * 0.7);\n\t\tf = max(f, p.y - p.x - size * 0.7);\n\t\tf = max(f, p.y + p.z - size * 0.7);\n\t\tf = max(f, p.y - p.z - size * 0.7);\n\t\t\n\t\tf = max(f, -p.y + p.x - size * 0.6);\n\t\tf = max(f, -p.y - p.x - size * 0.6);\n\t\tf = max(f, -p.y + p.z - size * 0.6);\n\t\tf = max(f, -p.y - p.z - size * 0.6);\n\n\t\tf = max(f, p.y + p.x + p.z - size * 0.95);\n\t\tf = max(f, p.y - p.x + p.z - size * 0.95);\n\t\tf = max(f, p.y - p.x - p.z - size * 0.95);\n\t\tf = max(f, p.y + p.x - p.z - size * 0.95);\n\n\t\tf = max(f, -p.y + p.x + p.z - size * 0.85);\n\t\tf = max(f, -p.y - p.x + p.z - size * 0.85);\n\t\tf = max(f, -p.y - p.x - p.z - size * 0.85);\n\t\tf = max(f, -p.y + p.x - p.z - size * 0.85);\n\t} else marchingMultplier = 1.0;\n\treturn f;\n}\n\nfloat atrium(vec3 p)\n{\n\tvec3 c = vec3(1.0, 1.0, 1.0)* 4.0;\n\tfloat c2 = 5.2;\n\tvec3 q = mod(p,c)-0.5*c;\n\tfloat q2 = mod(p.x,c2)-0.5*c2;\n\tvec3 p2 = vec3(q.x, p.y, q.z);\n\tvec3 p3 = vec3(q2, p.y, p.z);\n\n\tfloat final = -sdCapsule(p, vec3(0.0,-0.5,0.0), vec3(0.0,2.25,0.0), 3.0);\n\t// This if condition is for a culling speedup and a cool bevel effect on the ceiling tiles.\n\tif (final < 0.01) final = max(final, -dTiles(p + vec3(0.0, -2.25, 0.0)));\n\tfinal = min(final, sdTorus82(p, vec2(2.75, 0.25), vec3(0.0, -0.795, 0.0), 12.0));\n\tfinal = max(final, -sdCapsule(p, vec3(-6.0,0.0,0.0), vec3(6.0,0.0,0.0), 2.0));\n\t//final = max(final, -sdCapsule(p, vec3(0.0,0.0,-16.0), vec3(0.0,0.0,16.0), 2.0));\n\tfinal = max(final, -dBoxSigned(p));\n\tfinal = max(final, -sdCapsule(p, vec3(0.0,0.0,0.0), vec3(0.0,5.5,0.0), 0.5));\n\tfinal = max(final, p.y - 5.3);\n\t//final = max(final, sdCapsule(p, vec3(0.0,-0.5,0.0), vec3(0.0,0.5,0.0), 3.05));\n\t//final = max(final, -dSphere(p2, 0.08));\n\tfinal = min(final, sdColumn(p2, vec3(0.0, 0.0, 0.25)));\n\n\tfinal = min(final, sdTorus82(p, vec2(3.0, 0.25), vec3(0.0, 2.7, 0.0), 8.0));\n\tfinal = min(final, sdTorus82(p, vec2(0.75, 0.25), vec3(0.0, -1.0, 0.0), 6.0));\n\tfinal = min(final, sdTorusArch(p3, vec2(2.125, 0.3), vec3(0.0, -0.1, 0.0), 6.0));\n\t//final = min(final, sdTorusArch(p, vec2(2.125, 0.3), vec3(2.6, -0.1, 0.0), 6.0));\n\t//final = min(final, sdTorusArch(p, vec2(2.125, 0.3), vec3(-2.6, -0.1, 0.0), 6.0));\n\tfinal = min(final, dFloor(p));\n\tmaterial = 0.0;\n\tfinal = matMin(final, sdHexPrism(p, vec2(0.25, 1.0)), 2.0);\n\n\t//final = min(final, dGem(p));\n\t//final = matMin(final, sdHexPrismGem(p - vec3(0, 1.0, 0), vec2(0.25, 0.5)), 1.0);\n\tfinal = matMin(final, GemCut(p - vec3(0, 0.8, 0)), 1.0);\n\n\t//vec4 texX = texture(iChannel1, p.yz*0.2);\n\t//vec4 texY = texture(iChannel1, p.xz*0.2);\n\t//vec4 texZ = texture(iChannel1, p.xy*0.2);\n\t//vec4 noise = texX + texY + texZ;\n\t//final += noise.x * 0.05;\n\n\treturn final;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tfloat tubeWidth = 0.15;\n\t//p = RotateY(p, p.y);\n\tp = RotateY(p, p.y);\n\tvec3 rp = p;\n\tvec3 lp = p;\n\trp.x += (sin(rp.y+iTime)*0.5+0.5);\n\tlp.x += -(sin(rp.y+iTime)*0.5+0.5);\n\tfloat final = sdCapsule(lp, vec3(1.0,-5.5,0.0), vec3(1.0,5.5,0.0), tubeWidth);\n\tfinal = min(final, sdCapsule(rp, vec3(-1.0,-5.5,0.0), vec3(-1.0,5.5,0.0), tubeWidth));\n\tfloat cl = 0.5;\n\tfloat ql = mod(rp.y,cl)-0.5*cl;\n\tvec3 pl = vec3(rp.x, ql, rp.z);\n\tvec3 pr = vec3(lp.x, ql, lp.z);\n\tfinal = matMin(final, sdCapsule(pl, vec3(-1.0,0.0,0.0), vec3(0.0,0.0,0.0), tubeWidth), 1.0);\n\tfinal = matMin(final, sdCapsule(pr, vec3(-0.0,0.0,0.0), vec3(1.0,0.0,0.0), tubeWidth), 2.0);\n\n\treturn final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,1.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.5;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.93)*0.32+0.02;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.75); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\tfloat sunSpeed = -0.77;\n\tvec3 sunDir = normalize(vec3(sin(iTime*sunSpeed)*2.0, -3.0, sin(iTime*sunSpeed)*2.0));\n\n\tfloat dist = 0.02;\n\tfloat t = 0.1;\n\tfloat maxDepth = 40.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n\tfor (int i = 0; i < 150; i++)\n\t{\n\t\tif ((t > maxDepth) || (abs(dist) < 0.001)) continue;\t// break DOESN'T WORK!!! ARRRGGG!\n\t\tmaterial = 0.0;\n\t\tpos = camPos + relVec * t;\n\t\tdist = DistanceToObject(pos);\n\t\tt += dist * 0.5;\t// because deformations mess up distance function.\n\t}\n\tfloat finalMaterial = material;\n\n\t//vec3 finalColor = vec3(0.0,0.0,0.0);// GetSunColorReflection(relVec, -sunDir) + vec3(0.1, 0.1, 0.1);\n\tvec3 finalColor = GetSunColorStupid(relVec, -sunDir) + vec3(0.1, 0.1, 0.1);\n\n\t//finalColor += texture(iChannel0, vec2(pos.x+iTime, pos.y*0.01+0.0)).xyz;\n\tvec3 smallVec = vec3(0.0025, 0, 0);\n\tvec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n\t\t\t\t\t   dist - DistanceToObject(pos - smallVec.yxy),\n\t\t\t\t\t   dist - DistanceToObject(pos - smallVec.yyx));\n\tnormal = normalize(normal);\n\tfloat ambient = DistanceToObject(pos + normal * 1.0)*0.5;\n\tambient += DistanceToObject(pos + normal * 0.1)*5.0;\n\tambient = max(0.1, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\n\tvec4 texX = texture(iChannel0, pos.yz*0.75);\n\tvec4 texY = texture(iChannel0, pos.xz*0.75);\n\tvec4 texZ = texture(iChannel0, pos.xy*0.75);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\t//tex = tex * tex;\n\ttex.xyz = mix(tex.xyz, vec3(1.0,1.0,1.0), 0.97);\n\tfloat wave = sin(pos.y+iTime)*0.5+0.5;\n\twave = 1.0 - saturate(pow(wave, 0.25));\n\tif (finalMaterial == 1.0)\n\t{\n\n\t\ttex.xyz = mix(vec3(1.0, 0.2, 0.2), tex.xyz, wave);\n\t\ttex.xyz += vec3(1.0, 0.5, 0.5) * wave*16.0;\n\t//\ttex.xyz += wave;\n\t}\n\tif (finalMaterial == 2.0)\n\t{\n\t\ttex.xyz = mix(vec3(0.2, 1.1, 0.2), tex.xyz, wave);\n\t\ttex.xyz += vec3(1.0, 0.5, 0.5) * wave*16.0;\n\t}\n\tvec3 ref = reflect(relVec, normal);\n\tif (t <= maxDepth)\n\t{\n\t\tvec3 envLight = mix(environmentGroundColor, environmentSphereColor * 1.0, (normal.y * 0.5 + 0.5));\n\t\t\t// calculate the reflection vector for highlights\n\n\t\tvec3 sunRef = GetSunColorReflection(ref, -sunDir)* sunCol * max(0.0, dot(normal, -sunDir));\n\t\tvec3 sunDirect = max(0.0, dot(-sunDir, normal)) * sunCol * 1.0;\n\t\tfinalColor += (envLight) * tex.xyz;\n\t\tfinalColor *= vec3(1.0,1.0,1.0) * ambient;\n\t\tfinalColor += (sunDirect) * tex.xyz;// * ambient;\n\t\tfinalColor += sunRef;\n\t\t//finalColor = mix(finalColor, vec3(0.015,0.015,0.015), pow(saturate(distance(pos, camPos)*0.075), 0.7) );\n\t}\n\n\tfragColor = vec4(sqrt(clamp(finalColor*1.0, 0.0, 1.0)),1.0);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dj3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 314, 314, 344], [345, 345, 368, 368, 398], [399, 399, 424, 424, 454], [456, 456, 489, 489, 698], [699, 699, 732, 732, 941], [942, 942, 975, 975, 1116], [1120, 1156, 1197, 1197, 1290], [1291, 1444, 1498, 1498, 1927], [1928, 1928, 1978, 1978, 2393], [2395, 2395, 2514, 2575, 3269], [3271, 3271, 3305, 3403, 3430], [3431, 3431, 3469, 3519, 3605], [3607, 3607, 3637, 3637, 3678], [3680, 3680, 3706, 3706, 3907], [3909, 3909, 3931, 3931, 3952], [3954, 3954, 3988, 3988, 4406], [4408, 4408, 4460, 4460, 4587], [4589, 4589, 4622, 4622, 4698], [4699, 4699, 4722, 4722, 4780], [4781, 4781, 4804, 4804, 4878], [4879, 4879, 4939, 4939, 5152], [5153, 5153, 5215, 5215, 5430], [5431, 5431, 5493, 5493, 5708], [5710, 5710, 5746, 5746, 5858], [5859, 5859, 5898, 5898, 6005], [6007, 6007, 6027, 6027, 6091], [6093, 6093, 6139, 6139, 6276], [6278, 6278, 6300, 6300, 6844], [6846, 6846, 6868, 6868, 7721], [7723, 7723, 7745, 7745, 9654], [9656, 9656, 9688, 9688, 10350], [10352, 10352, 10409, 10409, 13761]], "test": "ok"}
{"id": "4dj3W3", "name": "Simple sphere raycasting", "author": "greg_o", "description": "My first working raycaster - simple, not well structured and have some bug, but mine :D", "tags": ["3d", "raytracing", "simple", "sphere"], "likes": 3, "viewed": 681, "published": "Public", "date": "1394371806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float intersect(vec4 lsphere, vec3 ray){\n// camera pos is origo\nvec4 sphere= lsphere;\nfloat a = dot(ray,ray);\nfloat b = dot(ray, -2.0* sphere.xyz);\nfloat c = dot(sphere.xyz,sphere.xyz)-dot(sphere.a,sphere.a);\nfloat determinant = b*b-4.0*a*c;\nif (determinant < 0.0) return -1.0;\nfloat t2 = (-b-sqrt(determinant))/(2.0*a);\nif(t2 > 0.001) return t2;\nfloat t1 = (-b+sqrt(determinant))/(2.0*a);\nif(t1 > 0.001) return t1;\nreturn -1.0;\n}\nvec3 F(vec3 normal, vec3 light,vec3 F0){\nfloat cos_a = abs(dot(normal,light));\n\tif (cos_a < 0.0) return vec3(0.0);\nreturn F0+(vec3(1.0) - F0)*pow(1.0-cos_a,5.0);\n}\n\nvec3 calcColor(vec3 view, vec3 normal, vec3 light,float lightintensity){\nvec3 nview = normalize(view);\nvec3 nnormal = normalize(normal);\nvec3 nlight = normalize(light);\nvec3 ambient = vec3(0.12,0.12,0.12);\nvec3 nhalf = normalize(nview+nlight);\nvec3 reflected = reflect(nnormal*-1.0,nlight);\n\t\nreturn ambient+(max(dot(nnormal,nlight),0.0)*0.3+0.4*pow(max(dot(reflected,nview),0.0),2.0))*lightintensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  vec3 ray = vec3(fragCoord.xy/iResolution.xx,-3.0);\n  vec4 light0 = vec4(sin(5.4*cos(iTime/2.0))*4.0,4.0+sin(5.4*sin(iTime/2.0))*4.0,5.0,1.0);\n\n\n  vec4 sphere = vec4(0.5,0.0,-10.0,0.5);\n  ray*=vec3(-1.0,-1.0,1.0);\n  ray+=vec3(0.5,0.3,0.0);\n  fragColor = vec4(vec3(0.0),0.6);\n  float t=intersect(sphere,ray);\n\tif (t > 0.0){\n\n\t  // calc intersection point\n\t  vec3 point = (t+0.0)*ray;\n\t  // calc normal\n\t  vec3 normal = point - sphere.xyz;\n\t  // calc lightvector\n\t  vec3 lightvector = light0.xyz - point; \n\t  fragColor  = vec4(calcColor(-1.0*ray,normal,lightvector,light0.a),1.0);\n\n\t}\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dj3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 63, 430], [431, 431, 471, 471, 594], [596, 596, 668, 668, 999], [1001, 1001, 1058, 1058, 1646]], "test": "error"}
{"id": "4dj3Wc", "name": "TrivialRaytracer3", "author": "Tivi", "description": "Tried out some raytracing to see how it works. Three spheres, two point lights, diffuse and specular lighting. There's probably something wrong with the horizon.", "tags": ["raytracing"], "likes": 0, "viewed": 203, "published": "Public", "date": "1394479035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct traceResult {\n\tfloat d;\n\tvec3 intersection;\n\tvec3 normal;\n\tvec3 color;\n};\n\t\ntraceResult trace( vec3 orig, vec3 delta ) {\n\tvec3 spherea = vec3(-200, 10, 2000);\n\tfloat spherea_r = 500.0;\n\tvec3 sphereb = vec3(400, 250, 1500);\n\tfloat sphereb_r = 300.0;\n\tvec3 spherec = vec3(200, -300, 1400);\n\tfloat spherec_r = 300.0;\n\t\n\tfloat plane_y = -300.0;\n\t\n\tfloat bar, foo, d=100000.0, d2;\n\tvec3 intersection, norm, color;\n\tcolor = vec3(0.5,0.5,0.5);\n    \n\tbar = dot(delta,orig-spherea);\n\tfoo = ( bar*bar - dot(orig-spherea,orig-spherea) + spherea_r*spherea_r );\n\td2 = - bar - sqrt(foo);\n\tif( foo>0.0 && d2 > 0.01 && d2<d ) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = normalize(spherea-intersection);\n\t\td=d2;\n\t\tcolor=vec3(0.8,0.2,0.3);\n\t}\n\t\n\tbar = dot(delta,orig-sphereb);\n\tfoo = ( bar*bar - dot(orig-sphereb,orig-sphereb) + sphereb_r*sphereb_r );\n\td2 = - bar - sqrt(foo);\n\tif( foo>0.0 && d2 > 0.01 && d2<d ) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = normalize(sphereb-intersection);\n\t\td=d2;\n\t\tcolor=vec3(0.3,0.2,0.8);\n\t}\n\t\n\tbar = dot(delta,orig-spherec);\n\tfoo = ( bar*bar - dot(orig-spherec,orig-spherec) + spherec_r*spherec_r );\n\td2 = - bar - sqrt(foo);\n\tif( foo>0.0 && d2 > 0.01 && d2<d ) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = normalize(spherec-intersection);\n\t\td=d2;\n\t\tcolor=vec3(0.3,0.2,0.8);\n\t}\n\t\n\td2 = (plane_y-orig.y)/delta.y;\n\tif( d2<d && d2 > 0.01) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = vec3(0.0,-1.0,0.0);\n\t\td=d2;\n\t\tcolor=vec3(0.1,0.3,0.2);\n\t}\n\t\n\treturn traceResult( d, intersection, norm, color );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat st = sin(iTime);\n\tfloat ct = cos(iTime);\n\tvec3 delta = normalize( vec3(fragCoord.xy-0.5*iResolution.xy, iResolution.x*0.5) );\n\tdelta = vec3(delta.x*ct-delta.z*st,delta.y,delta.z*ct+delta.x*st);\n    vec3 orig = vec3( 1200.0*st, 0.0, 1600.0-1400.0*ct );\n\tvec3 lighta = vec3(1000, 1000, 1000);\n\tvec3 lightb = vec3(-1000, 2000, -1000);\n\t\n\ttraceResult r = trace(orig, delta);\n\t\n\tvec3 delta2 = normalize(lighta-r.intersection);\n\tvec3 orig2 = r.intersection + 0.01*delta2;\n\ttraceResult r2 = trace(orig2,delta2);\n\t\n\tvec3 delta3 = normalize(lightb-r.intersection);\n\tvec3 orig3 = r.intersection + 0.01*delta3;\n\ttraceResult r3 = trace(orig3,delta3);\n\t\n\tif( ! (r.d > 0.001) ) {\n\t\tfragColor = vec4(1.0,0,0,0);\n\t}\n\telse {\n\t\tvec3 el = normalize(r.intersection-lighta);\n\t\tfloat e = dot( r.normal, el );\n\t\tfloat es = pow( dot( delta ,normalize(2.0*dot(el,r.normal)*r.normal-el) ), 100.0);\n\t\t//if(r2.d < distance(r2.intersection,lighta)-0.1 || e < 0.0){ e=0.0; es=0.0;} ;\n\t\t\n\t\tvec3 fl = normalize(r.intersection-lightb);\n\t\tfloat f = dot( r.normal, normalize(r.intersection-lightb) );\n\t\tfloat fs = pow( dot( delta ,normalize(2.0*dot(fl,r.normal)*r.normal-fl) ), 100.0);\n\t\tif(r3.d < distance(r3.intersection,lightb)-0.1 || f < 0.0) {f=0.0; fs=0.0;};\n\t\t//fragColor = vec4( sqrt(e*e+f*f)*r.color + (es+fs)*vec3(1.0,1.0,1.0), 1.0 );\n        fragColor = vec4( sqrt(e*e+f*f)*r.color + (es+fs)*vec3(1.0,1.0,1.0), 1.0 );\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dj3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 127, 127, 1522], [1524, 1524, 1581, 1581, 2987]], "test": "ok"}
{"id": "4djGDc", "name": "Simple Circles", "author": "asalga", "description": "Nothing special, just messing around.", "tags": ["2d", "circles"], "likes": 5, "viewed": 492, "published": "Public", "date": "1394507305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n  Andor Salga\n  March 2014\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2. - 1.;\n\tvec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.);\n\tfloat time = -iTime * 5.;\n\tfragColor = vec4( sin(length(uv * aspectRatio * .8) * 25. + time) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4djGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 91, 91, 305]], "test": "ok"}
{"id": "4djGWV", "name": "Reflection & Refraction", "author": "Justaway", "description": "Ray marcher with refraction and reflection.", "tags": ["raymarching"], "likes": 2, "viewed": 389, "published": "Public", "date": "1393732677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 global_color=vec4(0.0);\nbool global_stop=false;\nvec3 light_position;\nvec4 ambient_light=vec4(0.25,0.25,0.25,0.0);\nfloat total_distance=0.0;\nvec3 direction_vector;\nvec3 eye_point;\nbool inside_object=false;\nvec4 global_attenuation=vec4(1.0);\nfloat min_distance=0.001;\nfloat refraction_amount=0.25;\nfloat glass_torus(in vec3 point,in vec3 offset){\n\tvec3 point_offset=point+offset;\n\tvec2 torus_dimensions=vec2(0.5,0.25);\n\tvec4 color=vec4(0.0);\n\tfloat dist=length(vec2(length(point_offset.xy)-torus_dimensions.x,point_offset.z))-torus_dimensions.y;\n\tif(dist<0.0){\n\t\tif(inside_object==false){\n\t\t\tvec2 temp=vec2(point_offset.xy-torus_dimensions.x*normalize(point_offset.xy));\n\t\t\tvec3 normal=normalize(vec3(temp.x,temp.y,point_offset.z));\n\t\t\tinside_object=true;\n\t\t\tdirection_vector=refract(direction_vector,normal,1.0/1.5);\n\t\t\tfloat attenuation=abs(dot(normal,direction_vector));\n\t\t\tglobal_attenuation*=vec4(attenuation,(1.0-attenuation*0.5),attenuation,1.0);\n\t\t}\n\t}else{\n\t\tif(inside_object==true){\n\t\t\tvec2 temp=vec2(point_offset.xy-torus_dimensions.x*normalize(point_offset.xy));\n\t\t\tvec3 normal=normalize(vec3(temp.x,temp.y,point_offset.z));\n\t\t\tinside_object=false;\n\t\t\tdirection_vector=refract(direction_vector,-normal,1.0/1.5);\n\t\t\tfloat attenuation=abs(dot(direction_vector,normal));\n\t\t\tglobal_attenuation*=vec4(attenuation,(1.0-attenuation*0.5),attenuation,1.0);\n\t\t}\t\t\n\t}\n\tglobal_color=color;\n\treturn abs(dist);\n}\nfloat torus(vec3 point,vec3 offset){\n\tvec3 point_offset=point+offset;\n\tvec2 torus_dimensions=vec2(0.5,0.25);\n\tfloat dist=length(vec2(length(point_offset.xy)-torus_dimensions.x,point_offset.z))-torus_dimensions.y;\n\tif(dist<0.0){\n\t\tvec4 color=vec4(0.75,0.25,0.0,1.0);\n\t\tvec2 temp=vec2(point_offset.xy-torus_dimensions.x*normalize(point_offset.xy));\n\t\tvec3 normal=normalize(vec3(temp.x,temp.y,point_offset.z));\n\t\tfloat diffuse=dot(normal,normalize(light_position-point))/length(light_position-point);\n\t\tglobal_stop=true;\n\t\tglobal_color=vec4(clamp(color*diffuse,0.0,1.0))+color*ambient_light;\n\t}\n\treturn dist;\n}\nfloat plane(vec3 point){\n\tfloat dist=dot(point,vec3(0.0,0.0,1.0))+0.5;\n\tif(dist<0.0){\n\t\tvec4 color;\n\t\tvec4 color_1=vec4(1.0,1.0,1.0,1.0);\n\t\tvec4 color_2=vec4(0.25,0.75,1.0,1.0);\n\t\tif(abs(fract(point.x))<0.5){\n\t\t\tif(abs(fract(point.y))<0.5){\n\t\t\t\tcolor=color_1;\n\t\t\t}else{\n\t\t\t\tcolor=color_2;\n\t\t\t}\n\t\t}else{\n\t\t\tif(abs(fract(point.y))<0.5){\n\t\t\t\tcolor=color_2;\n\t\t\t}else{\n\t\t\t\tcolor=color_1;\n\t\t\t}\n\t\t}\n\t\tvec3 normal=vec3(0.0,0.0,1.0);\n\t\tfloat diffuse=dot(normal,normalize(light_position-point))/length(light_position-point);\n\t\tglobal_stop=true;\n\t\tglobal_color=vec4(clamp(color*diffuse,0.0,1.0))+color*ambient_light;\n\t}\t\n\treturn dist;\n}\nfloat glass_sphere(vec3 point,vec3 offset,float radius){\n\tvec3 point_offset=point+offset;\n\tvec4 color=vec4(0.0);\n\tfloat dist=length(point_offset)-radius;\n\tvec3 normal=0.5*normalize(point_offset);\n\tif(dist<0.0){\n\t\tif(inside_object==false){\n\t\t\tinside_object=true;\n\t\t\tdirection_vector=normalize(direction_vector-normal);\n\t\t}\n\t}else{\n\t\tif(inside_object==true){\n\t\t\tinside_object=false;\n\t\t\tdirection_vector=normalize(direction_vector+normal);\n\t\t}\t\t\n\t}\n\tglobal_color=color;\n\treturn abs(dist);\n}\nfloat reflective_sphere(vec3 point,vec3 offset){\n\tfloat radius=0.5;\n\tvec3 point_offset=point+offset;\n\tfloat dist=length(point_offset)-radius;\n\tvec4 color=vec4(0.5);\n\tif(dist<0.0){\n\t\tvec3 normal=normalize(point_offset);\n\t\tfloat attenuation=0.5*abs(dot(direction_vector,normal));\n\t\tglobal_attenuation*=vec4(1.0-attenuation);\n\t\tfloat diffuse=dot(normal,normalize(light_position-point))/length(light_position-point);\n\t\tdirection_vector=reflect(direction_vector,normal);\n\t\tglobal_color=color*ambient_light+color*diffuse;\n\t}\n\treturn abs(dist);\n}\nfloat sphere(vec3 point,vec3 offset){\n\tfloat radius=0.5;\n\tvec3 point_offset=point+offset;\n\tfloat dist=length(point_offset)-radius;\n\tif(dist<0.0){\n\t\tvec4 color=vec4(0.0,1.0,0.25,1.0);\n\t\tvec3 normal=normalize(point_offset);\n\t\tfloat diffuse=dot(normal,normalize(light_position-point))/length(light_position-point);\n\t\tglobal_stop=true;\n\t\tglobal_color=vec4(clamp(color*diffuse,0.0,1.0))+color*ambient_light;\n\t}\n\treturn dist;\n}\nfloat cube(vec3 point,vec3 offset){\n\tfloat radius=0.5;\n\tvec3 point_offset=point+offset;\n\tfloat dist=max(abs(point_offset.x),max(abs(point_offset.y),abs(point_offset.z)))-radius;\n\tif(dist<0.0){\n\t\tvec4 color=vec4(1.0,1.0,0.0,1.0);\n\t\tvec3 normal;\n\t\tfloat dot_1=dot(point_offset,vec3(1.0,0.0,0.0));\n\t\tfloat dot_2=dot(point_offset,vec3(0.0,1.0,0.0));\n\t\tfloat dot_3=dot(point_offset,vec3(0.0,0.0,1.0));\n\t\tif(abs(dot_1)>abs(dot_2)&&abs(dot_1)>abs(dot_3)){\n\t\t\tnormal=normalize(vec3(dot_1,0.0,0.0));\n\t\t}else if(abs(dot_2)>abs(dot_3)){\n\t\t\tnormal=normalize(vec3(0.0,dot_2,0.0));\n\t\t}else{\n\t\t\tnormal=normalize(vec3(0.0,0.0,dot_3));\n\t\t}\n\t\tfloat diffuse=dot(normal,normalize(light_position-point))/length(light_position-point);\n\t\tglobal_stop=true;\n\t\tglobal_color=vec4(clamp(color*diffuse,0.0,1.0))+color*ambient_light;\n\t}\n\treturn dist;\n}\nfloat dist(vec3 point){\n\tfloat min_dist=100.0;\n\tfloat dist;\n\tglobal_color=vec4(0.0);\n\tvec4 color=vec4(0.0);\n\tdist=reflective_sphere(point,vec3(-0.5,0.0,0.0));\n\tif(dist<min_dist){\n\t\tmin_dist=dist;\n\t\tcolor=global_color;\n\t}\n\tdist=reflective_sphere(point,vec3(0.5,-0.0,0.0));\n\tif(dist<min_dist){\n\t\tmin_dist=dist;\n\t\tcolor=global_color;\n\t}\n\tdist=reflective_sphere(point,vec3(0.0,0.0,-0.866));\n\tif(dist<min_dist){\n\t\tmin_dist=dist;\n\t\tcolor=global_color;\n\t}\n\tdist=plane(point);\n\tif(dist<min_dist){\n\t\tif(global_stop)return dist;\n\t\tcolor=global_color;\n\t\tmin_dist=dist;\n\t}\n\tdist=cube(point,vec3(-2.0,0.0,0.0));\n\tif(dist<min_dist){\n\t\tif(global_stop)return dist;\n\t\tcolor=global_color;\n\t\tmin_dist=dist;\n\t}\n\tdist=glass_torus(point,vec3(2.0,0.0,0.0));\n\tif(dist<min_dist){\n\t\tmin_dist=dist;\n\t}\n\tglobal_color=color;\n\t//out_color=color;\n\treturn min_dist;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat ratio=iResolution.x/iResolution.y;\n\tfloat time=iTime/10.0;\n\tlight_position=vec3(0.0,0.0,2.0);\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tvec2 screen_position=vec2((fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n\teye_point=vec3(3.0*sin(-mouse.x*3.14*2.0+time),3.0*cos(-mouse.x*3.14*2.0+time),-5.0*mouse.y+2.0+sin(time)/0.5);\n\tvec3 look_at=vec3(0.0,0.0,0.0);\n\tvec3 up_vector=vec3(0.0,0.0,1.0);\n\tdirection_vector=normalize(look_at-eye_point);\n\tvec3 horizontal_vector=normalize(cross(up_vector,direction_vector));\n\tvec3 vertical_vector=normalize(cross(direction_vector,horizontal_vector));\n\tdirection_vector=normalize(direction_vector+screen_position.x*horizontal_vector+screen_position.y*vertical_vector);\n\tvec4 color=vec4(0.0);\n\tvec3 point=eye_point;\n\tfloat nearest_object_distance;\n\tglobal_color=vec4(0.0);\n\tfor(int i=0;i<256;i++){\n\t\tnearest_object_distance=dist(point);\n\t\ttotal_distance+=nearest_object_distance;\n\t\tcolor+=global_color;\n\t\tif(global_stop)break;\n\t\tpoint+=direction_vector*max(nearest_object_distance,min_distance);\n\t}\n\tfragColor=color*global_attenuation;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4djGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 349, 349, 1413], [1414, 1414, 1450, 1450, 2021], [2022, 2022, 2046, 2046, 2647], [2648, 2648, 2704, 2704, 3135], [3136, 3136, 3184, 3184, 3675], [3676, 3676, 3713, 3713, 4097], [4098, 4098, 4133, 4133, 4920], [4921, 4921, 4944, 4944, 5756], [5757, 5757, 5813, 5813, 6939]], "test": "ok"}
{"id": "4dS3Wd", "name": " 1D, 2D & 3D Value Noise", "author": "morgan3d", "description": "Noise in up to three dimensions tuned for performance and avoiding visible tiling artifacts.", "tags": ["noise"], "likes": 148, "viewed": 19081, "published": "Public", "date": "1394922365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\n\n// All noise functions are designed for values on integer scale.\n// They are tuned to avoid visible periodicity for both positive and\n// negative coordinates within a few orders of magnitude.\n\n// For a single octave\n//#define NOISE noise\n\n// For multiple octaves\n#define NOISE fbm\n#define NUM_NOISE_OCTAVES 5\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\nconst float pi          = 3.1415926535;\nconst float inf         = 1.0 / 0.0;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat  intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat v = 0.0;\n\t\n\t// Visualize 1D, 2D, and 3D\n\tif (fragCoord.y > iResolution.y / 2.0) {\n\t\tif (fragCoord.x < iResolution.x / 2.0) {\n\t\t\t// 1D\n\t\t\tfloat coord = fragCoord.x * 0.05 + iTime * 5.0 - 10.0;\n\t\t\tfloat height = NOISE(coord) * iResolution.y / 2.0;\n\t\t\tv = clamp((height - fragCoord.y + iResolution.y / 2.0) / (iResolution.y * 0.02), 0.0, 1.0);\n\t\t} else if (fragCoord.x < iResolution.x / 2.0 + 1.0) {\n\t\t\tfragColor.rgb = vec3(1.0);\n\t\t\treturn;\n\t\t} else {\n\t\t\t// 2D\n\t\t\tvec2 coord = fragCoord.xy * 0.1 - vec2(iTime * 5.0, iResolution.y / 2.0);\n\t\t\tv = NOISE(coord);\n\t\t}\n\t} else if (fragCoord.y > iResolution.y / 2.0 - 1.0) {\n\t\tfragColor.rgb = vec3(1.0);\n\t\treturn;\n\t} else {\n\t\t// Ray-sphere\n\t\tconst float verticalFieldOfView = 25.0 * pi / 180.0;\n\t\t\t\n\t    vec3 P = vec3(sin(iTime) * 2.0, 0, 5.0);\n\t\tvec3 w = normalize(vec3(fragCoord.xy - iResolution.xy / vec2(2.0, 4.0), \n\t\t\t\t\t\t\t\t(iResolution.y / 2.0) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n\t\tfloat t = min(intersectSphere(vec3(0, 0, 0), 1.0, P, w),\n\t\t\t\t\t  intersectSphere(vec3(0, -2000, 0), 2000.0 - 1.0, P, w));\n\t\tif (t < inf) {\n\t\t\tvec3 X = P + w * t;\n\t\t\t// Fake lighting to make surfaces appear nicely\n\t\t\tv = NOISE(X * 10.0) * clamp(X.y * 0.75 + 1.0 - min(X.z * 0.05, 0.0), 0.0, 1.0) + \n\t\t\t\tclamp((length(X.xz) - 0.75) * 0.15, 0.0, 0.1);\n\t\t} else {\n\t\t\t// Background\n\t\t\tv = 0.5;\n\t\t}\n\t}\n\n    // Visualize with a fun color map\t\n\tfragColor.rgb = pow(v, 0.35) * 1.3 * normalize(vec3(0.5, fragCoord.xy / iResolution.xy)) + vec3(v * 0.25);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dS3Wd.jpg", "access": "shaders20k", "license": "bsd-new", "functions": [[410, 484, 505, 505, 572], [573, 573, 593, 593, 698], [700, 700, 722, 722, 854], [857, 857, 878, 878, 1512], [1515, 1515, 1536, 1536, 2297], [2300, 2300, 2320, 2320, 2498], [2501, 2501, 2520, 2520, 2797], [2800, 2800, 2819, 2819, 2995], [2998, 3180, 3203, 3203, 3219], [3220, 3220, 3250, 3250, 3281], [3283, 3358, 3415, 3415, 3689], [3691, 3691, 3748, 3748, 5238]], "test": "error"}
{"id": "4dSGD3", "name": "Foggy fractal", "author": "guil", "description": "I tried to render a fractal using the raymarching from Clouds by IQ (https://www.shadertoy.com/view/XslGRr) and I got this.", "tags": ["fractal", "kleinian"], "likes": 1, "viewed": 242, "published": "Public", "date": "1393960575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Based on Clouds by inigo quilez : https://www.shadertoy.com/view/XslGRr\n\nvec3 c =  vec3(1.05);//vec3(.7,.9,1.41);\nconst int MaxIter = 12;\nvec3 sundir = vec3(-1.0,0.0,0.0);\n\n\nvec4 map( vec3 p)\n{\n\tfloat dr = 1.0;\n\tfloat g=1.0;\n\tvec3 ot = vec3(1000.0); \n\tfloat r2;\n  \n\tfor( int i=0; i<MaxIter;i++ )\n\t{          \n        r2 = dot(p,p);\n        if(r2>100.)continue;\n\t\t\n        ot = min( ot, abs(p) );\n\n\t\t//Kali formula \n        p=abs(p)/r2*g-c;         \n\t\tdr= dr/r2*g;  \t\t\n\t}\n\t\n\tfloat d;\n\td = (abs(p.x)+abs(p.y))*length(p)/dr;\t\n\t//d = (length(p.xz)*abs(p.y)+length(p.xy)*abs(p.z)+length(p.yz)*abs(p.x))/dr;\n\t//d = 1.5*(length(p.xz))*length(p.xy)/dr;\n\t//r2 = dot(p,p);d = .5*sqrt(r2)*log(r2)/dr;\n\t//d = 1.*length(p)/dr;\n\treturn vec4(ot,d);\n\t\n}\n\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n    float fog = .65+.6*cos(.3*iTime);\n\n    \n\tfloat t = 0.0;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.a > 0.99 ) continue;\n\n\t\tvec3 pos = ro + t*rd;\t\t\n\t\tvec4 col = map( pos );\n\t\tfloat d = col.a;\n\t\tcol.a = 0.035*fog/d;\n\t\tcol.rgb *= col.a;\n\n\t\tif(dot(pos,pos)<11.)sum = sum + col*(1.0 - sum.a);\t\n     \n\t\t//t += 0.1;\n\t\tt += min(0.1,d*.25);\n\t\t\n\t}\n\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*(iMouse.xy) / iResolution.xy+sin(.1*iTime);\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\n    vec4 res = raymarch( ro, rd );\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\tcol = mix( col, res.xyz, res.w );\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSGD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[185, 265, 284, 284, 828], [832, 832, 873, 873, 1304], [1307, 1307, 1364, 1364, 2212]], "test": "ok"}
{"id": "4dSGWd", "name": "Antialiasing", "author": "Justaway", "description": "Multi-sample anti-aliasing adapted for raymarching. Not efficient but it works.  Click to move camera.", "tags": ["raymarching", "antialiasing"], "likes": 45, "viewed": 2859, "published": "Public", "date": "1395098505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define MAX_ITER 128\n#define MAX_ITER_INTERNAL 0\n#define MAX_ITER_SHADOW 32\n#define MAX_DIST_SHADOW 10.0\n#define MIN_DIST_SHADOW 0.1\n#define MAX_DIST 1000.0\n#define MIN_DIST 0.0001\n#define FOV 0.75\n#define SPECULAR 5.0\n#define SAMPLE_RADIUS 0.001\n#define PENUMBRA 5.0\n#define MULTISAMPLE 4\nstruct screen{\n\tvec2 p;\n\tvec2 r;\n\tvec2 m;\n\tfloat t;\n};\nstruct ray{\n\tvec4 c;\n\tvec3 p;\n\tvec3 d;\n\tvec3 n;\n\tfloat t;\n\tint i;\n};\nstruct light{\n\tvec4 c;\n\tvec3 p;\n};\nlight l=light(\n\tvec4(0.5),\n\tvec3(0.0,-5.0,5.0)\n);\nvec4 a=vec4(0.5);\nfloat s;\nvoid srand(vec2 p){\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\nfloat rand(){\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\nmat2 rot2d(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts, c);\n}\nmat3 rot_x(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\t1.0,0.0,0.0,\n\t\t0.0,  c, -s,\n\t\t0.0,  s,  c);\n}\nmat3 rot_y(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\tc,  0.0,  s,\n\t\t0.0,1.0,0.0,\n\t\t-s, 0.0,  c);\n}\nmat3 rot_z(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\t  c, -s,0.0,\n\t\t  s,  c,0.0,\n\t    0.0,0.0,1.0);\n}\nmat3 rot(vec3 z,float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat b=1.0-c;\n\treturn mat3(\n\t\tb*z.x*z.x+c,b*z.x*z.y-z.z*s,b*z.z*z.x+z.y*s,\n\t\tb*z.x*z.y+z.z*s,b*z.y*z.y+c,b*z.y*z.z-z.x*s,\n\t\tb*z.z*z.x-z.y*s,b*z.y*z.z+z.x*s,b*z.z*z.z+c);\n}\nfloat expstep(float x,float k,float n){\n\treturn exp(-k*pow(x,n));\n}\nfloat smin(float a,float b,float k){\n\tfloat h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\nfloat dome(inout ray r){\n\tfloat d=dot(r.p,vec3(0.0,0.0,1.0))+0.5;\n\td=smin(d,50.0-length(r.p),10.0);\n\tif(d<0.0){\n\t\tif(fract(r.p.x)<0.5){\n\t\t\tr.c=vec4(0.0);\n\t\t}else{\n\t\t\tr.c=vec4(1.0);\n\t\t}\t\t\n\t\tr.i=MAX_ITER_INTERNAL+1;\n\t}\n\treturn d;\n}\nfloat box(inout ray r){\n\tfloat d=max(max(abs(r.p.x),abs(r.p.y))-0.5,abs(r.p.z)-0.5);\n\tif(d<0.0){\n\t\tif(fract(length(r.p)*10.0+0.25)<0.5)r.c=vec4(1.0);\n\t\telse r.c=vec4(0.5);\n\t\tr.i=MAX_ITER_INTERNAL+1;\n\t}\n\treturn d;\n}\nfloat sphere(inout ray r){\n\tfloat d=length(r.p)-0.5;\t\n\tif(d<0.0){\n\t\tr.c=vec4(1.0);\n\t\tr.i++;\n\t}\n\treturn d;\n}\nfloat morph(inout ray r,vec3 o){\n\tvec3 p=r.p+o;\n\tfloat t=r.t/10.0;\n\tfloat d=0.0;\n\tt=fract(t);\n\t\n\t#define NUM_MORPH 4.0\t\n\tfloat sphere=length(p)-0.5;\n\tfloat box=max(abs(p.x),max(abs(p.y),abs(p.z)))-0.5;\n\tfloat octa=dot(abs(p),normalize(vec3(1.0)))-0.29;\n\tfloat torus=length(vec2(length(p.xz)-0.25,p.y))-0.125;\n\t\t\n\td+=max((NUM_MORPH*(abs(t-0.5))-0.5*(NUM_MORPH-2.0)),0.0)*octa;\n\td+=max((1.0-NUM_MORPH*abs(t-1.0/NUM_MORPH)),0.0)*sphere;\n\td+=max((1.0-NUM_MORPH*abs(t-2.0/NUM_MORPH)),0.0)*box;\n\td+=max((1.0-NUM_MORPH*abs(t-3.0/NUM_MORPH)),0.0)*torus;\n\t\n\tif(d<0.0){\n\t\tif(fract(r.p.y*10.0)<0.5){\n\t\t\tr.c=vec4(0.0);\n\t\t}else{\n\t\t\tr.c=vec4(1.0);\n\t\t}\t\t\n\t\tr.i=MAX_ITER_INTERNAL+1;\n\t}\n\treturn d;\n}\nfloat dist(inout ray r){\n\tfloat d=MAX_DIST;\n\td=min(d,dome(r));\n\td=min(d,morph(r,vec3(0.0)));\n\treturn d;\n}\nvoid normal(inout ray r){\n\tfloat d=dist(r);\n\tvec3 n=vec3(SAMPLE_RADIUS,0.0,0.0);\n\tray r0=r;\n\tray r1=r;\n\tray r2=r;\n\tr0.p+=n.xyy;\n\tr1.p+=n.yxy;\n\tr2.p+=n.yyx;\n\tr.n=normalize(vec3(dist(r0)-d,dist(r1)-d,dist(r2)-d));\n}\nvec4 ambient(ray r){\n\treturn r.c*a;\n}\nvec4 diffuse(ray r){\n\tvec3 v=l.p-r.p;\n\treturn clamp(r.c*l.c*dot(r.n,normalize(v)),0.0,1.0);\n}\nvec4 specular(ray r){\n\tfloat d=length(l.p-r.p);\n\tvec3 v=normalize(l.p-r.p);\n\treturn l.c*max(pow(dot(v,reflect(r.d,r.n)),SPECULAR),0.0);\n}\nvec4 shadow(ray r){\n\tfloat s=1.0;\n\tfloat t=MIN_DIST_SHADOW;\n\tfor(int i=0;i<MAX_ITER_SHADOW;i++){\n\t\tray tmp=r;\n\t\ttmp.p+=r.d*t;\n\t\tfloat h=dist(tmp);\n\t\tif(h<MIN_DIST)return vec4(0.0);\n\t\ts=min(s,PENUMBRA*h/t);\n\t\tt+=h;\n\t\tif(t>MAX_DIST_SHADOW)break;\n\t}\n\treturn vec4(1.0)*s;\n}\nvec4 trace(inout ray r){\n\tr.c=vec4(1.0);\n\tfor(int i=0;i<MAX_ITER;i++){\n\t\tfloat d=dist(r);\n\t\tif(r.i>MAX_ITER_INTERNAL)break;\n\t\tr.p+=r.d*max(d,MIN_DIST);\n\t}\n\tif(r.i==0){\n\t\tif(fract(r.p.x)<0.5){\n\t\t\tr.c=vec4(0.0);\n\t\t}else{\n\t\t\tr.c=vec4(1.0);\n\t\t}\n\t}\n\tnormal(r);\n\tray tmp=r;\n\ttmp.d=normalize(l.p-r.p);\n\ttmp.p-=2.0*MIN_DIST*r.d;\t\n\treturn ambient(r)+min(max(diffuse(r),specular(r)),shadow(tmp));\n}\nvoid initray(out ray r,screen s,vec2 o){\n\tvec3 l=vec3(0.0,0.0,0.0);\n\tvec3 tmp=vec3(2.0,0.0,0.0);\n\ttmp*=rot_y((PI*s.m.y)/4.0-PI/8.0);\n\ttmp*=rot_z(2.0*PI*s.m.x);\n\tvec3 e=l+tmp;\n\tvec3 u=vec3(0.0,0.0,1.0);\n\tvec3 d=normalize(l-e);\n\tvec3 h=normalize(cross(d,u));\n\tvec3 v=normalize(cross(h,d));\n\td*=rot(v,FOV*s.p.x+o.x/s.r.x);\n\td*=rot(h,FOV*s.p.y+o.x/s.r.y);\n\tr=ray(vec4(0.0),e,d,vec3(0.0),s.t,0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=iTime;\n\tfloat r=iResolution.x/iResolution.y;\n\tvec2 m=vec2(\n\t\t(iMouse.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(iMouse.y-iResolution.y/2.0)/iResolution.y);\n\tvec2 p=vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n\tscreen s=screen(p,iResolution.xy,m,t);\n\tsrand(p);\n\tray v;\n\tvec4 c=vec4(0.0);\n\tif(p.x<1.0/iResolution.x&&p.x>-1.0/iResolution.x){\n\t\tc=vec4(1.0,0.0,0.0,0.0);\n\t}else if(p.x<0.0){\n\t\tvec2 x=vec2(0.5,0.0);\n\t\tx*=rot2d(PI/8.0);\n\t\tfor(int i=0;i<MULTISAMPLE;i++){\n\t\t\tinitray(v,s,x);\n\t\t\tc+=trace(v)/float(MULTISAMPLE);\t\t\n\t\t\tx*=rot2d(PI/2.0);\n\t\t}\n\t}else{\n\t\tinitray(v,s,vec2(0.0));\n\t\tc=trace(v);\n\t}\n\tfragColor=c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[551, 551, 570, 570, 614], [615, 615, 628, 628, 686], [687, 687, 707, 707, 774], [775, 775, 795, 795, 891], [892, 892, 912, 912, 1008], [1009, 1009, 1029, 1029, 1128], [1129, 1129, 1154, 1154, 1362], [1363, 1363, 1402, 1402, 1430], [1431, 1431, 1467, 1467, 1545], [1546, 1546, 1570, 1570, 1775], [1776, 1776, 1799, 1799, 1990], [1991, 1991, 2017, 2017, 2098], [2099, 2099, 2131, 2131, 2781], [2782, 2782, 2806, 2806, 2887], [2888, 2888, 2913, 2913, 3101], [3102, 3102, 3122, 3122, 3139], [3140, 3140, 3160, 3160, 3233], [3234, 3234, 3255, 3255, 3371], [3372, 3372, 3391, 3391, 3641], [3642, 3642, 3666, 3666, 4030], [4031, 4031, 4071, 4071, 4423], [4424, 4424, 4480, 4480, 5161]], "test": "ok"}
{"id": "4s23Wc", "name": "pfhrector", "author": "pfhunk", "description": "80s vector graphics inspired kaliset", "tags": ["2d", "fractal", "kaliset"], "likes": 7, "viewed": 791, "published": "Public", "date": "1394505895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\nconst int iterations=20;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 z=fragCoord.xy / iResolution.xy-.5;\n\tz.y*=iResolution.y/iResolution.x;\n\t\n\tz.x += sin(z.y*2.0+iTime * .2)/10.0;\n\tz*=.6+pow(sin(iTime*.05),10.)*10.;\n\tz+=vec2(sin(iTime*.08),cos(iTime*.01));\n\tz=abs(vec2(z.x*cos(iTime*.12)-z.y*sin(iTime*.12)\n\t\t\t  ,z.y*cos(iTime*.12)+z.x*sin(iTime*.12)));\n\t\n\tvec2 c=vec2(.2, 0.188);\n\t\n\tfloat expsmooth=0.;\n\tfloat average=0.;\n\tfloat l=length(z);\n\tfloat prevl;\n\t\n\tfor (int i=0; i<iterations; i++) \n\t{\n\t\tz = abs(z * (2.2 + cos(iTime*0.2)))/(z.x*z.y)-c;\t\n\n\t\tprevl=l;\n\t\tl=length(z);\n\t\texpsmooth+=exp(-.2/abs(l-prevl));\n\t\taverage+=abs(l-prevl);\n\t}\n\t\n\tfloat brightness = expsmooth*.002;\n\t\n\taverage/=float(iterations) * 22.87;\n\t\n\tvec3 myColor=vec3(max(abs(sin(iTime)), 0.45),max(abs(cos(iTime * 0.2)), 0.45),max(abs(sin(iTime* 2.)), 0.45));\n\tvec3 finalColor;\n\n\tfinalColor.r = (float(average)/myColor.r);\n\tfinalColor.g = (float(average)/myColor.g);\n\tfinalColor.b = (float(average)/myColor.b);\n\n\tfragColor = vec4(finalColor*brightness,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s23Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 184, 184, 1152]], "test": "ok"}
{"id": "4s23WV", "name": "Edge Detect", "author": "mu6k", "description": "Derivative based edge detection. dFdx() and dFdy() are applied to the surface normal. It will detect discontinuities in the normal.", "tags": ["raymarching", "edge", "derivative", "toon"], "likes": 43, "viewed": 2335, "published": "Public", "date": "1393692019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n  email: muuuusk at gmail dot com\n\n2016-02-02:\n\n  Added fixes to make it more compatible.\n  Also added some comments + shading improvements\n  By now you can use a multipass aproach, \n  this method was for tha times when passes were not avaiable.\n\n\n2014-03-01:\n\n  Derivative based edge detection. \n  dFdx() and dFdy() are applied to the surface normal. \n  It will detect discontinuities in the normal.\n\n*/\n\n#define BACKGROUND_COLOR vec3(1.0)\n#define EDGE_COLOR vec3(0.0)\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n// a short hand for time, because I hate typing out iTime\n#define t (iTime - 4.0)\n\nfloat df_back(vec3 p)\n{\n\treturn (16.0-length(p));\n}\n\n//the rotation of the object\n#define rot (rotate_x(t*.5)*rotate_y(t*.5)*rotate_z(t*.5))\n#define trans (vec3(sin(t),cos(t),sin(t))*.1)\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n//distance function for the rotating object\nfloat df_obj(vec3 p)\n{\n\tp += trans;\n\tp *= rot;\n\t\n\t//p = mod(p+vec3(2.0),4.0)-vec3(2.0);\n\tfloat s0 = dot(abs(p),vec3(1.0))-1.5;\n\ts0*=.5;\n\t\n\t//p*=rot;\n\t\n    //all those spheres\n\tfloat s1 = length(p+vec3(1.,.0,.0))-.5;\n\tfloat s2 = length(p+vec3(.0,1.,.0))-.5;\n\tfloat s3 = length(p+vec3(.0,.0,1.))-.5;\n\tfloat s4 = length(p-vec3(1.,.0,.0))-.5;\n\tfloat s5 = length(p-vec3(.0,1.,.0))-.5;\n\tfloat s6 = length(p-vec3(.0,.0,1.))-.5;\n    \n    //combine the spheres with union and intersect into s0\n\ts0 = min(s0,s1);\n\ts0 = min(s0,s2);\n\ts0 = min(s0,s3);\n\ts0 = max(s0,-s4);\n\ts0 = max(s0,-s5);\n\ts0 = max(s0,-s6);\n\t\n    //apply rotation\n\tp*=rot;\n\t\n    //combine into s0 a bunch of cubes\n\ts0 = min(s0,max(max(abs(p.x+2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+2.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-2.0),abs(p.x)),abs(p.y))-.25);\n\t\n    //apply rotation again\n\tp*=rot;\n\t\n    //combine 6 other cubes (the outer ones that rotate faster\n\ts0 = min(s0,max(max(abs(p.x+4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+4.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-4.0),abs(p.x)),abs(p.y))-.25);\n\t\n\treturn s0;\n}\n\n\n//distance function for the whole scene\nfloat df(vec3 p)\n{\n\treturn min(df_obj(p),df_back(p));\n}\n\n//normal function for the whole scene\nvec3 nf(vec3 p)\n{\n\tfloat e = .01;\n\tfloat dfp = df(p);\n\treturn vec3(\n\t\t(dfp+df(p+vec3(e,.0,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,e,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,.0,e)))/e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //compte screen space, center around the center of the screen\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y; //aspect ratio correction\n\t\n    //compute mouse position in screen space (multiplied by 2, for greater effect)\n\tvec2 mouse = iMouse.xy/ iResolution.xy*2.0-1.0;\n\tmouse.x *= iResolution.x/iResolution.y*4.0;\n\t\n    //the rotation matrix for the mouse\n\tmat3 rotmat = rotate_y(mouse.x) * rotate_x(mouse.y);\n\t\n    //initial position, 0,0,-3 rotated by mouse movements\n\tvec3 pos = vec3(.0,.0,-3.0)*rotmat ;\n    \n    //ray direction\n\tvec3 dir = normalize(vec3(uv*.5,1.0-length(uv)*.25))*rotmat;\n\t\n    //light direction\n\tvec3 light_dir = normalize(vec3(.4,.5,.6));\n    //light color\n\tvec3 light_color = vec3(.6,.5,.4);\n\t\n    //raymarch to intersect screen ray with scene\n\tfor (int i=0; i<80; i++){\n\t\tfloat dist = df(pos);\n\t\tpos+=dir*dist;\n\t\tif (dist<.00001) break;\n\t}\n\t\n\tvec3 color = vec3(1.0);\n\tvec3 n = nf(pos);\n\t\n    //here is where we get the derivatives for the normal function\n\tvec3 dfdxn = dFdx(n);\n\tvec3 dfdyn = dFdy(n);\n\t\n    //edges become sum of amplitudes of the derivatives\n\tfloat lines = length(dfdxn) + length(dfdyn);\n    \n    //some post processing to make it better\n    lines = lines*12.75;\n\tlines = lines-1.0;\n\tlines = clamp(lines,.0,1.0);\n\t\n\tif (length(pos)>5.0)\n\t{\n        //background\n\t\tcolor = BACKGROUND_COLOR;\n\t}\n\telse\n\t{\n        //object shading\n\t\t\n        //ambient occlsion\n\t\tfloat oa = 0.5;\n\t\tfor (int i=0; i<30; i++)\n\t\t{\n\t\t\tfloat fi = float(i);\n\t\t\toa += df_obj(pos+noise(fi)-vec3(.5))*.15;\n\t\t}\n\t\toa = min(1.0,oa);\n\t\t\n        //secondary ray for soft shadow\n\t\tvec3 ocdir = light_dir;\n\t\tvec3 ocpos = pos+ocdir*.1;\n\t\tfloat od = 1.0;\n\t\tfor (int i=0; i<60; i++)\n\t\t{\n\t\t\tfloat dist = df_obj(ocpos);\n\t\t\tod = min(od,dist*10.);\n\t\t\tocpos += ocdir*dist*.3;\n\t\t\tif (dist<.0||dist>10.0) break;\n        }\n\t\tod = max(.0,od);\n\t\t\n        //compute diffuse component\n\t\tfloat diffuse = max(.0,dot(n,light_dir)*.8+.2)*od*oa*1.5;\n        \n        //compute specular component\n        float specular = pow(max(.0,dot(reflect(dir,n),light_dir)),16.0)*oa*od;\n        \n       \t//combine diffuse specular and add ambient\n\t\tcolor = vec3(.1,.2,.3)*oa + diffuse*light_color;\n        color += vec3(specular);\n\t}\n\t\n\tvec3 color0 = mix(color,EDGE_COLOR,lines);\n\tvec3 color1 = n*.4+.4;\n\tvec3 color2 = dfdxn+dfdyn;\n\tvec3 color3 = vec3(lines);\n\t\n\tfloat mt = mod(t,32.0);\n\tfloat mti = mod(t,1.0);\n\t\n    //material preview transition :)\n    //it's basically a switchtable\n\tif (mt<7.0){color = color0;}\n\telse if (mt<8.0){color = mix(color0,color1,mti);}\n\telse if (mt<11.0){color = color1;}\n\telse if (mt<12.0){color = mix(color1,color2,mti);}\n\telse if (mt<13.0){color = color2;}\n\telse if (mt<14.0){color = mix(color2,color3,mti);}\n\telse if (mt<18.0){color = color3;}\n\telse if (mt<19.0){color = mix(color2,color1-color3,mti);}\n\telse if (mt<24.0){color = color1-color3;}\n\telse if (mt<25.0){color = mix(color1-color3,color,mti);}\n\telse if (mt<29.0){;}\n\telse if (mt<30.0){color = mix(color,color0,mti);}\n\telse if (mt<32.0){color = color0;}\n\t\n    //post processing\n    color *= 2.0-length(uv)*.5;\n\tcolor += noise(vec3(fragCoord.xy,t*60.0))*0.01;\n\tcolor = color*vec3(1.7,1.5,1.4)/(vec3(1.0)+color);\n\tfragColor = vec4(pow(color,vec3(.5)),1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s23WV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[565, 606, 630, 630, 695], [696, 696, 719, 719, 806], [807, 807, 830, 830, 917], [918, 918, 941, 941, 1027], [1029, 1112, 1135, 1135, 1163], [1300, 1348, 1368, 1368, 1434], [1435, 1435, 1454, 1454, 1512], [1513, 1513, 1532, 1532, 1791], [1793, 1793, 1824, 1824, 1894], [1895, 1895, 1925, 1925, 1987], [1988, 1988, 2018, 2018, 2293], [2295, 2339, 2361, 2361, 3846], [3849, 3889, 3907, 3907, 3944], [3946, 3984, 4001, 4001, 4147], [4150, 4150, 4207, 4273, 7481]], "test": "ok"}
{"id": "4s2GWd", "name": "[SH2014]Thing", "author": "P_Malin", "description": "Submission for Shadertoy Hackathon 2014 - Theme \"Evolution\"", "tags": ["sh2014"], "likes": 30, "viewed": 1591, "published": "Public", "date": "1395286184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat kFarClip=1000.0;\n\nvec3 vLightPos = vec3(1.5, 2.0, 3.0);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.5, 0.05);\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nvec3 vCameraOffset = vec3(0.0, 0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n\t\n\tfloat fAngle = vMouse.x * 2.0 * 3.14 + 2.8;\n\tvec3 vCameraPos = vec3(sin(fAngle) * 10.0, vMouse.y * 10.0 - 2.0, cos(fAngle) * 10.0);\n\n\t\n\tvCameraOffset.z = iTime * 10.0;\n\t\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 0.0);\n\n\tif(iMouse.z <= 0.0)\n\t{\n\t\tvCameraPos += vCameraOffset;\n\t\tvCameraTarget += vCameraOffset;\n\n\t\tvLightPos += vCameraOffset;\n\t\t\n\t\tvCameraPos.x += sin(iTime * 0.5);\n\t}\n\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t\n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n// CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\n// POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.5;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tconst float kExposure = 2.0;\n\t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0/kGamma));\t\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\treturn ApplyGamma(vTemp);\t\t\n}\n\t\n// RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\t\n\tfloat fTileHash = (floor(vPos.x / 10.0) + floor(vPos.x / 12.0)) * 0.5;\n\t\n\tvec3 vStrandDomain = mod(vPos, 10.0) - 5.0;\n\t\t\n\tvStrandDomain.x += sin(vPos.y * 0.1);\n\t\n\tvStrandDomain.y += fTileHash * 10.0 + iTime * (1.0 + fract(fTileHash*123.456)) * 3.0;\n\t\n\tfloat fAngle = vPos.y * 0.5 + iTime* (1.0 + fract(fTileHash*123.456)) * 3.0;\n\tfloat s = sin(fAngle);\n\tfloat c = cos(fAngle);\n\n\tvec3 vStrutDomain = vStrandDomain;\n\tvStrutDomain.x = vStrandDomain.x * s + vStrandDomain.z * c;\n\tvStrutDomain.z = vStrandDomain.x * c - vStrandDomain.z * s;\n\t\n\tfloat fEdgeDist1 = length(vStrutDomain.xz + vec2(-1.0, 0.0)) - 0.25;\n\tfloat fEdgeDist2 = length(vStrutDomain.xz + vec2( 1.0, 0.0)) - 0.25;\n\t\n\tfloat fOutDist = min(fEdgeDist1, fEdgeDist2);\n\tvOutUVW_Id = vec4(vStrutDomain.xy, 0.0, 1.0);\n\n\tvStrutDomain.y = mod(vStrandDomain.y, 1.0) - 0.5;\n\t\n\tfloat fStrutDist = length(vStrutDomain.zy) - 0.1;\n\t\n\tfStrutDist = max(fStrutDist, length(vStrutDomain.xz) - 0.75);\n\t\n\tif(fStrutDist < fOutDist)\n\t{\n\t\tfOutDist = fStrutDist;\n\t\tvOutUVW_Id = vec4(vStrutDomain.xz, 0.0, 2.0);\n\t}\n\t//fOutDist = min(fStrutDist, fOutDist);\n\t\n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.01;\n\tconst int kRaymarchMaxIter = 48;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n#define SOFT_SHADOW\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n#ifndef SOFT_SHADOW\n\tC_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n#else\t\n\t#define kShadowIter 32\n\t#define kShadowFalloff 5.0\n\tfloat fShadow = 1.0;\n\tfloat t = 0.01;\n\tfloat fDelta = 1.0 / float(kShadowIter);\n\tfor(int i=0; i<kShadowIter; i++)\n\t{\n\t\tvec4 vUnused;\n\t\tfloat d = GetSceneDistance(vUnused, vOrigin + vDir * t);\n\t\t\n\t\tfShadow = min( fShadow, kShadowFalloff * d / t );\n\t\t\n\t\tt = t + fDelta;\n\t}\n\n\treturn clamp(fShadow, 0.0, 1.0);\n#endif\n}\n\n// AMBIENT OCCLUSION\n\nfloat GetAmbientOcclusion( const in vec3 vPos, const in vec3 vNormal )\n{\n\tfloat fAmbientOcclusion = 0.0;\n\t\n\tfloat fStep = 0.1;\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += fStep;\n\t\t\n\t\tvec4 vUnused;\n\t\tfloat fSceneDist = GetSceneDistance(vUnused, vPos + vNormal * fDist);\n\t\t\n\t\tfloat fAmount = (fDist - fSceneDist);\n\t\t\n\t\tfAmbientOcclusion += max(0.0, fAmount * fDist );                                  \n\t}\n\t\n\treturn max(1.0 - fAmbientOcclusion, 0.0);\n}\n\n// LIGHTING\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\t\n\tvDiffuseLight += vLightColour * fNDotL;\n\t\n\tvec3 vHalfAngle = normalize(-vViewDir + vLightDir);\n\tfloat fSpecularPower = exp2(4.0 + 6.0 * fSmoothness);\n\tfloat fSpecularIntensity = (fSpecularPower + 2.0) * 0.125;\n\tvSpecularLight += vLightColour * fSpecularIntensity * clamp(pow(dot(vHalfAngle, vNormal), fSpecularPower), 0.0, 1.0) * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tfloat kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\n}\n\n// SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.1;// + vec2(iTime * 0.5, 0.0);\n\t\tvOutAlbedo = texture(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 1.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) / vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) / vRes;\n\t\t\n\t\tfloat fSampleW = texture(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = vOutAlbedo.r * 0.9;//\n\t\t\n\t\tvOutR0 = vec3(0.5) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == 2.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy;\n\t\t//vec2 vUV = vec2(intersection.vUVW.z, iTime * -0.5 * 3.14 + atan(intersection.vUVW.x, intersection.vUVW.y));\n\t\tvOutAlbedo = texture(iChannel1, vUV).rgb;\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = vOutAlbedo.r;\t\t\t\n\t\tvOutR0 = vec3(0.05);\n\t}\n\t\n\t//vOutR0 = vec3(0.9);\n\t//fOutSmoothness = 0.5;\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\n\tvec3 vResult = vec3(0.0);\n\t\n\t//if(false)\n\t{\n\t\tvResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n\t}\n\t/*else\n\t{\n\t\tvec3 vEnvMap = texture(iChannel2, vDir).rgb;\n\t\tvEnvMap = vEnvMap * vEnvMap;\n\t\tfloat kEnvmapExposure = 0.5;\n\t\tvResult = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\t}*/\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.005;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn vec3(0.1, 0.25, 0.0);\t\t\n}\n\n\nvec3 vSunLightColour = vec3(1.0, 0.9, 0.6) * 2.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvec3 vGlow = vec3(0.0);\n\tAddPointLightFlare(vGlow, vRayOrigin, vRayDir, fDist, vLightPos, vLightColour);\t\t\t\t\t\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor) + vGlow;\t\n}\n\n// TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir )\n{\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n\tfor(int i=0; i<2; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n\t\t\tAddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\tvDiffuseLight += 0.2 * GetAmbientOcclusion(intersection.vPos, vBumpNormal);\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - dot(-vBumpNormal, vRayDir), 5.0) * fSmoothFactor;\n\t\t\t\n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\n\t\t\n\t\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n\tvColour += vSkyColor * vRemaining;\n\t\n\treturn vColour;\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2GWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 419, 476, 476, 1194], [1196, 1207, 1249, 1249, 1348], [1350, 1350, 1452, 1452, 1726], [1728, 1739, 1804, 1804, 2000], [2002, 2002, 2046, 2046, 2123], [2125, 2125, 2167, 2167, 2238], [2240, 2240, 2301, 2301, 2413], [2416, 2530, 2597, 2597, 3715], [3717, 3717, 3758, 3758, 4473], [4475, 4475, 4573, 4573, 5157], [5180, 5180, 5266, 5266, 5821], [5823, 5845, 5917, 5917, 6309], [6311, 6324, 6523, 6523, 6924], [6926, 6926, 7147, 7147, 7624], [7626, 7626, 7814, 7814, 8141], [8143, 8143, 8370, 8370, 8701], [8703, 8703, 8838, 8838, 8985], [8987, 9007, 9156, 9156, 10489], [10491, 10491, 10532, 10532, 10854], [10856, 10856, 10898, 10898, 10964], [10966, 10966, 11005, 11005, 11039], [11148, 11148, 11261, 11261, 11608], [11610, 11629, 11690, 11690, 13400]], "test": "error"}
{"id": "4sB3Dc", "name": "Fractal sphere", "author": "guil", "description": "Rendering of a kleinian fractal using the \"raymarching inside a sphere technique\" from IQ's Weird Thing : https://www.shadertoy.com/view/XsB3Wc", "tags": ["3d", "fractal", "kleinian"], "likes": 41, "viewed": 1264, "published": "Public", "date": "1394136771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Based on Weird Thing by inigo quilez : https://www.shadertoy.com/view/XsB3Wc\n\n\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nconst int MaxIter = 12;\nvec3 sundir = vec3(0.0,0.5,-1.0);\nfloat g=.8;\nfloat h=1.;\n\n\n\nvec4 map( vec3 p)\n{\n\tfloat dr = 1.0;\n\tvec3 ot = vec3(1000.0); \n\tfloat r2;\n\tfor( int i=0; i<MaxIter;i++ )\n\t{\n            \n        r2 = dot(p,p);\n        if(r2>100.)continue;\n\t\t\n        ot = min( ot, abs(p) );\n\n\n\t\tfloat k = max(h/r2,1.)*g;\n\t\tp  *= k;\n\t\tdr *= k;\n\t\tp=abs(p-0.5)-1.;\t\t\n\t\t\n\t}\n\t\n\tfloat d;\n\t//d = (abs(p.x)+abs(p.y))*length(p)/dr;\t\n\t//d = (length(p.xz)*abs(p.y)+length(p.xy)*abs(p.z)+length(p.yz)*abs(p.x))/dr;\n\t//d = 1.5*(length(p.xz))*length(p.xy)/dr;\n\t//d = 1.*length(p)*log(length(p))/dr;\n\t//d =1.*length(p)/dr;\n    d=abs(p.x)/dr;\n\treturn vec4(ot,d);\n\t\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd , in vec2 tminmax )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\tfloat t = tminmax.x;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.a > 0.99 || t>tminmax.y ) continue;\n\n\t\tvec3 pos = ro + t*rd;\t\t\n\t\tvec4 col = map( pos );\n\t\tfloat d = col.a;\n\t\tcol.a = min(0.002/d,1.);\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\n        t += min(0.1,d*.3);\t\n                \t\t\n\t}\n\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float an = 2.0 + 0.2*iTime - mo.x;\n\n\tvec3 ro = 2.0*vec3(cos(an), 0.17, sin(an));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\tvec3 col = vec3(0.08,0.09,0.18);\n    vec2 seg = iSphere( ro, rd, vec4(0.0,0.0,0.0,1.0) );\n\tif( seg.x>0.0 )\n\t{\n        vec4 res = raymarch( ro, rd, seg );\n\t    col = mix( col, res.xyz, res.w );\n\t}\n\t\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), -0.1 );\n\t\n\tcol = pow( col, vec3(0.45) ) * 1.2;\n\n\tcol *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sB3Dc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1, 171, 224, 224, 410], [497, 497, 516, 516, 1064], [1066, 1066, 1125, 1125, 1518], [1521, 1521, 1578, 1578, 2419]], "test": "ok"}
{"id": "4sB3Dt", "name": "Interpolated KIFS", "author": "andyalias", "description": "Inter-iteration interpolation (try saying that 3 times fast) of a Kaleidoscopic IFS fractal. I think it kind of resembles cell division.\n\nPress the left mouse button to see how it looks without interpolation.", "tags": ["animation", "kifs", "interpolation"], "likes": 30, "viewed": 1090, "published": "Public", "date": "1395027593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Andrew Caudwell 2014\n// @acaudwell\n\n#define MAX_RAY_STEPS 100\n#define PI 3.14159265359\n\n#define DEGREES_TO_RADIANS 0.017453292\n\n#define KIFS_ITERATIONS 12\n\nstruct KIFS {\n    vec3  offset;\n    float scale;\n    vec3  axis;\n    float angle;\n    mat4  transform;\n};\n\nKIFS KIFS_constructor(vec3 offset, vec3 axis, float angle, float scale) {\n        KIFS kifs;\n        kifs.offset = offset;\n        kifs.axis   = axis;\n        kifs.angle  = angle;\n        kifs.scale  = scale;\n        \n        return kifs;\n}\n\nmat4 calc_transform(inout KIFS kifs) {\n    float angle = kifs.angle * DEGREES_TO_RADIANS;\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 t = (1.0-c) * kifs.axis;\n\n    return mat4(\n        vec4(c + t.x * kifs.axis.x, t.y * kifs.axis.x - s * kifs.axis.z, t.z * kifs.axis.x + s * kifs.axis.y, 0.0) * kifs.scale,\n        vec4(t.x * kifs.axis.y + s * kifs.axis.z, (c + t.y * kifs.axis.y), t.z * kifs.axis.y - s * kifs.axis.x, 0.0) * kifs.scale,\n        vec4(t.x * kifs.axis.z - s * kifs.axis.y, t.y * kifs.axis.z + s * kifs.axis.x, c + t.z * kifs.axis.z, 0.0) * kifs.scale,\n        vec4(kifs.offset, 1.0)\n    );\n}\n\n#define t iTime*0.6\n\nint stage_no;\nfloat stage_t;\n\nKIFS kifs_N;\nKIFS kifs_lerp;\n\nvoid InitIFS() {\n        \n    if(stage_no >= KIFS_ITERATIONS) {\n        stage_no = KIFS_ITERATIONS-(stage_no-KIFS_ITERATIONS)-1;\n        stage_t  = 1.0-stage_t;\n    }\n        \n    // KIFS to visualize\n    kifs_N = KIFS_constructor(vec3(-1.5), normalize(vec3(-1.0)), -36.0, 1.5);\n\n    kifs_lerp.axis   = kifs_N.axis;\n    kifs_lerp.angle  = kifs_N.angle;\n\n    // interpolate scale and position offset\n    kifs_lerp.offset =kifs_N.offset * stage_t;\n    kifs_lerp.scale  = 1.0 + (kifs_N.scale-1.0) * stage_t;\n\n    // left mouse button disables interpolation\n    if(iMouse.z>0.0) {\n        kifs_lerp =kifs_N;\n    }\n        \n    kifs_N.transform    = calc_transform(kifs_N);\n    kifs_lerp.transform = calc_transform(kifs_lerp);\n}\n\n// The definitive Fractal Forums thread about this class of fractals:\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-%28escape-time-ifs%29/\n\nfloat scene(vec3 p) {\n\n    KIFS kifs = kifs_N;\n\n    float scale = 1.0;\n\n    for(int i=0;i<KIFS_ITERATIONS;i++) {\n\n        if(i==stage_no)kifs =kifs_lerp;\n        else if(i>stage_no) break;\n\n        // mirror on 2 axis to get a tree shape\n        p.xy = abs(p.xy);\n\n        // apply transform\n        p = (kifs.transform * vec4(p, 1.0)).xyz;\n\n        scale *=kifs.scale;\n    }\n\n    // divide by scale preserve correct distance\n    return (length(p)-2.0) / scale;\n}\n\nvec3 normal(vec3 p) {\n\n    vec2 o = vec2(0.001,0.0);\n\n    float d = scene(p);\n\n    float d1 = d-scene(p+o.xyy);\n    float d2 = d-scene(p+o.yxy);\n    float d3 = d-scene(p+o.yyx);\n\n    return normalize(vec3(d1,d2,d3));\n}\n\nfloat AO(vec3 p, vec3 normal) {\n\n    float a = 1.0;\n\n    float c = 0.0;\n    float s = 0.25;\n\n    for(int i=0; i<3; i++) {\n        c += s;\n        a *= 1.0-max(0.0, (c -scene(p + normal*c)) * s / c);\n    }\n\n    return clamp(a,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        \n    stage_no  = int(fract(t/float(KIFS_ITERATIONS*2)) * float(KIFS_ITERATIONS*2));\n    stage_t = smoothstep(0.0, 1.0, fract(t));\n    \n    InitIFS();\n        \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n    vec3 dir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), 1.0));\n\n    vec3 p = vec3(0.0,0.0,-4.1);\n\n    float d = 0.0;\n\n    for(int i=0; i<MAX_RAY_STEPS; i++) {\n        d = scene(p);\n        p += d * dir;\n        if(d<0.001) break;\n    }\n\n    vec3 c = vec3(0.0);\n        \n    if(d<0.001) {\n        vec3 l = vec3(-3.0, 3.0, -3.0);\n\n        vec3 n = -normal(p-dir*0.001);\n\n        c = vec3(0.4);\n\n        c += 1.5 * (max(0.0, dot(n, normalize(l-p)))/length(l-p));\n\n        c *= AO(p, 0.5*(n+normalize(n+l)));\n    }\n        \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sB3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 266, 339, 339, 506], [508, 508, 546, 546, 1132], [1215, 1215, 1231, 1231, 1938], [1940, 2110, 2131, 2131, 2573], [2575, 2575, 2596, 2596, 2793], [2795, 2795, 2826, 2826, 3031], [3033, 3033, 3090, 3090, 3886]], "test": "ok"}
{"id": "4sfXRn", "name": "Mandelfriend", "author": "cedric", "description": "The mandelbulb has a friend now.", "tags": ["procedural", "fractal", "mandelbulb"], "likes": 6, "viewed": 526, "published": "Public", "date": "1395555310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mandelbulb shader by cedric voisin 2014\n\t\n// tuning\n#define nIterMax 6\n#define rSat .05 \n#define rLight 1.4 \n// relative base intensities (can take any value >0)\n#define iSpec 3.\n#define iTrap 1.5\n#define iShad 10.\n#define iAO 1.\n\nfloat nMandelB; // nMandelB=8 for the usual bulb\nvec3 colMb=.8*vec3(1.,1.,.9); // MB  olor\nvec3 colSat = .8*vec3(1.,1.,.95); // sat color\n\n//\n//vec2 realSize = vec2(2.,2.*iResolution.y/iResolution.x);\n//vec2 po=(fragCoord.xy-iResolution.xy/2.)*realSize/iResolution.xy;\nvec3 col;\nfloat zMin; // smallest distance reached by the orbit of the computed point\nfloat pi=3.14;\nfloat piSur2=1.57;\nbool isSatOnTrajectory, isMbOnTrajectory;\nvec3 ptInterSphere;\n\n// def eye (the MB is fixed, the eye moves around)\nfloat thetaScr;\nfloat phiScr;\nfloat dScr=5.;\t// origin to (center of) screen\nfloat dEye=5.;\t// screen to eye\n\n\n// Screen normal and directions\nvec3 vN;\nvec3 vUp;\nvec3 vRight;\n// Screen position\nvec3 zScr;\n// Eye position\nvec3 zEye;\n\t\t\n\n// Distance Estimator\n// returns 0 if the test point is inside the MB, and the distance 0.5*r*logr/rD otherwise\nfloat DE(vec3 ptTest){\n\tfloat theta,phi,r; // point\n\tfloat newtheta,newphi,newr;\n\tfloat dr;\n\tvec3 z=ptTest; // iterated point\n\tdr=1.;\n\tzMin=1000.;\n\tfor (int i=0;i<nIterMax;i++){\n\t\tr=length(z);\n\t\tif (r>=pow(1.+float(nIterMax),2.)) break;\n\t\tnewr=pow(r,nMandelB);\n\t\tdr=1.+dr*nMandelB*pow(r,nMandelB-1.);\n\t\ttheta=acos(z.z/r);\n\t\tphi=atan(z.y,z.x);\n\t\tnewtheta=theta*nMandelB;\n\t\tnewphi=phi*nMandelB;\n\t\tz=ptTest+newr*vec3(sin(newtheta)*cos(newphi),sin(newtheta)*sin(newphi),cos(newtheta));\n\t\tzMin=min(zMin,length(z));\n\t}\n\treturn(0.5*newr*log(newr)/dr);\n}\n\n// intersection with sphere\nbool sphereInter(vec3 center, float rad, vec3 dir){\n\tvec3 result;\n\tvec3 dirSphere = zEye-center;\n\tfloat B = dot(dir,dirSphere);\n\tfloat C = length(dirSphere)*length(dirSphere)-rad*rad;\n\tfloat det2=B*B-C;\n\tif(det2>=0.){\n\t\tfloat s = min(-B+sqrt(det2),-B-sqrt(det2));\n\t\tptInterSphere = zEye+dir*s;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n// returns the nearest MB point\nvec3 getMbPoint(vec2 ptTest){\n\tvec3 zRes;\n\tvec3 z=zScr+ptTest.x*vRight+ptTest.y*vUp;// position of the tested pixel (on the screen) in space\n\tvec3 dzds=normalize(z-zEye);\n\tisMbOnTrajectory = sphereInter(vec3(0.,0.,0.),2.,dzds);\n\tif (!isMbOnTrajectory) return z+dzds;\n\tfloat maxDist=10.;\n\t\n\tfloat s=0.;\n\tfloat de;\n\t// ray tracing\n\tfor (int i=0;i<100;i++){ // awkward for because webgl forbids non constant loops :-(\n\t\tzRes=z+dzds*s;\n\t\tde=clamp(DE(zRes),0.000001,maxDist);\n\t\tif(de==0.000001) break; // distance estimated is small enough: we are on the MB\n\t\tif(s>dScr+5.) break; // gone to far: we didn't cross the MB\n\t\ts+=.5*de;\n\t}\n\tisMbOnTrajectory=true;\n\tif (s>=dScr+5.) isMbOnTrajectory=false;\n\treturn (zRes);\n}\n\n\n// the light has to follow the eye\nvec3 setLight(){\n\tfloat dthetaLight=pi+-pi/6.*cos(iTime/7.);\n\tfloat dphiLight=iTime/7.;\n\t// light direction\n\tfloat phiLight=phiScr+dphiLight;\n\tfloat thetaLight=thetaScr+dthetaLight;\n\t// light position\n\treturn rLight*vec3(sin(thetaLight)*cos(phiLight),sin(thetaLight)*sin(phiLight),cos(thetaLight));\n}\n\n// normal\nvec3 normal(vec3 ptO){\n\tvec3 dPt=vec3(.01,0.,0.);\n\tvec3 n=normalize(vec3(DE(ptO+dPt.xyy),DE(ptO+dPt.yxy),DE(ptO+dPt.yyx))); \n\treturn n;\n}\n\n// orbit trap coloring\n// proportionnal to the (normalized) smallest distance reached by the orbit of the computed point\nfloat orbitTrap(){\n\tfloat origin=.6; // to tune contrast and depth view\n\treturn (zMin-origin)/(1.-origin);\n}\n\n// specularity (coloration by normal)\nfloat specularity(vec3 n,vec3 vLight){\n\treturn dot(n,normalize(vLight));\n}\n\n// ambiant occlusion\n// compute the distance from MB for nk test points in the normal direction\n// the smaller the distance, the larger the occlusion\nfloat ambiantOcclusion(vec3 ptO,vec3 n){\n\tconst int nk=6;\n\tfloat dt=.05; // small t for constrast, large t for soft shadows\n\tvec3 pTest; // test point\n\tfloat dTest; // test distance (pTest <-> MB)\n\tfloat ao=1.; // AO intensity\n\tfloat ikf,nkf;\n\tfor (int ik=0;ik<nk;ik++){\n\t\tikf = float(ik);\n\t\tnkf = float(nk);\n\t\tpTest=ptO+n*ikf*dt;\n\t\tdTest=DE(pTest);\n\t\tao-=(ikf*dt-dTest);\n\t}\n\treturn ao;\n}\n\n// shadows\n// try some points on the light line. The more points inside the MB, the darkest the shadow.\nfloat shadows(vec3 ptO,vec3 vLight){\n\tfloat L=length(vLight-ptO);\n\tvec3 dzds=normalize(vLight-ptO);\n\tfloat nbInMB=0.;\n\tconst int nbPtTestInt=100; // number of test points on the line\n\tfloat nbPtTest=float(nbPtTestInt);\t\n\tfloat s=0.;\n\tfor (int i=0;i<nbPtTestInt;i++){\n\t\tif(DE(ptO+dzds*s)<0.01) nbInMB++;\n\t\ts+=L/nbPtTest;\n\t}\n\treturn 1.-nbInMB/nbPtTest;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    \n    // constants\n    nMandelB=4.+2.*cos(.01*iTime+1.57);\n    thetaScr=piSur2;\n    phiScr=-iTime/47.;\n    vN=-vec3(sin(thetaScr)*cos(phiScr),sin(thetaScr)*sin(phiScr),cos(thetaScr));\n\tvUp=normalize(dScr*vec3(sin(thetaScr-piSur2)*cos(phiScr),sin(thetaScr-piSur2)*sin(phiScr),cos(thetaScr-piSur2)));\n\tvRight = cross(vN,vUp);\n\tzScr=-dScr*vN;\n\tzEye=-(dScr+dEye)*vN;\n    //\n    \n\tvec2 poNoScale=-1.+2.*fragCoord.xy/iResolution.xy;\n\tvec2 poScale=poNoScale*vec2(1.,iResolution.y/iResolution.x);\n\tvec3 vLight=setLight();\n\tvec3 ptMb=getMbPoint(poScale);\n\tisSatOnTrajectory = sphereInter(vLight, rSat, normalize(ptMb-zEye));\n\tvec3 ptSat= ptInterSphere;\n\tbool satFirst;\n\tvec3 n,obj;\n\t\n\tif (!isMbOnTrajectory) satFirst=true;\n\tif (!isSatOnTrajectory) satFirst=false;\n\tif (isMbOnTrajectory && isSatOnTrajectory){\n\t\tif(length(ptSat-zEye)<length(ptMb-zEye)) {satFirst=true;} else {satFirst=false;}\n\t}\n\t\t\n\tif(isMbOnTrajectory || isSatOnTrajectory) {\n\t\tif (satFirst){\n\t\t\tfloat intSat=clamp((1.+dot(normalize(ptSat-vLight),-normalize(vLight)))/2.,0.,1.);\n\t\t\tcol = intSat*colSat;\n\t\t} else {\n\t\t\tn = normal(ptMb);\n\t\t\t// coefficients for intensities (0<c<1)\n\t\t\tfloat cTrap = orbitTrap();\n\t\t\tfloat cSpec = specularity(n,vLight);\n\t\t\tfloat cAO = ambiantOcclusion(ptMb,n);\n\t\t\tfloat cShad = shadows(ptMb,vLight);\n\n\t\t\t// Average intensity (weighted with computed coefs)\n\t\t\tfloat Intensity=clamp((cSpec*iSpec+cAO*iAO+cTrap*iTrap+cShad*iShad)/(iSpec+iTrap+iShad+iAO),0.,1.);\n\t\t\tcol = Intensity*Intensity*colMb.xyz;\n\t\t}\n\t}\n\t\n\tif(!isMbOnTrajectory && !isSatOnTrajectory){// background\n\t\tfloat bgInt=clamp(1.-length(fragCoord.xy-iResolution.xy/2.)/length(iResolution.xy),0.,1.);\n\t\tcol = .95*bgInt*vec3(1.,1.,1.);\n\t}\n\tfragColor= vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[973, 1085, 1107, 1107, 1631], [1633, 1661, 1712, 1712, 2000], [2002, 2034, 2063, 2063, 2746], [2749, 2784, 2800, 2800, 3084], [3086, 3096, 3118, 3118, 3233], [3235, 3356, 3374, 3374, 3464], [3466, 3504, 3542, 3542, 3578], [3580, 3730, 3770, 3770, 4118], [4120, 4224, 4260, 4260, 4576], [4578, 4578, 4635, 4658, 6350]], "test": "ok"}
{"id": "4sj3Wd", "name": "[SH2014] Simplex + Fractal", "author": "cabbibo", "description": "audio defining simplex  defining fractal", "tags": ["2d", "simplexnoise", "kalifractal"], "likes": 6, "viewed": 294, "published": "Public", "date": "1395284498", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// KALI FRACTAL\nvec3 kali( vec3 v , vec3 s ){\n\tfloat m = 0.0;\n\tfor( int i = 0; i < 10 ; i ++){\n\tv.x = abs(v.x);\n\tv.y = abs(v.y); \n\tv.z = abs(v.z);\n\tm = v.x * v.x + v.y * v.y + v.z * v.z;\n\tv.x = v.x / m + s.x;\n\tv.y = v.y / m + s.y;\n\tv.z = v.z / m + s.z;\n    }\n\treturn v;\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat ar = iResolution.x/iResolution.y;\n\t\n\tvec4 audio = texture( iChannel0 , uv );\n\tuv = audio.xy * .01 + uv;\n\n\tfloat noise = snoise( ar * vec3( uv.x * 10. , uv.y * 10. , 10.+10.*sin(iTime * .087) ));\n\tfloat noise2 = snoise( ar * vec3( uv.x * 2. , uv.y * 2. , 2.+2.*sin(iTime * .065) ));\n\tfloat noise1 = snoise( ar * vec3( uv.x * 5. , uv.y * 5. , 5.+5.*sin(iTime * .03) ));\n\tfloat noise3 = snoise( ar * vec3( uv.x * 20. , uv.y * 20. , 20.+20.*sin(iTime * .042) ));\n\t/*\n\tfloat noise = snoise( ar * vec3( uv.x * 10. , uv.y * 10. , 10.+10.*sin(iTime * .1) ));\n\tfloat noise2 = snoise( ar * vec3( uv.x * 2. , uv.y * 2. , 2.+2.*sin(iTime * .1) ));\n\tfloat noise1 = snoise( ar * vec3( uv.x * 5. , uv.y * 5. , 5.+5.*sin(iTime * .1) ));\n\tfloat noise3 = snoise( ar * vec3( uv.x * 20. , uv.y * 20. , 20.+20.*sin(iTime * .1) ));\n\t*/\n\tvec3 kali1 = kali( vec3( -uv.x , -uv.y , - .5+.5*sin(iTime )) , vec3( -abs( uv.y )  , -abs( noise1 ) , -abs(noise2 ) ) );\n\tvec3 kali2 = kali( vec3( -uv.x , -uv.y , - .5+.5*sin(iTime )) , vec3( -abs( uv.x )  , -abs( noise2 ) , -abs(noise ) ) );\n\n\tfragColor = vec4( normalize( kali1 + kali2  ),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sj3Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 16, 45, 45, 271], [275, 669, 690, 690, 739], [741, 741, 762, 762, 811], [813, 813, 835, 835, 875], [877, 877, 905, 905, 957], [959, 959, 983, 983, 3127], [3130, 3130, 3187, 3187, 4353]], "test": "ok"}
{"id": "4sj3WK", "name": "Study 9: Box-Ray Intersection", "author": "vug", "description": "A visually unpleasant study of box-ray intersection using analytical geometric methods, instead of ray marching (which I didn't learn yet). ", "tags": ["3d", "raytracer"], "likes": 8, "viewed": 2748, "published": "Public", "date": "1393633372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * This study includes\n *\n * 1) findUV: a function that finds two orthogonal vectors, given a \n * normal vector. The normal vector has to be given in spherical\n * coordinates, (theta, phi). findUV calculates an orthonormal\n * local coordinate system (n, u, v). This can be used in texture\n * mapping a plane, or orienting the camera.\n *\n * 2) iPlane2: Ray-plane intersection method. Its parameters are (besides\n * the ray parameters) the normal and the distance from the origin\n * of the plane.\n *\n * 3) checkerBoard3: An anti-aliased checker board pattern generator,\n * it does not need that (u,v) to be in [0,1]. they can go to infinity,\n * the pattern will repeat inifinitely.\n * It does work for closeby checker cells, but distant ones still\n * produce Moire patterns.\n *\n * 4) iBox: A box-ray intersection function. It is different than\n * the \"axis-aligned box\" method. It first defines 3 arbitrary normals.\n * (if these planes are orthogonal to each other, than we'll get a\n * rectangular box) For each normal, it defines two parallel planes on which\n * the sides of the box will lie.\n * The Kay-Kasia algorithm is applied to 3 slabs and the intersection\n * position and normal at the intersection are returned.\n *\n * 5) intersect: deals with whether we hit nothing, the ground plane or\n * the cube.\n *\n * 6) A camera implementation. the camera direction is given in spherical\n * coordinates. and u and v vectors on the camera plane are found\n * via findUV. Then, rays are sent with the formula:\n * normalize(sX * cU + sY * cV + FOV*cDir);\n * sX, sY: screen coordinates, cU,cV: camera UV. cDir: given direction.\n * The FOV parameter came for free. :-)\n * \n */\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 light = normalize( vec3(0.57703) );\nvec4 plane;\nvec4 sph1;\n\n\n// given spherical coordinates (theta, phi) of a normal vector (OR longitude and latitude)\n// find the normal vector, and two vectors that are perpendicular to it (and each other)\n// that lie on the plane defined by the normal vector\nvoid findUV(in float th, in float ph, out vec3 dir, out vec3 u, out vec3 v) {\n\tdir = vec3(sin(th)*cos(ph), cos(th), sin(th)*sin(ph));\n\t// Second direction, V of the plane, is PI/2 upwards towards the north pole\n\tfloat thV, phV;\n\tif(th < 0.5*PI) {\n\t\tthV = 0.5*PI - th;\n\t\tphV = mod(ph + PI, TWO_PI);\n\t} else {\n\t\tthV = th - 0.5*PI;\n\t\tphV = ph;\n\t}\n\tv = vec3(sin(thV)*cos(phV), cos(thV), sin(thV)*sin(phV));\n\t// Third direction, U of plane, is perpendicular to both\n\tu = cross(dir, v);\n}\n\n// the bad example from IQ's article, Haha!\n// http://www.iquilezles.org/www/articles/noacos/noacos.htm\nmat3 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c );\n}\n\n// assumes (u,v) in [0,1]. Divides the ares into nTile x nTile squares.\nvec3 checkerBoard(vec2 uv, float nTile) {\n\tvec3 color1 = vec3(1.0, 1.0, 1.0);\n\tvec3 color2 = vec3(0.0, 0.0, 0.0);\n\tfloat side = 1.0/nTile;\n\tfloat c1 = mod(uv.x, 2.0 * side);\n\tc1 = step(side, c1);\n\tfloat c2 = mod(uv.y, 2.0 * side);\n\tc2 = step(side, c2);\t\n\tvec3 color = mix(color1, color2, mod(c1+c2,2.0));\n\treturn color;\n}\n\n\n// infinite area, tiles of size \"side\"\nfloat stripe(float x, float side, float smth) {\n\tx = mod(x, 2.0*side);\n\treturn smoothstep(0.0 - smth, 0.0 + smth, -x)\n         + smoothstep(1.0*side - smth, 1.0*side + smth, x)\n         - smoothstep(2.0*side - smth, 2.0*side + smth, x);\n}\nfloat checkerBoard3(vec2 uv, float side, float smth) {\n\t//smooth *= length(1.0*uv);\n\tfloat xStripes = stripe(uv.x, side, smth);\n\tfloat yStripes = stripe(uv.y, side, smth);\n\tfloat checker = abs(xStripes+yStripes-1.0);\n\treturn checker;\n}\n\n\nfloat iPlane2(vec3 o, vec3 d, vec4 plane) { // ray Origin, ray Direction\n\tvec3 n = plane.xyz;\n\tfloat dist = -plane.w;\n\tfloat denom = dot(n, d);\n\n\treturn - (dot(n, o)+dist)/denom;\n}\nvec3 nPlane2(vec3 pos) {\n\treturn plane.xyz;\n}\n\nvoid swap(inout float x, inout float y) {\n\tif(x>y) {\n\t\tfloat temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t}\t\t\n}\n\nfloat iBox(vec3 o, vec3 d, vec3 center, vec3 sides, out vec3 normal) {\n\tvec3 axis = normalize(vec3(1.0, 1.0, 0.0));\n\tmat3 rot = rotationAxisAngle(axis, PI/2.);\n\tvec3 xn = rot*vec3(1.0, 0.0, 0.0);\n\tvec3 yn = rot*vec3(0.0, 1.0, 0.0);\n\tvec3 zn = rot*vec3(0.0, 0.0, 1.0);\n\taxis = normalize(vec3(0.0, 1.0, 0.0));\n\trot = rotationAxisAngle(axis, iTime);\n\txn = rot*xn;\n\tyn = rot*yn;\n\tzn = rot*zn;\t\n\tfloat t1, t2;\n\tfloat tNear = -10000.0;\n\tfloat tFar = 10000.0;\n\t\n\to = o - center; // translation\n\t\n\t// x -> yz-plane\n\tt1 = iPlane2(o, d, vec4(xn, -0.5*sides.x));\n\tt2 = iPlane2(o, d, vec4(xn, 0.5*sides.x));\n\tif(t1>t2) swap(t1, t2);\n\tif(t1 > tNear) { normal = xn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar || tFar < 0.0) return -1.0;\n\t\n\t// y -> xz-plane\n\tt1 = iPlane2(o, d, vec4(yn, -0.5*sides.y));\n\tt2 = iPlane2(o, d, vec4(yn, 0.5*sides.y));\t\n\tif(t1>t2) swap(t1, t2);\n\tif(t1 > tNear) { normal = yn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar || tFar < 0.0) return -1.0;\n\t\n\t// z -> xy-plane\n\tt1 = iPlane2(o, d, vec4(zn, -0.5*sides.z));\n\tt2 = iPlane2(o, d, vec4(zn, 0.5*sides.z));\t\n\tif(t1>t2) swap(t1, t2);\n\tif(t1 > tNear) { normal = zn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar || tFar < 0.0) return -1.0;\n\t\n\treturn tNear;\n}\n\nint intersect( in vec3 ro, in vec3 rd, out float resT, out vec3 normal ){\n\tresT = 1000.0;\n\tint id = -1;\n\tsph1 = vec4(0.0, -1.5, 00.0, 2.0);\n\tfloat tpla2 = iPlane2(ro, rd, plane);\n\t\n\tvec3 boxCenter = vec3(0.0, 4.0, 0.0);\n\tvec3 boxSides = vec3(2.0, 2.0+0.2*sin(iTime*20.), 2.0)*2.0;\n\tfloat tCube = iBox(ro, rd, boxCenter, boxSides, normal);\n\tif( tpla2 > 0.0 && tpla2 < resT ) {\n\t\tid = 3;\n\t\tresT = tpla2;\n\t}\n\tif( tCube > 0.0 && tCube < resT ) {\n\t\tid = 4;\n\t\tresT = tCube;\n\t}\n\t\n\t//float t = min(tsph, tpla);\n\treturn id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.yx;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Camera (My own attempt of preparing a camera. Use at your own risk!)\n\tvec3 ro = vec3( 0.0, 4.0, 10.0); // origin\n\tfloat cTheta = 0.55*PI; // polar theta of direction\n\tfloat cPhi = 0.2*PI*sin(iTime)-0.5*PI; // polar phi of direaction\n\tfloat cAlpha = 0.1*PI*cos(iTime); // tilt\n\tfloat FOV = 1.5; // smaller number wider view and vice versa.\n\t// direct the camera at given latitude and longitude\n\tvec3 cDir, cU, cV;\n\tfindUV(cTheta, cPhi, cDir, cU, cV);\t\n\t// Tilt the camera\n\tmat3 tilt = rotationAxisAngle(cDir, cAlpha);\n\tcU = tilt*cU; // just rotate camera U and V. Yay, tt works!\n\tcV = tilt*cV;\t\n\tvec2 scan = (-1.0+2.0*uv)*vec2(1.78, 1.0); // magical numbers\n\tvec3 rd = normalize(scan.x * cU + scan.y * cV + FOV*cDir);\n\t//vec3 rd = normalize(vec3( (-1.0+2.0*uv)*vec2(1.78, 1.0), -1.0));\t\n\t\n\t// ground\n\tfloat pTheta = 0.0*PI;\n\tfloat pPhi = 0.3*PI;\n\tvec3 pNorm, pU, pV;\n\tfindUV(pTheta, pPhi, pNorm, pU, pV);\n\tplane = vec4(pNorm, 0.0);\n\t\n\t// send rays to detect intersections with objects\n\tfloat t;\n\tvec3 normal;\n\t// intersect will return the object type \"id\"\n\t// and set the ray parameter \"t\" and normal at the intersection point\n\tint id = intersect(ro, rd, t, normal);\n\n\tvec3 bgCol = vec3(244., 198., 61.)/255.;\n\tvec3 col = bgCol;\n\t// hit id\n\tvec3 pos = ro + t*rd;\n\tif(id == 3) { // hit the floor\n\t\tvec3 nor = nPlane2( pos );\t\t\n\t\tfloat dif = clamp( dot(nor, light), 0.0, 1.0);\n\t\tfloat amb = 0.2;\n\t\t// find uv on the plane at the intersection\n\t\tvec3 projection = pos - dot(pos,nor)*nor;\n\t\tfloat u = dot(projection, pU);\n\t\tfloat v = dot(projection, pV);\n\t\tfloat side = 2.0;\n\t\t//vec3 texture = checkerBoard2( vec2(u, v), side );\n\t\tvec3 color1 = vec3(4., 105., 103.)/255.;\n\t\tvec3 color2 = vec3(234., 229., 206.)/255.;\n\t\tvec3 aveColor = mix(color1, color2, 0.5);\n\t\tfloat mixVal = checkerBoard3( vec2(u, v), side, 0.02*side );\n\t\tvec3 texture = mix(color1, color2, mixVal);\n\t\tfloat distVal = clamp(exp(-0.0005*t*t),0.0,0.99);\n\t\tvec3 fadedToAverage = mix(aveColor, texture, distVal*distVal);\n\t\t//vec3 texture = vec3( checkerBoard3( vec2(u, v), side, 0.5*side ) );\n\t\t//col = mix(texture*dif,bgCol, 0.001*t); // fade to background color\n\t\t//col = texture*dif;\n\t\tcol = fadedToAverage*dif;\n\t} else if(id == 4) { // hit the box\n\t\tfloat dif = clamp( abs(dot(normal, light)), 0.0, 1.0);\n\t\tvec3 boxColor = vec3(215., 2., 6.)/255.;\n\t\tcol = boxColor*dif;\n\t}\n\tcol = sqrt(col*1.5);\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sj3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1792, 2026, 2103, 2103, 2508], [2510, 2614, 2661, 2661, 2973], [2975, 3047, 3088, 3088, 3368], [3371, 3410, 3457, 3457, 3648], [3649, 3649, 3703, 3732, 3884], [3887, 3887, 3930, 3959, 4067], [4068, 4068, 4092, 4092, 4113], [4115, 4115, 4156, 4156, 4213], [4215, 4215, 4285, 4285, 5472], [5474, 5474, 5547, 5547, 5990], [5992, 5992, 6049, 6049, 8527]], "test": "ok"}
{"id": "4sS3Dc", "name": "HSL ColorSpace", "author": "bloxard", "description": "I needed to investigate and understand the HSL colorspace for a computer-vision image filter and I thought to myself 'How can I visualize this quickly?' and then this shader just sort of happened. :)", "tags": ["plasma", "hsl", "colorspectrum"], "likes": 28, "viewed": 1939, "published": "Public", "date": "1394131615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Per Bloksgaard/2014\n\n#define PI 3.14159265358979\n\n// Convert HSL colorspace to RGB. http://en.wikipedia.org/wiki/HSL_and_HSV\nvec3 HSLtoRGB(in vec3 c)\n{\n\tvec3 rgb = clamp(abs(mod(c.x+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n\treturn c.z+c.y*(rgb-0.5)*(1.-abs(2.*c.z-1.));\n}\n\nvec3 HSL2RGB_CubicSmooth(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb*rgb*(3.0-2.0*rgb); // iq's cubic smoothing.\n    return c.z+ c.y*(rgb-0.5)*(1.-abs(2.*c.z-1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n\tfloat fAngle = iTime*0.4;\n\tfloat h = atan(uv.x,uv.y) - fAngle;\n\tfloat x = length(uv);\n\tfloat a = -(0.6+0.2*sin(iTime*3.1+sin((iTime*0.8+h*2.0)*3.0))*sin(iTime+h));\n\tfloat b = -(0.8+0.3*sin(iTime*1.7+sin((iTime+h*4.0))));\n\tfloat c = 1.25+sin((iTime+sin((iTime+h)*3.0))*1.3)*0.15;\n\tfloat l = a*x*x + b*x + c;\n\t//vec3 hsl_standard = HSLtoRGB(vec3(h*3./PI,1.,l));\n\tvec3 hsl_cubic = HSL2RGB_CubicSmooth(vec3(h*3.0/PI,1.,l));\n\tfragColor = vec4(hsl_cubic,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sS3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 139, 165, 165, 278], [280, 280, 317, 317, 495], [497, 497, 554, 554, 1077]], "test": "ok"}
{"id": "4sS3RV", "name": "Voronoi Fireball", "author": "Dave_Hoskins", "description": "Experiment using a 3D Voronoi distance field.", "tags": ["voronoi", "voronoifireball"], "likes": 21, "viewed": 2548, "published": "Public API", "date": "1394307526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Voronoi Fireball\n// By David Hoskins\n\nfloat gTime = 0.0;\n\n//----------------------------------------------------------------------\nvec2 Rotate2D(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si) * p;\n}\n\n//----------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//--------------------------------------------------------------------------\nfloat Voronoi(in vec3 p)\n{\n\tfloat d = 1.0e10;\n\tfor (int zo = -1; zo <= 1; zo++)\n\t{\n\t\tfor (int xo = -1; xo <= 1; xo++)\n\t\t{\n\t\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t\t{\n\t\t\t\tvec3 tp = floor(p) + vec3(xo, yo, zo);\n\t\t\t\td = min(d, length(p - tp - Noise(p)));\n\t\t\t}\n\t\t}\n\t}\n\treturn .72 - d*d*d;\n}\n\n//--------------------------------------------------------------------------\nvec3 FlameColour(float f)\n{\n\tif (f > .999999) return vec3(1.0);\n\treturn  min(vec3(f*5.0, f*f, f*f*.05), 1.0);\n}\n\n//--------------------------------------------------------------------------\nvec4 Map(in vec3 p)\n{\n\tvec3 col = vec3(0.0);\n\tfloat di = length(p)-8.0;\n\n\tif (di > 0.0)\n\t{\n\t\tdi -= Noise(p * 1.5 + vec3(0.0, 0.0, gTime * 1.5)) * 8.0 + cos(gTime * .5) * 4.0 + 6.0;\n\t\t\n\t\tvec3 loops = p + vec3(0.0, 0.0, gTime * 5.0);\n\t\tloops.xy = Rotate2D(loops.xy, di * .15 - gTime * .15);\n\t\t\n\t\tfloat h = Voronoi(loops * .2);\n\t\tdi = di + pow(h, 12.0)*500.0;\n\t\tcol = FlameColour(clamp(-di*.13, 0.0, 1.0));\n\t}else\n\t{\n\t\tcol = vec3(1.0);\n\t\tdi *= 20.0;\n\t}\n\treturn vec4(col, -di*.006);\n}\n\n//--------------------------------------------------------------------------\nvec3 Scene(in vec3 rO, in vec3 rD)\n{\n    float t = 10.0;\n\tvec3 p = vec3(0.0);\n\tvec4 sum = vec4(0.0);\n\tfor( int j=0; j < 80; j++ )\n\t{\n\t\tif (sum.a >= 1.0) break;\n\t\tp = rO + t*rD;\n\t\tvec4 res = Map(p);\n\n\t\tres.rgb *= res.a;\n\t\tsum = sum + res * (1.0 - sum.a);\t\n\t\t\n\t\tt += 0.15;\n\t}\n\treturn clamp(sum.xyz, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tgTime = iTime+11.0;\n\tvec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tvec3 cameraPos = vec3(0.0, 0.0, -25.0);\n\t//cameraPos.xz = Rotate2D(cameraPos.xz, gTime*.5); // ...Rotate camera if you want\n\n\tvec3 cw = normalize(-cameraPos); \t// Look at 0,0,0 target\n\tvec3 cp = vec3(0.0, 1.0,0.0);\t\t// Y vector\n\tvec3 cu = cross(cw,cp);\t\t\t\t// X vector\n\tvec3 dir = normalize(uv.x*cu + uv.y*cp + 1.3*cw);\n\tvec3 col = Scene(cameraPos, dir);\n\n\tfragColor=vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sS3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 134, 166, 166, 243], [245, 318, 344, 344, 553], [555, 632, 658, 658, 915], [917, 994, 1021, 1021, 1105], [1107, 1184, 1205, 1205, 1664], [1666, 1743, 1779, 1779, 2052], [2054, 2131, 2188, 2188, 2692]], "test": "ok"}
{"id": "4sS3WV", "name": "Infinite KIFS Zoom", "author": "andyalias", "description": "Infinite zoom into a Kaleidoscopic IFS fractal... Or is it?", "tags": ["zoom", "kifs"], "likes": 50, "viewed": 2373, "published": "Public", "date": "1395051946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Andrew Caudwell 2014\n// @acaudwell\n\n#define MAX_RAY_STEPS 48\n#define KIFS_ITERATIONS 16\n\n// uncomment to see how it works ...\n//#define DEBUG\n\n// enable ray sphere intersection test\n#define INTERSECTION_TEST\n\n#define COLOUR vec3(0.55, 1.15, 0.5)\n\n#ifdef DEBUG\nvec3 col1 = vec3(1.0, 0.0, 0.0);\nvec3 col2 = vec3(0.0, 1.0, 0.0);\nvec3 col3 = vec3(0.0, 0.0, 1.0);\nvec3 col4 = vec3(1.0, 0.0, 1.0);\nvec3 col5 = vec3(0.0, 1.0, 1.0);\n#else\nvec3 col  = COLOUR;\nvec3 col1 = COLOUR;\nvec3 col2 = COLOUR;\nvec3 col3 = COLOUR;\nvec3 col4 = COLOUR;\nvec3 col5 = COLOUR;\n#endif\n\nmat4 calc_transform(vec3 offset, vec3 axis, float angle, float scale) {\n\n    angle *= radians(1.0);\n\t\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 t = (1.0-c) * axis;\n\n    return mat4(\n        vec4(c + t.x * axis.x, t.y * axis.x - s * axis.z, t.z * axis.x + s * axis.y, 0.0) * scale,\n        vec4(t.x * axis.y + s * axis.z, (c + t.y * axis.y),          t.z * axis.y - s * axis.x, 0.0) * scale,\n        vec4(t.x * axis.z - s * axis.y, t.y * axis.z + s * axis.x, c + t.z * axis.z, 0.0) * scale,\n        vec4(offset, 1.0)\n    );\n}\n\nmat4 M;\n\nfloat KIFS(vec3 p, float s) {\n        \n\tp /= s;\n\t\n\tfor(int i=0;i<KIFS_ITERATIONS;i++) {\n\t\t\n\t\tp = abs(p);\n\t\t\n\t\t// apply transform\n\t\tp = (M * vec4(p, 1.0)).xyz;                             \n\t}\n\t\n\t// divide by scale preserve correct distance\n\treturn ((length(p)-1.0) * (pow(1.5, -float(KIFS_ITERATIONS))))*s;\n}\n\nvec3 dir;\n\nbool intersect(vec3 p, float r) {\n\n    float b = 2.0 * dot(dir, p);\n    float c = dot(p, p) - r*r;\n\n    float sq = sqrt(b*b - 4.0*c);\n\n    float t1 = (-b + sq) * 0.5;\n    float t2 = (-b - sq) * 0.5;\n\n    float near = min(t1, t2);\n    float far  = max(t1, t2);\n\n    return near < far && far > 0.0;\n}\n\n\nvoid combineKIFS(vec3 p, float s, vec3 c, inout vec4 o) {\n\n#ifdef INTERSECTION_TEST\n    if(intersect(p, s*1.75)) {\n#endif\n\t\tfloat d = KIFS(p,s);\n\t\tif(d<o.x) o = vec4(d,c);\n#ifdef INTERSECTION_TEST\n\t}\n#endif\n}\n\n#define SF 0.2\n\nvec3 sp = normalize(vec3(1.0,1.0,-1.0));\n\nvec4 scene(vec3 p) {\n\t\n\tvec3 p2 = p - (sp + sp*SF);\n\tvec3 p3 = p - (sp + sp*SF*2.0 + sp*SF*SF);\n\tvec3 p4 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF);\n\tvec3 p5 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF*2.0 + sp*SF*SF*SF*SF);\n\tvec3 p6 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF*2.0 + sp*SF*SF*SF*SF*2.0 + sp*SF*SF*SF*SF*SF);\n\t\n\tvec4 o = vec4(10000.0,vec3(0.0));\n\t\n\tcombineKIFS(p,1.0,             col1, o);\n\tcombineKIFS(p2,SF,             col2, o);\n\tcombineKIFS(p3,SF*SF,          col3, o);\n\tcombineKIFS(p4,SF*SF*SF,       col4, o);\n\tcombineKIFS(p5,SF*SF*SF*SF,    col5, o);\n\t//combineKIFS(p6,SF*SF*SF*SF*S, col6, o);\n\t\n\treturn o;       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n       \n    M = calc_transform(vec3(-0.4,-0.4,-0.55),normalize(vec3(1.0, 1.0, 1.0)), 40.0, 1.5);    \n    \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tdir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), 0.665));\n\t\n\tfloat t = log(1.0 + 3.0*fract(iTime/3.0)) / log(4.0);\n\t\n\tvec3 t1 = sp + sp*SF*2.0 + sp*SF*SF + vec3(-0.05,-0.05,-SF);\n\tvec3 t2 = sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF + vec3(-0.05*SF,-0.05*SF,-SF*SF);\n\t\n\tvec3 cam = t1 + (t2-t1) * t;\n\t\n\tfloat d = 1.0;\n\tfloat ray_length = 0.0;\n\t\n\tint steps = 0;\n\t\t\n\tvec3 bg = vec3(0.0, 0.55, 1.0)*(pow(length(vec2(uv.x,uv.y*2.0)),0.5)-1.05);\n\t\n\tvec3 c = bg;\n\t\n\tvec4 s = vec4(0.0);\n\n\tfloat lod = 0.56 /max(iResolution.x,iResolution.y);\n\t\n\tfor(int i=0; i<MAX_RAY_STEPS; i++) {\n\t\tif(d<lod*ray_length) continue;\n\t\ts = scene(cam);\n\t\td = s.x;\n\t\tcam += d * dir;\n\t\tray_length += d;\n\t\tsteps++;\n\t}\n\n\tif(ray_length<1.0) {\n\t\tc = s.yzw;\n\t\t\n\t\tfloat cost = float(steps)/float(MAX_RAY_STEPS);\n\t\t\n\t\t// cost based shading\n\t\t\n\t\tc *= pow(max(0.0, 1.0 - cost),5.0);\n\t\t\n\t\tc += pow(max(0.0, 1.0 - cost),27.0);\n\t\t\n\t\tif(uv.y>0.1) c = mix(c,bg,cost*step(0.5,cost));\n\t}\n\t                \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sS3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 562, 633, 633, 1106], [1117, 1117, 1146, 1146, 1424], [1437, 1437, 1470, 1470, 1735]], "test": "ok"}
{"id": "4sSGDd", "name": "abstract", "author": "avix", "description": "just bored and goofing around a bit...", "tags": ["procedural", "3d", "raymarch"], "likes": 28, "viewed": 4310, "published": "Public", "date": "1394949557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FARCLIP    35.0\n\n#define MARCHSTEPS 90\n\n#define PI         3.14\n#define PI2        PI*0.5    \n\n#define MAT1       1.0\n\n#define FOV 1.0\n\n\n/***********************************************/\nfloat rbox(vec3 p, vec3 s, float r) {\t\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\n}\n\nvec2 rot(vec2 k, float t) {\n    float ct=cos(t); \n    float st=sin(t);\n    return vec2(ct*k.x-st*k.y,st*k.x+ct*k.y);\n}\n\nvoid oprep2(inout vec2 p, float l, float s, float k) {\n\tfloat r=1./l;\n\tfloat ofs=s+s/(r*2.0);\n\tfloat a= mod( atan(p.x, p.y) + PI2*r*k, PI*r) -PI2*r;\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n\tp.x+=ofs;\n}\n/***********************************************\nfloat hash(float n) { \n\treturn fract(sin(n)*43758.5453123); \n}\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*113.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n/***********************************************/\n\nvec2 DE(vec3 p) {\n\nvec3 q=p;\n    //ball\n    oprep2(p.xz,8.0,0.1, -iTime);\n    oprep2(p.zy,16.0,0.25, -iTime); \n    float t=rbox(p,vec3(0.25,0.025,0.1),0.05);   \n   //tube\n\n    p=q; \n    p.y-=1.0;  \n    p.xy=rot(p.xy,p.z*0.15); \n    p.z+=iTime;\n    p.xy=mod(p.xy,6.0)-0.5*6.0;    \n    p.xy=rot(p.xy,-floor(p.z/0.75)*0.35);   \n    p.z=mod(p.z,0.75)-0.5*0.75;\n    oprep2(p.xy,3.0,0.15, iTime);  \n    \n    float c=rbox(p,vec3(0.1,0.025,0.25),0.05);\n   //tube\n  p=q; \n    p.y+=2.0;  \n    p.yz=rot(p.yz,p.x*0.15); \n    p.x+=iTime;\n    p.yz=mod(p.yz,6.0)-0.5*6.0;    \n    p.yz=rot(p.yz,-floor(p.x/0.75)*0.35);   \n    p.x=mod(p.x,0.75)-0.5*0.75;\n    oprep2(p.yz,3.0,0.15, iTime);  \n    float r=rbox(p,vec3(0.25,0.1,0.025),0.05);\n    \n  t= min(min(t,c),r);\n \n\treturn vec2( t*0.85 , MAT1);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -10.0);\n\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n\t\n//\tfloat ma=iTime*0.2+ sin(iTime*0.5);\n//\tfloat mb=iTime*0.1- cos(iTime*0.1);\n//\trot(ro,vec3(mp.x,mp.y,0.0));\n    ro.xz=rot(ro.xz,iTime*0.23);\n    ro.xy=rot(ro.xy,iTime*0.12);\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( FOV*p.x*cr + FOV*p.y*cu + 2.5*cf );\n\n\tvec3 col=vec3(0.0);\n\t/* trace */\n\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\n        if( r.x<0.0 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n\t/* draw */\n\t\n\t\n\tfloat lp=sin(iTime)+1.5;\n    vec3 nor=normal(ww);\n\n\tif( r.x<FARCLIP ) {\n\n        col=vec3(0.43,0.84,0.97); \n\n    \tfloat amb=0.5;\t\n    \tfloat dif=0.5*clamp(dot(ww,-nor),-1.0,1.0);\n    \tfloat bac=0.2*clamp(dot(ww,nor),0.0,1.0);\n\n\t    col *= amb + dif +bac;\n\t    \n\t    float spe= pow(clamp( dot( nor, reflect(ww,nor) ), 0.0, 1.0 ) ,16.0 );\n\t    col += 0.5*pow(spe,1.0);\n\n        col*=lp;\n\n        col*=exp(-0.2*r.x); col*=1.5;\n\t} \n      \n    /* sun */\n    vec3 lpos=vec3(0.0, 0.0, 0.0);\n    \n\tfloat m = dot(rd, -ro);\n\t      d = length(ro-lpos+m*rd);\n\t\n\tfloat a = -m;\n\tfloat b = r.x-m;\n\tfloat aa = atan(a/d);\n\tfloat ba = atan(b/d);\n\tfloat to = (ba-aa)/d;\n\n    col+=to*0.15*lp;\n    /* sun */\n\n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sSGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 195, 232, 232, 283], [285, 285, 312, 312, 403], [405, 405, 459, 459, 611], [612, 1200, 1217, 1217, 1981], [1982, 2032, 2053, 2053, 2199], [2200, 2561, 2618, 2618, 4139]], "test": "ok"}
{"id": "4ssXRn", "name": "crosser", "author": "visy", "description": "crosses music vis", "tags": ["crossesmusicvis"], "likes": 2, "viewed": 165, "published": "Public", "date": "1395870051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat time = iTime;\n\tvec4 t = texture(iChannel0,uv);\n\tfloat c = sin(t.r+1.0*uv.y)*uv.x/atan(t.r*1.0*uv.y+time*0.5)*uv.x*time*0.01;\n\tc+=abs(tan(sin(uv.x+abs(cos(time*0.1)*sin(time*0.003))*2.3)+cos(uv.y+cos(time)*sin(time*0.4)*0.5))*uv.x*2.5*t.x*0.01+time*0.5);\n\tc-=abs(tan(sin(uv.y+abs(sin(time*0.1)*sin(time*0.004))*3.1)+cos(uv.x+sin(time)*cos(time*0.4)*0.5))*uv.x*2.5*t.x*0.01+time*0.5);\n\tfragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 521]], "test": "ok"}
{"id": "ld23DV", "name": "Box - intersection", "author": "iq", "description": "Intersection of a ray and a box. The ray is transformed to box space, and the returned normal is converted back to ray space upon intersection. If there were many boxes to be intersected oriented the same way, the transformations should be done only once.", "tags": ["3d", "raytracing", "box"], "likes": 61, "viewed": 12763, "published": "Public API", "date": "1393881136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Ray-Box intersection, by convertig the ray to the local space of the box.\n//\n// If this was used to raytace many equally oriented boxes (say you are traversing\n// a BVH), then the transformations in line 34 and 35 could be skipped, as well as\n// the normal computation in line 50. One over the ray direction is usually accessible\n// as well in raytracers, so the division would go away in real world applications.\n\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n//\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// Other Box functions (http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm)\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n// Gradient:         https://www.shadertoy.com/view/wlcXD2\n\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    // rotate and translate box\t\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( 0.0, 1.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat oid = 0.0;\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\toid = 1.0;\n\t}\n\n\t// raytrace box\n\tvec3 box = vec3(0.4,0.6,0.8) ;\n\tvec4 res = iBox( ro, rd, txx, txi, box);\n\tif( res.x>0.0 && res.x<tmin )\n\t{\n\t\ttmin = res.x; \n\t\tnor = res.yzw;\n\t\toid = 2.0;\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n    \n\tif( tmin<100.0 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // material\n\t\tfloat occ = 1.0;\n\t\tvec3  mate = vec3(1.0);\n\t\tif( oid<1.5 ) // plane\n\t\t{\n\t\t    mate = 0.35*texture( iChannel0, 0.25*pos.xz ).xyz;\n\t\t\tocc = 0.2 + 0.8*smoothstep( 0.0, 1.5, length(pos.xz) );\n\t\t}\t\t\t\n\t\telse // box\n\t\t{\n            // recover box space data (we want to do shading in object space)\t\t\t\n\t\t    vec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n\t\t    mate = abs(onor.x)*texture( iChannel0, 0.5*opos.yz ).xyz + \n                   abs(onor.y)*texture( iChannel0, 0.5*opos.zx ).xyz + \n                   abs(onor.z)*texture( iChannel0, 0.5*opos.xy ).xyz;\n\t\t\tmate *= 0.35;\n            occ = 0.6 + 0.4*nor.y;\n\t\t}\t\t\n\t\t\n        // lighting\n        vec3  lig = normalize(vec3(0.8,0.4,-0.6));\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        vec3  hal = normalize(lig-rd);\n        float sha = step( iBox( pos+0.001*nor, lig, txx, txi, box ).x, 0.0 );\n        float amb = 0.6 + 0.4*nor.y;\n        float bou = clamp(0.3-0.7*nor.y,0.0,1.0);\n        float spe = clamp(dot(nor,hal),0.0,1.0);\n        col  = 4.0*vec3(1.00,0.80,0.60)*dif*sha;\n        col += 2.0*vec3(0.20,0.30,0.40)*amb;\n        col += 2.0*vec3(0.30,0.20,0.10)*bou;\n        col *= mate;            \n        col += 0.3*pow(spe,8.0)*dif*sha*(0.04+0.96*pow(clamp(dot(lig,hal),0.0,1.0),5.0));\n        col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tmin*tmin) );           \n\t}\n\t\n    // vignetting        \n    col *= 1.0 - 0.1*dot(p,p);\n\n    // gamma\n    col = pow( col, vec3(0.45) );\n    \n\t// grading\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld23DV.jpg", "access": "shaders20k", "license": "mit", "functions": [[2107, 2175, 2252, 2289, 2807], [2810, 2878, 2943, 2943, 3273], [3276, 3369, 3416, 3416, 3820], [3822, 3822, 3867, 3867, 3983], [3984, 4268, 4325, 4325, 7081]], "test": "ok"}
{"id": "ld2GWc", "name": "Cross/Vector Product", "author": "Vlad86", "description": "Before I apply cross-product anywhere, I always visualize it in my head... however, sometimes I confuse when its UP or when its DOWN.. so I've made this little shader to show it's behavior. Axis: [Left -X+ Right] [Down -Y+ Up] [Back -Z+ Forward]", "tags": ["crossvectorproduct"], "likes": 2, "viewed": 260, "published": "Public", "date": "1394682385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t\t\t\t\t3.14159265359\n#define PIH \t\t\t\t(PI/2.0)\n#define PIQ \t\t\t\t(PI/4.0)\n#define PI2 \t\t\t\t(PI*2.0)\n#define MARCH_SCALE\t\t\t0.95\n#define MARCH_STEPS\t\t\t48\n#define PRECISION\t\t\t0.001\n\n#define LIGHT_POS\t\t\tvec3(0.0, 0.0, -5.0)\n#define COLOR_1\t\t\t\tvec3(-2.5, 2.5, 4.0)\n#define COLOR_2\t\t\t\tvec3(4.0, 1.5, -1.0)\n\n// Used inside the scene function, requires you to declare float depthCurr = 1000.0; float depthPrev = 1000.0; and float matID = -1.0;\n#define OBJ(inOBJ, inMatID) depthPrev=depthCurr; depthCurr=min(depthCurr, inOBJ); if(depthCurr < depthPrev) matID = inMatID;\n\nvec3 GetRayDir(vec2 inTC, vec2 inAspectRatio)\t{return normalize(vec3((-0.5 + inTC)*1.2 * inAspectRatio, 1.0));}\nmat3 RotX(float a)\t\t\t\t\t\t\t\t{float s = sin(a); float c = cos(a); return mat3(1,0,0,0,c,s,0,-s,c);}\nmat3 RotY(float a)\t\t\t\t\t\t\t\t{float s = sin(a); float c = cos(a); return mat3(c,0,-s,0,1,0,s,0,c);}\nmat3 RotZ(float a)\t\t\t\t\t\t\t\t{float s = sin(a); float c = cos(a); return mat3(c,s,0,-s,c,0,0,0,1);}\n\n// Global variables\nvec2 CrossObj(vec3 p)\n{\n\tfloat depthCurr\t= 1000.0;\n\tfloat depthPrev\t= 1000.0;\n\tfloat matID\t\t= -1.0;\n\t\n\tconst float cylinderHeight\t= 1.0;\n\tconst float cylinderRadius\t= 0.005;\n\t\n\t\n\tvec3 crossp\t\t\t\t\t= cross(vec3(1, 0, 0), vec3(sin(iTime),0,cos(iTime)));\n\tfloat crossHeight\t\t\t= crossp.y;\n\t\n\tOBJ(max(length(p.zy)-cylinderRadius, abs(p.x-cylinderHeight*0.5)-cylinderHeight*0.5), 0.0); // X - Axis\n\t\n\tOBJ(max(length(p.xz)-cylinderRadius, abs(p.y-crossHeight*0.5)-abs(crossHeight)*0.5), 1.0);\t// Y - Axis\n\t\n\t// We rotate only the Z axis vector\n\tp = RotY(iTime) * p;\n\tOBJ(max(length(p.xy)-cylinderRadius, abs(p.z-cylinderHeight*0.5)-cylinderHeight*0.5), 2.0); // Z - Axis\n\t\n\tOBJ(length(p)-0.05, 3.0); // Z - Axis\n\t\n\treturn vec2(depthCurr, matID);\n}\n\n\nvec3 GetColor(float id)\n{\n\t// Background color\n\tvec3 color = vec3(0,0,0);\n\t\n\t// Material Colors\n\tif(id == 0.0)color=vec3(1.0, 0.0, 0.0); // Red\n\tif(id == 1.0)color=vec3(0.0, 1.0, 0.0); // Green\n\tif(id == 2.0)color=vec3(0.0, 0.0, 1.0); // Blue\n\tif(id == 3.0)color=vec3(0.4, 0.4, 0.4); // Grey\n\t\n\treturn color;\n}\n\n\nvec2 Intersect(vec3 ro, vec3 rd)\n{\t\t\n\tvec2 r\t\t= vec2(1000.0, -1.0);\n\tfloat z\t\t= 1.1;\n\tfloat matID\t= -1.0;\n\t\n\tfor(int i=0; i<MARCH_STEPS; i++)\n\t{\n\t\tr = CrossObj(ro + rd*z);\n\t\tif(r.x < PRECISION)\n\t\t\tcontinue;\n\t\tz\t\t+=r.x*MARCH_SCALE;\n\t\tmatID\t= r.y;\n\t}\n\t\n\tif(z > 3.1)\n\t\tz = 0.0;\n\t\n\treturn vec2(z, matID);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv\t\t= fragCoord.xy / iResolution.xy;\n\t\n\t// Construct simple ray\n\tmat3 xrot\t= RotX(0.5);\n\tvec2 aspect\t= vec2(iResolution.x/iResolution.y, 1.0);\n\tvec3 ro\t\t= xrot * vec3(0, 0.0, -2);\n\tvec3 rd\t\t= xrot * GetRayDir(uv, aspect);\n\t\n\t// Draw background color\n\tvec3 c1\t\t= mix(COLOR_2, COLOR_1, pow(uv.x, 2.0));\n\tvec3 c2\t\t= mix(COLOR_2, COLOR_1, pow(uv.y, 2.0));\n\tvec3 color\t= mix(c1, c2, 0.5) * 0.1;\n\n\tvec2 res\t= Intersect(ro, rd);\n\tvec3 p;\n\tvec3 n;\n\tif(res.x > 0.0)\n\t\tcolor = GetColor(res.y);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2GWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 566, 613, 613, 677], [678, 678, 705, 705, 774], [775, 775, 802, 802, 871], [872, 872, 899, 899, 968], [970, 990, 1013, 1013, 1728], [1731, 1731, 1756, 1777, 2041], [2044, 2044, 2078, 2078, 2346], [2350, 2350, 2407, 2407, 2931]], "test": "ok"}
{"id": "ldB3DK", "name": "Portal Gun", "author": "Ramocles", "description": "THE CAKE IS A LIE. \nFully functional ray marched portal system. Mouse controls the camera direction (both \"subjective camera\" and \"3rd person camera\"). Sorry, no Companion Cube this time. \n", "tags": ["procedural", "raymarching", "portal"], "likes": 43, "viewed": 2121, "published": "Public", "date": "1396273161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////\n//\n// Created by Ramon Viladomat\n//\n// Description: \n//\n// Fully functional portal system with two portals connected. Mouse controls \n// the camera direction (both \"subjective camera\" and \"3rd person camera\"). \n//\n// How it works:  \n//\n// The basic idea behind this shader is to first compute the portals \n// used for the given ray before the raymarching phase( storing\n// ray lambdas, positions and offsets for each portal cross ). \n// \n// Next we raymarch checking the portal data at each step to know which \n// ray origin and direction we should use for the distance function based \n// on the line lambda.\n//\n// The camera movement uses a sequence of bezier splines going from portal to portal.\n//\n// Hope you like it. \n//\n//////////////////////////////////////////\n\n//////////////////////////////////////////\n// Option MACROS\n\n//Comment this to have an static camera and see the whole scene from a 3rd person view \n#define SUBJETIVE_CAMERA\n\n//Comment this to remove the ilumination of the spark representing the subjective camera\n#define SPARK_ILUMINATION\n\n//////////////////////////////////////////\n//Common MACROS\n\n#define PI          3.1415\n#define EPSILON     0.002\n#define TIME_SCALE  1.0\n#define TIME_OFFSET -0.5\n\n//////////////////////////////////////////\n//Fade-In Transition Times\n#define FADE_IN_START 0.5\n#define FADE_IN_END   1.5\n\n//////////////////////////////////////////\n//Ray marching MACROS\n\n#define NUM_RAYMARCH_STEP 150\n#define STEP_REDUCTION    0.8\n#define NUM_REFLECTIONS   3\n\n//////////////////////////////////////////\n//Portal MACROS\n\n#define NUM_PORTAL_RECURSIONS    4\n#define PORTAL_EPSILON           0.02\n#define PORTAL_RADIUS            1.5\n#define PORTAL_SHAPE_INV_SCALE_X 1.7\n#define PORTAL_OPEN_SPEED        5.0\n#define PORTAL_CLOSE_SPEED       20.0\n\n//////////////////////////////////////////\n// Global Definitions\n\n//Portal Ray Properties\nvec3 rayDirections[NUM_PORTAL_RECURSIONS]; \nvec3 rayPositions[NUM_PORTAL_RECURSIONS];\nvec4 rayColors[NUM_PORTAL_RECURSIONS];\nfloat distances[NUM_PORTAL_RECURSIONS];\n\n//Current Portals VARS\nvec3 portal1Norm = vec3(0.0,0.0,-1.0); \nvec3 portal1Pos = vec3(-8.0,-3.5,-PORTAL_EPSILON);  \nfloat portal1Radius = 1.5; \n\t\nvec3 portal2Norm = vec3(0.0,0.0,1.0); \nvec3 portal2Pos = vec3(-8.0,-3.5,-10.0+PORTAL_EPSILON);  \nfloat portal2Radius = 1.5; \n\n//Animation VARS\n\n#define NUM_CAMERA_TRAMS 5\nvec3 cameraControl0[NUM_CAMERA_TRAMS]; \nvec3 cameraControl1[NUM_CAMERA_TRAMS];\nvec3 cameraControl2[NUM_CAMERA_TRAMS];\nvec3 cameraControl3[NUM_CAMERA_TRAMS];\nfloat cameraDuration[NUM_CAMERA_TRAMS];\n\n#define NUM_PORTAL_TRAMS 5\nvec3 portal1Normals[NUM_PORTAL_TRAMS];\nvec3 portal1Positions[NUM_PORTAL_TRAMS];\nfloat portal1Duration[NUM_PORTAL_TRAMS];\n\nvec3 portal2Normals[NUM_PORTAL_TRAMS];\nvec3 portal2Positions[NUM_PORTAL_TRAMS];\nfloat portal2Duration[NUM_PORTAL_TRAMS];\n\n////////////////\n// DATA SETUP //\n////////////////\n\nvoid InitData()\n{\n\t//Portal 1 - Blue\n\tportal1Duration [0] = 4.0; \n\tportal1Normals  [0] = vec3(0.0,0.0,-1.0);\n\tportal1Positions[0] = vec3(-8.0,-3.5,-PORTAL_EPSILON); \n\t\n\tportal1Duration [1] = 2.6; \n\tportal1Normals  [1] = vec3(0.0,0.0,1.0);\n\tportal1Positions[1] = vec3(8.0,8.0,-10.0+PORTAL_EPSILON); \n\t\n\tportal1Duration [2] = 1.0; \n\tportal1Normals  [2] = vec3(0.0,0.0,-1.0);\n\tportal1Positions[2] = vec3(8.0,5.0,10.0-PORTAL_EPSILON); \n\t\n\tportal1Duration [3] = 5.0; \n\tportal1Normals  [3] = vec3(0.0,0.0,1.0);\n\tportal1Positions[3] = vec3(8.0,-3.5,-10.0+PORTAL_EPSILON); \n\t\n\t//Note: portal 4 doesn't have 4rt place\n\t\n\t//Portal 2 - Red\n\tportal2Duration [0] = 1.0; \n\tportal2Normals  [0] = vec3(0.0,0.0,1.0);\n\tportal2Positions[0] = vec3(-8.0,-3.5,-10.0+PORTAL_EPSILON); \n\n\tportal2Duration [1] = 4.6; \n\tportal2Normals  [1] = vec3(0.0,0.0,-1.0);\n\tportal2Positions[1] = vec3(8.0,-3.5,-PORTAL_EPSILON); \n\t\n\tportal2Duration [2] = 0.45; \n\tportal2Normals  [2] = vec3(0.0,1.0,0.0);\n\tportal2Positions[2] = vec3(0.0,-10.0+PORTAL_EPSILON,-5.0);\n\t\n\tportal2Duration [3] = 2.0; \n\tportal2Normals  [3] = vec3(0.0,0.0,-1.0);\n\tportal2Positions[3] = vec3(8.0,1.5,10.0-PORTAL_EPSILON); \t\n\t\n\tportal2Duration [4] = 5.0; \n\tportal2Normals  [4] = vec3(0.0,0.0,1.0);\n\tportal2Positions[4] = vec3(-8.0,-3.5,-10.0+PORTAL_EPSILON); \n\t\n  \t//Camera \n\tcameraDuration[0] = 3.0; \n\tcameraControl0[0] = portal2Positions[0];\n\tcameraControl1[0] = portal2Positions[0] + portal2Normals[0]*2.0;\n\tcameraControl2[0] = portal1Positions[0] + portal1Normals[0]*2.0;\n\tcameraControl3[0] = portal1Positions[0];\n\t\n\tcameraDuration[1] = 2.0; \n\tcameraControl0[1] = portal2Positions[1];\n\tcameraControl1[1] = portal2Positions[1] + portal2Normals[1]*2.0;\n\tcameraControl2[1] = vec3(8.0,-3.5,-5.0); \n\tcameraControl3[1] = vec3(5.0,-3.5,-5.0);\n\t\n\tcameraDuration[2] = 1.0; \n\tcameraControl0[2] = cameraControl3[1];\n\tcameraControl1[2] = cameraControl3[1]-vec3(2.0,0.0,0.0);\n\tcameraControl2[2] = portal2Positions[2] + portal2Normals[2]*5.0;\n\tcameraControl3[2] = portal2Positions[2];\n\t\n\tcameraDuration[3] = 1.5; \n\tcameraControl0[3] = portal1Positions[1];\n\tcameraControl1[3] = portal1Positions[1] + portal1Normals[1]*5.0;\n\tcameraControl2[3] = portal2Positions[3] + portal2Normals[3]*2.0;\n\tcameraControl3[3] = portal2Positions[3];\n\t\n\tcameraDuration[4] = 1.5; \n\tcameraControl0[4] = portal1Positions[2];\n\tcameraControl1[4] = portal1Positions[2] + portal1Normals[2]*10.0;\n\tcameraControl2[4] = portal1Positions[3] + portal1Normals[3]*2.0;\n\tcameraControl3[4] = portal1Positions[3];\n}\n\n///////////////////\n// WORLD UPDATES //\n///////////////////\n\nvec3 Bezier(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t, out vec3 tangent)\n{\n\t// n : being n+1 the number of control points\n\t// Bezier(t) = SUM[i=0..n]( Bernstein<n,i>(t)*ControlPoint<i> )\n\n\t// Bernstein polys for the given factor\n\t// Berstein<n,i>(t) = (n!/(i!*(n-i)!))*t^i*(1-t)^(n-i)\n\t\n\tfloat t2 = t*t;\n\tfloat t3 = t*t*t;\n\n\tfloat minusT = 1.0 - t;\n\tfloat minusT2 = minusT * minusT;\n\tfloat minusT3 = minusT2 * minusT;\n\n\t// Tangent\n\t\n\t// derived Bernstein polys for the given factor\n\t// Berstein<n,i>(t) = (n!/(i!*(n-i)!))*t^i*(1-t)^(n-i)\n\t\n\ttangent = normalize((p1-p0)*minusT2 + (p2-p1)*(2.0*t*minusT) + (p3-p2)*t2);\n\t\n\t// Position\n\t\n\tfloat b0 = minusT3;\t\t  //(1-t)^3\n\tfloat b1 = 3.0*t*minusT2; //3t(1-t)^2\n\tfloat b2 = 3.0*t2*minusT; //3t^2(1-t)\n\tfloat b3 = t3;\t\t\t  //t^3\n\n\treturn (b0*p0)+(b1*p1)+(b2*p2)+(b3*p3);\n}\n\nvec3 GetCameraPos(in float time, out vec3 tangent)\n{\n\tfloat localTime = time; \t\n\tfor (int i=0;i<NUM_CAMERA_TRAMS;++i)\n\t{\n\t\tif (localTime < cameraDuration[i])\n\t\t{\n\t\t\treturn Bezier(cameraControl0[i],cameraControl1[i],cameraControl2[i],cameraControl3[i],localTime/cameraDuration[i],tangent);\n\t\t}\n\t\t\t\t\t\t\n\t\tlocalTime -= cameraDuration[i];\t\t\n\t}\n\treturn vec3(0.0);\n}\n\nvec3 UpdatePortals(in float time)\n{\n\tfloat localTime1 = time; \t\n\tfloat localTime2 = time; \t\n\tfor (int i=0;i<NUM_PORTAL_TRAMS;++i)\n\t{\n\t\tif (localTime1 < portal1Duration[i])\n\t\t{\n\t\t\tportal1Norm = portal1Normals[i];\n\t\t\tportal1Pos  = portal1Positions[i];\n\t\t\tfloat openCloseFactor = min(PORTAL_OPEN_SPEED*localTime1,PORTAL_CLOSE_SPEED*abs(localTime1 - portal1Duration[i])); \n\t\t\tportal1Radius = PORTAL_RADIUS*min(openCloseFactor,1.0);\n\t\t\tlocalTime1  = 99999.0; \n\t\t}\n\t\t\n\t\tif (localTime2 < portal2Duration[i])\n\t\t{\n\t\t\tportal2Norm = portal2Normals[i];\n\t\t\tportal2Pos  = portal2Positions[i];\n\t\t\tfloat openCloseFactor = min(PORTAL_OPEN_SPEED*localTime2,PORTAL_CLOSE_SPEED*abs(localTime2 - portal2Duration[i])); \n\t\t\tportal2Radius = PORTAL_RADIUS*min(openCloseFactor,1.0);\n\t\t\tlocalTime2  = 99999.0; \n\t\t}\n\t\t\t\t\t\t\n\t\tlocalTime1 -= portal1Duration[i];\t\t\n\t\tlocalTime2 -= portal2Duration[i];\n\t}\n\treturn vec3(0.0);\n}\n\n////////////////\n// MORPHOLOGY //\n////////////////\n\nfloat AnaliticalDistSpark(in vec3 ro, in vec3 rd, vec3 point, float distThreshold)\n{\n\tfloat lambda = dot(-(ro - point),rd);\n\tfloat dist = length((ro+rd*lambda)-point);\n\treturn mix(9999.0,dist,step(-1.0,lambda)*step(lambda,distThreshold+1.0)); \n}\n\nfloat DistBox(in vec3 p, in vec3 dimensions)\n{\n\treturn length(max(abs(p) - dimensions,0.0)); \n}\n\nfloat DistWalls( in vec3 p)\n{\n\treturn min(min(-p.z+10.0,-p.x+10.0),-p.y+10.0);\n}\n\nfloat Map( in vec3 p )\n{\n\tvec3 q = vec3(abs(p.x),p.y,p.z); \n\t\n\treturn  min(\n\t\t\t   DistWalls(vec3(q.x,abs(q.y),abs(q.z))),\n\t\t\t   min(DistBox(q-vec3(0.0,-10.0,10.0),vec3(10.0)),DistBox(q-vec3(15.0,-15.0,0.0),vec3(10.0)))\n\t\t\t   );\n}\n\n////////////\n// PORTAL //\n////////////\n\nfloat RayPortalIntersection(\n\tin vec3 rayOrigin,\n\tin vec3 rayDir, \n\tin vec3 portalNorm, \n\tin vec3 portalLeft, \n\tin vec3 portalUp,\n\tin vec3 portalPos, \n\tin float portalRadius, \n\tin float otherRadius,\n\tout vec3 localRayDir,\n\tout vec2 localPos, \n\tout float signedDist\n)\n{\n\tfloat t = dot(portalNorm,portalPos-rayOrigin) / (dot(rayDir,portalNorm)); \n\tvec3 intersectionPos = rayOrigin + t*rayDir; \n\t\n\tfloat dotRayNorm = dot(rayDir,portalNorm); \n\t\n\tvec3 localp = intersectionPos - portalPos;\n\tlocalPos = vec2(dot(localp,portalLeft),dot(localp,portalUp));\n\tlocalRayDir = vec3(dot(rayDir,portalLeft),dot(rayDir,portalUp),dotRayNorm); \n\t\t\t\t\t\n\t//check distance to portal \n\tconst vec2 scale = vec2(PORTAL_SHAPE_INV_SCALE_X,1.0); \n\n\tvec2 localPosScaled = localPos*scale;\n\t\n\tvec2 closestBorderPoint = normalize(localPosScaled)*min(portalRadius,otherRadius); \n\tvec2 borderDeltaVec = localPosScaled - closestBorderPoint; \n\t\n\tsignedDist = dot(borderDeltaVec,closestBorderPoint)*length(borderDeltaVec/scale); \n\t\n\t//return data\n\tfloat insidePortal = step(dotRayNorm,0.0)*step(EPSILON,t)*step(length(localPosScaled),portalRadius);\n\treturn mix(9999.0,t,insidePortal);\n}\n\nvec4 GetPortalColor(in float signedDist, in vec3 baseColor)\n{\n\treturn vec4(baseColor,clamp(1.0+signedDist*20.0,0.0,1.0)); \n}\n\nfloat PortalCheck(\n\tin vec3 rayOrigin,\n\tin vec3 rayDir, \n\tout vec3 outRayOrigin,\n\tout vec3 outRayDir,\n\tout vec4 outPortalColor\n\t)\n{\n\tvec3 realUp1 = mix(vec3(0.0,1.0,0.0),vec3(-1.0,0.0,0.0),step(0.9,dot(vec3(0.0,1.0,0.0),portal1Norm)));\n\tvec3 realUp2 = mix(vec3(0.0,1.0,0.0),vec3(-1.0,0.0,0.0),step(0.9,dot(vec3(0.0,1.0,0.0),portal2Norm)));\n\t\n\tvec3 portal1Left = normalize(cross(realUp1,portal1Norm));\n\tvec3 portal1Up = normalize(cross(portal1Norm,portal1Left));\n\tvec3 portal2Left = normalize(cross(realUp2,portal2Norm));\n\tvec3 portal2Up = normalize(cross(portal2Norm,portal2Left));\n\t\n\tvec2 portal1localPos;\n\tvec3 portal1localRay; \n\tfloat portal1SignedDist; \n\tfloat p1 = RayPortalIntersection(rayOrigin,rayDir,portal1Norm,portal1Left,portal1Up,portal1Pos,portal1Radius,portal2Radius,portal1localRay,portal1localPos,portal1SignedDist); \n\tvec4 portal1Color = GetPortalColor(portal1SignedDist,vec3(0.0,0.0,1.0)); \t\n\t\n\tvec2 portal2localPos;\n\tvec3 portal2localRay; \n\tfloat portal2SignedDist; \n\tfloat p2 = RayPortalIntersection(rayOrigin,rayDir,portal2Norm,portal2Left,portal2Up,portal2Pos,portal2Radius,portal1Radius,portal2localRay,portal2localPos,portal2SignedDist); \n\tvec4 portal2Color = GetPortalColor(portal2SignedDist,vec3(1.0,0.0,0.0)); \t\n\t\n\tvec3 outPosp1p2 = portal2Pos - portal1localPos.x*portal2Left + portal1localPos.y*portal2Up;\n\tvec3 outDirp1p2 = -portal1localRay.x*portal2Left + portal1localRay.y*portal2Up - portal1localRay.z*portal2Norm; \t\n\n\tvec3 outPosp2p1 = portal1Pos - portal2localPos.x*portal1Left + portal2localPos.y*portal1Up;\n\tvec3 outDirp2p1 = -portal2localRay.x*portal1Left + portal2localRay.y*portal1Up - portal2localRay.z*portal1Norm; \t\n\n\tfloat portalSelector = step(p2,p1); // 0 if portal 1 -> portal 2 | 1 if portal 2 -> portal 1 \t\n\toutRayOrigin = mix(outPosp1p2,outPosp2p1,portalSelector);\n\toutRayDir = mix(outDirp1p2,outDirp2p1,portalSelector);\n\toutPortalColor = mix(portal1Color,portal2Color,portalSelector);\n\treturn mix(p1,p2,portalSelector);\n}\n\nvoid ComputePortals(in vec3 rayOrigin, in vec3 rayDir)\n{\n\trayPositions[0]=rayOrigin;\n\trayDirections[0]=rayDir; \n\tdistances[0]=0.0;\n\trayColors[0]=vec4(0.0);\n\t\n\tfor (int i=1;i<NUM_PORTAL_RECURSIONS;++i)\n\t{\n\t\tdistances[i]=distances[i-1] + PortalCheck(rayPositions[i-1],rayDirections[i-1],rayPositions[i],rayDirections[i],rayColors[i]);\t\t\n\t}\n}\n\nfloat ExtractPortalRay(in float t, out vec3 rayOrigin, out vec3 rayDir)\n{\n\tfloat ret = 0.0; \n\trayOrigin = vec3(0.0); \n\trayDir = vec3(0.0);\n\t\n\tfor (int i=0;i<NUM_PORTAL_RECURSIONS;++i)\n\t{\n\t\tfloat isCopy = step(distances[i],t);\n\t\tfloat minusIsCopy = 1.0 - isCopy; \n\t\t\n\t\tret = (distances[i]*isCopy)+(ret*minusIsCopy);\n\t\trayOrigin = (rayPositions[i]*isCopy)+(rayOrigin*minusIsCopy);\n\t\trayDir = (rayDirections[i]*isCopy)+(rayDir*minusIsCopy);\t\t\n\t}\n\treturn ret;\n}\n\nvec4 ExtractPortalColor(in float t)\n{\n\tvec4 ret = vec4(0.0); \n\t\n\tfor (int i=0;i<NUM_PORTAL_RECURSIONS;++i)\n\t{\n\t\tfloat blendFactor = (1.0 - ret.w)*rayColors[i].w*step(distances[i],t); \n\t\tret.xyz = ret.xyz + blendFactor*rayColors[i].xyz;\n\t\tret.w += blendFactor; \n\t}\n\treturn ret;\n}\n\n///////////////\n// MATERIALS //\n///////////////\n\nvec4 CalcColor( in vec3 pos, in vec3 nor)\n{\n\t//ground/ceiling basic Color\n\tvec2 groundtiles = 2.0*(0.5 - abs(0.5-mod(pos.xz,vec2(1.0)))); \n\tfloat groundtileBorder = smoothstep(0.0,0.1,min(groundtiles.x,groundtiles.y));\n\tvec4 groundColor = groundtileBorder*vec4(0.2,0.2,0.2,0.08); \n\t\n\t//walls\n\tvec3 wallTiles = 2.0*abs(vec3(1.0,2.5,1.0)-mod(pos+vec3(0.96,2.5,0.96),vec3(2.0,5.0,2.0)));\n\tfloat walltileBorder = smoothstep(0.0,0.1,min(min(wallTiles.x,wallTiles.y),wallTiles.z));\n\tvec4 wallColor = walltileBorder*vec4(0.05,0.05,0.05,0.02);\n\t\t\n\treturn mix(wallColor,groundColor,abs(dot(nor,vec3(0.0,1.0,0.0))));\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\nfloat Intersect()\n{\n\tvec3 ro; \n\tvec3 rd; \n\tfloat res = 2.0*EPSILON;\n    float t = 0.0;\n    for( int i=0; i<NUM_RAYMARCH_STEP; i++ )\n    {\n\t\tif( abs(res)<EPSILON ) continue;\n\t\tfloat dist = ExtractPortalRay(t,ro,rd);\n\t\tres = Map( ro+rd*(t-dist) );\n\t\tt += res*STEP_REDUCTION;\n    }\n\treturn t;\n}\n\nvec3 CalcNormal( in vec3 pos )\n{\n    vec2 eps = vec2(EPSILON,0.0);\n\treturn normalize( vec3( Map(pos+eps.xyy) - Map(pos-eps.xyy), Map(pos+eps.yxy) - Map(pos-eps.yxy), Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\n\n//IQ ray-marched ambient occlusion algorithm \nfloat AmbientOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = Map( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 0.6*totao, 0.0, 1.0 );\n}\n\n//////////\n// MAIN //\n//////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t////////////////\n\t//Init Data\n\tInitData();\n\t\n\t////////////////\n\t//Update World\n\tfloat localTime = mod(TIME_OFFSET+iTime*TIME_SCALE,9.0);\n\tvec3 tangent;\n\tvec3 worldCameraPos = GetCameraPos(localTime,tangent);\n\tUpdatePortals(localTime); \n\t\t\n\t////////////////\n\t// Render\n    vec2 puv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 p = vec2(puv.x * iResolution.x/iResolution.y,puv.y);\n\t\n\t// Compute Camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n#ifdef SUBJETIVE_CAMERA\n\t\n\t//move camera when clicking\t\n\tvec2 mouseAngles = (mix(vec2(0.0),(mousePos*2.0)-1.0,clamp(iMouse.z,0.0,1.0)))*vec2(PI,PI*0.5);\n\t\n\tvec3 camPosition = worldCameraPos;\n\tvec3 camTmpRight = normalize( cross(tangent,vec3(0.0,1.0,0.0) ) );\n    vec3 camTmpUp    = normalize( cross(camTmpRight,tangent));\n\t\n\t//apply camera extra rotation\n\tvec3 camFront    = (tangent*cos(mouseAngles.x)+camTmpRight*sin(mouseAngles.x))*cos(mouseAngles.y)+camTmpUp*sin(mouseAngles.y);\n\tvec3 camRight \t = normalize( cross(camFront,camTmpUp));\n\n#else\n\t\n\t//apply permanent camera movement \n\tfloat inputCamAngle = PI-2.0*PI*mousePos.x;\n\tvec3 camPosition    = vec3(0.0,2.0,-5.0);\n\tvec3 camTarget\t    = camPosition + vec3(sin(inputCamAngle), (3.0*mousePos.y)-1.0, cos(inputCamAngle));\n\tvec3 camFront \t    = normalize( camTarget - camPosition );\n\tvec3 camRight \t    = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n   \n#endif\n\t\n\tvec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\t\n\t// light compute \n\tvec3 lightPos1 = vec3(0.0,5.0,0.0);\n\tvec3 lightColor1 = vec3(1.0,1.0,1.0);\n\t\t\t\t\n\t// Start Ray\n    vec3 finalcolor = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int reflectCount=0; reflectCount<NUM_REFLECTIONS; reflectCount++ )\n\t{\n\t\t// Portal logic goes here \n\t\tComputePortals(camPosition,rayDir);\n\t\t\t\t\t\t\t\n\t\t// Compute color for single ray\n    \tfloat t = Intersect();\n\t\t\n\t\tvec3 prevRayDir = rayDir; \n\t\tvec3 prevCamPosition = camPosition;\n\t\t\n\t\t// results extraction\n\t\tvec4 portalColor = ExtractPortalColor(t);\n\t\tfloat dist = ExtractPortalRay(t,camPosition,rayDir); \n\t\tfloat localDist = t-dist;\n\t\t\n\t\tvec3 position \t= camPosition + localDist*rayDir;\n\t\tvec3 normal \t= normalize(CalcNormal(position));\n\t\tvec3 reflDir \t= reflect(rayDir,normal);\n\t\t\t\n\t\t// lights and materials \n\t\tvec4 materialColor \t= CalcColor( position, normal );\n\t\t\n\t\tfloat ambient  \t\t= 0.7 + 0.3*normal.y;\n\t\tvec3 ambientColor \t= ambient*materialColor.rgb;\n\t\t\n\t\t//ambient occlusion\n\t\tfloat occlusion = AmbientOcclusion( position, normal );\n\t\t\n\t\t//light 1\n\t\tvec3 lightDir1 \t= normalize(lightPos1 - position);\n\t\tfloat diffuse1  = max(dot(normal,lightDir1),0.0);\n\t\tvec3 diffuseColor = diffuse1*lightColor1*materialColor.rgb;\t\t\n\t\t\n\t\t//bluelightComponent shining\n\t\tvec2 lightSource = -(abs(position.xz)-10.0);\n\t\tfloat blueIntensity = pow(smoothstep(2.0,10.0,position.y)*(1.0-smoothstep(0.0,8.0,min(lightSource.x,lightSource.y))),50.0);  \n\t\t\n\t\t//fluroescentCeiling shining\n\t\tlightSource = abs(mod(position.xz-vec2(10.0),vec2(4.0))-vec2(2.0));\n\t\tfloat whiteIntensity = smoothstep(9.9,10.0,position.y)*(1.0 - smoothstep(1.0,2.5,lightSource.y))*(1.0 - smoothstep(1.0,2.5,lightSource.x));\n\t\t\t\n\t\tvec3 lightShine = max(0.0,blueIntensity)*vec3(0.0,0.1,0.5)+vec3(1.0)*max(whiteIntensity,0.0);\n\t\t\n#ifndef SUBJETIVE_CAMERA\n\n\t\t//Render Spark on the subjective Camera position\n\t\tfloat fwdSparkDist = AnaliticalDistSpark(prevCamPosition,prevRayDir,worldCameraPos,dist); \n\t\tfloat ptlSparkDist = AnaliticalDistSpark(camPosition,rayDir,worldCameraPos,localDist);\n\t\t\t\t\n\t\tfinalcolor += attenuation*vec3(pow(max(smoothstep(4.0,0.0,min(fwdSparkDist,ptlSparkDist)),0.0),80.0));\n\t\t\n#ifdef SPARK_ILUMINATION\n\t\t//Spark ilumination\n\t\tvec3 lightDir2 \t= worldCameraPos - position;\n\t\tfloat diffuse2  = smoothstep(5.0,1.0,length(lightDir2))*max(dot(normal,normalize(lightDir2)),0.0);\n\t\tdiffuseColor += diffuse2*materialColor.rgb;\t\t\n#endif\n\t\t\n#endif\n\t\t//mixing lights\n\t\tfinalcolor += attenuation*(lightShine + mix(mix(ambientColor,occlusion*diffuseColor,0.8),portalColor.xyz,portalColor.w));\n\t\t\n\t\t// prepare next ray for reflections \n\t\trayDir = reflDir;\n\t\tattenuation *= 2.0*materialColor.w;\n\t\tcamPosition = position + EPSILON*normal;\n\t}\n\t\n\t// saturate\n\tfinalcolor = min(finalcolor,vec3(1.0));\n\t\n\t// desaturation, gamma correction and simple vignette\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\tfloat introTransition = smoothstep(FADE_IN_START,FADE_IN_END,iTime); \n\tfinalcolor *= introTransition*mix(1.0,0.0,smoothstep(0.7,2.0,length(puv)));\n\t\n    fragColor = vec4( finalcolor,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldB3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2870, 2922, 2939, 2958, 5423], [5425, 5486, 5577, 5787, 6318], [6320, 6320, 6372, 6372, 6679], [6681, 6681, 6716, 6716, 7573], [7575, 7627, 7711, 7711, 7872], [7874, 7874, 7920, 7920, 7969], [7971, 7971, 8000, 8000, 8051], [8053, 8053, 8077, 8077, 8282], [8284, 8324, 8592, 8592, 9472], [9474, 9474, 9535, 9535, 9598], [9600, 9600, 9731, 9731, 11572], [11574, 11574, 11630, 11630, 11913], [11915, 11915, 11988, 11988, 12372], [12374, 12374, 12411, 12411, 12652], [12654, 12703, 12746, 12776, 13311], [13313, 13383, 13402, 13402, 13674], [13676, 13676, 13708, 13708, 13884], [13886, 13932, 13984, 13984, 14299], [14301, 14335, 14392, 14423, 18976]], "test": "ok"}
{"id": "ldB3Dt", "name": "wobbly thing", "author": "avix", "description": "goofing some more...", "tags": ["procedural", "3d", "weird"], "likes": 45, "viewed": 9539, "published": "Public", "date": "1395033780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FARCLIP    35.0\n\n#define MARCHSTEPS 60\n#define AOSTEPS    8\n#define SHSTEPS    10\n#define SHPOWER    3.0\n\n#define PI         3.14\n#define PI2        PI*0.5    \n\n#define AMBCOL     vec3(1.0,1.0,1.0)\n#define BACCOL     vec3(1.0,1.0,1.0)\n#define DIFCOL     vec3(1.0,1.0,1.0)\n\n#define MAT1       1.0\n\n#define FOV 1.0\n\n\n/***********************************************/\nfloat rbox(vec3 p, vec3 s, float r) {\t\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\n}\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat cylinder(vec3 p, vec2 h) {\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n/***********************************************/\nvoid oprep2(inout vec2 p, float l, float s, float k) {\n\tfloat r=1./l;\n\tfloat ofs=s+s/(r*2.0);\n\tfloat a= mod( atan(p.x, p.y) + PI2*r*k, PI*r) -PI2*r;\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n\tp.x+=ofs;\n}\n\nfloat hash(float n) { \n\treturn fract(sin(n)*43758.5453123); \n}\n\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*113.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat sminp(float a, float b) {\n    const float k=0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/***********************************************/\n\nvec2 DE(vec3 p) {\n    \n    //distortion\n    float d3=noise3(p*2.0 + iTime)*0.18;\n    //shape\n    float h=torus(p, vec2(3.0,1.5)) -d3;\n    float h2=torus(p, vec2(3.0,1.45)) -d3;\n        vec3 q=p.yzx; p.yz=q.yx;\n        oprep2(p.xy,32.0,0.15, 0.0);\n        oprep2(p.yz,14.0,0.15, 0.0);\n        float flag=p.z;\n        float k=rbox(p,vec3(0.05,0.05,1.0),0.0) ;\n        if (flag>0.1) k-=flag*0.18; else k-=0.01 ;\n\n    //pipes\n    p=q.zyx;\n\n    oprep2(p.xy,3.0,8.5, 3.0);\n    oprep2(p.xz,12.0,0.25, 0.0);\n        \n    p.y=mod(p.y,0.3)-0.5*0.3;\n    float k2=rbox(p,vec3(0.12,0.12,1.0),0.05) - 0.01;\n\n    p=q.xzy;\n    float r=p.y*0.02+sin(iTime)*0.05;\n        oprep2(p.zy,3.0,8.5, 0.0);\n    float g=cylinder(p,vec2(1.15+r,17.0)) - sin(p.y*1.3 - iTime*4.0)*0.1 -d3;\n    float g2=cylinder(p,vec2(1.05+r,18.0)) - sin(p.y*1.3 - iTime*4.0)*0.1 -d3;\n\n      float tot=max(h,-h2);\n      float sub=max(g,-g2);\n        float o=max(tot,-g);\n        float i=max(sub,-h);\n        \n            o=max(o,-k);\n            i=max(i,-k2);\n      \n      tot=sminp(o,i);\n\n\treturn vec2( tot*0.9 , MAT1);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcAO(vec3 p, vec3 n ){\n\tfloat ao = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i=0; i<AOSTEPS; i++) {\n        \tfloat h = 0.01 + 1.2*pow(float(i)/float(AOSTEPS),1.5);\n        \tfloat dd = DE( p+n*h ).x;\n        \tao += -(dd-h)*sca;\n        \tsca *= 0.65;\n    \t}\n   return clamp( 1.0 - 1.0*ao, 0.0, 1.0 );\n //  return clamp(ao,0.0,1.0);\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 1.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.02*SHPOWER;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n/***********************************************/\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -15.0);\n\tvec3 lig=normalize(vec3(2.3, 3.0, 0.0));\n\t\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n//\trot(ro,vec3(mp.x,mp.y,0.0));\n//\trot(lig,vec3(mp.x,mp.y,0.0));\n\t\n    float a=iTime*0.5;\n    float b=sin(iTime*0.25)*0.75;\n\trot(ro,vec3(a,b,0.0));\n\trot(lig,vec3(a,b,0.0));\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\n\n\tvec3 col=vec3(0.0);\n\t/* trace */\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\t\t\n        if( abs(r.x)<0.00 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n\t/* draw */\n\tif( r.x<FARCLIP ) {\n\t    vec2 rs=vec2(0.2,1.0);  //rim and spec\n\t\tif (r.y==MAT1) { col=vec3(0.29,0.53,0.91);  } \n\n\t\tvec3 nor=normal(ww);\n\n    \tfloat amb= 1.0;\t\t\n    \tfloat dif= clamp(dot(nor, lig), 0.0,1.0);\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\n    \tfloat rim= pow(1.+dot(nor,rd), 3.0);\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.5, 1.0 ) ,16.0 );\n    \tfloat ao= calcAO(ww, nor);\n    \tfloat sh= calcSh(ww, lig, 0.01, 2.0, 4.0);\n\n\t    col *= 0.5*amb*AMBCOL*ao + 0.4*dif*DIFCOL*sh + 0.05*bac*BACCOL*ao;\n\t    col += 0.3*rim*amb * rs.x;\n    \tcol += 0.5*pow(spe,1.0)*sh * rs.y;\n        \n\t}\n\t\n\tcol*=exp(.08*-r.x); col*=2.0;\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldB3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 373, 410, 410, 461], [462, 462, 491, 491, 560], [561, 561, 593, 593, 645], [647, 697, 751, 751, 903], [905, 905, 926, 926, 967], [969, 969, 991, 991, 1393], [1395, 1395, 1426, 1426, 1542], [1545, 1596, 1613, 1635, 2670], [2671, 2721, 2742, 2742, 2888], [2889, 2939, 2969, 2969, 3269], [3270, 3320, 3381, 3381, 3595], [3596, 3646, 3679, 3679, 3907], [3908, 3958, 4015, 4015, 5526]], "test": "ok"}
{"id": "ldBGDc", "name": "look me in the eyes", "author": "FabriceNeyret2", "description": "look at the center for 1 minute, then press SPACE\n\nT: toggles rotation direction     S: stop/go\n2: 2 spirals (mouse location)   R: reverse orientation   T : opposite rotation\n", "tags": ["illusion", "short"], "likes": 53, "viewed": 4332, "published": "Public API", "date": "1394276968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t;\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nfloat spiral(vec2 m) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n\tfloat v = sin(100.*(sqrt(r)-0.02*a-.3*t));\n\treturn clamp(v,0.,1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tt = iTime;\n    if (keyToggle(84)) t=-t; // 'T'\n\tif (keyToggle(83)) t=0.; // 'S'\n\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\t\n\tvec2 m = iMouse.xy/ iResolution.y;\n\tif ((length(m)==0.) || (iMouse.z<0.)) m = vec2(.9,.5);\n\n\tfloat v = spiral(m-uv);\n\tif (keyToggle(50)) {     // '2'\n\t\tm = vec2(.9,.5);\n\t\tif (!keyToggle(82)) uv.y = 1.-uv.y;  // 'R'\n\t\tif (!keyToggle(84)) t = -t;          // 'T'\n\t\tv += (1.-v)*spiral(m-uv);\n\t}\n\n\tuv = fragCoord.xy / iResolution.xy;\n\tvec3 col = (keyToggle(32)) ? texture(iChannel0,1.-uv).rgb : vec3(v);\n\t\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 36, 36, 109], [111, 111, 133, 133, 253], [255, 255, 312, 312, 869]], "test": "ok"}
{"id": "ldfXRr", "name": "Hyborian Age", "author": "cedric", "description": "use and abuse of perlin noise^^\ni learned and stole from many shaders here and iq's website. Thanks to all !", "tags": ["procedural", "3d", "terrain", "perlin"], "likes": 17, "viewed": 644, "published": "Public", "date": "1396281229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n//\n// Hyborian Age by cedric voisin 2014\n//\n//\n\n// comment to stop cam motion or night/day cycle\n#define CAM_MOTION\n#define NIGHT_AND_DAY\n\n// in case you turn off day/night cycle, you can choose the hour of the day\n// 0.=dawn, pi/2=noon, pi=dusk, 3pi/2=midnight\n#define dayTimeOrigin .2\n\n// what you see\n#define maxHeight 5.\n#define swampHeight .15\n#define fov 30.\n#define screenWidth 10.\n#define camFocal 10.\n#define camTilt (-.2)\n\n// perf\n#define iLowRes 6\n#define iHighRes 6\n\n// global\nint idI;\n#define idBackground 0\n#define idField 1\n#define idSwamp 2\n#define idSky 3\n#define idClouds 4\n#define idSphere 5\n\nvec3 pCam, nCam, uCam, rCam, pEye;\nfloat thetaCam, phiCam, fCam, rSky;\n\nfloat time;\n#define PI 3.14\n\n//\n// setup routines\n//\n\nvec2 globalSetup(vec2 fragCoord){\n\tvec2 pct = fragCoord.xy / iResolution.xy;\n\tvec2 xy = -screenWidth/2.+screenWidth*pct;\n\txy.y *= iResolution.y/iResolution.x;\n\treturn xy;\n}\n\nvoid setupCam(vec3 p, float thetaCam, float phiCam, float f){\n\tpCam = p;\n\tfCam = f;\n\tnCam = vec3(cos(thetaCam)*cos(phiCam),cos(thetaCam)*sin(phiCam),sin(thetaCam));\n\tuCam = vec3(cos(thetaCam+PI/2.)*cos(phiCam),cos(thetaCam+PI/2.)*sin(phiCam),sin(thetaCam+PI/2.));\n\trCam = cross(nCam,uCam);\n\tpEye = pCam - fCam*nCam;\n}\n\n//\n// perlin\n//\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = screenWidth/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\n//\n// objects\n//\n\n// field(x,y)\nfloat field(vec2 p, int res){\n\tfloat z = maxHeight*pNoise(p, res);\n\treturn z;\n}\n\nfloat iField(vec3 pStart, vec3 dir, int res){\n\tvec3 p = pStart;\n\tfloat s = 0.;\n\tfloat h = 1.;\n\tfor (int i=0; i<250; i++){\n\t\th = p.z - field(p.xy, res);\n\t\tif (h<.1 || length(dir*s) > fov) break;\n\t\ts+=0.1*h;\n\t\tp=pStart+dir*s;\n\t}\n\tif (h >= .1) s = -1.;\n\treturn s;\n}\n\nvec3 nField(vec3 p, int res){\n\tvec2 dp = vec2(.0001,0.);\n\tvec3 dpx = vec3(2.*dp.x, 0., field(p.xy+dp.xy,res)-field(p.xy-dp.xy,res));\n\tvec3 dpy = vec3(0., 2.*dp.x, field(p.xy+dp.yx,res)-field(p.xy-dp.yx,res));\n\treturn normalize(cross(dpx,dpy));\n}\n\n// Swamp\nfloat iSwamp(vec3 pStart, vec3 dir){\n\tfloat s=(swampHeight-pStart.z)/dir.z;\n\tif (length(dir*s) > fov) s=-1.;\n\treturn s;\t\n}\n\n// clouds\nfloat iClouds (vec3 pStart, vec3 dir){\n\tfloat zClouds=15.;\n\tfloat s=(zClouds-pStart.z)/(dir.z+zClouds/fov);\n\tif (length(dir*s) > fov) s=-1.;\n\treturn s;\t\n}\n\n// Sky\nfloat iSky (vec3 dir){\n\tfloat s;\n\tvec3 d = pEye;\n\tfloat B = dot(dir,d);\n\tfloat C = length(d)*length(d)-rSky*rSky;\n\tfloat det2=B*B-C;\n\tif(det2>=0.){\n\t\ts = max(-B+sqrt(det2),-B-sqrt(det2));\n\t} else {\n\t\ts = -1.;\n\t}\n\treturn s;\n}\n\n//\n// routines\n//\n\nfloat shadows(vec3 pi, vec3 pSun) {\n\tfloat L=distance(pi, pSun)/10.;\n\tvec3 dpds=normalize(pSun-pi);\n\t\n\tconst int ni=20;\n\tfloat n=float(ni);\t\n\t\n\tfloat s=0.;\n\tfloat iShad = 1.;\n\t\n\tfor (int i=0;i<ni;i++){\n\t\tvec3 pt = pi+dpds*s;\n\t\tfloat h = pt.z - field(pt.xy, iHighRes);\n\t\ts+=L/n;\n\t\tif(h < 0.5) iShad*=.9;\n\t}\n\t\n\treturn iShad;\n}\n\nvec3 clouds(vec3 p, vec2 wind, vec3 colSky, vec3 colClouds, vec2 fragCoord){\n\tfloat grad=clamp(1.5-fragCoord.y / iResolution.y,0.,1.);\n\tvec2 stretch = vec2 (3.,1.);\n\treturn grad*mix(colSky, colClouds,field(.1*(p.xy+wind)*stretch,5));\n}\n\nfloat intersection(vec3 p, vec3 d, vec3 pLight, int res){\n\tfloat sit = 1000.*fov;\n\t\n\tidI = idBackground;\n\tfloat si = sit;\n\t\n\tsit = min(iField(p, d, res), si);\n\t\tif (sit >= 0. && sit < si){\n\t\tidI = idField;\n\t\tsi = sit;\n\t}\n\t\n\tsit = min(iSwamp(p, d), si);\n\t\tif (sit >= 0. && sit < si){\n\t\tidI = idSwamp;\n\t\tsi = sit;\n\t}\n\t\n\tsit = min(iClouds(p, d), si);\n\t\tif (sit >= 0. && sit < si){\n\t\tidI = idClouds;\n\t\tsi = sit;\n\t}\n\n\treturn si;\n}\n\n//\n// at last :-)\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // constants\n    time = iTime;\n    //\n    \n\tvec2 xy = globalSetup(fragCoord);\n\tfloat si;\n\t\n\t// time\n\tfloat camTime = 0.;\n\tfloat dayTime = dayTimeOrigin;\n\t#ifdef CAM_MOTION\n\t\tcamTime = .03*time;\n\t#endif\n\t#ifdef NIGHT_AND_DAY\n\t\tdayTime = .2*time+dayTimeOrigin;\n\t#endif\n\t\n\t// cam\n\tfloat zoCam = swampHeight + screenWidth*iResolution.y/iResolution.x;\n\tfloat camOrbit = 100.;\n\tfloat xCam = camOrbit*sin(camTime);\n\tfloat yCam = -camOrbit*cos(camTime);\n\tsetupCam(vec3 (xCam,yCam,zoCam),camTilt,camTime,camFocal);\n\t\n\t// sun\n\tfloat sunOrbit=2.*camOrbit;\n\trSky = sunOrbit;\n\tvec3 pSun = vec3(1.5*sunOrbit*sin(dayTime),sunOrbit*cos(dayTime),sunOrbit*sin(dayTime));\n\t\n\t// wind\t(speed)\n\tvec2 wind = vec2 (1.,-5.);\n\t\n\t// virtual screen\n\tvec3 pStart = pCam+xy.x*rCam+xy.y*uCam;\n\tvec3 dir = normalize(pStart-pEye);\n\t\n\t// ray march\n\tsi = intersection(pStart, dir, pSun, iLowRes);\n\tvec3 pi = pStart + dir*si;\n\tvec3 nor = nField(pi, iHighRes);\n\tvec3 norLowRes = nField(pi, iLowRes);\n\t\n\t// colors\n\tvec3 col = vec3(0.,0.,0.);\n\tvec3 colSky = vec3(.2,.5,1.);\n\tfloat redishClouds = pow(1.2-abs(pSun.y/sunOrbit),.5);\n\tvec3 colClouds = vec3(1.,1.*redishClouds,.9*redishClouds);\n\tvec3 colSun = vec3 (1.,1.,.7);\n\tvec3 colGrass = vec3(.1,.4,.1);\n\tvec3 colMountain = vec3(.7,.6,.5);\n\tvec3 colFog = vec3(.5,.6,.7);\n\tvec3 colField = colMountain;\n\tif (nor.z > .8) colField = colGrass;\n\t\n\t// night and day corrections\n\tcolSky*=smoothstep(-1.2,1.,sin(dayTime));\n\tcolFog*=smoothstep(-1.2,1.,sin(dayTime));\n\t\n\t// illuminations\n\tif (idI == idBackground){ // in principle, never used here\n\t\tfloat cBg=clamp(1.5-fragCoord.y / iResolution.y,0.,1.);\n\t\tcol += cBg*colSky;\n\t\tcol = mix (colSky, vec3(1.,1.,1.),field(xy,7));\n\t}\n\t\n\tif (idI == idField){\n\t\tfloat iShad = shadows(pi, pSun);\n\t\tfloat iSpec=.5+.5*dot(nField(pi, iHighRes),normalize(pSun-pi));\n\n\t\t// AO\n\t\tvec3 p;\n\t\tfloat sAmb=0.;\n\t\tfloat iAmb = 1.;\n\t\tfor (int i=0;i<5;i++) {\n\t\t\tfloat h = p.z - field (p.xy, iLowRes);\n\t\t\tif (h < sAmb) iAmb*=.8;\n\t\t\tsAmb+=float(i)*.2;\n\t\t\tp = pi + norLowRes*sAmb;\n\t\t}\n\n\t\tcol += .2*iSpec*colSun;\n\t\tcol += .2*nor.z*colSky;\n\t\tcol += iSpec*colField;\n\t\tcol *=iShad;\n\t\tcol *=iAmb;\n\t\tcol += .4*iSpec*colField*smoothstep(-.3,1.,sin(dayTime+PI)); // night light\n\t\t\n\t\tcol = smoothstep(0.,1.2,col);\n\t}\n\t\n\tif (idI == idSwamp){\t\t\n\t\tfloat iShad = shadows(pi, pSun);\n\t\t\n\t\t// clouds for fake reflection\n\t\tcol += clouds(pi, wind*time, colSky, colClouds, fragCoord);\n\t\t\n\t\t// moisture\n\t\tcol += 3.*mix (vec3(0.,.1,0.), vec3(.4,.7,.4),20.*pNoise(pi.xy,7));\n\t\t\n\t\t// foam\n\t\tcol += 1.*mix (vec3(0.,0.,0.), vec3(.9,1.,.9),pNoise(5.*pi.xy,7));\n\t\t\n\t\tcol *= iShad;\n\t\tcol = smoothstep(0.,3.,col);\n\t}\n\n\tif (idI == idClouds){\n\t\t// clouds\n\t\tvec3 colCloudsInSky = clouds(pi, wind*time, colSky, colClouds, fragCoord);\n\t\t\n\t\t// sky (sphere)\n\t\tfloat siSky = iSky(dir);\n\t\tvec3 piSky = pStart + dir*siSky;\n\t\tfloat theta = acos(piSky.z/rSky);\n\t\tfloat phi = abs(atan(piSky.y, piSky.x)); // symmetric sky because perlin(2pi)!=perlin(0)\n\t\tvec3 colSkySphere = mix(colSky, vec3(.05,.1,.3),field(20.*vec2(theta, phi),7));\n\t\t\n\t\t// stars\n\t\tfloat pN = pNoise(2000.*vec2(theta, phi),5);\n\t\tcolSkySphere += mix(colSky, vec3(1.,1.,1.),pN);\n\n\t\tcol = mix(colCloudsInSky, colSkySphere, smoothstep(-.5,2.,sin(dayTime+PI)));\n\t}\n\t\n\t// fog\n\tfloat cFog = 1.-smoothstep(.3*fov, fov, length(dir*si))+smoothstep(fov+1., fov+2.,length(dir*si));\n    col = mix(colFog, col, cFog );\n\n\tcol = clamp(col,0.,1.);\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[716, 741, 774, 774, 913], [915, 915, 976, 976, 1232], [1234, 1251, 1270, 1270, 1338], [1340, 1340, 1373, 1373, 1743], [1745, 1745, 1775, 1775, 2064], [2084, 2098, 2127, 2127, 2177], [2179, 2179, 2224, 2224, 2441], [2443, 2443, 2472, 2472, 2688], [2690, 2699, 2735, 2735, 2821], [2823, 2833, 2871, 2871, 2987], [2989, 2996, 3018, 3018, 3220], [3222, 3241, 3276, 3276, 3565], [3567, 3567, 3643, 3643, 3802], [3804, 3804, 3861, 3861, 4229], [4231, 4253, 4310, 4327, 7726]], "test": "ok"}
{"id": "ldfXzn", "name": "Diamonds are Forever", "author": "Nrx", "description": "A bunch of diamonds. Just because a friend asked me :).", "tags": ["raymarching", "transparency"], "likes": 41, "viewed": 2246, "published": "Public API", "date": "1395743430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t5\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define REFRACT_FACTOR\t\t0.6\n#define REFRACT_INDEX\t\t1.2 // 2.417 for real diamonds... but it would require RAY_COUNT to be increased (because of total internal reflections)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define FADE_POWER\t\t\t1.0\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n#define GLOW_FACTOR\t\t\t0.5\n#define LUMINOSITY_FACTOR\t2.0\n\n//#define ATAN2 // Comment this to use the original atan function\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n#ifndef ATAN2\n#define atan2 atan\n#else\nfloat atan2 (in float y, in float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\t// atan (x) = x / (1 + 0.28086 x^2)\n\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n\nfloat atan2_nobranch (in float y, in float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\t// atan (x) = x / (1 + 0.28086 x^2)\n\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tfloat t4 = M_PI / 2.0 - t3;\n\tt3 = step (0.0, t2 - t1) * (t3 - t4) + t4;\n\tt4 = M_PI - t3;\n\tt3 = step (0.0, x) * (t3 - t4) + t4;\n\tt3 = step (0.0, y) * (t3 + t3) - t3;\n\treturn t3;\n}\n#endif\n\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.8));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.6));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 2.0));\nvec3 k;\nfloat getDistance (in vec3 p) {\n\tfloat repeat = 20.0;\n\tvec3 q = p + repeat * 0.5;\n\tk = floor (q / repeat);\n\tq -= repeat * (k + 0.5);\n\tp = mRotate (k + iTime) * q;\n\n\tfloat topCut = p.y - 1.1;\n\tfloat angleStep = M_PI / max (1.0, abs (4.0 + k.x + 2.0 * k.y + 4.0 * k.z));\n\tfloat angle = angleStep * (0.5 + floor (atan2 (p.x, p.z) / angleStep));\n\tq = vRotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat bottomA = dot (q, normalBottomA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.8;\n\tq = vRotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan2 (q.x, q.z) / angleStep);\n\tq = vRotateY (p, angle);\n\tfloat bottomB = dot (q, normalBottomB) - 1.95;\n\tfloat topB = dot (q, normalTopB) - 1.92;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\n\tvec3 lightDirection = normalize (LIGHT);\n\tvec2 delta = vec2 (DELTA, 0.0);\n\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\n\tfloat intensity = 1.0;\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\trayLength += distMin;\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t\t++rayStepCount;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\n\t\tif (dist >= 0.0) {\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\n\n\t\t// Basic lighting\n\t\tvec3 reflection = reflect (direction, normal);\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\n\t\t\tlocalColor = mix (backColor, localColor, fade);\n\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\n\t\t\tintensity *= REFRACT_FACTOR;\n\t\t}\n\n\t\t// Next ray...\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflection;\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t\trefractionRatio = 1.0 / refractionRatio;\n\t\t}\n\t}\n\n\t// Return the fragment color\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Set the fragment color\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 592, 622, 622, 949], [951, 951, 994, 994, 1102], [2451, 2451, 2482, 2482, 3244], [3246, 3246, 3305, 3305, 5604], [5606, 5606, 5662, 5713, 6305]], "test": "ok"}
{"id": "ldj3WK", "name": "Pulsing Creature Loves Worlds", "author": "vug", "description": "My first ray marching study. iq's codes from his apple tutorial (for ray marching) and this presentation (for combinations of distance functions) http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf are shamelessly stolen.", "tags": ["3d", "raymarching"], "likes": 9, "viewed": 571, "published": "Public", "date": "1393749197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n// smooth min from, guess who? Yes, from iq. :-)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat creatureShape( vec3 p ) {\n\tfloat rr = dot(p.xz, p.xz);\n\tfloat r = sqrt(rr);\n\tfloat dist = 10000.0;\n\tconst int nTentacle = 3;\n\tfor(int i=0; i<nTentacle; i++){\n\t\tfloat ii = float(i);\n\t\tfloat th = ii * TWO_PI / float(nTentacle);\n\t\t// bend the veins, comment out to make the shader faster\n\t\tth += 0.1*(0.3*sin(r*2.1+ii)*.5+sin(r*4.3+ii+2.0)*.75+sin(r*6.7+9.3+ii)*.125);\n\t\t// q.x, qz: to set the direction of each tentacle\n\t\t// q.y: to embrace the sphere\n\t\tvec3 q = vec3( cos(th)*p.x - sin(th)*p.z, p.y+0.9*sin(0.5*rr+3.*PI/2.), sin(th)*p.x + cos(th)*p.z );\n\t\tq.y += 0.6;\n\t\t// vein radius\n\t\tfloat radius = (0.5)/(rr*r+1.0);\n\t\t// pumps\n\t\tfloat bulge = mod(2.5*iTime+float(2*i), 8.);\n\t\tradius += 0.12*(smoothstep(bulge, bulge+0.3,r) - smoothstep(bulge+0.5, bulge+0.8,r))/r;\n\t\t// cylinder distance function\n\t\tfloat newDist = length(vec3(0.0,q.y,q.z))-radius;// - 0.1*smoothstep(2.0, 3.0, rr);\n\t\tnewDist = max(newDist, abs(q.x) - 2.0);\n\t\t// union all veins\n\t\tdist = smin(dist, newDist, 0.15 );\n\t\t// add the head/hearth with a sphere\n\t\tfloat distToBall = length(p-vec3(0.0,0.55,0.0))-0.2-0.3*sin(clamp(sin(iTime*7.0),0.0,1.0)+1.0);\n\t\tdist = smin(dist, distToBall, 0.15);\n\t\t// smooth out the feets\n\t\tdist = smax(dist, -p.y-1., 0.25);\n\t}\n\treturn dist;\n}\nvec3 creatureMaterial(vec3 pos, vec3 nor) {\n\tvec3 col = vec3(1.0, 0.1, 0.02);\n\tcol -= 0.25*texture( iChannel0, pos.xz ).x;\n\n\tfloat ao = 0.5 + 0.5*nor.y;\n\tcol *= ao;\n\n\treturn col;\t\n}\n\nfloat floorShape( vec3 pos ) {\n\treturn length(pos-vec3(0.0,-1.5,0.0))-2.;// + .5 + 0.01*sin(5.*pos.x)*sin(3.*pos.z);\n}\nvec3 floorMaterial(vec3 pos, vec3 nor) {\n\tvec3 col = vec3(0.6, 0.5, 0.2);\n\tvec2 q = vec2( length(pos.xy), atan(pos.y, pos.x) );\n\t\n\t//col = mix( col, texture(iChannel1, 0.1*pos.xz).x, 0.7);\n\tvec3 lands = mix( col, vec3(.1,2.2,.5)*texture(iChannel1, vec2(0.4/length(pos.xz), 0.4*atan(pos.z, pos.x))).xyz, 0.85);\n\tvec3  seas = smoothstep(0.25, 0.26, texture(iChannel2, 0.03*pos.xz+vec2(0.6,0.002)).xxx);\n\tcol = vec3(0.1,0.1,1.0)*seas + (1.0-seas)*lands;\n\tfloat ao = 0.1 + 0.9*smoothstep(0.4, 2.0, length( pos.xz ));\n\tcol *= ao;\n\treturn col;\t\n}\n\n\n// returns the smallest distance value and its ID\nvec2 map(vec3 p) {\n\tvec2 d = vec2(10000.0, -1.);\n\tvec2 d1 = vec2( creatureShape(p), 1. );\n\tif( d1.x < d.x ) d = d1;\n\tvec2 d2 = vec2( floorShape(p), 2. );\n\tif( d2.x < d.x ) d = d2;\n\treturn d;\n}\n\nvec3 calcNormal( vec3 p ) {\n\t// calculating the gradient.\n\t// evaluate the the distance function just below and above the surface\n\t// and take their difference.\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\tvec3 n;\n\tn.x = map(p+e.xyy).x - map(p-e.xyy).x;\n\tn.y = map(p+e.yxy).x - map(p-e.yxy).x;\n\tn.z = map(p+e.yyx).x - map(p-e.yyx).x;\t\n\treturn normalize( n );\n}\n\nfloat softShadow( vec3 ro, vec3 rd ) {\n\tfloat res = 1.0;\n\t// for some reason I had to start t at 1.0 instead of 0.1\n\t// to get the same shadow effect. Otherwise the shadow were too small.\n\tbool hit = false;\n\tfloat t=0.2;\n\tfor( int i=0; i<50; i++ ) {\n\t\tif(!hit) {\n\t\t\tfloat h = map(ro+t*rd).x;\n\t\t\tif(h<0.01) {\n\t\t\t\thit = true; //(?)\n\t\t\t\tres = 0.0;\n\t\t\t}\n\t\t\tres = min( res, 8.0*h/t );\n\t\t\tt += h;\n\t\t\tif(t>5.0) hit = true;\n\t\t}\n\t}\n\treturn res;\n}\n\nfloat softShadowBreak( vec3 ro, vec3 rd ) {\n\tfloat res = 1.0;\n\t// for some reason I had to start t at 1.0 instead of 0.1\n\t// to get the same shadow effect. Otherwise the shadow were too small.\n\tfloat t=0.2; \n\tfor( int i=0; i<50; i++ ) {\n\t\tfloat h = map(ro+t*rd).x;\n\t\tif(h<0.01) return 0.0;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += h;\n\t\tif(t<5.0) break;\n\t}\n\treturn res;\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n\t// instead of \"for(float=0.0; t<6.0)\" which gave error\n\t// also \"while\" does not work too.\n\tbool hit = false;\n\tvec2 res = vec2(0.0);\n\tfloat t=0.0;\n\tfor( int i=0; i<50; i++ ) {\n\t\tif(!hit) {\n\t\t\tvec2 h = map( ro+t*rd ); // h.x: smallest distance, h.y: ID\n\t\t\tif(h.x<0.01) { // if close enough to an object\n\t\t\t\tres = vec2(t, h.y);\n\t\t\t\thit = true;\n\t\t\t}\n\t\t\tif(t>5.0) {\n\t\t\t\thit = true;\n\t\t\t\tres = vec2(0.0);\n\t\t\t}\n\t\t// the step size for ray marching is the distance to closes object.\n\t\t// A safe bet! This is called \"raymarching distance fields\"\n\t\t\tt += h.x; \n\t\t}\n\t}\n\treturn res;\n}\n\nvec2 intersectBreak(vec3 ro, vec3 rd) {\n\t// instead of \"for(float=0.0; t<6.0)\" which gave error\n\t// also \"while\" does not work too.\n\tfloat t=0.0;\n\tfor( int i=0; i<50; i++ ) {\n\t\tvec2 h = map( ro+t*rd ); // h.x: smallest distance, h.y: ID\n\t\tif(h.x<0.01) return vec2(t, h.y); // if close enough to an object\n\t\t// the step size for ray marching is the distance to closes object.\n\t\t// A safe bet! This is called \"raymarching distance fields\"\n\t\tt += h.x; \n\t\tif(t>5.0) break;\n\t}\n\treturn vec2(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = (-1.0+2.0*q)*vec2(1.77,1.0);\n\n\tvec3 ro = 3.*vec3( cos(iTime*0.3), 0.6+0.4*sin(0.99*iTime), sin(iTime*0.3) );\n\t//vec3 ro = 2.3*vec3( cos(iTime*0.3), 0.01, sin(iTime*0.3) );\n\n\tvec3 target = vec3(0.0, -0.5, 0.0);\n\tvec3 ww = normalize( target - ro );\n\tvec3 uu = normalize( cross(vec3(0.0, 1.0, 0.0), ww) );\n\tvec3 vv = normalize( cross(ww, uu) );\n\tvec3 rd = normalize( p.x*uu + p.y*vv +1.5*ww );\n\n\tvec2 t = intersect( ro, rd );\n\tvec3 col = vec3(0.5, 0.7, 0.99);\n\tif( t.y > 0.5 ) {\n\t\tvec3 pos = ro + t.x*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\tvec3 lig = normalize( vec3(0.0, 0.9, 0.6) );\n\t\tvec3 blig = vec3( -lig.x, lig.y, -lig.z);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\tfloat dif = max(0.0, dot(nor, lig) );\n\t\tfloat bac = max(0.0, 0.2+0.8*dot(nor,blig) );\n\t\tfloat sha = softShadow(pos, lig);\n\t\tfloat spe = pow(clamp( dot(lig, ref), 0.0, 1.0), 8.0);\n\t\tfloat rim = pow( 1.0 + dot(nor, rd), 2.5);\n\t\t\n\t\tcol += amb*vec3(0.1, 0.15, 0.2);\n\t\tcol += dif*vec3(1.0, 0.97, 0.85)*sha;\n\t\tcol += bac*vec3(1.0, 0.97, 0.85);\n\t\t\n\t\tif(t.y > 1.5 && t.y < 2.5) {\n\t\t\tcol *= floorMaterial(pos, nor);\n\t\t}\n\t\telse {\n\t\t\tcol *= creatureMaterial(pos, nor);\n\t\t\tcol += 0.6*spe*sha*amb;\n\t\t}\n\t\tcol += 0.6*rim*amb;\n\t\t//col += 0.6*spe*sha*amb;\n\t\t//col += 1.0*pow(spe, 1.0);\n\t\t\n\t\tcol = 0.82*sqrt(col);\t\n\t}\n\t\n\tcol *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2); //different kind of vignette\t\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldj3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 104, 145, 145, 238], [239, 239, 280, 280, 373], [375, 375, 406, 406, 1622], [1623, 1623, 1666, 1666, 1804], [1806, 1806, 1836, 1836, 1924], [1925, 1925, 1965, 1965, 2465], [2468, 2518, 2536, 2536, 2710], [2712, 2712, 2739, 2872, 3061], [3063, 3063, 3101, 3101, 3500], [3502, 3502, 3545, 3545, 3867], [3869, 3869, 3903, 3995, 4476], [4478, 4478, 4517, 4609, 4970], [4972, 4972, 5029, 5029, 6497]], "test": "ok"}
{"id": "ldjGDt", "name": "Bouncing Heart", "author": "Nihilus", "description": "An heart (cardioid) made with GLSL, an example and test.", "tags": ["test", "example", "newbe"], "likes": 2, "viewed": 205, "published": "Public", "date": "1395327079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//20/03/2014 - Click on the shader to activate a different cardioid shape\n//26/03/2014 - Added a basic border smoothing, enable it with the SMOOTH define\n\n#define SMOOTH true\n\nfloat s_mask(vec2 p, float s) {\n\tfloat fw = fwidth(s);\n\treturn smoothstep(-fw, fw, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-1.0 + 2.0*fragCoord.xy / iResolution.xy)*vec2(iResolution.x/iResolution.y, 1.0);\n\tfloat beat = abs(sin(iTime)) + 0.7;\n\tfloat x = beat*p.x*3.0;\n\tfloat y = beat*p.y*4.0;\n\tfloat b = 1.2;\n\tfloat shape = x*x + pow((y - pow(x*x, 1.0/3.0)), 2.0) - 1.5;\n\t//float shape = pow(x*x+y*y-1.0, 3.0) - (x*x*y*y*y); //smooth not working well\n\t\n\tvec4 bCol = vec4(1.0, 0.65, 0.74, 1.0)*vec4(vec3(1.0 - 0.3*length(p)), 1.0);\n\tvec4 sCol = vec4(0.7, 0.062, 0.23, 1.0);\n\t\n\tif(iMouse.z > 0.0) {\n\t\ty -= 1.0;\n\t\tshape = pow(x*x+y*y+b*y, 2.0) - b*b*(x*x+y*y);\n\t}\n\t\n\tvec4 col = (shape < 0.0) ? sCol : bCol;\n\t\n\tif(SMOOTH) {\n\t\tfloat m = s_mask(p, shape);\n\t\tcol = mix(sCol, bCol, m);\n\t}\n\t\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldjGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 176, 207, 207, 264], [266, 266, 323, 323, 1013]], "test": "ok"}
{"id": "ldS3Wd", "name": "perforations", "author": "ahihi", "description": "original version. ", "tags": ["2d"], "likes": 1, "viewed": 215, "published": "Public API", "date": "1395091778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TAU = 2*PI\n#define TAU 6.283185307179586\n\nvec2 rotate(float theta, vec2 p) {\n\tvec2 polar = vec2(atan(p.y, p.x), length(p));\n\tpolar.x += theta;\n\treturn vec2(polar.y * cos(polar.x), polar.y * sin(polar.x));\n}\n\nvec2 shear(float theta, vec2 p) {\n\treturn vec2(p.x - p.y / tan(theta), p.y / sin(theta));\n}\n\nvec2 unshear(float theta, vec2 p) {\n\tfloat y = p.y * sin(theta);\n\tfloat x = p.x + y / tan(theta);\n\treturn vec2(x, y);\t\n}\n\nvec2 target(float theta, float delta, vec2 p) {\n\treturn unshear(theta, floor(shear(theta, p) + delta) - delta + 0.5);\n}\n\nbool perforations(float theta, float rot, float scale, float r, vec2 p0) {\n\tvec2 p1 = scale * rotate(rot, p0);\n\treturn distance(p1, target(theta, 0.5, p1)) < r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // relative coordinates: -1 ≤ p0.x ≤ 1\n\tvec2 p0 = 2.0*(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n\n    // come up with some magic numbers...\n    \n    // try 4, 2, 1.9999\n\tfloat theta = TAU / 6.0;\n\t\n\tfloat rot1 = 0.01 * TAU * iTime;\n\tfloat rot2 = rot1 + TAU / 12.0 + TAU / 18.0 * sin(0.6 * iTime);\n\t\n\tfloat scale1 = 16.0;\n\tfloat scale2 = 16.0;\n\t\n    // try 0.3\n\tfloat r1 = 0.4;\n\tfloat r2 = 0.4;\n\t\n    // compute mask\n\tbool i1 = perforations(theta, rot1, scale1, r1, p0);\n\tbool i2 = perforations(theta, rot2, scale2, r2, p0);\n\tbool mask = i1 && i2;\n    \n    // choose color depending on mask\n\tvec3 color = mask\n        ? vec3(1.0, 0.0, 1.0 - length(p0))\n        : vec3(0.0, 0.0, 0.0);\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldS3Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 79, 79, 209], [211, 211, 244, 244, 302], [304, 304, 339, 339, 424], [426, 426, 473, 473, 545], [547, 547, 621, 621, 709], [711, 711, 768, 815, 1506]], "test": "ok"}
{"id": "ldS3Wm", "name": "doski canady", "author": "w23", "description": "I cannot describe my shader. Use mouse to move sun around.", "tags": ["3d", "sunset", "clouds", "scattering"], "likes": 226, "viewed": 13072, "published": "Public", "date": "1394219377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License: CC BY 4.0\n\n#define ANIMATE_CLOUDS 0\n\nconst float R0 = 6360e3;\nconst float Ra = 6380e3;\nconst int steps = 128;\nconst int stepss = 8;\nconst float g = .76;\nconst float g2 = g * g;\nconst float Hr = 8e3;\nconst float Hm = 1.2e3;\nconst float I = 10.;\n\n#define t iTime\n\nvec3 C = vec3(0., -R0, 0.);\nvec3 bM = vec3(21e-6);\nvec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6);\nvec3 Ds = normalize(vec3(0., .09, -1.));\n\nfloat noise(in vec2 v) { return textureLod(iChannel0, (v+.5)/256., 0.).r; }\n\n// by iq\nfloat noise(in vec3 v) {\n\tvec3 p = floor(v);\n    vec3 f = fract(v);\n\t//f = f*f*(3.-2.*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat fnoise(in vec3 v) {\n#if ANIMATE_CLOUDS\n\treturn\n\t\t.55 * noise(v) +\n\t\t.225 * noise(v*2. + t *.4) +\n\t\t.125 * noise(v*3.99) +\n\t\t.0625 * noise(v*8.9);\n#else\n\treturn\n\t\t.55 * noise(v) +\n\t\t.225 * noise(v*2.) +\n\t\t.125 * noise(v*3.99) +\n\t\t.0625 * noise(v*8.9);\n#endif\n}\n\nfloat cloud(vec3 p) {\n\tfloat cld = fnoise(p*2e-4);\n\tcld = smoothstep(.4+.04, .6+.04, cld);\n\tcld *= cld * 40.;\n\treturn cld;\n}\n\nvoid densities(in vec3 pos, out float rayleigh, out float mie) {\n\tfloat h = length(pos - C) - R0;\n\trayleigh =  exp(-h/Hr);\n\n\tfloat cld = 0.;\n\tif (5e3 < h && h < 10e3) {\n\t\tcld = cloud(pos+vec3(23175.7, 0.,-t*3e3));\n\t\tcld *= sin(3.1415*(h-5e3)/5e3);\n\t}\n\tmie = exp(-h/Hm) + cld;\n}\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n// this can be explained: http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 scatter(vec3 o, vec3 d) {\n\tfloat L = escape(o, d, Ra);\t\n\tfloat mu = dot(d, Ds);\n\tfloat opmu2 = 1. + mu*mu;\n\tfloat phaseR = .0596831 * opmu2;\n\tfloat phaseM = .1193662 * (1. - g2) * opmu2 / ((2. + g2) * pow(1. + g2 - 2.*g*mu, 1.5));\n\t\n\tfloat depthR = 0., depthM = 0.;\n\tvec3 R = vec3(0.), M = vec3(0.);\n\t\n\tfloat dl = L / float(steps);\n\tfor (int i = 0; i < steps; ++i) {\n\t\tfloat l = float(i) * dl;\n\t\tvec3 p = o + d * l;\n\n\t\tfloat dR, dM;\n\t\tdensities(p, dR, dM);\n\t\tdR *= dl; dM *= dl;\n\t\tdepthR += dR;\n\t\tdepthM += dM;\n\n\t\tfloat Ls = escape(p, Ds, Ra);\n\t\tif (Ls > 0.) {\n\t\t\tfloat dls = Ls / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n\t\t\tfor (int j = 0; j < stepss; ++j) {\n\t\t\t\tfloat ls = float(j) * dls;\n\t\t\t\tvec3 ps = p + Ds * ls;\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\tdensities(ps, dRs, dMs);\n\t\t\t\tdepthRs += dRs * dls;\n\t\t\t\tdepthMs += dMs * dls;\n\t\t\t}\n\t\t\t\n\t\t\tvec3 A = exp(-(bR * (depthRs + depthR) + bM * (depthMs + depthM)));\n\t\t\tR += A * dR;\n\t\t\tM += A * dM;\n\t\t} else {\n\t\t\treturn vec3(0.);\n\t\t}\n\t}\n\t\n\treturn I * (R * bR * phaseR + M * bM * phaseM);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tif (iMouse.z > 0.) {\n\t\tfloat ph = 3.3 * (1. - iMouse.y / iResolution.y);\n\t\tDs = normalize(vec3(iMouse.x / iResolution.x - .5, sin(ph), cos(ph)));\n\t}\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 O = vec3(uv * .1, 0.) + vec3(0., 25e2, 0.);\n\tvec3 D = normalize(vec3(uv, -2.));\n\t\n\tfloat att = 1.;\n\tif (D.y < -.02) {\n\t\tfloat L = - O.y / D.y;\n\t\tO = O + D * L;\n\t\t\n\t\tD.y = -D.y;\n\t\tD = normalize(D+vec3(0.,.003*sin(t+6.2831*noise(O.xz*.8+vec2(0.,-t*3e3))),0.));\n\t\tatt = .6;\n\t}\n\t\n\tvec3 color = att * scatter(O, D);\n\n\tfloat env = pow(1. - smoothstep(.5, iResolution.x / iResolution.y, length(uv*.8)), .3);\n\tfragColor = vec4(env * pow(color, vec3(.4)), 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldS3Wm.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[0, 409, 433, 433, 484], [486, 495, 519, 519, 718], [720, 720, 745, 745, 985], [987, 987, 1008, 1008, 1111], [1113, 1113, 1177, 1177, 1390], [1392, 1392, 1440, 1440, 1654], [1656, 1796, 1826, 1826, 2833], [2835, 2835, 2892, 2892, 3598]], "test": "ok"}
{"id": "ldS3Wt", "name": "clock 2", "author": "FabriceNeyret2", "description": "SPACE : 3D version", "tags": ["clock"], "likes": 27, "viewed": 1968, "published": "Public API", "date": "1394993852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(float s) { return mod(10E6*sin(s*2526.2352+6532.235),1.); }\n\nbool keyToggle(int ascii) \n{\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.); }\n\n// for rotations\nvoid setPos(float r, vec2 pos, out float ang, out float radius) {\n\tfloat dt = r; // rnd(floor(.5+r*10.))*3.;\n    pos.x /= sin(6.283*iTime/10.*dt);\n\tang = mod(.5-atan(pos.y,pos.x)/6.283,1.); radius = length(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy, \n        pos = ( 2.*fragCoord -R ) / iResolution.y;\n\tfloat ang = mod(.5-atan(pos.y,pos.x)/6.283,1.), radius = length(pos);\n\n\t// tunings\n\tfloat MY = 2.5/R.y,    MA = .5/R.y,\n\t\t  MR = 64./R.y,   MR2 = 410./R.y;\n\tfloat AI = (1.+sin(6.283*iTime/100.))/2.;\n\t\n\tfloat year = iDate.x, month = iDate.y, day = iDate.z, seconds = iDate.a;\n\tfloat v,I; \tvec3 col = vec3(0.);\n\n\tv = mod(year/1000.,10.)/10.;  \n\tif (keyToggle(32)) setPos(.15, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.r  += smoothstep(MY,-MY,ang-v) *I *smoothstep(MR,-MR,abs(radius-.15)/.025-1.);\n\tv = mod(year/100.,10.)/10.;   \n\tif (keyToggle(32))setPos(.2, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.r  += smoothstep(MY,-MY,ang-v) *I *smoothstep(MR,-MR,abs(radius-.2)/.025-1.);\n\tv = mod(year/10.,10.)/10.;   \n\tif (keyToggle(32))setPos(.25, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.r  += smoothstep(MY,-MY,ang-v) *I *smoothstep(MR,-MR,abs(radius-.25)/.025-1.);\n\tv = mod(year,10.)/10.;   \n\tif (keyToggle(32))setPos(.3, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.r  += smoothstep(MY,-MY,ang-v) *I *smoothstep(MR,-MR,abs(radius-.3)/.025-1.);\n\tv = month/12.;   \n\tif (keyToggle(32))setPos(.4, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.g  += smoothstep(MA,-MA,ang-v) *I *smoothstep(MR,-MR,abs(radius-.4)/.04-1.);\n\tv = day/31.;   \n\tif (keyToggle(32))setPos(.5, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.b  += smoothstep(MA,-MA,ang-v)* I  *smoothstep(MR,-MR,abs(radius-.5)/.04-1.);\n\tv = floor(seconds/3600./12.);   \n\tif (keyToggle(32)) setPos(.56, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.rg += vec2(smoothstep(MA,-MA,ang-v)) *I *smoothstep(MR2,-MR2,abs(radius-.56)/.005-1.);\n    v = floor(mod(seconds/3600.,12.))/12.;  \n\tif (keyToggle(32)) setPos(.6, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.rg += vec2(smoothstep(MA,-MA,ang-v)) *I *smoothstep(MR,-MR,abs(radius-.61)/.035-1.);\n\tv = mod(seconds,3600.)/3600.;\t \n\tif (keyToggle(32)) setPos(.7, pos,ang,radius);\n\t I = smoothstep(0.,1.,ang/v/AI);\n\tcol.gb += vec2(smoothstep(MA,-MA,ang-v)) *I *smoothstep(MR,-MR,abs(radius-.7)/.04-1.);\n    v = mod(seconds,60.)/60.;  \n\tif (keyToggle(32)) setPos(.8, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\n\tcol.rb += vec2(smoothstep(MA,-MA,ang-v)) *I *smoothstep(MR,-MR,abs(radius-.8)/.04-1.);\n\tv = mod(iTime,1.);\t \n\tif (keyToggle(32)) setPos(.9, pos,ang,radius);\n\tI = smoothstep(0.,1.,ang/v/AI);\t\t   \n\tcol.rgb += vec3(smoothstep(MA,-MA,ang-v))*I *smoothstep(MR,-MR,abs(radius-.9)/.04-1.);\n\t//v = mod(iTime*10.,1.);\t \n\t//I = smoothstep(0.,1.,ang/v/AI);\t\t   \n\t//col.rgb += vec3(smoothstep(MA,-MA,ang-v))*I *smoothstep(MR2,-MR2,abs(radius-.97)/.005-1.);\n\t\n#if 0 // for those who dislike coder colors :-D\n\tcol += vec3(.1,.2,.3); col.xyz += col.zxy*.5; col*=.5; \n#endif \n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldS3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 69], [71, 71, 99, 99, 171], [173, 190, 255, 255, 403], [405, 405, 462, 462, 3324]], "test": "ok"}
{"id": "ldsSzr", "name": "Polygon Raytracing", "author": "Branch", "description": "Polygon Raytracing.", "tags": ["raytracing", "ray", "tracing", "polygon"], "likes": 15, "viewed": 707, "published": "Public", "date": "1396223421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//float closest;\nstruct point{\n\tvec3 position;\n\tvec3 normal;\n\tvec3 color;\n\tfloat distanceFromCamera;\n};\nstruct polygon{\n\tvec3 A;\n\tvec3 B;\n\tvec3 C;\t\n\tvec3 color;\n};\nstruct sphere{\n\tvec3 pos;\n\tfloat size;\n};\nvec3 color;\nvec3 camera;\nvec3 ray;\npoint closestPoint;\nvoid resolveRayPolygonIntersection(polygon poly){\n\t\n\tvec3 e1=poly.B-poly.A;\n\tvec3 e2=poly.C-poly.A;\n\tvec3 pvec=cross(ray, e2);\n\tfloat det=dot(e1, pvec);\n\t\n\tfloat invDet=1.0/det;\n\tvec3 tvec=camera-poly.A;\n\tfloat u=dot(tvec,pvec)*invDet;\n\tif(u<0.0||u>1.0) return;\n\tvec3 qvec=cross(tvec,e1);\n\tfloat v=dot(ray,qvec)*invDet;\n\tif(v<0.0||v>1.0||(u+v)>1.0) return;\n\tfloat t=dot(e2,qvec)*invDet;\n\tif(t>0.0)\n\tif(t<closestPoint.distanceFromCamera){\n\t\tclosestPoint.distanceFromCamera=t;\n\t\tclosestPoint.normal=normalize(cross(e1, e2));\n\t\tclosestPoint.color=poly.color;\n\t}\n}\nbool resolveRaySphereIntersection(sphere ball){\n\tvec3 OC=ball.pos-camera;\n\tfloat P=dot(OC,ray);\n\tif(P<0.) return false;\n\tfloat d=sqrt(pow(length(OC),2.0)-pow(P,2.0));\n\tif(d>ball.size) return false;\n\treturn true;\n}\nfloat resolveRayLightIntersection(sphere sun){\n\tvec3 OC=sun.pos-camera;\n\tfloat P=dot(OC,ray);\n\tfloat d=sqrt(pow(length(OC),2.0)+pow(P,2.0));\n\treturn 1./d;\n\t\n}\nmat3 rotate_x( float angle)\n{\n\treturn mat3(\t\t1\t,\t\t0,\t\t\t0\t,\n\t\t\t\t\t\t0\t,cos(angle),-sin(angle) ,\n\t\t\t\t\t\t0\t,sin(angle),cos(angle)\t); \n}\nmat3 rotate_y( float angle)\n{\n\treturn mat3(cos(angle)\t,\t\t0,\tsin(angle)\t,\n\t\t\t\t\t\t0\t,\t\t1,\t\t\t0\t,\n\t\t\t\t-sin(angle)\t,\t\t0,\tcos(angle)\t); \n}\nsphere sun;\nvoid resolveRay(float howManiethReflection){\n\tif(closestPoint.distanceFromCamera<100000.){\n\t\tcamera+=ray*(closestPoint.distanceFromCamera)-normalize(closestPoint.normal);\n\t\tray=normalize(reflect(ray,closestPoint.normal));\n\t\tfloat sunlight=length(sun.pos-camera)/min(max(0.4/resolveRayLightIntersection(sun),0.01),1.0);\n\t\tcolor+=vec3(closestPoint.color/(0.11*sunlight*(howManiethReflection*1.1+1.)));\n\t\t//ray=normalize(ray)*vec3(0.77);\n\n\t}\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid scene(){\n\tsphere ball;\n\tball.pos=vec3(0.,-3.,10.);\n\tball.size=17.;\n\tif(resolveRaySphereIntersection(ball))\n\tfor(float reflection=0.; reflection<=6.; reflection++){\n\t\t\n\tpolygon test2;\n\ttest2.A=vec3(9., -10., 10.);\n\ttest2.B=vec3(4., -10., -10.);\n\ttest2.C=vec3(9., 10., 10.);\n\ttest2.color=vec3(.61,.8,.51);\n\tresolveRayPolygonIntersection(test2);\n\tpolygon test3;\n\ttest3.C=vec3(-12., -10., 10.);\n\ttest3.B=vec3(-7., -10., -10.);\n\ttest3.A=vec3(-1., 30., 0.);\n\ttest3.color=vec3(.8,.5,.5);\n\tresolveRayPolygonIntersection(test3);\n\t\t\n\tfor(float i=3.14*2000.0; i<3.14*4000.0; i+=3.14*400.0){\n\t\t\tpolygon ympyraPala;\n\t\t\tympyraPala.A=vec3(4.0*cos(i), -1.0, 4.0*sin(i));\n\t\t\tympyraPala.B=vec3(4.0*cos(i+3.14*400.), -1.0, 4.0*sin(i+3.14*400.));\n\t\t\tympyraPala.C=vec3(0.0, 4.+1.*sin(iTime*3.782562261), 0.0);\n\t\t\tympyraPala.color=vec3(.31,.0,.0);\n\t\t\tresolveRayPolygonIntersection(ympyraPala);\n\t}\n\tfor(float i=3.14*2000.0; i<3.14*4000.0; i+=3.14*400.0){\n\t\t\tpolygon ympyraPala;\n\t\t\tympyraPala.A=vec3(5.0*cos(i+3.14*400.), -3.0+1.*sin(iTime*3.782562261-1.), 5.0*sin(i+3.14*400.));\n\t\t\tympyraPala.B=vec3(4.0*cos(i+3.14*400.), -1.0, 4.0*sin(i+3.14*400.));\n\t\t\tympyraPala.C=vec3(4.0*cos(i), -1.0, 4.0*sin(i));\n\t\t\tympyraPala.color=vec3(.31,.0,.0);\n\t\t\tresolveRayPolygonIntersection(ympyraPala);\n\t\t\tympyraPala.C=vec3(5.0*cos(i+3.14*400.), -3.0+1.*sin(iTime*3.782562261-1.), 5.0*sin(i+3.14*400.));\n\t\t\tympyraPala.B=vec3(5.0*cos(i), -3.0+1.*sin(iTime*3.782562261-1.0), 5.0*sin(i));\n\t\t\tympyraPala.A=vec3(4.0*cos(i), -1.0, 4.0*sin(i));\n\t\t\tympyraPala.color=vec3(.31,.0,.0);\n\t\t\tresolveRayPolygonIntersection(ympyraPala);\n\t}\n\tpolygon RR;\n\tRR.A=vec3(-10., -6., -10.);\n\tRR.B=vec3(10., -6., -10.);\n\tRR.C=vec3(-10., -6., 10.);\n\tRR.color=vec3(.104,.1,.31);\n\tresolveRayPolygonIntersection(RR);\n\tRR.A=vec3(10., -6., -10.);\n\tRR.B=vec3(10., -6., 10.);\n\tRR.C=vec3(-10., -6., 10.);\n\tRR.color=vec3(.104,.1,.31);\n\tresolveRayPolygonIntersection(RR);\n\t\t\n\tfor(float j=-1.0; j<4.0; j++)\n\t\tfor(float i=-2.0; i<2.0; i++){\n\t\t\tpolygon tasoPalaA;\n\t\t\ttasoPalaA.C=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);\n\t\t\ttasoPalaA.B=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);\n\t\t\ttasoPalaA.A=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);\n\t\t\ttasoPalaA.color=vec3(.41,.41,.41);\n\t\t\tresolveRayPolygonIntersection(tasoPalaA);\n\t\t\tpolygon tasoPalaB;\n\t\t\ttasoPalaB.C=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);\n\t\t\ttasoPalaB.B=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);\n\t\t\ttasoPalaB.A=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);\n\t\t\ttasoPalaB.color=vec3(.41,.41,.41);\n\t\t\tresolveRayPolygonIntersection(tasoPalaB);\n\t\t}\n\t\tresolveRay(reflection);\n\t\tcolor+=vec3(min(resolveRayLightIntersection(sun),0.0));\n\tclosestPoint.distanceFromCamera=100000.;\n\t}\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//float aspectratio = iResolution.x / iResolution.y;\n\tvec3 noise=texture(iChannel0, uv+vec2(iTime)).xyz*rand(uv+vec2(iTime))*vec3(0.052);\n\t\n\t\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n\t\n\tcamera = vec3(-4.0*sin(iTime),3.0,22.0);\n\tray = normalize(vec3(coord, -1.5));\n\tclosestPoint.distanceFromCamera=100000.;\n\tcolor=vec3(0.);\n\tscene();\n\n\tfragColor = vec4(color+noise+vec3(-0.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 261, 310, 310, 821], [822, 822, 869, 869, 1035], [1036, 1036, 1082, 1082, 1194], [1195, 1195, 1224, 1224, 1324], [1325, 1325, 1354, 1354, 1456], [1469, 1469, 1513, 1513, 1909], [1910, 1910, 1930, 1930, 2002], [2003, 2003, 2016, 2016, 4731], [4732, 4732, 4788, 4788, 5335]], "test": "ok"}
{"id": "ldXSzr", "name": "Fantasy scene", "author": "avix", "description": "A small fantasy scene.", "tags": ["procedural", "3d", "raymarch"], "likes": 58, "viewed": 5372, "published": "Public", "date": "1395776922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AUTOROTATE 1\r\n\r\n#define FARCLIP    25.0\r\n\r\n#define MARCHSTEPS 60\r\n#define AOSTEPS    20\r\n#define SHSTEPS    20\r\n#define SHPOWER    2.0\r\n\r\n#define PI         3.14\r\n#define PI2        PI*0.5    \r\n\r\n#define AMBCOL     vec3(1.0,1.0,1.0)\r\n#define BACCOL     vec3(1.0,1.0,1.0)\r\n#define DIFCOL     vec3(1.0,1.0,1.0)\r\n\r\n#define MAT1       1.0  //terrain\r\n#define MAT2       2.0  //sea\r\n#define MAT3       3.0  //h walls\r\n#define MAT4       4.0  //h roof\r\n\r\n\r\n/***********************************************/\r\nfloat rbox(vec3 p, vec3 s, float r) {\t\r\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\r\n}\r\nfloat sdTriPrism(vec3 p, vec2 h){\r\n    vec3 q = abs(p);\r\n    return max(q.x-h.y,max(q.z*0.166025+p.y*0.5,-p.y)-h.x*0.5);\r\n}\r\nfloat pyramid( vec3 p, float h) {\r\n\tvec3 q=abs(p);\r\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\r\n}\r\n\r\nvec2 rot(vec2 k, float t) {\r\n    float ct=cos(t); \r\n    float st=sin(t);\r\n    return vec2(ct*k.x-st*k.y,st*k.x+ct*k.y);\r\n}\r\n\r\n\r\n/***********************************************/\r\n\r\nvec2 house(vec3 p) {\r\n    float d=rbox(p,vec3(0.6,0.4,0.3),0.01);\r\n    //so much crap for a few windows.. lol\r\n    vec3 q=-abs(p);\r\n        q+=vec3(0.09,0.28,0.3);\r\n            q.x=clamp(q.x,-0.4,0.55);\r\n            q.y=clamp(q.y, 0.0,0.6);\r\n        q.x=mod(q.x,0.18)-0.5*0.18;\r\n        q.y=mod(q.y,0.3)-0.5*0.3;\r\n        float w=rbox(q,vec3(0.035,0.06,0.1),0.01);\r\n    d=max(d,-w);\r\n    q.x=-abs(p.x);\r\n        q.xz+=vec2(0.6,-0.2);   \r\n        w=rbox(q,vec3(0.1,0.06,0.035),0.01);\r\n    d=max(d,-w);\r\n    //roof\r\n    p.y-=0.43;\r\n        w=sdTriPrism(p,vec2(0.07,0.61));\r\n//    d=min(d,w);\r\n    return mix(vec2(d,MAT3), vec2(w,MAT4), step(w, d));\r\n}\r\n\r\nvec2 tower(vec3 p, float h) {\r\n    float d=rbox(p,vec3(0.25,h,0.25),0.02);\r\n    //windows\r\n    vec3 q=p;\r\n    q.y-=h*0.45;\r\n    q.xy=-abs(q.xy)+vec2(0.3,0.17);\r\n        float w=rbox(q,vec3(0.1,0.06,0.035),0.01);\r\n    d=max(d,-w);\r\n\r\n    //roof\r\n    p.y-=h;\r\n    p.xz=rot(p.xz,0.785398163);\r\n    w=pyramid(p,0.4);\r\n    \r\n    return mix(vec2(d,MAT3), vec2(w,MAT4), step(w, d));\r\n}\r\n\r\n\r\nvec2 DE(vec3 p) {\r\n    //terrain\r\n    vec2 uv=-vec2(-p.x*0.002, p.z*0.002-0.02);\r\n    float d=p.y+4.0 -texture(iChannel0, uv).x*5.0 + texture(iChannel0, p.xz*0.08).x*0.2;\r\n    vec2 terrain=vec2(d*0.4,MAT1); \r\n  \r\n    //sea \r\n    uv=vec2(p.y+2.0+sin(p.x+iTime)*0.02-texture(iChannel1, p.xz*0.02+iTime*0.003).x*0.5, MAT2);\r\n    uv.x+=texture(iChannel1, p.xz*0.013-iTime*0.002).x*0.4;\r\n    terrain=mix(terrain, uv, step(uv.x, terrain.x));\r\n\r\n    vec2 castle=vec2(FARCLIP,0.0);\r\n    //castle\r\n    vec3 q=p;\r\n    p.z-=0.8;\r\n    if (p.z>-2.0 && p.z<2.0) {\r\n        p.xy+=vec2(0.7,0.1);\r\n        p.z=mod(p.z,2.0)-0.5*2.0;\r\n        castle=house(p);\r\n    } \r\n\r\n    p.z=-abs(q.z);\r\n    p-=vec3(1.35,-0.2,-0.5);\r\n    p.xz=rot(p.xz,1.8);\r\n    uv=house(p);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n    \r\n    p=q;\r\n    p.xz=rot(p.xz,1.5);\r\n    p-=vec3(-0.90,-0.5,-0.9);\r\n    uv=house(p);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n\r\n    //towers\r\n//    p=q;\r\n    q.x-=0.4;\r\n    uv=tower(q,0.6);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n    q.xz-=vec2(-0.7,0.4);\r\n    uv=tower(q,1.2);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n    q.xz-=vec2(0.2,0.8);\r\n    uv=tower(q,0.8);\r\n    castle=mix(castle, uv, step(uv.x, castle.x));\r\n \r\n\r\n    return mix(terrain, castle, step(castle.x, terrain.x));\r\n}\r\n/***********************************************/\r\nvec3 normal(vec3 p) {\r\n\tvec3 e=vec3(0.01,-0.01,0.0);\r\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\r\n}\r\n/***********************************************/\r\nfloat calcAO(vec3 p, vec3 n ){\r\n\tfloat ao = 0.0;\r\n\tfloat sca = 1.0;\r\n\tfor (int i=0; i<AOSTEPS; i++) {\r\n        \tfloat h = 0.01 + 1.2*pow(float(i)/float(AOSTEPS),1.5);\r\n        \tfloat dd = DE( p+n*h ).x;\r\n        \tao += -(dd-h)*sca;\r\n        \tsca *= 0.65;\r\n        if( ao>1.0 ) break;\r\n    \t}\r\n   return clamp( 1.0 - 1.0*ao, 0.0, 1.0 );\r\n //  return clamp(ao,0.0,1.0);\r\n}\r\n/***********************************************/\r\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\r\n\tfloat res = 1.0;\r\n    for( int i=0; i<SHSTEPS; i++ ) {\r\n    \tif( s>e ) break;\r\n        float h = DE( ro + rd*s ).x;\r\n        res = min( res, k*h/s );\r\n    \ts += 0.02*SHPOWER;\r\n        if( res<0.001 ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n/***********************************************/\r\n#ifndef AUTOROTATE\r\nvoid rotc( inout vec3 p, vec3 r) {\r\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\r\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\r\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\r\n}\r\n#endif\r\n/***********************************************/\r\nvec3 fog(vec3 color, vec3 fcolor, float depth, float density){\r\n\tconst float e = 2.71828182845904523536028747135266249;\r\n\tfloat f = pow(e, -pow(depth*density, 2.0));\r\n\treturn mix(fcolor, color, f);\r\n}\r\n\r\n/***********************************************/\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\t\r\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\r\n\tvec3 ro =vec3(0.0, 5.0, -9.0);  //0.0,6.0,-15\r\n\tvec3 lig=normalize(vec3(0.0, 4.0, -15.0));\r\n\r\n#ifdef AUTOROTATE\t\r\n\tro.z-=sin(iTime*0.1)*2.0;\r\n    ro.xz=rot(ro.xz,iTime*0.123);\r\n    ro.yz=rot(ro.yz,sin(iTime*0.075)*0.3);\r\n    lig.xz=rot(lig.xz,iTime*0.123);\r\n#else\r\n\tvec2 mp=iMouse.xy/iResolution.xy;\r\n\trotc(ro,vec3(mp.x,mp.y,0.0));\r\n\trotc(lig,vec3(mp.x,mp.y,0.0));\r\n#endif\r\n\tvec3 cf = normalize( ta - ro );\r\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\r\n    vec3 cu = normalize( cross(cr,cf));\r\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\r\n\r\n\tvec3 col=vec3(0.82,0.85,0.92);\r\n\t/* trace */\r\n\tvec2 r=vec2(0.0);\t\r\n\tfloat d=0.0;\r\n\tvec3 ww;\r\n\tfor(int i=0; i<MARCHSTEPS; i++) {\r\n\t\tww=ro+rd*d;\r\n\t\tr=DE(ww);\t\t\r\n        if( abs(r.x)<0.00 || r.x>FARCLIP ) break;\r\n        d+=r.x;\r\n\t}\r\n    r.x=d;\r\n\t/* draw */\r\n\tif( r.x<FARCLIP ) {\r\n\t    vec2 rs=vec2(0.0,0.2);  //rim and spec\r\n\r\n\t    if (r.y==MAT1) {\r\n\t            col=vec3(1.0,0.76,0.55)*texture(iChannel1,ww.xz*0.2).xyz*1.6;\r\n\t            col=mix(col,vec3(0.1,0.66,0.25),texture(iChannel0,ww.xz*0.05).x*0.5);\r\n\t    }\r\n\t    if (r.y==MAT2) { col=vec3(0.13,0.16,0.35); rs=vec2(1.0); }\r\n\r\n\r\n\t    if (r.y==MAT3) { col=3.75*texture(iChannel2,ww.xy*3.0).xyz*texture(iChannel2,ww.zy*3.0).xyz; rs.y=0.4; }\r\n\t    if (r.y==MAT4) { col=vec3(0.76,0.46,0.35); rs.y=0.4; }\r\n\r\n\r\n\t\tvec3 nor=normal(ww);\r\n\r\n    \tfloat amb= 1.0;\t\t\r\n    \tfloat dif= clamp(dot(nor, lig), 0.0,1.0);\r\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\r\n    \tfloat rim= pow(1.+dot(nor,rd), 3.0);\r\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.0, 1.0 ) ,16.0 );\r\n    \tfloat ao= calcAO(ww, nor);\r\n    \tfloat sh= calcSh(ww, lig, 0.01, 2.0, 4.0);\r\n\r\n\t    col *= 0.5*amb*AMBCOL*ao + 0.4*dif*DIFCOL*sh + 0.05*bac*BACCOL*ao;\r\n\t    col += 0.3*rim*amb * rs.x;\r\n    \tcol += 0.5*pow(spe,1.0)*sh * rs.y;\r\n\r\n\r\n        vec3 ff=vec3(0.82,0.85,0.92);\r\n        col=fog(col,ff,r.x*0.047,ww.y);\r\n\t}\r\n\r\n\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[459, 510, 547, 547, 600], [602, 602, 635, 635, 725], [727, 727, 760, 760, 822], [826, 826, 853, 853, 948], [954, 1007, 1027, 1027, 1656], [1660, 1660, 1689, 1689, 2038], [2044, 2044, 2061, 2077, 3363], [3365, 3416, 3437, 3437, 3586], [3588, 3639, 3669, 3669, 4009], [4011, 4062, 4123, 4123, 4378], [4727, 4778, 4840, 4840, 4978], [4982, 5033, 5090, 5090, 7172]], "test": "ok"}
{"id": "ls23W3", "name": "Dots moving in squares", "author": "gleurop", "description": "An attempt at recreating this gif: http://i.imgur.com/sX9SHHm.gif", "tags": ["2d", "trippy"], "likes": 23, "viewed": 694, "published": "Public", "date": "1394589189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float x(float t) { // From http://mathforum.org/kb/message.jspa?messageID=407257\n\tt = mod(t, 4.0);\n\treturn abs(t) - abs(t-1.0) - abs(t-2.0) + abs(t-3.0) - 1.0;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -0.5 + fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec2 p = abs(mod(uv*30.0, 1.0));\n\tvec2 cell = floor(uv*30.0);\n\tfloat t = iTime*2.0+atan(cell.y+0.01,cell.x)/1.57*4.0+length(cell)/3.0;\n\tvec2 s = vec2(x(t), x(t-1.0))*0.35+0.5; \n\tfloat d = max(abs(p.x-s.x), abs(p.y-s.y));\n\tfragColor = vec4(smoothstep(0.15, 0.1, d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls23W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 80, 162], [164, 164, 221, 221, 579]], "test": "ok"}
{"id": "lsBGDt", "name": "Nebula Clouds", "author": "mu6k", "description": "Pause the shader and rotate it around with the mouse ;)", "tags": ["noise", "volume", "space", "stars"], "likes": 37, "viewed": 2100, "published": "Public", "date": "1395007823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tI wanted to make it as exotic and colorful as possible \n\twithout ruining the framerate too much. \n\n\tI'm not happy with the illumination but anything \n\tbetter hits the performance too hard.\n\n\tPause the shader and rotate it around with the mouse ;)\n\n\tSoundtrack: https://www.youtube.com/watch?v=5mDwVSfY-EE\n\n*/\n\n\n//2D texture based 4 component 1D, 2D, 3D noise\nvec4 noise(float p){return texture(iChannel0,vec2(p*float(1.0/256.0),.0));}\nvec4 noise(vec2 p){return texture(iChannel0,p*vec2(1.0/256.0));}\nvec4 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy*vec2(1.0/256.0) + noise(sprev).yz*21.421),texture(iChannel0,p.xy*vec2(1.0/256.0) + noise(s).yz*14.751),m);}\nvec4 noise(vec4 p){float m = mod(p.w,1.0);float s = p.w-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(noise(p.xyz+noise(sprev).wyx*3531.123420),\tnoise(p.xyz+noise(s).wyx*4521.5314),\tm);}\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nconst float toffs = -154.0;\nfloat t;\n\n//density function\nfloat density(vec3 p)\n{\n\tvec4 d = noise(p*.5)*noise(p.xz*.044)*noise(p.xy*.26)*noise(p.yz*.21);\n\tfloat fd = dot(d,vec4(1.4));\n\tfd = fd*fd*fd*fd*fd;\n\t\n\treturn max(.0,fd);\n}\n\n//background with stars\nvec3 background(vec3 d, vec3 p)\n{\n\tvec4 n = noise(d*0.45*iResolution.y+p*.05);\n\tfloat sun = pow(dot(d,normalize(vec3(1.0)))*.5+.5,64.0);;\n\tfloat den = abs(d.y); den = 1.0-den; den=den*den*den*den; den*=.1;\n\treturn vec3(pow(n.x+n.y*.1+den,22.0))*.3+ mix(vec3(.1,.15,.2)*.25,vec3(1.2,.9,.5),sun);\n}\n\n//smooth version of the background - used for ambient lighting\nvec3 background2(vec3 d)\n{\n\tfloat sun = pow(dot(d,normalize(vec3(1.0)))*.5+.5,16.0)*.7;;\n\treturn mix(vec3(.1,.15,.2),vec3(1.2,.9,.5),sun);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime + noise(fragCoord.xy).y/(24.0-24.0/(iTime+1.0)) + toffs;\n    \n     vec2 uv = fragCoord.xy / iResolution.yy -vec2(.9,.5);\n\tvec2 m = iMouse.xy*8.0/ iResolution.yy;\n\t//rotation matrix for the camera\n\tmat3 rotmat = rotate_y((t-toffs)*.07+m.x)*rotate_x((t-toffs)*.031+m.y);\n\t//p is ray position\n\tvec3 p = vec3(.0,.0,-30.0); p*=rotmat;\n\tp += vec3(sin(t),cos(t),sin(t*.25)*29.0+t*7.0-22.0-4.0/((t-toffs)*.01+0.01));\n\t//d is ray direction\n\tvec3 d = normalize(vec3(uv*(sin(t*.17)*.2+0.8),1.0-length(uv)*.2));\n\td*=rotmat;\n\tp+=d*noise(fragCoord.xy).x*.9;\n\t\n\t//some accumulators\n\tfloat a = .0;\n\tfloat ai = .0;\n\tvec3 color = vec3(.0);\n\t\n\t//raycast 60 steps\n\tfor (int i=0; i<60; i++)\n\t{\n\t\t//move forward\n\t\tp+=d*.9;\n\t\t//space distort\n\t\tvec3 n = noise(p.xz*.25+vec2(t*.1)).xyz*12.0*noise(p.zy*.1+vec2(t*.1)).xyz;\n\n\t\tfloat de = density(p+n);\n\t\ta += de; // a is alpha, as the ray traverses the density function the\n\t\t//pixel is more and more opaque\n\t\ta = min(1.0,a); //a > 1.0 makes no sence and produces bugs\n\t\tvec4 c2 = noise(p.yz*.03).xyzw;\n\t\tvec3 c = c2.xyz*1.7;\n\t\t\n\t\t//lame illumiation\n\t\tfloat occ = min((de-density(p+vec3(0.7+n))),1.0);\n\t\tocc = min(occ,(de-density(p+vec3(3.7)+n)));\n\t\tocc = min(occ,(de-density(p+vec3(5.7)+n)));\n\t\t\n\t\tcolor += max(.0,occ)*(1.0-a)*c;\n\t\tif (a>1.0) break; //traversing beyond this point makes\n\t\t//no sense because it's not visible anymore, so break\n\t}\n\n\t//post processing + blending\n\t\n\tcolor += background2(d)*.15;\n\tcolor = mix(min(vec3(1.0),background(d,p)),color,a);\n\t\n\tcolor +=noise(uv).xyz*.08;\n\tcolor -= length(uv)*.12;\n\tcolor = max(vec3(.0),color);\n\tcolor  = mix(color,vec3(length(color)),length(color)*1.7-.4);\n\tcolor  = pow(color,vec3(.6));\n\t\n\tcolor *= 1.0+1.0/(t-toffs+.01);\n\t\n\tfragColor = vec4(color,1.0);\n\t\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsBGDt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[407, 455, 475, 475, 530], [531, 531, 550, 550, 595], [596, 596, 615, 615, 866], [867, 867, 886, 886, 1091], [1093, 1134, 1158, 1158, 1223], [1224, 1224, 1247, 1247, 1334], [1335, 1335, 1358, 1358, 1445], [1446, 1446, 1469, 1469, 1555], [1595, 1614, 1637, 1637, 1785], [1787, 1811, 1844, 1844, 2107], [2109, 2172, 2198, 2198, 2312], [2314, 2314, 2371, 2371, 4123]], "test": "ok"}
{"id": "lsfXRn", "name": "Julia - Dark Side", "author": "Nihilus", "description": "An example of Julia fractal, click the mouse to activate the \"dark side\".", "tags": ["fractal", "example", "noob"], "likes": 1, "viewed": 132, "published": "Public", "date": "1395697679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//pc = pixel coordinates\n//c = costant proper of Julia Set\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pc = 1.2*(-1.0 + 2.0*fragCoord.xy/iResolution.xy)*vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 c = 0.7*cos(vec2(0.0,1.5) + 0.15*iTime) - 0.3*cos(vec2(0.0,1.5) + 0.25*iTime);\n\t\n\tfloat f = 1e20;\n\tfor(int i = 0; i < 256; i++) {\n\t\t//The Julia fractal equation: pc = pc*pc + c\n\t\tpc = vec2(pc.x*pc.x-pc.y*pc.y, 2.0*pc.x*pc.y) + c;\n\t\t//Trap orbit from iq site\n\t\tf = min(f, dot(pc, pc));\n\t}\n\t\n\tif(iMouse.z > 0.0) {\n\t\tf = log(f)/8.0;\n\t} else {\n\t\tf = 1.0+log(f)/16.0;\n\t}\n\t\n\tfragColor = mix(vec4(0.0, 0.0, 0.0, 1.0), vec4(f,f*f*2.0,f*f*f*0.6, 1.0), 0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 117, 117, 670]], "test": "ok"}
{"id": "lsj3DK", "name": "Analytical AO", "author": "yoslber", "description": "\"Analytical\" ambient occlusion for a box on a plane, as seen from above", "tags": ["ambientocclusion"], "likes": 8, "viewed": 767, "published": "Public", "date": "1393786259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat x = fragCoord.x/iResolution.x;\n\tfloat y = fragCoord.y/iResolution.y;\n\tfloat amp = 0.19;\n\t\n\tfloat pX0 = 0.3+amp*sin(1.3*iTime);\n\tfloat pX1 = 0.7+amp*sin(1.5*iTime);\n\tfloat pY0 = 0.3+amp*sin(1.7*iTime);\n\tfloat pY1 = 0.7+amp*sin(1.1*iTime);\n\tfloat pH  = 0.2+amp*sin(2.3*iTime);\n\t\n\tfloat x0 = pX0;\n\tfloat x1 = pX1;\n\tfloat y0 = pY0;\n\tfloat y1 = pY1;\n\tfloat h  = pH;\n\tfloat M_1_2PI = 0.159154943;\n\t\n\tfloat I0, I1, c, angle;\n\tvec3 v0,v1;\n\t\n\t// Local coordinate system\n\tfloat xa = x0-x;\n\tfloat xb = x1-x;\n\tfloat ya = y0-y;\n\tfloat yb = y1-y;\n\t\n\t// LEFT        \n\tc = xa/sqrt(xa*xa+h*h);\n\tI0 = atan(c*ya/xa);\n\tI1 = atan(c*yb/xa);\n\tfloat visAreaL = c*(I1-I0)*M_1_2PI;\n\t\n\t// TOP\n\tc = ya/sqrt(ya*ya+h*h);\n\tI0 = atan(c*xa/ya);\n\tI1 = atan(c*xb/ya);\n\tfloat visAreaT = c*(I1-I0)*M_1_2PI;\n\t\n\t// BOTTOM        \n\tc = yb/sqrt(yb*yb+h*h);\n\tI0 = atan(c*xa/yb);\n\tI1 = atan(c*xb/yb);\n\tfloat visAreaB = c*(I0-I1)*M_1_2PI;\n\t\n\t// RIGHT\n\tc =  xb/sqrt(xb*xb+h*h);\n\tI0 = atan(-c*ya/xb);\n\tI1 = atan(-c*yb/xb);\n\tfloat visAreaR = c*(I1-I0)*M_1_2PI;\n\t\n\tvec4 col = vec4(0,0,0,1);\n\t\n\tfloat sx0 = step(x0,x);\n\tfloat sx1 = step(x1,x);\n\tfloat sy0 = step(y0,y);\n\tfloat sy1 = step(y1,y);\n\t\n\tif (sx0*(1.0-sx1)*sy0*(1.0-sy1) >0.0)\n\t{\n\t\tcol = vec4(1.0,1.0,1.0,1);\n\t}\n\telse if ((1.0-sx0)*sy0*(1.0-sy1) > 0.0)\n\t{ // x<=x0 && y>=y0 && y<=y1\n\t\t// left\n\t\tv0 = normalize(vec3(xa, ya,0));\n\t\tv1 = normalize(vec3(xa, yb,0));\n\t\tangle = acos(dot(v0,v1));\n\t\tfloat fracVis = 1.0-angle*M_1_2PI;\n\t\tfloat fac = fracVis+visAreaL;\n\t\tcol = vec4(fac,fac,fac,1);\n\t}\n\telse if ((1.0-sx0)*(1.0-sy0) > 0.0)\n\t{ // x<=x0 && y<=y0\n\t\t// Left top\n\t\tv0 = normalize(vec3(xb, ya,0));\n\t\tv1 = normalize(vec3(xa, yb,0));\n\t\tangle = acos(dot(v0,v1));\n\t\tfloat fracVis = 1.0-angle*M_1_2PI;\n\t\t\n\t\tfloat fac = fracVis + visAreaL + visAreaT;\n\t\tcol = vec4(fac,fac,fac,1);\n\t}\n\telse if ((1.0-sx0)*sy1 > 0.0)\n\t{ // x<=x0 && y>y1\n\t\t// Left bottom\n\t\tv0 = normalize(vec3(xa, ya,0));\n\t\tv1 = normalize(vec3(xb, yb,0));\n\t\tangle = acos(dot(v0,v1));\n\t\tfloat fracVis = 1.0-angle*M_1_2PI;\n\t\t\n\t\tfloat fac = fracVis + visAreaL + visAreaB;\n\t\tcol = vec4(fac,fac,fac,1);\t}\n\telse if (sx0*(1.0-sx1)*sy1 > 0.0)\n\t{ // x>x0 && x<x1 && y>y1\n\t\t// Bottom\n\t\tv0 = normalize(vec3(xa, yb,0));\n\t\tv1 = normalize(vec3(xb, yb,0));\n\t\tangle = acos(dot(v0,v1));\n\t\tfloat fracVis = 1.0-angle*M_1_2PI;\n\t\t\n\t\tfloat fac = fracVis + visAreaB; //\n\t\tcol = vec4(fac,fac,fac,1);\n\t}\n\t\n\telse if ( sx0*(1.0-sx1)*(1.0-sy0) > 0.0)\n\t{ // x>x0 && x<x1 && y<y0\n\t\t// Top\n\t\tv0 = normalize(vec3(xa, ya,0));\n\t\tv1 = normalize(vec3(xb, ya,0));\n\t\tangle = acos(dot(v0,v1));\n\t\tfloat fracVis = 1.0-angle*M_1_2PI;\n\t\t\n\t\tfloat fac = fracVis+visAreaT;\n\t\tcol = vec4(fac,fac,fac,1);\n\t}\n\t\n\telse if ( sx1*(1.0-sy1)*sy0 > 0.0 )\n\t{ // x>x1 && y<y1 && y>y0\n\t\t// Right\n\t\tv0 = normalize(vec3(xb, ya,0));\n\t\tv1 = normalize(vec3(xb, yb,0));\n\t\tangle = acos(dot(v0,v1));\n\t\tfloat fracVis = 1.0-angle*M_1_2PI;\n\t\t\n\t\tfloat fac = fracVis + visAreaR;\n\t\tcol = vec4(fac,fac,fac,1);\n\t}\n\t\n\telse if (sx1*sy1 > 0.0)\n\t{ // x>x1 && y>y1\n\t\tv0 = normalize(vec3(xb, ya,0));\n\t\tv1 = normalize(vec3(xa, yb,0));\n\t\tangle = acos(dot(v0,v1));\n\t\tfloat fracVis = 1.0-angle*M_1_2PI;\n\t\t\n\t\tfloat fac = fracVis + visAreaR+visAreaB;\n\t\tcol = vec4(fac,fac,fac,1);\n\t}\n\t\n\telse if (sx1*(1.0-sy1) > 0.0)\n\t{ // x>x1 && y<y1\n\t\tv0 = normalize(vec3(xa, ya,0));\n\t\tv1 = normalize(vec3(xb, yb,0));\n\t\tangle = acos(dot(v0,v1));\n\t\tfloat fracVis = 1.0-angle*M_1_2PI;\n\t\t\n\t\tfloat fac = fracVis + visAreaR + visAreaT;\n\t\tcol = vec4(fac,fac,fac,1);\n\t}\n\t\n\tfragColor = col;\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsj3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 3511]], "test": "ok"}
{"id": "lsj3Dt", "name": "Kifs experiment", "author": "guil", "description": "Kifs experiment", "tags": ["3d", "fractal", "kifs"], "likes": 8, "viewed": 246, "published": "Public", "date": "1395355116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Based on https://www.shadertoy.com/view/4ds3zn by IQ \n\n#define igt  iTime\n\nvec4 ot=vec4(.3,.5,0.21,1.);\nfloat g=1.25;\n\nconst int MaxIter = 15;\n\nfloat zoom=1.;\n\nmat3 tr;\n\n\n//from Tree in grass by alleycatsphinx : https://www.shadertoy.com/view/Xd2GDy \nvec3 foldY(vec3 P, float c)\n{\n\tfloat r = length(P.xz);\n\tfloat a = atan(P.z, P.x);\n\n\ta = mod(a, 2.0 * c) - c; \n\n\tP.x = r * cos(a);\n\tP.z = r * sin(a);\n\n\treturn P;\n}\n\n\n// Rotation function included in MathUtils.frag of Syntopia's Fragmentarium \nmat3 rotationMat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\nfloat map(vec3 p)\n{ \n    float l= length(p)-1.;\n    float dr = 1.0;\n    ot = vec4(1.);\n\t\t\t\t\n\tfor(int i=0;i<MaxIter;i++) {\n\n\t\tif(i-(i/3)*5==0)\n\t\t\tp = foldY(p, .95);\n\t\tp.yz = abs(p.yz);\t\t\t\t\n        p = tr * p * g -1.;\t\t\n\t\tdr *= g;\n\t\tot=min(ot,vec4(abs(p),dot(p,p)));\n        l = min (l ,(length(p)-1.) / dr);\n\t}\n\t\t\t\n    return l;    \n}\n\n\nfloat trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.;\n\tfloat precis = 0.001;\n      \n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n\tif( t>maxd ||  h<precis*(.1+t)) continue;//break;//        \n        \n        t += h;\n\t\th = map( ro+rd*t );\n    }\n\n   \tif( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  eps = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n\tnor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n\tnor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n        p.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 m = vec2(-0.5)*6.28;\n\tif( iMouse.z>0.0 )m = (iMouse.xy/iResolution.xy-.5)*6.28;\n\tm+=.5*vec2(cos(0.15*igt),cos(0.09*igt))+.3;      \n\t\n    // camera\n\n\tzoom = (2.8+sin(.2*igt))/2.5;\n\tvec3 ta = vec3(0.,0.1,0.);\n\tvec3 ro =  -zoom*10.*vec3( cos(m.x)*cos(m.y), sin(m.y), sin(m.x)*cos(m.y));\n\t\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.,1.,0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n\n    // trace\n\n    tr = rotationMat(normalize(vec3(-1.,-1.,-0.5)), -.55);\n\t\n\tvec3 col = vec3(0.8,0.8,1.);\n\tfloat t = trace( ro, rd );\n\tif( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, -0.707,0.0  );\n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(ot.w*6.0,0.2,1.0), 1.2 );\t\t\n                vec3 brdf = vec3(ao)*(.4*amb+key+.2*bac);\n\n        // material\t\t\t\t\n\t\tvec3 rgb =1.-sqrt(3.*ot.brg);\n\t\t\n\t\t// color\n\t\tcol = mix(vec3(0.8,0.8,1.),rgb*brdf,exp(-0.04*t));\n\n\t}\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsj3Dt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[261, 341, 370, 370, 503], [506, 583, 622, 622, 972], [975, 975, 994, 994, 1308], [1311, 1311, 1350, 1350, 1635], [1637, 1637, 1669, 1669, 1878], [1880, 1880, 1937, 1937, 3252]], "test": "ok"}
{"id": "lsj3Wd", "name": "A tree", "author": "guil", "description": "An attempt to make a simple tree", "tags": ["fractal", "tree", "kifs"], "likes": 4, "viewed": 246, "published": "Public", "date": "1395411633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Based on https://www.shadertoy.com/view/4ds3zn by IQ \n\n#define igt  iTime\n\nvec4 ot=vec4(1.);\nfloat g=1.15;\n\nconst int MaxIter = 16;\n\nfloat zoom=1.5;\nvec3 dim=vec3(1., .3 ,1.);\nmat3 tr;\n\n\n//from Tree in grass by alleycatsphinx : https://www.shadertoy.com/view/Xd2GDy \nvec3 foldY(vec3 P, float c)\n{\n\tfloat r = length(P.xz);\n\tfloat a = atan(P.z, P.x);\n\t//float c = 3.14159265358979 / n;\n\n\ta = mod(a, 2.0 * c) - c; \n\n\tP.x = r * cos(a);\n\tP.z = r * sin(a);\n\n\treturn P;\n}\n\n\n\n// Rotation function included in MathUtils.frag of Syntopia's Fragmentarium \nmat3 rotationMat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\nfloat map(vec3 p)\n{ \n    float l= length(p*dim)-1.;\n\tfloat l1 = l;\n    float dr = 1.0;\n    ot = vec4(1.);\n\t\t\t\t\n\tfor(int i=0;i<MaxIter;i++) {\n\t\tif(p.y<-3.)continue;\n\t\tif(i-(i/4)*5==0)\n\t\t\tp = foldY(p, 1.047);\n        else{\n\t\t\tp.yz = abs(p.yz);\t\t\t\t\n            p = tr * p * g -vec3(1.2,1.,0.);\t\t\n\t\t\tdr *= g;\n\t\t\tot=min(ot,vec4(abs(p),dot(p,p)));\n\t\t\t}\n\t\tl1=(length(p*dim)-1.) / dr;\n\t\tif(l1<l){\n\t\t\tl=l1;\n\t\t\tot.y*=1.1;\n\t\t}\n\t}\n\t\t\t\n    return l;    \n}\n\n\nfloat trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.;\n\tfloat precis = 0.001;\n      \n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n\tif( t>maxd ||  h<precis*(.1+t)) continue;//break;//        \n        \n        t += h;\n\t\th = map( ro+rd*t );\n    }\n\n   \tif( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  eps = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n\tnor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n\tnor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n        p.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 m = vec2(-0.5)*6.28;\n\tif( iMouse.z>0.0 )m = (iMouse.xy/iResolution.xy-.5)*6.28;\n\tm+=.5*vec2(cos(0.15*igt),cos(0.09*igt))+.3;      \n\t\n    // camera\n\n\n\tvec3 ta = vec3(0.,2.1,0.);\n\tvec3 ro =  -zoom*10.*vec3( cos(m.x)*cos(m.y), sin(m.y), sin(m.x)*cos(m.y));\n\t\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.,1.,0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n\n    // trace\n\n        tr = rotationMat(normalize(vec3(-1.,-1.7,-0.5)), -.85);\n\t\n\tvec3 col = vec3(0.8,0.8,1.);\n\tfloat t = trace( ro, rd );\n\tif( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// lighting\n                vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n                vec3  light2 = vec3( -0.707, -0.707,0.0  );\n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(ot.w*6.0,0.2,1.0), 1.2 );\t\t\n                vec3 brdf = vec3(ao)*(.4*amb+key+.2*bac);\n\n                // material\t\t\t\t\n\t\tvec3 rgb =ot.rgb*vec3(.6,.5,.2);\n\t\t\n\t\t// color\n\t\tcol = mix(vec3(0.8,0.8,1.),rgb*brdf,exp(-0.04*t));\n\n\t}\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsj3Wd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[277, 357, 386, 386, 554], [558, 635, 674, 674, 1024], [1027, 1027, 1046, 1046, 1469], [1472, 1472, 1511, 1511, 1795], [1797, 1797, 1829, 1829, 2038], [2040, 2040, 2097, 2097, 3414]], "test": "ok"}
{"id": "lsjGDd", "name": "Voronoi by Justaway", "author": "Justaway", "description": "Voronoi diagram", "tags": ["voronoi"], "likes": 0, "viewed": 148, "published": "Public", "date": "1395427836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float s;\nvoid srand(vec2 p){\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\nfloat rand(){\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\nfloat grad(float t){\n\treturn 6.0*pow(t,5.0)-15.0*pow(t,4.0)+10.0*pow(t,3.0);\n}\nmat2 rot2d(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts, c);\n}\nvec4 voronoi2d(vec2 p,float t){\n\tfloat v=8.0;\n\tvec4 c;\n\tvec2 f=floor(p)+vec2(0.5);\n\tfor(float i=-3.0;i<3.0;i++)\n\tfor(float j=-3.0;j<3.0;j++){\n\t\tsrand(f+vec2(i,j));\n\t\tvec2 o;\n\t\to.x=rand();\n\t\to.y=rand();\n\t\to*=rot2d(t*(rand()-0.5));\n\t\tfloat d=distance(p,f+vec2(i,j)+o);\n\t\tif(d<v){\n\t\t\tv=d;\n\t\t\tc.r=rand();\n\t\t\tc.g=rand();\n\t\t\tc.b=rand();\n\t\t}\n\t}\n\treturn vec4(c*(1.0-v));\n}\nvec4 smoothvoronoi2d(vec2 p,float t){\n\tfloat v=0.0;\n\tvec2 f=floor(p)+vec2(0.5);\n\tfor(float i=-3.0;i<3.0;i++)\n\tfor(float j=-3.0;j<3.0;j++){\n\t\tsrand(f+vec2(i,j));\n\t\tvec2 o;\n\t\to.x=rand();\n\t\to.y=rand();\n\t\to*=rot2d(t*(rand()-0.5));\n\t\tfloat r=distance(p,f+vec2(i,j)+o);\n\t\tv+=exp(-8.0*r);\n\t}\n\treturn vec4(-(1.0/8.0)*log(v));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=iTime;\n\tfloat r=iResolution.x/iResolution.y;\n\tvec2 s=vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n\tfragColor=voronoi2d(s*5.0,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 28, 28, 72], [73, 73, 86, 86, 144], [145, 145, 165, 165, 223], [224, 224, 244, 244, 311], [312, 312, 343, 343, 676], [677, 677, 714, 714, 996], [997, 997, 1053, 1053, 1255]], "test": "ok"}
{"id": "lsS3Wc", "name": "HSV and HSL", "author": "iq", "description": "Converting from HSL and HSV color spaces to RGB. Could probably be faster, but not smaller (seems most people out there use lots of branches to do the same thing - too bad)", "tags": ["2d", "color", "hsv", "hsl", "colorspace"], "likes": 48, "viewed": 3575, "published": "Public API", "date": "1394251826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Somehow optimized HSV and HSL to RGB conversion functions. \n\n//========================================================================\n\nconst float eps = 0.0000001;\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nvec3 rgb2hsl( vec3 col )\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + eps)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              // H\n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + eps),  // S\n                 (minc+maxc)*0.5 );                           // L\n}\n\n//========================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 hsv = vec3( uv.x, 0.5+0.5*sin(iTime), uv.y );\n\t\n\tvec3 rgb = hsv2rgb(hsv);\n\t//vec3 rgb = hsl2rgb(hsl);\n\t\n\tfragColor = vec4( rgb, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsS3Wc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1143, 1250, 1277, 1277, 1406], [1408, 1408, 1435, 1435, 1577], [1579, 1579, 1605, 1605, 1920], [1922, 1922, 1948, 1948, 2400], [2402, 2478, 2535, 2535, 2722]], "test": "ok"}
{"id": "lssSRn", "name": "clipped disc hypertexture 1", "author": "FabriceNeyret2", "description": "hypertexture (here, sphere clipped by plane) with well controlled thickness, i.e., noise saturating the \"skin\" range.\nmouse.x tune noise layer thickness\nmouse.y tune noise bluriness\nSee #define for more tunings", "tags": ["procedural"], "likes": 15, "viewed": 2097, "published": "Public API", "date": "1396028001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\n\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\n\nvec2 sphere1Pos = vec2(0.,0.);\nfloat sphere1Rad = .7;         // sphere radius\n\nfloat planePos = .1;\n\nvec2 sphere2Pos = vec2(1.,0.);\nfloat sphere2Rad = .2;         \n\n// cloud appearance (superseeded by mouse tuning)\n\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\n\n\n\n#define ANIM 1         // 1/0\n\n#define PI 3.14159\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )  // base rand in [0,1]; \n{\n    return fract(sin(n-765.36334)*43758.5453);\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\n}\n\nfloat noise( in vec3 x ) // base noise in [0,1]; \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#if NOISE==1\n\treturn res;\n#elif NOISE==2\n\treturn abs(2.*res-1.);\n#elif NOISE==3\n\treturn 1.-abs(2.*res-1.);\n#endif\n}\n\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n\n\n// smooth distance to sphere = [-1,1] around radius +- thickness H\n\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\n{\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\n\tfloat d = (1.-length(p))/H;  \n\treturn clamp(d,-1.,1.);\n}\n\t\t\n// smooth distance to plane = [-1,1] around plane +- thickness H\n\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\n{\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\n\tfloat d = -p.x/(H*planeRad);  \n\treturn clamp(d,-1.,1.);\n}\n\t\n// smooth intersect operator\n\nfloat inter(float d0, float d1) {\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\n\td1 = (1.+d1)/2.;\n\treturn 2.*d0*d1 -1.;\n}\n\n// smooth union operator\n\nfloat add(float d0, float d1) {\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\n\td1 = (1.+d1)/2.;\n\treturn 2.*(d0+d1-d0*d1) -1.;\n}\n\n// jitter the distance around 0  and smoothclamp\n\nfloat perturb(vec2 p, float d, float H) {\n#if ANIM\n   float t = iTime;\n#else\n  float t = 0.; \n#endif\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\n\t\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\n}\n\n// convert [-1,1] distances into densities\n\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\n\treturn smoothstep(-sharp,sharp,d);\n}\n\n\n// user-define shape\n\t\nfloat shape(vec2 uv,float n) {\n\t\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\n\tfloat v;\n\n#define globalNoise false\n\t\n\tif (globalNoise || (n==0.)) {\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\n\t}\n\telse {\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\n\t}\n\t\n\treturn v;\n}\n\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\n\t\tvec2 m = iMouse.xy / iResolution.xy;\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \n\t}\n\n\tfloat v = dist2dens( shape(uv,1.) ); \n\tvec3 col = vec3(v);\n\t\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\n\t\t\n\t\tsharp = 1e-5; // no noise for bounds\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\n\t\t\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\n\t\t\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\n\t\tcol = mix(col, vec3(0.,v,0.),v);\n\t\t\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\n\t\tfloat alpha = max(col.r,col.g);\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\n\t\talpha = max(col.b,alpha);\n\t\t\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\n\t}\n\t\n    fragColor = vec4(col,0.); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 926, 974, 974, 1079], [1081, 1081, 1132, 1132, 1635], [1637, 1637, 1699, 1699, 1882], [1946, 2014, 2070, 2070, 2204], [2208, 2274, 2376, 2376, 2507], [2510, 2540, 2573, 2573, 2682], [2684, 2710, 2741, 2741, 2858], [2860, 2910, 2951, 2951, 3293], [3295, 3339, 3365, 3412, 3450], [3453, 3476, 3506, 3506, 4063], [4065, 4079, 4136, 4136, 5128]], "test": "ok"}
{"id": "lsXXRn", "name": "Milky Voronoi", "author": "Justaway", "description": "Voronoi diagram based milky surface.", "tags": ["voronoi"], "likes": 5, "viewed": 329, "published": "Public", "date": "1395688354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define MAX_ITER 128\n#define MAX_ITER_INTERNAL 0\n#define MAX_ITER_SHADOW 32\n#define MAX_DIST_SHADOW 10.0\n#define MIN_DIST_SHADOW 0.1\n#define MAX_DIST 1000.0\n#define MIN_DIST 0.01\n#define FOV 0.75\n#define SPECULAR 5.0\n#define SAMPLE_RADIUS 0.001\n#define PENUMBRA 2.0\nstruct ray{\n\tvec4 c;\n\tvec3 p;\n\tvec3 d;\n\tvec3 n;\n\tfloat t;\n\tint i;\n};\nstruct light{\n\tvec4 c;\n\tvec3 p;\n};\nlight l=light(\n\tvec4(0.5),\n\tvec3(0.0,-5.0,5.0)\n);\nvec4 a=vec4(0.5);\nfloat s;\nvoid srand(vec2 p){\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\nfloat rand(){\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\nmat3 rotx(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\nmat3 roty(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\nmat3 rotz(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\nmat3 rot(vec3 z,float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat b=1.0-c;\n\treturn mat3(\n\t\tb*z.x*z.x+c,b*z.x*z.y-z.z*s,b*z.z*z.x+z.y*s,\n\t\tb*z.x*z.y+z.z*s,b*z.y*z.y+c,b*z.y*z.z-z.x*s,\n\t\tb*z.z*z.x-z.y*s,b*z.y*z.z+z.x*s,b*z.z*z.z+c);\n}\nmat2 rot2d(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts, c);\n}\nfloat expstep(float x,float k,float n){\n\treturn exp(-k*pow(x,n));\n}\nfloat smin(float a,float b,float k){\n\tfloat h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\nfloat voronoi2d(vec2 p,float t){\n\tfloat v=0.0;\n\tvec2 f=floor(p)+vec2(0.5);\n\tfor(float i=-3.0;i<3.0;i++)\n\tfor(float j=-3.0;j<3.0;j++){\n\t\tsrand(f+vec2(i,j));\n\t\tvec2 o;\n\t\to.x=rand();\n\t\to.y=rand();\n\t\to*=rot2d(t*(rand()-0.5));\n\t\tfloat r=distance(p,f+vec2(i,j)+o);\n\t\tv+=exp(-16.0*r);\n\t}\n\t//return -(1.0/16.0)*log(v);\n\treturn -smin((1.0/16.0)*log(v),-0.1,0.1);\n}\nfloat dome(inout ray r){\n\tfloat v=voronoi2d(r.p.xy,r.t);\n\tfloat d=dot(r.p,vec3(0.0,0.0,1.0))+0.5-0.5*v;\n\tif(d<0.0){\n\t\tr.c=vec4(1.0);\n\t\tr.i=MAX_ITER_INTERNAL+1;\n\t}\n\treturn d;\n}\nfloat sphere(inout ray r){\n\tfloat d=length(r.p)-0.5;\t\n\tif(d<0.0){\n\t\tr.c=vec4(1.0);\n\t\tr.i=MAX_ITER_INTERNAL+1;\n\t}\n\treturn d;\n}\nfloat dist(inout ray r){\n\tfloat d=MAX_DIST;\n\td=min(d,dome(r));\n\treturn d;\n}\nvoid normal(inout ray r){\n\tfloat d=dist(r);\n\tvec3 n=vec3(SAMPLE_RADIUS,0.0,0.0);\n\tray r0=r;\n\tray r1=r;\n\tray r2=r;\n\tr0.p+=n.xyy;\n\tr1.p+=n.yxy;\n\tr2.p+=n.yyx;\n\tr.n=normalize(vec3(dist(r0)-d,dist(r1)-d,dist(r2)-d));\n}\nvec4 ambient(ray r){\n\treturn r.c*a;\n}\nvec4 diffuse(ray r){\n\tvec3 v=l.p-r.p;\n\treturn clamp(r.c*l.c*dot(r.n,normalize(v)),0.0,1.0);\n}\nvec4 specular(ray r){\n\tfloat d=length(l.p-r.p);\n\tvec3 v=normalize(l.p-r.p);\n\treturn l.c*max(pow(dot(v,reflect(r.d,r.n)),SPECULAR),0.0);\n}\nvec4 shadow(ray r){\n\tfloat s=1.0;\n\tfloat t=MIN_DIST_SHADOW;\n\tfor(int i=0;i<MAX_ITER_SHADOW;i++){\n\t\tray tmp=r;\n\t\ttmp.p+=r.d*t;\n\t\tfloat h=dist(tmp);\n\t\tif(h<MIN_DIST)return vec4(0.0);\n\t\ts=min(s,PENUMBRA*h/t);\n\t\tt+=h;\n\t\tif(t>MAX_DIST_SHADOW)break;\n\t}\n\treturn vec4(1.0)*s;\n}\nvec4 trace(inout ray r){\n\tr.c=vec4(1.0);\n\tfor(int i=0;i<MAX_ITER;i++){\n\t\tfloat d=dist(r);\n\t\tif(r.i>MAX_ITER_INTERNAL)break;\n\t\tr.p+=r.d*max(d,MIN_DIST);\n\t}\n\tnormal(r);\n\tray tmp=r;\n\ttmp.d=normalize(l.p-r.p);\n\ttmp.p-=2.0*MIN_DIST*r.d;\n\tif(r.i<=MAX_ITER_INTERNAL){\n\t\treturn vec4(1.0/exp(abs(r.p.z)));\n\t}else{\n\t\treturn ambient(r)+min(max(diffuse(r),specular(r)),shadow(tmp));\n\t}\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=iTime;\n\tfloat r=iResolution.x/iResolution.y;\n\tvec2 m=vec2(\n\t\t(iMouse.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(iMouse.y-iResolution.y/2.0)/iResolution.y);\n\tvec2 s=vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\t\n\tvec3 l=vec3(0.0,0.0,0.0);\n\tvec3 tmp=vec3(2.0,0.0,0.0);\n\ttmp*=roty((PI*m.y)/4.0-PI/8.0);\n\ttmp*=rotz(2.0*PI*m.x);\n\tvec3 e=l+tmp;\n\tvec3 u=vec3(0.0,0.0,1.0);\n\tvec3 d=normalize(l-e);\n\tvec3 h=normalize(cross(d,u));\n\tvec3 v=normalize(cross(h,d));\n\tfloat f=0.75;\n\td*=rot(v,FOV*s.x);\n\td*=rot(h,FOV*s.y);\n\tray a=ray(vec4(0.0),e,d,vec3(0.0),t,0);\n\tfragColor=trace(a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 472, 491, 491, 535], [536, 536, 549, 549, 607], [608, 608, 627, 627, 707], [708, 708, 727, 727, 807], [808, 808, 827, 827, 907], [908, 908, 933, 933, 1141], [1142, 1142, 1162, 1162, 1229], [1230, 1230, 1269, 1269, 1297], [1298, 1298, 1334, 1334, 1412], [1413, 1413, 1445, 1445, 1768], [1769, 1769, 1793, 1793, 1944], [1945, 1945, 1971, 1971, 2070], [2071, 2071, 2095, 2095, 2146], [2147, 2147, 2172, 2172, 2360], [2361, 2361, 2381, 2381, 2398], [2399, 2399, 2419, 2419, 2492], [2493, 2493, 2514, 2514, 2630], [2631, 2631, 2650, 2650, 2900], [2901, 2901, 2925, 2925, 3276], [3277, 3277, 3333, 3333, 3972]], "test": "ok"}
{"id": "Md23DV", "name": "GLSL 2D Tutorials", "author": "vug", "description": "28 tutorials on writing pixel shaders at Shadertoy. Written by a beginner for beginners.  ^_^", "tags": ["tutorial"], "likes": 581, "viewed": 48910, "published": "Public", "date": "1394312329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nby Uğur Güney. March 8, 2014. \n\nHi! I started learning GLSL a month ago. The speedup gained by using\nGPU to draw real-time graphics amazed me. If you want to learn\nhow to write shaders, this tutorial written by a beginner can be\na starting place for you.\n\nPlease fix my coding errors and grammar errors. :-)\n*/\n\n// choose the tutorial by changing the number and compiling the shader again\n#define TUTORIAL 0\n\n/* TUTORIAL LIST\n 1 VOID. BLANK SCREEN.\n 2 SOLID COLOR\n 3 GLSL VECTORS\n 4 RGB COLOR MODEL AND COMPONENTS OF VECTORS\n 5 THE COORDINATE SYSTEM\n 6 RESOLUTION, THE FRAME SIZE\n 7 COORDINATE TRANSFORMATION\n 8 HORIZONTAL AND VERTICAL LINES\n 9 VISUALISING THE COORDINATE SYSTEM\n10 MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n11 MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n12 DISK\n13 FUNCTIONS\n14 BUILT-IN FUNCTIONS: STEP\n15 BUILT-IN FUNCTIONS: CLAMP\n16 BUILT-IN FUNCTIONS: SMOOTHSTEP\n17 BUILT-IN FUNCTIONS: MIX\n18 ANTI-ALIASING WITH SMOOTHSTEP\n19 FUNCTION PLOTTING\n20 COLOR ADDITION AND SUBSTRACTION\n21 COORDINATE TRANSFORMATIONS: ROTATION\n22 COORDINATE TRANSFORMATIONS: SCALING\n23 SUCCESSIVE COORDINATE TRANSFORMATIONS\n24 TIME, MOTION AND ANIMATION\n25 PLASMA EFFECT\n26 TEXTURES\n27 MOUSE INPUT\n28 RANDOMNESS\n*/\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#if TUTORIAL == 1\n// VOID. BLANK SCREEN.\n//\n// \"main\" function is called several times per second to produce\n// the shader effect.\n// The system aims to produces a speed of 60 frames per second (FPS).\n// But if the GLSL script is computationally hard, then the frame\n// rate drops. (You can read the frame rate at the info bar below\n// the screen.\n//\n// Because we are not doing anything in the function\n// this shader will produce a black screen.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#elif TUTORIAL == 2\n// SOLID COLOR\n//\n// \"fragColor\" is the output variable of the shader.\n// Its value determines the image on the screen.\n// This shaders sets its value to be the yellow color.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1.0, 1.0, 0.0 ,1.0);\n}\n\n\n#elif TUTORIAL == 3\n// GLSL VECTORS\n//\n// fragColor\" should be assigned a vec4 object, which is made \n// of four numbers between 0 and 1.\n// First three numbers determines the color, and fourth number\n// determines the opacity.\n// (For now changing the transparancy value will have no effect)\n// A \"vec4\" data object can be constructed by giving 4 \"float\" arguments,\n// or one \"vec3\" and one \"float\" argument.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Here we are seperating the color and transparency parts\n\t// of the vec4 that represents the pixels.\n\tvec3 color = vec3(0.0, 1.0, 1.0);\n\tfloat alpha = 1.0;\n\t\n\tvec4 pixel = vec4(color, alpha);\n\tfragColor = pixel;\n}\n\n#elif TUTORIAL == 4\n// RGB COLOR MODEL AND COMPONENTS OF VECTORS\n//\n// After initialized, the components of vectors can be reached using\n// the dot \".\" notation.\n//\n// RGB: http://en.wikipedia.org/wiki/RGB_color_model\n// A color is represented by three numbers (here in the range [0.0, 1.0])\n// The model assumes the addition of pure red, green and blue lights\n// of given intensities.\n//\n// If you lack design skills like me, and having hard time\n// in choosing nice looking, coherent set of colors \n// you can use one of these websites to choose color palettes, where\n// you can browse different sets of colors \n// https://kuler.adobe.com/create/color-wheel/\n// http://www.colourlovers.com/palettes\n// http://www.colourlovers.com/colors\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// play with these numbers:\n\tfloat redAmount = 0.6; // amount of redness\n\tfloat greenAmount = 0.2; // amount of greenness\n\tfloat blueAmount = 0.9; // amount of blueness\n\t\n\tvec3 color = vec3(0.0); \n\t// Here we only input a single argument. It is a third way of\n\t// contructing vectors.\n\t// \"vec3(x)\" is equivalent to vec3(x, x, x);\n\t// This vector is initialized as\n\t// color.x = 0.0, color.y = 0.0; color.z = 0.0;\n\tcolor.x = redAmount;\n\tcolor.y = greenAmount;\n\tcolor.z = blueAmount;\n\t\n\tfloat alpha = 1.0;\n\tvec4 pixel = vec4(color, alpha);\t\n\tfragColor = pixel;\n}\n\n\n#elif TUTORIAL == 5\n// THE COORDINATE SYSTEM\n//\n// \"fragCoord\", \"fragment coordinate\" is an input variable.\n//\n// It tells us at which pixel we are on the screen. The coordinate center\n// is the left bottom corner, and coordinate values increases towards\n// right and upwards.\n//\n// The main function is run for each and every pixel on the screen. At\n// each call the \"gl_FracCoord\" has the coordinates of the corresponding\n// pixel.\n//\n// GPUs have many cores, so, the function calls for different pixels\n// can be calculated in parallel at the same time.\n// This allows higher speeds than the calculation of pixel colors one\n// by one in series on the CPU. But, it puts an important constraint too:\n// The value of a pixel cannot depend on the value of another pixel. (the\n// calculations are done in parallel and it is impossible to know which\n// one will finish before the other one)\n// The outcome of a pixel can only depend on the pixel coordinate (and\n// some other input variables.)\n// This is the most important difference of shader programming. We'll\n// come to this point again and again\n//\n// Let's draw something that is not a solid color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// choose two colors\n\tvec3 color1 = vec3(0.886, 0.576, 0.898);\n\tvec3 color2 = vec3(0.537, 0.741, 0.408);\n\tvec3 pixel;\n\t\n\t// if the x coordinate is greater than 100 then plot color1\n\t// else plot color2\n\tfloat widthOfStrip = 100.0;\n\tif( fragCoord.x > widthOfStrip ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color1;\n\t}\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 6\n// RESOLUTION, THE FRAME SIZE\n//\n// If you resize your browser, or go to fullscreen mode and come back\n// you'll see that the ratio of the width of the first color to the\n// second color changes with screen size.\n// It is because we set the width of the strip in absolute number of\n// pixels, rather than as a proportion of the screen width and height.\n//\n// Say we want to paint the left and right halves with different colors.\n// Without knowing the number of pixels horizontally, we cannot prepare\n// a shader that works on all frame sizes.\n// \n// How can we learn the screen size (the width and height) in terms of \n// the number of pixel. It is given us in the variable \"iResolution\".\n// \"iResolution.x\" is the width of the frame, and\n// \"iResolution.y\" is the height of the frame\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color1 = vec3(0.741, 0.635, 0.471);\n\tvec3 color2 = vec3(0.192, 0.329, 0.439);\n\tvec3 pixel;\n\t\n\t// sugar syntax for \"if\" conditional. It says\n\t// \"if the x coordinate of a pixel is greater than the half of\n\t// the width of the screen, then use color1, otherwise use\n\t// color2.\"\n\tpixel = ( fragCoord.x > iResolution.x / 2.0 ) ? color1 : color2;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 7\n// COORDINATE TRANSFORMATION\n// \n// Instead of working on screen coordinates, using our own coordinate\n// system is more convenient most of the time.\n//\n// Here we will make and use a new coordinate system \"r\", instead of\n// the absolute screen coordinates \"fragCoord\". In \"r\"\n// the x and y coordinates will go from 0 to 1. For x, 0 is the left\n// side and 1 is the right side. For y, 0 is the bottom side, and 1 is\n// the upper side.\n//\n// Using \"r\" let's divide the screen into 3 parts.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2(fragCoord.x / iResolution.x,\n\t\t\t\t  fragCoord.y / iResolution.y);\n\t// r is a vec2. Its first component is pixel x-coordinate divided by\n\t// the frame width. And second component is the pixel y-coordinate\n\t// divided by the frame height.\n\t//\n\t// For example, on my laptop, the full screen frame size is\n\t// 1440 x 900. Therefore iResolution is (1440.0, 900.0).\n\t// The main function should be run 1440*900=1296000 times to\n\t// generate a frame.\n\t// fragCoord.x will have values between 0 and 1439, and\n\t// fragCoord.y will have values between 0 and 899, whereas\n\t// r.x and r.y will have values between [0,1].\n\t\n\tvec3 color1 = vec3(0.841, 0.582, 0.594);\n\tvec3 color2 = vec3(0.884, 0.850, 0.648);\n\tvec3 color3 = vec3(0.348, 0.555, 0.641);\n\tvec3 pixel;\n\t\n\t// sugar syntax for \"if\" conditional. It says\n\t// \"if the x coordinate of a pixel is greater than the half of\n\t// the width of the screen, then use color1, otherwise use\n\t// color2.\"\n\tif( r.x < 1.0/3.0) {\n\t\tpixel = color1;\n\t} else if( r.x < 2.0/3.0 ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color3;\n\t}\n\t\t\t\n\t// pixel = ( r.x < 1.0/3.0 ) ? color1 : (r.x<2.0/3.0) ? color2: color3;\n\t// same code, single line.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 8\n// HORIZONTAL AND VERTICAL LINES\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t// shorter version of the same coordinate transformation.\n\t// For example \"aVector.xy\" is a new vec2 made of the first two \n\t// components of \"aVector\".\n\t// And, when division operator is applied between vectors,\n\t// each component of the first vector is divided by the corresponding\n\t// component of the second vector.\n\t// So, first line of this tutorial is the same as the first line\n\t// of the previous tutorial.\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 color1 = vec3(0.216, 0.471, 0.698);\n\tvec3 color2 = vec3(1.00, 0.329, 0.298);\n\tvec3 color3 = vec3(0.867, 0.910, 0.247);\n\n\t// start by setting the background color. If pixel's value\n\t// is not overwritten later, this color will be displayed.\n\tvec3 pixel = backgroundColor;\n\t\n\t// if the current pixel's x coordinate is between these values,\n\t// then put color 1.\n\t// The difference between 0.55 and 0.54 determines\n\t// the with of the line.\n\tfloat leftCoord = 0.54;\n\tfloat rightCoord = 0.55;\n\tif( r.x < rightCoord && r.x > leftCoord ) pixel = color1;\n\t\n\t// a different way of expressing a vertical line\n    // in terms of its x-coordinate and its thickness:\n\tfloat lineCoordinate = 0.4;\n\tfloat lineThickness = 0.003;\n\tif(abs(r.x - lineCoordinate) < lineThickness) pixel = color2;\n\t\n\t// a horizontal line\n\tif(abs(r.y - 0.6)<0.01) pixel = color3;\n\t\n\t// see how the third line goes over the first two lines.\n\t// because it is the last one that sets the value of the \"pixel\".\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 9\n// VISUALISING THE COORDINATE SYSTEM\n//\n// Let's use a for loop and horizontal and vertical lines to draw\n// a grid of the coordinate center\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// start by setting the background color. If pixel's value\n\t// is not overwritten later, this color will be displayed.\n\tvec3 pixel = backgroundColor;\n\t\n\t// Draw the grid lines\n\t// we used \"const\" because loop variables can only be manipulated\n\t// by constant expressions.\n\tconst float tickWidth = 0.1;\n\tfor(float i=0.0; i<1.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.002) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.002) pixel = gridColor;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.005 ) pixel = axesColor;\n\tif( abs(r.y)<0.006 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 10\n// MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n//\n// Instead of mapping [0, iResolution.x]x[0, iResolution.y] region to\n// [0,1]x[0,1], lets map it to [-1,1]x[-1,1]. This way the coordinate\n// (0,0) will not be at the lower left corner of the screen, but in the\n// middle of the screen.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tr = 2.0 * r.xy / iResolution.xy;\n\t// [-0.5*iResolution.x, 0.5*iResolution.x] -> [-1.0, 1.0]\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// start by setting the background color. If pixel's value\n\t// is not overwritten later, this color will be displayed.\n\tvec3 pixel = backgroundColor;\n\t\n\t// Draw the grid lines\n\t// This time instead of going over a loop for every pixel\n    // we'll use mod operation to achieve the same result\n    // with a single calculation (thanks to mikatalk)\n\tconst float tickWidth = 0.1;\n\tif( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n    if( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n    // Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 11\n// MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n//\n// As we have seen from the previous examples, we do get rectangles\n// instead of squares when we plot the coordinate systems.\n// It is because, we assigned same numerical interval, [0,1] to different\n// physical distances. Actually the width of the frame is bigger \n// than of its height.\n// So, to keep the aspect ratio, we should not map the actual distances\n// [0, iResolution.x] and [0, iResolution.y] to the same interval.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tr = 2.0 * r.xy / iResolution.y;\n\t// instead of dividing r.x to iResolution.x and r.y to iResolution.y\n\t// divide both of them to iResolution.y.\n\t// This way r.y will be in [-1.0, 1.0]\n\t// and r.x will depend on the frame size. I guess the non-full screen\n\t// mode rx will be in [-1.78, 1.78], and in full screen mode\n\t// for my laptop, it will be in [-1.6, 1.6] (1440./900.=1.6)\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.004) pixel = gridColor;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 12\n// DISK\n//\n// Let's draw disks\n//\n// So, in GLSL we don't give a command of \"draw this disk here with that\n// color\". Instead we use an indirect command such as \"if the pixel \n// coordinate is inside this disk, put that color for the pixel\"\n// The indirect commands are a bit counter intuitive until you\n// get used to that way of thinking.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 colBlue = vec3(0.216, 0.471, 0.698);\n\tvec3 colRed = vec3(1.00, 0.329, 0.298);\n\tvec3 colYellow = vec3(0.867, 0.910, 0.247);\n\n\tvec3 pixel = bgCol;\n\t\n\t// To draw a shape we should know the analytic geometrical\n\t// expression of that shape.\n\t// A circle is the set of points that has the same distance from\n\t// it its center. The distance is called radius.\n\t// The distance from the coordinate center is sqrt(x*x + y*y)\n\t// Fix the distance as the radius will give the formula for\n\t// a circle at the coordinate center\n\t// sqrt(x*x + y*y) = radius\n\t// The points inside the circle, the disk, is given as\n\t// sqrt(x*x + y*y) < radius\n\t// Squaring both sides will give\n\t// x*x + y*y < radius*radius\n\tfloat radius = 0.8;\n\tif( r.x*r.x + r.y*r.y < radius*radius ) {\n\t\tpixel = colBlue;\n\t}\n\t\n\t// There is a shorthand expression for sqrt(v.x*v.x + v.y*v.y)\n\t// of a given vector \"v\", which is \"length(v)\"\n\tif( length(r) < 0.3) {\n\t\tpixel = colYellow;\n\t}\n\t\n\t// draw a disk of which center is not at (0,0).\n\t// Say the center is at c: (c.x, c.y). \n\t// The distance of any point r: (r.x, r.y) to c is \n\t// sqrt((r.x-c.x)^2+(r.y-c.y)^2)\n\t// define a distance vector d: (r.x - c.x, r.y - c.y)\n\t// in GLSL d can be calculated \"d = r - c\".\n\t// Just as in division, substraction of two vectors is done\n\t// component by component.\n\t// Then, length(d) means sqrt(d.x^2+d.y^2)\n\t// which is the distance formula we are looking for.\n\tvec2 center = vec2(0.9, -0.4);\n\tvec2 d = r - center;\n\tif( length(d) < 0.6) {\n\t\tpixel = colRed;\n\t}\n\t// This shifting of the center of the shape works for any\n\t// kind of shape. If you have a formula in terms of r\n\t// f(r) = 0, then f(r-c)=0 expresses the same geometric shape\n\t// but its coordinate is shifted by c.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// Note how the latest disk is shown and previous ones are left\n// behind it. It is because the last if condition changes the pixel\n// value at the end.\n// If the coordinates of pixel fits multiple if conditions, the last\n// manipulation will remain and fragColor is set to that one.\n\n\n#elif TUTORIAL == 13\n// FUNCTIONS\n//\n// Functions are great for code reuse. Let's put the code for disks\n// into a function and use the function for drawing.\n// There are so many different ways of writing a function to draw a shape.\n//\n// Here we have a void function that does not return anything. Instead,\n// \"pixel\" is taken as an \"inout\" expression. \"inout\" is a unique\n// keyword of GLSL.\n// By default all arguments are \"in\" arguments. Which\n// means, the value of the variable is given to the function scope\n// from the scope the function is called. \n// An \"out\" variable gives the value of the variable from the function\n// to the scope in which the function is called.\n// An \"inout\" argument does both. First the value of the variable is\n// sent to the function as its argument. Then, that variable is\n// processed inside the function. When the function ends, the value\n// of the variable is updated where the function is called.\n//\n// Here, the \"pixel\" variable that is initialized with the background\n// color in the \"main\" function. Then, \"pixel\" is given to the \"disk\"\n// function. When the if condition is satisfied the value of the \"pixel\"\n// is changed with the \"color\" argument. If it is not satified, the\n// \"pixel\" is left untouched and keeps it previous value (which was the\n// \"bgColor\".\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tdisk(r, vec2(0.1, 0.3), 0.5, col3, pixel);\n\tdisk(r, vec2(-0.8, -0.6), 1.5, col1, pixel);\n\tdisk(r, vec2(0.8, 0.0), .15, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// As you see, the borders of the disks have \"jagged\" curves, where\n// individual pixels can be seen. This is called \"aliasing\". It occurs\n// because pixels have finite size and we want to draw a continuous\n// shape on a discontinuous grid.\n// There is a method to reduce the aliasing. It is done by mixing the\n// inside color and outside colors at the border. To achieve this\n// we have to learn some built-in functions.\n\n// And, again, note the order of disk function calls and how they are\n// drawn on top of each other. Each disk function manipulates\n// the pixel variable. If a pixel is manipulated by multiple disk\n// functions, the value of the last one is sent to fragColor.\n\n// In this case, the previous values are completely overwritten.\n// The final value only depends to the last function that manipulated\n// the pixel. There are no mixtures between layers.\n\n\n#elif TUTORIAL == 14\n// BUILT-IN FUNCTIONS: STEP\n//\n// \"step\" function is the Heaviside step function :-)\n// http://en.wikipedia.org/wiki/Heaviside_step_function\n// \n// f(x0, x) = {1 x>x0, \n//            {0 x<x0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into five parts horizontally\n\t// for different examples\n\tif(r.x < -0.6*xMax) { // Part I\n\t\tvariable = r.y;\n\t\tedge = 0.2;\n\t\tif( variable > edge ) { // if the \"variable\" is greater than \"edge\"\n\t\t\tret = 1.0;          // return 1.0\n\t\t} else {                // if the \"variable\" is less than \"edge\"\n\t\t\tret = 0.0;          // return 0.0\n\t\t}\n\t} \n\telse if(r.x < -0.2*xMax) { // Part II\n\t\tvariable = r.y;\n\t\tedge = -0.2;\n\t\tret = step(edge, variable); // step function is equivalent to the\n\t\t                            // if block of the Part I\n\t} \n\telse if(r.x < 0.2*xMax) { // Part III\n\t\t// \"step\" returns either 0.0 or 1.0.\n\t\t// \"1.0 - step\" will inverse the output\n\t\tret = 1.0 - step(0.5, r.y); // Mirror the step function around edge\n\t} \n\telse if(r.x < 0.6*xMax) { // Part IV\n\t\t// if y-coordinate is smaller than -0.4 ret is 0.3\n\t\t// if y-coordinate is greater than -0.4 ret is 0.3+0.5=0.8\n\t\tret = 0.3 + 0.5*step(-0.4, r.y);\n\t}\n\telse { // Part V\n\t\t// Combine two step functions to create a gap\n\t\tret = step(-0.3, r.y) * (1.0 - step(0.2, r.y));\n\t\t// \"1.0 - ret\" will create a gap\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 15\n// BUILT-IN FUNCTIONS: CLAMP\n//\n// \"clamp\" function saturates the input below and above the thresholds\n// f(x, min, max) = { max x>max\n//                  { x   max>x>min\n//                  { min min>x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 0.25) { // Part I\n\t\tret = p.y; // the brightness value is assigned the y coordinate\n\t\t           // it'll create a gradient\n\t} \n\telse if(p.x < 0.5) { // Part II\n\t\tfloat minVal = 0.3; // implementation of clamp\n\t\tfloat maxVal = 0.6;\n\t\tfloat variable = p.y;\n\t\tif( variable<minVal ) {\n\t\t\tret = minVal;\n\t\t}\n\t\tif( variable>minVal && variable<maxVal ) {\n\t\t\tret = variable;\n\t\t}\n\t\tif( variable>maxVal ) {\n\t\t\tret = maxVal;\n\t\t}\n\t} \n\telse if(p.x < 0.75) { // Part III\n\t\tfloat minVal = 0.6;\n\t\tfloat maxVal = 0.8;\n\t\tfloat variable = p.y;\n\t\tret = clamp(variable, minVal, maxVal);\n\t} \n\telse  { // Part IV\n\t\tfloat y = cos(5.*TWOPI*p.y); // oscillate between +1 and -1\n\t\t                             // 5 times, vertically\n\t\ty = (y+1.0)*0.5; // map [-1,1] to [0,1]\n\t\tret = clamp(y, 0.2, 0.8);\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 16\n// BUILT-IN FUNCTIONS: SMOOTHSTEP\n//\n// \"smoothstep\" function is like step function but instead of a\n// sudden jump from 0 to 1 at the edge, it makes a smooth transition\n// in a given interval\n// http://en.wikipedia.org/wiki/Smoothstep\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\tfloat edge = 0.5;\n\t\tret = step(edge, p.y); // simple step function\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// linearstep (not a builtin function)\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = (p.y - edge0)/(edge1 - edge0);\n\t\t// when p.y == edge0 => t = 0.0\n\t\t// when p.y == edge1 => t = 1.0\n\t\t// RHS is a linear function of y\n\t\t// so, between edge0 and edge1, t has a linear transition\n\t\t// between 0.0 and 1.0\n\t\tfloat t1 = clamp(t, 0.0, 1.0);\n\t\t// t will have negative values when t<edge0 and\n\t\t// t will have greater than 1.0 values when t>edge1\n\t\t// but we want it be constraint between 0.0 and 1.0\n\t\t// so, clamp it!\t\t\n\t\tret = t1;\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// implementation of smoothstep\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n\t\tfloat t1 = 3.0*t*t - 2.0*t*t*t;\n\t\t// previous interpolation was linear. Visually it does not\n\t\t// give an appealing, smooth transition.\n\t\t// To achieve smoothness, implement a cubic Hermite polynomial\n\t\t// 3*t^2 - 2*t^3\n\t\tret = t1;\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tret = smoothstep(0.45, 0.55, p.y);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// smootherstep, a suggestion by Ken Perlin\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\t\t\n\t\t// 6*t^5 - 15*t^4 + 10*t^3\n\t\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\t\tret = t1;\n\t\t// faster transition and still smoother\n\t\t// but computationally more involved.\n\t}\t\n\t\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 17\n// BUILT-IN FUNCTIONS: MIX\n//\n// A shader can be created by first constructing individual parts\n// and composing them together.\n// There are different ways of how to combine different parts.\n// In the previous disk example, different disks were drawn on top\n// of each other. There was no mixture of layers. When disks\n// overlap, only the last one is visible.\n//\n// Let's learn mixing different data types (in this case vec3's\n// representing colors\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow \n\t\n\tvec3 ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\t// implementation of mix\n\t\tfloat x0 = 0.2; // first item to be mixed\n\t\tfloat x1 = 0.7;  // second item to be mixed\n\t\tfloat m = 0.1; // amount of mix (between 0.0 and 1.0)\n\t\t// play with this number\n\t\t// m = 0.0 means the output is fully x0\n\t\t// m = 1.0 means the output is fully x1\n\t\t// 0.0 < m < 1.0 is a linear mixture of x0 and x1\n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// try all possible mix values \n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// use the mix function\n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = mix(x0, x1, m);\n\t\tret = vec3(val);\t\t\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\t// mix colors instead of numbers\n\t\tfloat m = p.y;\n\t\tret = mix(col1, col2, m);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// combine smoothstep and mix for color transition\n\t\tfloat m = smoothstep(0.5, 0.6, p.y);\n\t\tret = mix(col1, col2, m);\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 18\n// ANTI-ALIASING WITH SMOOTHSTEP\n//\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\tfloat m;\n\t\n\tfloat radius = 0.4; // increase this to see the effect better\n\tif( r.x < -0.5*xMax ) { // Part I\n\t\t// no interpolation, yes aliasing\n\t\tm = step( radius, length(r - vec2(-0.5*xMax-0.4,0.0)) );\n\t\t// if the distance from the center is smaller than radius,\n\t\t// then mix value is 0.0\n\t\t// otherwise the mix value is 1.0\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < -0.0*xMax ) { // Part II\n\t\t// linearstep (first order, linear interpolation)\n\t\tm = linearstep( radius-0.005, radius+0.005, length(r - vec2(-0.0*xMax-0.4,0.0)) );\n\t\t// mix value is linearly interpolated when the distance to the center\n\t\t// is 0.005 smaller and greater than the radius.\n\t\tpixel = mix(col1, bgCol, m);\n\t}\t\n\telse if( r.x < 0.5*xMax ) { // Part III\n\t\t// smoothstep (cubical interpolation)\n\t\tm = smoothstep( radius-0.005, radius+0.005, length(r - vec2(0.5*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < 1.0*xMax ) { // Part IV\n\t\t// smootherstep (sixth order interpolation)\n\t\tm = smootherstep( radius-0.005, radius+0.005, length(r - vec2(1.0*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 19\n// FUNCTION PLOTTING\n//\n// It is always useful to see the plots of functions on cartesian\n// coordinate system, to understand what they are doing precisely\n//\n// Let's plot some 1D functions!\n// \n// If y value is a function f of x value, the expression of their\n// relation is: y = f(x)\n// in other words, the plot of a function is all points\n// that satisfy the expression: y-f(x)=0\n// this set has 0 thickness, and can't be seen.\n// Instead use the set of (x,y) that satisfy: -d < y-f(x) < d\n// in other words abs(y-f(x)) < d\n// where d is the thickness. (the thickness in in y direction)\n// Because of the properties of absolute function, the condition\n// abs(y-f(x)) < d is equivalent to the condition:\n// abs(f(x) - y) < d\n// We'll use this last one for function plotting. (in the previous one\n// we have to negate the function that we want to plot)\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid plot(vec2 r, float y, float lineThickness, vec3 color, inout vec3 pixel) {\n\tif( abs(y - r.y) < lineThickness ) pixel = color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tvec3 col1 = vec3(0.841, 0.582, 0.594);\n\tvec3 col2 = vec3(0.884, 0.850, 0.648);\n\tvec3 col3 = vec3(0.348, 0.555, 0.641);\t\n\n\tvec3 pixel = bgCol;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridCol;\n\t\tif(abs(r.y - i)<0.004) pixel = gridCol;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesCol;\n\tif( abs(r.y)<0.007 ) pixel = axesCol;\n\t\n\t// Draw functions\n\tfloat x = r.x;\n\tfloat y = r.y;\n\t// pink functions\n\t// y = 2*x + 5\n\tif( abs(2.*x + .5 - y) < 0.02 ) pixel = col1;\n\t// y = x^2 - .2\n\tif( abs(r.x*r.x-0.2 - y) < 0.01 ) pixel = col1;\n\t// y = sin(PI x)\n\tif( abs(sin(PI*r.x) - y) < 0.02 ) pixel = col1;\n\t\n\t// blue functions, the step function variations\n\t// (functions are scaled and translated vertically)\n\tif( abs(0.25*step(0.0, x)+0.6 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*linearstep(-0.5, 0.5, x)+0.1 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smoothstep(-0.5, 0.5, x)-0.4 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smootherstep(-0.5, 0.5, x)-0.9 - y) < 0.01 ) pixel = col3;\n\t\n\t// yellow functions\n\t// have a function that plots functions :-)\n\tplot(r, 0.5*clamp(sin(TWOPI*x), 0.0, 1.0)-0.7, 0.015, col2, pixel);\n\t// bell curve around -0.5\n\tplot(r, 0.6*exp(-10.0*(x+0.8)*(x+0.8)) - 0.1, 0.015, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// in the future we can use this framework to see the plot of functions\n// and design and find functions for our liking\n// Actually using Mathematica, Matlab, matplotlib etc. to plot functions\n// is much more practical. But they need a translation of functions \n// from GLSL to their language. Here we can plot the native implementations\n// of GLSL functions.\n\n\n#elif TUTORIAL == 20\n// COLOR ADDITION AND SUBSTRACTION\n//\n// How to draw a shape on top of another, and how will the layers\n// below, affect the higher layers?\n//\n// In the previous shape drawing functions, we set the pixel\n// value from the function. This time the shape function will\n// just return a float value between 0.0 and 1.0 to indice the\n// shape area. Later that value can be multiplied with some color\n// and used in determining the final pixel color.\n\n// A function that returns the 1.0 inside the disk area\n// returns 0.0 outside the disk area\n// and has a smooth transition at the radius\nfloat disk(vec2 r, vec2 center, float radius) {\n\tfloat distanceFromCenter = length(r-center);\n\tfloat outsideOfDisk = smoothstep( radius-0.005, radius+0.005, distanceFromCenter);\n\tfloat insideOfDisk = 1.0 - outsideOfDisk;\n\treturn insideOfDisk;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 black = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\tvec3 gray = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\t\n\tvec3 ret;\n\tfloat d;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\t// opaque layers on top of each other\n\t\tret = gray;\n\t\t// assign a gray value to the pixel first\n\t\td = disk(r, vec2(-1.1,0.3), 0.4);\n\t\tret = mix(ret, col1, d); // mix the previous color value with\n\t\t                         // the new color value according to\n\t\t                         // the shape area function.\n\t\t                         // at this line, previous color is gray.\n\t\td = disk(r, vec2(-1.3,0.0), 0.4);\n\t\tret = mix(ret, col2, d);\n\t\td = disk(r, vec2(-1.05,-0.3), 0.4); \n\t\tret = mix(ret, col3, d); // here, previous color can be gray,\n\t\t                         // blue or pink.\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\t// Color addition\n\t\t// This is how lights of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Additive_color\n\t\tret = black; // start with black pixels\n\t\tret += disk(r, vec2(0.1,0.3), 0.4)*col1; // add the new color\n\t\t                                         // to the previous color\n\t\tret += disk(r, vec2(-.1,0.0), 0.4)*col2;\n\t\tret += disk(r, vec2(.15,-0.3), 0.4)*col3;\n\t\t// when all components of \"ret\" becomes equal or higher than 1.0\n\t\t// it becomes white.\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\t// Color substraction\n\t\t// This is how dye of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Subtractive_color\n\t\tret = white; // start with white\n\t\tret -= disk(r, vec2(1.1,0.3), 0.4)*col1;\n\t\tret -= disk(r, vec2(1.05,0.0), 0.4)* col2;\n\t\tret -= disk(r, vec2(1.35,-0.25), 0.4)* col3;\t\t\t\n\t\t// when all components of \"ret\" becomes equals or smaller than 0.0\n\t\t// it becomes black.\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 21\n// COORDINATE TRANSFORMATIONS: ROTATION\n//\n// Up to now, we translated to coordinate center to draw geometric\n// shapes at different parts of the screen.\n// Lets learn how to rotate the shapes.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the rectangle\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tvec2 q;\n\tfloat angle;\n\tangle = 0.2*PI; // angle in radians (PI is 180 degrees)\n\t// q is the rotated coordinate system\n\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\n\tret = bgCol;\n\t// draw the old and new coordinate systems\n\tret = mix(ret, col1, coordinateGrid(r)*0.4 );\n\tret = mix(ret, col2, coordinateGrid(q) );\n\t\n\t// draw shapes in old coordinate system, r, and new coordinate system, q\n\tret = mix(ret, col1, disk(r, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col2, disk(q, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col1, rectangle(r, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\tret = mix(ret, col2, rectangle(q, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\t// as you see both circle are drawn at the same coordinate, (1,0),\n\t// in their respective coordinate systems. But they appear\n\t// on different locations of the screen\n\t\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 22\n// COORDINATE TRANSFORMATIONS: SCALING\n//\n// Scaling the coordinate system.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the rectangle\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\t\n\t// original\n\tret = mix(ret, col1, coordinateGrid(r)/2.0);\n\t// scaled\n    float scaleFactor = 3.3; // zoom in this much\n\tvec2 q = r / scaleFactor;\n\tret = mix(ret, col2, coordinateGrid(q)/2.0);\n\n\tret = mix(ret, col2, disk(q, vec2(0.0, 0.0), 0.1));\t\n\tret = mix(ret, col1, disk(r, vec2(0.0, 0.0), 0.1));\n\t\n\tret = mix(ret, col1, rectangle(r, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\tret = mix(ret, col2, rectangle(q, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\t\n\t// note how the rectangle that are not centered at the coordinate origin\n\t// changed its location after scaling, but the disks at the center\n\t// remained where they are.\n\t// This is because scaling is done by multiplying all pixel\n\t// coordinates with a constant.\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 23\n// SUCCESSIVE COORDINATE TRANSFORMATIONS\n//\n// Drawing a shape on the desired location, with desired size, and\n// desired orientation needs mastery of succesive application of\n// transformations.\n//\n// In general, transformations do not commute. Which means that\n// if you change their order, you get different results.\n//\n// Let's try application of transformations in different orders.\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\n\tfloat angle = 0.6;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\t\n\n\tif(p.x < 1./2.) { // Part I\n\t\t// put the origin at the center of Part I\n\t\tr = r - vec2(-xMax/2.0, 0.0); \n\n\t\tvec2 rotated = rotationMatrix*r;\n\t\tvec2 rotatedTranslated = rotated - vec2(0.4, 0.5);\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(rotated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(rotatedTranslated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(rotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(rotatedTranslated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t} \n\telse if(p.x < 2./2.) { // Part II\n\t\tr = r - vec2(xMax*0.5, 0.0); \n\n\t\tvec2 translated = r - vec2(0.4, 0.5);\n\t\tvec2 translatedRotated = rotationMatrix*translated;\n\t\t\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(translated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(translatedRotated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(translated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(translatedRotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\t\t\n\t} \t\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 24\n// TIME, MOTION AND ANIMATION\n//\n// One of the inputs that a shader gets can be the time.\n// In ShaderToy, \"iTime\" variable holds the value of the\n// time in seconds since the shader is started.\n//\n// Let's change some variables in time!\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\t\n\tif(p.x < 1./5.) { // Part I\n\t\tvec2 q = r + vec2(xMax*4./5.,0.);\n\t\tret = vec3(0.2);\n\t\t// y coordinate depends on time\n\t\tfloat y = iTime;\n\t\t// mod constraints y to be between 0.0 and 2.0,\n\t\t// and y jumps from 2.0 to 0.0\n\t\t// substracting -1.0 makes why jump from 1.0 to -1.0\n\t\ty = mod(y, 2.0) - 1.0;\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), 0.1) );\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\tvec2 q = r + vec2(xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\t// oscillation\n\t\tfloat amplitude = 0.8;\n\t\t// y coordinate oscillates with a period of 0.5 seconds\n\t\tfloat y = 0.8*sin(0.5*iTime*TWOPI);\n\t\t// radius oscillates too\n\t\tfloat radius = 0.15 + 0.05*sin(iTime*8.0);\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), radius) );\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\tvec2 q = r + vec2(xMax*0./5.,0.);\n\t\tret = vec3(0.4);\n\t\t// booth coordinates oscillates\n\t\tfloat x = 0.2*cos(iTime*5.0);\n\t\t// but they have a phase difference of PI/2\n\t\tfloat y = 0.3*cos(iTime*5.0 + PI/2.0);\n\t\tfloat radius = 0.2 + 0.1*sin(iTime*2.0);\n\t\t// make the color mixture time dependent\n\t\tvec3 color = mix(col1, col2, sin(iTime)*0.5+0.5);\n\t\tret = mix(ret, color, rect(q, vec2(x-0.1, y-0.1), vec2(x+0.1, y+0.1)) );\t\t\n\t\t// try different phases, different amplitudes and different frequencies\n\t\t// for x and y coordinates\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tvec2 q = r + vec2(-xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\tfor(float i=-1.0; i<1.0; i+= 0.2) {\n\t\t\tfloat x = 0.2*cos(iTime*5.0 + i*PI);\n\t\t\t// y coordinate is the loop value\n\t\t\tfloat y = i;\n\t\t\tvec2 s = q - vec2(x, y);\n\t\t\t// each box has a different phase\n\t\t\tfloat angle = iTime*3. + i;\n\t\t\tmat2 rot = mat2(cos(angle), -sin(angle), sin(angle),  cos(angle));\n\t\t\ts = rot*s;\n\t\t\tret = mix(ret, col1, rect(s, vec2(-0.06, -0.06), vec2(0.06, 0.06)) );\t\t\t\n\t\t}\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\tvec2 q = r + vec2(-xMax*4./5., 0.);\n\t\tret = vec3(0.2);\n\t\t// let stop and move again periodically\n\t\tfloat speed = 2.0;\n\t\tfloat t = iTime*speed;\n\t\tfloat stopEveryAngle = PI/2.0;\n\t\tfloat stopRatio = 0.5;\n\t\tfloat t1 = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\t\t\n\t\tfloat x = -0.2*cos(t1);\n\t\tfloat y = 0.3*sin(t1);\n\t\tfloat dx = 0.1 + 0.03*sin(t*10.0);\n\t\tfloat dy = 0.1 + 0.03*sin(t*10.0+PI);\n\t\tret = mix(ret, col1, rect(q, vec2(x-dx, y-dy), vec2(x+dx, y+dy)) );\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 25\n// PLASMA EFFECT\n//\n// We said that the a pixel's color only depends on its coordinates\n// and other inputs (such as time)\n// \n// There is an effect called Plasma, which is based on a mixture of\n// complex function in the form of f(x,y).\n//\n// Let's write a plasma!\n//\n// http://en.wikipedia.org/wiki/Plasma_effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(length(r) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./10.) { // Part I\n\t\t// vertical waves\n\t\tret = vec3(v1);\n\t} \n\telse if(p.x < 2./10.) { // Part II\n\t\t// horizontal waves\n\t\tret = vec3(v2);\n\t} \n\telse if(p.x < 3./10.) { // Part III\n\t\t// diagonal waves\n\t\tret = vec3(v3);\n\t}\n\telse if(p.x < 4./10.) { // Part IV\n\t\t// circular waves\n\t\tret = vec3(v4);\n\t}\n\telse if(p.x < 5./10.) { // Part V\n\t\t// the sum of all waves\n\t\tret = vec3(v);\n\t}\t\n\telse if(p.x < 6./10.) { // Part VI\n\t\t// Add periodicity to the gradients\n\t\tret = vec3(sin(2.*v));\n\t}\n\telse if(p.x < 10./10.) { // Part VII\n\t\t// mix colors\n\t\tv *= 1.0;\n\t\tret = vec3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t}\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}\n\n\n\n#elif TUTORIAL == 26\n// TEXTURES\n//\n// ShaderToy can use upto four textures. \n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\tret = texture(iChannel1, p).xyz;\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\tret = texture(iChannel1, 4.*p+vec2(0.,iTime)).xyz;\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\tr = r - vec2(xMax*2./3., 0.);\n\t\tfloat angle = iTime;\n\t\tmat2 rotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tvec2 q = rotMat*r;\n\t\tvec3 texA = texture(iChannel1, q).xyz;\n\t\tvec3 texB = texture(iChannel2, q).xyz;\n\t\t\n\t\tangle = -iTime;\n\t\trotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tq = rotMat*r;\t\t\n\t\tret = mix(texA, texB, rect(q, vec2(-0.3, -0.3), vec2(.3, .3)) );\n\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 27\n// MOUSE INPUT\n//\n// ShaderToy gives the mouse cursor coordinates and button clicks\n// as an input via the iMouse vec4.\n//\n// Let's write a shader with basic Mouse functionality.\n// When clicked on the frame, the little disk will follow the\n// cursor. The x coordinate of the cursor changes the background color.\n// And if the cursor is inside the bigger disk, it'll color will change.\n\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\t// background color depends on the x coordinate of the cursor\n\tvec3 bgCol = vec3(iMouse.x / iResolution.x);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec2 center;\n\t// draw the big yellow disk\n\tcenter = vec2(100., iResolution.y/2.);\n\tfloat radius = 60.;\n\t// if the cursor coordinates is inside the disk\n\tif( length(iMouse.xy-center)>radius ) {\n\t\t// use color3\n\t\tret = mix(ret, col3, disk(fragCoord.xy, center, radius));\n\t}\n\telse {\n\t\t// else use color2\n\t\tret = mix(ret, col2, disk(fragCoord.xy, center, radius));\n\t}\t\n\t\n\t// draw the small blue disk at the cursor\n\tcenter = iMouse.xy;\n\tret = mix(ret, col1, disk(fragCoord.xy, center, 20.));\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n#elif TUTORIAL == 28\n// RANDOMNESS\n//\n// I don't know why, but GLSL does not have random number generators.\n// This does not pose a problem if you are writing your code in\n// a programming language that has random functions. That way\n// you can generate the random values using the language and send\n// those values to the shader via uniforms.\n//\n// But if you are using a system that only allows you to write\n// the shader code, such as ShaderToy, then you need to write your own\n// pseuo-random generators.\n//\n// Here is a pattern that I saw again and again in many different\n// shaders at ShaderToy.\n// Let's draw N different disks at random locations using this pattern.\n\nfloat hash(float seed)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec2 hashPosition(float x)\n{\n\t// Return a \"random\" position based on the \"seed\"\n\treturn vec2(hash(x), hash(x * 1.1));\n}\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.005, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.01, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.y));\n\treturn ret;\n}\n\nfloat plot(vec2 r, float y, float thickness) {\n\treturn ( abs(y - r.y) < thickness ) ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec3 white = vec3(1.);\n\tvec3 gray = vec3(.3);\n\tif(r.y > 0.7) {\n\t\t\n\t\t// translated and rotated coordinate system\n\t\tvec2 q = (r-vec2(0.,0.9))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// just the regular sin function\n\t\tfloat y = sin(5.*q.x) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.1));\n\t}\n\telse if(r.y > 0.4) {\n\t\tvec2 q = (r-vec2(0.,0.6))*vec2(1.,20.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\t// take the decimal part of the sin function\n\t\tfloat y = fract(sin(5.*q.x)) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\t\n\telse if(r.y > 0.1) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0.,0.25))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// scale up the outcome of the sine function\n\t\t// increase the scale and see the transition from\n\t\t// periodic pattern to chaotic pattern\n\t\tfloat scale = 10.0;\n\t\tfloat y = fract(sin(5.*q.x) * scale) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.2));\n\t}\t\n\telse if(r.y > -0.2) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0., -0.0))*vec2(1.,10.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\tfloat seed = q.x;\n\t\t// Scale up with a big real number\n\t\tfloat y = fract(sin(seed) * 43758.5453) * 2.0 - 1.0;\n\t\t// this can be used as a pseudo-random value\n\t\t// These type of function, functions in which two inputs\n\t\t// that are close to each other (such as close q.x positions)\n\t\t// return highly different output values, are called \"hash\"\n\t\t// function.\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\n\telse {\n\t\tvec2 q = (r-vec2(0., -0.6));\n\t\t\n\t\t// use the loop index as the seed\n\t\t// and vary different quantities of disks, such as\n\t\t// location and radius\n\t\tfor(float i=0.0; i<6.0; i++) {\n\t\t\t// change the seed and get different distributions\n\t\t\tfloat seed = i + 0.0; \n\t\t\tvec2 pos = (vec2(hash(seed), hash(seed + 0.5))-0.5)*3.;;\n\t\t\tfloat radius = hash(seed + 3.5);\n\t\t\tpos *= vec2(1.0,0.3);\n\t\t\tret = mix(ret, col1, disk(q, pos, 0.2*radius));\n\t\t}\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n\n\n/* End of tutorials */\n\n#elif TUTORIAL == 0\n// WELCOME SCREEN\nfloat square(vec2 r, vec2 bottomLeft, float side) {\n\tvec2 p = r - bottomLeft;\n\treturn ( p.x > 0.0 && p.x < side && p.y>0.0 && p.y < side ) ? 1.0 : 0.0;\n}\n\nfloat character(vec2 r, vec2 bottomLeft, float charCode, float squareSide) {\n\tvec2 p = r - bottomLeft;\n\tfloat ret = 0.0;\n\tfloat num, quotient, remainder, divider;\n\tfloat x, y;\t\n\tnum = charCode;\n\tfor(int i=0; i<20; i++) {\n\t\tfloat boxNo = float(19-i);\n\t\tdivider = pow(2., boxNo);\n\t\tquotient = floor(num / divider);\n\t\tremainder = num - quotient*divider;\n\t\tnum = remainder;\n\t\t\n\t\ty = floor(boxNo/4.0); \n\t\tx = boxNo - y*4.0;\n\t\tif(quotient == 1.) {\n\t\t\tret += square( p, squareSide*vec2(x, y), squareSide );\n\t\t}\n\t}\n\treturn ret;\n}\n\nmat2 rot(float th) { return mat2(cos(th), -sin(th), sin(th), cos(th)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat G = 990623.; // compressed characters :-)\n\tfloat L = 69919.;\n\tfloat S = 991119.;\n\t\n\tfloat t = iTime;\n\n\tvec2 r = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t//vec2 rL = rot(t)*r+0.0001*t;\n\t//vec2 rL = r+vec2(cos(t*0.02),sin(t*0.02))*t*0.05;\n\tfloat c = 0.05;//+0.03*sin(2.5*t);\n\tvec2 pL = (mod(r+vec2(cos(0.3*t),sin(0.3*t)), 2.0*c)-c)/c;\n\tfloat circ = 1.0-smoothstep(0.75, 0.8, length(pL));\n\tvec2 rG = rot(2.*3.1415*smoothstep(0.,1.,mod(1.5*t,4.0)))*r;\n\tvec2 rStripes = rot(0.2)*r;\n\t\t\t\t\n\tfloat xMax = 0.5*iResolution.x/iResolution.y;\n\tfloat letterWidth = 2.0*xMax*0.9/4.0;\n\tfloat side = letterWidth/4.;\n\tfloat space = 2.0*xMax*0.1/5.0;\n\t\n\tr += 0.001; // to get rid off the y=0 horizontal blue line.\n\tfloat maskGS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskG = character(rG, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskL1 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*1.0, L, side);\n\tfloat maskSS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0, S, side);\n\tfloat maskS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0 + vec2(0.01*sin(2.1*t),0.012*cos(t)), S, side);\n\tfloat maskL2 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*3.0, L, side);\n\tfloat maskStripes = step(0.25, mod(rStripes.x - 0.5*t, 0.5));\n\t\n\tfloat i255 = 0.00392156862;\n\tvec3 blue = vec3(43., 172., 181.)*i255;\n\tvec3 pink = vec3(232., 77., 91.)*i255;\n\tvec3 dark = vec3(59., 59., 59.)*i255;\n\tvec3 light = vec3(245., 236., 217.)*i255;\n\tvec3 green = vec3(180., 204., 18.)*i255;\n\n\tvec3 pixel = blue;\n\tpixel = mix(pixel, light, maskGS);\n\tpixel = mix(pixel, light, maskSS);\n\tpixel -= 0.1*maskStripes;\t\n\tpixel = mix(pixel, green, maskG);\n\tpixel = mix(pixel, pink, maskL1*circ);\n\tpixel = mix(pixel, green, maskS);\n\tpixel = mix(pixel, pink, maskL2*(1.-circ));\n\t\n\tfloat dirt = pow(texture(iChannel0, 4.0*r).x, 4.0);\n\tpixel -= (0.2*dirt - 0.1)*(maskG+maskS); // dirt\n\tpixel -= smoothstep(0.45, 2.5, length(r));\n\tfragColor = vec4(pixel, 1.0);\n}\n#endif", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md23DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "Md23W3", "name": "Boink!", "author": "andyalias", "description": "Inspired by the old Amiga 'Boing' demos and some ShaderToy physics demos like ioccc_fan's excellent https://www.shadertoy.com/view/4dl3Wf.", "tags": ["amiga", "boing", "physics"], "likes": 11, "viewed": 1010, "published": "Public", "date": "1394708744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAY_STEPS 75\n#define PI 3.14159265\n\n#define t iTime*2.0\n\nmat3 ball_rot;\n\nvec2 polarRepeat(vec2 p, float r) {\n    float a = mod( atan(p.y,p.x), r) - r*0.5;\n    return vec2(cos(a),sin(a)) * length(p.xy);\n}\n\nfloat ball(vec3 p, vec2 sides, float size, out vec3 c) {\n\t\n\tmat3 r = ball_rot;\n\t\n\tp = r * p;\n\t\n\tp.xz = polarRepeat(p.xz, PI/sides.x);\n\tp.xy = polarRepeat(p.xy, PI/sides.y);\n\n\tfloat checkers = max(0.0,step(p.y*p.z, 0.0));\n\t\n\tc = vec3(1.0, vec2(checkers)) * 2.0;\n\t\n\treturn dot(p,vec3(1.0,0.0,0.0))-size;\n}\n\nfloat fourth_wall = 0.0;\n\nvec4 scene(vec3 p) {\n\t\n\tvec3 c;\n\t\n\tfloat width =12.0;\n\t\n\tfloat x = width*abs(fract(t/10.0)-0.5) - width*0.25;\n\tfloat z = width*abs(fract((-t+2.)/10.0)-0.5) - width*0.25 + 0.2;\n\t\t\n\tfloat t2 = max(t*4.0 - 15.0,0.0);\n\t\n\tfloat bounce = 1.0 + max(15.0-t*4.0,0.0) + 0.35*log(1.0+abs(10.0*sin(t2*0.33)));\n\t\n\tvec3 pos = p - vec3(x, bounce, z);\n\t\n\tfloat b = ball(pos, vec2(8.0,8.0), 2.0, c);\n\n\tfloat g = dot(p,vec3(0.0,1.0,0.0)) + 1.0;\n\n\tif(fourth_wall > 0.0) p.z = abs(p.z);\n\t\n\tfloat w1 = dot(p,vec3(0.0,0.0,-1.0)) + 5.0;\n\tfloat w2 = dot(vec3(abs(p.x),p.yz),vec3(-1.0,0.0,0.0)) + 5.0;\t\n\t\n\tvec3 wallc = vec3(0.67) + normalize(p)*0.05;\n\n\tvec4 d = g<b ? vec4(g,wallc) : vec4(b,c);\n\t\n\td = w1<d.x ? vec4(w1,wallc) : d;\n\td = w2<d.x ? vec4(w2,wallc) : d;\n\t\n\treturn d;\n}\n\nvec3 normal(vec3 p) {\n\n    vec2 o = vec2(0.00001,0.0);\n\n\tfloat d = scene(p).x;\n\t\n    float d1 = d-scene(p+o.xyy).x;\n    float d2 = d-scene(p+o.yxy).x;\n    float d3 = d-scene(p+o.yyx).x;\n\n    return normalize(vec3(d1,d2,d3));\n}\n\nfloat AO(vec3 p, vec3 normal) {\n\n    float a = 1.1;\n\n\tfloat c = 0.0;\n    float s = 0.25;\n\n    for(int i=0; i<4; i++) {\n\t    c += s;\n        a *= 1.0-max(0.0, (c -scene(p + normal*c).x) * s / c);\n    }\n\t\n    return clamp(a,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float ball_angle = t/3.0;\n    vec3 forward = vec3(0.0,-cos(ball_angle),sin(ball_angle));\n    vec3 side    = normalize(cross(forward, vec3(1.0, 0.0, 0.0)));\n    vec3 up      = normalize(cross(forward, side));\n\n    ball_rot = mat3(forward,side,up);\n\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n    vec3 dir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), 1.0));\t\n\t\n    vec3 cam = vec3(0.0,1.8,-10.0);\n\n\tvec3 p = cam;\n\n\tvec4 d;\n\t\n\tfourth_wall  = 0.0;\n\t\n    for(int i=0; i<MAX_RAY_STEPS; i++) {\n\t\td = scene(p);\n        p += d.x * dir;\n    }\n\t\n\tfourth_wall = 1.0;\n\t\n    vec3 n = -normal(p-dir*0.00001);\n\n    vec3 l = vec3(0.0,7,-4.0);\n\n\tvec3 diffuse = d.yzw;\n\t\t\n\tfloat ao = AO(p, 0.5*(n+normalize(n+l)));\n\t\n\tvec3 c = diffuse * ao;\n\t\n\tc += pow(max(0.0, dot(n, normalize(l-p))),1.5);\n\t\n\tc -= c * length(cam-p)*0.055;\n\t\t\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md23W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 120, 120, 215], [217, 217, 273, 273, 520], [548, 548, 568, 568, 1302], [1304, 1304, 1325, 1325, 1530], [1532, 1532, 1563, 1563, 1765], [1767, 1767, 1824, 1824, 2707]], "test": "ok"}
{"id": "Md23Wc", "name": "FlowNoiseFire", "author": "Antonalog", "description": "firey flow noise..Took nikat's simplex noise, added analytic derivatves, couldn't resist making yet another fire effect.", "tags": ["noise", "fire", "flow"], "likes": 73, "viewed": 3848, "published": "Public", "date": "1394705121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//http://mrl.nyu.edu/~perlin/flownoise-talk/#17\n\n\nvec4 dnoise(vec3 p);\n\nvec4 quat_rotation( float half_angr, vec3 unitVec );\n\nvec2 screen_uv;\nvec4 quat;\n\nfloat Checker2(vec2 uv)\n{\n\tfloat s = sin(uv.x)*cos(uv.y);\n\t//s = s*s*s*s*s;\n\treturn s;\n}\n\nvec4 FlowNoise(vec3 uvw, vec2 uv)\n{\n\tvec4 n = vec4(0.);\n\n\tfloat f = 1.;\n\tfloat a = 1.;\n\t\t\t\n\tfloat lac = 2.13;\n\t\n#if 0\t\n\tfor (int i=0; i<5; i++)\n\t{\t\n\t\t//offsetting swirl angle relative to position seems to flow along the gradient\n\t\tfloat ang = iTime*.4;//+uv.y*0.5;\n\t\t\n\t\tang *= Checker2(uvw.xy*0.0125);\n\t\t\n\t\tvec3 ax = normalize(vec3(1,1,1)); \n//\t\tvec3 ax = texture(iChannel0,vec2(float(i)*0.1,0.)).xyz*2.-1.;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\n\t\tfloat e = 0.1;//*f;\n\t\t\n\t\t//advect by going back in domain along noise gradient\n\t\tvec4 dn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\t\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\t}\n#else\n\tvec3 ax = normalize(vec3(1,1,1)); \n\tfloat e = 0.1;//*f;\n\tfloat ang;\n\tvec4 dn;\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\t\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\n\t\tang = iTime*.4+uv.y*0.5;\n\t\tquat = quat_rotation( ang*2.*f, normalize(ax) );\n\t\tdn = dnoise(uvw);\n\t\tuvw -= 0.01*dn.xyz;\n\t\tn += abs(a*dn);\n\t\tuvw *= lac;\n\t\tf *= lac;\n\t\ta *= (1./lac);\n\t\n#endif\n\t\n\treturn n;\n}\n\t\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tuv.x *= iResolution.x/iResolution.y;\t\n\tuv.y = 1. - uv.y;\n\tscreen_uv = uv;\n\t\n\tfloat t = iTime*0.8;\n\tvec3 uvw = vec3(uv*1.15+vec2(0.,t),t*0.5);\n\n\n\tvec4 d = FlowNoise(uvw,uv);\n\tfloat de = d.w;\n\tde = length(d.xyz)*.15+.2-d.w*.2;\n\tvec3 n = FlameColour(de);\n\n\t\n\tfragColor = vec4(vec3(n),1.0);\n}\n\nvec4 quat_rotation( float half_angr, vec3 unitVec )\n{\n    float s, c;\n    s = sin( half_angr );\n    c = cos( half_angr );\n    return vec4( unitVec*s, c );\n}\n\nvec3 quat_times_vec(vec4 q, vec3 v)\n{\n\t//http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n\tvec3 t = 2. * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n/* Created by Nikita Miropolskiy, nikat/2013\n * This work is licensed under a \n * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * http://creativecommons.org/licenses/by-nc-sa/3.0/\n *  - You must attribute the work in the source code \n *    (link to https://www.shadertoy.com/view/XsX3zB).\n *  - You may not use this work for commercial purposes.\n *  - You may distribute a derivative work only under the same license.\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) \n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\tr = r-0.5;\n\n\t\n\t//rotate for extra flow!\n\tr=quat_times_vec(quat,r);\n\t\n\treturn r;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec4 dnoise(vec3 p) \n{\n\t /* 1. find current tetrahedron T and its four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t vec3 s = floor(p + (p.x+p.y+p.z)*F3);\n\t vec3 x = p - s + (s.x+s.y+s.z)*G3;\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \t\t \n\t /* calculate surflet weights */\n\t vec4 w;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\t\t//aka t0,t1,t2,t3\n\t vec4 w2 = w*w;\t\t\t\t//aka t20,t21,t22,t23\n\t vec4 w4 = w2*w2;\t\t\t//aka t40,t41,t42,t43\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec3 g0 = random3(s);\n\t vec3 g1 = random3(s + i1);\n\t vec3 g2 = random3(s + i2);\n\t vec3 g3 = random3(s + 1.0);\n\t \n\t vec4 d;\n\t /* calculate surflet components */\n\t d.x = dot(g0, x);\t\t//aka graddotp3( gx0, gy0, gz0, x0, y0, z0 )\n\t d.y = dot(g1, x1);\n\t d.z = dot(g2, x2);\n\t d.w = dot(g3, x3);\n\t \n\t //derivatives as per\n\t //http://webstaff.itn.liu.se/~stegu/aqsis/flownoisedemo/srdnoise23.c\n\t vec4 w3 = w*w2;\n\t vec4 temp = w3*d;\n\t vec3 dnoise = temp[0]*x;\n\t     dnoise += temp[1]*x1;\n\t     dnoise += temp[2]*x2;\n\t\t dnoise += temp[3]*x3;\n\t\t dnoise *= -8.;\n\t\t dnoise += w4[0]*g0+w4[1]*g1+w4[2]*g2+w4[3]*g3;\n\t\t dnoise *= 52.; //???\n\t\t \n\t d *= w4;\t//aka n0,n1,n2,n3\n\t \n\tfloat n = (d.x+d.y+d.z+d.w)*52.;\n\t\n\treturn vec4(dnoise,n);\n}\n\n//http://www.csee.umbc.edu/~olano/s2002c36/ch02.pdf\n// t = 0.6 - (u^2+v^2+w^2)\n// if (t>0) 8 t^4 else 0\n\t", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md23Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 154, 179, 179, 242], [244, 244, 279, 279, 1917], [1920, 1920, 1942, 1942, 2111], [2113, 2160, 2194, 2194, 2372], [2374, 2374, 2415, 2415, 2530], [2532, 2532, 2559, 2559, 2632], [2634, 2634, 2691, 2691, 3024], [3026, 3026, 3079, 3079, 3182], [3184, 3184, 3221, 3316, 3389], [3844, 3917, 3940, 3940, 4179], [4181, 4286, 4308, 4531, 5921]], "test": "error"}
{"id": "Md2GDt", "name": "[TDF2014] caress", "author": "w23", "description": "specially for 7x79 GLSL compo at Tokyo Demo Fest 2014", "tags": ["raymarching", "noise", "fur"], "likes": 37, "viewed": 2488, "published": "Public", "date": "1395476418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// to-shadertoy preamble\n#define time (iTime)\n#define t (iTime)\n#define resolution (iResolution.xy)\n/*float time=iTime;vec2 resolution=iResolution.xy;*/float N(vec2 v){return fract(sin(dot\n\n//orig: uniform float time;uniform vec2 resolution;float N(vec2 v){return fract(sin(dot\n(vec2(7.,23.),v))*519.);}vec2 e=vec2(1.,0.),s,f,F;float M(vec2 v){F=floor(v);f=\nfract(v);f*=f*(3.-2.*f);return mix(mix(N(F),N(F+e.xy),f.x),mix(N(F+e.yx),N(F+e.\nxx),f.x),f.y);}float B(vec2 v){return M(v)+.5*M(v*2.)+.2*M(v*8.);}\nfloat l=0.,r;void mainImage( out vec4 fragColor, in vec2 fragCoord ){for(int i=0;i<99;++i){vec3 q=vec3(fragCoord.xy/resolution\n-.5,1.)*l;q.z-=2.;q.x*=1.8;r=length(q)-1.;s=42.*(q.xy+M(vec2(r-t*.5))-M(vec2(r-\nt*.3))*e.xy);l+=.4*(r+.2*B(s));}fragColor=1.-vec4(B(s),B(s+.1),B(s+.3),1.);}\n\n// I DEMAND AN EXPLANATION\n//\n// TL;DR: not much, just some common techinques squeezed together.\n//\n// let's break down the lines a bit:\n//\n// line 1:\n// obvious and uninteresting uniform declarations\n// \tuniform float time;uniform vec2 resolution;\n//\n// lines 1-2:\n// hash noise function R^2 -> R\n// \tfloat N(vec2 v) { \n//\t\treturn fract(sin(\n//\n// get from vec2 to float\n//\t\t\tdot(vec2(7.,23.),v)\n//\t\t)*519.);\n//\t}\n//\n// line 2:\n// declare all vec2 vars in one place so there as little declaration overhead as possible\n// \tvec2 e=vec2(1.,0.),s,f,F;\n// \n// lines 2-4:\n// C2-smooth value noise from hash noise.\n// simply a bilinear interpolation of 4 adjacent hashes\n// \tfloat M(vec2 v){\n//\n// cell params\n// F = bottom-left vertex coordinates\n// f = sampling point coords relative to F\n// \t\tF=floor(v);\n//\t\tf=fract(v);\n//\n// guarantee smoothness:\n//\t\tf*=f*(3.-2.*f);\n//\n// interpolate bilinearly\n//\t\treturn mix(\n//\t\t\tmix(N(F),N(F+e.xy),f.x),\n//\t\t\tmix(N(F+e.yx),N(F+e.xx),f.x),\n//\t\t\tf.y);\n//\t}\n//\n// line 4:\n// fractal value noise sum with 3 octaves\n//\tfloat B(vec2 v){\n//\t\treturn\n//\t\t\tM(v)\n//\t\t\t+.5*M(v*2.)\n//\t\t\t+.2*M(v*8.);\n//\t}\n//\n// lines 4-5:\n// as before with vec2 declare all float variables in one place\n// float t=time,l=0.,r;\n// l is raymarched distance\n//\n// lines 5-7: void main\n// simple sdf raymarching\n// \tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n//\n// for max 99 ray samples\n//\t\tfor(int i=0;i<99;++i){\n//\n// calculate ray sample position from screen pixel coords and marched distance l\n//\t\t\tvec3 q=vec3(fragCoord.xy/resolution-.5,1.)*l;\n//\n// begin ray at (0., 0., -2.)\n//\t\t\tq.z-=2.;\n//\n// fix aspect at ~16:9\n//\t\t\tq.x*=1.8;\n//\n// get distance to sphere center\n// \t\t\tr=length(q)-1.;\n//\n// calculate displacement map coordinates\n// \t\t\ts=42.*(\n//\n// begin with current xy screen coordinates\n//\t\t\t\tq.xy\n//\n// add random \"bottom-left to top-right\" rotation\n// note that we have only a vec2 noise function so we need to wrap arguments in vec2.\n// this is cheaper than having separate float N(float) by a few bytes.\n// subtracting time from radius gives the wavy fur look\n//\t\t\t\t+M(vec2(r-t*.5))\n//\n// add analogous random \"right to left\" rotation just to add one more visible degree of freedom\n//\t\t\t\t-M(vec2(r-t*.3))*e.xy);\n//\n// sample radius displacement as fractal noise and step along the ray accordingly\n//\t\t\tl+=.4*(r+.2*B(s));\n//\t\t}\n//\n// re-use displacement coordinates as a hash value for determining color\n//\t\tfragColor=1.-vec4(B(s),B(s+.1),B(s+.3),1.);\n//\t}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md2GDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 152, 168, 168, 303], [328, 328, 344, 344, 453], [453, 453, 469, 469, 504], [518, 518, 574, 574, 788]], "test": "ok"}
{"id": "MdB3Dt", "name": "Expanding Starfield", "author": "zanneth", "description": "Expanding starfield", "tags": ["2d", "space", "polar"], "likes": 22, "viewed": 1128, "published": "Public", "date": "1395378367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MOVEMENT_SPEED 0.02\n#define MIN_RADIUS 0.01\n#define MAX_RADIUS 0.3\n#define STAR_COUNT 200\n#define PI 3.14159265358979323\n#define TWOPI 6.283185307\n\n#define RADIUS_SEED 1337.0\n#define START_POS_SEED 2468.0\n#define THETA_SEED 1675.0\n\nconst vec3 backgroundColor = vec3(0.0, 0.0, 0.3);\nconst vec3 starColor = vec3(1.0, 1.0, 1.0);\n\nfloat rand(float s1, float s2)\n{\n\treturn fract(sin(dot(vec2(s1, s2), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat saturate(float v)\n{\n\treturn clamp(v, 0.0, 1.0);\n}\n\nvec2 cartesian(vec2 p)\n{\n\treturn vec2(p.x * cos(p.y), p.x * sin(p.y));\n}\n\nvec3 renderBackground(vec2 uv, float aspect)\n{\n\tvec2 center = vec2(0.0);\n\tfloat dist = length(uv - center);\n\tvec3 col = saturate(1.0 / (dist + 1.5)) * backgroundColor;\n\treturn col;\n}\n\nvec3 renderStars(vec2 uv, float aspect)\n{\n\tvec3 col = vec3(0.0);\n\tfloat maxDistance = aspect;\n\n\tfor (int i = 0; i < STAR_COUNT; ++i) {\n\t\t// setup radius\n\t\tfloat radiusrand = rand(float(i), RADIUS_SEED);\n\t\tfloat rad = MIN_RADIUS + radiusrand * (MAX_RADIUS - MIN_RADIUS);\n\t\t\n\t\t// compute star position\n\t\tfloat startr = rand(float(i), START_POS_SEED) * maxDistance;\n\t\tfloat speed = radiusrand * MAX_MOVEMENT_SPEED;\n\t\tfloat r = mod(startr + iTime * speed, max(1.0, maxDistance));\n\t\tfloat theta = rand(float(i), THETA_SEED) * TWOPI;\n\t\tvec2 pos = cartesian(vec2(r, theta));\n\t\tpos.x *= aspect;\n\t\t\n\t\t// blending/effects\n\t\tfloat dist = length(uv - pos);\n\t\tfloat distFromStarCenter = dist / rad;\n\t\tfloat distTraveled = r / maxDistance;\n\t\tfloat shape = saturate(1.0 / (50.0 * (1.0 / distTraveled) * distFromStarCenter) - 0.05);\n\t\t\n\t\tcol += starColor * step(dist, rad) * shape;\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n\tuv.x *= aspect;\n\t\n\tvec3 col = renderBackground(uv, aspect);\n\tcol += renderStars(uv, aspect);\n\t\n\tfragColor = vec4(col.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdB3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 371, 371, 448], [450, 450, 475, 475, 505], [507, 507, 531, 531, 579], [581, 581, 627, 627, 763], [765, 765, 806, 806, 1648], [1650, 1650, 1707, 1707, 1942]], "test": "ok"}
{"id": "MdB3Wd", "name": "BluFlame - Reflected", "author": "xTr1m", "description": "A shadertoy adaptation of the PC 4k released at Evoke 2013.\nhttp://www.pouet.net/prod.php?which=61720", "tags": ["raymarching", "4k", "bluflame", "evoke", "reflected"], "likes": 1, "viewed": 494, "published": "Public API", "date": "1395093307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int shader = 0; // Change to 0, 1, 2 or 3\n\n#define time (iTime * 0.125)\n\nfloat Yy() // Base drum sync\n{\n\treturn smoothstep(0.4, 0.6, (1.0 - mod(2.0 * iTime, 1.0)));\n}\nfloat Yz() // Snare sync\n{\n\treturn pow(1.0 - mod(iTime + 0.5, 1.0), 2.0);\n}\n\n// All data of our world\nfloat L, CurScene, CurTime, CurAnim, CurStep, cFac, VolLight, pi2= 6.28319, LightHeight = 50.0;\nint m;\nvec3 cRes, CurColor, RayStep;\n\nvec2 rotate(vec2 v,float y)\n{\n\treturn cos(y)*v+sin(y)*vec2(-v.y,v.x);\n}\n\n//repeat around y axis w times\n//void rp(inout vec3 p, float trans, float w) \nfloat repeatr(inout vec2 v,float x, float y) \n{\n    float a= atan(v.y,v.x);\n\tfloat z=mod(a,y)-y*.5;\n\tv=(length(v))*vec2(cos(z),sin(z));\n\tv.x-=x;\n    return a-z;\n}\n \nvoid repeat( inout float w, float y )\n{\n\tw= mod( w - y*.5, y ) - y*.5;\n}\n\nvoid repeate( inout float w, float y, float z )\n{\n\tw= max( abs(w)-z, mod( w - y*.5, y ) - y*.5);\n}\n\nfloat CBox( in vec3 p, in vec3 box, float rad )\n{\n    return length( max( abs(p) - box + vec3(rad), 0.0 ) ) - rad;\n}\n\n\nfloat plasm(float x, float a, float b,float c)\n{\n\treturn sin(x+a+c*sin(x+b));\n}\n\nvec3 shad2move()\n{\n\treturn vec3( CurTime*19.0, 24.0 - cos(CurAnim*9.0) * 8.0, cos(CurAnim*5.0) * 24.0);\n}\n\nvoid schad3transform( inout vec3 p )\n{\n\tp.xz = rotate(p.xz, 0.2 * cos( pow(abs(p.x),0.4 - CurTime * 0.1)) );\n\tp.yx = rotate(p.yx, 0.2 * cos( pow(abs(p.x),0.3 + CurTime * 0.1)) );\n}\n\nfloat round(float x)\n{\n\treturn floor(x + .5);\n}\n\nfloat f0(vec3 p)\n{\n\tif( shader == 0 )\n\t{\n\t\tschad3transform(p);\n\t\trepeat(p.x, 0.5);\n\t\treturn max( length(p.x) - 0.1, CBox( p, vec3(1000.,1.4,1.4), .5));\n\t}\n\tif( shader == 1 )\n\t{\n\t\tp -= shad2move();\n\t\t//p.y = rotate(p.yz, 50. *CurAnim );\n\t\tp.x = length (p.xz)+4.0*Yy() - 12.5;\n\t\trepeat (p.x, 24.0);\n\t\treturn length( max( abs(p.xy) - vec2(3., .2), 0.0 ) ) - 0.2;\n\t}\n\tif( shader == 2 )\n\t{\n\t\t p.y += plasm( \n\t\t\t0.1 * p.x,\n\t\t\t0.1 * p.z,\n\t\t\tCurTime* 10.0,\n\t\t\t1.0 );\n\t\tfloat d = p.x;\n\t\trepeat(p.x, pi2);\n\t\tp.y -= 0.3 * cos(  (p.z + d - p.x)*.5);\n\t\tp.z += 128.0 * CurTime * cos(0.7 * (d-p.x) );\n\t\trepeat(p.z, 2.4);\n\t\treturn CBox( p, vec3(1.0, 0.1, 1.0), 0.1); \n\t}\n\tif( shader == 3 )\n\t{\n\t\tp.x -= 128. * CurAnim;\n\t\trepeat(p.x, 64.);\n\t\tp.x = length( p.x ) - 11.;\n\t\treturn (p.x < 0.0 ? length( p.yz ): length( p )) -  5.0 ;\n\t}\n}\n\nfloat f1(vec3 p)\n{\n\tif( shader == 0 || shader == 3)\n\t{\n\t\tfloat d = p.y - 5.;\n        p.x *= 1.0;\n\t\trepeat(p.x, 20.);\n\t\trepeatr(p.yz, 28.0, pi2 / 9.0);\n\t\treturn max( d,  CBox( p, vec3(10.,2.0,10.), 3.));\n\t}\n\tif( shader == 1)\n\t{\n\t\tvec3 o= p;\n\t\trepeat(p.x, 8.0);\n\t\trepeat(p.z, 8.0);\n\t\to -= shad2move();\n\t\tp.xz = rotate(p.xz, atan(o.x, o.z) );\n\t\tp.yz = rotate(p.yz, atan(length(o.xz), 48.0) );\n\t\tfloat d = CBox( p, vec3(2.5 , 2.0, 2.5), 0.8); \n\t\tp.y += 12. + plasm( \n\t\t\t0.1 * o.x,\n\t\t\t0.1 * o.z,\n\t\t\tCurTime* 10.0,\n\t\t\t1.0 );\n\t\treturn max(d,  length(p)- 12.);\n\t}\n\tif( shader == 2 )\n\t{\n\t\tp.y += plasm( \n\t\t\t0.1 * p.x,\n\t\t\t0.1 * p.z,\n\t\t\tCurTime* 10.0,\n\t\t\t1.0 );\n\t\tfloat d = p.z;\n\t\trepeat(p.z, pi2);\n\t\tp.y += 0.3 * cos( (p.x + d - p.z)*.5);\n\t\treturn CBox( p, vec3(1000.0, 0.1, 2.0), 0.1); \n\t}\n}\n\nfloat f2(vec3 p)\n{\n\tif( shader == 0)\n\t{\n\t\tschad3transform(p);\n\t\tp.x += 256.0 * CurAnim;\n\t\trepeat(p.x, 32.0);\n\t\treturn length(vec2(length(p.yz) - 3.0,p.x)) - 1.- Yy();\n\t}\n\tif( shader == 1 )\n\t{\n\t\treturn length(p-shad2move()) - 12.0;\n\t}\n\tif( shader == 2 )\n\t{\n\t\tp.y -= 8.;\n\n\t\tfloat d = p.x;\n\t\trepeat(p.x, 32.0);\n\n\t\tp.yz = rotate(p.yz, plasm(d-p.x, 2., CurAnim, 1.0)- Yz() );\n\t\tp.xz = rotate(p.xz, plasm(d-p.x, 1., CurAnim, 2.0) );\n\n\t\treturn CBox( p, vec3(8.0), 6. - CurAnim);\n\t}\n\tif( shader == 3 )\n\t{\n\t\tp.yz = rotate(p.yz, plasm(round(p.x / 8.0), 1., 4.0*CurTime, 2.0) );\n\t\trepeat(p.x, 8.0);\n\t\trepeatr(p.yz, 0.0, pi2 / 10.0);\n\t\treturn max( abs(length(p.yz) - 6.0)-.2, abs(length(p.xz) - 2.+0.5*Yy())-.3);\n\t}\n}\n\nfloat f3(vec3 p)\n{\n\tif( shader == 0)\n\t{\n\t\tschad3transform(p);\n\t\treturn CBox( p, vec3(1000.,1.,1.), .1);\n\t}\n\tif( shader == 1 )\n\t{\n\t\tp.y += 20.;\n\t\trepeat( p.x, 6.3);\n\t\trepeat( p.z, 1.3);\n\t\t//repeatr(p.xz, .0, pi2 / 4.0);\n\t\treturn CBox( p, vec3(3.0, 15.0, 0.5), 0.4);\n\t}\n\tif( shader == 2 )\n\t{\n\t\tp.y -= 20.;\n\t\trepeat( p.x, 20.0);\n\t\trepeat( p.z, 20.0);\n\t\trepeatr(p.xz, .0, pi2 / 4.0);\n\t\treturn CBox( p, vec3(1000.0, 1.0, 1.0), 0.2);\n\t}\n\tif( shader == 3 )\n\t{\n\t\trepeat(p.z, 6.);\n\t\trepeat(p.x, 5.5);\n\t\trepeatr(p.xz, 2.0, pi2 / 6.0);\n\t\treturn max( abs(1.-length(p.xz))-0.1,abs(length(p.y)-15.0)-0.1);\n\t}\n\n}\n\n\nfloat f(vec3 p)\n{\n\treturn (0.003 - Yy() * 0.007) * plasm(p.x+Yy()*9., p.y, p.z,  1.0-Yy()) + min( min( min( f0(p), f1(p) ), f2(p) ), f3(p) );\n}\n\nfloat l(vec2 p)\n{\n    float d = floor(0.5 - p.y/32.0) + floor(0.5 - p.x/70.0) * 3.;\n    if( shader == 1 || shader == 2 )\n\t{\n\t\td= plasm( 33.0 * floor(0.5 - p.y/20.0), 5.0 * floor(0.5 - p.x/20.0), 17.0 * floor(CurTime * 16.0 + 0.5), 1.0);\n\t\trepeate( p.x, 20.0, 60.0 );\n\t\trepeat( p.y, 20.0);\n\t\tL = length( max( abs(p) - vec2(3.0), 0.0 ) ) + 2.5;// max( length(p.x), length(p.y));\n        if (d > 0.5)\n\t\t\tL +=  2.0*Yy();\n\t}\n\telse if( shader == 0 || shader == 3 )\n\t{\n\t\trepeate( p.y, 32.0, 32.0 );\n\t\trepeat( p.x, 70.0 );\n\t\tp.x = length(p.x) - 25.0;\n\t\tL =  2.0 - Yz() + (p.x < 0. ? length(p.y) : length(p));\n\t}\n    if( CurScene == 0.0 )\n\t    return max(0.0, 4.0 * smoothstep(10.,-pow(sin(d+CurTime*10.0*CurTime*220.0)+sin(d)+CurTime*10.0-4.0,.2),L));\n\n    return 4.0 * smoothstep(10.,0.0,L);\n}\n\n\nvoid mat(vec3 p)\n{\n\tCurColor = vec3(0.,.65,.2 );\n\t//CurColor = vec3(1.0,.3,0.9 );\n\tCurStep= .3;\n\t//CurNormal.y= 1.5;\n\t\n\tfloat z= f0(p);\n\tif( z > f1(p) )\n\t{\n\t\tz= f1(p);\n\t\tCurColor = vec3(0.1);\n\t\tCurStep= 0.85;\n\t\t//CurNormal.y= 0.15;\n\t}\n\t\t\n\tif( z > f2(p) )\n\t{\n\t\tz= f2(p);\n\t\tCurColor = vec3(1.0,.0,0.0 );\n\t\t//CurColor = vec3(0.1,1.0,.0 );\t\n\t\tCurStep= .2;\n\t\t//CurNormal.y= 0.0;\n\t}\n\n\tif( z > f3(p) )\n\t{\n\t\t//Wz= f3(p);\n\n\t\tCurColor = vec3(.25);// + animTex(p.zy / 10.0) * 0.6;\n\t\tCurStep= .1;\n\t\tm=2;\n\t}\n}\n\nvoid ToRes(vec3 Color, float Factor)\n{\n\tcRes+= Color * cFac;\n\tcFac*= Factor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat st = float(shader) * 4.0 + mod(time, 4.0);\n\tCurScene= floor(st);\n\tCurTime= st - CurScene;\n\tCurAnim= CurTime;\n\n\t// Get the look direction for the current pixel (always look forwards)\n\tvec3 rayDir = vec3( 0.6, (vec2(iResolution.x/iResolution.y, 1)*(fragCoord.yx / iResolution.xy) - 0.5));\n\t\n\t//Kamera sitzt an dieser Position\n\tvec3 p;\n\n\tif( CurScene == 0.0 )\n\t{\n\t\tp= vec3(  CurTime * 120. - 120. , -24.0, .0);\n\t\trayDir.xy= rotate( rayDir.xy, CurTime - 0.9  );\n\t\t//rayDir.xz= rotate( rayDir.xz, CurTime );\n\t\t//rayDir.yz= rotate( rayDir.yz, 0.9 - CurTime );\n\t}\n\telse if( CurScene == 1.0 )\n\t{\n\t\tp= vec3( 0., 5.0, -2.0);\n\t\trayDir.xy= rotate( rayDir.xy, -0.4 );\n\t\trayDir.xz= rotate( rayDir.xz, CurTime );\n\t\tCurAnim= CurTime*CurTime;\n\t}\n\telse if( CurScene == 2.0 )\n\t{\n\t\tp= vec3( -CurTime * 200. + 140.0, -2., 5.0);\n\t\trayDir.xy= rotate( rayDir.xy, CurTime-0.8 );\n\t\trayDir.xz= rotate( rayDir.xz, 3.14 );\n\t}\n\telse if( CurScene == 3.0 )\n\t{\n\t\tp= vec3( -25. , 0., CurTime * 20.0 - 19.0);\n\t\trayDir.xy= rotate( rayDir.xy, -0.2 );\n\t}\n\telse if( CurScene == 4.0 )\n\t{\n\t\tp= vec3( 0., 40.0, CurTime *8.);\n\t\trayDir.xy= rotate( rayDir.xy, -CurTime );\n\t\tCurAnim= 0.0;\n\t}\n\telse if( CurScene == 5.0 )\n\t{\n\t\tp= vec3( 0., 40.0, CurTime * -64. + 56.);\n\t\trayDir.xy= rotate( rayDir.xy, -1.0 );\n\t\tCurAnim= 0.4*CurTime*CurTime;\n\t}\n\telse if( CurScene == 6.0 )\n\t{\n\t\tp= vec3( 0., 12.0, CurTime * -12.0);\n\t\trayDir.xy= rotate( rayDir.xy, CurTime - 1.5);\n\t\trayDir.xz= rotate( rayDir.xz, CurTime );\n\t}\n\telse if( CurScene == 7.0 )\n\t{\n\t\tp= vec3( -4., CurTime * 64. + 4.0,  0.);\n\t\trayDir.xy= rotate( rayDir.xy, -1.0 );\n\t\trayDir.xz= rotate( rayDir.xz, -CurTime );\n\t}\n\telse if( CurScene == 8.0 )\n\t{\n\t\tp= vec3( 8.0, 8.0, CurTime * 24. - 32.);\n\t\trayDir.xy= rotate( rayDir.xy, -0.3 );\n\t\trayDir.xz= rotate( rayDir.xz, CurTime );\n\t\tCurAnim= 0.0;\n\t}\n\telse if( CurScene == 9.0 )\n\t{\n\t\tp= vec3( CurTime * 14., 18.0, 0.);\n\t\trayDir.xy= rotate( rayDir.xy, -CurTime-0.5 );\n\t\tCurAnim= CurTime*CurTime;\n\t}\n\telse if( CurScene == 10.0 )\n\t{\n\t\tp= vec3( 2.0, CurTime * 4. + 2.0, CurTime * 12.+ 7.);\n\t\trayDir.xy= rotate( rayDir.xy, -0.2 );\n\t\trayDir.xz= rotate( rayDir.xz, -CurTime );\n\t}\n\telse if( CurScene == 11.0 )\n\t{\n\t\tp= vec3( CurTime * 70. - 80., CurTime * -4. + 6.0, CurTime * 64.- 56.);\n\t\trayDir.xy= rotate( rayDir.xy, -0.2 );\n\t\trayDir.xz= rotate( rayDir.xz, CurTime );\n\t\tCurAnim= 4.*CurTime;\n\t}\n\telse if( CurScene == 12.0 )\n\t{\n\t\tp= vec3( 30.,-8.,-8.);\n\t\trayDir.xy= rotate( rayDir.xy, 0.2 );\n\t\trayDir.xz= rotate( rayDir.xz, -CurTime + 3.0 );\n\t\tCurAnim= 0.4*CurTime*CurTime;\n\t}\n\telse if( CurScene == 13.0 )\n\t{\n\t\tp= vec3( -60.,12.,0.);\n\t\trayDir.xy= rotate( rayDir.xy, CurTime - 1.5 );\n\t}\n\telse if( CurScene == 14.0 )\n\t{\n\t\tp= vec3( -22.,0.,-8.);\n\t\t//rayDir.xy= rotate( rayDir.xy, 0.2 );\n\t\trayDir.xz= rotate( rayDir.xz, -CurTime + 2.0 );\n\t\t//CurAnim= 0.4*Y.y;\n\t}\n\telse if( CurScene == 15.0 )\n\t{\n\t\tp= vec3( 80. * CurTime,  7. ,-0.);\n\t\trayDir.xz= rotate( rayDir.xz, 3.*CurTime );\n\t}\n\telse if( CurScene == 16.0 )\n\t{\n\t\tp.x = 43.0;\n\t\trayDir.xz= rotate( rayDir.xz, pi2/2.);\n\t\tCurAnim= CurTime*CurTime;\n\t}\n\t\n\trayDir = normalize(rayDir);\n\n\tcRes= vec3( .0 );\n\tcFac=1.0;\n\t\n\tfloat t=0.0;\n\tm = 0;\n\tfor (int w=0; w < 2; w++)\n\t{\n\t\tif (m >= 2)\n\t\t\tbreak;\n\t\t\n\t\t//bis zu einer Oberflaeche steppen\n\t\t//for (CurStep=1.0;t<220.0 && CurStep>t*.003;t+=0.01+max(0.0, CurStep),RayStep=rayDir*t )\n\t\tCurStep = 1.0;\n\t\tfor (int i = 0; i < 64; ++i)\n\t\t{\n\t\t\tCurStep = f(p+RayStep);\n\t\t\t\t\n\t\t\tt+=CurStep;RayStep=rayDir*t;\n\t\t\tif (CurStep<=t*.003 || t>220.0)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvec3 NextPos = p+RayStep;\n\t\tVolLight = 0.0;\n\t\tif( p.y < LightHeight && NextPos.y > LightHeight)\n\t\t{\n\t\t\tfloat f = (p.y - LightHeight) / (p.y - NextPos.y);\n\t\t\tp += RayStep*f;\n\t\t\tVolLight = l(p.xz) * smoothstep( 220.0,0.0, f * t );\n\t\t}\n\t\t\n\t\t//Startpunkt und Richtung fuer reflektierten Strahl;\n\t\tp= NextPos;\n\t\t\n\t\tvec3 n = vec3(0.04, 0.0, 0.0);\n\t\tn= normalize(vec3( f(p + n.xyy) - f(p - n.xyy), f(p + n.yxy) - f(p - n.yxy), f(p + n.yyx) - f(p - n.yyx) ));\n\t\t\n\t\t//n= normalize(n);\n\t\t//CurStep ab hier == Reflektion !!!\n\t\tmat(p);\n\t\t\n\t\tfloat Ambient= 0.45 + 0.4 * dot( n,vec3(0,1.0,0) );\n\n\n\t\tToRes(vec3(0.7,1.0,0.9)*VolLight,1.0-VolLight);\n\t\tL= smoothstep( 0.,128., t );\n\t\tToRes(vec3( 0.0, 0.0, 0.05 )*L,1.0-L); // FogColor\n\t\t\n\t\tif( t > 220.0 )\n\t\t\tbreak;\n\t\t\n\t\trayDir= reflect( rayDir, n );\n\n\t\t//float ao(vec3 p, vec3 n, float d, float i) {\n\t\tfloat z = 1.0;\n\t\tfor (float y=6.0;y>0.;y--)\n\t\t{\n\t\t\tz-=(y*.5-f(p+n*y*.5))/exp2(y);\n\t\t}\n\t\tCurColor*= z*Ambient;\n\t\t\n\t\t//CurColor*= .4 + .3 * ( dot(normalize(LightPos-p),n) );\n    \n\t\tcRes+= cFac*CurColor;//*(1.0-Reflect);\n\t\tcFac*= CurStep;// Reflect * (1.0-t/tmax);\n\t\tt= 0.5;\n\t\tRayStep=rayDir*t;\n\t}\n\t\n\t\n\tfragColor.xyz = cRes;// + Y.w;// + cFac*FogColor;\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdB3Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 79, 109, 109, 172], [173, 173, 199, 199, 248], [250, 409, 438, 438, 480], [482, 560, 607, 607, 722], [725, 725, 764, 764, 797], [799, 799, 848, 848, 897], [899, 899, 948, 948, 1015], [1018, 1018, 1066, 1066, 1097], [1099, 1099, 1117, 1117, 1204], [1206, 1206, 1244, 1244, 1386], [1388, 1388, 1410, 1410, 1435], [1437, 1437, 1455, 1455, 2252], [2254, 2254, 2272, 2272, 3036], [3038, 3038, 3056, 3056, 3743], [3745, 3745, 3763, 3763, 4342], [4345, 4345, 4362, 4362, 4488], [4490, 4490, 4507, 4507, 5276], [5279, 5279, 5297, 5297, 5775], [5777, 5777, 5815, 5815, 5855], [5857, 5857, 5914, 5914, 10586]], "test": "error"}
{"id": "MdfSzn", "name": "Metatunnel", "author": "XT95", "description": "Fixed step marching.", "tags": ["raymarching", "metatunnel", "fixedstep"], "likes": 34, "viewed": 2954, "published": "Public API", "date": "1395717092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by anatole duprat - XT95/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// http://www.pouet.net/prod.php?which=52777\n\n#define time (iTime*.5)\n\nconst float s=0.4; //Density threshold\n \n\n\nfloat obj(vec3 p)\n{\n    float d = 1.0;\n    d *= distance(p, vec3(cos(time)+sin(time*0.2),0.3,2.0+cos(time*0.5)*0.5) );\n    d *= distance(p,vec3(-cos(time*0.7),0.3,2.0+sin(time*0.5)));\n    d *= distance(p,vec3(-sin(time*0.2)*0.5,sin(time),2.0));\n    d *=cos(p.y)*cos(p.x)-0.1-cos(p.z*7.+time*7.)*cos(p.x*3.)*cos(p.y*4.)*0.1;\n    return d;\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y*.5+.5;\n\t\n\tvec3 o = vec3(v.x,v.y,0.0);\n    vec3 d = normalize(vec3(v.x+cos(time)*.3,v.y,1.0))/64.0;\n\t\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    bool hit = false;\n\t\n    for(int i=0; i<100; i++)\n    {\n        if(!hit)\n        {\n\t\t\tif(obj(o+d*t) < s)\n\t\t\t{\n\t\t\t\tt-=5.0;\n\t\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\t\tif(obj(o+d*t) > s)\n\t\t\t\t\tt+=1.0;\n\t\t\t\t\t\n\t\t\t\tvec3 e=vec3(0.01,.0,.0);\n\t\t\t\tvec3 n=vec3(0.0);\n\t\t\t\tn.x=obj(o+d*t)-obj(vec3(o+d*t+e.xyy));\n\t\t\t\tn.y=obj(o+d*t)-obj(vec3(o+d*t+e.yxy));\n\t\t\t\tn.z=obj(o+d*t)-obj(vec3(o+d*t+e.yyx));\n\t\t\t\tn = normalize(n);\n\t\t\t\t\n\t\t\t\tcolor = vec3(1.) * max(dot(vec3(0.0,0.0,-0.5),n),0.0)+max(dot(vec3(0.0,-0.5,0.5),n),0.0)*0.5;\n\t\t\t\thit=true;\n\t\t\t}\n\t\t\t\n\t\t\tt+=5.0;\n\t\t}\n    }\n    fragColor= vec4(color,1.)+vec4(0.1,0.2,0.5,1.0)*(t*0.025);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfSzn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[220, 244, 263, 263, 583], [588, 588, 645, 645, 1499]], "test": "ok"}
{"id": "Mdj3Dc", "name": "Distance Field Buzz", "author": "hat", "description": "Distance field for the Buzz Lightyear character of PixarÂ´s Toy Story, thereÂ´s also a simple shaded version www.shadertoy.com/view/Xs2GRc (sadly it only works in Mac)", "tags": ["raymarching", "distancefield", "displacement"], "likes": 8, "viewed": 937, "published": "Public", "date": "1394735884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\tconst int max_iterations = 45;\n\tconst float stop_threshold = 1.;\n\tconst float grad_step = 0.1;\n\tconst float clip_far = 6500.;\n\tconst float PI = 3.14159265359;\n\tconst float uSpeed = 50.0;\n\n\n\tmat3 rotX(float g) {\n\t\tg = radians(g);\n\t\tvec2 a = vec2(cos(g), sin(g));\n\t\treturn mat3(1.0, 0.0, 0.0,\n\t\t\t\t\t0.0, a.x, -a.y,\n\t\t\t\t\t0.0, a.y, a.x);\n\t}\n\t\n\tmat3 rotY(float g) {\n\t\tg = radians(g);\n\t\tvec2 a = vec2(cos(g), sin(g));\n\t\treturn mat3(a.x, 0.0, a.y,\n\t\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\t\t-a.y, 0.0, a.x);\n\t}\n\n\tmat3 rotZ(float g) {\n\t\tg = radians(g);\n\t\tvec2 a = vec2(cos(g), sin(g));\n\t\treturn mat3(a.x, -a.y, 0.0,\n\t\t\t\t\ta.y, a.x, 0.0,\n\t\t\t\t\t0.0, 0.0, 1.0);\n\t}\n\n\tfloat rCyl(in vec3 p, in float h, in float r1, in float r2) {\n\t    float a = abs(p.x)-(h-r2);\n\t    float b = length(p.yz)-r1;\n\t    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);\n\t}\n\n\tfloat rCylH(in vec3 p, in float h, in float r1, in float r2) {\n\t    float a = abs(p.y)-(h-r2);\n\t    float b = length(p.xz)-r1;\n\t    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);\n\t}\n\n\tfloat dd(float u, vec3 v) {\n\t\tv.x *= 0.5;\n\t\tfloat s = (u + v.x) * step(-u, v.x) * step(u, v.y - v.x) / v.y;\n\t\ts += step(-u, v.x - v.y) * step(u, v.x - v.z);\n\t\ts += (v.x - u) * step(-u, v.z - v.x) * step(u, v.x) / v.z;\t\t\n\t\ts = s * s * (3. - 2. * s);\n\t\t\n\t\treturn s;\n\t}\n\n\tfloat bt(vec3 u) {\n\t\tu *= rotZ(-5.0);\n\t\tu.y *= 0.4;\n\t\tfloat c = length(u.xy);\n\t\tfloat f = 3.;\n\t\tfloat k = 1. / pow(10., 4.5);\n\t\treturn step(c, 30.) * clamp(exp( -k * pow(c, f)), 0., 1.);\n\t}\n\n\tfloat head(vec3 p) {\n\t\t\t\n\t\tvec3 u = p;\n\t\tvec4 c1 = vec4(270., 50., 65., 190.);\n\t\tvec2 c2 = vec2(150., 0.);\n\t\t\n\t\tu.y *= 0.00225 * u.y;\n\t\tu.x *= 1.15 + (sin((u.y) * 0.0030667) * step(p.y, 0.0) - (c2.x - p.y) * 0.00046);\n\t\tu.z += (0.05 + step(p.z, 0.0) * clamp(p.z * 0.1, -0.18, 0.0)) * p.y;\n\t\t\t\t\n\t\tfloat s = length(u) - 200.0;\n\t\t\n\t\tu.z = p.z -40.0 + 5.0 * cos(p.y * 0.011 + 1.1) + 190.0 * cos(p.x * 0.008) - 25.0 * cos(p.y * 0.02 + 1.1) + 0.05 * p.y;\n\t\ts -= 4.0 * clamp(u.z, 0.0, 1.);\n\t\t\n\t\tu = vec3(abs(p.x) - 170., p.y - 130., p.z - 60.);\n\t\tc2.x = length(u);\n\t\ts -= 4.0 * sqrt(60.0 - clamp(c2.x, 0.0, 60.0)) * step(c2.x, 60.0);\n\t\t\n\t\tc2.x = (p.y + c1.z) * step(p.y, c1.y - c1.z) / c1.y + step(-p.y, -c1.y + c1.z) * (1.0 - (p.y - c1.y + c1.z) / (c1.x - c1.y));\n\t\tc2.x *= c2.x;\n\t\tc2.y = clamp(c1.w - 2.0 * abs(p.x), 0.0, c1.w) / c1.w;\n\t\tc2.y = c2.y * c2.y * c2.y * (3.0 - 2.0 * c2.y);\n\n\t\ts -= c2.x * 0.28 * clamp((c1.w - 2.0 * abs(p.x)) * c2.y, 0.0, c1.w) * step(-p.y, c1.z) * step(p.y, c1.x - c1.z) * step(p.z, 0.0);\n\t\t\n\t\tu = vec3(abs(p.x) - 60., p.y - 110., p.z + 130.);\n\t\tc2.xy = vec2(68., length(u));\n\t\tc2.x = 4.0 * pow((c2.x - clamp(c2.y, 0.0, c2.x)), 0.5) * step(c2.y, c2.x);\n\t\ts -= c2.x;\n\t\t\n\t\tu.x -= 20.0;\n\t\tu.x *= 0.9;\n\t\tu.y -= 10.0 + 8.0 * cos(u.x * 0.07 - 0.4);\n\t\t\n\t\tc1.xy = vec2(10., 34.);\n\t\tc1.z = c1.x + 75.0 * cos(u.x * 0.016);\n\t\tc1.w = step(-u.y, -c1.x) * step(u.y, c1.z) * step(abs(u.x), 80.0) * step(p.z, 0.0);\n\t\t\n\t\tc2.x = u.y * step(u.y, c1.y) + c1.y * step(-u.y, -c1.y) - (u.y - c1.z + c1.y ) * step(-u.y, -c1.z + c1.y);\n\t\tc2.x /= c1.y;\n\t\tc2.x *= c2.x * c2.x * c2.x *( 3.0 - 2.0 * c2.x);\n\t\tc2.y = (110.0 - (abs(p.x) - 20.0))/ 80.0;\n\t\tc2.y = c2.y * c2.y * ( 3.0 - 2.0 * c2.y);\n\t\ts -= 30.0 * c2.x * c1.w * c2.y;\n\t\t\n\t\tu = vec3(abs(p.x) -90., p.y + 83., p.z + 200.);;\n\t\tc1.x = length(u);\n\t\tc1.z = (c1.x - 180.) / 180.;\n\t\tc1.z *= c1.z * c1.z * c1.z * (3.0 - 2.0 * c1.z * c1.z);\n\t\ts += 12.0 * c1.z * step(c1.x, 180.);\n\t\t\n\t\tu = vec3(abs(p.x) - 110., p.y, p.z + 120.);;\n\t\tc1.x = length(u);\n\t\tc1.z = (c1.x - 130.) / 130.;\n\t\tc1.z *= c1.z * c1.z * c1.z * (3.0 - 2.0 * c1.z * c1.z);\n\t\ts -= 10.0 * c1.z * step(c1.x, 130.);\t\t\n\t\t\n\t\treturn 0.5 * s;\n\t}\n\n\tfloat helmet(vec3 p) {\n\t\n\t\tvec3 u = p;\n\t\tfloat c = 0.;\n\t\tfloat d = 0.;\n\t\t\n\t\tu.y += 80.0;\n\t\tc = length(u);\n\t\tfloat s = max(max(max(c - 500.0, -c + 490.0), -u.y), - u.z);\n\t\t\n        float uAngle = iTime * uSpeed;\n\n\t\tc = mod(0.1 * uAngle, 140.0);\n\t\tif(c > 70.0) c = 140.0 - c; \n\t\tu *= rotX(c);\n\t\tc = length(u);\n\t\ts = min(s, max(max(max(c - 490.0, - c + 480.0), -u.y), -u.z -0.7* u.y));\n\t\t\n\t\tu = p;\n\t\tu.y += 110.;\n\t\tc = length(u.xz);\n\t\td = max(max(max(c - 510., abs(u.y) - 30.0), -max(c - 480., abs(u.y) - 40.0)), -p.z);\n\t\t\n\t\tu *= rotX(18.);\n\t\tc = length(u.xz);\n\t\tc = max(max(max(c - 510., abs(u.y) - 30.0), -max(c - 480., abs(u.y) - 40.0)), p.z);\n\t\t\n\t\tu = vec3(abs(p.x) - 490., p.y + 120., p.z);\t\t\n\t\ts = min(s,min(min(min(d, rCyl(u, 30.0, 95.0, 15.0)), rCyl(u, 60.0, 55.0, 20.0)), c));\n\t\t\n\t\treturn s;\n\t}\n\n\tfloat body(vec3 p) {\n\t\t\n\t\tvec3 u = vec3(abs(p.x), p.y + 445., abs(p.z));\n\t\tvec3 v = p;\n\t\tfloat c = u.y - 275.;\n\t\tc = 1. + 0.000001 * c * c;\n\t\tu.xz *= vec2(c);\n\t\tc = length(u.xz);\n\t\tfloat s = max(max(c - 500.0, abs(u.y) - 300.0), -max(c - 490.0, abs(u.y - 250.) - 150.0));\t\t\n\t\t\n\t\tu = p;\n\t\tv.x = u.x = abs(p.x);\n\t\t\t\t\n\t\tv.y += 0.3 * v.x;\n\t\tc = dd(v.y, vec3(1150., vec2(30.)));\n\t\t\n\t\tv.y = -p.y  + 0.3 * (u.x - 250.0);\n\t\tc *= dd(v.y, vec3(1150., vec2(30.)));\n\t\t\n\t\tv.y = -p.y + 1.6 * (u.x - 380.0);\n\t\tc *= dd(v.y, vec3(1150., vec2(30.)));\n\t\t\t\t\n\t\ts -= 26.0 * c;\n\t\t\n\t\tv.y = 280.0 + p.y + 0.9 * v.x;\n\t\tc = dd(v.y, vec3(150., vec2(20.))) * (1. - c);\n\t\ts -= 23. * c;\n\t\t\n\t\tv.y = p.y - 0.3 * v.x;\n\t\tc = dd(v.y, vec3(920., vec2(30.)));\n\t\t\n\t\tv.y = p.y -5. * (u.x - 110.0);\n\t\tc *= dd(v.y, vec3(750., vec2(30.))) * step(p.z, 0.);\n\n\t\ts += 26.0 * c;\n\t\ts = max(max(s, p.y - 0.3 * p.z + 150.0), p.y + 140.0);\n\n\t\tvec4 c1 = vec4(vec3(bt(vec3(p.x + 170., p.y + 430., p.z)), bt(vec3(p.x + 250., p.y + 420., p.z)), bt(vec3(p.x + 330., p.y + 410., p.z))), 0.);\n\t\t\n\t\tu = vec3(p.x - 230., p.y + 430., p.z);\n\t\tfloat f = 10.;\n\t\tfloat k = 1. / pow(10., 18.);\n\t\tc = length(u.xy);\n\t\tc1.w = step(c, 60.) * clamp(exp( -k * pow(c, f)), 0., 1.);\n\t\t\n\t\ts -= 20.0 * (c1.x + c1.y + c1.z + 1.3 * c1.w) * step(p.z, 0.);;\n\t\t\n\t\tu = p;\n\t\tu.y += 500.;\n\t\ts += 15. * dd(u.x, vec3(35., vec2(15.))) * dd(u.y, vec3(150., vec2(15.))) * step(p.z, 0.);\n\t\t\n\t\tu = p;\n\t\tu += vec3(10.0 * cos(u.y * 0.1), 800., 10.0 * cos(u.y * 0.1 - 0.5 * PI));\n\t\tu.x *= 0.9;\n\t\t\n\t\ts = min(s, max(length(u.xz) - 325., abs(u.y) - 130.));\n\t\t\n\t\treturn s *= 0.5;\n\t}\n\n\tfloat arms(vec3 p) {\n\t\t\n\t\tvec3 c = vec3(0.);\n\t\tvec3 u = vec3(abs(p.x) - 500., p.y + 370., p.z);\n\t\tu *= rotZ(15.);\n\t\tfloat s = rCyl(u, 20.0, 200.0, 15.0);\n\t\tu.x -= 30.;\n\t\ts = min(s, rCyl(u, 20.0, 190.0, 15.0));\n\t\tu *= rotX(90.);\n\t\ts = min(s, length(u) - 160. + 7.* dd(u.x, vec3(1270.0, vec2(80.0))) * dd(u.y, vec3(27.0, vec2(8.0))));\n\t\t\n\t\tu = vec3(-abs(p.x) + 760., abs(p.y + 380.), p.z);\t\t\n\t\tu.y -= 0.04 * u.x;\n\t \tc.x = u.y * u.y * 0.005;\n\t\tu.x -= c.x * step(u.x, 50.);\n\t\tc.x = rCyl(u, 130., 135., 10.);\n\t\t\n\t\tfloat f = 10.;\n\t\tfloat k = 1. / pow(10.,17.5);\n\t\t\n\t\tu = vec3(-abs(p.x) + 660., p.y + 380., p.z);\t\n\t\tu.x += 0.1 * (110. - abs(u.y));\n\t\tu.xy *= vec2(0.5, 0.45);\n\t\tc.z = length(u.xy);\n\t\tc.y = step(c.z, 110.) * step(p.z, 0.) * clamp(exp( -k * pow(c.z, f)), 0., 1.);\n\t\t\n\t\tc.x -= 20. * c.y;\n\t\ts = min(s, c.x);\n\t\t\n\t\tu = vec3(-abs(p.x) + 890., p.y + 380., p.z);\t\n\t\tc.x = length(u) - 130.;\n\t\tu *= rotX(90.);\n\t\tc.x += 10.* dd(u.x, vec3(1270.0, vec2(80.0))) * dd(u.y, vec3(27.0, vec2(8.0)));\n\t\ts = min(s, c.x);\n\t\t\n\t\tu = vec3(-abs(p.x) + 1140., p.y + 430., p.z);\t\n\t\tc.x = u.x - 200.;\n\t\tc.x = 1.0 +  0.000005 * c.x * c.x;\n\t\tu.yz *= vec2(c.x);\n\t\tu.y -= 50.;\n\t\t\n\t\tc.y = rCyl(u, 170., 110., 15.);\t\t\n\t\tu.x -= 0.5 * u.y + 190.;\n\t\tc.y -= 10. * dd(u.x, vec3(400., vec2(20.)));\n\t\t\n\t\ts = min(s, c.y);\n\t\t\n\t\treturn s *= 0.7;\n\t}\n\n\tfloat hips(vec3 p) {\n\t\t\n\t\tvec3 u = p;\n\t\tvec4 c = vec4(160., 70., 0., 0.);\n\n\t\tu.y += 1170.;\n\t\tc.z = (u.y - c.x) * step(u.y, c.x);\n\t\tu.y -= c.y;\n\t\tc.z *= c.z;\n\t\tu.x *= 1.0 - 0.0011 * u.y * step(u.y, c.x);\n\t\tu.xz *= vec2(1.) + c.z * vec2(0.00002, 0.00001);\n\n\t\tfloat s = rCylH(u, c.x, 290., 20.);\n\t\ts = max(s, p.y + 970.);\n\t\t\n\t\tu = vec3(abs(p.x), p.yz);\n\t\tu.y += 0.2 * u.x + 910.;\n\t\tc.x = dd(u.y, vec3(230., vec2(10.)));\n\t\t\n\t\tu.y = p.y + 920. - 0.2 * (u.x - 250.0);\n\t\tc.x *= dd(u.y, vec3(230., vec2(10.)));\n\t\t\t\t\n\t\ts -= 20.0 * c.x;\n\t\t\n\t\tu = vec3(0.5 * p.x, p.y + 950., p.z);\n\t\tc.xy = vec2(10., 1. / pow(10., 17.));\n\t\tc.w = length(u.xy);\n\t\tc.x = step(c.w, 100.) * step(p.z, 0.) * clamp(exp( -c.y * pow(c.w, c.x)), 0., 1.);\n\t\t\n\t\ts -= 20. * c.x;\n\t\treturn s *= 0.5;\t\n\t}\n\n\tfloat legs(vec3 p) {\n\t\t\n\t\tvec3 u = vec3 (-abs(p.x) + 190., p.y + 1440., p.z);\n\t\tvec4 c = vec4(u.z * u.z * 0.004, 0., 0., 0.);\n\t\t\n\t\tu.xz *= vec2(1.0 - 0.0003 * u.y, 0.8);\n\t\tu.y -= c.x * step(u.y, 50.);\n\n\t\tfloat s = rCylH(u, 240., 140., 5.);\n\t\t\n\t\tu.y -= 240.;\n\t\ts = min(s, length(u) - 140.);\n\t\t\n\t\tu = vec3 (-abs(p.x) + 190., p.y + 1660., p.z - 30.);\n\t\tc.x = length(u);\n\t\ts = min(s, c.x - 125.);\n\t\t\n\t\tu = vec3 (-abs(p.x) + 190., p.y + 2020., p.z);\n\t\t\n\t\tc.x = u.z + 200.;\n\t\tc.x *= c.x * 0.0015;\n\t\tc.y = u.z * .5;\n\t\tu.z *= 0.9;\n\t\tu.y += c.y - c.x * step(u.y, 260.);\n\t\tu.xz *= vec2(1.0) + u.y * vec2(0.0004, 0.001);\n\t\tc.x = rCylH(u, 280., 150., 10.) - 15. * step(u.y, -190.);;\n\t\t\n\t\tc.zw = vec2(5., 1. / pow(10., 10.7));\n\t\tu.y -= 200.;\n\t\tu.y *= 0.8;\t\n\t\tc.y = length(u.xy);\n\t\tc.x -= 55. *  step(c.y, 200.) * step(p.z, 0.) * clamp(exp( - c.w * pow(c.y, c.z)), 0., 1.);;\n\t\t\n\t\ts = min(s, c.x);\n\t\n\t\tu = vec3 (abs(p.x) - 190., p.y + 2200., p.z);\n\t\ts = min(s, length(u) - 140.);\n\t\t\n\t\tu = vec3 (-abs(p.x) + 190., p.y, p.z);\n\t\ts += 10. * dd(u.x, vec3(25., vec2(12.)));\n\t\t\n\n\t\tu = vec3 (abs(p.x) - 350., p.y + 2200., p.z);\n\t\tc.x = rCyl(u, 30.0, 85.0, 20.0);\n\t\tu.x += 315.;\n\t\tc.x = min(c.x, rCyl(u, 30.0, 85.0, 20.0));\n\t\t\n\t\tc.yz = vec2(10., 1. / pow(10., 17.5));\n\t\tc.w = length(u.yz);\n\t\tc.x += 10.* step(c.w, 80.) * clamp(exp( -c.z *pow(c.w, c.y)), 0., 1.);\n\t\t\n\t\ts = min(s, c.x);\t\t\n\t\treturn s *= 0.7;\n\t}\n\t\n\tfloat shoes(vec3 p) {\n\t\t\n\t\tvec3 u = vec3(abs(p.x) - 190., p.y + 2500., p.z + 90.);\n\t\tvec3 v = u;\n\t\tfloat c = 0.;\n\t\t\n\t\tu.z *= 0.5;\n\t\tu.y *= 0.002 * u.y;\n\t\tu.xy *= vec2(0.85 - u.z * u.z * 0.00001, 1.2);\n\t\tfloat s = max(length(u) - 150., -v.y + 60.);\n\t\t\n\t\tv.y -= 40.;\n\t\tc = dd(v.y, vec3(100., vec2(7.)));\n\t\ts -= 15. * c;\n\t\t\n\t\tc = dd(v.x, vec3(700, vec2(50.))) * step(-v.y, -59.) * step(v.z + v.y, -140.);\n\t\ts -= 15. * c;\n\t\t\n\t\tc = dd(v.x, vec3(180, vec2(20.))) * step(-v.y, -59.) * step(-v.z, 30.);\n\t\ts -= 12. * c;\n\t\t\n\t\treturn s;\n\t}\n\n\tfloat hands(vec3 p) {\n\t\t\n\t\tp.x = abs(p.x);\n\t\tp.xy += vec2(-1450., 400.);\n\t\tp *= 1.2;\n\t\tp *= rotX(-50.);\n\t\t\n\t\tvec3 u = p;\n\t\tvec2 c = vec2(1. / (1. +  pow(u.x / 30. + 0.5, 6.)), 0.);\n\t\t\n\t\tu.z = abs(p.z);\n\t\tu.yz *= vec2(1.0 + 0.6 * (1. / (1. +  pow((u.x / 35. + 2.5), 6.))));\n\t\t\n\t\tu.z += 1.9 * u.x;\n\t\tu.z *= 1.0 - 0.305 * c.x * step(p.z, 0.);\n\t\tu.z -= 1.9 * u.x;\n\t\t\n\t\tc.x = clamp((u.x + 123.) / 200., 0., 1.);\n\t\tu.y *= 1.0 + 2.2 * pow(c.x, 0.8);\n\t\tu.x *= 0.00002 * u.x * u.x;\n\t\t\n\t\tfloat s = length(u) - 100.;\n\t\t\n\t\tc.x = dd(u.y, vec3(225., vec2(100.))) * dd(u.z, vec3(140., vec2(20.)));\n\t\tc.x *= step(-p.x, -110.);\n\t\ts += 300. * c.x;\n\t\t\n\t\tc.x = dd(u.x - 12., vec3(18., vec2(7.)));\n\t\ts -= 10. * c.x;\n\t\t\n\t\tc.x = p.x - 10.;\n\t\tu.z = abs(p.z);\n\t\tu.z += 0.005 * c.x * c.x;\n\t\tc.x = dd(u.x, vec3(2.1, vec2(1.))) * dd(u.z + 10., vec3(175., vec2(30.)));\n\t\ts -= 15. * c.x * step(-u.y, 0.);\n\t\t\n\t\tu = vec3(p) + vec3(-140., 50., -100.);\n\t\tc.x = 55.;\n\t\tu.y -= 50. * cos(0.008 * u.x);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tu.xz += vec2(-17., 40.);\n\t\t\tc.x += 17.;\n\t\t\tif(i == 3) {\n\t\t\t\tc.x -= 30.;\n\t\t\t\tu.x += 30.;\n\t\t\t}\n\t\t\tc.y = rCyl(u, c.x, 20., 20.);\n\t\t\ts = min(s, c.y);\n\t\t}\n\t\t\n\t\tu = vec3(p) + vec3(-60., 0., 135. + 26. * cos(.024 * p.x + 0.8));\n\t\tu *= rotY(-33.);\n\t\tc.x = rCyl(u, 75., 20., 20.);\n\t\t\n\t\ts = min(s, c.x);\n\t\t\n\t\treturn s *= 0.7;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \n\t}\n\n\n\tvec3 map(vec3 p) {\t\n\t\n\t\tp.y -= 900.;\n        float uAngle = iTime * uSpeed;\n\n\t\tp *= rotY(uAngle);\n\t\t\n\t\tvec3 s = vec3(100000.0);\n\t\ts.x = min(min(min(min(min(min(min(min(s.x, head(p)), helmet(p)), body(p)), arms(p)), hands(p)), hips(p)), legs(p)), shoes(p));\n\t\treturn s;\t\n\t}\n\n\n\tvec3 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\t\n\t\tfloat depth = start;\n\t\tvec3 salida = vec3(end);\n\t\tvec3 dist = vec3(2800.0);\n\t\t\n\t\tfor ( int i = 0; i < max_iterations; i++ ) \t\t{\n\t\t\tif ( dist.x < stop_threshold || depth > end ) break;\n                dist = map( origin + dir * depth );\n                depth += dist.x;\n\t\t\t\tdist.y = float(i);\n\t\t}\n\t\t\n\t\tsalida = vec3(depth, dist.y, dist.z);\n\t\treturn salida;\n\t}\n\n\n\tvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\t\tvec2 xy = pos - size * 0.5;\n\n\t\tfloat cot_half_fov = tan(radians( 90.0 - fov * 0.5 ));\t\n\t\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\t\treturn normalize( vec3( xy, z ) );\n\t}\n\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\t\t\t\n\t\tvec3 rd = ray_dir(60.0, iResolution.xy, fragCoord.xy );\n\t\tvec3 eye = vec3( 0.0, 000.0, -4000.0 );\n\t\tvec4 color = vec4(0.);\n\t\t\n\t\t\n\t\tvec3 data = ray_marching( eye, rd, 2400.0, clip_far );\n\t\tif ( data.x < clip_far ) {\n\t\t\tcolor.rgb = vec3(1.5) * data.y / float(max_iterations);\n\t\t};\n\t\t\n\n\t\t\t\n\t\tfragColor = color;\n\t} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdj3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 212, 212, 337], [341, 341, 361, 361, 486], [489, 489, 509, 509, 634], [637, 637, 698, 698, 840], [843, 843, 905, 905, 1047], [1050, 1050, 1077, 1077, 1316], [1319, 1319, 1337, 1337, 1508], [1511, 1511, 1531, 1531, 3661], [3664, 3664, 3686, 3686, 4464], [4467, 4467, 4487, 4487, 6050], [6053, 6053, 6073, 6073, 7365], [7368, 7368, 7388, 7388, 8128], [8131, 8131, 8151, 8151, 9515], [9519, 9519, 9540, 9540, 10047], [10050, 10050, 10071, 10071, 11393], [11397, 11397, 11415, 11415, 11669], [11673, 11673, 11741, 11741, 12105], [12109, 12109, 12157, 12157, 12329], [12333, 12333, 12391, 12391, 12707]], "test": "ok"}
{"id": "Mdj3W3", "name": "Secant Step", "author": "huwb", "description": "Detect if we cross the surface and if so borrow a step from the Secant Method to linearly approximate the intersection. Alternating on and off over time. Analysed in FPI talk here: http://www.huwbowles.com/fpi-gdc-2016/", "tags": ["raymarch", "fpi", "convergence", "iteration"], "likes": 14, "viewed": 567, "published": "Public", "date": "1394657513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Overview:\n\n// Analysed in my FPI talk: http://www.huwbowles.com/fpi-gdc-2016/ (see slide notes)\n// Pixel intensity shows iteration count\n// Time switches between normal sphere march and the improved sphere march in this shader\n// Click-drag to explore different rays\n// Lower half of screen visualises the distance estimates along the ray (x-axis)\n// The new code is in the raymarchFPI() function\n\n// Description:\n\n// This is normal fixed point iteration but switches to the secant method whenever a\n// surface crossing is detected. This has super linear convergence properties, and\n// is guaranteed to converge safely since I'm only applying it at crossings (as opposed\n// to the normal secant method which may extrapolate instead of strictly interpolating).\n\n// The nice thing is that the raymarch loop rearranges nicely to avoid doing any\n// additional DE computations (except if the step crosses the surface, in which\n// case the step is reduced and the DE is evaulated at the new step location).\n\n// A halfway approach would be to do this correction just once - when the sphere\n// march crosses the surface for the first time, a correction is done using\n// the estimated surface position, and then the raymarch terminates. This might be\n// an easy and cheap addition to existing sphere march shaders. Future work..\n\n// There are still situations where the iteration will completely overstep surface\n// features, hence the missing parts of the bumps in the render. This can be addressed\n// by reducing step size at the expense of efficiency.\n\n\n#define ITERCNT 60\n\n// turn on and off new approach over time\n#define NEW_LIMIT_STEP (fract(iTime/4.)>.5)\n\n\n// the wavy surface\nfloat surfHeight( vec2 xz )\n{\n\tfloat result = 3.* (cos(xz.x) + cos(xz.y));\n\tresult *= 1.-exp(-length(xz)/10.);\n\treturn result;\n}\n\n// evaluate the ray\nvec3 rayPt( vec3 ro, vec3 rd, float t )\n{\n\treturn ro + rd * t;\n}\n\n// the distance estimate - a poor mans distance field. return the\n// height difference from the surface.\nfloat distField( vec3 pt )\n{\n\tfloat dSurf = pt.y - surfHeight(pt.xz);\n\treturn dSurf;\n}\n\n// raymarch\nfloat raymarchFPI( vec3 ro, vec3 rd, out float cnt )\n{\n\t// initial guess for t - just pick the start of the ray\n\tfloat t = 0.;\n\t\n\tfloat d = distField( rayPt(ro,rd,t) );\n\tfloat dNext;\n\t\n\tcnt = 0.;\n\tfor( int i = 0; i < ITERCNT; i++ )\n\t{\n\t\t// termination condition - iteration has converged to surface\n\t\tif( abs(d) < 0.001 )\n\t\t\tcontinue;\n\t\t\n\t\tdNext = distField( rayPt(ro,rd,t+d) );\n\t\t\n\t\t// NEW ALGORITHM\n\t\t// are we crossing the surface? (sign(d) != sign(dNext)).\n\t\t// im detecting this by dividing the two and checking\n\t\t// if the result is negative. the only reason i use a divide is because\n\t\t// ill reuse the division result later. i thought it would be unstable but\n\t\t// it seems to work fine!\n\t\tfloat dNext_over_d = dNext/d;\n\t\tif( NEW_LIMIT_STEP && dNext_over_d < 0.0 )\n\t\t{\n\t\t\t// fit a line from (current t, current d) to (next t, next d),\n\t\t\t// and set t to the approximated intersection of the line with d=0\n\t\t\t\n\t\t\t// the human readable version\n\t\t\t// float grad = (dNext - d) / d;\n\t\t\t// d /= -grad;\n\t\t\t// steeper gradient means smaller step. this is analytically\n\t\t\t// correct (to a linear approximation of the surface)\n\n\t\t\t// optimised (confuscated) version\n\t\t\td /= 1.0 - dNext_over_d;\n\t\t\t\n\t\t\t// re-evaluate at the partial step location\n\t\t\tdNext = distField( rayPt(ro,rd,t+d) );\n\t\t\t\n\t\t\t// OPTION - terminate march after doing one correction step..\n\t\t}\n\t\t// END OF NEW ALGORITHM\n\t\t\n\t\tt += d;\n\t\td = dNext;\n\t\t\n\t\tcnt += 1.;\n\t}\n\t\n\treturn t;\n}\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.1);\n\t\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0*q;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tpp.x *= aspect;\n    \n\tif( pp.y > 0. )\n\t{\n\t\t// top half of screen. draw the 3d scene with a cross indicating\n\t\t// a particular ray\n\n\t\tpp.y = 2. * (pp.y-.5);\n\t\t\n\t\t// cross\n\t\tif( \n\t\t\t(abs(pp.x) < 0.0125/aspect && abs(pp.y) < 0.1) ||\n\t\t\t(abs(pp.y) < 0.0125 && abs(pp.x) < 0.1/aspect) )\n\t\t{\n\t\t\tfragColor.rgb = vec3(0.,1.,0.);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tpp.x *= 2.;\n\t\t\n\t\t// ray march and shade based on iteration count\n\t\tvec3 ro;\n\t\tvec3 rd = computePixelRay( pp, ro );\n\t\t\n\t\tfloat cnt;\n\t\tfloat t = raymarchFPI(ro,rd, cnt);\n\t\tfloat iters = clamp(cnt/float(ITERCNT),0.,1.);\n\t\t\n\t\tfragColor.xyz = vec3( iters );\n\t}\n\telse\n\t{\n\t\t// bottom half of screen. here we will draw the graph. this is done by finding\n\t\t// out which pixel we are on, computing a graph coordinate from that, and then\n\t\t// checking if we are close to the curve.\n\t\t\n\t\t// axis\n\t\tif( abs(fragCoord.y - iResolution.y/4.) < 1.)\n\t\t{\n\t\t\tfragColor.rgb = vec3(0.4);\n\t\t}\n\t\t\n\t\t// compute ray for the middle of the screen. this is where the cross\n\t\t// is located, and this is the ray that is graphed\n\t\tvec3 ro;\n\t\tvec3 rd = computePixelRay( vec2(0.), ro );\n\t\t\n\t\t// compute the t (x-axis) value for this pixel\n\t\tfloat tmax = 50.0;\n\t\tfloat thist = tmax * fragCoord.x / iResolution.x;\n\t\t\n\t\t// evaluate the distance field for this value of t\n\t\tvec3 thisPt = rayPt( ro, rd, thist );\n\t\tfloat dist = distField( thisPt );\n\t\t\n\t\t// compute the dist (y-axis) value for this pixel\n\t\t// compute max y axis value from x axis range\n\t\tfloat maxDist = tmax * (iResolution.y*0.5/iResolution.x);\n\t\tfloat thisDist = maxDist * (pp.y+.5);\n\t\t\n\t\t// we'll also want the gradient, which tells us whether the\n\t\t// iteration will converge. compute it using forward differences\n\t\t// along the ray\n\t\tfloat eps = tmax/iResolution.x;\n\t\tvec3 nextPt = rayPt( ro, rd, thist + eps );\n\t\tfloat nextDist = distField(nextPt );\n\t\tfloat distGradient = (nextDist - dist) / eps;\n\t\t\n\t\t\n\t\t// when using FPI, the iterated function is t = distField + t\n\t\t// therefore the gradient of the iteration is d/dt(distField) + 1\n\t\tfloat fpiGrad = distGradient + 1.;\n\t\t\n\t\t// for fpi to converge, the gradient has to be in (-1,1). the next\n\t\t// few lines compute a color, blending to red over the last 20% of\n\t\t// this range\n\t\tfpiGrad = abs(fpiGrad);\n\t\tfpiGrad = smoothstep( .8, 1., fpiGrad );\n\t\tfloat g = 1.5 + -2.*fpiGrad;\n\t\tfloat r =  2.*fpiGrad;\n\t\tvec3 lineColor = clamp(vec3(r,g,0.),.0,1.);\n\t\tlineColor.g *= .85;\n\t\t\n\t\t// iq's awesome distance to implicit http://www.iquilezles.org/www/articles/distance/distance.htm\n\t\tfloat alpha = abs(thisDist - dist)*iResolution.y/sqrt(1.+distGradient*distGradient);\n\t\t// antialias\n\t\talpha = smoothstep( 80., 30., alpha );\n\t\tfragColor.rgb = (1.-alpha) * fragColor.rgb + lineColor * alpha;\n\t\t\n\t\t\n\t\t// additional visualisation - for sphere tracing, visualise each sphere\n\t\t// need each t value, then plot circle at each t with the radius equal to the distance\n\t\t\n\t\tfloat stepTotalAlpha = 0.;\n\t\t\n\t\tfloat stept = 0.;\n\t\t\n\t\t\tvec3 stepPt = rayPt( ro, rd, stept );\n\t\t\t\n\t\t\tfloat d = distField( stepPt );\n\t\t\n\t\tfloat dNext;\n\t\tfloat tNext;\n\t\t\n\t\tfloat last_t = 10000.; // something far away from t0\n\t\tfor( int i = 0; i < ITERCNT; i++ )\n\t\t{\n\t\t\t// termination condition - iteration has converged to surface\n\t\t\tif( abs(last_t - stept) < 0.001 )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tlast_t = stept;\n\t\t\t\n\t\t\ttNext = stept + d;\n\t\t\tdNext = distField( rayPt(ro,rd,tNext) );\n\t\t\t\n\t\t\tfloat dNext_over_d = dNext / d;\n\t\t\tif( NEW_LIMIT_STEP && dNext_over_d < 0.0 )\n\t\t\t{\n\t\t\t\td /= 1.0 - dNext_over_d;\n\t\t\t\ttNext = stept + d;\n\t\t\t\tdNext = distField( rayPt(ro,rd,tNext) );\n\t\t\t}\n\t\t\t\n\t\t\tfloat stepx = -aspect + 2.*aspect * stept / tmax ;\n\t\t\tfloat stepDist = abs( d );\n\t\t\tfloat R = length( vec2(stepx,-.5) - pp );\n\t\t\t\n\t\t\tfloat circleR = stepDist / ( maxDist);\n\t\t\t// circle boundary\n\t\t\tfloat stepAlpha = 0.2*smoothstep( 5.0/iResolution.x, 0.0, abs(circleR - R) );\n\t\t\t// add a dot at the center\n\t\t\tstepAlpha += 0.3*smoothstep(5.0/iResolution.x,0.0,R);\n\t\t\t\t\n\t\t\tstepTotalAlpha += stepAlpha;\n\t\t\t\n\t\t\tstept = tNext;\n\t\t\td = dNext;\n\t\t}\n\t\tfragColor.rgb += (1.-alpha) * clamp(stepTotalAlpha,0.,1.)*vec3(1.0,1.0,0.);\n\t}\n}\n\n\n\n\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 3.8;\n\t// use mouse x coord\n\tfloat a = iTime*1. + .1;\n\t//if( iMouse.z > 0. )\n\t//\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,2.5,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,2.2,0.);\n     \n    // camera frame\n\txoff = 0.;\n\tfloat yoff = 0.;\n\t//if( iMouse.z > 0. )\n\t{\n\t\txoff = -3.5*(iMouse.x/iResolution.x - .5)+.5;\n        if( iMouse.y != 0. )\n\t\t\tyoff = 2.*(4.*iMouse.y/iResolution.y-1.5);\n\t}\n\t\n\tvec3 toTarget = target-cameraPos;\n\tvec3 right = vec3(-toTarget.z,0.,toTarget.x);\n\t\n    vec3 fo = normalize(target-cameraPos + vec3(0.,yoff,0.) + xoff*right );\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n\n\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdj3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1660, 1680, 1709, 1709, 1808], [1810, 1830, 1871, 1871, 1894], [1896, 2001, 2029, 2029, 2087], [2089, 2101, 2155, 2212, 3544], [3648, 3648, 3705, 3705, 7981], [7988, 7988, 8043, 8078, 9045], [9050, 9109, 9131, 9131, 9462], [9464, 9464, 9486, 9486, 9655]], "test": "ok"}
{"id": "Mdj3Wd", "name": "Gaussian Wave", "author": "novalis", "description": "Just a simple extension to the default shader with a gaussian profiled sine wave.", "tags": ["wave", "gaussian"], "likes": 5, "viewed": 232, "published": "Public", "date": "1395408453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec4 col = vec4(vec3(cos(iTime)*.2+uv.x, sin(iTime)*.1+uv.y, 1.), 1.0);\n\tfloat dist = distance(vec2(uv.x, sin(uv.x*sin(iTime)*2.+iTime)/3.+.5), uv);\n\tcol += vec4(vec3(exp(-pow(dist,2.)/2e-3)), 1.);\n\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdj3Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 320]], "test": "ok"}
{"id": "MdjGWt", "name": "[SH2014] Simplex_Fractal 3D", "author": "cabbibo", "description": "3D Simplex fractal", "tags": ["3d", "fractal", "simplex"], "likes": 1, "viewed": 329, "published": "Public", "date": "1395286708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// KALI FRACTAL\nvec3 kali( vec3 v , vec3 s ){\n\tfloat m = 0.0;\n\tfor( int i = 0; i < 5 ; i ++){\n\tv.x = abs(v.x);\n\tv.y = abs(v.y); \n\tv.z = abs(v.z);\n\tm = v.x * v.x + v.y * v.y + v.z * v.z;\n\tv.x = v.x / m + s.x;\n\tv.y = v.y / m + s.y;\n\tv.z = v.z / m + s.z;\n    }\n\treturn v;\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n\n\nfloat r;\n\nfloat map( in vec3 p )\n{\n\t\n\n\tvec4 a = texture(iChannel0 ,  vec2(abs(p.x) , abs(p.y) ));\n\tfloat t1 = .5 + .5*sin(  iTime * .3);\n\tfloat t2 = .5 + .5*sin(  iTime * .2);\n\tfloat t3 = .5 + .5*sin(  iTime * .1);\n\t\n\t//p *= t1;\n\tfloat noise = .9 * snoise( vec3( p.x , p.y , t1 ));\n\tfloat noise1 = .9 * snoise( vec3( p.x * 5. , p.y * 5. , t2 ));\n\tfloat noise2 = .9 * snoise( vec3( p.x * 10. , p.y * 10. , t3 ));\n\tfloat noise3 = .9 * snoise( vec3( p.x * 40. , p.y * 40. , t1 ));\n\n\t\n\t//float noise2\n\t\n\tfloat e = r * noise*noise1*noise2*noise3;\n\t\n    return  max( e + a.x * .01 + length(p) -1.0 , -2.0 );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n\n\tvec3 e = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(map(p+e.xyy) - map(p-e.xyy),\n\t\t\t\t\t\t   map(p+e.yxy) - map(p-e.yxy),\n\t\t\t\t\t\t   map(p+e.yyx) - map(p-e.yyx) ) );\n\t\t\t\t\t\t   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 p = -1.0 + 2.0*uv;\n\t\n\tp.x *= iResolution.x/iResolution.y;\n\n    //r = 2.0*texture( iChannel0, uv ).x;\n\tr = 1.0;\n\tvec3 ro = vec3(0.0, 0.0, 2.0 );\n\tvec3 rd = normalize( vec3( p, -1.0 ) );\n\t\n\t\n\tvec3 col = vec3(0.0);\n\t\n\t\n\tfloat tmax = 10.0;\n\tfloat h = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<100; i++ )\n\t{\n\t\tif( h<0.00001 || t>tmax ) continue;\n\t\th = map( ro + t*rd );\n\t\tt += h;\n\t}\n\t\n\t\n\tif( t<tmax )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\tcol = vec3(1.0, 1.0, 1.0 );\n\t\t//col *= dot( nor, vec3(0.57703) );\n\t\t\n\t\tvec3 nReduce = nor * .4;\n\t\tvec3 c = nReduce + vec3( .5 , .5 , .5 );\n\t\tvec3 kCol = kali( vec3( -c.x  , -c.y , -c.z ) , vec3( -.5 , -.5 , -.5 ) );\n\t\tcol = normalize( vec3( .5  , .4 , .9 ) + kCol );\n\t\tcol *= dot( nor, vec3(0.57703) );\n\t}\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdjGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 16, 45, 45, 270], [274, 668, 689, 689, 738], [740, 740, 761, 761, 810], [812, 812, 834, 834, 874], [876, 876, 904, 904, 956], [958, 958, 982, 982, 3126], [3142, 3142, 3166, 3166, 3735], [3737, 3737, 3767, 3767, 3944], [3946, 3946, 4003, 4003, 4843]], "test": "ok"}
{"id": "MdS3Dc", "name": "[TDF2014] Glitch07", "author": "mu6k", "description": "This is my entry for the 7 line GLSL compo at Tokyo demofest!", "tags": ["raymarching", "animation"], "likes": 13, "viewed": 766, "published": "Public", "date": "1395301687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*---------------------------------------------------------------------------\nGlitch07 by musk/brainstorm                 Tokyo Demo Fest 2014 2014/3/21-23\n                                                  7 Lines GLSL Graphics Compo\n\nCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfeatures:\n\n\tanimation:\n\t - time based intro effect (first 10 seconds)\n\t - rotating object\n\tgeometry:\n\t - raymarching\n\t - geometry repetition via rotation\n\t - signed distance field is a simple box\n\tshading:\n\t - one sample ambient occlusion\n\tpost processing:\n\t - gamma correction\n\t - vignette\n\ntested on: \n\t\n\tNVIDIA 9800, AMD A4 and I get the same result. This means that the \nshader is stable even though it looks like a random glitch :D\n\nHow to run it?\n\t1. Open http://glsl.heroku.com/e in your browser\n\t2. Copy the text from this file\n\t3. Paste it into the code editor on the website\n\tPS: your browser needs WebGL\n\nObligatory section which doesn't count into the 7 lines :D                 */\n#ifdef GL_ES\nprecision mediump float;\n#endif\n                                                                           /*\nHere are the 7 lines:\n----8<---------------------------------------------------------------------*/\nfloat t=iTime*.5;float m(vec3 p){p=abs(p);return max(p.x-6.5,max(p.y-.4\n,p.z-.4));}vec2 r(vec2 p){float a=mod(atan(p.x,p.y),.4)-.5;return vec2(cos(a)\n,sin(a))*length(p);}float f(vec3 p){p.xz*=mat2(sin(t),cos(t),-cos(t),sin(t));\np.xz=r(p.xz);p.yz=r(p.yz);p.xy=r(p.xy);return (m(p));}void mainImage( out vec4 fragColor, in vec2 fragCoord ){vec2 uv\n=fragCoord.xy/iResolution.yy-vec2(.9,.5); vec3 p=vec3(cos(uv*999.0)/(t*t*t\n),-5.),d=vec3(uv,.5);for(int i=0;i<50;i++){p+=d*f(p);}fragColor = vec4(min\n(pow(f(p-d),.5),1.)-length(uv)*.5);}\n/*--8<---------------------------------------------------------------------*/\n\n//glsl.heroku.com version (compo version)\n/*--8<-----------------------------------------------------------------------\nuniform float time;uniform vec2 resolution;float t=time*.5;float m(vec3 p){p=\nabs(p);return max(p.x-6.5,max(p.y-.4,p.z-.4));}vec2 r(vec2 p){float a=mod(\natan(p.x,p.y),.4)-.5;return vec2(cos(a),sin(a))*length(p);}float f(vec3 p){p.\nxz*=mat2(sin(t),cos(t),-cos(t),sin(t));p.xz=r(p.xz);p.yz=r(p.yz);p.xy=r(p.xy)\n;return (m(p));}void mainImage( out vec4 fragColor, in vec2 fragCoord ){vec2 uv=fragCoord.xy/resolution.yy-vec2(.9\n,.5); vec3 p=vec3(cos(uv*999.0)/(t*t*t),-5.),d=vec3(uv,.5);for(int i=0;i<50;i\n++){p+=d*f(p);}fragColor = vec4(min(pow(f(p-d),.5),1.)-length(uv)*.5);}\n----8<---------------------------------------------------------------------*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdS3Dc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1126, 1246, 1262, 1262, 1312], [1312, 1312, 1327, 1327, 1399], [1399, 1399, 1415, 1415, 1511], [1511, 1511, 1567, 1567, 1761]], "test": "ok"}
{"id": "MdSGDd", "name": "Perforations 2", "author": "ahihi", "description": "now with less r", "tags": ["2d"], "likes": 6, "viewed": 543, "published": "Public", "date": "1395100249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307179586\n\nfloat scale(float l0, float r0, float l1, float r1, float x) {\n\treturn (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nvec2 polar(vec2 p) {\n\treturn vec2(atan(p.y, p.x), length(p));\n}\n\nvec2 cartesian(vec2 p) {\n\treturn vec2(p.y * cos(p.x), p.y * sin(p.x))\t;\n}\n\nvec2 rotate(float theta, vec2 p) {\n\tvec2 p_polar = polar(p);\n\tp_polar.x += theta;\n\treturn cartesian(p_polar);\n}\n\nvec2 shear(float theta, vec2 p) {\n\treturn vec2(p.x - p.y / tan(theta), p.y / sin(theta));\n}\n\nvec2 unshear(float theta, vec2 p) {\n\tfloat y = p.y * sin(theta);\n\tfloat x = p.x + y / tan(theta);\n\treturn vec2(x, y);\t\n}\n\nvec2 target(float theta, float delta, vec2 p) {\n\treturn unshear(theta, floor(shear(theta, p) + delta) - delta + 0.5);\n}\n\nfloat perforations(float theta, float rot, float scale, float r, vec2 p0) {\n\tvec2 p1 = scale * rotate(rot, p0);\n\treturn distance(p1, target(theta, 0.5, p1)) - r;\n}\n\nvec3 blend(float k, vec3 c0, vec3 c1) {\n\tfloat k_clamp = clamp(k, 0.0, 1.0);\n\treturn (1.0 - k) * c0 + k * c1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p0 = 2.0*(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n\tvec2 p0_1 = vec2(p0.x, p0.y);\n\tvec2 p0_2 = vec2(p0.x, p0.y);\n\t\n\tvec2 p1_polar = polar(p0);\n\tp1_polar.y = p1_polar.y * pow(cos(0.6 * length(p0)), 1.5);\n\tvec2 p1 = cartesian(p1_polar);\n\t\n\t// mess with this for all sorts of fun patterns\n\tfloat theta = TAU / 6.0;\n\t\n\tfloat rot1 = 0.004 * TAU * iTime;\n\tfloat rot2 = rot1 + TAU / 12.0 + TAU / 13.0 * sin(0.2 * iTime);\n\t\n\tfloat scale1 = 16.0;\n\tfloat scale2 = 16.0;\n\t\n\tfloat r1 = 0.25;\n\tfloat r2 = 0.25;\n\t\n\tfloat i1 = perforations(theta, rot1, scale1, r1, p1);\n\tfloat i2 = perforations(theta, rot2, scale2, r2, p1);\n\t\n\tvec3 bg = blend(length(p0), vec3(0.0, 0.2, 0.6), vec3(0.0, 0.0, 0.3));\n\tvec3 fg = blend(length(p0), vec3(1.0, 0.0, 0.5), vec3(0.5, 0.0, 1.0));\n\t\n\tfloat satan = 0.03;\n\tfloat k = scale(-satan, satan, 0.0, 1.0, max(i1, i2));\n\t\n\tvec3 color = bg;\n\tif(k < 0.0) {\n\t\tcolor = fg;\n\t} else if(k < 1.0) {\n\t\tcolor = blend(0.5, fg, bg);\t\n\t}\n\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 93, 93, 142], [144, 144, 164, 164, 207], [209, 209, 233, 233, 282], [284, 284, 318, 318, 395], [397, 397, 430, 430, 488], [490, 490, 525, 525, 610], [612, 612, 659, 659, 731], [733, 733, 808, 808, 896], [898, 898, 937, 937, 1009], [1011, 1011, 1068, 1068, 2065]], "test": "ok"}
{"id": "MdsXzr", "name": "Fluid Amoeba", "author": "jpm8888", "description": "Smooth amobea shader, fusing liquids", "tags": ["amoebafluidfusionsmooth"], "likes": 20, "viewed": 669, "published": "Public", "date": "1396270081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define POINTS 25.0\n#define RADIUS 350.0\n#define BRIGHTNESS 0.95\n#define COLOR vec3(1.0, 1.0, 1.0)\n#define SMOOTHNESS 40.0\n\n#define LAG_A 2.325\n#define LAG_B 3.825\n#define LAG_C 8.825\n\nvec2 getPoint(float n) {\n     float t = iTime * 0.1;\n     vec2 center = iResolution.xy / 2.0;\n     vec2 p = (\n            vec2(100.0, 0.0) * sin(t *  2.5 + n * LAG_A)\n          + vec2(110.0, 100.0) * sin(t * -1.5 + n * LAG_B)\n          + vec2(150.0, 100.0) * cos(t * 0.05 + n * LAG_C)\n          + vec2(150.0, 0.0) * sin(t * 0.15 + n)\n     );\n     return center + p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     vec2 position = fragCoord.xy;\n     float b = 0.3;\n    \n     for (float i = 0.0; i < POINTS; i += 0.8) {\n          vec2 p = getPoint(i);\n          float d = 1.0 - clamp(distance(p, position) / RADIUS, 0.0, 0.5);\n          b += pow(d, SMOOTHNESS);\n     }\n    \n     vec3 c = 0.9 - b+(\n            //(sin(b * 24.0) - 0.25) * vec3(0.3, 0.1, 1.0)\n          //+ b * vec3(0.57, 0.0, 0.0)\n          + clamp(1.0 - b, 1.0, 1.0) * (cos(b * 10.0) + 1.25) * vec3(1.5, 1.5, 1.5)\n     );\n    \n     fragColor = vec4(c * BRIGHTNESS, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 253, 253, 596], [598, 598, 655, 655, 1183]], "test": "ok"}
{"id": "Ms2GDd", "name": "Heli", "author": "avix", "description": "semi finished.. got bored with it...", "tags": ["procedural", "3d"], "likes": 3, "viewed": 227, "published": "Public", "date": "1395433748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FARCLIP    55.0\r\n\r\n#define MARCHSTEPS 60\r\n#define AOSTEPS    20\r\n#define SHSTEPS    20\r\n#define SHPOWER    1.0\r\n\r\n#define PI         3.14\r\n#define PI2        PI*0.5    \r\n#define d90        1.57079633\r\n#define d15        0.261799388\r\n\r\n#define AMBCOL     vec3(1.0,1.0,1.0)\r\n#define BACCOL     vec3(1.0,1.0,1.0)\r\n#define DIFCOL     vec3(1.0,1.0,1.0)\r\n\r\n#define MAT1       1.0  //terrain\r\n#define MAT2       2.0  //water\r\n#define MAT3       3.0  //trees\r\n\r\n#define MAT4       4.0  //body\r\n#define MAT5       5.0  //windows\r\n#define MAT6       6.0  //propelers\r\n#define MAT7       7.0  //legs\r\n\r\n/***********************************************/\r\nfloat rbox(vec3 p, vec3 s, float r) {\t\r\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\r\n}\r\nfloat sminp(float a, float b) {\r\nconst float k=0.1;\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n/***********************************************/\r\nfloat hash(float n) { \r\n\treturn fract(sin(n)*43758.5453123); \r\n}\r\n/***********************************************/\r\nfloat noise2(vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n\tfloat n = p.x + p.y*57.0;\r\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\r\n}\r\n/***********************************************/\r\nvoid oprep(inout vec3 p, float l, float s) {\r\n\tfloat r=1./l;\r\n\tfloat ofs=s+s/(r*2.0);\r\n\tfloat a= mod( atan(p.x, p.z) + PI2*r, PI*r) -PI2*r;\r\n\tp.xz=vec2(sin(a),cos(a))*length(p.xz) -ofs;\r\n\tp.x+=ofs;\r\n}\r\nvoid oprepb(inout vec3 p, float l, float s) {\r\n\tfloat r=1./l;\r\n\tfloat ofs=s+s/(r*2.0);\r\n\tfloat a= mod( atan(p.x, p.y) + PI2*r, PI*r) -PI2*r;\r\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\r\n\tp.x+=ofs;\r\n}\r\n/***********************************************/\r\nvec2 rot(vec2 k, float t) {\r\n    float ct=cos(t); \r\n    float st=sin(t);\r\n    return vec2(ct*k.x-st*k.y,st*k.x+ct*k.y);\r\n}\r\n/***********************************************/\r\nvec3 opU(vec3 a, vec3 b) {\r\n\treturn mix(a, b, step(b.x, a.x));\r\n}\r\n/***********************************************/\r\nvec3 chop(vec3 p) {\r\n    p.x+=sin(PI+iTime)*2.0;\r\n    p.y-=0.5+sin(iTime*0.35)*0.75;\r\n    p.xz=rot(p.xz,-d90+sin(PI2+iTime));\r\n    p.xy=rot(p.xy,d15);\r\n\r\n    vec3 q=p;\r\n        q.z+=sin(p.z)*0.5;\r\n        q.y+=sin(p.y)*0.45 -0.05;\r\n        float h=length(q)-0.3;\r\n        float t=rbox(p+vec3(-0.25,-0.1,0.0), vec3(0.2,0.1,0.2),0.025);\r\n        float r=rbox(p+vec3(0.05,-0.1,0.0), vec3(0.08,0.1,0.3),0.025);\r\n    vec3 wind=vec3 (max(min(t,r),h),MAT5,0.0);\r\n    \r\n    h=max(max(h,-t),-r);\r\n          t=rbox(p+vec3(0.5,-0.12,0.0), vec3(0.3,0.05,0.06),0.05);\r\n    h=sminp(h,t);\r\n          t=rbox(p+vec3(0.8,-0.23,0.0), vec3(0.05,0.1,0.04),0.02);\r\n    h=sminp(h,t);\r\n    \r\n        q.xz=-abs(p.xz);\r\n        q.yz+=vec2(0.3,0.2);\r\n          r=rbox(q, vec3(0.2,0.015,0.015),0.0075);\r\n        q+=vec3(0.1,-0.025,-0.2);\r\n          t=rbox(q, vec3(0.015,0.015,0.2),0.0075);\r\n        r=min(r,t);      \r\n        wind=opU(wind,vec3(r,MAT7,0.0));\r\n//        h=min(h,r);      \r\n\r\n        q=p;\r\n        q.xz=rot(q.xz,iTime*9.0);\r\n        oprep(q,1.5,0.1);\r\n        r=rbox(q+vec3(0.0,-0.25,0.0), vec3(0.04,0.01,0.5),0.01);\r\n        q=p;\r\n        q+=vec3(0.8,-0.25,-0.05);\r\n        q.xy=rot(q.xy,iTime*9.0);\r\n        oprepb(q,1.5,0.0);\r\n        t=rbox(q, vec3(0.03,0.15,0.01),0.01);\r\n    vec3 rotors=vec3(min(r,t),MAT6,0.0);\r\n    \r\n    return opU(rotors,opU(wind,vec3(h, MAT4,0.0)));\r\n}\r\n\r\n/***********************************************/\r\nvec3 DE(vec3 p) {\r\n\r\nfloat rw=0.8;                //river width\r\nfloat sw=0.55;              //shore to side transition speed\r\nfloat h=p.y+0.8;\r\nfloat ss=0.0;\r\n\r\nfloat mat=MAT1;\r\nvec3 q=p;\r\n\r\n        p.z+=iTime*2.0;\r\n\r\n        float crv=sin(p.z*0.5)*2.0+0.5;         //river path center\r\n        float lrv=crv+rw + noise2(p.xz);  //left shore path\r\n        float rrv=crv-rw + noise2(p.zx);  //right shore path\r\n\r\n        //river        \r\n        if ( p.x<lrv && rrv<p.x ) {  //water surface\r\n            mat=MAT2;\r\n            ss=texture(iChannel0, p.xz).x*0.01; \r\n            h+=ss;\r\n        } else { //terrain\r\n\r\n            float t=texture(iChannel0, p.xz*0.001).x*1.25; //hills \r\n            float g=texture(iChannel0, vec2(p.x*0.2,p.z*0.5*0.2)).x*0.05;  //greens\r\n            t+=g;\r\n            //soft shore transition\r\n            if ( p.x>lrv ) sw=t*clamp( (p.x - lrv  )*sw ,0.0,3.0); else\r\n                           sw=t*clamp( abs(p.x - rrv)*sw ,0.0,3.0);\r\n            h-=sw;               \r\n            if (g>0.01) { mat=MAT3; ss=g; } else ss=sw;\r\n            \r\n        }\r\n\r\n    return opU(chop(q),vec3(h,mat,ss));\r\n}\r\n/***********************************************/\r\n#define suncolor vec3(0.8,0.8,0.2)  //vec3(0.8,0.7,0.9)\r\nvec3 sky(vec3 rd, vec3 sky){\r\n    float sa=max(dot(rd,sky),0.0);\r\n    float v=pow(1.0-max(rd.y,0.0),8.0);\r\n    vec3 s=mix(vec3(0.7,0.8,0.9),vec3(0.9,0.9,0.9),v);\r\n        s=s+suncolor*sa*sa*0.2;\r\n        s=s+suncolor*min(pow(sa,550.0)*1.5,0.3);\r\n    return clamp(s,0.0,1.0);\r\n}\r\n/***********************************************/\r\nvec3 clouds(vec3 ro, vec3 rd, vec3 col) {\r\n    float v=(250.0-ro.y)/rd.y;\r\n    rd.xz*=v;\r\n    rd.xz+=ro.xz;\r\n    rd.xz*=0.1;\r\n    float f=noise2(rd.xz*0.05+iTime*0.2)*2.2;\r\n    col=mix(col,vec3(0.75,0.75,0.73), clamp(f*rd.y,0.0,1.0));\r\n    return col;\r\n}\r\n/***********************************************/\r\nvec3 normal(vec3 p) {\r\n\tvec3 e=vec3(0.01,-0.01,0.0);\r\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\r\n}\r\n/***********************************************/\r\nfloat calcAO(vec3 p, vec3 n ){\r\n\tfloat ao = 0.0;\r\n\tfloat sca = 1.0;\r\n\tfor (int i=0; i<AOSTEPS; i++) {\r\n        \tfloat h = 0.01 + 1.2*pow(float(i)/float(AOSTEPS),1.5);\r\n        \tfloat dd = DE( p+n*h ).x;\r\n        \tao += -(dd-h)*sca;\r\n        \tsca *= 0.65;\r\n\t\tif( ao>0.99 ) break;\r\n    \t}\r\n   return clamp( 1.0 - 1.0*ao, 0.0, 1.0 );\r\n //  return clamp(ao,0.0,1.0);\r\n}\r\n/***********************************************/\r\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\r\n\tfloat res = 1.0;\r\n    for( int i=0; i<SHSTEPS; i++ ) {\r\n    \tif( s>e ) break;\r\n        float h = DE( ro + rd*s ).x;\r\n        res = min( res, k*h/s );\r\n    \ts += 0.02*SHPOWER;\r\n\t\tif( res<0.001 ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n/***********************************************/\r\nvoid rot2( inout vec3 p, vec3 r) {\r\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\r\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\r\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\r\n}\r\n/***********************************************/\r\n\r\nvoid animate(inout vec3 ro) {\r\n ro.xz=rot(ro.xz,iTime*0.1);   \r\n    ro.z+=sin(iTime*0.2)*5.0;\r\n    ro.y+=5.0+abs(sin(iTime))*0.35;\r\n}\r\n/***********************************************/\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\t\r\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\r\n\tvec3 ro =vec3(0.0, 0.0, -13.0);     //-10.0\r\n\tvec3 lig=normalize(vec3(0.0, 0.5, 5.0));\r\n\tvec3 sun=normalize(vec3(0.0, 0.5, 5.0));\r\n\r\nanimate(ro);\r\n\t\r\n\tvec2 mp=iMouse.xy/iResolution.xy;\r\n\trot2(ro,vec3(mp.x,mp.y,0.0));\r\n\trot2(lig,vec3(mp.x,-mp.y,0.0));\r\n\r\n\tvec3 cf = normalize( ta - ro );\r\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\r\n    vec3 cu = normalize( cross(cr,cf));\r\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\r\n\r\n\tvec3 col=vec3(1.0);\r\n\t/* trace */\r\n\tvec3 r=vec3(0.0);\t\r\n\tfloat d=0.0;\r\n\tvec3 ww;\r\n\tfor(int i=0; i<MARCHSTEPS; i++) {\r\n\t\tww=ro+rd*d;\r\n\t\tr=DE(ww);\t\t\r\n        if( abs(r.x)<0.01 || r.x>FARCLIP ) break;\r\n        d+=r.x;\r\n\t}\r\n    r.x=d;\r\n\t/* draw */\r\n\tif( r.x<FARCLIP ) {\r\n\t    \r\n\t    vec2 rs=vec2(1.0,1.0);  //rim and spec\r\n\r\n\t\tif (r.y==MAT1) { col=smoothstep(vec3(0.0,0.0,0.06),vec3(0.63,0.63,0.605), vec3(r.z*3.1)); rs=vec2(0.3,0.6); }\r\n\t\tif (r.y==MAT2) { col=vec3(0.148,0.157,0.331); rs=vec2(1.0,0.6); }\r\n\t\tif (r.y==MAT3) { col=smoothstep(vec3(0.235,0.114,0.105), vec3(1.0,0.713,1.623), vec3(r.z*10.0));  rs=vec2(0.0,0.5); }\r\n\r\n\t\tif (r.y==MAT4) { col=vec3(0.95,0.34,0.21);  rs=vec2(0.2,1.0); }\r\n\t\tif (r.y==MAT5) { col=vec3(0.6,0.7,0.95);  rs=vec2(0.2,1.0); }\r\n\t\tif (r.y==MAT6) { col=vec3(0.1,0.2,0.1);  rs=vec2(0.2,1.0); }\r\n\t\tif (r.y==MAT7) { col=vec3(0.91,0.95,0.98);  rs=vec2(0.2,1.0); }\r\n\r\n\t\tvec3 nor=normal(ww);\r\n\r\n    \tfloat amb= 1.0;\t\t\r\n    \tfloat dif= clamp(dot(nor, lig), 0.0,1.0);\r\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,1.0);\r\n    \tfloat rim= pow(1.+dot(nor,rd), 3.0);\r\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.0, 1.0 ) ,16.0 );\r\n    \tfloat ao= calcAO(ww, nor);\r\n    \tfloat sh= calcSh(ww, lig, 0.01, 2.0, 4.0);\r\n\r\n\t    col *= 0.5*amb*AMBCOL*ao + 0.4*dif*DIFCOL*sh + 0.05*bac*BACCOL;\r\n\t    col += 0.3*rim*amb * rs.x;\r\n    \tcol += 0.5*pow(spe,1.0)*sh * rs.y;\r\n\r\n     \r\n\t}else {\r\n        col=sky(rd,sun);\r\n        col=clouds(ro,rd,col);\r\n\t}\r\n\r\n    \t\r\n\t\t\r\n//\tcol*=exp(.01*-d); col*=0.9;\t\r\n    \r\n\tfragColor = vec4( col, 1.0 );\r\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2GDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[600, 651, 688, 688, 741], [743, 743, 774, 774, 890], [892, 943, 964, 964, 1007], [1009, 1060, 1082, 1082, 1304], [1306, 1357, 1401, 1401, 1557], [1559, 1559, 1604, 1604, 1760], [1762, 1813, 1840, 1840, 1935], [1937, 1988, 2014, 2014, 2053], [2055, 2106, 2125, 2125, 3472], [3476, 3527, 3544, 3544, 4655], [4657, 4765, 4793, 4793, 5042], [5044, 5095, 5136, 5136, 5349], [5351, 5402, 5423, 5423, 5572], [5574, 5625, 5655, 5655, 5990], [5992, 6043, 6104, 6104, 6353], [6355, 6406, 6440, 6440, 6672], [6674, 6727, 6756, 6756, 6860], [6862, 6913, 6970, 6970, 9098]], "test": "ok"}
{"id": "Ms2GDV", "name": "Scythe", "author": "otaviogood", "description": "This is my first attempt at ray marching.", "tags": ["raymarching"], "likes": 33, "viewed": 1341, "published": "Public", "date": "1394129693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Set this to 1.0 for crazy morphing animation.\n#define crazyAnim 0.0\n\nfloat PI=3.14159265;\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 255.0;\nvec3 environmentSphereColor = vec3(0.3001, 0.501, 0.901);\n\nfloat distFromSphere;\nvec3 normal;\nvec3 texBlurry;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nvec3 RotateX(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n\t//else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n\t//else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// exponential smooth min (k = 32);\n/*float smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}*/\n\n// This function basically is a procedural environment map that makes the sun and sky.\n// (I deleted the sky to make it more gloomy)\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.1 / sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn environmentSphereColor * 0.01 + sunCol * sunIntensity;\n}\n\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\nfloat dSphere(vec3 p, float rad)\n{\n\t//vec3 center = vec3(0, 0, 0.0);\n\t//p -= center;\n\t//rad += sin(p.y * 32.0 - iTime * 8.0) * 0.01;\n\t// This makes a basic sphere.\n\treturn length(p) - rad;\n}\nfloat dSphereWave(vec3 p, float rad)\n{\n\t//vec3 center = vec3(0, 0, 0.0);\n\t//p -= center;\n\trad -= 0.05;\n\trad += sin(p.y * 8.0 - iTime * 2.0) * 0.03;\n\treturn length(p) - rad;\n}\n\nfloat dBox(vec3 pos)\n{\n\tfloat b = 0.8;\n\tvec3 center = vec3(0, 0, 0.0);\n\treturn length(max(abs(pos - center)-(b*(cos(pos.y))),0.0));\n}\n\nfloat dBoxSigned(vec3 p)\n{\n\t// This makes a twisted box that is cut off.\n\tfloat b = 0.8;\n\t//vec3 center = vec3(0, 0, 0.0);\n\tp = RotateY(p, (p.y * cos(iTime*crazyAnim)-0.24)*PI);\n\tvec3 d = abs(p /*- center*/) - b*abs(cos(p.y + 0.5));\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dFloor(vec3 p)\n{\n\treturn p.y + 2.0;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z + abs(p.y)*0.05;\n}\n\nfloat dJank(vec3 p)\n{\n\t//p += vec3(0.0, -1.54, 0.0);\n\tp += vec3(0.0, -1.62, 0.0);\n\t// This makes the janky blade object. It's really just a sphere subtracted from a cube,\n\t// but twisted and cut off.\n\treturn max(dBoxSigned(p), -dSphere(p, 1.0));\n}\n\nfloat dSquareJank(vec3 p)\n{\n\t// This copies 5 rotations of the basic janky blade object. The 5 rotations make most of a cube.\n\t// I use smin() function to smoothly blend between the 5 objects.\n\tfloat final = dJank(p);\n\t//const float blend = 7.0;// 0.41;\n\tconst float blend = 0.41;\n\tvec3 p2 = p.xzy * vec3(1.0, 1.0, -1.0);// RotateX(p, PI/2.0);\n\t//vec3 p2 = RotateX(p, PI/2.0);\n\tfinal = smin(final, dJank(p2), blend);\n\tp2 = p.xzy * vec3(1.0, -1.0, 1.0);//  RotateX(p, -PI/2.0);\n\t//p2 = RotateX(p, -PI/2.0);\n\tfinal = smin(final, dJank(p2), blend);\n\tp2 = p.yxz * vec3(1.0, -1.0, 1.0);// RotateZ(p, PI/2.0);\n\t//p2 = RotateZ(p, PI/2.0);\n\tfinal = smin(final, dJank(p2), blend);\n\tp2 = p.yxz * vec3(-1.0, 1.0, 1.0);// RotateZ(p, -PI/2.0);\n\t//p2 = RotateZ(p, -PI/2.0);\n\tfinal = smin(final, dJank(p2), blend);\n\tp2 = p.xyz * vec3(1.0, -1.0, -1.0);\n\t//final = smin(final, dJank(p2), blend);\n\treturn final;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\t//vec3 c = vec3(1.0, 1.0, 1.0)* 1.0;\n\t//vec3 q = mod(p,c)-0.5*c;\n\t//p = q;\n\n\t// This makes the janky-looking blade object.\n\tfloat final = dSquareJank(p);\n\t// This makes the wavy sphere on the inside.\n\tfinal = min(final, dSphereWave(p, 0.1 + sin(iTime*0.0) * 0.015 + 0.87));\n\t//final = smin(final, sdCylinder(p, vec3(0.0, 0.0, 0.001) ), 0.5);\n\t//final = min(final, dFloor(p));\n\treturn final;\n\t//return clamp((distance(pos, vec3(0, 0, 1.0)) - 1.0), 0.0, 1.0);\n\t//return dSphere(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(2.6); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\t// I put a bounding sphere around the whole object. If the ray is outside\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\n\tvec3 iA, iB;\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 1.9, camPos, camPos+relVec,\n\t\t\t\t\t\t\t\t\t  iA, iB);\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.02;\n\tfloat t = 0.5;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 6.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\n\t{\n\t\tfor (int i = 0; i < 180; i++)\t// This is the count of how many times the ray actually marches.\n\t\t{\n\t\t\tif ((t > maxDepth) || (abs(dist) < 0.001))\n            {\n                break;\n                continue;\t// break DOESN'T WORK!!! ARRRGGG!\n            }\n\t\t\tpos = camPos + relVec * t;\n\t\t\t// *******************************************************\n\t\t\t// This is _the_ function that defines the \"distance field\".\n\t\t\t// It's really what makes the scene geometry.\n\t\t\t// *******************************************************\n\t\t\tdist = DistanceToObject(pos);\n\t\t\tinc = dist;\n\t\t\tt += inc * 0.45;\t// because deformations mess up distance function.\n\t\t\t\n\t//\t\tif ((t > maxDepth) || (abs(dist) < 0.001)) break;\n\t\t}\n\t}\n\telse\n\t{\n\t\tt = maxDepth + 1.0;\n\t}\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(1.0, 1.0, 0.0));\n\t// This sun color value will only be used as a backup in case no ray hits the object.\n\tvec3 finalColor = GetSunColorReflection(relVec, sunDir) + vec3(0.1, 0.1, 0.1);\n\n\t// calculate the normal from the distance field. The distance field is a volume, so if you\n\t// sample the current point and neighboring points, you can use the difference to get\n\t// the normal.\n\tvec3 smallVec = vec3(0.02, 0, 0);\n\tvec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n\t\t\t\t\t   dist - DistanceToObject(pos - smallVec.yxy),\n\t\t\t\t\t   dist - DistanceToObject(pos - smallVec.yyx));\n\tnormal = normalize(normal);\n\n\t// calculate the reflection vector for highlights\n\tvec3 ref = reflect(relVec, normal);\n\t\n\t// This is the rainbow coloring for the inside wavy sphere.\n\tvec3 spinner = abs(RotateY(normal * normal, iTime* 2.0)) * vec3(1.0, 1.0, 1.0);\n\tvec3 inner = abs(RotateY((-normal) * (-normal), iTime* 2.0)) * vec3(1.0, 1.0, 1.0);\n\t// get some texture on that inner wavy rainbow sphere.\n\tvec4 texX = texture(iChannel0, normal.yz);// * vec2(0.925, 0.0) + vec2(iTime*1.0, 0.0));\n\tvec4 texZ = texture(iChannel0, normal.xy);// * vec2(0.0, 0.925) + vec2(0.0, iTime*1.0));\n\tvec4 noise = mix(texX, texZ, abs(normal.z));\n\n\t// If a ray actually hit the object, let's light it.\n\tif (t <= maxDepth)\n\t{\n\t\tfinalColor = GetSunColorReflection(ref, sunDir)*0.68;// sunCol * max(0.0, dot(normal, -sunDir));\n\t\t// make a darker stripe in the middle, redder towards the top and bottom\n\t\tfinalColor *= vec3(0.3 + abs(pos.y*pos.y), 0.35, 0.3);\n\t\t// we need the glowy rainbow sphere to illuminate the blade object from the inside.\n\t\tvec3 innerLight = inner * 2.0 * max(0.0,dot(pos, -normal)) + vec3(1.0,1.0,1.0)*0.3;\n\t\tinnerLight *= (1.45 - length(pos));\n\t\tfinalColor += max(vec3(0,0,0),innerLight);\n\t\tfinalColor += vec3(0.02, 0.050, 0.09);\n\t\t//finalColor = sunCol * max(0.0, dot(normal, sunDir));\n\n\t\t// If we are inside a certain radius, call it the inner sphere and make it rainbow colors.\n\t\tif ((length(pos) < 1.0) || (length(pos.xz) < 0.5))\n\t\t{\n\t\t\tfinalColor = spinner*2.0 + vec3(1.0,1.0,1.0)*0.25;\n\t\t\tfinalColor += noise.xyz*0.15;\n\t\t}\n\t}\n\t//finalColor += hit*0.1;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2GDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 253, 276, 276, 306], [307, 307, 330, 330, 360], [361, 361, 386, 386, 416], [418, 418, 451, 451, 660], [661, 661, 694, 694, 903], [904, 904, 937, 937, 1078], [1082, 1118, 1159, 1159, 1252], [1407, 1540, 1594, 1594, 1895], [1897, 1897, 2016, 2077, 2771], [2773, 2773, 2807, 2936, 2963], [2964, 2964, 3002, 3052, 3138], [3140, 3140, 3162, 3162, 3273], [3275, 3275, 3301, 3347, 3570], [3572, 3572, 3594, 3594, 3615], [3617, 3617, 3653, 3653, 3703], [3705, 3705, 3726, 3757, 3952], [3954, 3954, 3981, 4146, 4849], [4851, 4851, 4883, 5007, 5368], [5370, 5370, 5427, 5512, 10122]], "test": "ok"}
{"id": "MsB3Dc", "name": "Infinite Spheres", "author": "Justaway", "description": "Infinite spheres with depth of field.", "tags": ["raymarching"], "likes": 3, "viewed": 350, "published": "Public", "date": "1394572647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nvec3 lp=vec3(10.0,10.0,10.0);\nvec4 lc=vec4(0.5);\nvec4 la=vec4(0.5);\nvec4 mc=vec4(0.0);\nfloat s;\nfloat t;\nvoid srand(vec2 p){\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\nfloat rand(){\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\nmat3 rot_x(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\nmat3 rot_y(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\nmat3 rot_z(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\nmat3 rot(vec3 z,float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat ic=1.0-c;\n\treturn mat3(\n\t\tic*z.x*z.x+c,ic*z.x*z.y-z.z*s,ic*z.z*z.x+z.y*s,\n\t\tic*z.x*z.y+z.z*s,ic*z.y*z.y+c,ic*z.y*z.z-z.x*s,\n\t\tic*z.z*z.x-z.y*s,ic*z.y*z.z+z.x*s,ic*z.z*z.z+c);\n}\nfloat plane(vec3 p,vec4 n){\n\tfloat d=dot(p,n.xyz)+n.w;\n\tif(d<0.0)mc=vec4(1.0);\n\treturn d;\n}\nfloat sphere(vec3 p,float r){\n\tvec4 c=vec4(1.0);\n\tvec3 tmp;\n\tvec2 rp=vec2(floor(p.x),floor(p.y));\n\tsrand(rp);\n\tc.r=rand()*0.2+0.2*sin(t/4.0+PI/4.0)+0.2;\n\tc.g=rand()*0.2+0.4*sin(t/3.0+PI/3.0)+0.2;\n\tc.b=rand()*0.2+0.2*sin(t/2.0)+0.3;\n\tfloat x=(fract(p.x)-0.5);\n\tfloat y=(fract(p.y)-0.5);\n\tfloat tmp2=rand();\n\tfloat z=rand()*5.0*(sin(t/2.0+tmp2*PI*2.0)+1.0);\n\ttmp=vec3(x,y,p.z-z);\n\tfloat d=length(tmp)-r;\n\tif(d<0.0)mc=c;\n\treturn min(d,0.1);\n}\nfloat dist(vec3 p){\n\tfloat d=100.0;\n\td=min(d,plane(p,vec4(0.0,0.0,1.0,0.5)));\n\td=min(d,sphere(p,0.5));\n\treturn d;\n}\nvec3 normal(vec3 p){\n\tfloat d=dist(p);\n\tvec3 n=vec3(0.01,0.0,0.0);\n\treturn normalize(vec3(dist(p+n.xyy)-d,dist(p+n.yxy)-d,dist(p+n.yyx)-d));\n}\nfloat trace_light(vec3 p,vec3 dv){\n\tfloat d;\n\tfloat a=1.0;\n\tfloat l=0.1;\n\tp+=dv*l;\n\tfor(int i=0;i<32;i++){\n\t\td=dist(p);\n\t\tif(d<0.01){\n\t\t\treturn 0.0;\n\t\t}\n\t\ta=min(a,2.0*d/l);\n\t\tl+=d;\n\t\tp+=dv*d;\n\t}\n\treturn a;\n}\nvec4 trace(vec3 p,vec3 dv){\n\tfloat d;\n\tfloat dt=0.0;\n\tvec3 lv;\n\tvec4 c;\n\tmc=vec4(1.0);\n\tfor(int i=0;i<256;i++){\n\t\td=dist(p);\n\t\tdt+=d;\n\t\tif(d<0.0)break;\n\t\td=max(d,0.01);\n\t\tp+=dv*d;\n\t}\n\tc=mc;\n\tvec3 n=normal(p);\n\tlv=normalize(lp-p);\n\tvec4 df=clamp(c*lc*dot(n,lv),0.0,1.0);\n\tvec4 ab=c*la;\t\n\tfloat sd=trace_light(p-0.01*dv,lv);\n\tfloat sp=max(pow(dot(lv,reflect(dv,n)),length(lp-p)),0.0);\n\treturn min(df,vec4(1.0)*sd)+ab+min(sd,sp);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tt=iTime;\n\tfloat r=iResolution.x/iResolution.y;\n\tfloat h=2.0;\n\tfloat fov=0.75;\n\tvec2 m=vec2((iMouse.x-iResolution.x/2.0)/iResolution.x*r,(iMouse.y-iResolution.y/2.0)/iResolution.y);\n\tvec2 sp=vec2((fragCoord.x-iResolution.x/2.0)/iResolution.x*r,(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n\t\n\tvec3 la=vec3(5.0*sin(t/2.0+PI),5.0*cos(t/3.0+PI),sin(t/4.0)+2.0);\n\tvec3 ep=vec3(2.0*sin(t),2.0*cos(t),sin(t)*2.0+6.0);\n\t\n\tsrand(sp);\n\tvec3 rv;\n\tfloat dof=0.2;\n\trv.x=(rand()-0.5)*dof;\n\trv.y=(rand()-0.5)*dof;\n\trv.z=(rand()-0.5)*dof;\n\tep+=rv;\n\t\n\t\n\t/*\n\tvec3 la=vec3(0.0,0.0,h);\n\tvec3 ep=vec3(0.0,-3.0,0.0);\n\tep*=rot_x(PI*m.y/2.0+PI/8.0-PI/4.0);\n\tep*=rot_z(2.0*PI*m.x);\n\tep.z+=h;\n\t*/\n\t\n\tvec3 uv=vec3(0.0,0.0,1.0);\n\tvec3 dv=normalize(la-ep);\n\tvec3 hv=normalize(cross(dv,uv));\n\tvec3 vv=normalize(cross(hv,dv));\n\tdv*=rot(vv,fov*sp.x);\n\tdv*=rot(hv,fov*sp.y);\n\tfragColor=trace(ep,dv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsB3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 149, 149, 193], [194, 194, 207, 207, 265], [266, 266, 286, 286, 366], [367, 367, 387, 387, 467], [468, 468, 488, 488, 568], [569, 569, 594, 594, 812], [813, 813, 840, 840, 904], [905, 905, 934, 934, 1344], [1345, 1345, 1364, 1364, 1460], [1461, 1461, 1481, 1481, 1603], [1604, 1604, 1638, 1638, 1811], [1812, 1812, 1839, 1839, 2240], [2241, 2241, 2297, 2297, 3169]], "test": "ok"}
{"id": "Msj3Wt", "name": "Dragoon", "author": "Nrx", "description": "Just a very basic shader, but which I found the result to be \"interesting\".", "tags": ["raymarching"], "likes": 18, "viewed": 710, "published": "Public API", "date": "1395302262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DELTA\t\t\t0.01\n#define RAY_LENGTH_MAX\t300.0\n#define RAY_STEP_MAX\t200\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p) {\n\tp += vec3 (3.0 * sin (p.z * 0.2 + iTime * 2.0), sin (p.z * 0.3 + iTime), 0.0);\n\treturn fixDistance (length (p.xy) - 4.0 + 0.8 * sin (abs (p.x * p.y) + p.z * 4.0) * sin (p.z), 2.5, 0.2);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((17.0 + 5.0 * sin (iTime)) * cos (iTime * 0.2), 12.0 * sin (iTime * 0.2), 0.0);\n\tvec3 forward = vec3 (-origin.x, -origin.y, 22.0 + 6.0 * cos (iTime * 0.2));\n\tvec3 up = vec3 (0.0, 1.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Ray marching\n\tvec3 p = origin;\n\tfloat dist = RAY_LENGTH_MAX;\n\tfloat rayLength = 0.0;\n\tint stepCount = 0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tdist = getDistance (p);\n\t\trayLength += dist;\n\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp = origin + direction * rayLength;\n\t\t++stepCount;\n\t}\n\n\t// Compute the fragment color\n\tvec4 color = vec4 (float (stepCount * 3) / float (RAY_STEP_MAX), float (stepCount) * 1.5 / float (RAY_STEP_MAX), 0.0, 1.0);\n\tvec3 LIGHT = normalize (vec3 (1.0, -3.0, -1.0));\n\tif (dist < DELTA) {\n\t\tvec2 h = vec2 (DELTA, 0.0);\n\t\tvec3 normal = normalize (vec3 (\n\t\t\tgetDistance (p + h.xyy) - getDistance (p - h.xyy),\n\t\t\tgetDistance (p + h.yxy) - getDistance (p - h.yxy),\n\t\t\tgetDistance (p + h.yyx) - getDistance (p - h.yyx)));\n\t\tcolor.rg += 0.5 * max (0.0, dot (normal, LIGHT));\n\t}\n\telse {\n\t\tcolor.b += 0.1 + 0.5 * max (0.0, dot (-direction, LIGHT));\n\t}\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msj3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 141, 141, 270], [272, 272, 303, 303, 492], [494, 494, 550, 601, 2081]], "test": "ok"}
{"id": "MsjGWK", "name": "future city mk2", "author": "Hodgman", "description": "Another version of https://www.shadertoy.com/view/Xdj3WV", "tags": ["cyberpunk"], "likes": 4, "viewed": 203, "published": "Public", "date": "1393724853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define ORBIT_CAM\n\n#define ITERATIONS 96\n#define SHADOW_ITERATIONS 8\n\n\nconst float streetWidth = 30.0;\nconst float blockWidth = 200.0;\nconst float totalBlock = blockWidth + streetWidth;\nconst float halfStreetWidth = streetWidth*0.5;\nconst float maxBlockHeight = 600.00;\n\n#define sat(x) clamp(x,0.0, 1.0)\n\nfloat linstep(float a, float b, float t){\n\tfloat v=(t-a)/(b-a);\n\treturn clamp(v,0.,1.);\n}\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat smoothstep2( float min1, float max1, float min2, float max2, float p )\n{\n\treturn smoothstep(min1, max1, p) * (1.0 - smoothstep(min2, max2, p));\n}\nfloat softstep( float min1, float p )\n{\n\treturn smoothstep(min1, min1+0.01, p);\n}\nfloat softstep2( float min1, float min2, float p )\n{\n\treturn softstep(min1, p) * (1.0 - softstep(min2, p));\n}\n\n\n\nfloat BlockDe( vec3 pos, float blockId, inout vec4 m )\n{\n\tif( blockId < 0.33 )\n\t\treturn 99999.9;\n\tfloat h = blockId;\n\t\n\th = maxBlockHeight*0.01 + h*maxBlockHeight*0.99;\n\th *= 0.5;\n\t\n\tfloat wScale = fract(blockId+0.5);\n\t\n\tfloat w = blockWidth*0.5;\n\tfloat xz = w*0.6 + w*0.4*wScale;\n\t\n\tpos.xz -= totalBlock*0.5;\n\t\n\tfloat bulk = sdBox( pos - vec3(0,h,0), vec3(xz,h,xz) );\n\tfloat de = bulk;\n\t\n\tfloat bounds = sdBox( pos - vec3(0,h+1.0,0), vec3(xz+2.0,h+2.0,xz+2.0) );\n\t\n\tfloat bands;\n\t{\n\t\tvec3 p = pos;\n\t\tfloat addHeight = 10.0;\n\t\tp.y += 2.0;\n\t\tfloat r = addHeight + addHeight + 20.0 * (fract(1.3-blockId*7.0));\n\t\tp.y = mod(p.y,r);//-0.5*r;\n\t\txz = xz+1.0*wScale;\n\t\tbands = sdBox(p, vec3(xz, addHeight, xz));\n\t\tbands = max(bands,bounds);\n\t\tde = smin( de, bands, 10.0 );\n\t}\n\t\n\tfloat base;\n\t{\n\t\tfloat baseW = w*0.9 + w*0.1*wScale;\n\t\tfloat baseH = 0.1 + 4.0 * blockId;\n\t\tbase = sdBox( pos - vec3(0,baseH,0), vec3(baseW,baseH,baseW) );\n\t\tde = min(de,base);\n\t}\n\t\n\t\n\tfloat alpha = clamp((bulk-bands)*100.0,0.0,1.0);\n\tm = mix( vec4(1,0,0,0), vec4(0,1,0,0), alpha );\n\talpha = clamp((base-bulk+2.0)*10000.0,0.0,1.0);\n\tm = mix( vec4(0,0,1,0), m, alpha );\n\t\n\treturn de;\n}\nfloat BlockId( vec2 pos )\n{\n\t//return 1.0;\n\treturn rand(floor(pos/totalBlock));\n}\n//close to the surface of a building\nfloat DeN( vec3 pos )\n{\n\tfloat blockId1 = BlockId(pos.xz);\n\tpos.x = mod(pos.x,totalBlock);\n\tpos.z = mod(pos.z,totalBlock);\n\tvec4 m = vec4(0);\n\treturn BlockDe(pos, blockId1, m);\n}\n//within city volume\nfloat DeWithin( vec3 pos, vec3 rd, out float maxStep, inout vec4 m )\n{\n\tfloat startBlockX = floor((pos.x)/totalBlock);\n\tfloat startBlockZ = floor((pos.z)/totalBlock);\n\tfloat xDir = rd.x > 0.0 ? 1.0 : -1.0;\n\tfloat zDir = rd.z > 0.0 ? 1.0 : -1.0;\n\tvec3 p1N = normalize(vec3(-1,0,0));\n\tvec3 p2N = normalize(vec3(0,0,-1));\n\tfloat p1Offs = rd.x > 0.0 ? (startBlockX+1.0)*totalBlock : (startBlockX)*totalBlock;\n\tfloat p2Offs = rd.z > 0.0 ? (startBlockZ+1.0)*totalBlock : (startBlockZ)*totalBlock;\n\tfloat e1 = -(dot(p1N,pos) + p1Offs) / (dot(p1N, rd));\n\tfloat e2 = -(dot(p2N,pos) + p2Offs) / (dot(p2N, rd));\n\tmaxStep = min(e1,e2);\n\t\n\tfloat blockId1 = BlockId(pos.xz);\n\tpos.x = mod(pos.x,totalBlock);\n\tpos.z = mod(pos.z,totalBlock);\n\treturn BlockDe(pos, blockId1, m);\n}\n//above city volume\nfloat DeAbove( vec3 pos, vec3 rd, out float maxStep, inout vec4 m )\n{\n\tfloat de;\n\tif( pos.y > maxBlockHeight+0.1 )\n\t{//if ray is above buildings, continue until you're at roof height\n\t\tde = (pos.y-maxBlockHeight) / (abs(rd.y));\n\t\tde = max(de, 0.1);\n\t}\n\telse\n\t{\n\t\treturn DeWithin(pos, rd, maxStep, m);\n\t\t//return DeN(pos);\n\t}\n\treturn maxStep=de;\n}\n\n\nvec3 CalcNormal(vec3 p, float rCoC)\n{\n\trCoC = 0.001;\n\tvec2 v=vec2(0.5*rCoC,0.0);\n\treturn normalize(vec3(-DeN(p-v.xyy)+DeN(p+v.xyy),-DeN(p-v.yxy)+DeN(p+v.yxy),-DeN(p-v.yyx)+DeN(p+v.yyx)));\n}\n\nvec2 GetUv(vec3 N0, vec3 hit0)\n{\n\tN0 = abs(N0);\n\treturn N0.x > N0.y\n\t\t? (N0.z > N0.x ? hit0.xy : hit0.zy)\n\t\t: (N0.z > N0.y ? hit0.xy : hit0.xz);\n}\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n\tconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n\tconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nvec3 DoLighting( vec3 pos, vec3 V, vec3 N, vec3 color, vec2 fragCoord )\n{\n\tfloat specular = 0.0;\n\tfloat diffuse = 0.0;\n\t\n\tvec3 ambientL = normalize(vec3(-1,2,1));\n\tvec3 ambientH = normalize(ambientL + V);\n\t\n\tvec3 L = ambientL;\n\tfloat shadow = 0.0;\n\tfloat t = 1.0;\n\tpos += N*1.0;\n\t//pos += V*1.0;\n\tfor(int i=1;i<SHADOW_ITERATIONS;i++){//march loop\n\t\t\n\t\tvec3 p = pos+L*t;\n\t\tfloat rCoC;\n\t\t\n\t\tfloat maxStep = 9999999.0;\n\t\tvec4 c = vec4(0);\n\t\tfloat de=DeWithin( p, L, maxStep, c );// +0.25*rCoC;\n\t\t\n\t\trCoC = (100.0 - 100.0/(t*0.02));\n\t\tif(de<rCoC){\n\t\t\tshadow += (1.0-sat(de/rCoC))*sat(45.0/t);\n\t\t}\n\t\t\n\t\tde = max( de * 2.0, 10.0 );\n\t\tde = min(de,maxStep);\n\t\tde += 1.0*rand(fragCoord.xy*vec2(i));\n\t\tt += de;\n\t}\n\tshadow = 1.0-sat(shadow)*0.55;\n\t\n\tdiffuse += (dot(N,ambientL)*0.5+0.5) * shadow;\n\tspecular += sat(dot(N,ambientL))* pow(sat(dot(N,ambientH)), 10.0) * shadow;\n\t\n\t//return vec3(shadow);\n\t\n\tfloat specMask = sat(1.0-dot(vec3(1./3.), color));\n\treturn diffuse * color + specular * specMask;\n}\n\nvec3 _RoadTexture(vec3 pos)\n{\n\tfloat f = abs(sin(pos.x*10.0))*abs(sin(pos.z*12.0));\n\tvec3 road = mix(vec3(0.10,0.12,0.13), vec3(0.13,0.1,0.08), f);\n\t\n\tvec2 xz = abs(mod(pos.xz, totalBlock)-totalBlock*0.5)-blockWidth*0.5;\n\txz /= halfStreetWidth;\n\t\n\tconst float lineWidth = 0.1;\n\tconst float lnpcnt = 0.5*lineWidth/halfStreetWidth;\n\tvec3 paint = vec3(0.5,0.5,0.4);\n\tfloat lane;\n\t\n\troad = mix(road, paint, softstep(1.0-lnpcnt*5.0,xz.x) );\n\tlane = 3.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 6.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 9.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 12.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt*5.0, 1.0-lane+lnpcnt*5.0, xz.x) );\n\t\n\troad = mix(road, paint, softstep(1.0-lnpcnt*5.0,xz.y) );\n\tlane = 3.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 6.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 9.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 12.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt*5.0, 1.0-lane+lnpcnt*5.0, xz.y) );\n\treturn road;\n}\nvec3 RoadTexture(vec3 uvw)\n{\n\tvec3 ddx_uvw = uvw + dFdx(uvw);\n\tvec3 ddy_uvw = uvw + dFdy(uvw);\n\t\n\tfloat detail = 1.0;\n\tconst int MaxSamples = 4;\n\t\n    int sx = 1 + int( clamp( 4.0*length(ddx_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n    int sy = 1 + int( clamp( 4.0*length(ddy_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n\n\tvec3 no = vec3(0.0);\n\n    for( int j=0; j<MaxSamples; j++ )\n    for( int i=0; i<MaxSamples; i++ )\n    {\n        if( j<sy && i<sx )\n        {\n            vec2 st = vec2( float(i), float(j) ) / vec2( float(sx),float(sy) );\n            no += _RoadTexture( uvw + st.x*(ddx_uvw-uvw) + st.y*(ddy_uvw-uvw) );\n        }\n    }\n\n    return no / float(sx*sy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n#ifdef ORBIT_CAM\n\tvec3 ro = vec3(sin(time*0.5)*1000.0, 1000, cos(time*0.5)*1000.0);\n\tvec3 ta = vec3(0, (sin(time)*0.5+0.5)*200.0, 0);\n#else\n\tvec3 ro = vec3(pow(sin(time*0.5),3.0)*5.0+6.0, 1.4, time*100.0);\n\tvec3 ta = ro + vec3(sin(time*0.8)*3.0,(sin(time)*0.5+0.5)*2.0,10);\n#endif\n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.0*cw );\n\t\n\tfloat distToGround = - (dot(vec3(0,1,0),ro) + 0.0) / (dot(vec3(0,1,0), rd));\n\tdistToGround = distToGround < 0.0 ? 999999.0 : distToGround;\n\t\n\tvec3 N = vec3(0,0.000001,0);\n\tfloat coverage = 0.0;\n\tvec4 material = vec4(0.001, 0, 0, 0);\n\tfloat t=0.0;//distance traveled\n\t//float didHit = 0.0;\n\tfor(int i=0;i<ITERATIONS;i++){//march loop\n\t\tif( t >= distToGround || coverage > 0.99 ) continue;\n\t\t\n\t\tvec3 pos = ro+rd*t;\n\t\t\n\t\tfloat rCoC=0.0001;\n\t\t\n\t\tfloat maxStep = 999999.0;\n\t\tfloat de=DeAbove( pos, rd, maxStep, material ) +0.25*rCoC;\n\t\t\n\t\tif(de<rCoC){\n\t\t\tN = CalcNormal(pos, rCoC);\n\t\t\tcoverage = 1.0;\n\t\t}\n\t\t\n\t//\tde = abs(de)*(0.5+0.5*rand(fragCoord.xy*vec2(i)));\n\t\tde = min(de, maxStep+halfStreetWidth);\n\n\t\tt += de;\n\t}\n\t\n\tt = min(t,abs(distToGround));\n\tvec3 pos = ro + rd*t;\n\t\n//\t\tcol += vec3(0.5,.5,1.0) * (sin(pos.y*0.5)*0.25+0.75) * bgAlpha;\n\t\n\t//vec3 N = normalize(avgN);\n\tN = normalize(N);\t\n\t\n\tvec3 _mtl0 = vec3(0.34, 0.40, 0.24);\n\tvec3 _mtl1 = vec3(0.38, 0.54, 0.51);\n\tvec3 _mtl2 = vec3(0.38, 0.40, 0.61);\n\tvec3 _mtl3 = vec3(0.03, 0.42, 0.64);\n\t\n\tfloat id = BlockId(pos.xz);\n\t\n\tvec3 mtl0 = mix(_mtl0, _mtl1, fract(id*2.0));\n\t     mtl0 = mix( mtl0, _mtl3, fract(id*2.0+1.0));\n\tvec3 mtl1 = mix(_mtl1, _mtl2, fract(id*4.0+0.4));\n\t     mtl1 = mix( mtl1, _mtl0, fract(id*1.0+0.3));\n\tvec3 mtl2 = mix(_mtl2, _mtl3, fract(id*2.0+0.7));\n\t     mtl2 = mix( mtl2,  mtl1, fract(id*0.1+0.7));\n\tvec3 mtl3 = mix(_mtl3, _mtl0, fract(id*8.0+0.6));\n\t     mtl3 = mix( mtl3, _mtl1, fract(id*0.5+0.6));\n\t\n\t\n\tvec3 col = vec3(0);\n\t\n\tif( pos.y < 0.01 )\n\t{\n\t\tmtl3 = RoadTexture(pos);\n\t\tmaterial = vec4(0,0,0,1);\n\t\tN = vec3(0,1,0);\n\t\tcoverage = 1.0;\n\t}\n//\telse if( rd.y > 0.0 && t > 1000.0 )\n//\telse if( rd.y > 0.0 && pos.y >= maxBlockHeight-1.1 )\n\telse if( pos.y >= maxBlockHeight-10.1 )\n\t{\n\t\tvec3 sky = mix( vec3(.17, .13, .3), vec3(.1, .13, .47), rd.y );\n\t\tcol = sky;\n\t\tcoverage = 0.0;\n\t}\n\telse if( coverage < 1.0 )\n\t{\n\t\tfloat rCoC=0.01;\n\t\tN = CalcNormal(pos, rCoC);\n\t\tcoverage = 1.0;\n\t}\n\t\n\t\t\t\n\tvec2 uv = GetUv(N, pos.xyz);\n\t\n\tmaterial /= dot(vec4(1),material);\n\tvec3 mtlCol = mtl0 * material.x\n\t            + mtl1 * material.y\n\t            + mtl2 * material.z\n\t            + mtl3 * material.w;\n\tmtlCol *= (fbm4(uv*0.041)*0.25+0.75) * vec3(1);\n\t\n\tif( coverage > 0.0 )\n\t{\n\t\tvec3 V = -normalize(pos - ro);\n\t\tcol.rgb += DoLighting( pos, V, N, mtlCol, fragCoord )*2.0;\n\t}\n\t\n\tif( fragCoord.x > iMouse.x )\n\t{\n\t\tfloat crush = 0.1;\n\t\tfloat frange = 12.0;\n\t\tfloat exposure = 256.0;\n\t\tcol = log2(1.0+col*exposure);\n\t\tcol = smoothstep(crush, frange, col);\n\t\tcol = col*col*col*(col*(col*6.0 - 15.0) + 10.0);\n\t\tcol = pow(col, vec3(2.2));\n\t}\n\t\n//\tcol = mix( col, vec3(1,0,0), coverage>0.0?0.0:1.0 );\n\tfragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsjGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 307, 348, 348, 396], [397, 397, 417, 488, 559], [561, 561, 602, 602, 695], [696, 696, 741, 741, 781], [782, 782, 813, 813, 851], [852, 852, 883, 883, 979], [980, 980, 1058, 1058, 1131], [1132, 1132, 1171, 1171, 1213], [1214, 1214, 1266, 1266, 1323], [1327, 1327, 1383, 1383, 2482], [2483, 2483, 2510, 2525, 2564], [2565, 2602, 2625, 2625, 2780], [2781, 2802, 2872, 2872, 3563], [3564, 3584, 3653, 3653, 3930], [3933, 3933, 3970, 3970, 4122], [4124, 4124, 4156, 4156, 4270], [4272, 4272, 4298, 4298, 4335], [4337, 4337, 4359, 4359, 4606], [4608, 4608, 4630, 4630, 5034], [5037, 5037, 5110, 5110, 6028], [6030, 6030, 6059, 6059, 7415], [7416, 7416, 7444, 7444, 8083], [8085, 8085, 8142, 8142, 11431]], "test": "ok"}
{"id": "MssSzr", "name": "Something trippy", "author": "Panoptics", "description": "CEV floaters", "tags": ["noise"], "likes": 1, "viewed": 154, "published": "Public", "date": "1396237747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// math const\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvec3 calcOrder( vec3 dir )\n{\n    int signs;\n\n    bool  sx = dir.x<0.0;\n    bool  sy = dir.y<0.0;\n    bool  sz = dir.z<0.0;\n    float ax = abs( dir.x );\n    float ay = abs( dir.y );\n    float az = abs( dir.z );\n\n    if( ax>ay && ax>az )\n        {\n        if( ay>az )\n            return vec3(0.0,0.5,0.0);\n        else\n        \treturn vec3(0.5,1.0,0.0);\n        }\n    else if( ay>ax && ay>az )\n        {\n        if( ax>az )\n        \treturn vec3(0.0,1.0,0.4);\n        else\n             return vec3(0.0,1.0,1.0);\n        }\n    else\n        {\n        if( ax>ay )\n             return vec3(1.0,1.0,0.0);\n        else\n             return vec3(1.0,0.0,1.0);\n        }\n\n    \n}\n// pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat hash( float n ) { return fract(sin(n)*458.5453123); }\nfloat noise( in vec3 x )\n{\n\tfloat modifier = sin(iTime/34.0)+10.0;\n    vec3 p = floor(x*modifier);\n    vec3 f = fract(x*modifier);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 dir = ray_dir( 90.0, iResolution.xy, fragCoord.xy );\n\tmat3 rot = rot3xy(-iMouse.yx/32.0);\n\tdir = rot*dir;\n\tvec4 albedo = vec4(  mod(cos(iTime/3.33),noise(dir+iTime)),mod(cos(iTime/34.6),noise(dir+iTime/40.0))+cos(iTime)/2.0,mod(cos(iTime/3.33),noise(dir+iTime/6.34)),1.0);\n\tvec4 contrast = vec4(  mod(cos(iTime/37.33),noise(dir+iTime/400.0)),mod(cos(iTime/34.6),noise(dir+iTime/40.0))+cos(iTime)/2.0,mod(cos(iTime/3.33),noise(dir+iTime/6.34)),1.0);\n\tif (contrast.x >.2){\n\tfragColor = mix(albedo, contrast,cos(iTime)/5.5);\n\t}else{\n\t\tfragColor = mix(albedo, contrast,sin(iTime)*5.5);\n\t}\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 84, 132, 132, 308], [310, 310, 338, 338, 976], [977, 991, 1018, 1018, 1174], [1176, 1176, 1199, 1199, 1235], [1236, 1236, 1262, 1262, 1689], [1691, 1691, 1748, 1748, 2383]], "test": "ok"}
{"id": "MssXRr", "name": "Tuhkamaa Shadertoy version", "author": "Branch", "description": "Shadertoy version of our Instanssi 2014 4k intro called \"Tuhkamaa\" which means \"Ashyard\" or \"Ashland\" in finnish. \"Tuhkamaa\" won the 4k compo. Full version with noby's music here: http://branch.untergrund.net/online/intros/tuhkamaa/windo.htm", "tags": ["tuhkamaa", "typographicy", "constructivism", "minimalism"], "likes": 3, "viewed": 586, "published": "Public", "date": "1396212151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float RR(vec2 uv){\n    return fract(cos(dot(uv ,vec2(11.954626276298,71.236333))) * 43718.54763);\n}\nfloat raster(vec2 uv){\n\tvec2 oxide=mod(uv, vec2(0.1));\n\tif(oxide.x>0.08 && oxide.y>0.08)\n\t\treturn 1.0;\n\telse\n\t\treturn 0.0;\n}\nvec4 ball(vec2 uv, vec2 pos, float size, vec4 color_border, vec4 color_inside){\n\tfloat dist=distance(uv,pos);\n\tif(dist>size && dist<(size+size*0.35))\n\t\treturn color_border;\n\telse if(dist<size)\n\t\treturn color_inside;\n\telse\n\t\treturn vec4(-1.0);\n}\nvec4 rectangle(vec2 uv, vec2 pos, vec2 mins, vec2 maxs, vec4 c){\n\tif(uv.x>(pos.x+mins.x) && \n\t   uv.y>(pos.y+mins.y) && \n\t   uv.x<(pos.x+maxs.x) && \n\t   uv.y<(pos.y+maxs.y))\n\t\treturn c;\n\treturn vec4(-1.0);\n}\n\nfloat line(vec2 p1, vec2 p2, vec2 uv, float thick) {\n\n  float vA= abs(distance(p1, uv));\n  float vB= abs(distance(p2, uv));\n  float vC= abs(distance(p1, p2));\n\n  if ( vA>= vC|| vB>=  vC) return 0.0;\n\n  float p = (vA+ vB+ vC) * 0.5;\n  float h = (2.0 / vC) * sqrt( p * ( p - vA) * ( p - vB) * ( p - vC));\n  return mix(1.0, 0.0, smoothstep(0.5 * thick, 1.5 * thick, h));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 start=vec2(0.0,3.0);\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tfloat aspectCorrection=(iResolution.x/iResolution.y);\n\tvec2 coordinate_entered=2.0*uv-1.0;\n\tvec2 coord=vec2(aspectCorrection,1.0) *coordinate_entered;\n\tvec2 rcoord=coord;\n\tvec4 end=vec4(0.0);\n\tcoord.y+=min(iTime,10.0)*0.15;\n\tcoord*=1.2+min(max(iTime-10.0,0.0),16.0)*0.16;\n\tfloat rytmi=floor(iTime*(80.0/60.0));\n\t/*vec4 result=rectangle(coord, vec2(0.0), vec2(-0.06,-0.1), vec2(0.06,min(0.1+iTime*0.09,1.0)), vec4(0.3, 0.38, 0.3, 1.0));\n\t\tif(result.x>=0.0)\n\t\t\tend=result;*/\n\tvec4 result=vec4(0.0);\n\t\n\t\tfor(float i=0.0; i<3.0; i+=0.081){\n\t\tfloat music=0.0; //texture(iChannel0,vec2(0.6+i*0.06)).x-0.16;\n\t\tmusic*=music;\n\t\tvec2 position=vec2((RR(vec2(i,7.0))*2.0-1.0)*mod(iTime*0.6+i,3.0), mod(iTime*0.6+i,3.0)-1.5);\n\t\tfloat size=min((0.08+RR(vec2(i,0.0))*0.11)*mod(iTime*0.6+i,3.0),1.3);\n\t\tfloat kerroin=sin(i)*0.07;\n\t\tvec4 color_border=vec4(0.47+kerroin, 0.29, 0.28, 1.0);\n\t\tvec4 color_inside=vec4(0.7+music, 0.53+kerroin+music, 0.3+kerroin+music, 1.0);\n\t\tvec4 result=ball(rcoord, position, size, color_border, color_inside);\n\t\tif(result.x>=0.0)\n\t\t\tend=result;\n\t}\n\tfloat rr=floor(iTime*(80.0/60.0));\n\tfor(float j=-4.0; j<6.0; j++)\n\tfor(float i=-8.0; i<-2.0; i++){\n\t\tif(mod(i+j+1000.0*RR(vec2(i,j+rr)*4.0),5.0)<2.0){\n\t\t\tvec4 result=rectangle(rcoord, vec2(i*0.2,j*0.2), vec2(-0.05), vec2(0.1), vec4(0.01));\n\t\t\tif(result.x>=0.0)\n\t\t\t\tend+=result;\n\t\t} \n\t}\n\t\n\t\n\tfloat r=line(vec2(0.0, 0.0),min(iTime*0.1,1.0)*start, coord, 0.02);\n\tif(r>0.0)\n\t\tend=vec4(1.0);\n\t\n\tfor(float i=0.0; i<64.0; i++){\n\t\tvec2 pos=start+vec2(RR(vec2(5.0,i))*10.0-5.0, -5.0+mod(RR(vec2(3.0,i))*15.0+iTime*1.0,15.0));\n\t\tresult=rectangle(coord, pos, vec2(-0.1), vec2(0.1), vec4(0.1));\n\t\tif(result.x>=0.0)\n\t\t\tend=result;\n\t}\n\t\n\tfor(float i=0.0; i<3.141*2.0; i+=0.3){\n\t\tvec2 posi=start+(0.5+0.13*sin(i*i*i+iTime))*max(min(iTime-15.0, 5.3),0.0)*vec2(cos(i), sin(i));\n\t\tfloat r=line(posi,start, coord, 0.014);\n\t\tif(r>0.0)\n\t\t\tend=vec4(1.0);\n\t\t\n\t\tresult=ball(coord, posi, max(min(iTime-15.0, 20.0)*(0.014+0.0063*sin(i*i*i+iTime)),0.0), vec4(0.4, 0.01, 0.01, 1.0), vec4(0.25, 0.16, 0.16, 1.0));\n\t\tif(result.x>=0.0)\n\t\t\tend=result;\n\t}\n\t\n\tresult=ball(coord, start, max(min(iTime-10.0, 8.0),0.0)*0.17, vec4(0.5, 0.11, 0.01, 1.0), vec4(0.25, 0.16, 0.16, 1.0));\n\tif(result.x>=0.0)\n\t\tend=result;\n\n\t\n\tif(end.x==0.0)\n\t\tend=vec4(0.39*uv.y, 0.39*uv.y, 0.37*uv.y,1.0);\n\tfragColor=(end+vec4(-0.02+RR(uv*iTime)*0.04))*(1.62-length(rcoord));\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 99], [100, 100, 122, 122, 224], [225, 225, 304, 304, 469], [470, 470, 534, 534, 677], [679, 679, 731, 731, 1048], [1049, 1049, 1106, 1106, 3554]], "test": "ok"}
{"id": "MsXSzn", "name": "Point Based Global Illumination", "author": "XT95", "description": "An approximation of global illumination (noise free) by a disk to disk approach.\nDistance field is only used to show the cornell box, not to compute the GI.\n", "tags": ["raymarching", "gi", "globalillumination", "ambientocclusion", "pointbased", "surfel"], "likes": 31, "viewed": 3684, "published": "Public API", "date": "1395714295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by anatole duprat - XT95/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Papers :\n// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter14.html\n// http://graphics.pixar.com/library/PointBasedColorBleeding/paper.pdf\n// http://graphics.pixar.com/library/PointBasedGlobalIlluminationForMovieProduction/paper.pdf\n\n\n\nstruct Surfel\n{\n\tvec3 pos,n,col;\n\tfloat area;\n};\n\t\n#define NBSURFEL 18\nSurfel surfel[NBSURFEL];\nvoid generateSurfelsList();\n\n\n\n//Maths\nconst float PI = 3.14159265359;\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\nmat3 lookat( in vec3 fw, in vec3 up )\n{\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\nfloat occ( float cosE, float cosR, float a, float d) // Element to element occlusion\n{\n\treturn ( clamp(cosE,0.,1.) * clamp(4.*cosR,0.,1.) ) / sqrt( a/PI + d*d );\n}\nfloat radiance( float cosE, float cosR, float a, float d) // Element to element radiance transfer\n{\n\treturn (a * max(cosE,0.) * max(cosR,0.) ) / ( PI*d*d + a );\n}\n\n//Raymarching \nfloat map( in vec3 p );\nfloat box( in vec3 p, in vec3 data )\n{\n    return max(max(abs(p.x)-data.x,abs(p.y)-data.y),abs(p.z)-data.z);\n}\nvec4 raymarche( in vec3 org, in vec3 dir, in vec2 nfplane )\n{\n\tfloat d = 1.0, g = 0.0, t = 0.0;\n\tvec3 p = org+dir*nfplane.x;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( d > 0.001 && t < nfplane.y )\n\t\t{\n\t\t\td = map(p);\n\t\t\tt += d;\n\t\t\tp += d * dir;\n\t\t\tg += 1./64.;\n\t\t}\n\t}\n\t\n\treturn vec4(p,g);\n}\nvec3 normal( in vec3 p )\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n\t\tmap(p+eps.yyx)-map(p-eps.yyx)\n\t) );\n}\n\n\n\n//Geometry\nfloat map( in vec3 p )\n{\n\tfloat d = -box(p-vec3(0.,10.,0.),vec3(10.));\n\td = min(d, box(rotate(vec3(0.,1.,0.), 0.)*(p-vec3(4.,5.,6.)), vec3(3.,5.,3.)) );\n\td = min(d, box(rotate(vec3(0.,1.,0.), 0.)*(p-vec3(-4.,2.,0.)), vec3(2.)) );\n\td = max(d, -p.z-9.);\n\t\n\treturn d;\n}\n\n\n\n//Shading\nvec3 shade( in vec4 p, in vec3 n, in vec3 org, in vec3 dir )\n{\t\t\n\t//wall color\n\tvec3 amb = vec3(.5);\n\tif(p.x<-9.999)\n\t\tamb = vec3(1.,0.,0.);\n\telse if(p.x>9.999)\n\t\tamb = vec3(.0,0.,1.);\n\telse\n\t\tamb = vec3(1);\n\t\t\n\t\n\t//computing GI and ambient occlusion with the surfels\n\tvec3 gi = vec3(0.);\n\tvec3 glossy = vec3(0.);\n\tfloat ao = 0.;\n\tfor(int i=0; i<NBSURFEL; i++)\n\t{\n\t\tvec3 v = surfel[i].pos - p.xyz; // recever to emitter vector\n\t\tfloat d = length( v );\n\t\tv = normalize( v );\n\t\t\n\t\tfloat cosE = dot( -v, surfel[i].n );\n\t\tfloat cosR = dot( v, n );\n\t\tfloat cosR2 = dot( v, reflect(dir,n));\n\t\t\n\t\tgi += surfel[i].col * radiance( cosE, cosR, surfel[i].area, d);\n\t\tglossy += surfel[i].col * radiance( cosE, cosR2, surfel[i].area, d);\n\t\t\n\t\tao += occ( cosE, cosR, surfel[i].area, d);\n\t}\n    ao = exp(-ao)*ao;\n\tvec3 col = ( amb*ao + gi + glossy ) ;\n\t\n\treturn col;\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tgenerateSurfelsList();\n\t\n\n\t//screen coords\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//camera ray\n\tfloat ctime = (iTime)*.25;\n\tvec3 org = vec3( cos(ctime)*5.,10.+cos(ctime*.5)*3.,-13.+sin(ctime) );\n\tvec3 dir = normalize( vec3(v.x, v.y, 1.5) );\n\tdir = lookat( -org + vec3(0., 5., 0.), vec3(0., 1., 0.) ) * dir;\n\t\n\t//classic raymarching by distance field\n\tvec4 p = raymarche(org, dir, vec2(1., 30.) );\n\tvec3 n = normal(p.xyz);\n\tvec3 col = shade(p, n, org, dir);\n\t\n\t\n\tfragColor = vec4( col, 1. );\n}\n\n\n\n// -- Must be pre-computed on CPU with more precision --\nvoid generateSurfelsList()\n{\n\t//cornell box\n\tsurfel[0].pos = vec3( 10., 10.,  0.); surfel[0].n = vec3(-1., 0., 0.); surfel[0].area = 100.; surfel[0].col = vec3(.0,.0,2.);\n\tsurfel[1].pos = vec3(-10., 10.,  0.); surfel[1].n = vec3( 1., 0., 0.); surfel[1].area = 100.; surfel[1].col = vec3(2.,.0,0.);\n\tsurfel[2].pos = vec3(  0., 10., 10.); surfel[2].n = vec3( 0., 0.,-1.); surfel[2].area = 100.; surfel[2].col = vec3(.0);\n\tsurfel[3].pos = vec3(  0., 20.,  0.); surfel[3].n = vec3( 0.,-1., 0.); surfel[3].area = 100.; surfel[3].col = vec3(.0);\n\tsurfel[4].pos = vec3(  0.,  0.,  0.); surfel[4].n = vec3( 0., 1., 0.); surfel[4].area = 100.; surfel[4].col = vec3(.0);\n\tsurfel[5].pos = vec3(  0., 10.,-10.); surfel[5].n = vec3( 0., 0., 1.); surfel[5].area = 100.; surfel[5].col = vec3(.0);\n\t\n\t//big cube\n\tsurfel[6].pos = vec3(  4.,  0., 6.); surfel[6].n = vec3( 0., 1., 0.); surfel[6].area = 9.; surfel[6].col = vec3(.0);\n\tsurfel[7].pos = vec3(  4., 10., 6.); surfel[7].n = vec3( 0.,-1., 0.); surfel[7].area = 9.; surfel[7].col = vec3(.0);\n\tsurfel[8].pos = vec3(  7.,  5., 6.); surfel[8].n = vec3( 1., 0., 0.); surfel[8].area = 9.; surfel[8].col = vec3(.0);\n\tsurfel[9].pos = vec3(  1.,  5., 6.); surfel[9].n = vec3(-1., 0., 0.); surfel[9].area = 9.; surfel[9].col = vec3(.0);\n\tsurfel[10].pos = vec3(  4.,  5., 3.); surfel[10].n = vec3( 0., 0., -1); surfel[10].area = 9.; surfel[10].col = vec3(.0);\n\tsurfel[11].pos = vec3(  4.,  5., 9.); surfel[11].n = vec3( 0., 0.,  1); surfel[11].area = 9.; surfel[11].col = vec3(.0);\n\t\n\t//small cube\n\tsurfel[12].pos = vec3( -4.,  0., 0.); surfel[12].n = vec3( 0., 1., 0.); surfel[12].area = 4.; surfel[12].col = vec3(.0);\n\tsurfel[13].pos = vec3( -4., 2., 0.); surfel[13].n = vec3( 0.,-1., 0.); surfel[13].area = 4.; surfel[13].col = vec3(.0);\n\tsurfel[14].pos = vec3( -2.,  1., 0.); surfel[14].n = vec3( 1., 0., 0.); surfel[14].area = 4.; surfel[14].col = vec3(.0);\n\tsurfel[15].pos = vec3( -6.,  1., 0.); surfel[15].n = vec3(-1., 0., 0.); surfel[15].area = 4.; surfel[15].col = vec3(.0);\n\tsurfel[16].pos = vec3( -4.,  1., -2.); surfel[16].n = vec3( 0., 0., -1); surfel[16].area = 4.; surfel[16].col = vec3(.0);\n\tsurfel[17].pos = vec3( -4.,  1., 2.); surfel[17].n = vec3( 0., 0.,  1); surfel[17].area = 4.; surfel[17].col = vec3(.0);\n\t\n\n}\t\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXSzn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[505, 545, 586, 586, 954], [955, 955, 994, 994, 1106], [1107, 1107, 1193, 1193, 1270], [1271, 1271, 1370, 1370, 1433], [1435, 1474, 1512, 1512, 1584], [1585, 1585, 1646, 1646, 1867], [1868, 1868, 1894, 1894, 2060], [2064, 2075, 2099, 2099, 2341], [2345, 2355, 2417, 2433, 3208], [3210, 3217, 3274, 3274, 3830], [3834, 3891, 3919, 3934, 6155]], "test": "error"}
{"id": "MsXXzn", "name": "Rolling Colorful Circle", "author": "MikeCAT", "description": "This shader draws a rolling colorful circle.", "tags": ["2d", "hsv"], "likes": 3, "viewed": 436, "published": "Public", "date": "1395743286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hsv2rgb(float h,float s,float v) {\n\tconst float eps=1e-3;\n\tvec4 result=vec4(0.0, 0.0, 0.0, 1.0);\n\tif(s<=0.0)result.r=result.g=result.b=v;\n\telse {\n\t\tfloat hi=floor(h/60.0);\n\t\tfloat f=(h/60.0)-hi;\n\t\tfloat m=v*(1.0-s);\n\t\tfloat n=v*(1.0-s*f);\n\t\tfloat k=v*(1.0-s*(1.0-f));\n\t\tif(hi<=0.0+eps) {\n\t\t\tresult.r=v;\n\t\t\tresult.g=k;\n\t\t\tresult.b=m;\n\t\t} else if(hi<=1.0+eps) {\n\t\t\tresult.r=n;\n\t\t\tresult.g=v;\n\t\t\tresult.b=m;\n\t\t} else if(hi<=2.0+eps) {\n\t\t\tresult.r=m;\n\t\t\tresult.g=v;\n\t\t\tresult.b=k;\n\t\t} else if(hi<=3.0+eps) {\n\t\t\tresult.r=m;\n\t\t\tresult.g=n;\n\t\t\tresult.b=v;\n\t\t} else if(hi<=4.0+eps) {\n\t\t\tresult.r=k;\n\t\t\tresult.g=m;\n\t\t\tresult.b=v;\n\t\t} else if(hi<=5.0+eps) {\n\t\t\tresult.r=v;\n\t\t\tresult.g=m;\n\t\t\tresult.b=n;\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tconst float pi=3.1415926535897932384626433832795028841;\n\tvec2 nowCoord=(fragCoord.xy/iResolution.xy)-vec2(0.5,0.5);\n\tif(iResolution.x>iResolution.y) {\n\t\tnowCoord.x*=iResolution.x/iResolution.y;\n\t} else {\n\t\tnowCoord.y*=iResolution.y/iResolution.x;\n\t}\n\tfloat tmp=length(nowCoord)/0.5;\n\tfloat angle=atan(nowCoord.y,nowCoord.x)*180.0/pi;\n\tangle+=mod(iTime*270.0,360.0);\n\tif(angle<0.0)angle+=360.0;\n\tangle=mod(angle,360.0);\n\tif(tmp>1.0) {\n\t\tfragColor=vec4(0.0, 0.0, 0.0, 1.0);\n\t} else {\n\t\tfragColor=hsv2rgb(\n\t\t\tangle,\n\t\t\t1.0,\n\t\t\ttmp<=1.0?sin(tmp*pi/2.0):0.0);\n\t\tfragColor.rgb*=tmp<0.99?1.0:sin((1.0-tmp)*100.0*pi/2.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 722], [724, 724, 781, 781, 1401]], "test": "ok"}
{"id": "Xd23Dd", "name": "[SH2014] 2d test", "author": "slack", "description": "this shader really sucks :P", "tags": ["2d", "test"], "likes": 1, "viewed": 151, "published": "Public", "date": "1395286643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 p = vec2(0.0, -1.0) + 2.0*uv;\n\tp.x *= iResolution.x/iResolution.y;\n\tp *= 10.0;\n\tvec2 wave1 = vec2(p.x, p.y + 3.0*sin(p.x*0.4 + iTime));\n\tvec2 wave2 = vec2(p.x, p.y + 3.0*sin(p.x*0.36+ 2.9 + iTime));\n\tfloat t = 1.0 - abs(wave1.y);\n\tt = max(t, 1.0 - abs(wave2.y));\n\t\n\tif (wave1.y * wave2.y < 0.0) t = mod(p.x + 3.141592654*iTime, 1.0);\n\tfloat c = t;\n\tc = smoothstep(0.7, 0.84, c);\n\tfragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd23Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 518]], "test": "ok"}
{"id": "Xd23Wc", "name": "Aurora Mask av nitelite", "author": "zomg", "description": "nitelites mask, med litt ape pÃ¥ paramterene ", "tags": ["wave"], "likes": 2, "viewed": 213, "published": "Public", "date": "1394493033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * vec2(5.0, 30.0) + vec2(iTime / 10.0, 0.0);\n\n\tuv.y = uv.y + sin((uv.x + (iTime / 3.0)) * 6.0);\n\t\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\n\tfloat f = 0.0;\n\tf  = 0.5000*noise( uv ); uv = m*uv*iDate.z;\n\tf += 0.2500*noise( uv ); uv = m*uv*iDate.x;\n\tf += 0.1250*noise( uv ); uv = m*uv*iDate.y;\n\tf += 0.0625*noise( uv ); uv = m*uv*iDate.a;\n\t\n\t\n\tf = 0.5 + 0.5*f;\n\t\n\tf = step(f, 0.24);\n\t\n\tfragColor = vec4(f, f, f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd23Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 114], [116, 116, 142, 142, 436], [439, 439, 496, 496, 957]], "test": "ok"}
{"id": "Xd23Wt", "name": "Simplex Mosiac", "author": "Justaway", "description": "A simplex mosiac.", "tags": ["procedural", "2d", "mosiac"], "likes": 5, "viewed": 341, "published": "Public", "date": "1395250181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define FILTER 1\nfloat s;\nvoid srand(vec2 p){\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\nfloat rand(){\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\nvec4 hash2d(vec2 p){\n\tsrand(p);\n\tvec4 c;\n\tc.r=rand();\n\tc.g=rand();\n\tc.b=rand();\n\treturn c;\n}\nmat2 rot2d(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts, c);\n}\nmat3 rotx(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\t1.0,0.0,0.0,\n\t\t0.0,  c, -s,\n\t\t0.0,  s,  c);\n}\nmat3 roty(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\tc,  0.0,  s,\n\t\t0.0,1.0,0.0,\n\t\t-s, 0.0,  c);\n}\nmat3 rotz(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\t  c, -s,0.0,\n\t\t  s,  c,0.0,\n\t    0.0,0.0,1.0);\n}\nvec2 simplex(vec2 p){\n\tvec2 r;\n\tr.x=1.1547*p.x;\n\tr.y=p.y+0.5*r.x;\n\treturn r;\n}\nvec2 unsimplex(vec2 p){\n\tvec2 r;\n\tr.y=p.y-0.5*p.x;\n\tr.x=p.x/1.1547;\n\treturn r;\n}\nvec4 noise2d(vec2 p){\n\tp=simplex(p);\n\tvec2 p0=floor(p);\n\tvec2 p1=p0+vec2(1.0,0.0);\n\tvec2 p2=p0+vec2(1.0,1.0);\n\tvec2 p3=p0+vec2(0.0,1.0);\n\tvec2 i=fract(p);\n\tvec4 r0,r1,r2;\n\tfloat d0,d1,d2;\t\n\tif(i.x>i.y){\n\t\tr0=hash2d(p0);\n\t\tr1=hash2d(p1);\n\t\tr2=hash2d(p2);\n\t\td0=max(1.0-distance(unsimplex(p),unsimplex(p0)),0.0);\n\t\td1=max(1.0-distance(unsimplex(p),unsimplex(p1)),0.0);\n\t\td2=max(1.0-distance(unsimplex(p),unsimplex(p2)),0.0);\n\t\t/*\n\t\td0=max(1.0-distance(p,p0),0.0);\n\t\td1=max(1.0-distance(p,p1),0.0);\n\t\td2=max(1.0-distance(p,p2),0.0);\n\t\t*/\n\t}else{\n\t\tr0=hash2d(p0);\n\t\tr1=hash2d(p2);\n\t\tr2=hash2d(p3);\n\t\td0=max(1.0-distance(unsimplex(p),unsimplex(p0)),0.0);\n\t\td1=max(1.0-distance(unsimplex(p),unsimplex(p2)),0.0);\n\t\td2=max(1.0-distance(unsimplex(p),unsimplex(p3)),0.0);\n\t}\n\t/*\n\tfloat d=d0+d1+d2;\n\td0/=d;\n\td1/=d;\n\td2/=d;\n\t*/\n\treturn d0*r0+d1*r1+d2*r2;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat r=iResolution.x/iResolution.y;\n\tvec2 p=vec2((fragCoord.x-iResolution.x/2.0)/iResolution.x*r,(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n\tvec4 n=vec4(0.0);\n\tfloat t=iTime/PI;\n#if FILTER\n\tvec2 x=vec2(0.5/iResolution.y,0.0);\n\tx*=rot2d(PI/8.0);\n\tn+=0.25*noise2d((p+x)*10.0);\n\tx*=rot2d(PI/4.0);\n\tn+=0.25*noise2d((p+x)*10.0);\n\tx*=rot2d(PI/4.0);\n\tn+=0.25*noise2d((p+x)*10.0);\n\tx*=rot2d(PI/4.0);\n\tn+=0.25*noise2d((p+x)*10.0);\n#else\n\tn=noise2d(p*10.0);\n#endif\n\tn.rgb*=rotx(t);\n\tn.rgb*=roty(t);\n\tn.rgb*=rotz(t);\n\tfragColor=vec4(abs(n));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd23Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 70, 70, 114], [115, 115, 128, 128, 186], [187, 187, 207, 207, 279], [280, 280, 300, 300, 367], [368, 368, 387, 387, 483], [484, 484, 503, 503, 599], [600, 600, 619, 619, 718], [719, 719, 740, 740, 797], [798, 798, 821, 821, 878], [879, 879, 900, 900, 1722], [1723, 1723, 1779, 1779, 2319]], "test": "ok"}
{"id": "Xd2GR3", "name": "Hexagons - distance", "author": "iq", "description": "Very dirty maths for computing the distance to hexagon borders", "tags": ["2d", "hexagons"], "likes": 324, "viewed": 26532, "published": "Public API", "date": "1394360615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2014 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n#define AA 2\n\n// { 2d cell id, distance to border, distnace to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int mm=0; mm<AA; mm++ )\n    for( int nn=0; nn<AA; nn++ )\n    {\n        vec2 off = vec2(mm,nn)/float(AA);\n        vec2 uv = (fragCoord+off)/iResolution.xy;\n        vec2 pos = (-iResolution.xy + 2.0*(fragCoord+off))/iResolution.y;\n    #else    \n    {\n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 pos = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    #endif\n\n        // distort\n        pos *= 1.0 + 0.1*length(pos);\n\n        // gray\n        vec4 h = hexagon(8.0*pos + 0.5*iTime);\n        float n = noise( vec3(0.3*h.xy+iTime*0.1,iTime) );\n        vec3 col = 0.15 + 0.15*hash1(h.xy+1.2)*vec3(1.0);\n        col *= smoothstep( 0.10, 0.11, h.z );\n        col *= smoothstep( 0.10, 0.11, h.w );\n        col *= 1.0 + 0.15*sin(40.0*h.z);\n        col *= 0.75 + 0.5*h.z*n;\n\n\n        // red\n        h = hexagon(6.0*pos + 0.6*iTime);\n        n = noise( vec3(0.3*h.xy+iTime*0.1,iTime) );\n        vec3 colb = 0.9 + 0.8*sin( hash1(h.xy)*1.5 + 2.0 + vec3(0.0,1.0,1.0) );\n        colb *= smoothstep( 0.10, 0.11, h.z );\n        colb *= 1.0 + 0.15*sin(40.0*h.z);\n        colb *= 0.75 + 0.5*h.z*n;\n\n        h = hexagon(6.0*(pos+0.1*vec2(-1.3,1.0)) + 0.6*iTime);\n        col *= 1.0-0.8*smoothstep(0.45,0.451,noise( vec3(0.3*h.xy+iTime*0.1,iTime) ));\n\n        col = mix( col, colb, smoothstep(0.45,0.451,n) );\n\n        col *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.1 );\n\n        tot += col;\n\t}\t\n \t#if AA>1\n    tot /= float(AA*AA);\n    #endif\n        \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2GR3.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[656, 714, 739, 739, 1250], [1252, 1252, 1276, 1276, 1348], [1350, 1350, 1376, 1376, 1584], [1587, 1587, 1645, 1645, 3180]], "test": "ok"}
{"id": "XdBGDd", "name": "Love Tunnel", "author": "Nrx", "description": "Greetings everyone! :)\n\nThis is the result of my very first experiment with shaders and ray marching. Nothing really amazing, but I hope you like it though :).", "tags": ["3d", "raymarching", "tunnel"], "likes": 30, "viewed": 2632, "published": "Public API", "date": "1394949601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rendering parameters\n#define FLOW\n#define RAY_LENGTH_MAX\t\t50.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (0.5, 0.0, -2.0)\n#define AMBIENT\t\t\t\t0.5\n#define SPECULAR_POWER\t\t4.0\n#define SPECULAR_INTENSITY\t0.2\n#define FADE_POWER\t\t\t3.0\n#define GAMMA\t\t\t\t(1.0 / 2.2)\n#define HSV2RGB_FAST\n#define TEXTURE_SCALE\t\t0.4\n\n// Constants\n#define PI\t\t3.14159265359\n#define DELTA\t0.01\n\nvec3 vRotateZ (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x + s * p.y, c * p.y - s * p.x, p.z);\n}\n\nfloat sphere (in vec3 p, in float r) {\n\treturn length (p) - r;\n}\n\nfloat box (in vec3 p, in vec3 b, in float r) {\n\t#ifdef BOX_NEGATIVE\n\tvec3 d = abs (p) - b + r;\n\treturn min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0)) - r;\n\t#else\n\treturn length (max (abs (p) - b + r, 0.0)) - r;\n\t#endif\n}\n\nfloat torusZ (in vec3 p, in float r1, in float r2) {\n\tvec2 q = vec2 (length (p.xy) - r1, p.z);\n\treturn length (q) - r2;\n}\n\nfloat cylinderZ (in vec3 p, in float r) {\n \treturn length (p.xy) - r;\n}\n\nvec3 twistZ (in vec3 p, in float k, in float angle) {\n\treturn vRotateZ (p, angle + k * p.z);\n}\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p, out vec4 q) {\n\n\t// Global deformation\n\tp += vec3 (2.0 * sin (p.z * 0.2 + iTime * 2.0), sin (p.z * 0.1 + iTime), 0.0);\n\n\t// Cylinder\n\tq.xyz = p;\n\tq.w = -1.0;\n\tfloat d = fixDistance (-cylinderZ (q.xyz, 4.0) + 0.5 * sin (atan (q.y, q.x) * 6.0) * sin (q.z), 0.4, 0.8);\n\n\t// Twisted boxes\n\tvec3 q_;\n\tq_.xy = mod (p.xy, 5.0) - 0.5 * 5.0;\n\tq_.z = mod (p.z, 12.0) - 0.5 * 12.0;\t\n\tq_ = twistZ (q_, 1.0, iTime);\n\tfloat d_ = fixDistance (box (q_, vec3 (0.6, 0.6, 1.5), 0.3), 0.4, 0.8);\n\tif (d_ < d) {\n\t\tq.xyz = q_;\n\t\td = d_;\n\t}\n\n\t// Rotating spheres\n\tq_ = p;\n\tq_.z += 12.0;\n\tq_ = vRotateZ (q_, sin (iTime * 4.0));\n\tq_.xy = mod (q_.xy, 4.5) - 0.5 * 4.5;\n\tq_.z = mod (q_.z, 24.0) - 0.5 * 24.0;\n\td_ = sphere (q_, 0.5);\n\tif (d_ < d) {\n\t\tq.xyz = q_;\n\t\td = d_;\n\t}\n\n\t// Torus\n\tq_ = p;\n\tq_.z = mod (q_.z + 12.0, 24.0) - 0.5 * 24.0;\n\td_ = torusZ (q_, 3.5, 0.4);\n\tif (d_ < d) {\n\t\tq.xyz = q_;\n\t\td = d_;\n\t}\n\n\t// Flow of boxes and spheres\n\t#ifdef FLOW\n\tq_ = p;\n\tq_.z += iTime * 20.0;\n\tconst float spacing = 0.5;\n\tconst float stepCount = 3.0;\n\tconst float period = spacing * stepCount;\n\tfor (float step = 0.0; step < stepCount; ++step) {\n\t\tfloat k1 = floor (q_.z / period + 0.5);\n \t\tfloat k2 = k1 * stepCount + step;\n\t\tvec3 qq = q_ - vec3 (0.4 * sin (k2), 0.4 * sin (k2 * 13.0), period * k1);\n\t\tif (mod (k2, 2.0) > 0.5) {\n\t\t\td_ = box (vRotateZ (qq, k2), vec3 (0.08), 0.01);\n\t\t} else {\n\t\t\td_ = sphere (qq, 0.08);\n\t\t}\n\t\tif (d_ < d) {\n\t\t\tq.xyz = qq;\n\t\t\tq.w = 1.0;\n\t\t\td = d_;\n\t\t}\n\t\tq_.z += spacing;\n\t}\n\t#endif\n\n\t// Final distance\n\treturn d;\n}\n\nvec3 getNormal (in vec3 p) {\n\tvec4 q;\n\tconst vec2 h = vec2 (DELTA, 0.0);\n\treturn normalize (vec3 (\n\t\tgetDistance (p + h.xyy, q) - getDistance (p - h.xyy, q),\n\t\tgetDistance (p + h.yxy, q) - getDistance (p - h.yxy, q),\n\t\tgetDistance (p + h.yyx, q) - getDistance (p - h.yyx, q)\n\t));\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 (0.0, 0.0, iTime * 6.0);\n\tvec3 forward = vec3 (0.2 * cos (iTime), 0.2 * sin (iTime), cos (iTime * 0.3));\n\tvec3 up = vRotateZ (vec3 (0.0, 1.0, 0.0), PI * sin (iTime) * sin (iTime * 0.2));\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Ray marching\n\tvec3 p = origin;\n\tvec4 q;\n\tfloat rayLength = 0.0;\n\tint rayStepCounter = 0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = getDistance (p, q);\n\t\trayLength += dist;\n\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp += dist * direction;\n\t\t++rayStepCounter;\n\t}\n\n\t// Compute the fragment color\n\tvec3 color;\n\tfloat bass = texture (iChannel0, vec2 (0.0)).x;\n\tif (rayLength > RAY_LENGTH_MAX) {\n\t\tcolor = vec3 (0.0);\n\t} else {\n\n\t\t// Object color\n\t\tvec3 normal = getNormal (p);\n\t\tfloat hue = (p.z + iTime) * 0.1;\n\t\tif (q.w < 0.0) {\n\t\t\t#ifdef TEXTURE_SCALE\n\t\t\tvec3 textureUV = q.xyz * TEXTURE_SCALE;\n\t\t\tvec3 textureFactor = abs (normal);\n\t\t\tmat3 textureColor = mat3 (\n\t\t\t\ttexture (iChannel1, textureUV.yz).rgb,\n\t\t\t\ttexture (iChannel1, textureUV.zx).rgb,\n\t\t\t\ttexture (iChannel1, textureUV.xy).rgb\n\t\t\t\t);\n\t\t\tcolor = hsv2rgb (vec3 (hue, 1.0, 1.0));\n\t\t\tcolor *= textureColor * textureFactor / (textureFactor.x + textureFactor.y + textureFactor.z);\n\t\t\t#else\n\t\t\tfloat treble = texture (iChannel0, vec2 (0.8, 0.0)).x;\n\t\t\tfloat saturation = 0.8 + (0.2 + 0.8 * treble) * 0.4 * sin (q.x * 10.0) * sin (q.y * 10.0) * sin (q.z * 10.0);\n\t\t\tfloat value = 0.2 + 0.8 * bass;\n\t\t\tcolor = hsv2rgb (vec3 (hue, saturation, value));\n\t\t\t#endif\n\t\t} else {\n\t\t\tcolor = hsv2rgb (vec3 (hue, 1.0, 1.0));\n\t\t}\n\n\t\t// Lighting\n\t\tvec3 lightDirection = normalize (LIGHT);\n\t\tvec3 reflectDirection = reflect (direction, normal);\n\t\tfloat diffuse = max (0.0, dot (normal, lightDirection));\n\t\tfloat specular = pow (max (0.0, dot (reflectDirection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\t\tcolor = ((AMBIENT + diffuse) * color + specular) * fade;\n\n\t\t// Special effect\n\t\tcolor *= max (1.0, 10.0 * sin (p.z * 0.1 - iTime * 4.0) - 7.0);\n\n\t\t// Gamma correction\n\t\tcolor = pow (color, vec3 (GAMMA));\n\t}\n\n\t// Another special effect\n\tcolor.r = mix (color.r, float (rayStepCounter) / float (RAY_STEP_MAX / 2), bass * bass);\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdBGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 374, 417, 417, 525], [527, 527, 565, 565, 591], [593, 593, 639, 639, 827], [829, 829, 881, 881, 950], [952, 952, 993, 993, 1023], [1025, 1025, 1078, 1078, 1119], [1121, 1121, 1186, 1186, 1315], [1317, 1317, 1360, 1384, 2860], [2862, 2862, 2890, 2890, 3143], [3145, 3145, 3173, 3173, 3508], [3510, 3510, 3566, 3617, 6225]], "test": "ok"}
{"id": "XdBGDt", "name": "Door Knob", "author": "DiLemming", "description": "asd", "tags": ["3d", "raytracing", "lighting"], "likes": 19, "viewed": 893, "published": "Public", "date": "1394837035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time (iTime * 0.5 - 2.0)\n\n#define dithering\t\t\t2.01\n\n#define samples 32\n\n#define brightness\t1.0\n#define gamma\t\t1.0\n\n//#define crossEyeStereo\n//#define nonlinearPerspective\n\nstruct material {\n\tvec3 color;\n\tvec3 light;\n\tfloat spec;\n};\n\nstruct hit {\n\tvec3 p;\n\tvec3 n;\n\tfloat t;\n\tmaterial m;\n};\n\n\nvec2 sphere (vec3 v, float f, vec3 p, vec3 d) {\n\tvec3 rp = p - v;\n\t\n\tfloat b = dot (d, rp);\n\tfloat c = dot (rp, rp) - f*f;\n\t\n\tfloat g = b*b - c;\n\t\n\tif (g < 0.0)\n\t\treturn vec2 (-1);\n\t\n\tfloat root = sqrt (g);\n\treturn vec2 (-root, root) - b;\n\n}\n\nhit scene (const in vec3 p, const in vec3 d) {\n\thit h;h.t = 1e20;\n\tfloat c = sin (time * 2.0) * 0.5 + 1.5;\n\t\n\tfloat t;\n\tvec2 t2;\n\tvec3 t3;\n\t\n\tvec3 invd = 1.0 / d;\n\t\n\tmaterial m1 = material (vec3 ( 1.0, 1.0, 1.0), vec3 ( 0.0, 0.0, 0.0),-1.0);\n\tmaterial m2 = material (vec3 ( 0.8, 0.5, 0.2), vec3 ( 0.0, 0.0, 0.0),-1.0);\n\tmaterial m3 = material (vec3 ( 0.2, 0.5, 0.8), vec3 ( 0.0, 0.0, 0.0),-1.0);\n\tmaterial m4 = material (vec3 ( 0.5, 0.7, 0.8), vec3 ( 0.0, 0.0, 0.0),-1.0);\n\tmaterial m5 = material (vec3 ( 1.0, 1.0, 1.0), vec3 ( 1.0, 1.0, 1.0),-1.0);\n\tmaterial m6 = material (vec3 ( 1.0, 0.0, 0.0), vec3 ( 0.0, 0.0, 0.0), 2.0);\n\t\n\tt3 = vec3 (0,0.5,0);\n\tt2 = sphere (t3, 0.5, p, d);\n\t\n\tt = t2.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\tif (r.y < 0.25)\n\t\t\th = hit (r, normalize (r - t3), t, m2);\n\t}\n\tt = t2.y;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\tif (r.y < 0.25) {\n\t\t\th = hit (r, normalize (r - t3), t, m1);\n\t\t\th.m.color *= mod (dot (fract (r * 4.0), vec3 (1)), 2.0) * 0.5 + 0.5;\n\t\t}\n\t}\n\tt2 = sphere (t3, 0.4, p, d);\n\tt = t2.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, normalize (r - t3), t, m1);\n\t\th.m.spec = \n\t\t\tdot (cos (h.p.yz * 20.0), vec2 (h.p.x*h.p.x)) +\n\t\t\tdot (cos (h.p.xz * 20.0), vec2 (h.p.y*h.p.y)) +\n\t\t\tdot (cos (h.p.xy * 20.0), vec2 (h.p.z*h.p.z));\n\t\th.m.spec *= 10.0;\n\t}\n\t\n\tt2 = sphere (t3, 1.0, p, d);\n\t\n\tt = t2.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\tfloat m = dot (r.yz, r.yz) * 0.9999999;\n\t\tif (any (lessThan (vec2 (abs (r.z), m), vec2 (0.25, 0.5)))) {\n\t\t\th = hit (r, normalize (r - t3), t, m3);\n\t\t}\n\t}\n\tt = t2.y;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\tfloat m = dot (r.yz, r.yz) * 0.9999999;\n\t\tif (any (lessThan (vec2 (abs (r.z), m), vec2 (0.25, 0.5)))) {\n\t\t\th = hit (r, normalize (r - t3), t, m5);\n\t\t\th.m.light = fract (floor (m * 6.0) * 0.5) * vec3 (0.0, 1.0, 1.0);\n\t\t\th.m.color = vec3 (0.8, 0.2, 0.5);\n\t\t}\n\t}\n\t\n\tt = -p.y * invd.y;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (0,1,0), t, m4);\n\t\th.m.color *= mod (dot (floor (r.xz), vec2 (1)), 2.0) * 0.5 + 0.5;\n\t}\n\tt = (3.0 - p.y) * invd.y;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (0,1,0), t, m5);\n\t\th.m.light *= sin (time * 0.2) * 0.5 + 0.5;\n\t}\n\tt = (4.0 - p.x) * invd.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (1,0,0), t, m1);\n\t}\n\tt = (-4.0 - p.x) * invd.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (1,0,0), t, m1);\n\t}\n\tt = (4.0 - p.z) * invd.z;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (0,0,1), t, m6);\n\t}\n\tt = (-4.0 - p.z) * invd.z;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (0,0,1), t, m1);\n\t}\n\t\n\th.n = faceforward (h.n, h.n, d);\n\t\n\treturn h;\n}\n\nfloat seed1;\nfloat rndValue () {\n\tseed1 = fract (seed1 * 3.01);\n\treturn seed1;\n}\nvec2 rndUnit2D () {\n\tfloat angle = rndValue () * 6.28318530718;\n\treturn vec2 (sin (angle), cos (angle));\n}\nvec2 rnd2D () {\n\tfloat radius = sqrt (rndValue ());\n\treturn rndUnit2D () * radius;\n}\nvec3 rndUnit3D () {\n\tfloat z = rndValue () * 2.0 - 1.0;\n\tvec2 xy = rndUnit2D () * sqrt (1.0 - z*z);\n\treturn vec3 (xy, z);\n}\n\nvec3 dir (const in vec3 n, const in vec3 d, const in float p) {\n\tvec3 r = reflect (d, n);\n\tvec3 b = rndUnit3D ();\n\t\n\tvec3 na = normalize (cross (n, b));\n\tvec3 nb = cross (n, na);\n\t\n\tvec3 ra = normalize (cross (r, b));\n\tvec3 rb = cross (r, ra);\n\t\n\tvec2 ng = rnd2D ();\n\tfloat nl = length (ng);\n\t\n\tfloat t = pow (nl, p);\n\tvec2 rg = ng * t;\n\tfloat rl = nl * t;\n\t\n\tvec3 o;\n\tif (p < 0.0)\n\t\to = ng.x * na + ng.y * nb + n * sqrt (1.0 - nl*nl);\n\telse\n\t\to = rg.x * ra + rg.y * rb + r * sqrt (1.0 - rl*rl);\n\t\n\treturn o + n * clamp (-dot (o, n), 0.0, 1.0) * 2.0;\n}\n\nvec3 rayColor (const in vec3 p, const in vec3 d) {\n\thit h;\n\tvec3 p1 = p;\n\tvec3 d1 = d;\n\t\n\tvec3 light = vec3 (0);\n\tvec3 color = vec3 (1);\n\tfor (int i = 0; i < 3; i++) {\n\t\th = scene (p1, d1);\n\t\tlight += h.m.light * color;\n\t\tcolor *= h.m.color;\n\t\t\n\t\td1 = dir (h.n, d1, h.m.spec);\n\t\tp1 = h.p + d1 * 0.001;\n\t}\n\t\n\treturn light;\n}\n\nvec3 rayDirection (const in vec3 r, const in vec3 u, const in vec3 f, const in float fov, in vec2 cr) {\n\tvec2 rs = cr * 3.14159 * fov;\n\tvec2 sn = sin (rs);\n\tvec2 cs = cos (rs);\n\t\n\t#ifdef nonlinearPerspective\n\treturn normalize (r * sn.x + u * sn.y + f * cs.x * cs.y);\n\t#else\n\treturn normalize (r * cr.x * 4.0 * fov + u * cr.y * 4.0 * fov + f);\n\t#endif\n}\n\nvoid camera (inout vec3 right, inout vec3 up, inout vec3 forward, inout vec3 p, inout vec2 cr) {\n\tforward = normalize (forward);\n\tright = normalize (cross (up, forward));\n\tup = normalize (cross (forward, right));\n\t\n\t#ifdef crossEyeStereo\n\tfloat s = sign (cr.x);\n\tcr.x = (cr.x - s * 0.25);\n\tp -= right * s / iResolution.x * 200.0;\n\t#endif\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tseed1 = 1.0;\n\t\n\tvec2 tmp = mod (fragCoord.xy + time, dithering);\n\tseed1 += tmp.x + tmp.y / dithering;\n\t\n\t//seed1 += mod (fragCoord.x + fragCoord.y * 2.0, dithering);\n\t\n\tvec2 cr = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n\tvec3 p = vec3 (sin (time) * 2.0, sin (time) + 1.25, cos (time) * 2.0);\n\n\tvec3 right, up = vec3 (0,1,0), forward = vec3 (0,0.75,0)-p;\n\tcamera (right, up, forward, p, cr);\n\t\n\tvec3 color = vec3 (0);\n\tfor (int i = 0; i < samples; i++) {\n\t\tvec3 d = rayDirection (\n\t\t\tright, up, forward, 1.0,\n\t\t\tcr + vec2 (rndValue (), rndValue ()) / iResolution.x);\n\t\t\n\t\tcolor += rayColor (p, d);\n\t}\n\tcolor = pow (color / float (samples), vec3 (gamma));\n\tfragColor = vec4 (color * brightness, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdBGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 300, 347, 347, 541], [543, 543, 589, 589, 3603], [3618, 3618, 3637, 3637, 3685], [3686, 3686, 3705, 3705, 3792], [3793, 3793, 3808, 3808, 3877], [3878, 3878, 3897, 3897, 4001], [4003, 4003, 4066, 4066, 4555], [4557, 4557, 4607, 4607, 4880], [4882, 4882, 4985, 4985, 5234], [5236, 5236, 5332, 5332, 5577], [5579, 5579, 5636, 5636, 6352]], "test": "error"}
{"id": "XdBGW3", "name": "DF Lighting", "author": "TekF", "description": "Using my  scene to test some distance-field light effects. Each pixel only uses 1 lighting direction, and 2 taps for shadows/AO. Obviously it's not perfect.", "tags": ["lighting"], "likes": 48, "viewed": 1815, "published": "Public", "date": "1394119645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// parameters\nconst float SSradius = 200.0; // Okay, it's actually a lot smaller than the Stanford Torus, but it's a cool name.\nconst float SSthickness = 16.0;\n\nconst float angularSpeed = .221; // g = r*w^2, e.g. w = sqrt(9.81/200) = .221\n\nvec3 SunDir = vec3(1,1,-1.5);\n\nconst float tau = 6.28318530717958647692;\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\n#define MAX 1000.0\n\nfloat Foliage( vec3 pos )\n{\n\treturn\n\t\tmax(\n\t\t\tabs(pos.z)-SSthickness,\n\t\t\tabs(length(pos.xy)-SSradius-2.0 + Noise(pos/16.0).x*2.0 + 2.0*abs(pos.z)/SSthickness - 1.0)-1.0\n\t\t);\n\t// todo: leafiness\n}\n\nfloat Water( vec3 pos )\n{\n\treturn max( abs(pos.z)-SSthickness, abs(length(pos.xy)-SSradius-1.0)-1.0 );\n}\n\n\nfloat Building( vec3 pos, float seed )\n{\n\tif ( seed < .1 )\n\t\treturn length(vec3(pos.x,max(abs(pos.y)-2.0,0.0),pos.z))-2.0;\n\t\n\tvec3 p = pos;\n\tp.y += (seed-.5)*p.z;\n\tp = abs(p)-vec3(2,3,2);\n\tvec3 p2 = abs(pos+vec3(0,1.67,0))-vec3(1,.67,1);\n\treturn max(max(max(p.x,p.y),p.z),-max(p2.z,p2.y));\n}\n\n\nfloat Solid( vec3 pos )\n{\n\tfloat r = length(pos.xy);\n\t\n\tvec2 polar = vec2(atan(pos.x,-pos.y),length(pos.xy));\n\n\tvec3 spokep = pos;\n\tconst float spokeangle = tau/5.0;\n\tfloat spokea = (fract(polar.x/spokeangle)-.5)*spokeangle;\n\tspokep.xy = polar.y*vec2(sin(spokea),-cos(spokea));\n\t\n\treturn\n\t\tmin(min(\n\t\t\t// ring\n\t\t\tmax(max(\n\t\t\t\t// outer torus\n\t\t\t\tabs( length(vec2(pos.z, r-SSradius))-SSthickness-.5 )-.5,\n\t\t\t\t// window-gap\n\t\t\t\t5.0-abs(r-(SSradius-6.0))),\n\t\t\t\t// top gap\n\t\t\t\tmin(\n\t\t\t\t\t6.0-abs(pos.z), //todo: close bottom\n\t\t\t\t\tSSradius-r\n\t\t\t\t)\n\t\t\t),\n\t\t\t// buildings\n\t\t\t//length( vec3((fract(polar.x*40.0)-.5)*polar.y/40.0,polar.y+1.0-SSradius,pos.z+30.0*(fract(pow(floor(polar.x*40.0)*.777,2.0))-.5) ) ) - .5\n\t\t\t//length( vec3((fract(polar.x*20.0)-.5)*polar.y/20.0,polar.y-SSradius,pos.z+30.0*(fract(pow(floor(polar.x*20.0)*.444,2.0))-.5) ) ) - 2.0\n\t\t\tBuilding( vec3((fract(polar.x*20.0)-.5)*polar.y/20.0,polar.y-SSradius,pos.z+30.0*(fract(pow((floor(polar.x*20.0)+5.0)*.444,2.0))-.5) ), fract(pow(floor(polar.x*20.0)*.777,2.0)) )\n\t\t\t// could do roads connecting them, by drawing 2 for every position\n\t\t\t),\n\t\t\tmax(\n\t\t\t\tmin( min(\n\t\t\t\t\t// spokes\n\t\t\t\t\tmax(\n\t\t\t\t\t\t-SSradius-spokep.y,\n\t\t\t\t\t\tlength(spokep.xz)-2.0\n\t\t\t\t\t),\n\t\t\t\t\t// hub\n\t\t\t\t\tmax(\n\t\t\t\t\t\tr-20.0,\n\t\t\t\t\t\tabs(pos.z)-7.0\n\t\t\t\t\t)),\n\t\t\t\t\tmax(\n\t\t\t\t\t\tr-17.0,\n\t\t\t\t\t\tabs(pos.z)-9.0\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\t// dock\n\t\t\t\tmin(\n\t\t\t\t\t8.0-abs(pos.x),\n\t\t\t\t\t3.0-abs(pos.y)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n}\n\n\n// smooth min, to prevent hard edges when I use union of lights\nbool domin;\nfloat smin ( float a, float b )\n{\n\t/*const float s = 1.0;\n\treturn -log2(exp2(-a/s)+exp2(-b/s))*s;*/\n\tif ( domin )\n\t{\n\t\treturn min( a, b );\n\t}\n\telse\n\t{\n\t\treturn 1.0/(1.0/a+1.0/b);\n\t}\n}\n\n\nfloat Lights( vec3 pos )\n{\n\treturn\n\t\tsmin(smin(//smin(\n\t\t\t// ring light\n\t\t\tsqrt( pow(length(vec2(pos.z, length(pos.xy)-188.0)),2.0) + pow(max(.0,dot(pos.xy,vec2(sin(iTime*.3),cos(iTime*.3)))),2.0) )-.5,\n\t\t\t\n\t\t\t// landing lights\n\t\t\t//length( vec3( abs(pos.x)-8.0, max(vec2(0),abs(pos.yz)-vec2(3,8.5)) ) )-.1),\n\t\t\t\t  \n\t\t\t// moving lights to test fake lighting/shadows\n\t\t\tlength(pos-vec3(-sin(iTime*.2)*20.0+8.0,-197,12.0*sin(iTime)))-.3),\n\t\t\tlength(pos-vec3(-sin(iTime*.22)*30.0,-197.0+4.0*sin(iTime*.7),12.0*sin(iTime*.87)))-2.0\n\t\t);\n}\n\nvec4 SampleLights( vec3 pos )\n{\n\tdomin = false;\n\t\n\t// like then Normal calc\n\tfloat r = .1;\n\tvec2 d = vec2(-1,1) * r;\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = Lights(p0);\n\tfloat f1 = Lights(p1);\n\tfloat f2 = Lights(p2);\n\tfloat f3 = Lights(p3);\n\t\n\t// this direction is completely  innaccurrate for hard-edged intersections!\n\t// it gets one or other surface normal, rather than a smoothed result\n\t// so, build smooth light shapes\n\t\n\treturn vec4(\n\t\t\t\t-normalize( p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3) ),// /r, should be possible to use non-normalized value, for more realistic effect\n\t\t\t\t(f0+f1+f2+f3)/4.0\n\t\t\t);\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n\tdomin = true;\n\t\n\treturn min( min( min(\n\t\t\tFoliage( pos ),\n\t\t\tWater( pos ) ),\n\t\t\tSolid( pos ) ),\n\t\t\tLights( pos )\n\t\t);\n}\n\n\nfloat DistanceFieldNoLights( vec3 pos )\n{\n\treturn min( min(\n\t\t\tFoliage( pos ),\n\t\t\tWater( pos ) ),\n\t\t\tSolid( pos )\n\t\t);\n}\n\n\nstruct ShadeData { vec3 pos, ray, normal; float shadow; float t; };\nShadeData SetShadeData( vec3 pos, vec3 ray, vec3 normal, float shadow, float t )\n{\n\tShadeData s;\n\ts.pos = pos;\n\ts.ray = ray;\n\ts.normal = normal;\n\ts.shadow = shadow;\n\ts.t = t;\n\treturn s;\n}\n\n\nvec3 DiffuseLight( ShadeData s )\n{\n\t// sunlight\n\tvec3 sun = vec3(1)*2.0*max(.0,dot(s.normal,SunDir))*s.shadow;\n\t\n\t// local soft light sources\n\t// Actually sample the lights!!\n\tvec4 sl = SampleLights( s.pos );\n//\tfloat fade = 1.0/sl.w; // point lights should be 1/(w*w), line lights are 1/w, infinite area lights are 1\n\t//vec3 local = vec3(.4,.7,1)*5.0*(dot(sl.xyz,s.normal)*.5+.5)*fade;\n\tvec3 local = vec3(.4,.7,1)*2.0*(dot(sl.xyz,s.normal)+1.0)/sl.w;\n\n\t// like ambient occlusion, but towards the light\n\tvec3 l = normalize(sl.xyz);\n\tfloat d = 2.0;//s.t/20.0;\n//shadow strength should depend on strength of SH vector\n\tlocal *= .3+.7*min( 1.0, max( 0.0, (DistanceFieldNoLights(s.pos+l*d)/d)) );// /max(.001,dot(s.normal,l)) );\n\t\n\t// ambient\n\tvec3 ambient = vec3(0) + local;\n\t// this ambient occlusion trick works ridiculously well\n\t// sample the distance field at a point in front of the surface\n\t// if there's a nearby concave surface the value will be less than the distance to the sample point\n\tfloat aoRange = s.t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceFieldNoLights( s.pos + s.normal*aoRange )/aoRange ); // can be > 1.0\n\tambient *= exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\t\n\treturn ambient;//+sun;\n}\n\n\nvec3 ShadeFoliage( ShadeData s )\n{\n\tvec3 albedo = mix( vec3(.05,.02,.01), vec3(.1,.5,.0), Noise(s.pos*20.0).x*.3+.7 );\n\t\n\treturn albedo*DiffuseLight(s);\n}\n\nvec3 ShadeWater( ShadeData s )\n{\n\tconst float albedoScale = 4.0;\n\tfloat rad = (SSradius+1.0)/albedoScale;\n\trad = floor( rad*tau+.5 )/tau; // round it so we get a whole number of texture repeats\n\tvec2 uv = vec2(s.pos.z/albedoScale,atan(s.pos.x,s.pos.y)*rad);\n\t\n\tvec3 base = vec3(.05,.1,.2)*DiffuseLight(s);\n\t\n\t// normal map\n\tvec2 noise = (Noise( s.pos*2.0+iTime*vec3(-4,4,0) )*2.0-1.0)*.1;\n\tvec3 tangent = normalize(vec3(s.pos.y,-s.pos.x,0));\n\tvec3 binormal = vec3(0,0,1);\n\tvec3 normal = s.normal + tangent*noise.x + binormal*noise.y;\n\t\n\tfloat fresnel = dot(normal,s.ray);\n\tvec3 reflection = s.ray-2.0*fresnel*normal;\n\tfresnel = pow( 1.0-abs(fresnel), 5.0 );\n\tfloat up = dot( reflection, normal );\n\tfloat across = dot( reflection, binormal );\n\tvec3 refcol = vec3(.4,.7,1)*1.0*pow(1.0-abs(across),40.0);\n\t\n\treturn mix( base, refcol, fresnel );\n}\n\nvec3 ShadeSolid( ShadeData s )\n{\n\treturn vec3(.8) * DiffuseLight(s);\n}\n\nvec3 ShadeLights( ShadeData s )\n{\n\treturn vec3(.4,.7,1)*8.0*abs(dot(s.ray,s.normal)); // draw the lightbulb\n}\n\nvec3 Shade( ShadeData s )\n{\n\tfloat foliage = Foliage(s.pos);\n\tfloat water = Water(s.pos);\n\tfloat solid = Solid(s.pos);\n\tfloat lights = Lights(s.pos);\n\tfloat dist = min(min(min(foliage, water),solid),lights);\n\t\n\tif ( lights == dist )\n\t\treturn ShadeLights(s);\n\t\n#if (1) // test lighting\n\treturn DiffuseLight(s)*.8;\n#else\n\telse if ( foliage == dist )\n\t\treturn ShadeFoliage(s);\n\telse if ( water == dist )\n\t\treturn ShadeWater(s);\n\telse\n\t\treturn ShadeSolid(s);\n#endif\n}\n\n\n//Compute the surface normal\nvec3 Normal( vec3 pos )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n\tvec2 d = vec2(-1,1) * .01;\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\treturn normalize( p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3) );\n}\n\n\nstruct Camera { vec3 pos, target, up; float zoom; };\n\nCamera SetCam( vec3 pos, vec3 target, vec3 up, float zoom )\n{\n\tCamera cam;\n\tcam.pos = pos;\n\tcam.target = target;\n\tcam.up = up;\n\tcam.zoom = zoom;\n\treturn cam;\n}\n\nCamera MixCam( Camera a, Camera b, float c )\n{\n\tCamera cam;\n\tcam.pos = mix( a.pos, b.pos, c );\n\tcam.target = mix( a.target, b.target, c );\n\tcam.up = mix( a.up, b.up, c );\n\tcam.zoom = mix( a.zoom, b.zoom, c );\n\treturn cam;\n}\n\nvec3 BGRot( in vec3 v, in vec3 cs )\n{\n\treturn vec3(v.xy*cs.x + v.yx*cs.yz, v.z);\n}\n\nvec2 Trace( vec3 pos, vec3 ray, vec2 interval )\n{\n\tfloat t = interval.x;\n\tfloat h;\n\tfor( int i=0; i<200; i++ )\n\t{\n\t\th = DistanceField( pos + t*ray );\n\t\tif ( h < .01 || t > interval.y )\n\t\t\tbreak;\n\t\tt += h;\n\t}\n\treturn vec2(t,h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate background\n\tfloat a = iTime*angularSpeed; // radians per second\n\tvec3 cs = vec3( cos(a), sin(a)*vec2(1,-1) );\n\tSunDir = normalize( BGRot( SunDir, cs ) );\n\t\n\t// todo: animate camera between pairs of keyframes\n\tCamera camKeys[8];\n\tcamKeys[0] = SetCam( vec3(-400,-300,-300), vec3(0,0,0), vec3(0,.5,-1), .8 );\n\tcamKeys[1] = SetCam( vec3(-20,3.0-SSradius,-16), vec3(SSradius,-130,0), vec3(0,1,1), .7 );\n\tcamKeys[2] = SetCam( vec3(-10,2.0-SSradius,16), vec3(0,-SSradius,0), vec3(0,1,0), .8 );\n\tcamKeys[3] = SetCam( vec3(30,2.5-SSradius,5), vec3(-SSradius,40.0-SSradius,-50), vec3(0,1,0), .8 );\n\tcamKeys[4] = SetCam( vec3(30,2.5-SSradius,5), vec3(-SSradius,40.0-SSradius,-50), vec3(0,1,0), .8 );\n\tcamKeys[5] = SetCam( vec3(-10,2.5-SSradius,2), vec3(0,SSradius,0), vec3(.5,3,1), 1.2 );\n\tcamKeys[6] = SetCam( vec3(200,-150,400), vec3(0,0,0), vec3(0,.5,1), .8 );\n\tcamKeys[7] = SetCam( vec3(0,0,50), vec3(0,0,0), vec3(cs.y,-cs.x,0), .8 );\n\n\t// pick a pair of cameras using time\n\t// todo: could manually pick cam using all combinations of \"iop\", shown on screen when auto-cycling (cam: io)\n\t// mouse moves cam along path, and target up/down (by up*length(target-pos))\n\tfloat T = fract(iTime/52.0)*4.0;\n\tCamera cam1, cam2;\n\tbool rotCam = false;\n\tif ( T < 1.0 ) { cam1 = camKeys[0]; cam2 = camKeys[1]; rotCam = true; }\n\telse if ( T < 2.0 ) { cam1 = camKeys[2]; cam2 = camKeys[3]; }\n\telse if ( T < 3.0 ) { cam1 = camKeys[4]; cam2 = camKeys[5]; }\n\telse { cam1 = camKeys[6]; cam2 = camKeys[7]; rotCam = true; }\n\n\t// mix between them\n\t//T = smoothstep( .15, .85, fract(T) );\n\tT = fract(T);\n\tfloat T2 = T*T;\n\tT = (6.0*T2 - 15.0*T + 10.0)*T2*T;\n\tCamera cam = MixCam( cam1, cam2, T );\n\t\n//rotCam = true; cam = camKeys[1];\nrotCam = false; cam = camKeys[3];\n\t\n\t//Camera cam = SetCam( vec3(500.0*(iMouse.xy/iResolution.xy-.5),0)+vec3(0,-300,-300), vec3(0,-100,0), vec3(0,1,0), .7 );\n\t\n\t// fire a ray from the camera\n\tvec3 pos = cam.pos;\n\tvec3 forward = normalize(cam.target-cam.pos);\n\tvec3 right = normalize(cross(cam.up,forward));\n\tvec3 up = normalize(cross(forward,right));\n\tvec3 ray = normalize(vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*cam.zoom ));\n\tray = right*ray.x + up*ray.y + forward*ray.z;\n\t\n\tif ( rotCam )\n\t{\n\t\tpos = BGRot( pos, cs );\n\t\tray = BGRot( ray, cs );\n\t}\n\t\n\t// intersect that ray with isosurface bounding volume\n\tvec2 interval = vec2(0,1000);\n\t\n\t// march isosurface\n\tvec2 th = Trace( pos, ray, interval );\n\t\n\t// shading\n\tvec3 col;\n\t\n\tif ( th.y < 1.0 ) // shade some near misses to reduce artefacts\n\t{\n\t\tvec3 p = pos + th.x*ray;\n\t\tvec3 n = Normal(p);\n\t\t\n\t\tfloat shadowBias = mix ( 1.0, .1, abs(dot( n, SunDir )) );\n\n\t\tfloat shadow = Trace( p, SunDir, vec2(shadowBias, 1000.0) ).y;\n\t\t\n\t\tshadow = smoothstep( .01, 4.0, shadow );\n\t\t\n\t\tcol = Shade( SetShadeData(p,ray,n,shadow,th.x) );\n\t}\n\telse\n\t{\n\t\t// draw background\n\t\tray = BGRot( ray, cs.xzy );\n\t\tfloat s = 1.3;\n\t\tvec3 X = texture( iChannel1, ray.yz*s ).rgb;\n\t\tvec3 Y = texture( iChannel1, ray.xz*s ).rgb;\n\t\tvec3 Z = texture( iChannel1, ray.xy*s ).rgb;\n\t\tcol = mix( X, Y, smoothstep(-.3,.3,abs(ray.y)-abs(ray.x)) );\n\t\tcol = mix( col, Z, smoothstep(-.3,.3,abs(ray.z)-max(abs(ray.x),abs(ray.y))) );\n\t\tcol = pow(col,vec3(7,5,3))*.1;\n\t\t\n\t\tcol = vec3(0);\n\t}\n\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdBGW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[305, 425, 450, 450, 648], [671, 671, 698, 698, 866], [868, 868, 893, 893, 972], [975, 975, 1015, 1015, 1266], [1269, 1269, 1294, 1294, 2686], [2689, 2765, 2798, 2864, 2948], [2951, 2951, 2977, 2977, 3485], [3487, 3487, 3518, 3518, 4185], [4188, 4188, 4221, 4221, 4342], [4345, 4345, 4386, 4386, 4465], [4536, 4536, 4618, 4618, 4723], [4726, 4726, 4760, 4773, 5951], [5954, 5954, 5988, 5988, 6108], [6110, 6110, 6142, 6142, 6953], [6955, 6955, 6987, 6987, 7025], [7027, 7027, 7060, 7060, 7136], [7138, 7138, 7165, 7165, 7601], [7604, 7633, 7658, 7733, 8068], [8125, 8125, 8186, 8186, 8284], [8286, 8286, 8332, 8332, 8509], [8511, 8511, 8548, 8548, 8593], [8595, 8595, 8644, 8644, 8823], [8825, 8825, 8882, 8904, 12151]], "test": "ok"}
{"id": "XdfXzn", "name": "Sample Pinning", "author": "huwb", "description": "Mash up of Clouds by iq and Cloud Ten by nimitz to demonstrate sample pinning & adaptive sampling algorithms presented at siggraph 2015: http://advances.realtimerendering.com/s2015/index.html", "tags": ["noise", "raymarch", "clouds", "sampling", "stationary"], "likes": 121, "viewed": 8365, "published": "Public", "date": "1395576140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2015 Huw Bowles & Daniel Zimmermann\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// UPDATE: this method is now superseded by a new approach named Structured Sampling,\n// see here: https://www.shadertoy.com/view/Mt3GWs\n//\n// Example to illustrate volume sampling research undertaken right here on\n// shadertoy and published at siggraph 2015:\n//\n// http://advances.realtimerendering.com/s2015/index.html\n//\n// In particular this shader demonstrates Forward Pinning and Adaptive Sampling.\n// The general advection requires state and is not implemented here, see the Unity\n// implementation for this:\n//\n// https://github.com/huwb/volsample\n//\n// For a diagram shader illustrating the adaptive sampling:\n//\n// https://www.shadertoy.com/view/llXSD7\n// \n//\n// Credits - this scene is mostly mash up of these two amazing shaders:\n//\n// Clouds by iq: https://www.shadertoy.com/view/XslGRr\n// Cloud Ten by nimitz: https://www.shadertoy.com/view/XtS3DD\n// \n\n#define SAMPLE_COUNT 32\n#define DIST_MAX 128.\n#define MOUSEY (3.*iMouse.y/iResolution.y)\n#define SAMPLES_ADAPTIVITY 0.2\n\n// mouse toggle\nbool useNewApproach = true;\n\n// cam moving in a straight line\nvec3 lookDir = vec3(-1.,0.,0.);\nvec3 camVel = vec3(-3.,0.,0.);\nfloat zoom = 1.2; // 1.5;\n\n// cam spin around on spot\nfloat samplesCurvature = 0.; // can mix between fixed z and fixed radius sampling\n\nvec3 sundir = normalize(vec3(-1.0,0.0,-1.));\n\n// LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.1 + .8 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;\n\n    vec3 q = p;\n    float f;\n    \n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n    d += 2.75 * f;\n\n    d = clamp( d, 0.0, 1.0 );\n    \n    vec4 res = vec4( d );\n    \n    vec3 col = 1.15 * vec3(1.0,0.95,0.8);\n    col += vec3(1.,0.,0.) * exp2(res.x*10.-10.);\n    res.xyz = mix( col, vec3(0.7,0.7,0.7), res.x );\n    \n    return res;\n}\n\n// compute desired spacing between samples, modelled as a 1/z curve\nfloat spacing(float t )\n{\n    // restrict to domain\n    t = max(t,0.);\n    \n    // unnorm pdf - plot this in graphtoy to see shape\n    float pdf = 1. / (SAMPLES_ADAPTIVITY*t + 1.);\n\t// integral of pdf over dist\n\tfloat norm = (1. / SAMPLES_ADAPTIVITY)*log(1. + SAMPLES_ADAPTIVITY*DIST_MAX);\n    // norm pdf\n    pdf /= norm;\n    \n    // sample spacing for our sample count\n    return 1. / (float(SAMPLE_COUNT) * pdf);\n}\n\n// mod but moves the boundaries to keep them stationary with the camera\nfloat mov_mod( float x, float y )\n{\n    return mod(x + (useNewApproach ? dot(camVel*iTime,lookDir) : 0.), y) ;\n}\n\nbool on_boundary( float x, float y )\n{\n    // the +0.25 solves numerical issues without changing the result\n    float numericalFixOffset = y*0.25;\n    return mov_mod( x + numericalFixOffset, y ) < y*0.5;\n}\n\n// put t on an appropriate sample location and initialise sampling data\nvoid firstT( out float t, out float dt, out float wt, out bool even )\n{\n    dt = exp2(floor(log2(spacing(0.))));\n    t = dt - mov_mod(t,dt);\n    even = on_boundary(t,2.*dt);\n    wt = 1.;\n}\n\n// advance t to next sample location\nvoid nextT( inout float t, inout float dt, inout float wt, inout bool even )\n{\n    float s = spacing(t); // get desired sample spacing\n    if( s < dt ) { dt /= 2.; even = true; } // can immediately move to higher density\n    else if( even && s > 2.*dt ) { dt *= 2.; wt = 1.; even = on_boundary(t,2.*dt); } // move to lower density if a sample is there\n\n    if( even ) wt = clamp( 2. - s/dt,0.,1.); // update wt for next odd sample - based on how far this even sample is into its band\n    \n    // next sample\n    t += dt;\n    even = !even;\n}\n\n// wt for blending in/out samples without pops\nfloat sampleWt( float wt, bool even )\n{\n    return even ? (2.-wt) : wt;\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec4 sum = vec4(0, 0, 0, 0);\n    \n    // setup sampling\n    float t, dt, wt; bool even;\n    firstT( t, dt, wt, even );\n    \n    for(int i=0; i<SAMPLE_COUNT; i++)\n    {\n        if( sum.a > 0.99 ) continue;\n\n        vec3 pos = ro + t*rd;\n        vec4 col = map( pos );\n        \n        // iqs goodness\n        float dif = clamp((col.w - map(pos+0.6*sundir).w)/0.6, 0.0, 1.0 );\n        vec3 lin = vec3(0.51, 0.53, 0.63)*1.35 + 0.55*vec3(0.85, 0.57, 0.3)*dif;\n        col.xyz *= lin;\n        \n        col.xyz *= col.xyz;\n        \n        col.a *= 0.35;\n        col.rgb *= col.a;\n\n        // fade samples at far field\n        float fadeout = 1.-clamp((t/(DIST_MAX*.3)-.85)/.15,0.,1.); // .3 is an ugly fudge factor due to oversampling\n            \n        // integrate\n        float thisDt = dt * sampleWt( wt, even); // blend in dts\n        thisDt = sqrt(thisDt/5. )*5.; // hack to soften and brighten\n        sum += thisDt * col * (1.0 - sum.a) * fadeout;\n\n        // next sample\n        nextT( t, dt, wt, even );\n    }\n\n    sum.xyz /= (0.001+sum.w);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec3 sky( vec3 rd )\n{\n    vec3 col = vec3(0.);\n    \n    float hort = 1. - clamp(abs(rd.y), 0., 1.);\n    col += 0.5*vec3(.99,.5,.0)*exp2(hort*8.-8.);\n    col += 0.1*vec3(.5,.9,1.)*exp2(hort*3.-3.);\n    col += 0.55*vec3(.6,.6,.9);\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    col += .2*vec3(1.0,0.3,0.2)*pow( sun, 2.0 );\n    col += .5*vec3(1.,.9,.9)*exp2(sun*650.-650.);\n    col += .1*vec3(1.,1.,0.1)*exp2(sun*100.-100.);\n    col += .3*vec3(1.,.7,0.)*exp2(sun*50.-50.);\n    col += .5*vec3(1.,0.3,0.05)*exp2(sun*10.-10.); \n    \n    float ax = atan(rd.y,length(rd.xz))/1.;\n    float ay = atan(rd.z,rd.x)/2.;\n    float st = texture( iChannel0, vec2(ax,ay) ).x;\n    float st2 = texture( iChannel0, .25*vec2(ax,ay) ).x;\n    st *= st2;\n    st = smoothstep(0.65,.9,st);\n    col = mix(col,col+1.8*st,clamp(1.-1.1*length(col),0.,1.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( iMouse.z > 0. )\n        useNewApproach = false;\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n   \n    // camera\n    vec3 ro = vec3(0.,1.9,0.) + iTime*camVel;\n    vec3 ta = ro + lookDir; //vec3(ro.x, ro.y, ro.z-1.);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + 1.2*p.y*vv + 1.5*ww );\n    \n    // sky\n    vec3 col = sky(rd);\n    \n    // divide by forward component to get fixed z layout instead of fixed dist layout\n    vec3 rd_layout = rd/mix(dot(rd,ww),1.0,samplesCurvature);\n    vec4 clouds = raymarch( ro, rd_layout );\n    \n    col = mix( col, clouds.xyz, clouds.w );\n    \n\tcol = clamp(col, 0., 1.);\n    col = smoothstep(0.,1.,col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n        \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfXzn.jpg", "access": "shaders20k", "license": "mit", "functions": [[2416, 2444, 2470, 2470, 2696], [2699, 2699, 2722, 2722, 3212], [3214, 3282, 3307, 3333, 3699], [3701, 3773, 3808, 3808, 3885], [3887, 3887, 3925, 3994, 4092], [4094, 4166, 4237, 4237, 4354], [4356, 4393, 4471, 4471, 4933], [4935, 4982, 5021, 5021, 5055], [5057, 5057, 5098, 5098, 6188], [6190, 6190, 6211, 6211, 7051], [7053, 7053, 7110, 7110, 8104]], "test": "ok"}
{"id": "Xdj3WV", "name": "future city", "author": "Hodgman", "description": "Learning how to ray-march against a city grid for the #cyberpunkjam.\n\nThanks IQ, Eiffie and the rest of the community for the learning material.", "tags": ["cyberpunk"], "likes": 7, "viewed": 1016, "published": "Public", "date": "1393660233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define ORBIT_CAM\n\n#define ITERATIONS 96\n#define SHADOW_ITERATIONS 8\n\n#ifdef ORBIT_CAM\nconst float aperture=0.0001,focalDistance=1000.0;\n#else\nconst float aperture=0.025,focalDistance=10.0;\n#endif\n\n\nconst float streetWidth = 30.0;\nconst float blockWidth = 200.0;\nconst float totalBlock = blockWidth + streetWidth;\nconst float halfStreetWidth = streetWidth*0.5;\nconst float maxBlockHeight = 600.00;\n\n#define sat(x) clamp(x,0.0, 1.0)\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n//\treturn 0.01;\n//\treturn max(0.01,abs(focalDistance-t)*1.0*aperture);\n\treturn clamp(abs(focalDistance-t)*1.0*aperture, 0.01, halfStreetWidth);\n}\nfloat linstep(float a, float b, float t){\n\tfloat v=(t-a)/(b-a);\n\treturn clamp(v,0.,1.);\n}\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat smoothstep2( float min1, float max1, float min2, float max2, float p )\n{\n\treturn smoothstep(min1, max1, p) * (1.0 - smoothstep(min2, max2, p));\n}\nfloat softstep( float min1, float p )\n{\n\treturn smoothstep(min1, min1+0.01, p);\n}\nfloat softstep2( float min1, float min2, float p )\n{\n\treturn softstep(min1, p) * (1.0 - softstep(min2, p));\n}\n\n\n\nfloat BlockDe( vec3 pos, float blockId, inout vec4 m )\n{\n\tif( blockId < 0.33 )\n\t\treturn 99999.9;\n\tfloat h = blockId;\n\t\n\th = maxBlockHeight*0.01 + h*maxBlockHeight*0.99;\n\th *= 0.5;\n\t\n\tfloat wScale = fract(blockId+0.5);\n\t\n\tfloat w = blockWidth*0.5;\n\tfloat xz = w*0.6 + w*0.4*wScale;\n\t\n\tpos.xz -= totalBlock*0.5;\n\t\n\tfloat bulk = sdBox( pos - vec3(0,h,0), vec3(xz,h,xz) );\n\tfloat de = bulk;\n\t\n\tfloat bounds = sdBox( pos - vec3(0,h+1.0,0), vec3(xz+2.0,h+2.0,xz+2.0) );\n\t\n\tfloat bands;\n\t{\n\t\tvec3 p = pos;\n\t\tfloat addHeight = 10.0;\n\t\tp.y += 2.0;\n\t\tfloat r = addHeight + addHeight + 20.0 * (fract(1.3-blockId*7.0));\n\t\tp.y = mod(p.y,r);//-0.5*r;\n\t\txz = xz+1.0*wScale;\n\t\tbands = sdBox(p, vec3(xz, addHeight, xz));\n\t\tbands = max(bands,bounds);\n\t\tde = smin( de, bands, 10.0 );\n\t}\n\t\n\tfloat base;\n\t{\n\t\tfloat baseW = w*0.9 + w*0.1*wScale;\n\t\tfloat baseH = 0.1;//0.5 + 4.0 * (1.0-blockId);\n\t\tbase = sdBox( pos - vec3(0,baseH,0), vec3(baseW,baseH,baseW) );\n\t\tde = min(de,base);\n\t}\n\t\n\t//m.x += 1.0;\n\t/*\n\tm.x += clamp(1.0-smoothstep(0.0,de,bulk), 0.0, 1.0);\n\tm.y += clamp(1.0-smoothstep(0.0,de,bands), 0.0, 1.0);\n\tm.z += clamp(1.0-smoothstep(0.0,de,base), 0.0, 1.0);*/\n\t\n\t//if( base -de < 0.001 ) m.x += 1.0;\n\t//if( bands-de < 0.001 ) m.y += 1.0;\n\t//if( base -de < 0.001 ) m.z += 1.0;\n\t\n\tfloat alpha = clamp((bulk-bands)*100.0,0.0,1.0);\n\tm = mix( vec4(1,0,0,0), vec4(0,1,0,0), alpha );\n\talpha = clamp((base-bulk+2.0)*10000.0,0.0,1.0);\n\tm = mix( vec4(0,0,1,0), m, alpha );\n\t\n\t\n\t/*\n\tfloat dentHeight = 10.0;\n\tfloat dentDepth = 10.0 + 20.0 * (fract(blockId+0.7));\n\tpos.y -= dentHeight+2.0;\n\tfloat r = dentHeight + 1.0 + 20.0 * (fract(1.3-blockId*7.0));\n\tpos.y = mod(pos.y,r);//-0.5*r;\n\t\n\txz+=halfStreetWidth;\n\tfloat carve = sdBox(pos, vec3(xz,dentHeight,xz));\n\n\tcarve = 999999.0;\n*/\n\t//addLower = 999999.0;\n\t//addLower = min(addLower,bulk);\n\t//carveLower = min(carveLower,bulk);\n\t//addLower = 999999.9;\n\t\n\t//return smin( bulk, add, 1.0 );\n\treturn de;\n}\nfloat BlockId( vec2 pos )\n{\n\t//return 1.0;\n\treturn rand(floor(pos/totalBlock));\n}\n//close to the surface of a building\nfloat DeN( vec3 pos )\n{\n\tfloat blockId1 = BlockId(pos.xz);\n\tpos.x = mod(pos.x,totalBlock);\n\tpos.z = mod(pos.z,totalBlock);\n\tvec4 m = vec4(0);\n\treturn BlockDe(pos, blockId1, m);\n}\n//within city volume\nfloat DeWithin( vec3 pos, vec3 rd, out float maxStep, inout vec4 m )\n{\n\tfloat startBlockX = floor((pos.x)/totalBlock);\n\tfloat startBlockZ = floor((pos.z)/totalBlock);\n\tfloat xDir = rd.x > 0.0 ? 1.0 : -1.0;\n\tfloat zDir = rd.z > 0.0 ? 1.0 : -1.0;\n\tvec3 p1N = normalize(vec3(-1,0,0));\n\tvec3 p2N = normalize(vec3(0,0,-1));\n\tfloat p1Offs = rd.x > 0.0 ? (startBlockX+1.0)*totalBlock : (startBlockX)*totalBlock;\n\tfloat p2Offs = rd.z > 0.0 ? (startBlockZ+1.0)*totalBlock : (startBlockZ)*totalBlock;\n\tfloat e1 = -(dot(p1N,pos) + p1Offs) / (dot(p1N, rd));\n\tfloat e2 = -(dot(p2N,pos) + p2Offs) / (dot(p2N, rd));\n\tmaxStep = min(e1,e2);\n\t\n\tfloat blockId1 = BlockId(pos.xz);\n\tpos.x = mod(pos.x,totalBlock);\n\tpos.z = mod(pos.z,totalBlock);\n\treturn BlockDe(pos, blockId1, m);\n}\n//above city volume\nfloat DeAbove( vec3 pos, vec3 rd, out float maxStep, inout vec4 m )\n{\n\tfloat de;\n\tif( pos.y > maxBlockHeight+0.1 )\n\t{//if ray is above buildings, continue until you're at roof height\n\t\tde = (pos.y-maxBlockHeight) / (abs(rd.y));\n\t\tde = max(de, 0.1);\n\t}\n\telse\n\t{\n\t\treturn DeWithin(pos, rd, maxStep, m);\n\t\t//return DeN(pos);\n\t}\n\treturn maxStep=de;\n}\n\nvec3 N0=vec3(0.0001);\nvec3 N1=vec3(0.0001);\nvec3 N2=vec3(0.0001);\nvec3 N3=vec3(0.0001);\n\nvec4 hit0=vec4(0);\nvec4 hit1=vec4(0);\nvec4 hit2=vec4(0);\nvec4 hit3=vec4(0);\n\nvoid onHit(float de, vec3 p, float rCoC, inout float coverage, vec4 c, inout vec4 material)\n{\n\tvec2 v=vec2(0.5*rCoC,0.0);\n\tvec3 N=normalize(vec3(-DeN(p-v.xyy)+DeN(p+v.xyy),-DeN(p-v.yxy)+DeN(p+v.yxy),-DeN(p-v.yyx)+DeN(p+v.yyx)));\n\t\n\tfloat alpha=(1.0-coverage)*linstep(-rCoC,rCoC,-de);\n\t\n\tmaterial += c*alpha;\n\t//float lit = 1.0 * (dot(N,L)*0.5+0.5);\n\t//float lit = 1.0;\n\t\n\t//col += (N*0.5+0.5) * alpha;\n\t\n//\tcol += lit * vec3(0.5,.5,1.0) * (sin(p.y*0.5)*0.25+0.75) * alpha;\n//\tavgN += N*alpha;\n\tcoverage += alpha;\n\t\n\thit0 = alpha > hit0.w ? vec4(p,alpha) : hit0;\n\thit1 = alpha > hit1.w ? vec4(p,alpha) : hit1;\n\thit2 = alpha > hit2.w ? vec4(p,alpha) : hit2;\n\thit3 = alpha > hit3.w ? vec4(p,alpha) : hit3;\n\t\n\tN0 += N * alpha * c.x;\n\tN1 += N * alpha * c.y;\n\tN2 += N * alpha * c.z;\n\tN3 += N * alpha * c.w;\n}\n\nvec2 GetUv(vec3 N0, vec3 hit0)\n{\n\tN0 = abs(N0);\n\treturn N0.x > N0.y\n\t\t? (N0.z > N0.x ? hit0.xy : hit0.zy)\n\t\t: (N0.z > N0.y ? hit0.xy : hit0.xz);\n}\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n\tconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n\tconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nvec3 DoLighting( vec3 pos, vec3 V, vec3 N, vec3 color, vec2 fragCoord )\n{\n\tfloat specular = 0.0;\n\tfloat diffuse = 0.0;\n\t\n\tvec3 ambientL = normalize(vec3(-1,2,1));\n\tvec3 ambientH = normalize(ambientL + V);\n\t\n\tvec3 L = ambientL;\n\tfloat shadow = 0.0;\n\tfloat t = 1.0;\n\t//pos += N*1.0;\n\tpos += V*1.0;\n\tfor(int i=1;i<SHADOW_ITERATIONS;i++){//march loop\n\t\t\n\t\tvec3 p = pos+L*t;\n\t\tfloat rCoC=CircleOfConfusion(t);\n\t\t\n\t\tfloat maxStep = 9999999.0;\n\t\tvec4 c = vec4(0);\n\t\tfloat de=DeWithin( p, L, maxStep, c );// +0.25*rCoC;\n\t\t\n\t\trCoC = (100.0 - 100.0/(t*0.02));\n\t\tif(de<rCoC){\n\t\t\tshadow += (1.0-sat(de/rCoC))*sat(45.0/t);\n\t\t}\n\t\t\n\t\t//de = de + 1.0*fract(de);// + t;//de;// * 2.0 + 5.0;\n\t\t//de = 15.0 + 15.0*rand(fragCoord.xy*vec2(i));\n\t\t//de = 15.0 + 15.0*fract(abs(pos.z*de+V.x));\n\t\tde = max( de * 2.0, 10.0 );\n\t\tde = min(de,maxStep);\n\t\tde += 1.0*rand(fragCoord.xy*vec2(i));\n\t\tt += de;\n\t}\n\tshadow = 1.0-sat(shadow)*0.55;\n\t\n\tdiffuse += (dot(N,ambientL)*0.5+0.5) * shadow;\n\tspecular += sat(dot(N,ambientL))* pow(sat(dot(N,ambientH)), 10.0) * shadow;\n\t\n\t//return vec3(shadow);\n\t\n\tfloat specMask = sat(1.0-dot(vec3(1./3.), color));\n\treturn diffuse * color + specular * specMask;\n}\n\nvec3 RoadTexture(vec3 pos)\n{\n\tfloat f = abs(sin(pos.x*10.0))*abs(sin(pos.z*12.0));\n\tvec3 road = mix(vec3(0.10,0.12,0.13), vec3(0.13,0.1,0.08), f);\n\t\n\tvec2 xz = abs(mod(pos.xz, totalBlock)-totalBlock*0.5)-blockWidth*0.5;\n\txz /= halfStreetWidth;\n\t\n\tconst float lineWidth = 0.1;\n\tconst float lnpcnt = 0.5*lineWidth/halfStreetWidth;\n\tvec3 paint = vec3(0.5,0.5,0.4);\n\tfloat lane;\n\t\n\troad = mix(road, paint, softstep(1.0-lnpcnt*5.0,xz.x) );\n\tlane = 3.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 6.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 9.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 12.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt*5.0, 1.0-lane+lnpcnt*5.0, xz.x) );\n\t\n\troad = mix(road, paint, softstep(1.0-lnpcnt*5.0,xz.y) );\n\tlane = 3.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 6.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 9.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 12.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt*5.0, 1.0-lane+lnpcnt*5.0, xz.y) );\n\treturn road;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n#ifdef ORBIT_CAM\n\tvec3 ro = vec3(sin(time*0.5)*1000.0, 1000, cos(time*0.5)*1000.0);\n\tvec3 ta = vec3(0, (sin(time)*0.5+0.5)*200.0, 0);\n#else\n\tvec3 ro = vec3(pow(sin(time*0.5),3.0)*5.0+6.0, 1.4, time*100.0);\n\tvec3 ta = ro + vec3(sin(time*0.8)*3.0,(sin(time)*0.5+0.5)*2.0,10);\n#endif\n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.0*cw );\n\t\n\tfloat distToGround = - (dot(vec3(0,1,0),ro) + 0.0) / (dot(vec3(0,1,0), rd));\n\tdistToGround = distToGround < 0.0 ? 999999.0 : distToGround;\n\t\n\tfloat coverage = 0.0;\n\tvec4 material = vec4(0.001, 0, 0, 0);\n\tvec3 col = vec3(0);\n\tvec4 c;\n\tfloat lastT = 0.0;\n\tfloat t=0.0;//distance traveled\n\t//float didHit = 0.0;\n\tfor(int i=0;i<ITERATIONS;i++){//march loop\n\t\tif( t >= distToGround || coverage > 0.99 ) continue;\n\t\t\n\t\tvec3 pos = ro+rd*t;\n\t\tfloat rCoC=CircleOfConfusion(t);\n\t\t\n\t\tfloat maxStep = 999999.0;\n\t\tc = vec4(0);\n\t\tfloat de=DeAbove( pos, rd, maxStep, c ) +0.25*rCoC;\n\t\t//float de=DeN( pos ) +0.25*rCoC;\n\t\t\n\t\tif(de<rCoC){\n\t\t\tonHit(de, pos, rCoC, coverage, c, material);\n\t\t}\n\t\t\n\t\tde=abs(de)*(0.5+0.5*rand(fragCoord.xy*vec2(i)));\n\t\tde = min(de, maxStep+halfStreetWidth);\n\t\t\n\t\tlastT = t;\n\t\tt += de;\n\t}\n\t\n\tt = min(t,abs(distToGround));\n\tvec3 pos = ro + rd*t;\n\t\n\tfloat bgAlpha = 1.0-coverage;\n\t\n//\t\tcol += vec3(0.5,.5,1.0) * (sin(pos.y*0.5)*0.25+0.75) * bgAlpha;\n\t\n\t//vec3 N = normalize(avgN);\n\tN0 = normalize(N0);\t\n\tN1 = normalize(N1);\t\n\tN2 = normalize(N2);\t\n\tN3 = normalize(N3);\n\t\n\tvec3 _mtl0 = vec3(0.34, 0.40, 0.24);\n\tvec3 _mtl1 = vec3(0.38, 0.54, 0.51);\n\tvec3 _mtl2 = vec3(0.38, 0.40, 0.61);\n\tvec3 _mtl3 = vec3(0.03, 0.42, 0.64);\n\t/*vec3 mtl0 = vec3(1, 0, 0);\n\tvec3 mtl1 = vec3(0, 1, 0);\n\tvec3 mtl2 = vec3(0, 0, 1);\n\tvec3 mtl3 = vec3(0, 0, 0);*/\n\t\n\tfloat id = BlockId(pos.xz);\n\t\n\tvec3 mtl0 = mix(_mtl0, _mtl1, fract(id*2.0));\n\t     mtl0 = mix( mtl0, _mtl3, fract(id*2.0+1.0));\n\tvec3 mtl1 = mix(_mtl1, _mtl2, fract(id*4.0+0.4));\n\t     mtl1 = mix( mtl1, _mtl0, fract(id*1.0+0.3));\n\tvec3 mtl2 = mix(_mtl2, _mtl3, fract(id*2.0+0.7));\n\t     mtl2 = mix( mtl2,  mtl1, fract(id*0.1+0.7));\n\tvec3 mtl3 = mix(_mtl3, _mtl0, fract(id*8.0+0.6));\n\t     mtl3 = mix( mtl3, _mtl1, fract(id*0.5+0.6));\n\t\n\tif( pos.y < 0.01 )\n\t{\n\t\tmtl3 = RoadTexture(pos) * bgAlpha;\n\t\tmaterial = vec4(0,0,0,1);\n\t\tN3 = vec3(0,1,0);\n\t\tcoverage = 1.0;\n\t}\n//\telse if( rd.y > 0.0 && t > 1000.0 )\n//\telse if( rd.y > 0.0 && pos.y >= maxBlockHeight-1.1 )\n\telse if( pos.y >= maxBlockHeight-10.1 )\n\t{\n\t\tvec3 sky = mix( vec3(.17, .13, .3), vec3(.1, .13, .47), rd.y );\n\t\tcol += sky * bgAlpha;\n\t}\n\telse\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tfloat rCoC=CircleOfConfusion(t);\n\t\tonHit(0.0, pos, rCoC, coverage, c, material);\n\t}\n\t\n\thit0.xyz = pos;\n\thit1.xyz = pos;\n\thit2.xyz = pos;\n\thit3.xyz = pos;\n\t\n\t//vec3 u = cross(N0, vec3(0,0,1));\n\t//vec3 v = cross(N0, u);\n\t//vec2 uv0 = vec2( dot(hit0.xyz,u), dot(hit0.xyz,v) );\n\t\t\t\n\tvec2 uv0 = GetUv(N0, hit0.xyz);\n\tvec2 uv1 = GetUv(N1, hit1.xyz);\n\tvec2 uv2 = GetUv(N2, hit2.xyz);\n\tvec2 uv3 = GetUv(N3, hit3.xyz);\n\t//mtl0 = vec3( fract(uv0*0.1), 0 );\n\t//mtl0 = v*0.5+0.5;\n\t//mtl0 = fract(hit0.xyz*0.1);\n//\tmtl0 = texture(iChannel0, uv0*0.1).rgb;\n//\tmtl1 = texture(iChannel1, uv1*0.1).rgb;\n//\tmtl2 = texture(iChannel2, uv2*0.1).rgb;\n//\tmtl3 = texture(iChannel3, uv3*0.1).rgb;\n\t\n\t//uv0.x *= fbm4(uv0.xy*0.01);\n\tmtl0 *= (fbm4(uv0*0.041)*0.25+0.75) * vec3(1);\n\tmtl1 *= (fbm4(uv1*0.031)*0.25+0.75) * vec3(1);\n\tmtl2 *= (fbm4(uv2*0.011)*0.25+0.75) * vec3(1);\n\tmtl3 *= (fbm4(uv3*0.021)*0.25+0.75) * vec3(1);\n\t\n\tmaterial /= dot(vec4(1),material);\n\tmaterial *= coverage;\n\t\n\tvec3 V = -normalize(pos - ro);\n\t\n\tcol.rgb += DoLighting( pos, V, N0, mtl0, fragCoord ) * material.x;\n\tcol.rgb += DoLighting( pos, V, N1, mtl1, fragCoord ) * material.y;\n\tcol.rgb += DoLighting( pos, V, N2, mtl2, fragCoord ) * material.z;\n\tcol.rgb += DoLighting( pos, V, N3, mtl3 , fragCoord) * material.w;\n\n\t//col = col * (dot(N,L)*0.5+0.5);\n//\tcol = mix( col, vec3(1,0,0), coverage>0.0?0.0:1.0 );\n\tfragColor = vec4(col,1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdj3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 435, 468, 601, 676], [677, 677, 718, 718, 766], [767, 767, 787, 858, 929], [931, 931, 972, 972, 1065], [1066, 1066, 1111, 1111, 1151], [1152, 1152, 1183, 1183, 1221], [1222, 1222, 1253, 1253, 1349], [1350, 1350, 1428, 1428, 1501], [1502, 1502, 1541, 1541, 1583], [1584, 1584, 1636, 1636, 1693], [1697, 1697, 1753, 1753, 3626], [3627, 3627, 3654, 3669, 3708], [3709, 3746, 3769, 3769, 3924], [3925, 3946, 4016, 4016, 4707], [4708, 4728, 4797, 4797, 5074], [5242, 5242, 5335, 5335, 6044], [6046, 6046, 6078, 6078, 6192], [6194, 6194, 6220, 6220, 6257], [6259, 6259, 6281, 6281, 6528], [6530, 6530, 6552, 6552, 6956], [6959, 6959, 7032, 7032, 8123], [8125, 8125, 8153, 8153, 9509], [9511, 9511, 9568, 9568, 13730]], "test": "ok"}
{"id": "XdlSRr", "name": "Simple Voronoi", "author": "Nrx", "description": "Not much to say: it's a basic Voronoi diagram...", "tags": ["voronoi"], "likes": 19, "viewed": 792, "published": "Public API", "date": "1395909642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Concept from: http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n// Relation between the \"HASH_MAGNITUDE\" (M) and \"KERNEL\" (K):\n// - In a given cell C1, the greatest distance from a point P1 of this cell to the cell's reference point R1 is D:\n//   D = SQRT2 * (M / 2 + 1 / 2)\n//   D = (M + 1) * SQRT2 / 2\n//   (This happens when P1 is in a corner of C1, and R1 is as far as possible in the opposite direction.)\n// - So, the farther other reference point R2 that can be closer to P1 is somewhere on the circle of center P1 and radius D.\n// - The center of the cell C2 which the reference point is R2 is maximum at a distance M / 2 from R2.\n// - The relative position of the center of C2 compare to C1 is K:\n//   K = floor (1 / 2 + sqrt ((D + M / 2) ^ 2 - (1 / 2) ^ 2))\n//   K = floor ((1 + sqrt (((M + 1) * SQRT2 + M) ^ 2 - 1)) / 2)\n// - If we neglect \"- 1\" in the square root, we can approximate K:\n//   K = floor ((1 + (M + 1) * SQRT2 + M) / 2)\n//   K = floor ((M + 1) * (SQRT2 + 1) / 2)\n// - Reciprocally, if we set K, we can compute the maximum value of M:\n//   M < 2 * (K + 1) / (SQRT2 + 1) - 1\n// Having said that, you can actually use greater values for M without too much risk, as the relations given here above are just for the worst case (i.e. theoretical).\n\n#define SQRT2\t1.41421356237\n#define SQRT3\t1.73205080757\n\n#define SIZE \t\t\t15\n#define HASH_MAGNITUDE\t(6.0 / (SQRT2 + 1.0) - 1.0) // Perfect if: HASH_MAGNITUDE < 2 * (KERNEL + 1) / (SQRT2 + 1) - 1\n#define KERNEL\t\t\t2 // Perfect if: KERNEL >= floor ((HASH_MAGNITUDE + 1) * (SQRT2 + 1) / 2)\n\n#define BORDER\n//#define CENTER\n#define DISTANCE\n#define STRIPS\n#define HEXAGONAL\n\nfloat hash (in int index) {\n\tfloat x = float (index);\n\treturn HASH_MAGNITUDE * 0.5 * sin (sin (x) * x + sin (x * x) * iTime);\n}\n\nvec2 pointInCell (in ivec2 cell) {\n\tint index = cell.x + cell.y * SIZE;\n\tvec2 point = vec2 (cell);\n\t#ifdef HEXAGONAL\n\tpoint.x += fract (point.y * 0.5) - 0.25;\n\t#endif\n\treturn point + vec2 (hash (index), hash (index + 1)) * (0.5 + 0.5 * sin (iTime * 0.5));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = float (SIZE) * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t#ifdef HEXAGONAL\n\tp.y /= SQRT3 * 0.5;\n\t#endif\n\tivec2 pCell = ivec2 (floor (p + 0.5));\n\n\tfloat dMin = HASH_MAGNITUDE + 1.0;\n\tvec2 pqMin;\n\tivec2 minCell;\n\tfor (int y = -KERNEL; y <= KERNEL; ++y) {\n\t\tfor (int x = -KERNEL; x <= KERNEL; ++x) {\n\t\t\tivec2 qCell = pCell + ivec2 (x, y);\n\t\t\tvec2 pq = pointInCell (qCell) - p;\n\t\t\t#ifdef HEXAGONAL\n\t\t\tpq.y *= SQRT3 * 0.5;\n\t\t\t#endif\n\t\t\tfloat d = dot (pq, pq);\n\t\t\tif (d < dMin) {\n\t\t\t\tdMin = d;\n\t\t\t\tpqMin = pq;\n\t\t\t\tminCell = qCell;\n\t\t\t}\n\t\t}\n\t}\n\tint col = minCell.x + minCell.y * SIZE;\n\tvec4 color = 0.6 + vec4 (hash (col), hash (col + 1), hash (col + 2), 0.0) * 0.8 / HASH_MAGNITUDE;\n\n\t#ifdef CENTER\n\tdMin = sqrt (dMin);\n\t#else\n\tdMin = HASH_MAGNITUDE + 1.0;\n\t#endif\n\n\t#ifdef BORDER\n\tfor (int y = -KERNEL; y <= KERNEL; ++y) {\n\t\tfor (int x = -KERNEL; x <= KERNEL; ++x) {\n\t\t\tivec2 qCell = pCell + ivec2 (x, y);\n\t\t\tif (qCell != minCell) {\n\t\t\t\tvec2 pq = pointInCell (qCell) - p;\n\t\t\t\t#ifdef HEXAGONAL\n\t\t\t\tpq.y *= SQRT3 * 0.5;\n\t\t\t\t#endif\n\t\t\t\tdMin = min (dMin, dot (0.5 * (pqMin + pq), normalize (pq - pqMin)));\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n\n\tcolor *= smoothstep (0.02, 0.1, dMin);\n\n\t#ifdef DISTANCE\n\tcolor *= 0.9 + 0.1 * sin (dMin * 40.0);\n\t#endif\n\n\t#ifdef STRIPS\n\tfloat strip = float (col);\n\tfloat stripCos = cos (strip);\n\tfloat stripSin = sin (strip);\n\tstrip = mix (1.0, sin (40.0 * (pqMin.x * stripCos - pqMin.y * stripSin)), mod (strip * 0.5, 2.0));\n\tstrip *= sin (40.0 * (pqMin.x * stripSin + pqMin.y * stripCos));\n\tcolor *= 0.8 + 0.2 * strip;\n\t#endif\n\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1591, 1659, 1686, 1686, 1786], [1788, 1788, 1822, 1822, 2045], [2047, 2047, 2103, 2103, 3683]], "test": "ok"}
{"id": "XdS3D3", "name": "Atomium", "author": "guil", "description": "A variation of my previous shader using  a different formula", "tags": ["3d", "fractal"], "likes": 0, "viewed": 211, "published": "Public", "date": "1394015364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Based on Clouds by inigo quilez : https://www.shadertoy.com/view/XslGRr\n\nvec3  c =  vec3(1.05);\nvec3  c1 =  vec3(.7);\nconst int MaxIter = 12;\nvec3 sundir = vec3(-1.0,0.0,0.0);\nfloat fog = .65+.6*cos(.3*iTime);\nfloat g=.8;\nfloat h=1.;\nfloat zoom=.25;\n\n\n\nvec4 map( vec3 p)\n{\n\tfloat dr = 1.0;\n\tvec3 ot = vec3(1000.0); \n\tfloat r2;\n\tfor( int i=0; i<MaxIter;i++ )\n\t{\n            \n        r2 = dot(p,p);\n        if(r2>100.)continue;\n\t\t\n        ot = min( ot, abs(p) );\n\n\t\t//Box fold       \n       //p = clamp(p,-c1,  c1) * 2.0 - p;\n\n\t\t//Sphere fold\n\t\tfloat k = max(h/r2,.1)*g;p *= k;dr *= k;\n\t\t\n\t\t//Exotic squaring\n\t\tp=abs(p*p.zxy)-c;dr*=2.*length(p);\t\n\t}\n\t\n\tfloat d;\n\t//d = (abs(p.x)+abs(p.y))*length(p)/dr;\t\n\t//d = (length(p.xz)*abs(p.y)+length(p.xy)*abs(p.z)+length(p.yz)*abs(p.x))/dr;\n\t//d = 1.5*(length(p.xz))*length(p.xy)/dr;\n\td = sqrt(r2)*log(r2)/dr;\n\t//d = 2.*length(p)/dr;\n\treturn vec4(ot,d);\n\t\n}\n\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\tfloat t = 0.0;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.a > 0.99 ) continue;\n\n\t\tvec3 pos = ro + t*rd;\t\t\n\t\tvec4 col = map( pos );\n\t\tfloat d = col.a;\n\t\tcol.a = 0.035*fog/d;\n\t\tcol.rgb *= col.a;\n\n\t\tif(dot(pos,pos)<11.)sum = sum + col*(1.0 - sum.a);\t\n     \n\t\tt += min(0.1,d*.3);\n\t\t\n\t}\n\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*(iMouse.xy) / iResolution.xy+sin(.1*iTime);\n    \n    // camera\n    vec3 ro =zoom* 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\n    vec4 res = raymarch( ro, rd );\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\tcol = mix( col, res.xyz, res.w );\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdS3D3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 343, 362, 362, 987], [991, 991, 1032, 1032, 1404], [1406, 1406, 1463, 1463, 2316]], "test": "ok"}
{"id": "XdXSR8", "name": "noise histogramm 2", "author": "FabriceNeyret2", "description": "Evaluates histogramm of Perlin noise algorithms.\nIn theory fbm should be Gaussian...\nTry larger STEP to better average.", "tags": ["noise", "perlin", "histogramm"], "likes": 12, "viewed": 2213, "published": "Public API", "date": "1396274086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SAMPLE 200      // per 1x1 pixel bin\n#define STEP 32.        // bin width\n#define LAZZY 1         // lazzy exact noise evaluation\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\n#define NOISE_SRC 1  \t// 0: texture 1: math\n\n\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\n\n\n#define ANIM 1          \n#define PI 3.14159\n\nfloat t;\nvec2 FragCoord;\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )  // base rand in [0,1]; \n{\n#if NOISE_SRC==0\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\n#elif NOISE_SRC==1\n\treturn fract(sin(n-765.36334)*43758.5453);\n#endif\n   \n    \n}\n\nfloat noise( in vec3 x ) // base noise in [0,1]; \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#if NOISE_TYPE==1\n\treturn res;\n#elif NOISE_TYPE==2\n\treturn abs(2.*res-1.);\n#elif NOISE_TYPE==3\n\treturn 1.-abs(2.*res-1.);\n#endif\n}\n\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n\n// for noise to be thresholded, we not always need to compute high freq\n\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\n{\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\n\tfloat s=1.,f,r=1.,t;\n\t\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\n\n    return f;\n}\n\n\n// calc histogramm of noise\n\nfloat histogramm(vec2 uv) {\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\n\tfloat s = 0., q=0., n;\n#if ANIM\n  float t = iTime;\n#else\n  float t = 0.; \n#endif\t\n\tfor (int j=0; j<= SAMPLE; j++)\n\t{\n\t\tfloat y = float(j)/float(SAMPLE);\n#if !LAZZY\n\t\tn = fbm(8.*vec3(0.,y,t));\n#else\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\n#endif\n\n\t\tif (abs(n-uv.x) < .5*dx) s++;\n\t\tq++;\n\t}\n\treturn .1*s/(q*dx);\n}\n\n\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\n\nfloat smoothf(float v)\n{\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\n\n\treturn v + SMOOTH*(vx+vy)/3.;\n}\n\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    FragCoord=fragCoord;\n\tvec3 col=vec3(0.);\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\n\t\n\t\n\tfloat t = histogramm(uv);\n\t\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\n\t\n\tfragColor = vec4(col,1.); \n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXSR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 713, 761, 761, 904], [906, 906, 957, 957, 1475], [1477, 1477, 1539, 1539, 1722], [1785, 1858, 1934, 1934, 2312], [2315, 2344, 2371, 2371, 2737], [2740, 2811, 2835, 2835, 2972], [2974, 2988, 3045, 3045, 3623]], "test": "ok"}
{"id": "XdXXzn", "name": "specular", "author": "kaminate", "description": "mod", "tags": ["raymarch"], "likes": 1, "viewed": 385, "published": "Public", "date": "1395554332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float gRaymarchEpsilon = 0.001;\n//float gMusicSamplert\nvec2 GetUV();\nfloat plane(vec3 p, vec3 n)\n{\n\treturn dot(p,n);\n}\nfloat sphere(vec3 p, float radius)\n{\n\tfloat modval = 2. * radius + radius;\n\tp.xz = mod(p.xz, modval) - modval / 2.;\n\t\n\treturn length(p) - radius;\n}\n\n// distance estimator\nfloat DE(vec3 p)\n{\n\tfloat s0 = sphere(p, 0.25);\n\tfloat p0 = plane(p, normalize(vec3(0,1,0.1)));\n\treturn min(s0, p0);\n\treturn s0;\n}\n\nvoid raymarch( vec3 ray_start, vec3 ray_dir, out float depth, out float dist)\n{\n   vec3 point = ray_start;\n   \n\tdist = 1.0;\n\tdepth = 0.0;\n\tfor (int i = 0; i < 100; ++i)\n\t{\n\t\tif (dist < gRaymarchEpsilon) continue;\n\t\tvec3 point = ray_start + ray_dir * depth;\n\t\tdist = DE(point);\n\t\tdepth += dist;\n\t}\n}\n\nvec2 GetUV()\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = gl_FragCoord.xy;\n\tuv /= iResolution.xy;\n\tuv *= 2.0;\n\tuv -= 1.0;\n\tuv.x *= aspect;\n\t\n\treturn uv;\n}\n\nvec3 GetNormal(vec3 point)\n{\n\tfloat epsilon= 0.1;\n\tvec3 dx = vec3(epsilon,0,0);\n\tvec3 dy = vec3(0,epsilon,0);\n\tvec3 dz = vec3(0,0,epsilon);\n\treturn normalize(vec3(\n\t\tDE(point + dx)- DE(point - dx),\n\t\tDE(point + dy)- DE(point - dy),\n\t\tDE(point + dz)- DE(point - dz)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = GetUV();\n\t\t\n\tfloat camZ = 0.115 * sin(iTime) + 0.25 + 1. + 0.1;\n\tfloat camY = 0.115 * sin(iTime) + 0.45;\n\tvec3 camPos = vec3(0,camY, camZ);\n\tvec3 camDir = normalize(-camPos);\n\t\n    vec3 rayStart = camPos;\n    vec3 rayDir = normalize(vec3(uv,0) - rayStart);\n    \n    vec3 color = vec3(0);\n\tfloat depth;\n\tfloat dist;\n    raymarch(rayStart, rayDir, depth, dist);\n    if (dist < gRaymarchEpsilon)\n\t{\n\t\tvec3 n = GetNormal(rayStart + rayDir * depth);\n\t\tvec3 diffuseCol = vec3((uv + 1.) / 2., 0);\n\t\tvec3 specularCol = vec3(0.7,0.7,0.7);\n\t\tfloat shinyness = 128.;\n\t\t\n\t\tvec3 l = normalize(vec3(.5,1,1));\n\t\tvec3 dPara = n * dot(n, camDir);\n\t\tvec3 dPerp = camDir - dPara;\n\t\tvec3 r = normalize(-dPara + dPerp);\n\t\tcolor += diffuseCol * max(dot(n,l), 0.0);\n\t\tcolor += specularCol * pow(max(dot(n, r), 0.0), shinyness);\n\t\t\n\t}\n\telse\n\t{\n\t\t//color.xy += uv;\n\t}\n\tfragColor = vec4(color,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 69, 98, 98, 118], [119, 119, 155, 155, 266], [268, 290, 308, 308, 420], [422, 422, 501, 501, 720], [722, 722, 736, 736, 891], [893, 893, 921, 921, 1162], [1164, 1164, 1221, 1221, 2108]], "test": "ok"}
{"id": "XdXXzr", "name": "Electric Sinusoid", "author": "ddoodm", "description": "My first Shadertoy! It's pretty terrible, but it is my first standalone fragment shader. ", "tags": ["2d", "line", "glow", "sine"], "likes": 55, "viewed": 2480, "published": "Public", "date": "1395655644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\t\n\tfloat bg = (cos(uv.x*3.14159*2.0) + sin((uv.y)*3.14159)) * 0.15;\n\t\n\tvec2 p = uv*2.0 - 1.0;\n\tp *= 15.0;\n\tvec2 sfunc = vec2(p.x, p.y + 5.0*sin(uv.x*10.0-iTime*2.0 + cos(iTime*7.0) )+2.0*cos(uv.x*25.0+iTime*4.0));\n\tsfunc.y *= uv.x*2.0+0.05;\n\tsfunc.y *= 2.0 - uv.x*2.0+0.05;\n\tsfunc.y /= 0.1; // Thickness fix\n\t\n\tvec3 c = vec3(abs(sfunc.y));\n\tc = pow(c, vec3(-0.5));\n\tc *= vec3(0.3,0.85,1.0);\n\t//c += vec3(bg, bg*0.8, bg*0.4);\n\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 595]], "test": "ok"}
{"id": "Xs23D3", "name": "Infinite Perlin Noise", "author": "LoubetG", "description": "Infinite multiscale Perlin noise.\nBased on Inigo Quilez's code (https://www.shadertoy.com/view/XslGRr).\nC key changes the colormap.", "tags": ["fractal", "noise", "perlin", "filtering", "multiscale"], "likes": 54, "viewed": 2153, "published": "Public", "date": "1394620066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- Fractal noise simulating heterogeneous density in galactic clouds\n// ---   -> help from Fabrice Neyret, https://www.shadertoy.com/user/FabriceNeyret2\n// ---   -> noise functions from Inigo Quilez, https://www.shadertoy.com/view/XslGRr\n\n\n// Number of computed scales\n#define NbScales 22.\n\n// Id of the lowest displayed scale (debug)\n#define FirstScale 0.\n\n// Anti aliasing\n#define LimitDetails 2.5\n#define SmoothZone 100.\n\n// Manual Zoom / Auto Zoom\n#define Anim 1\n\n// Colormap\n#define ClampLevel 1.\n\n#define ZoomDistance 10.\n\n// Size of the first Perlin Noise grid (debug)\n#define FirstDivision 8.\n\n\n// 0 : multiplicative\n// 1 : additive\n#define Mode 0\n\n#define GazConcentration 0.\n\n// Caracteristic ratio of the frequencies (0.5 for octaves)\n#define fRatio .5\n\n\n\nbool keyToggle(int ascii) {\n\treturn !(texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor(p), f = fract(p);\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n\n// -----------------------------------------------\n\nvec3 colormap(float value) {\n\tfloat maxv = ClampLevel;\n\tvec3 c1,c2;\n\tfloat t;\n\tif (value < maxv / 3.) {\n\t\tc1 = vec3(1.);   \t   c2 = vec3(1., 1., .5);\n\t\tt =  1./3.;\n\t} else if (value < maxv * 2. / 3.) {\n\t\tc1 = vec3(1., 1., .5); c2 = vec3(1., 0,  0.);\n\t\tt =  2./3. ;\n\t} else {\n\t\tc1 = vec3(1., 0., 0.); c2 = vec3(0.);\n\t\tt =  1.;\n\t}\n\tt = (t*maxv-value)/(maxv/3.);\n\treturn t*c1 + (1.-t)*c2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { // --------------------------------------\n    \n    float t = iTime;\n    \n    vec2 uv = fragCoord.xy/ iResolution.y;\n\n\tfloat d = 1.; // initial density\n\t\n #if Anim\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\n\tfloat n_tiles_level_1 = exp(cycle*cycle*ZoomDistance)*pow(2.,FirstDivision);\n#else\n\tfloat n_tiles_level_1 = exp(iMouse.x/iResolution.x*ZoomDistance)*pow(2.,FirstDivision);\n#endif\n\t\n\t// zoom and centering\n\tuv = (uv - vec2(.9,.5))*n_tiles_level_1 + vec2(.9,.5);\n\t\n\tfloat theta = 4.+.008*t; // some rotations, not necessary\n    mat2 m = fRatio*mat2( cos(theta),sin(theta), \n\t\t\t\t\t -sin(theta),cos(theta) );\n\t\t\n\t// computation of the multiplicative noise\n\tfloat q = 1.;\n\tfor (float i = 0.; i < NbScales; i++) {\n\t\tif (d<1e-2) continue;\n\t\t\n\t\t// multiply the amplitude to maintain the total density\n\t\tfloat c = (i+1.< NbScales) ? 2. : 1.;\n\t\t\n\t\tfloat nn = noise(uv + 10.7*i*i);\n\n\t\tfor (float j = 0.; j < GazConcentration; j++) {\n\t\t\tnn = sin(nn*3.14159265359/2.);\n\t\t}\n\t\t\t\n#if Mode == 0\n\t\tfloat n = c* 0.5*(1.+nn);\n#else\n\t\tfloat n = nn;\n#endif\t\n\t\t\n\t\t// compute only the visible scales\n\t\tfloat crit = n_tiles_level_1 *q - iResolution.x/LimitDetails;\n\t\tif (crit < SmoothZone && i >= FirstScale) {\n\t\t\tif (crit>0.) {  // avoid aliasing\n\t\t\t\tfloat t = crit/SmoothZone;\t\t\t\t\n\t\t\t\tn = n*(1.-t);\n#if Mode == 0\n\t\t\t\tn += t;\n#endif\n\t\t\t}\n\t\t\t\n#if Mode == 0\n\t\t\td *= n;\n#else\n\t\t\td += n*(0.5);\n#endif\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\n\t\tuv = m*uv; q*= fRatio; // go to the next octave\n\t}\n\t\n\td = clamp(d,0.0,d);\n\tfragColor.xyz = (keyToggle(67)) ? vec3(exp(-d)) :colormap(exp(-d));\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs23D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[690, 771, 798, 798, 872], [874, 1065, 1086, 1111, 1233], [1234, 1234, 1260, 1260, 1624], [1627, 1679, 1707, 1707, 2066], [2068, 2068, 2125, 2167, 3671]], "test": "ok"}
{"id": "Xs23W3", "name": "[Study] Triangle patterns", "author": "vug", "description": "A study for finding whether the pixel is inside one of the given set of triangles, and painting the triangles. A Delanuay triangulation of random points is done via Python beforehand and triangles are loaded by assignment.", "tags": ["2d"], "likes": 21, "viewed": 1222, "published": "Public", "date": "1394386173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWOPI 6.28318530718\n\n// Please try METHOD = 0, 1 and 2\n#define METHOD 0\n\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat triangle(vec2 r, vec2 A1, vec2 A2, vec2 A3) {\n\tvec2 q = r - A3;\n\tvec2 A1q = A1 - A3;\n\tvec2 A2q = A2 - A3;\n\tmat2 Bq = mat2(A1q, A2q);\n\tvec2 c = inverse(Bq)*q;\n\t\n\tfloat ret = 0.0;\n\tif(c.x>0. && c.y>0.0 && c.x+c.y<1.0) {\n\t\t// solid color\n\t\t//ret = 1.0;\n\t\t// darker towards edges\n\t\tfloat x = c.x*c.y*(1.-c.x-c.y)*75.;\n\t\t//x = 1.0-smoothstep(0.2, 5.8, x);\n\t\tret = pow(x,0.25);\n\t\t//ret = pow((1.0-c.x*c.y*(1.-c.x-c.y)),64.);\n\t\tret -= 0.5*pow(texture(iChannel0, 0.5*c).x, 4.0 );\n\t}\n\t\n\t\t\n\treturn ret;\n}\n\nfloat triangle2(vec2 r, vec2 A1, vec2 A2, vec2 A3) {\n\tmat2 B = mat2(A1-A3, A2-A3);\n\tvec2 c = inverse(B)*(r-A3);\n\t\n\tfloat ret = 0.0;\n\tif(c.x>0. && c.y>0.0 && 1.-c.x-c.y>0.0) {\n\t\tret = 1.0;\n\t}\n\treturn ret;\n}\n\nfloat triangle3(vec2 r, vec2 A3, mat2 inv) {\n\tvec2 c = inv*(r-A3);\n\t\n\tfloat ret = 0.0;\n\tif(c.x>0. && c.y>0.0 && 1.-c.x-c.y>0.0) {\n\t\t// solid color\n\t\t//ret = 1.0;\n\t\t// darker towards edges\n\t\tret = pow(c.x*c.y*(1.-c.x-c.y)*75.,1.15+sin(iTime));\n\t}\n\treturn ret;\t\n}\n\n\n// a new method to test being inside of triangle\n// no need of matrices etc. uses vectors and trigonometry\n//\n// Hmm... I expected this to be faster than matrix method,\n// but I was wrong. I don't get it. :-(\nfloat triangle4(vec2 r, vec2 A1, vec2 A2, vec2 A3) {\n\tfloat ret = 0.0;\n\t// Draw arrows from pixel to vertices\t\n\tvec2 A1p = A1 - r;\n\tvec2 A2p = A2 - r;\n\tvec2 A3p = A3 - r;\n\t// normalize them\n\tvec2 A1pn = normalize(A1p);\n\tvec2 A2pn = normalize(A2p);\n\tvec2 A3pn = normalize(A3p);\n\t// find the angles between the arrows\n\tfloat an12 = acos(dot(A1pn, A2pn));\n\tfloat an23 = acos(dot(A2pn, A3pn));\n\tfloat an31 = acos(dot(A3pn, A1pn));\t\n\t\n\t// if they add up to 2Pi then inside the triangle!\n\tif( abs(an12+an23+an31-TWOPI) < 0.01 ) {\n\t\t//float man = max(an12, an23);\n\t\t//man = max(man, an31);\n\t\tret = 1.0;\n\t\t//float col = 1. - man/PI;\n\t\t//col = pow(col, .4)*1.;\n\t\t//ret = (sin(man));\t\n\t}\n\treturn ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 r = 2.0*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\n\tvec3 pixel = vec3(0.0, 0.1, 0.0);\n\nconst int nPoints = 20;\nvec2 pt[20];\nconst int nTriangles = 31;\nivec3 triangles[31];\nmat3 tri[31];\nmat2 invB[31];\n\t\n#if METHOD == 0\npt[0] = vec2(-0.752524495777,0.276016142992);\npt[1] = vec2(-0.545694726988,0.507777307568);\npt[2] = vec2(0.0344987625226,-0.306673145755);\npt[3] = vec2(-0.297237538054,0.191710047873);\npt[4] = vec2(-0.715035346718,0.0364155198627);\npt[5] = vec2(0.612024151395,0.536568473836);\npt[6] = vec2(-0.40447145914,-0.79573858745);\npt[7] = vec2(-0.0664654101251,0.789470572312);\npt[8] = vec2(0.262284652061,-0.61074282809);\npt[9] = vec2(-0.350794881771,0.986410561889);\npt[10] = vec2(-0.794242268159,0.00942264957239);\npt[11] = vec2(0.45294387004,0.544629519029);\npt[12] = vec2(-0.670283449528,0.248633296271);\npt[13] = vec2(0.132599909009,-0.241305025684);\npt[14] = vec2(0.0758491466031,-0.370676582564);\npt[15] = vec2(-0.251344572955,0.381006780584);\npt[16] = vec2(-0.48716276886,0.84889489905);\npt[17] = vec2(-0.402684172294,0.388539347107);\npt[18] = vec2(0.851456864277,0.970948923036);\npt[19] = vec2(-0.392850985248,-0.651126446093);\ntriangles[0] = ivec3(19,6,10);\ntriangles[1] = ivec3(8,19,6);\ntriangles[2] = ivec3(11,7,18);\ntriangles[3] = ivec3(9,7,18);\ntriangles[4] = ivec3(14,8,13);\ntriangles[5] = ivec3(14,8,19);\ntriangles[6] = ivec3(4,19,10);\ntriangles[7] = ivec3(5,8,18);\ntriangles[8] = ivec3(5,11,18);\ntriangles[9] = ivec3(5,8,13);\ntriangles[10] = ivec3(5,11,13);\ntriangles[11] = ivec3(15,11,7);\ntriangles[12] = ivec3(15,3,13);\ntriangles[13] = ivec3(15,11,13);\ntriangles[14] = ivec3(2,14,19);\ntriangles[15] = ivec3(2,4,19);\ntriangles[16] = ivec3(2,4,3);\ntriangles[17] = ivec3(2,3,13);\ntriangles[18] = ivec3(2,14,13);\ntriangles[19] = ivec3(16,9,7);\ntriangles[20] = ivec3(16,15,7);\ntriangles[21] = ivec3(1,16,15);\ntriangles[22] = ivec3(12,4,3);\ntriangles[23] = ivec3(17,15,3);\ntriangles[24] = ivec3(17,1,15);\ntriangles[25] = ivec3(17,12,3);\ntriangles[26] = ivec3(17,12,1);\ntriangles[27] = ivec3(0,1,16);\ntriangles[28] = ivec3(0,12,1);\ntriangles[29] = ivec3(0,4,10);\ntriangles[30] = ivec3(0,12,4);\n#else\ntri[0] = mat3(vec3(-0.392850985248,-0.651126446093,0.0),vec3(-0.40447145914,-0.79573858745,0.0),vec3(-0.794242268159,0.00942264957239,0.0));\ntri[1] = mat3(vec3(0.262284652061,-0.61074282809,0.0),vec3(-0.392850985248,-0.651126446093,0.0),vec3(-0.40447145914,-0.79573858745,0.0));\ntri[2] = mat3(vec3(0.45294387004,0.544629519029,0.0),vec3(-0.0664654101251,0.789470572312,0.0),vec3(0.851456864277,0.970948923036,0.0));\ntri[3] = mat3(vec3(-0.350794881771,0.986410561889,0.0),vec3(-0.0664654101251,0.789470572312,0.0),vec3(0.851456864277,0.970948923036,0.0));\ntri[4] = mat3(vec3(0.0758491466031,-0.370676582564,0.0),vec3(0.262284652061,-0.61074282809,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[5] = mat3(vec3(0.0758491466031,-0.370676582564,0.0),vec3(0.262284652061,-0.61074282809,0.0),vec3(-0.392850985248,-0.651126446093,0.0));\ntri[6] = mat3(vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.392850985248,-0.651126446093,0.0),vec3(-0.794242268159,0.00942264957239,0.0));\ntri[7] = mat3(vec3(0.612024151395,0.536568473836,0.0),vec3(0.262284652061,-0.61074282809,0.0),vec3(0.851456864277,0.970948923036,0.0));\ntri[8] = mat3(vec3(0.612024151395,0.536568473836,0.0),vec3(0.45294387004,0.544629519029,0.0),vec3(0.851456864277,0.970948923036,0.0));\ntri[9] = mat3(vec3(0.612024151395,0.536568473836,0.0),vec3(0.262284652061,-0.61074282809,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[10] = mat3(vec3(0.612024151395,0.536568473836,0.0),vec3(0.45294387004,0.544629519029,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[11] = mat3(vec3(-0.251344572955,0.381006780584,0.0),vec3(0.45294387004,0.544629519029,0.0),vec3(-0.0664654101251,0.789470572312,0.0));\ntri[12] = mat3(vec3(-0.251344572955,0.381006780584,0.0),vec3(-0.297237538054,0.191710047873,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[13] = mat3(vec3(-0.251344572955,0.381006780584,0.0),vec3(0.45294387004,0.544629519029,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[14] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(0.0758491466031,-0.370676582564,0.0),vec3(-0.392850985248,-0.651126446093,0.0));\ntri[15] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.392850985248,-0.651126446093,0.0));\ntri[16] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.297237538054,0.191710047873,0.0));\ntri[17] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(-0.297237538054,0.191710047873,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[18] = mat3(vec3(0.0344987625226,-0.306673145755,0.0),vec3(0.0758491466031,-0.370676582564,0.0),vec3(0.132599909009,-0.241305025684,0.0));\ntri[19] = mat3(vec3(-0.48716276886,0.84889489905,0.0),vec3(-0.350794881771,0.986410561889,0.0),vec3(-0.0664654101251,0.789470572312,0.0));\ntri[20] = mat3(vec3(-0.48716276886,0.84889489905,0.0),vec3(-0.251344572955,0.381006780584,0.0),vec3(-0.0664654101251,0.789470572312,0.0));\ntri[21] = mat3(vec3(-0.545694726988,0.507777307568,0.0),vec3(-0.48716276886,0.84889489905,0.0),vec3(-0.251344572955,0.381006780584,0.0));\ntri[22] = mat3(vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.297237538054,0.191710047873,0.0));\ntri[23] = mat3(vec3(-0.402684172294,0.388539347107,0.0),vec3(-0.251344572955,0.381006780584,0.0),vec3(-0.297237538054,0.191710047873,0.0));\ntri[24] = mat3(vec3(-0.402684172294,0.388539347107,0.0),vec3(-0.545694726988,0.507777307568,0.0),vec3(-0.251344572955,0.381006780584,0.0));\ntri[25] = mat3(vec3(-0.402684172294,0.388539347107,0.0),vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.297237538054,0.191710047873,0.0));\ntri[26] = mat3(vec3(-0.402684172294,0.388539347107,0.0),vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.545694726988,0.507777307568,0.0));\ntri[27] = mat3(vec3(-0.752524495777,0.276016142992,0.0),vec3(-0.545694726988,0.507777307568,0.0),vec3(-0.48716276886,0.84889489905,0.0));\ntri[28] = mat3(vec3(-0.752524495777,0.276016142992,0.0),vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.545694726988,0.507777307568,0.0));\ntri[29] = mat3(vec3(-0.752524495777,0.276016142992,0.0),vec3(-0.715035346718,0.0364155198627,0.0),vec3(-0.794242268159,0.00942264957239,0.0));\ntri[30] = mat3(vec3(-0.752524495777,0.276016142992,0.0),vec3(-0.670283449528,0.248633296271,0.0),vec3(-0.715035346718,0.0364155198627,0.0));\n#endif\n#if METHOD == 2\t\ninvB[0] = mat2(vec2(12.2510254236,-10.0506623921),vec2(5.93060355006,-6.10741623619));\ninvB[1] = mat2(vec2(1.53399980438,-1.96237643676),vec2(-0.123266307448,7.07273770067));\ninvB[2] = mat2(vec2(0.56888588823,-1.33639683109),vec2(-2.87743979553,1.24923120468));\ninvB[3] = mat2(vec2(-0.780971094288,-0.0665373746576),vec2(3.95017234978,-5.17375134818));\ninvB[4] = mat2(vec2(-9.78814469667,3.42766092189),vec2(-3.43595869638,-1.50359457115));\ninvB[5] = mat2(vec2(-0.24503895042,1.70170835607),vec2(3.9752195788,-2.84396975926));\ninvB[6] = mat2(vec2(10.4592126164,0.427408305219),vec2(6.35567711449,-1.25417177539));\ninvB[7] = mat2(vec2(-12.8819194429,3.53776514935),vec2(4.79845012174,-1.9500341436));\ninvB[8] = mat2(vec2(6.001840763,-6.11532635427),vec2(-5.61037454762,3.37079898937));\ninvB[9] = mat2(vec2(1.32893321047,2.79814875556),vec2(0.46649899066,-1.724573916));\ninvB[10] = mat2(vec2(6.15892743873,-6.09575755676),vec2(-2.51035563292,3.75697841644));\ninvB[11] = mat2(vec2(-0.951112766618,1.58672380226),vec2(-2.01770410166,-0.718184020575));\ninvB[12] = mat2(vec2(4.27714958179,-6.14694694126),vec2(4.24576225912,-3.79244991859));\ninvB[13] = mat2(vec2(-1.56839020972,1.24186899648),vec2(0.639269943792,0.766189462769));\ninvB[14] = mat2(vec2(-6.74237275671,8.28109708786),vec2(11.2681495377,-10.2740335142));\ninvB[15] = mat2(vec2(1.69848014931,-0.850925648119),vec2(0.795913223442,1.05571019566));\ninvB[16] = mat2(vec2(0.597883981974,-1.91877545315),vec2(-1.60852169555,-1.27718486218));\ninvB[17] = mat2(vec2(-6.13536188092,-0.926196561268),vec2(-6.0903383017,1.38998864331));\ninvB[18] = mat2(vec2(-14.4037331347,7.27783586836),vec2(6.3184123048,-10.9222055317));\ninvB[19] = mat2(vec2(-2.98592777252,0.900968604446),vec2(-4.31089322062,6.37845025774));\ninvB[20] = mat2(vec2(-2.23416737961,-0.325032218376),vec2(1.01123037862,-2.30108111076));\ninvB[21] = mat2(vec2(-4.33920223823,1.17567198807),vec2(-2.18698189397,2.72980825286));\ninvB[22] = mat2(vec2(-1.90045491795,-0.696612229362),vec2(5.11290327071,-4.56524094034));\ninvB[23] = mat2(vec2(-6.52887308512,6.78867244949),vec2(1.5828553422,3.63687044328));\ninvB[24] = mat2(vec2(-7.47107010851,0.443922841778),vec2(-17.3471759529,8.91901914235));\ninvB[25] = mat2(vec2(0.844257950794,-2.91927649076),vec2(5.53283562751,-1.56393322318));\ninvB[26] = mat2(vec2(4.99159876947,-2.29674632932),vec2(-2.39981202347,-2.75465099603));\ninvB[27] = mat2(vec2(-5.98579635017,10.0526494462),vec2(1.02709561182,-4.65646245201));\ninvB[28] = mat2(vec2(-10.4815316901,9.37398467703),vec2(5.03920826492,-8.36559087426));\ninvB[29] = mat2(vec2(-1.35032087116,13.336364544),vec2(3.96233368338,-2.08693548111));\ninvB[30] = mat2(vec2(-11.3616396639,12.8276527504),vec2(2.39591111903,2.00708069855));\n#endif\n\t\n\tpt[4] += 0.1*vec2(0.5*cos(iTime),sin(iTime));\n\tpt[2] += vec2(0.05,0.02)*vec2(cos(-iTime),sin(iTime*2.2));\n\tpt[7] += vec2(0.01,0.2)*vec2(cos(iTime*3.1),sin(iTime*1.2));\n\tpt[8] += vec2(0.2,0.0)+vec2(0.3,0.2)*vec2(cos(iTime*0.4),sin(iTime*1.2));\n\tpt[11] += vec2(0.01,0.03)*vec2(cos(iTime*3.1),sin(iTime*5.1));\n\tfloat nTrigInv = 1.0/float(nTriangles);\n\t\n\tvec3 col1 = vec3(1.0, 0.0, 0.0);\n\tvec3 col2 = vec3(0.0, 0.0, 1.0);\n\t\n\t#if METHOD == 0\n \t// 16 FPS\n\t// Here, the data structures are defined such that\n\t// points are given in \"pt\", an array of vec2s. \n\t// and each triangle is a set of 3 indices of pt array.\n\tfor(int i=0; i<nTriangles; i++) {\n\t\tivec3 tri = triangles[i];\n\n\t\tvec2 A1, A2, A3;\n\t\t// Super stupid method to reach array indices :-(\n\t\t// \"pt[tri.x]\" does not work -Grrr!- because\n\t\t// a variable has to be a constant (or a looping variable) \n\t\t// to be used as an index.\n\t\t// So, tri to be constant. But I can't make \"triangles\" \n\t\t// a constant array.\n\t\tfor(int ind=0; ind<nTriangles; ind++) {\n\t\t\tif(ind==tri.x) A1 = pt[ind];\n\t\t\tif(ind==tri.y) A2 = pt[ind];\n\t\t\tif(ind==tri.z) A3 = pt[ind];\t\t\n\t\t}\n\t\tpixel += vec3(1.0)*triangle(r,A1,A2,A3)*float(i)/float(nTriangles);\n\t}\n\t\n\t#elif METHOD == 1\n\t// 25 FPS\n\t// Here, the data structures are defined such that\n\t// each triangle is given as three points\n\tfor(int i=0; i<nTriangles; i++) {\n\t\tmat3 t = tri[i];\n\t\tvec2 A1 = t[0].xy;\n\t\tvec2 A2 = t[1].xy;\n\t\tvec2 A3 = t[2].xy;\n\t\tvec3 col = vec3(0.0);\n\t\t\n\t\tif( mod(float(i),2.0) < 0.9 ) {\n\t\t\tcol = col1;\n\t\t} else {\n\t\t\tcol = col2;\n\t\t}\n\t\t\n\t\tfloat x = float(i)-mod(iTime*1.0,float(nTriangles));\n\t\tif(abs(x)<0.5) {\n\t\t\tcol=mix(col,vec3(1.0, 1.0, 0.0), 0.8);\n\t\t\t//col=vec3(1.0, 1.0, 0.0);\n\t\t}\n\t\tpixel = mix(pixel, col, triangle(r,A1,A2,A3)*float(i)*nTrigInv);\n\t}\n\t\n\t#elif METHOD == 2\n\t// 15 FPS\n\t// Here, the data structures are defined such that\n\t// Triangle matrix inverses calculated beforehand\n\tfor(int i=0; i<nTriangles; i++) {\n\t\tmat3 t = tri[i];\n\t\tvec2 A3 = t[2].xy;\n\t\n\t\tpixel += vec3(1.0)*triangle3(r,A3,invB[i])*float(i)/float(nTriangles);\t\t\t\t\n\t}\t\t\n\t#endif\t\n\t\n\t/*\n\tfloat c1=0.1;\n\tfloat c2=0.3;\n\tvec2 x = c1*A1+c2*A2+(1.0-c1-c2)*A3;\n\tpixel = mix(pixel, vec3(1.0,1.0,0.0), disk(r, x, 0.05));\n\tfloat u = 0.1;\n\tfloat v = 0.1;\n\tx = u*A1q + v*A2q;\n\tpixel = mix(pixel, vec3(1.0,0.0,1.0), disk(q, x, 0.05));\n\t*/\n\t\n\t//pixel += 0.3*vec3( pow(texture(iChannel0, 1.*r).x, 4.0) );\n\tfragColor = vec4(pixel,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs23W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 82, 129, 129, 204], [206, 206, 257, 257, 706], [708, 708, 760, 760, 913], [915, 915, 959, 959, 1176], [1179, 1388, 1440, 1440, 2080], [2083, 2083, 2140, 2140, 13809]], "test": "ok"}
{"id": "Xs2GDd", "name": "[SH2014] Cellular", "author": "vug", "description": "A colony of single cell organisms", "tags": ["2d"], "likes": 214, "viewed": 25331, "published": "Public", "date": "1395286468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\nvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\nvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.008, radius+0.008, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*2.;\n\tvec2 r = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n\tr *= 1.0 + 0.05*sin(r.x*5.+iTime) + 0.05*sin(r.y*3.+iTime);\n\tr *= 1.0 + 0.2*length(r);\n\tfloat side = 0.5;\n\tvec2 r2 = mod(r, side);\n\tvec2 r3 = r2-side/2.;\n\tfloat i = floor(r.x/side)+2.;\n\tfloat j = floor(r.y/side)+4.;\n\tfloat ii = r.x/side+2.;\n\tfloat jj = r.y/side+4.;\t\n\t\n\tvec3 pix = vec3(1.0);\n\t\n\tfloat rad, disks;\n\t\t\n\trad = 0.15 + 0.05*sin(t+ii*jj);\n\tdisks = disk(r3, vec2(0.,0.), rad);\n\tpix = mix(pix, col2, disks);\n\n\tfloat speed = 2.0;\n\tfloat tt = iTime*speed+0.1*i+0.08*j;\n\tfloat stopEveryAngle = PI/2.0;\n\tfloat stopRatio = 0.7;\n\tfloat t1 = (floor(tt) + smoothstep(0.0, 1.0-stopRatio, fract(tt)) )*stopEveryAngle;\n\t\t\n\tfloat x = -0.07*cos(t1+i);\n\tfloat y = 0.055*(sin(t1+j)+cos(t1+i));\n\trad = 0.1 + 0.05*sin(t+i+j);\n\tdisks = disk(r3, vec2(x,y), rad);\n\tpix = mix(pix, col1, disks);\n\t\n\trad = 0.2 + 0.05*sin(t*(1.0+0.01*i));\n\tdisks = disk(r3, vec2(0.,0.), rad);\n\tpix += 0.2*col3*disks * sin(t+i*j+i);\n\n\tpix -= smoothstep(0.3, 5.5, length(r));\t\n\tfragColor = vec4(pix,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2GDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 168, 215, 215, 290], [292, 292, 349, 349, 1406]], "test": "ok"}
{"id": "XsB3Wc", "name": "Weird Thing", "author": "iq", "description": "Some broken experiment on something undefined", "tags": ["3d", "raymarching", "volumetric"], "likes": 89, "viewed": 6904, "published": "Public API", "date": "1394102815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2014 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n//#define HIGH_QUALITY_NOISE\n\nvec3 hash( vec3 x )\n{\n\treturn textureLod( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, 0.0 ).xyz;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+vec2(0.5,0.5))/256.0, 0.0 ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+vec2(1.5,0.5))/256.0, 0.0 ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+vec2(0.5,1.5))/256.0, 0.0 ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+vec2(1.5,1.5))/256.0, 0.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec2 voronoi( in vec3 x, out vec3 cen )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    float res = 100.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = d;\n\t\t\tcen = p + r + f;\n        }\n    }\n\n    return vec2( sqrt( res ), id );\n}\n\nvec4 map( in vec3 p )\n{\n\tvec3 q = 8.0*p;\n\tfloat n = 0.0;\n\tn  = 0.5000*noise( q ); q = q*2.02;\n    n += 0.2500*noise( q ); q = q*2.03;\n    n += 0.1250*noise( q );\n\t\n\tvec3 cen = vec3(0.0);\n\tvec2 vor = voronoi( 2.0*p, cen );\n\tfloat f = 1.0-1.5*vor.x; cen /= 2.0;\n\tf -= smoothstep( 0.4, 0.5, n );\n\t\n    float d = 2.0*f;\n\t\n\td *= smoothstep( 0.0, 0.2, 1.0-length(p) );\n\td *= smoothstep( 0.0, 0.2, 1.0-length(cen) );\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec3 col = mix( vec3(1.0,0.85,0.7), vec3(0.2,0.0,0.0), d );\n\t\n\tcol -= 0.05*sin( 5.0*vor.y + vec3(1.0,2.0,3.0) );\n\t\n\treturn vec4( col, d );\n}\n\nconst vec3 sundir = vec3(0.0,0.5,-1.0);\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec2 tminmax, in vec2 px )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n    const int numSteps = 64;\n    \n\tfloat dt = 1.0/float(numSteps);\n\t\n\tfloat t = tminmax.x + dt*textureLod(iChannel0, px/iChannelResolution[0].xy, 0.0).x;\n\tfor(int i=0; i<numSteps; i++)\n\t{\n\t\tif( sum.a > 0.99 || t>tminmax.y ) break;\n\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = map( pos );\n\t\t\n\t\tfloat dif = clamp((col.w - map(pos+0.01*sundir).w)/0.01, 0.0, 1.0 );\n        float occ = dot(pos,pos);\n        vec3 lin = vec3(0.2,0.2,0.2) + vec3(1.0, 0.9, 0.7)*dif;\n\t\tcol.xyz *= lin*2.5*occ*occ;\n\t\t\n\t\tcol.a *= 0.1;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a) * dt/0.01;\t\n\n\t\tt += dt;\n\t}\n\n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float an = 2.0 + 0.2*iTime - mo.x;\n\n\tvec3 ro = 2.0*vec3(cos(an), 0.17, sin(an));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\tvec3 col = vec3(0.05,0.04,0.03);\n    vec2 seg = iSphere( ro, rd, vec4(0.0,0.0,0.0,1.0) );\n\tif( seg.x>0.0 )\n\t{\n        vec4 res = raymarch( ro, rd, seg, fragCoord );\n        col = col*(1.0-res.w) + res.xyz;\n\t}\n\t\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), -0.1 );\n\t\n\tcol = pow( col, vec3(0.45) ) * 1.2;\n\n\tcol *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsB3Wc.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[642, 672, 693, 693, 773], [775, 775, 801, 801, 1432], [1434, 1434, 1487, 1487, 1673], [1675, 1675, 1716, 1716, 2212], [2214, 2214, 2237, 2237, 2794], [2837, 2837, 2907, 2907, 3536], [3538, 3538, 3595, 3595, 4446]], "test": "ok"}
{"id": "XsBGDV", "name": "Stanford Torus", "author": "TekF", "description": "Because space.", "tags": ["raymarching", "scifi", "spacestation"], "likes": 31, "viewed": 2856, "published": "Public API", "date": "1393636185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// parameters\nconst float SSradius = 200.0; // Okay, it's actually a lot smaller than the Stanford Torus, but it's a cool name.\nconst float SSthickness = 16.0;\n\nconst float angularSpeed = .221; // g = r*w^2, e.g. w = sqrt(9.81/200) = .221\n\nvec3 SunDir = vec3(1,1,-1.5);\n\nconst float tau = 6.28318530717958647692;\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\n#define MAX 1000.0\n\nfloat Foliage( vec3 pos )\n{\n\treturn\n\t\tmax(\n\t\t\tabs(pos.z)-SSthickness,\n\t\t\tabs(length(pos.xy)-SSradius-2.0 + Noise(pos/16.0).x*2.0 + 2.0*abs(pos.z)/SSthickness - 1.0)-1.0\n\t\t);\n\t// todo: leafiness\n}\n\nfloat Water( vec3 pos )\n{\n\treturn max( abs(pos.z)-SSthickness, abs(length(pos.xy)-SSradius-1.0)-1.0 );\n}\n\n\nfloat Building( vec3 pos, float seed )\n{\n\tif ( seed < .1 )\n\t\treturn length(vec3(pos.x,max(abs(pos.y)-2.0,0.0),pos.z))-2.0;\n\t\n\tvec3 p = pos;\n\tp.y += (seed-.5)*p.z;\n\tp = abs(p)-vec3(2,3,2);\n\tvec3 p2 = abs(pos+vec3(0,1.67,0))-vec3(1,.67,1);\n\treturn max(max(max(p.x,p.y),p.z),-max(p2.z,p2.y));\n}\n\n\nfloat Solid( vec3 pos )\n{\n\tfloat r = length(pos.xy);\n\t\n\tvec2 polar = vec2(atan(pos.x,-pos.y),length(pos.xy));\n\n\tvec3 spokep = pos;\n\tconst float spokeangle = tau/5.0;\n\tfloat spokea = (fract(polar.x/spokeangle)-.5)*spokeangle;\n\tspokep.xy = polar.y*vec2(sin(spokea),-cos(spokea));\n\t\n\treturn\n\t\tmin(min(\n\t\t\t// ring\n\t\t\tmax(max(\n\t\t\t\t// outer torus\n\t\t\t\tabs( length(vec2(pos.z, r-SSradius))-SSthickness-.5 )-.5,\n\t\t\t\t// window-gap\n\t\t\t\t5.0-abs(r-(SSradius-6.0))),\n\t\t\t\t// top gap\n\t\t\t\tmin(\n\t\t\t\t\t6.0-abs(pos.z), //todo: close bottom\n\t\t\t\t\tSSradius-r\n\t\t\t\t)\n\t\t\t),\n\t\t\t// buildings\n\t\t\t//length( vec3((fract(polar.x*40.0)-.5)*polar.y/40.0,polar.y+1.0-SSradius,pos.z+30.0*(fract(pow(floor(polar.x*40.0)*.777,2.0))-.5) ) ) - .5\n\t\t\t//length( vec3((fract(polar.x*20.0)-.5)*polar.y/20.0,polar.y-SSradius,pos.z+30.0*(fract(pow(floor(polar.x*20.0)*.444,2.0))-.5) ) ) - 2.0\n\t\t\tBuilding( vec3((fract(polar.x*20.0)-.5)*polar.y/20.0,polar.y-SSradius,pos.z+30.0*(fract(pow((floor(polar.x*20.0)+5.0)*.444,2.0))-.5) ), fract(pow(floor(polar.x*20.0)*.777,2.0)) )\n\t\t\t// could do roads connecting them, by drawing 2 for every position\n\t\t\t),\n\t\t\tmax(\n\t\t\t\tmin( min(\n\t\t\t\t\t// spokes\n\t\t\t\t\tmax(\n\t\t\t\t\t\t-SSradius-spokep.y,\n\t\t\t\t\t\tlength(spokep.xz)-2.0\n\t\t\t\t\t),\n\t\t\t\t\t// hub\n\t\t\t\t\tmax(\n\t\t\t\t\t\tr-20.0,\n\t\t\t\t\t\tabs(pos.z)-7.0\n\t\t\t\t\t)),\n\t\t\t\t\tmax(\n\t\t\t\t\t\tr-17.0,\n\t\t\t\t\t\tabs(pos.z)-9.0\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\t// dock\n\t\t\t\tmin(\n\t\t\t\t\t8.0-abs(pos.x),\n\t\t\t\t\t3.0-abs(pos.y)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n}\n\n\n// smooth min, to prevent hard edges when I use union of lights\nfloat smin ( float a, float b )\n{\n\tconst float s = 1.0;\n\treturn -log2(exp2(-a/s)+exp2(-b/s))*s;\n}\n\n\nfloat Lights( vec3 pos )\n{\n\treturn\n\t\tsmin(smin(smin(smin(smin(smin(smin(smin(//smin(\n\t\t\t// ring light\n\t\t\tlength(vec2(pos.z, length(pos.xy)-188.0))-.5,\n\t\t\t// landing lights\n\t\t\tlength(pos-vec3(-8,-3,-9))-.3),\n\t\t\tlength(pos-vec3( 8,-3,-9))-.3),\n\t\t\tlength(pos-vec3(-8, 3,-9))-.3),\n\t\t\tlength(pos-vec3( 8, 3,-9))-.3),\n\t\t\tlength(pos-vec3(-8,-3, 9))-.3),\n\t\t\tlength(pos-vec3( 8,-3, 9))-.3),\n\t\t\tlength(pos-vec3(-8, 3, 9))-.3),\n\t\t\tlength(pos-vec3( 8, 3, 9))-.3/*),\n\t\t\tlength(pos-vec3(-8,-197,12.0*sin(iTime)))-.3*/\n\t\t);\n}\n\nvec4 SampleLights( vec3 pos )\n{\n\t// like then Normal calc\n\tvec2 d = vec2(-1,1) * .1;\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = Lights(p0);\n\tfloat f1 = Lights(p1);\n\tfloat f2 = Lights(p2);\n\tfloat f3 = Lights(p3);\n\t\n\t// this direction is completely  innaccurrate for hard-edged intersections!\n\t// it gets one or other surface normal, rather than a smoothed result\n\t// so, build smooth light shapes\n\t\n\treturn vec4(\n\t\t\t\t-normalize( p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3) ),\n\t\t\t\t(f0+f1+f2+f3)/4.0\n\t\t\t);\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n\treturn min( min( min(\n\t\t\tFoliage( pos ),\n\t\t\tWater( pos ) ),\n\t\t\tSolid( pos ) ),\n\t\t\tLights( pos )\n\t\t);\n}\n\n\nfloat DistanceFieldNoLights( vec3 pos )\n{\n\treturn min( min(\n\t\t\tFoliage( pos ),\n\t\t\tWater( pos ) ),\n\t\t\tSolid( pos )\n\t\t);\n}\n\n\nstruct ShadeData { vec3 pos, ray, normal; float shadow; float t; };\nShadeData SetShadeData( vec3 pos, vec3 ray, vec3 normal, float shadow, float t )\n{\n\tShadeData s;\n\ts.pos = pos;\n\ts.ray = ray;\n\ts.normal = normal;\n\ts.shadow = shadow;\n\ts.t = t;\n\treturn s;\n}\n\n\nvec3 DiffuseLight( ShadeData s )\n{\n\t// sunlight\n\tvec3 sun = vec3(1)*2.0*max(.0,dot(s.normal,SunDir))*s.shadow;\n\t\n\t// local soft light sources\n\t// Actually sample the lights!!\n\tvec4 sl = SampleLights( s.pos );\n\tfloat fade = 1.0/sl.w; // point lights should be 1/(w*w), line lights are 1/w, infinite area lights are 1\n\tvec3 local = vec3(.4,.7,1)*5.0*(dot(sl.xyz,s.normal)*.5+.5)*fade;\n\n/*\t// like ambient occlusion, but towards the light\n\tIt's not quite right\n\tfloat lRange = s.t/20.0;\n\tfloat lOcclusion = max( 0.0, 1.0 - DistanceFieldNoLights( s.pos + sl.xyz*lRange )/(lRange*max(.1,dot(sl.xyz,s.normal))) );\n\tlocal *= exp2( -2.0*pow(lOcclusion,2.0) ); // tweak the curve*/\n\t\n\t// ambient\n\tvec3 ambient = vec3(0) + local;\n\t// this ambient occlusion trick works ridiculously well\n\t// sample the distance field at a point in front of the surface\n\t// if there's a nearby concave surface the value will be less than the distance to the sample point\n\tfloat aoRange = s.t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceFieldNoLights( s.pos + s.normal*aoRange )/aoRange ); // can be > 1.0\n\tambient *= exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\t\n\treturn ambient+sun;\n}\n\n\nvec3 ShadeFoliage( ShadeData s )\n{\n\tvec3 albedo = mix( vec3(.05,.02,.01), vec3(.1,.5,.0), Noise(s.pos*20.0).x*.3+.7 );\n\t\n\treturn albedo*DiffuseLight(s);\n}\n\nvec3 ShadeWater( ShadeData s )\n{\n\tconst float albedoScale = 4.0;\n\tfloat rad = (SSradius+1.0)/albedoScale;\n\trad = floor( rad*tau+.5 )/tau; // round it so we get a whole number of texture repeats\n\tvec2 uv = vec2(s.pos.z/albedoScale,atan(s.pos.x,s.pos.y)*rad);\n\t\n\tvec3 base = vec3(.05,.1,.2)*DiffuseLight(s);\n\t\n\t// normal map\n\tvec2 noise = (Noise( s.pos*2.0+iTime*vec3(-4,4,0) )*2.0-1.0)*.1;\n\tvec3 tangent = normalize(vec3(s.pos.y,-s.pos.x,0));\n\tvec3 binormal = vec3(0,0,1);\n\tvec3 normal = s.normal + tangent*noise.x + binormal*noise.y;\n\t\n\tfloat fresnel = dot(normal,s.ray);\n\tvec3 reflection = s.ray-2.0*fresnel*normal;\n\tfresnel = pow( 1.0-abs(fresnel), 5.0 );\n\t\n\tfloat up = dot( reflection, normal );\n\tfloat across = dot( reflection, binormal );\n\t\n\treturn mix( base, vec3(.4,.7,1)*1.0*pow(1.0-abs(across),10.0), fresnel );\n}\n\nvec3 ShadeSolid( ShadeData s )\n{\n\treturn vec3(.8) * DiffuseLight(s);\n}\n\nvec3 ShadeLights( ShadeData s )\n{\n\treturn vec3(.4,.7,1)*8.0*abs(dot(s.ray,s.normal)); // draw the lightbulb\n}\n\nvec3 Shade( ShadeData s )\n{\n\tfloat foliage = Foliage(s.pos);\n\tfloat water = Water(s.pos);\n\tfloat solid = Solid(s.pos);\n\tfloat lights = Lights(s.pos);\n\tfloat dist = min(min(min(foliage, water),solid),lights);\n\t\n\tif ( lights == dist )\n\t\treturn ShadeLights(s);\n\t\n#if (0) // test lighting\n\treturn DiffuseLight(s)*.8;\n#else\n\telse if ( foliage == dist )\n\t\treturn ShadeFoliage(s);\n\telse if ( water == dist )\n\t\treturn ShadeWater(s);\n\telse\n\t\treturn ShadeSolid(s);\n#endif\n}\n\n\n//Compute the surface normal\nvec3 Normal( vec3 pos )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n\tvec2 d = vec2(-1,1) * .01;\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\treturn normalize( p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3) );\n}\n\n\nstruct Camera { vec3 pos, target, up; float zoom; };\n\nCamera SetCam( vec3 pos, vec3 target, vec3 up, float zoom )\n{\n\tCamera cam;\n\tcam.pos = pos;\n\tcam.target = target;\n\tcam.up = up;\n\tcam.zoom = zoom;\n\treturn cam;\n}\n\nCamera MixCam( Camera a, Camera b, float c )\n{\n\tCamera cam;\n\tcam.pos = mix( a.pos, b.pos, c );\n\tcam.target = mix( a.target, b.target, c );\n\tcam.up = mix( a.up, b.up, c );\n\tcam.zoom = mix( a.zoom, b.zoom, c );\n\treturn cam;\n}\n\nvec3 BGRot( in vec3 v, in vec3 cs )\n{\n\treturn vec3(v.xy*cs.x + v.yx*cs.yz, v.z);\n}\n\nvec2 Trace( vec3 pos, vec3 ray, vec2 interval )\n{\n\tfloat t = interval.x;\n\tfloat h;\n\tfor( int i=0; i<150; i++ )\n\t{\n\t\th = DistanceField( pos + t*ray );\n\t\tif ( h < .01 || t > interval.y )\n\t\t\tbreak;\n\t\tt += h;\n\t}\n\treturn vec2(t,h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate background\n\tfloat a = iTime*angularSpeed; // radians per second\n\tvec3 cs = vec3( cos(a), sin(a)*vec2(1,-1) );\n\tSunDir = normalize( BGRot( SunDir, cs ) );\n\t\n\t// todo: animate camera between pairs of keyframes\n\tCamera camKeys[8];\n\tcamKeys[0] = SetCam( vec3(-400,-300,-300), vec3(0,0,0), vec3(0,.5,-1), .8 );\n\tcamKeys[1] = SetCam( vec3(-20,20.0-SSradius,-40), vec3(0,-SSradius,0), vec3(0,1,.5), .8 );\n\tcamKeys[2] = SetCam( vec3(-10,2.0-SSradius,16), vec3(0,-SSradius,0), vec3(0,1,0), .8 );\n\tcamKeys[3] = SetCam( vec3(30,2.5-SSradius,5), vec3(-SSradius,40.0-SSradius,-50), vec3(0,1,0), .8 );\n\tcamKeys[4] = SetCam( vec3(30,2.5-SSradius,5), vec3(-SSradius,40.0-SSradius,-50), vec3(0,1,0), .8 );\n\tcamKeys[5] = SetCam( vec3(-10,2.5-SSradius,2), vec3(0,SSradius,0), vec3(.5,3,1), 1.2 );\n\tcamKeys[6] = SetCam( vec3(200,-150,400), vec3(0,0,0), vec3(0,.5,1), .8 );\n\tcamKeys[7] = SetCam( vec3(0,0,50), vec3(0,0,0), vec3(cs.y,-cs.x,0), .8 );\n\n\t// pick a pair of cameras using time\n\t// todo: could manually pick cam using all combinations of \"iop\", shown on screen when auto-cycling (cam: io)\n\t// mouse moves cam along path, and target up/down (by up*length(target-pos))\n\tfloat T = fract(iTime/52.0)*4.0;\n\tCamera cam1, cam2;\n\tbool rotCam = false;\n\tif ( T < 1.0 ) { cam1 = camKeys[0]; cam2 = camKeys[1]; rotCam = true; }\n\telse if ( T < 2.0 ) { cam1 = camKeys[2]; cam2 = camKeys[3]; }\n\telse if ( T < 3.0 ) { cam1 = camKeys[4]; cam2 = camKeys[5]; }\n\telse { cam1 = camKeys[6]; cam2 = camKeys[7]; rotCam = true; }\n\t\n\t// mix between them\n\t//T = smoothstep( .15, .85, fract(T) );\n\tT = fract(T);\n\tfloat T2 = T*T;\n\tT = (6.0*T2 - 15.0*T + 10.0)*T2*T;\n\tCamera cam = MixCam( cam1, cam2, T );\n\t\n\t\n\t//Camera cam = SetCam( vec3(500.0*(iMouse.xy/iResolution.xy-.5),0)+vec3(0,-300,-300), vec3(0,-100,0), vec3(0,1,0), .7 );\n\t\n\t// fire a ray from the camera\n\tvec3 pos = cam.pos;\n\tvec3 forward = normalize(cam.target-cam.pos);\n\tvec3 right = normalize(cross(cam.up,forward));\n\tvec3 up = normalize(cross(forward,right));\n\tvec3 ray = normalize(vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*cam.zoom ));\n\tray = right*ray.x + up*ray.y + forward*ray.z;\n\t\n\tif ( rotCam )\n\t{\n\t\tpos = BGRot( pos, cs );\n\t\tray = BGRot( ray, cs );\n\t}\n\t\n\t// intersect that ray with isosurface bounding volume\n\tvec2 interval = vec2(0,1000);\n\t\n\t// march isosurface\n\tvec2 th = Trace( pos, ray, interval );\n\t\n\t// shading\n\tvec3 col;\n\t\n\tif ( th.y < 1.0 ) // shade some near misses to reduce artefacts\n\t{\n\t\tvec3 p = pos + th.x*ray;\n\t\tvec3 n = Normal(p);\n\t\t\n\t\tfloat shadowBias = mix ( 1.0, .1, abs(dot( n, SunDir )) );\n\n\t\tfloat shadow = Trace( p, SunDir, vec2(shadowBias, 1000.0) ).y;\n\t\t\n\t\tshadow = smoothstep( .01, 4.0, shadow );\n\t\t\n\t\tcol = Shade( SetShadeData(p,ray,n,shadow,th.x) );\n\t}\n\telse\n\t{\n\t\t// draw background\n\t\tray = BGRot( ray, cs.xzy );\n\t\tfloat s = 1.3;\n\t\tvec3 X = texture( iChannel1, ray.yz*s ).rgb;\n\t\tvec3 Y = texture( iChannel1, ray.xz*s ).rgb;\n\t\tvec3 Z = texture( iChannel1, ray.xy*s ).rgb;\n\t\tcol = mix( X, Y, smoothstep(-.3,.3,abs(ray.y)-abs(ray.x)) );\n\t\tcol = mix( col, Z, smoothstep(-.3,.3,abs(ray.z)-max(abs(ray.x),abs(ray.y))) );\n\t\tcol = pow(col,vec3(7,5,3))*.1;\n\t}\n\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBGDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[305, 425, 450, 450, 648], [671, 671, 698, 698, 866], [868, 868, 893, 893, 972], [975, 975, 1015, 1015, 1266], [1269, 1269, 1294, 1294, 2686], [2689, 2753, 2786, 2786, 2850], [2853, 2853, 2879, 2879, 3363], [3365, 3365, 3396, 3422, 3951], [3954, 3954, 3987, 3987, 4091], [4094, 4094, 4135, 4135, 4214], [4285, 4285, 4367, 4367, 4472], [4475, 4475, 4509, 4522, 5645], [5648, 5648, 5682, 5682, 5802], [5804, 5804, 5836, 5836, 6626], [6628, 6628, 6660, 6660, 6698], [6700, 6700, 6733, 6733, 6809], [6811, 6811, 6838, 6838, 7274], [7277, 7306, 7331, 7406, 7741], [7798, 7798, 7859, 7859, 7957], [7959, 7959, 8005, 8005, 8182], [8184, 8184, 8221, 8221, 8266], [8268, 8268, 8317, 8317, 8496], [8498, 8498, 8555, 8577, 11736]], "test": "ok"}
{"id": "XsjGD3", "name": "Karamelli", "author": "Branch", "description": "Kun haluatte pahaa.", "tags": ["fatser"], "likes": 2, "viewed": 188, "published": "Public", "date": "1394387472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 tulos;\n\tvec4 end=vec4(0.0);\n\tvec2 rl = -vec2(0.5)+fragCoord.xy / iResolution.xy;\n\tfor(float i=0.; i<0.2; i+=0.004){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 rl=uv-vec2(0.5);\n\tfloat ar=iResolution.y/iResolution.x;\n\tuv.y*=ar;\n\tuv.x+=rand(vec2(iTime+i)+uv*100.0)*0.00181;\n\tuv.y+=rand(vec2(iTime+i)+uv*100.0)*0.00181;\n\tuv+=vec2(cos((iTime+i)*0.1)*0.31,sin((iTime+i)*0.1)*0.31);\n\tif(mod(uv.x*2.1,0.5+0.1*sin((iTime+i)*0.02963))>0.182 && mod(uv.y,0.5+0.1*sin((iTime+i)*0.01))>0.08)\n\tif(mod(uv.x-uv.y+0.5*(iTime+i),0.6+0.01*sin((iTime+i)*0.01))>0.435)\n\t\ttulos = vec4(0.89,0.5,0.5,1.0);\n\telse \n\t\ttulos = vec4(0.49,0.1,0.1,1.0);\n\telse if(mod(uv.x-uv.y+(iTime+i),0.6+0.1*sin((iTime+i)*0.01))>0.435)\n\t\ttulos = vec4(0.19,0.11,0.21,1.0);\n\telse\n\t\ttulos = vec4(0.19,0.11,0.01,1.0);\n\tend+=tulos*57.4*((i*i*i*i));\n\t}\n\tend+=rand(vec2(rl)+sin(iTime))*0.1;\n\tend*=1.6-length(rl)*2.48;\n\tfragColor=end;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [93, 93, 150, 150, 1045]], "test": "ok"}
{"id": "XsSGWd", "name": "Smooth Mosiac", "author": "Justaway", "description": "Smooth mosiac.", "tags": ["procedural", "2d"], "likes": 1, "viewed": 147, "published": "Public", "date": "1395078750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define FILTER 1\nfloat s;\nvoid srand(vec2 p){\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\nfloat rand(){\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\nfloat grad(float t){\n\treturn 6.0*pow(t,5.0)-15.0*pow(t,4.0)+10.0*pow(t,3.0);\n}\nvec4 hash2d(vec2 p){\n\tsrand(p);\n\tvec4 c;\n\tc.r=rand();\n\tc.g=rand();\n\tc.b=rand();\n\treturn c;\n}\nmat2 rot2d(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts, c);\n}\nmat3 rotx(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\t1.0,0.0,0.0,\n\t\t0.0,  c, -s,\n\t\t0.0,  s,  c);\n}\nmat3 roty(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\tc,  0.0,  s,\n\t\t0.0,1.0,0.0,\n\t\t-s, 0.0,  c);\n}\nmat3 rotz(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(\n\t\t  c, -s,0.0,\n\t\t  s,  c,0.0,\n\t    0.0,0.0,1.0);\n}\nvec2 simplex(vec2 p){\n\tvec2 r;\n\tr.x=1.1547*p.x;\n\tr.y=p.y+0.5*r.x;\n\treturn r;\n}\nvec2 unsimplex(vec2 p){\n\tvec2 r;\n\tr.y=p.y-0.5*p.x;\n\tr.x=p.x/1.1547;\n\treturn r;\n}\nvec4 noise2d(vec2 p){\n\tp=simplex(p);\n\tvec2 p0=floor(p);\n\tvec2 p1=p0+vec2(1.0,0.0);\n\tvec2 p2=p0+vec2(1.0,1.0);\n\tvec2 p3=p0+vec2(0.0,1.0);\n\tvec2 i=fract(p);\n\tvec4 r0,r1,r2;\n\tfloat d0,d1,d2;\t\n\t#define RADIUS 1.0\n\tif(i.x>i.y){\n\t\tr0=hash2d(p0);\n\t\tr1=hash2d(p1);\n\t\tr2=hash2d(p2);\n\t\td0=max(RADIUS-distance(unsimplex(p),unsimplex(p0)),0.0);\n\t\td1=max(RADIUS-distance(unsimplex(p),unsimplex(p1)),0.0);\n\t\td2=max(RADIUS-distance(unsimplex(p),unsimplex(p2)),0.0);\n\t}else{\n\t\tr0=hash2d(p0);\n\t\tr1=hash2d(p2);\n\t\tr2=hash2d(p3);\n\t\td0=max(RADIUS-distance(unsimplex(p),unsimplex(p0)),0.0);\n\t\td1=max(RADIUS-distance(unsimplex(p),unsimplex(p2)),0.0);\n\t\td2=max(RADIUS-distance(unsimplex(p),unsimplex(p3)),0.0);\n\t}\n\td0=grad(d0);\n\td1=grad(d1);\n\td2=grad(d2);\n\treturn d0*r0+d1*r1+d2*r2;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat r=iResolution.x/iResolution.y;\n\tvec2 p=vec2((fragCoord.x-iResolution.x/2.0)/iResolution.x*r,(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n\tvec4 n=vec4(0.0);\n\tfloat t=iTime/PI;\n#if FILTER\n\tvec2 x=vec2(0.5/iResolution.y,0.0);\n\tx*=rot2d(PI/8.0);\n\tn+=0.25*noise2d((p+x)*10.0);\n\tx*=rot2d(PI/4.0);\n\tn+=0.25*noise2d((p+x)*10.0);\n\tx*=rot2d(PI/4.0);\n\tn+=0.25*noise2d((p+x)*10.0);\n\tx*=rot2d(PI/4.0);\n\tn+=0.25*noise2d((p+x)*10.0);\n#else\n\tn=noise2d(p*10.0);\n#endif\n\tn.rgb*=rotx(t*0.5);\n\tn.rgb*=roty(t*0.6);\n\tn.rgb*=rotz(t*0.7);\n\tfragColor=vec4(abs(n));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsSGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 70, 70, 114], [115, 115, 128, 128, 186], [187, 187, 207, 207, 265], [266, 266, 286, 286, 358], [359, 359, 379, 379, 446], [447, 447, 466, 466, 562], [563, 563, 582, 582, 678], [679, 679, 698, 698, 797], [798, 798, 819, 819, 876], [877, 877, 900, 900, 957], [958, 958, 979, 979, 1718], [1719, 1719, 1775, 1775, 2327]], "test": "ok"}
