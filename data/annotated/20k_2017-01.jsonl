{"id": "4lGSDw", "name": "Fourier - interpolation", "author": "iq", "description": "Interpolating a set of 38 points with the Discrete Fourier Transform. More info here: [url]http://www.iquilezles.org/www/articles/fourier/fourier.htm[/url]", "tags": ["2d", "fourier"], "likes": 103, "viewed": 6225, "published": "Public API", "date": "1484594019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// A set of 38 points gets interpolated by computing the DFT (Discrete Fourier Transform)\n// and then its inverse, and evaluating the it at more than 38 points. This results in\n// an interpolation sort of made of cosine/sine waves. Would be nice to do a regular\n// Hermite spline interpolation as well to compare.\n//\n// More info: http://www.iquilezles.org/www/articles/fourier/fourier.htm\n//\n// Original drawing (kind of), here:\n// https://mir-s3-cdn-cf.behance.net/project_modules/disp/831a237863325.560b2e6f92480.png\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  d = pa - ba*h;\n\treturn dot(d,d);\n}\n\nfloat sdPointSq( in vec2 p, in vec2 a )\n{\n    vec2 d = p - a;\n\treturn dot(d,d);\n}\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.x;\n\tvec2 p = fragCoord / iResolution.x;\n    \n    vec3 col = vec3(1.0);\n\n    #define NUM 38\n    \n    vec2 path[NUM];\n    \n    //------------------------------------------------------\n    // path\n    //------------------------------------------------------\n    {\n        path[ 0] = vec2( 0.098, 0.062 );\n        path[ 1] = vec2( 0.352, 0.073 );\n        path[ 2] = vec2( 0.422, 0.136 );\n        path[ 3] = vec2( 0.371, 0.085 );\n        path[ 4] = vec2( 0.449, 0.140 );\n        path[ 5] = vec2( 0.352, 0.187 );\n        path[ 6] = vec2( 0.379, 0.202 );\n        path[ 7] = vec2( 0.398, 0.202 );\n        path[ 8] = vec2( 0.266, 0.198 );\n        path[ 9] = vec2( 0.318, 0.345 );\n        path[10] = vec2( 0.402, 0.359 );\n        path[11] = vec2( 0.361, 0.425 );\n        path[12] = vec2( 0.371, 0.521 );\n        path[13] = vec2( 0.410, 0.491 );\n        path[14] = vec2( 0.410, 0.357 );\n        path[15] = vec2( 0.502, 0.482 );\n        path[16] = vec2( 0.529, 0.435 );\n        path[17] = vec2( 0.426, 0.343 );\n        path[18] = vec2( 0.449, 0.343 );\n        path[19] = vec2( 0.504, 0.335 );\n        path[20] = vec2( 0.664, 0.355 );\n        path[21] = vec2( 0.748, 0.208 );\n        path[22] = vec2( 0.738, 0.277 );\n        path[23] = vec2( 0.787, 0.308 );\n        path[24] = vec2( 0.748, 0.183 );\n        path[25] = vec2( 0.623, 0.081 );\n        path[26] = vec2( 0.557, 0.099 );\n        path[27] = vec2( 0.648, 0.116 );\n        path[28] = vec2( 0.598, 0.116 );\n        path[29] = vec2( 0.566, 0.195 );\n        path[30] = vec2( 0.584, 0.228 );\n        path[31] = vec2( 0.508, 0.083 );\n        path[32] = vec2( 0.457, 0.140 );\n        path[33] = vec2( 0.508, 0.130 );\n        path[34] = vec2( 0.625, 0.071 );\n        path[35] = vec2( 0.818, 0.093 );\n        path[36] = vec2( 0.951, 0.066 );\n        path[37] = vec2( 0.547, 0.081 );\n    }\n\n    //------------------------------------------------------\n    // draw path\n    //------------------------------------------------------\n    {\n        vec2 d = vec2(1000.0);\n        for( int i=0; i<(NUM-1); i++ )\n        {\n            vec2 a = path[i+0];\n            vec2 b = path[i+1];\n            d = min( d, vec2(sdSegmentSq( p,a,b ), sdPointSq(p,a) ) );\n        }\n        d.x = sqrt( d.x );\n        d.y = sqrt( min( d.y, sdPointSq(p,path[NUM-1]) ) );\n        //col = mix( col, vec3(0.8,0.8,0.8), 1.0-smoothstep(0.0,e,d.x) );\n        col = mix( col, vec3(0.9,0.2,0.0), 1.0-smoothstep(5.0*e,6.0*e,d.y) );\n    }\n\n    //------------------------------------------------------\n    // compute fourier transform of the path\n    //------------------------------------------------------\n    vec2 fcsX[20];\n    vec2 fcsY[20];\n    for( int k=ZERO; k<20; k++ )\n    {\n        vec2 fcx = vec2(0.0);\n        vec2 fcy = vec2(0.0);\n        for( int i=0; i<NUM; i++ )\n        {\n            float an = -6.283185*float(k)*float(i)/float(NUM);\n            vec2  ex = vec2( cos(an), sin(an) );\n            fcx += path[i].x*ex;\n            fcy += path[i].y*ex;\n        }\n        fcsX[k] = fcx;\n        fcsY[k] = fcy;\n    }\n\n    //------------------------------------------------------\n    // inverse transform with 6x evaluation points\n    //------------------------------------------------------\n    {\n    float ani = min( mod((12.0+iTime)/10.1,1.3), 1.0 );\n    float d = 1000.0;\n    vec2 oq, fq;\n    for( int i=ZERO; i<256; i++ )\n    {\n        float h = ani*float(i)/256.0;\n        vec2 q = vec2(0.0);\n        for( int k=0; k<20; k++ )\n        {\n            float w = (k==0||k==19)?1.0:2.0;\n            float an = -6.283185*float(k)*h;\n            vec2  ex = vec2( cos(an), sin(an) );\n            q.x += w*dot(fcsX[k],ex)/float(NUM);\n            q.y += w*dot(fcsY[k],ex)/float(NUM);\n        }\n        if( i==0 ) fq=q; else d = min( d, sdSegmentSq( p, q, oq ) );\n        oq = q;\n    }\n    d = sqrt(d);\n    col = mix( col, vec3(0.1,0.1,0.2), 1.0-smoothstep(0.0*e,2.0*e,d) );\n    col *= 0.75 + 0.25*smoothstep( 0.0, 0.13, sqrt(d) );\n    }\n\n    //------------------------------------------------------\n\n    col *= 1.0 - 0.3*length(fragCoord/iResolution.xy-0.5);\n \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGSDw.jpg", "access": "shaders20k", "license": "mit", "functions": [[1600, 1600, 1654, 1654, 1778], [1780, 1780, 1821, 1821, 1861], [1863, 1863, 1893, 1893, 1948], [1978, 1978, 2035, 2035, 6170]], "test": "valid"}
{"id": "4lGSWh", "name": "Spectrum Spiral", "author": "XRNZ", "description": "spiral made of circles of increasing radius, with circle color varying with time and distance to circle center", "tags": ["procedural", "2d", "spectrum", "spiral"], "likes": 14, "viewed": 367, "published": "Public", "date": "1483994397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//spiral made of circles of increasing radius\n//with circle color varying with time and distance to circle center\n\n// Falloff : attenuation en fonction de la distance\n// x : distance\n// r : distance limite\n// a : coefficient de ponderation\nfloat Falloff(in float x,in float r,in float a)\n{\n    if (x<r)\n    {\n        float t = x / r;\n        return a*(1.0-t*t)*(1.0-t*t)*(1.0-t*t);\n    }\n    else\n    {\n        return 0.0;\n    }\n}\n\n// Cercle\n// c  : Centre\n// r  : Rayon\n// uv : position pixel\n// old : ancienne couleur\nvec4 Circle(in vec2 c,in float r, in vec2 uv)\n{\n  float L=length(uv-c);\n \n  // Dans le cercle si distance < rayon\n  if (L<r)\n  {  \n      //chaque couleur varie en fonction de la distance au centre L\n      //et en fonction du temps, avec desynchronisation\n      \n       float red = 0.5*sin((-iTime*1.0+10.0*L)+1.0);\n       float green = 0.5*sin((-iTime*2.0+20.0*L)+1.0);\n       float blue = 0.5*sin((-iTime*3.0+30.0*L)+1.0);\n     \n    return Falloff(L,r,1.0)*vec4(red, green, blue, 1.0);\n  }\n  // Else ancienne couleur\n  else\n  {\n    return vec4(0.0);\n  }\n}\n\n\n// Image\nvoid mainImage( out vec4 col, in vec2 p )\n{\n\n  //parametre :\n    \n  const float circle_size = 0.01;\n    \n  //spirale de cercles de rayon croissant\n    \n  vec2 uv = (p.xy-iResolution.xy/vec2(2.0)) / iResolution.y;\n    \n  vec4 circ = vec4(.0,.0,.0,1.);\n\n  for (int k=0;k<int(1.0/circle_size);k++)\n  {\n  \tvec2 q=(circle_size*float(k))*vec2(cos(0.5*float(k)),sin(0.5*float(k)));\n   \n \t circ += Circle(q,circle_size*float(k),uv);\n  }\n    \n  col = circ; \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 240, 289, 289, 430], [432, 520, 567, 567, 1076], [1079, 1088, 1131, 1148, 1538]], "test": "valid"}
{"id": "4lGSWW", "name": "Ice Ice Baby", "author": "voz", "description": "F*ck you ShaderToy inquisitors. Here's an exact copy of my old code for your dogmatic asses (Eat me).\n\nFree code forever!", "tags": ["shadertoy", "just", "for", "haters", "dogmatic"], "likes": 3, "viewed": 544, "published": "Public API", "date": "1484263062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCopyright (c) 2016, CrazedCoding@gmail.com.\nPermission is hereby DENIED, with prejudice (lol f***\nyou), to anyone/everyone obtaining a copy of this\nsoftware and associated documentation files (the\n\"Software\"), pending a written admition (the\n\"Admition\") of how wildly jealous of my coding skills\n(and good looks) they are, to deal in the Software\nwithout restriction, including without limitation the\nrights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the\nSoftware, subject to the following conditions: DO\nNOT EVEN CONTINUE READING THIS COPYRIGHT UNTIL YOU\nHAVE WRITTEN AND DELIVERED YOUR ADMITION; DO NOT LOOK\nAT THIS SOFTWARE; IF YOU FOUND THIS SOFTWARE BY \nFOLLOWING LINKS IN MY POSTS (SPREAD THROUGHOUT \nCYBERSPACE) THEN QUIT WASTING TIME ON FACEBOOK/YOUTUBE \nSTALKING ME AND SPEND MORE TIME LEARNING BASIC \nCALCULUS AND COMPUTER SCIENCE SO YOU CAN WRITE YOUR \nOWN F***ING CODE; BETTER YET, CONTACT ME AND I WILL \nTUTOR YOU AT A RATE OF $12.50 AN HOUR IN THOSE\nSUBJECTS... THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\nWARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\nBUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \nARISING FROM, OUT OF OR IN CONNECTION WITH THE \nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\nvec3 eye = vec3 (0.0);\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    //return length(bp - rp) - r;\n    \n    vec3 oc = eye - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return FAR;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return length(bp - rp) - r;\n}\n\nfloat sdCapsule(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,eye-a);\n    float e = dot(eye-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((eye+ray*t1)-(a+ray2*t2));\n    return dist > r || t2 < r || t2 > length(a-b)+r? FAR : length(pa - ba * h) - r;\n}\n\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\nvec4  saved_stance[NUM_ANGLES];\nvec4  stance[NUM_ANGLES];\n\nfloat saved_shoulderRot = 0.0;\nfloat shoulderRot = 0.0;\n\nfloat saved_hipRot = 0.0;\nfloat hipRot = 0.0;\n\nfloat saved_lean = 0.0;\nfloat lean = 0.0;\n\n//body joints\nvec3 head = vec3(0.0);\n\nvec3 bSpine = vec3(0.0);\nvec3 uSpine = vec3(0.0);\n\nvec3 leftShoulder = vec3(0.0);\nvec3 rightShoulder = vec3(0.0);\n\nvec3 leftElbow = vec3(0.0);\nvec3 rightElbow = vec3(0.0);\n\nvec3 leftWrist = vec3(0.0);\nvec3 rightWrist = vec3(0.0);\n\nvec3 leftFinger = vec3(0.0);\nvec3 rightFinger = vec3(0.0);\n\nvec3 leftHip = vec3(0.0);\nvec3 rightHip = vec3(0.0);\n\nvec3 leftKnee = vec3(0.0);\nvec3 leftAnkle = vec3(0.0);\n\nvec3 rightKnee = vec3(0.0);\nvec3 rightAnkle = vec3(0.0);\n\nconst vec3 downY = vec3(0.0, -1.0, 0.0);\nfloat minY = 0.0;\n\nvoid load_stance() {\n    \n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n    \tstance[i] = saved_stance[i];\n    \n    shoulderRot = (saved_shoulderRot);\n    hipRot = (saved_hipRot);\n    lean = (saved_lean);\n    \n    head = vec3(0.0, GR/E, 0.0);\n    \n    ///////////////////////////////////////////////////////////////\n    //Spine////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = head/GR;\n    uSpine = -bSpine;\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulders////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    leftShoulder = bSpine+vec3(1.0, 0.0, 0.0)/E;\n    rightShoulder = bSpine-vec3(1.0, 0.0, 0.0)/E;\n    \n    ///////////////////////////////////////////////////////////////\n    //Elbows///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftElbow = downY/GR;\n\n    float leftArmOmega = stance[ELBOWS].x;\n    float leftArmTheta = stance[ELBOWS].y;\n    \n    hangingLeftElbow = rotatePoint(rotatePoint(hangingLeftElbow, vec3(1.0, 0.0, 0.0), leftArmOmega), vec3(0.0, 0.0, 1.0), leftArmTheta);\n    \n    leftElbow = leftShoulder+hangingLeftElbow;\n        \n    vec3 hangingRightElbow = downY/GR;\n    \n    float rightArmOmega = stance[ELBOWS].z;\n    float rightArmTheta = stance[ELBOWS].w;\n    \n    hangingRightElbow = rotatePoint(rotatePoint(hangingRightElbow, vec3(1.0, 0.0, 0.0), rightArmOmega), vec3(0.0, 0.0, -1.0), rightArmTheta);\n    \n    rightElbow = rightShoulder+hangingRightElbow;\n    \n    ///////////////////////////////////////////////////////////////\n    //Wrists///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftWrist = downY/E;\n\n    float leftForeArmOmega = leftArmOmega+stance[WRISTS].x;\n    float leftForeArmTheta = leftArmTheta+stance[WRISTS].y;\n    \n    straightLeftWrist = rotatePoint(rotatePoint(straightLeftWrist, vec3(1.0, 0.0, 0.0), leftForeArmOmega), vec3(0.0, 0.0, 1.0), leftForeArmTheta);\n    \n    leftWrist = leftElbow+straightLeftWrist;\n        \n    vec3 straightRightWrist = downY/E;\n    \n    float rightForeArmOmega = rightArmOmega+stance[WRISTS].z;\n    float rightForeArmTheta = rightArmTheta+stance[WRISTS].w;\n    \n    straightRightWrist = rotatePoint(rotatePoint(straightRightWrist, vec3(1.0, 0.0, 0.0), rightForeArmOmega), vec3(0.0, 0.0, -1.0), rightForeArmTheta);\n    \n    rightWrist = rightElbow+straightRightWrist;\n    \n    ///////////////////////////////////////////////////////////////\n    //Fingers//////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftFingers = downY/PI/E;\n\n    float leftFingersOmega = leftForeArmOmega+stance[FINGERS].x;\n    float leftFingersTheta = leftForeArmTheta+stance[FINGERS].y;\n    \n    straightLeftFingers = rotatePoint(rotatePoint(straightLeftFingers, vec3(1.0, 0.0, 0.0), leftFingersOmega), vec3(0.0, 0.0, 1.0), leftFingersTheta);\n    \n    leftFinger = leftWrist+straightLeftFingers;\n        \n    vec3 straightRightFingers = downY/PI/E;\n    \n    float rightFingersOmega = rightForeArmOmega+stance[FINGERS].z;\n    float rightFingersTheta = rightForeArmTheta+stance[FINGERS].w;\n    \n    straightRightFingers = rotatePoint(rotatePoint(straightRightFingers, vec3(1.0, 0.0, 0.0), rightFingersOmega), vec3(0.0, 0.0, -1.0), rightFingersTheta);\n    \n    rightFinger = rightWrist+straightRightFingers;\n    \n    \n    ///////////////////////////////////////////////////////////////\n    //Hips/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    leftHip = uSpine+vec3(circle(hipRot), 0.0).xzy/E/GR;\n    rightHip = uSpine-vec3(circle(hipRot), 0.0).xzy/E/GR;\n    ///////////////////////////////////////////////////////////////\n    //Knees////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftKnee = downY/GR;\n\n    float leftKneeOmega = stance[KNEES].x;\n    float leftKneeTheta = stance[KNEES].y;\n    \n    hangingLeftKnee = rotatePoint(rotatePoint(hangingLeftKnee, vec3(1.0, 0.0, 0.0), leftKneeOmega), vec3(0.0, 0.0, 1.0), leftKneeTheta);\n    \n    leftKnee = leftHip+hangingLeftKnee;\n        \n    vec3 hangingRightKnee = downY/GR;\n    \n    float rightKneeOmega = stance[KNEES].z;\n    float rightKneeTheta = stance[KNEES].w;\n    \n    hangingRightKnee = rotatePoint(rotatePoint(hangingRightKnee, vec3(1.0, 0.0, 0.0), rightKneeOmega), vec3(0.0, 0.0, -1.0), rightKneeTheta);\n    \n    rightKnee = rightHip+hangingRightKnee;\n    \n    ///////////////////////////////////////////////////////////////\n    //Ankles///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 straightLeftAnkle = downY/GR;\n\n    float leftAnkleOmega = leftKneeOmega+stance[ANKLES].x;\n    float leftAnkleTheta = leftKneeTheta+stance[ANKLES].y;\n    \n    straightLeftAnkle = rotatePoint(rotatePoint(straightLeftAnkle, vec3(1.0, 0.0, 0.0), leftAnkleOmega), vec3(0.0, 0.0, 1.0), leftAnkleTheta);\n    \n    leftAnkle = leftKnee+straightLeftAnkle;\n        \n    vec3 straightRightAnkle = downY/GR;\n    \n    float rightAnkleOmega = rightKneeOmega+stance[ANKLES].z;\n    float rightAnkleTheta = rightKneeTheta+stance[ANKLES].w;\n    \n    straightRightAnkle = rotatePoint(rotatePoint(straightRightAnkle, vec3(1.0, 0.0, 0.0), rightAnkleOmega), vec3(0.0, 0.0, -1.0), rightAnkleTheta);\n    \n    rightAnkle = rightKnee+straightRightAnkle;\n    \n    ///////////////////////////////////////////////////////////////\n    //Lean/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = rotatePoint(bSpine, vec3(1.0, 0.0, 0.0), lean);\n    head = rotatePoint(head, vec3(1.0, 0.0, 0.0), lean);\n    \n    leftShoulder = rotatePoint(leftShoulder, vec3(1.0, 0.0, 0.0), lean);\n    rightShoulder = rotatePoint(rightShoulder, vec3(1.0, 0.0, 0.0), lean);\n    leftElbow = rotatePoint(leftElbow, vec3(1.0, 0.0, 0.0), lean);\n    rightElbow = rotatePoint(rightElbow, vec3(1.0, 0.0, 0.0), lean);\n    leftWrist = rotatePoint(leftWrist, vec3(1.0, 0.0, 0.0), lean);\n    rightWrist = rotatePoint(rightWrist, vec3(1.0, 0.0, 0.0), lean);\n    leftFinger = rotatePoint(leftFinger, vec3(1.0, 0.0, 0.0), lean);\n    rightFinger = rotatePoint(rightFinger, vec3(1.0, 0.0, 0.0), lean);\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulder Rotation////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n\n    leftShoulder = rotatePoint(leftShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightShoulder = rotatePoint(rightShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftElbow = rotatePoint(leftElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightElbow = rotatePoint(rightElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftWrist = rotatePoint(leftWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightWrist = rotatePoint(rightWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftFinger = rotatePoint(leftFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightFinger = rotatePoint(rightFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    \n    ///////////////////////////////////////////////////////////////\n    //Hip Rotation/////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    //MIN calc\n \tfloat lowestY = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(bSpine.y, uSpine.y),\n                                                                            leftShoulder.y),\n                                                                        rightShoulder.y),\n                                                                    leftElbow.y),\n                                                                rightElbow.y),\n                                                            leftWrist.y),\n                                                        rightWrist.y),\n                                                    leftFinger.y), \n                                                rightFinger.y), \n                                            leftHip.y), \n                                        rightHip.y), \n                                    leftKnee.y), \n                                leftAnkle.y),\n                            rightKnee.y),\n                        rightAnkle.y);\n    minY = min(lowestY, minY);\n}\n\nfloat dfScene(vec3 rp, vec3 rd) {\n    \n    float msd = 99.0;\n    \n    float scale = GR;\n    \n    //hip\n    msd = min(msd, sdSphere(rp, rd, leftHip, 0.06*scale));\n    msd = min(msd, sdSphere(rp, rd, rightHip, 0.06*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftHip, rightHip, 0.02*scale));\n    //left thigh\n    msd = min(msd, sdSphere(rp, rd, leftKnee, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftHip, leftKnee, 0.02*scale));\n    //left shin\n    msd = min(msd, sdSphere(rp, rd, leftAnkle, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftKnee, leftAnkle, 0.015*scale));\n    //right thigh\n    msd = min(msd, sdSphere(rp, rd, rightKnee, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightHip, rightKnee, 0.02*scale));\n    //right shin\n    msd = min(msd, sdSphere(rp, rd, rightAnkle, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightKnee, rightAnkle, 0.015*scale));\n    //spine\n    msd = min(msd, sdSphere(rp, rd, bSpine, 0.04*scale));\n    msd = min(msd, sdSphere(rp, rd, uSpine, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, bSpine, uSpine, 0.02*scale));\n    //shoulder\n    msd = min(msd, sdSphere(rp, rd, leftShoulder, 0.05*scale));\n    msd = min(msd, sdSphere(rp, rd, rightShoulder, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftShoulder, rightShoulder, 0.02*scale));\n    //left upper arm\n    msd = min(msd, sdSphere(rp, rd, leftElbow, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftShoulder, leftElbow, 0.02*scale));\n    //left lower arm\n    msd = min(msd, sdSphere(rp, rd, leftWrist, 0.03*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftElbow, leftWrist, 0.015*scale));\n    //left finger\n    msd = min(msd, sdSphere(rp, rd, leftFinger, 0.015*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftWrist, leftFinger, 0.01*scale));\n    //right upper arm \n    msd = min(msd, sdSphere(rp, rd, rightElbow, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightShoulder, rightElbow, 0.02*scale));\n    //right lower arm\n    msd = min(msd, sdSphere(rp, rd, rightWrist, 0.03*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightElbow, rightWrist, 0.015*scale));\n    //right finger\n    msd = min(msd, sdSphere(rp, rd, rightFinger, 0.015*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightWrist, rightFinger, 0.01*scale));\n    //head\n    msd = min(msd, sdSphere(rp, rd, head, 0.15));\n    \n    return msd;\n}\n\nvec3 surfaceNormal(vec3 p, vec3 rd) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy, rd), d2 = dfScene(p - e.xyy, rd);\n\tfloat d3 = dfScene(p + e.yxy, rd), d4 = dfScene(p - e.yxy, rd);\n\tfloat d5 = dfScene(p + e.yyx, rd), d6 = dfScene(p - e.yyx, rd);\n\tfloat d = dfScene(p, rd) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor, vec3 rd) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos, rd)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 8; i++) {\n        rp = ro + rd * d;\n        eye = rp;\n        float ns = dfScene(rp, rd);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = vec3(1.0, 0.0, 0.0); //surface colour\n        vec3 n = surfaceNormal(rp, rd);\n        float ao = calcAO(rp, n, rd);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\nconst int numWeights = 512;\n\nvec3 weights[numWeights];\n\nfloat lowAverage()\n{\n    const int iters = numWeights;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.25)).r;\n        \n        product *= sound;\n        sum += sound;\n        \n        weights[i].r = sound;\n    }\n    for(int i = 0; i < iters; i++)\n        weights[i].gb = vec2(sum/float(iters), pow(product, 1.0/float(iters)));\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nvoid clear_stance()\n{\n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n        stance[i] = vec4(0.0);\n    shoulderRot = 0.0;\n    hipRot = 0.0;\n    lean = 0.0;\n}\n\nvoid dance1()\n{\n    clear_stance();\n\tfloat twist = time;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    vec2 twistCircle = circle(twist*GR)*GR;\n    \n    stance[ELBOWS].x = twistCircle.x;\n    stance[ELBOWS].y = twistCircle.x/PI;\n    stance[ELBOWS].z = twistCircle.y;\n    stance[ELBOWS].w = twistCircle.y/PI;\n    \n    stance[WRISTS].x = (stance[ELBOWS].x*.5+.5);\n    stance[WRISTS].z = (stance[ELBOWS].z*.5+.5);\n    \n    shoulderRot = sin(PI+twist*PI*3.0)/PI/GR;\n    hipRot = sin(twist*PI*3.0)/PI/GR;\n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance2()\n{\n    clear_stance();\n\tfloat run = time*PI;\n    \n    vec2 runCircleA = circle(run)*.5+.5;\n    vec2 runCircleB = circle(run+PI)*.5+.5;\n    \n    stance[ELBOWS].x = (runCircleA.x*2.0-1.0)*GR;\n    stance[ELBOWS].z = (runCircleB.x*2.0-1.0)*GR;\n    \n    stance[KNEES].x = runCircleA.x*2.0-1.0;\n    stance[KNEES].z = runCircleB.x*2.0-1.0;\n    stance[ANKLES].x = runCircleA.y;\n    stance[ANKLES].z = runCircleB.y;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance3()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI/2.0+sin(wave)/PI;\n    stance[ELBOWS].w = PI/2.0+sin(wave+PI/2.0)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance4()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI+sin(wave)/PI;\n    stance[ELBOWS].w = PI+sin(wave+PI/2.0)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance5()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI+sin(wave)/PI;\n    stance[ELBOWS].w = PI+sin(wave+PI/2.0)/PI;\n    \n    stance[ELBOWS].x = sin(wave)/PI;\n    stance[ELBOWS].z = sin(wave)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid save_stance(float factor)\n{\n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n    {\n        saved_stance[i] += (stance[i]-saved_stance[i])*factor;\n    }\n    \n    saved_shoulderRot += (shoulderRot-saved_shoulderRot)*factor;\n    saved_hipRot += (hipRot-saved_hipRot)*factor;\n    saved_lean += (lean-saved_lean)*factor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float height = max(lowAverage(), last_height)-1.0/60.0;\n    beat = clip(height);\n    last_height = height;\n    \n    float dance = time/PI/PI;\n    float v1 =  smoothstep(-1.0, 1.0/5.0, saw(dance));\n    float v2 =  smoothstep(1.0/5.0, 2.0/5.0, saw(dance));\n    float v3 =  smoothstep(2.0/5.0, 3.0/5.0, saw(dance));\n    float v4 =  smoothstep(3.0/5.0, 4.0/5.0, saw(dance));\n    float v5 =  smoothstep(4.0/5.0, 1.0, saw(dance));\n    dance1();\n    save_stance(v1);\n    dance2();\n    save_stance(v2);\n    dance3();\n    save_stance(v3);\n    dance4();\n    save_stance(v4);\n    dance5();\n    save_stance(v5);\n    load_stance();\n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, minY+1.25, -3.5);\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    eye = ro;\n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [{"id": "ldBGz3", "previewfilepath": "https://soundcloud.com/mattybraps/iceicebaby", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mattybraps/iceicebaby", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGSWW.jpg", "access": "shaders20k", "license": "x11", "functions": [[2565, 2565, 2584, 2584, 2636], [2638, 2638, 2690, 2724, 3298], [3300, 3300, 3360, 3360, 3879], [5493, 5493, 5513, 5513, 14493], [14495, 14495, 14528, 14528, 16842], [16844, 16844, 16881, 16881, 17211], [17213, 17218, 17261, 17261, 17558], [17560, 17573, 17608, 17608, 18390], [18448, 18448, 18468, 18468, 18963], [18965, 18965, 18986, 18986, 19115], [19117, 19117, 19132, 19132, 19721], [19723, 19723, 19738, 19738, 20199], [20201, 20201, 20216, 20216, 20750], [20752, 20752, 20767, 20767, 21293], [21295, 21295, 21310, 21310, 21915], [21917, 21917, 21949, 21949, 22229], [22231, 22231, 22286, 22286, 23403]], "test": "timedout"}
{"id": "4lGSzw", "name": "VR reticle", "author": "public_int_i", "description": "Reticle for VR", "tags": ["reticle"], "likes": 4, "viewed": 485, "published": "Public API", "date": "1483465786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2016\n\n\n//units = pixels\n#define RETICLE_SIZE 100.\n#define BAR_DISTANCE 40.\n#define INDICATOR_BAR_THICKNESS 7.\n#define INDICATOR_BAR_FADE 8.\n#define PROGRESS_BAR_THICKNESS 10.\n#define TOTAL_SIZE (RETICLE_SIZE + BAR_DISTANCE + INDICATOR_BAR_THICKNESS*2.0 + PROGRESS_BAR_THICKNESS*2.0)\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2. - iResolution.xy);\n    float len = length(uv),\n          ang = 3.14-atan(uv.y,uv.x);\n    \n    float indicatorOn = mod(floor(iTime),2.),\n          progress = cos(iTime)*.5+.5;\n    \n    float blen = (RETICLE_SIZE+BAR_DISTANCE)-len;\n    \n    float d = max(RETICLE_SIZE-len,\n                  max(indicatorOn*(INDICATOR_BAR_THICKNESS-abs(blen))/INDICATOR_BAR_FADE,\n                     clamp(ang/(-6.28)+progress*2.,0.,1.)*(PROGRESS_BAR_THICKNESS-abs(blen+INDICATOR_BAR_THICKNESS+PROGRESS_BAR_THICKNESS))));\n\tfragColor = vec4(clamp(pow(max(0.,d/4.),1./1.3),0.,1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 370, 370, 959]], "test": "valid"}
{"id": "4lGSzy", "name": "Basic audio visualizer", "author": "Lallis", "description": "Just a basic 2D audio visualizer. :)", "tags": ["2d", "visualizer"], "likes": 18, "viewed": 1806, "published": "Public API", "date": "1484744941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv*2.0-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    p.y+=0.5;\n    \n    vec3 col = vec3(0.0);\n    vec3 ref = vec3(0.0);\n   \n    float nBands = 64.0;\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n    band *= band*band;\n    band = band*0.995;\n    band += 0.005;\n    float s = texture( iChannel0, vec2(band,0.25) ).x;\n    \n    /* Gradient colors and amount here */\n    const int nColors = 4;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.0,0.0,1.0);\n    colors[1] = vec3(0.0,1.0,1.0);\n    colors[2] = vec3(1.0,1.0,0.0);\n    colors[3] = vec3(1.0,0.0,0.0);\n    \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n      \n    col += vec3(1.0-smoothstep(0.0,0.01,p.y-s*1.5));\n    col *= gradCol;\n\n    ref += vec3(1.0-smoothstep(0.0,-0.01,p.y+s*1.5));\n    ref*= gradCol*smoothstep(-0.5,0.5,p.y);\n    \n    col = mix(ref,col,smoothstep(-0.01,0.01,p.y));\n\n    col *= smoothstep(0.125,0.375,f);\n    col *= smoothstep(0.875,0.625,f);\n\n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(p,time))*2.0/256.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 43, 43, 124], [126, 126, 168, 168, 227], [229, 229, 286, 286, 1574]], "test": "error"}
{"id": "4lGXDh", "name": "WoodSphere", "author": "Jabberwock", "description": "TEst", "tags": ["3d"], "likes": 3, "viewed": 82, "published": "Public", "date": "1484577998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 red=vec3(0.6,0.4,0.2);\nconst vec3 yellow=vec3(1.2,0.8,0.4);//vec3(0.95,0.85,0.45);\n\n// Simple color\n// p : Point on object\n// n : Normal at point\nvec3 color(in vec3 p,in vec3 n)\n{\n    return vec3(1,1,1);\n}\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v =  p.x * 10.0;//v=mod(floor(40.0*p.x)/*+floor(p.y)+floor(p.z)*/,2.1);\n    v -= floor(v);\n    v= pow(v ,2.0);\n    return mix(red,yellow,v);\n}\n\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(4.5*p),n); \n    //return checker(p+a*noise(1.5*p),n);\n}\n\n// Color sine wave\nvec3 sine(in vec3 p,in vec3 n)\n{\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    float v=0.5*(1.0+cos(70.0*sqrt(dot(pa,pa))));\n        return mix(red,yellow,v);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-4.0);\n    const vec3 lightColor = vec3(1.0);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.55*warped(p,n,0.3);//*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 128, 163, 163, 232], [234, 316, 340, 340, 383], [385, 416, 442, 442, 811], [982, 1044, 1077, 1077, 1103], [1105, 1162, 1197, 1197, 1350], [1352, 1352, 1397, 1397, 1482], [1484, 1503, 1535, 1535, 1654], [1731, 1913, 1991, 1991, 2226], [2303, 2344, 2372, 2372, 2445], [2447, 2493, 2526, 2545, 2994], [2996, 3053, 3091, 3091, 3172], [3249, 3249, 3306, 3306, 3875]], "test": "valid"}
{"id": "4lGXDK", "name": "Julia Orbit Traps Zoom&Pan", "author": "utak3r", "description": "Classic Julia with animated c param, playing with zoom and pan.\nAntialiasing procedure from ttoinou, orbit traps colouring from Inigo Quilez (iq).\nSee comments in the code.", "tags": ["fractal", "julia"], "likes": 4, "viewed": 325, "published": "Public", "date": "1485869949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Piotr Borys - utak3r/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Classic Julia with animated c param, playing with zoom and pan.\n//\n// Antialiasing procedure from ttoinou\n// Orbit traps colouring from Inigo Quilez (iq)\n//\n// For antialiasing, use AA_ENABLE and adjust AA_RADIUS for your needs/capabilities.\n// For rendering a whole fractal, without camera zooming and panning, disable PLAY_ZOOM.\n// MAXITER is taken into account only with PLAY_ZOOM disabled.\n// MINITER is a starting value for dynamic quality in zooming animation.\n// If you want to explore Julia set by yourself, disable ANIMATE_C and set c for yourself.\n//\n// Please note: \n// In WebGL one cannot use variables as for loop's target, as the loop is unwinded.\n// Hence here below in main for loop I'm going to use a MAXITER constant.\n// But, if you want to use it somewhere else, go and use a maxiter variable instead.\n\n\n#define MAXITER 1024\n#define MINITER 256\n//#define AA_ENABLE\n#define AA_RADIUS 4\n#define PLAY_ZOOM\n#define ANIMATE_C\n\nvec4 julia(vec2 fragCoord)\n\t{\n\tfloat time = iTime * 1.0;\n\tfloat PIH = 1.570797;\n#ifdef PLAY_ZOOM\n\tfloat zoommin = 0.8;\n\tfloat zoommax = 5.0;\n\tfloat zoom = (sin(time - PIH) + 1.0) / 2.0 * (zoommax - zoommin) + zoommin;\n\t//int maxiter = int(float(MINITER) * zoom); // disabled for WebGL\n\tvec2 zoomcenter = vec2(cos(3.0*time*0.2), sin(5.0*time*0.2));\n#else\n\tfloat zoom = 0.8;\n\tvec2 zoomcenter = vec2(0.0, 0.0);\n\t//int maxiter = MAXITER; // disabled for WebGL\n#endif\n\n\tvec2 z = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tz.x *= iResolution.x/iResolution.y;\n\tz += zoomcenter;\n\tz /= zoom;\n#ifdef ANIMATE_C\n\tvec2 c = 1.1*vec2( 0.5*cos(0.1*time) - 0.25*cos(0.2*time), \n\t\t\t\t\t\t0.5*sin(0.1*time) - 0.25*sin(0.2*time));\n#else\n\tvec2 c = vec2(-1.05, 0.25015);\n#endif\n\tvec4 dmin = vec4(1e20);\n\n\tfor (int i = 0; i < MAXITER; i++)\n\t\t{\n\t\tz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\tdmin=min(dmin, vec4(abs(0.0+z.y + 0.5*sin(z.x)),\n\t\t\t\t\t\t\tabs(1.0+z.x + 0.5*sin(z.y)),\n\t\t\t\t\t\t\tdot(z,z),\n\t\t\t\t\t\t\tlength(fract(z)-0.5)));\n\t\t}\n\n\tvec3 color = vec3(dmin.w);\n\tcolor = mix(color, vec3(0.992, 0.929, 0.675), min(1.0,pow(dmin.x*0.25,0.20)));\n\tcolor = mix(color, vec3(0.835, 0.8, 0.667), min(1.0,pow(dmin.y*0.50,0.50)));\n\tcolor = mix(color, vec3(1.00,1.00,1.00), 1.0-min(1.0,pow(dmin.z*1.00,0.15)));\n\tcolor = 1.25*color*color;\n\treturn vec4(color, 1.0);\n\t}\n\nvoid mainImage(out vec4 fragColor, in vec2 coord)\n{\n\tvec4 i1, i2;\n#ifdef AA_ENABLE\n\ti1 = julia(coord);\n\tvec2 pos;\n\tfloat radius = float (AA_RADIUS);\n\tfor (int i = 0; i < AA_RADIUS; i++)\n\t{\n\t\tfor (int j = 0; j < AA_RADIUS; j++)\n\t\t{\n\t\t\tif (i + j > 0)\n\t\t\t{\n\t\t\tpos = vec2(i, j) / radius;\n\t\t\ti2 = julia(coord+pos);\n\t\t\ti1 += i2;\n\t\t\t}\n\t\t}\n\t}\n\ti1 /= radius*radius;\n#else\n\ti1 = julia(coord);\n#endif\n\tfragColor = i1;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGXDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1074, 1074, 1103, 1103, 2404], [2406, 2406, 2457, 2457, 2814]], "test": "valid"}
{"id": "4lGXWy", "name": "Mandelbrot Variant", "author": "TrueBoolean", "description": "Fractal fun", "tags": ["fractal"], "likes": 0, "viewed": 100, "published": "Public", "date": "1485570560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t )\n{\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.);\n    vec3 d = vec3(0.3,0.20,0.20);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 O, in vec2 z ){\n\tz =  (-iResolution.xy + 2.0 * z.xy )/iResolution.y;\n\tfloat S = pow(2.0, sin(iTime/3.)*8.+8.);\n    //Interesting coordinates at: http://paulbourke.net/fractals/mandelbrot/\n    //vec2 l = vec2(0.42884,-0.231345);\n    //vec2 l = vec2(-1.62917,-0.0203968);\n    vec2 l = vec2(-0.761574,-0.0847596);\n    z.xy += l*S;\n    z/=S;\n    //#define ROT(x) mat2(cos(x), - sin(x), sin(x), cos(x))\n    //z*=ROT(iTime/2.);\n    //z*=sin(iTime)/2.+2.;\n    //z.x+=cos(iTime);\n    //z.y+=sin(iTime);\n    O = vec4(vec3(0.),1.0);\n    vec2 c = z;\n    for( int i=0; i<256; i++){\n        z = vec2( z.x*z.x - z.y*z.y, 2. * z.x * z.y) + c;\n        if(length(z)>2.){\n        \tO = vec4(pal(float(i)/256.),1.);\n            break;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 41, 65, 65, 213], [215, 215, 255, 255, 972]], "test": "valid"}
{"id": "4lGXz3", "name": "Foggy", "author": "Valou", "description": "Fog", "tags": ["fog"], "likes": 1, "viewed": 87, "published": "Public", "date": "1485170026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=20.0; // Minimum\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 1.0);\n\n  // Color of the object comes from background !\n  vec3 c = 0.25*background(n);\n    \n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n    \n  //Fog\n  float fogfactor = (t-rA) / (rB - rA);\n  fogfactor =  fogfactor *  fogfactor *  fogfactor;\n    \n    \n    \n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  rgb = mix (rgb, vec3 (0.0, 1.0, 1.0), fogfactor);\n    \n  fragColor=vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 279, 279, 378], [380, 447, 482, 482, 555], [581, 695, 741, 741, 778], [780, 871, 901, 901, 919], [921, 1009, 1039, 1039, 1062], [1064, 1110, 1132, 1132, 1328], [1330, 1370, 1401, 1401, 1621], [1623, 1728, 1779, 1779, 2214], [2216, 2321, 2378, 2378, 2829], [2834, 2854, 2880, 2880, 2952], [2954, 3015, 3043, 3060, 3431], [3573, 3573, 3630, 3630, 4560]], "test": "valid"}
{"id": "4lGXzG", "name": "Warp Core", "author": "cacheflowe", "description": "Using iq's classic deform technique: https://www.shadertoy.com/view/Xdf3Rn", "tags": ["deform", "warp", "core"], "likes": 5, "viewed": 896, "published": "Public API", "date": "1484724741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.;\t\t\t\t\t\t\t\t\t// adjust time\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.x;\t\t// center coordinates\n    \t\n    ////////////////////////////////////\n    // deform technique from iq: https://www.shadertoy.com/view/Xdf3Rn\n    float r2 = dot(p,p);\n    float r = sqrt(r2);\n    vec2 uv = p/r2;\t\n    // animate\t\n\tuv += 10.0 * cos( vec2(0.6,0.3) + vec2(0.1,0.13) * 2. * sin(time) );\n\t// uv = p; // switch back to normal coords to test drawing\n\t////////////////////////////////////\n    \n    // custom drawing\n    uv += vec2(0., 2. * cos(uv.y * 8.));\t\t\t\t\t\t\t\t\t// warp coordinates a little more\n    uv = abs(sin(uv * 0.3));\t\t\t\t\t\t\t\t\t\t\t\t// draw horizontal stripes\n    float color = smoothstep(0.2, 0.8, abs(sin(time + uv.y * 3.)));\n    color = min(color, smoothstep(0.1, 0.95, abs(sin(time + uv.y * 4.))) );\n    color += 0.75;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// brighten everything\n    vec3 col = vec3(\t\t\t\t\t\t\t\t\t\t\t\t\t\t// oscillate color components\n        0.6 + 0.1 * cos(time + color * 1.), \n        0.5 * color, \n    \t0.9 + 0.2 * sin(time + color * 1.1)\n    );\n    // reverse vignette\n\tcol *= r*1.5 * color;\n    col += pow(length(p)/2., 2.);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1239]], "test": "valid"}
{"id": "4lKSzK", "name": "Worley/Cell Noise", "author": "AxleMike", "description": "Worley and Cell Noise\nHopefully I'm doing this right.", "tags": ["2d", "noise", "worley", "cell"], "likes": 4, "viewed": 469, "published": "Public API", "date": "1485061275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Alexander Lemke, 2017\n\nvec2 Hash2D(in vec2 p)\n{\n    return fract(sin(p * mat2(12.98, 78.23, 127.99, 311.33)) * 43758.54);\n}\n\nvec3 DisplayNoise(in vec4 d)\n{\n    float toggle = mod(floor(iTime * 0.5), 6.0);\n    \n    vec3 color = d.xxx;\n    \n    if(toggle == 1.0) \t\tcolor = vec3(1.0 - d.x);\n    else if(toggle == 2.0) \tcolor = vec3(d.y - d.x);     \n    else if(toggle == 3.0) \tcolor = vec3(d.z - d.y);\n    else if(toggle == 4.0) \tcolor = vec3(d.z - d.x);  \n    else if(toggle == 5.0) \tcolor = d.xyz;   \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy * 12.0;\n    vec2 i = floor(uv);\n    vec2 n = fract(uv);\n    vec4 minD = vec4(9.0);\n    \n    for (float y = -1.0; y <= 1.0; ++y) \n    {\n        for(float x = -1.0; x <= 1.0; ++x) \n        {\n            vec2 point = sin(iTime + 32.0 * Hash2D(i + vec2(x, y))) * 0.5 + 0.5;\n            float d = length(vec2(x, y) + point - n);\n            \n            minD = (d < minD.x) ? vec4(d, minD.xyz) \n               \t : (d < minD.y) ? vec4(minD.x, d, minD.yz) \n               \t : (d < minD.z) ? vec4(minD.xy, d, minD.z) \n               \t : (d < minD.w) ? vec4(minD.xyz, d) \n                 : minD;\n        }\n    }\n    fragColor = vec4(DisplayNoise(minD), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 50, 50, 126], [128, 128, 158, 158, 527], [529, 529, 584, 584, 1278]], "test": "valid"}
{"id": "4lKXWm", "name": "PnP", "author": "mreysset", "description": "My first shader", "tags": ["2d"], "likes": 1, "viewed": 99, "published": "Public", "date": "1484627152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *=iResolution.x/iResolution.y;\n    uv.x += smoothstep(0., 1., abs(sin(iTime/8.)));\n    uv.y += smoothstep(0., 1., abs(cos(iTime/10.)));\n    \n    uv *= 3.;\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    vec3 color = vec3(0.);\n    float t4dots = 32.+12.*-cos(iTime);\n    float t2dots = 11. + iTime;\n    \n    color = vec3(smoothstep(0.8,0.9, abs(sin(f_uv.y*t4dots)*cos(f_uv.x*t4dots))));\n    \n    color *= vec3(smoothstep(0.8, 0.9,abs(sin(f_uv.x*t4dots/10.)*cos(f_uv.y*t4dots/10.))));\n    color *= vec3(abs(sin(iTime+uv.x)), abs(sin(iTime+uv.y)), abs(sin(iTime)));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 720]], "test": "valid"}
{"id": "4lKXWz", "name": "Rotating square", "author": "Fieu", "description": "Some simple practice with rotation and stuff.", "tags": ["2d", "rotate", "square", "rotating", "rotation"], "likes": 0, "viewed": 205, "published": "Public", "date": "1483889732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Some stuff to mess around\n */\nconst vec2 pos = vec2(0.0, 0.0);\nconst float width = 0.3;\nconst vec3 color = vec3(1.0, 1.0, 1.0);\nconst vec3 background = vec3(0.0, 0.0, 0.0);\n\n/*\n * Rotation matrix by angle (modified version of function rotate(vec2, angle) ) thanks to FabriceNeyret2\n */\nmat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\n/*\n * Passing position, currect pixel, width and angle from main\n */\nvec3 drawSquare(vec2 pos, vec2 uv, float w, float a) {\n    vec2 u = uv - pos;\n    u *= rotate(a);\n    float stepfrom = w - 0.01;\n    \n    // Simple edge smoothing\n    float alpha = 1.0 - smoothstep(stepfrom, w, abs(u.x))\n                  - smoothstep(stepfrom, w, abs(u.y));\n    \n    // Return mix of background with color by smooth alpha\n    return mix(background, color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalization\n    vec2 uv = 2.0*fragCoord.xy - iResolution.xy;\n    uv /= min(iResolution.x, iResolution.y);\n        \n\n    vec3 color = drawSquare(pos, uv, width, iTime);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 292, 314, 314, 390], [392, 461, 515, 515, 844], [846, 846, 903, 924, 1113]], "test": "valid"}
{"id": "4lKXzK", "name": "Circular Permutations artwork", "author": "matrefeytontias", "description": "A quick little program I put together to generate an artwork for the metal song I wrote. The image I kept is at 6.65 seconds. You can hear the song on my SoundCloud : https://soundcloud.com/matrefeytontias/circular-permutations", "tags": ["2d", "distancebased"], "likes": 1, "viewed": 144, "published": "Public", "date": "1485039708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RADIUS 0.3\n#define THICKNESS 0.01\n\nvec2 centers[3];\nvec2 amplitudes[3];\n\nvec4 line(vec2 uv, vec2 p1, vec2 p2, vec4 c1, vec4 c2)\n{\n    vec4 r = mix(c1, c2, distance(uv, p1) / distance(p1, p2));\n    vec2 u = normalize(p2 - p1);\n    float d = distance(uv, dot(uv, u) * u);\n    return r * exp(-abs(d - THICKNESS) * 10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    centers[0] = vec2(0.); centers[1]= vec2(-0.8, -0.4); centers[2] = vec2(0.4, 0.1);\n    amplitudes[0] = vec2(0.2, 0.5); amplitudes[1] = vec2(0.3, 0.4); amplitudes[2] = vec2(0.1, 0.7);\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.y *= iResolution.y / iResolution.x;\n    \n    vec4 color = vec4(0.);\n    \n    for(int i = 0; i < 3; i++)\n    {\n        int ni = (i + 1) * ((i + 1 < 3) ? 1 : 0);\n        vec4 c = vec4(0., 0., 0., 1.);\n        c[i] = 1.;\n        vec4 nc = vec4(0., 0., 0., 1.);\n        nc[(i + 1) * ((i < 3) ? 1 : 0)] = 1.;\n        vec2 circle = vec2(cos(iTime * (float(i) / 2. + 1.)) * amplitudes[i].x,\n                                    sin(iTime * (float(i) / 2. + 1.)) * amplitudes[i].y);\n\t\tcolor += c * exp(-abs(distance(uv, circle - centers[i]) - RADIUS) * 10.);\n        color += line(uv, centers[i], centers[(i + 1) * ((i + 1 < 3) ? 1 : 0)], c, nc);\n    }\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 137, 137, 326]], "test": "valid"}
{"id": "4lVXDR", "name": "Loading hash...", "author": "Zavie", "description": "Just an experiment with ray tracing a sphere then rejecting solutions based on a hash and see what happens.", "tags": ["raytracing", "sphere", "hash"], "likes": 32, "viewed": 1008, "published": "Public API", "date": "1483875461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nJust a test ray tracing a sphere with a twist.\n\n--\nZavie\n\n*/\n\n#define MAX_BOUNCES 3\nfloat gamma = 2.2;\n\n// ---8<----------------------------------------------------------------------\n// Material\n\nstruct Material\n{\n    vec3 c;\t\t// diffuse color\n    vec3 f0;\t// specular color (colored)\n};\n\n// ---8<----------------------------------------------------------------------\n// Geometry\n\n#define PI acos(-1.)\nfloat hash(float x) { return fract(sin(x) * 43758.5453); }\nfloat hash(vec2 v){ return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nstruct Ray\n{\n    vec3 o;\t\t// origin\n    vec3 d;\t\t// direction\n};\n\nstruct Hit\n{\n    float t;\t// solution to p=o+t*d\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\nconst Hit noHit = Hit(1e10, vec3(0.), Material(vec3(-1.), vec3(-1.)));\n\nstruct Plane\n{\n    float d;\t// solution to dot(n,p)+d=0\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\n\nstruct Sphere\n{\n\tfloat r;\t// radius\n    vec3 p;\t\t// center position\n    Material m;\t// material\n};\n\nHit intersectPlane(Plane p, Ray r)\n{\n    float dotnd = dot(p.n, r.d);\n    if (dotnd > 0.) return noHit;\n\n    float t = -(dot(r.o, p.n) + p.d) / dotnd;\n    return Hit(t, p.n, p.m);\n}\n\nfloat surfaceHash(vec2 p, float freq)\n{\n    float h = 0.;\n    float sum = 0.;\n    for (int i = 0; i < 5; ++i)\n    {\n        h = 2. * h + hash(floor(freq * p));\n        sum = 2. * sum + 1.;\n        freq *= 2.;\n    }\n    \n    return h / sum;\n}\n\nHit intersectHashedSphere(Sphere s, Ray r)\n{\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t1 = b - det;\n    float t2 = b + det;\n\n    float t = t1;\n    vec3 p = r.o + t * r.d;\n    vec3 n = (r.o + t*r.d - s.p) / s.r;\n    \n    // Reject intersection solution based on random magic.\n    if (t < 0. || surfaceHash(p.xy + vec2(0., -iTime), 3.) < 0.5)\n    {\n        t = t2;\n        p = r.o + t * r.d;\n        n = -(r.o + t*r.d - s.p) / s.r;\n    }\n    if (t < 0. || surfaceHash(p.xy + vec2(0., -iTime), 3.) < 0.5)\n    {\n        return noHit;\n    }\n\n    return Hit(t, n, s.m);\n}\n\nvec3 randomVector(float seed)\n{\n    float r2 = hash(seed);\n    float phi = 2. * PI * hash(seed + r2);\n    float sina = sqrt(r2);\n    float cosa = sqrt(1. - r2);\n\n\treturn vec3(cos(phi) * sina, cosa, sin(phi) * sina);\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (b.m.f0.r >= 0. && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nHit intersectScene(Ray r)\n{\n    vec3 axis1 = randomVector(floor(iTime));\n    vec3 axis2 = randomVector(floor(iTime+1.));\n    vec3 axis = normalize(mix(axis1, axis2, fract(iTime)));\n    float translation = 4.*abs(2.*fract(iTime/8.)-1.) - 2.;\n\n    Material weirdMat = Material(0.05 * vec3(0., 0.05, 1.), 0.1 * vec3(1.1, 0.08, 0.01));\n    Sphere s = Sphere(1.6, vec3(0., 1.6, 0.), weirdMat);\n    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(0.05), vec3(0.02)));\n\n    Hit hit = noHit;\n    compare(hit, intersectPlane(p, r));\n    compare(hit, intersectHashedSphere(s, r));\n    return hit;\n}\n\n// ---8<----------------------------------------------------------------------\n// Light\n\nstruct DirectionalLight\n{\n    vec3 d;\t\t// Direction\n    vec3 c;\t\t// Color\n};\n\nDirectionalLight sunLight = DirectionalLight(normalize(vec3(1., .5, .5)), vec3(1e3));\nvec3 skyColor(vec3 d)\n{\n    float transition = pow(smoothstep(0.02, .5, d.y), 0.4);\n\n    vec3 sky = 2e2*mix(vec3(0.52, 0.77, 1), vec3(0.12, 0.43, 1), transition);\n    vec3 sun = sunLight.c * pow(abs(dot(d, sunLight.d)), 5000.);\n    return sky + sun;\n}\n\nfloat pow5(float x) { return x * x * x * x * x; }\n\n// Schlick approximation\nvec3 fresnel(vec3 h, vec3 v, vec3 f0)\n{\n    return pow5(1. - clamp(dot(h, v), 0., 1.)) * (1. - f0) + f0;\n}\n\nfloat epsilon = 4e-4;\n\nvec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)\n{\n    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0.r < 0.)\n    {\n        return clamp(dot(n, l.d), 0., 1.) * l.c;\n    }\n\treturn vec3(0.);\n}\n\nvec3 radiance(Ray r)\n{\n    vec3 accum = vec3(0.);\n    vec3 attenuation = vec3(1.);\n\n    for (int i = 0; i <= MAX_BOUNCES; ++i)\n    {\n        Hit hit = intersectScene(r);\n\n        if (hit.m.f0.r >= 0.)\n        {\n            vec3 f = fresnel(hit.n, -r.d, hit.m.f0);\n\n            vec3 hitPos = r.o + hit.t * r.d;\n\n            // Diffuse\n            vec3 incoming = vec3(0.);\n            incoming += accountForDirectionalLight(hitPos, hit.n, sunLight);\n\n            accum += (1. - f) * attenuation * hit.m.c * incoming;\n\n            // Specular: next bounce\n            attenuation *= f;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(r.o + hit.t * r.d + epsilon * d, d);\n        }\n        else\n        {\n            accum += attenuation * skyColor(r.d);\n            break;\n        }\n    }\n    return accum;\n}\n\n// ---8<----------------------------------------------------------------------\n// Tone mapping\n\n// See: http://filmicgames.com/archives/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n// ---8<----------------------------------------------------------------------\n// Scene\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n\n    vec3 color = vec3(0.);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec3 p0 = vec3(0., 1.1, 4.);\n        vec3 p = p0;\n        vec3 offset = vec3(msaa[i] / iResolution.y, 0.);\n        vec3 d = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, -1.5) + offset);\n        Ray r = Ray(p, d);\n        color += radiance(r) / 4.;\n    }\n\n\tfragColor = vec4(Uncharted2ToneMapping(color),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[406, 406, 427, 427, 464], [465, 465, 484, 484, 551], [1005, 1005, 1041, 1041, 1186], [1188, 1188, 1227, 1227, 1429], [1431, 1431, 1475, 1475, 2118], [2120, 2120, 2151, 2151, 2337], [2339, 2339, 2373, 2373, 2478], [2480, 2480, 2507, 2507, 3073], [3328, 3328, 3351, 3351, 3579], [3581, 3581, 3602, 3602, 3630], [3632, 3657, 3696, 3696, 3763], [3788, 3788, 3857, 3857, 4003], [4005, 4005, 4027, 4027, 4825], [4923, 4966, 5006, 5006, 5421], [5512, 5512, 5569, 5569, 6198]], "test": "valid"}
{"id": "4lVXWw", "name": "Torus Interior - 180 chars", "author": "GregRostami", "description": "I've been trying to reduce one of my favorite shaders from fb39ca4 down to two-tweets (2TC):\n[url]https://www.shadertoy.com/view/MsX3Wj[/url]\nFellow code golfers ... Please HELP reduce this further.", "tags": ["raymarch", "torus", "short", "2tc", "codegolf"], "likes": 31, "viewed": 1493, "published": "Public API", "date": "1484606598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 180 chars - iq and Fabrice not only fix a bug, they kill another 13 chars:\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution;\n    for ( o.z++; R.z++ < 64. ; )\n        o += vec4((u+u-R.xy)/R.x,1,0)*(length(vec2(o.a=length(o.xz)-.7,o.y) )-.5);\n    o += sin( 21.* ( atan(o.y,o.w) - atan(o.z,o.x) - iTime ) ); }   /*\n\n\n// 193 chars - using the #define trick to reduce.\n\n#define mainImage(o,u)\t\\\nvec3 R = iResolution, p = R-R;\t\\\np.z = 4.;\t\\\nwhile (R.z++<64.)\t\\\n    p+=vec3((u+u-R.xy)/R.x,.5)*(length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\t\\\no = vec4( 1&int(7.*(atan(p.y,o.a)-atan(p.z,p.x)-iTime)) )\n\n\n// 207 chars - Thanks to TomCat's amazing optimization we saved 8 more chars:\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec3 R = iResolution, \n         p = R-R; p.z = 4.;\n    \n    while (R.z++<64.)\n        p +=  vec3((u+u-R.xy)/R.x,.5) \n            * (length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\n    \n    o = vec4 ( 1&int(7.*(atan(p.y,o.a)-atan(p.z,p.x)-iTime)) );                 \n}\n\n\n// 215 chars - Another 3 chars lie dead behind Fabrice's path ...\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec3 R = iResolution, \n         p = R-R; p.z = 4.;\n    \n    for (int i = 0; i++ < 64;)\n        p +=  vec3((u+u-R.xy)/R.x,.5) \n            * (length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\n    \n    o = vec4 ( 2.*sin(16.*(atan(p.y, o.a) - atan(p.z,p.x) - iTime)) );                 \n}\n\n\n// 222 chars - Greg added fade to black for depth.\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec3 R = iResolution, \n         p = R-R; p.z = 4.;\n    \n    for (int i = 0; i < 64; i++)\n        p +=  vec3((u+u-R.xy)/R.x,.5) \n            * (length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\n    \n    o += .2*(p.z+6.)*sin(16.*(atan(p.y, o.a) - atan(p.z,p.x) - iDate.w)) -o;                 \n}\n\n\n// 216 chars - Code Golf Master F (Fabrice) schooled me AGAIN!!\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec3 p = iResolution;\n    u = (u+u-p.xy)/p.x;\n    p -=p; p.z = 4.;\n    for (int i = 0; i < 64; i++)\n        p += vec3(u,.5) * (length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\n    \n    o += 9.*sin(16.*(atan(p.y, o.a) + atan(p.z,p.x) + iDate.w)) -o;                \n}\n\n\n// 280 chars - reduced by Greg Rostami\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec3 R = iResolution, p = R-R;\n    u = u/R.xy*2.-1.;\n    p.z = 4.;\n    for (int i = 0; i < 64; i++)\n        p += vec3(u.x*.8, u.y*R.y/R.x, .5) * (length(vec2(length(p.xz)-4.,p.y))-3.);\n    \n    o = vec4( smoothstep(\n        o.a = fract(8.*(atan(p.y, length(p.xz) - 4.) + atan(p.z,p.x) + iDate.w)/3.142),\n                        o.a, o.a < .6 ? .1 : 1.));\n}\n\n\n// 1151 chars - Original shader by fb39ca4\n\n//Thank you iquilez for some of the primitive distance functions!\n\n\nconst float PI = 3.14159265358979323846264;\n\n\nconst int MAX_PRIMARY_RAY_STEPS = 64; //decrease this number if it runs slow on your computer\n\nvec2 rotate2d(vec2 v, float a) { \n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distanceField(vec3 p) {\n\treturn -sdTorus(p, vec2(4.0, 3.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir, float treshold) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\t//if (abs(dist) < treshold) break;\n\t\t\tpos += dist * dir;\n\t}\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraPos = vec3(0.0, 0.0, -3.8);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.5);\n\tvec3 planeU = vec3(1.0, 0.0, 0.0) * 0.8;\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\t//cameraPos.yz = rotate2d(cameraPos.yz, mousePos.y);\n\t//rayDir.yz = rotate2d(rayDir.yz, mousePos.y);\n\t\n\t//cameraPos.xz = rotate2d(cameraPos.xz, mousePos.x);\n\t//rayDir.xz = rotate2d(rayDir.xz, mousePos.x);\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir, 0.01);\n\t\n\tfloat majorAngle = atan(rayPos.z, rayPos.x);\n\tfloat minorAngle = atan(rayPos.y, length(rayPos.xz) - 4.0);\n\t\t\n\tfloat edge = mod(8.0 * (minorAngle + majorAngle + iTime) / PI, 1.0);\n\tfloat color = edge < 0.7 ? smoothstep(edge, edge+0.03, 0.5) : 1.0-smoothstep(edge, edge+0.03, 0.96);\n\t//float color = step(mod(8.0 * (minorAngle + majorAngle + iTime) / PI, 1.0), 0.5);\n\t//color -= 0.20 * step(mod(1.0 * (minorAngle + 1.0 * majorAngle + PI / 2.0) / PI, 1.0), 0.2);\n\t\n\tfragColor = vec4(color);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 115, 115, 323]], "test": "valid"}
{"id": "4lVXzc", "name": "Julia Trip", "author": "lherm", "description": "Playing with colors and the Julia set", "tags": ["fractal", "juliaset"], "likes": 4, "viewed": 139, "published": "Public", "date": "1485288561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy)*2.+-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 z = uv;\n    float t;\n    for (int i = 0; i < 5; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.*z.x*z.y)-vec2(sin(iTime), cos(iTime));\n        if (t< 5.) t = distance(z, vec2(0.));\n        if (t >= 5.) t = pow(dot(z,z), float(i)/t);\n        \n    }\n\tfragColor = vec4(hsv(t + iTime, 1., 1.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 169], [171, 171, 228, 228, 632]], "test": "valid"}
{"id": "4lySRV", "name": "Moving Colors jittered", "author": "hornet", "description": "random-sampled version of https://www.shadertoy.com/view/ltXXz2", "tags": ["jitter"], "likes": 2, "viewed": 98, "published": "Public", "date": "1484901976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SPEED 0.5\n#define NB_SHAPES 6.0\n\n#define TRAIL_DUR 0.35\n#define NB_REPEAT 16.0\n\n//#define TRAIL_MODE\n\n#define DRAW_CIRCLES\n// AND / OR\n#define DRAW_LINES\n\n\n#define LINE_THICKNESS 0.0025\n#define LINE_SHINE 0.01\n\nfloat sqrLen(vec2 vec)\n{\n\treturn dot(vec, vec);  \n}\n\nvec2 pixelToNormalizedspace(vec2 pixel)\n{\n    vec2 res;\n    res.x = pixel.x * 2.0 / iResolution.x - 1.0;\n    res.y = pixel.y * 2.0 / iResolution.y - 1.0;\n    res.y *= iResolution.y / iResolution.x;//correct aspect ratio\n    return res;\n}\n\nvec2 rotate(vec2 pos, float angle)\n{\n    float rad = radians(angle);\n \tmat2 rotM = mat2(vec2(cos(rad), -sin(rad)), vec2(sin(rad), cos(rad)));    \n    return rotM * pos;\n}\n\nfloat circle(vec2 diff, float radius){\n    return abs(length(diff) - radius);\n}\n\nfloat segment(vec2 diff, vec2 dir, vec2 dim)\n{\n    float projDist \t= dot(diff, dir);\n\tfloat dist = 0.0;\n\n    dist += length(diff - dir * dim.x) * step(dim.x, projDist);\n    dist += length(diff) * (1.0 - step(0.0, projDist));\n    dist += length(diff - dir * projDist) * (step(0.0, projDist) - step(dim.x, projDist));\n    return dist - dim.y;\n}\n\nfloat colorStrength(float dist){\n \t   return 1.0 - smoothstep(LINE_THICKNESS - LINE_SHINE,\n                               LINE_THICKNESS + LINE_SHINE,\n                               dist);\n}\n\nfloat hash(in ivec2 c)\n{\n  int x = 0x3504f333*c.x*c.x + c.y;\n  int y = 0xf1bbcdcb*c.y*c.y + c.x;\n    \n  return float(x*y)*(2.0/8589934592.0)+0.5;\n}\nfloat hash( in vec2 c ) { return hash( ivec2(1337.1*c) ); }\n\nvec3 draw(vec2 pos, float in_time, float prev_time, float rnd)\n{ \n    vec3 col \t\t= vec3(0.0);    \n    float colorStr \t= 0.0;    \n    float colTime \t= 0.0;\n\n    float time = prev_time + rnd * (in_time - prev_time);\n    \n#ifdef DRAW_CIRCLES\n    vec2 circlePos = vec2(0.0);\n    circlePos.x += cos(time) - cos(time * 5.0) * 0.5 - sin(time * 15.0) * 0.1;\n    circlePos.y += sin(time) - sin(time * 3.0) * 0.5 + cos(time * 10.0) * 0.3;\n    circlePos \t*= 0.3; \n    float dist = 0.05 + sqrLen(circlePos - vec2(0.5, 0.5)) * 0.1;\n#endif\n    \n#ifdef DRAW_LINES    \n    vec2 lineEnd = vec2(0.0);\n  \tlineEnd.x += (sin(time) * 0.5 - cos(time * 2.0)) * sin(time * 0.5);\n    lineEnd.y += (cos(time) * 0.5 - sin(time * 2.0)) * sin(time * 0.5);\n    lineEnd *= 0.3;    \n    vec2 lineStart = vec2(0.0);\n    lineStart.x -= (sin(time) * 0.5 + cos(time * 2.0)) * cos(time * 0.4);\n    lineStart.y -= (cos(time) * 0.5 + sin(time * 2.0)) * cos(time * 0.4);\n#endif             \n    \n    for(float a = 0.0; a < 359.0; a += 360.0 / NB_SHAPES)\n    {\n        colorStr = 0.0;\n        colTime = time + 1.0 * a / 360.0;        \n    \tvec2 rotPos = rotate(pos, a);\n        \n\t#ifdef DRAW_CIRCLES        \n        colorStr += colorStrength(circle(rotPos - circlePos, dist));\n\t#endif \n        \n\t#ifdef DRAW_LINES        \n        vec2 seg = lineEnd - lineStart;\n        colorStr += colorStrength(segment(rotPos - lineStart,\n                                          normalize(seg),\n                                          vec2(length(seg), LINE_THICKNESS)));        \n\t#endif                \n        col += vec3(0.5 + 0.5 * cos(colTime * 5.0),\n                    0.5 + 0.5 * cos(colTime * 5.0 + 3.14),\n                    0.5 + 0.5 * sin(colTime * 5.0)) * colorStr;\n    }\n       \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float startTime = iTime - iMouse.x / iResolution.x * 5.0;\n    float time = 0.0;\n    vec2 fragPos = pixelToNormalizedspace(fragCoord);\n\tvec2 uv = fragCoord.xy / iResolution.xy;        \n    \n    vec3 finalCol = vec3(0.0);\n\n    //float rnd = hash( fragPos + fract(iTime) );\n    float rnd = texelFetch( iChannel0, ivec2( ivec2(fragCoord)%textureSize(iChannel0,0).xy), 0 ).r;\n    //fragColor = vec4( vec3(rnd), 1.0 ); return;\n    \n    float scale = 1.0;\n    \n    float sumw = 0.0;\n    float prev_time = startTime * SPEED;\n    for(float rep = 0.0; rep < NB_REPEAT; ++rep)\n    {\n        time = (startTime - rep * TRAIL_DUR/NB_REPEAT) * SPEED;\n        float w = pow(1.0 - rep / NB_REPEAT, 2.0);\n        sumw += w;\n        finalCol += draw(fragPos, time, prev_time, rnd) * w;\n        #ifndef TRAIL_MODE\n        scale *= 1.0 + TRAIL_DUR / NB_REPEAT;\n        #endif\n        prev_time = time;\n    }\n    finalCol /= sumw;\n    finalCol *= 7.0;\n    \n\tfragColor = vec4(finalCol, 1.0);\n    fragColor = pow( fragColor, vec4(1.0/2.2));\n}\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lySRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 244, 244, 271], [273, 273, 314, 314, 510], [512, 512, 548, 548, 682], [684, 684, 722, 722, 763], [765, 765, 811, 811, 1107], [1109, 1109, 1141, 1141, 1299], [1301, 1301, 1325, 1325, 1448], [1449, 1449, 1474, 1474, 1508], [1510, 1510, 1574, 1574, 3267], [3269, 3269, 3326, 3326, 4349]], "test": "error"}
{"id": "4lySzy", "name": "PolarVisualizer", "author": "Lallis", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 22, "viewed": 1139, "published": "Public API", "date": "1484745278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 32\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    //uv.x-=0.25;\n    //uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 1.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.99;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,0.25) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 4;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.05,0.05,1.0);\n    colors[1] = vec3(0.05,1.00,1.00);\n    colors[2] = vec3(0.50,1.00,0.25);\n    colors[3] = vec3(1.00,0.75,0.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*0.5;\n    \n    col += vec3(1.0-smoothstep(-0.5,0.0,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-0.5,0.0,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.125,0.375,f);\n    col *= smoothstep(0.875,0.625,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.2);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(0.0025,-0.0025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.y));\n\n    ref /= 8.0;\n     \n    float colStep = length(smoothstep(0.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(0.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*2.0-1.0))*0.15*smoothstep(0.75,-0.25,length(p*2.0-1.0));\n    vec3 plColBg = vec3(0.05)*smoothstep(1.0,0.0,length(p*2.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(0.5,0.65,1.0-uv.y);\n    \n    col += clamp(pl*(1.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*2.0/256.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lySzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 110, 110, 191], [193, 193, 235, 235, 294], [296, 296, 321, 321, 1857], [1859, 1859, 1916, 1916, 3173]], "test": "error"}
{"id": "4lyXDm", "name": "VeinedMarbleTest", "author": "Jabberwock", "description": "Trying noise and assorted things", "tags": ["3d"], "likes": 1, "viewed": 69, "published": "Public", "date": "1484577991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 blue=vec3(0.0,0.0,0.0);\nconst vec3 green=vec3(1.0,1.0,1.0);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)/*+floor(p.y)+floor(p.z)*/,2.0);\n    return mix(blue,green,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(0.88);\n   return t;\n     \n   \n}\nfloat turbulenceMetalRouille(in vec3 p,in vec3 n)\n{\n    // Utiliser ces couleurs pour le mÃ©tal rouillÃ©.\n    //const vec3 blue=vec3(1.52,0.87,0.23);\n\t//const vec3 green=vec3(0.5,0.5,0.5);\n    \n    \n    // Add scaled noises\n    float t=noise(p);\n   // t+=0.25*noise(2.0*p);\n    //t+=0.125*noise(5.0*p);\n    //t+=0.025*noise(13.0*p);\n    // Scale\n    //t/=(1.0+0.25+0.125+0.025);\n    // Modifier 0.8 pour changer la frÃ©quence des taches. rÃ©duire 0.8 augmente la frÃ©quence\n    if(t>0.2 && t<= 0.8){\n        return 0.0;\n    }else{\n        return 0.6;\n    }\n    return t;\n   \n}\n\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(blue,green,t);\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 marble(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (8.0*p,n);\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    \n    float t2 = turbulence(2.0*p,n);\n    \n    if(t2>=0.51 && t2 < 0.52){\n        return vec3(0.1);\n    }\n    \n    t2 = turbulence(5.0*p,n);\n    \n    if(t2>=0.51 && t2 < 0.52){\n        return vec3(0.0);\n    }\n    \n    return mix(blue,green,t);\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(1.0, 1.0,1.0);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*marble(p,n);//*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 156, 180, 180, 223], [225, 256, 282, 282, 651], [727, 780, 815, 815, 884], [1032, 1089, 1124, 1124, 1215], [1217, 1258, 1297, 1322, 1478], [1479, 1479, 1530, 1702, 2055], [2058, 2083, 2117, 2142, 2204], [2206, 2243, 2277, 2302, 2667], [2669, 2739, 2784, 2784, 2826], [2903, 3085, 3163, 3163, 3398], [3475, 3516, 3544, 3544, 3617], [3619, 3665, 3698, 3717, 4170], [4172, 4229, 4267, 4267, 4348], [4425, 4425, 4482, 4482, 5051]], "test": "valid"}
{"id": "4lyXRc", "name": "Mirror, Mirror", "author": "dr2", "description": "Androids reflecting", "tags": ["reflection"], "likes": 13, "viewed": 542, "published": "Public API", "date": "1485193232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Mirror, Mirror\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 qHit, qnHit, sunDir, msOrg;\nvec2 rAngACs;\nfloat tCur, dstFar, msRad, msDep, msDir, mDskRad, frmWid;\nint idObj;\nbool isRefl;\n\nfloat PrRndBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrERCylDf (vec3 p, float r, float rt, float h);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat AngQnt (float a, float s, float nr);\n\nconst float pi = 3.14159;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w;\n  float sd, f;\n  vec2 e = vec2 (0.01, 0.);\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * (1. - max (rd.y, 0.)) +\n       0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.);\n    f = Fbm2 (0.02 * (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.01)));\n    col = mix (col, vec3 (1.), clamp (0.2 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    ro -= (ro.y / rd.y) * rd;\n    w = 4. * ro.xz;\n    f = Fbm2 (w);\n    col = mix (vec3 (0.3, 0.4, 0.1), vec3 (0.4, 0.5, 0.2), f) *\n         (1. - 0.1 * Noisefv2 (w));\n    vn = normalize (vec3 (f - Fbm2 (w + e.xy), 0.1, f - Fbm2 (w + e.yx)));\n    col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.45, 0.55, 0.7), pow (1. + rd.y, 64.));\n  }\n  return col;\n}\n\nfloat MirHit (vec3 ro, vec3 rd)\n{\n  vec3 v;\n  float h, b, d;\n  v = ro - msOrg;\n  b = dot (rd, v);\n  d = b * b + msRad * msRad - dot (v, v);\n  h = dstFar;\n  if (d > 0.) {\n    d = sqrt (d);\n    h = - b + d * msDir;\n    qHit = ro + h * rd;\n    v = qHit - msOrg;\n    if (qHit.z > 0. || length (v.xy) > mDskRad) h = dstFar;\n    else qnHit = v / msRad;\n  }\n  return h;\n}\n\nfloat RobDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 s;\n  float d, szFac;\n  p.xz = vec2 (- p.z, p.x);\n  szFac = 8.;\n  p *= szFac;\n  dMin *= szFac;\n  q = p;  q.y -= 2.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q = p;  q.y -= 1.2;\n  d = min (d, PrERCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = p;  q.x = abs (q.x) - 0.3;  q.y -= 3.;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  q.y -= 0.1;\n  d = min (d, PrERCylDf (q.xzy, 0.06, 0.04, 0.3));\n  q = p;  q.x = abs (q.x) - 1.05;  q.y -= 2.1;\n  q.yz = Rot2Cs (q.yz, rAngACs * vec2 (1.));\n  q.y -= -0.8;\n  d = min (d, PrERCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;  q.x = abs (q.x) - 0.4;  q.y -= 0.2;\n  d = min (d, PrERCylDf (q.xzy, 0.25, 0.15, 0.55));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;  q.x = abs (q.x) - 0.4;  q.yz -= vec2 (2.6, 0.7);\n  d = PrSphDf (q, 0.15);\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  dMin /= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (! isRefl) {\n    d = dMin;\n    q = p;\n    q.y -= msOrg.y;\n    d = min (d, PrCylDf (q, mDskRad + frmWid, msDep));\n    q.z -= -0.01;\n    d = max (d, - PrCylDf (q, mDskRad, msDep));\n    if (d < dMin) { dMin = d;  idObj = 1; }\n    q = p;\n    q.y -= 0.2 * frmWid;\n    d = PrRndBoxDf (q, vec3 (0.4, 0.2 * frmWid, msDep), 0.01);\n    if (d < dMin) { dMin = d;  idObj = 1; }\n  }\n  q = p;\n  q.xz = Rot2D (q.xz, AngQnt (atan (q.z, - q.x), 0.5, 13.));\n  q.x -= -2.;\n  dMin = RobDf (q, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 25; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.02;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, dstMir, sh;\n  int idObjT;\n  bool isBg;\n  if (rd.z > 0.) dstMir = MirHit (ro, rd);\n  else dstMir = dstFar;\n  isRefl = false;\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstMir < min (dstObj, dstFar)) {\n    rd = reflect (rd, qnHit);\n    ro = qHit;\n    isRefl = true;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj >= dstFar) isBg = true;\n  } else if (dstObj >= dstFar) isBg = true;\n  if (! isBg) {\n    ro += dstObj * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == 1) {\n      vn = VaryNf (100. * ro, vn, 2.);\n      col = vec3 (0.6, 0.4, 0.1);\n    } else if (idObj == 2) col = vec3 (0.8, 0.2, 0.5);\n    else if (idObj == 3) col = vec3 (1., 1., 0.);\n    sh = ObjSShadow (ro, sunDir);\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       0.2 * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  } else {\n    col = BgCol (ro, rd);\n    if (rd.y < 0.) {\n      ro -= (ro.y / rd.y) * rd;\n      col *= ObjSShadow (ro, sunDir);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 15.;\n  az = 0.;\n  el = 0.02 * pi;\n  if (mPtr.z > 0.) {\n    az = clamp (az - 4. * mPtr.x, -0.4 * pi, 0.4 * pi);\n    el = clamp (el - 3. * mPtr.y, -0.01 * pi, 0.3 * pi);\n  } else az += 0.3 * pi * sin (0.011 * 2. * pi * tCur);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  t = mod (0.1 * tCur, 2.);\n  msDir = 2. * floor (t) - 1.;\n  t = pow (0.5 * (1. + cos (2. * pi * t)), 2.);\n  msRad = exp (8. * t) + 0.4;\n  mDskRad = 0.75;\n  frmWid = 0.05;\n  msDep = 0.25;\n  msOrg = vec3 (0., mDskRad + frmWid,\n     - sqrt (msRad * msRad - mDskRad * mDskRad) * msDir - msDep);\n  t = 2. * pi * (0.5 - abs (mod (0.3 * tCur, 1.) - 0.5)); \n  rAngACs = vec2 (cos (t), sin (t));\n  ro = vec3 (0., mDskRad + frmWid, -7.) * vuMat;\n  rd = normalize (vec3 (uv, 5.)) * vuMat;\n  sunDir = normalize (vec3 (-1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRndBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrERCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z - 0.5 * h) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat AngQnt (float a, float s, float nr)\n{\n  return (s + floor (a * (nr / (2. * pi)))) * (2. * pi / nr);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.1, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyXRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[642, 642, 673, 673, 1472], [1474, 1474, 1507, 1507, 1838], [1840, 1840, 1874, 1874, 2717], [2719, 2719, 2741, 2741, 3287], [3289, 3289, 3322, 3322, 3498], [3500, 3500, 3521, 3521, 3728], [3730, 3730, 3767, 3767, 3992], [3994, 3994, 4029, 4029, 5084], [5086, 5086, 5142, 5142, 6388], [6390, 6390, 6434, 6434, 6481], [6483, 6483, 6516, 6516, 6543], [6545, 6545, 6587, 6587, 6638], [6640, 6640, 6694, 6694, 6883], [6885, 6885, 6928, 6928, 6992], [6994, 6994, 7024, 7024, 7082], [7084, 7084, 7115, 7115, 7179], [7302, 7302, 7326, 7326, 7373], [7375, 7375, 7400, 7400, 7599], [7601, 7601, 7622, 7622, 7761], [7763, 7763, 7792, 7792, 8004], [8006, 8006, 8045, 8045, 8252]], "test": "error"}
{"id": "4lyXWz", "name": "Shine", "author": "KitVanDeBunt", "description": "This wasn't exactly the plan but looks cool.", "tags": ["2d", "oops"], "likes": 14, "viewed": 299, "published": "Public", "date": "1483749881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.2831853071\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n\tvec2 uv = 0.5 + (fragCoord -.5*r)/r.y;\n    \n    float particlePower = 0.0;\n    \n    vec2 p = vec2(0.5)-uv;\n    \n    float angle = (atan(p.x,p.y)/TAU)+0.5;\n    float dc = length(vec2(0.5)-uv);\n    fragColor = vec4(1.0);\n    float rand = texture(iChannel0,vec2(angle,iTime*0.02)).x;\n    float shinePower = pow((sin(iTime*1.0)+2.0)*1.2,1.5);\n    rand = clamp(rand*dc*8.0,0.5,0.8);\n    fragColor = fragColor-vec4(0.0,rand*0.2*dc*shinePower,rand*dc*shinePower,0.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 601]], "test": "error"}
{"id": "4lyXz3", "name": "Circular Multiplication Graph", "author": "n1kk", "description": "A circle of multiplication relations. Point on a circle represents number. Multiply each number to get a second point and draw a line. Repeat for each number on a circle (200). Points loop (201 == 1). Animating multiplier value we see interesting patterns", "tags": ["circles", "patterns", "lines", "multiplication"], "likes": 26, "viewed": 401, "published": "Public", "date": "1485190110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define LINE_COUNT 400.\n//#define ANIMATE_HALF_FILL true\n\nfloat getLineThickness(float thickness) {\n    // thickness optimized for resolution\n    return thickness * 400. / max(iResolution.x, iResolution.y); \n}\n\n//------- CIRCLE\n\nfloat circle(vec2 origin, vec2 pos, float radius, float thickness)\n{\n    float n = 100.0 / getLineThickness(thickness);\n    return clamp(((1.0-abs(length(origin + pos)-radius))-(1.0 - 1.0/n)) * n, 0.0, 1.0);\n}\n\nfloat circle(vec2 origin, vec2 pos, float radius)\n{\n    return circle(origin, pos, radius, 1.0);\n}\n\nfloat circleFill(vec2 origin, vec2 pos, float radius)\n{\n    return clamp(((1.0-(length(origin+pos)-radius))-0.99)*100.0, 0.0, 1.0);   \n}\n\nfloat circleGlow(vec2 origin, vec2 pos, float radius, float len, float str)\n{\n    float inCircle = ((1.0-(length(origin + pos)-(radius + len)))-0.99) * str;\n    return clamp(inCircle, 0.0, 1.0);   \n}\n\nfloat circleLineGlow(vec2 origin, vec2 pos, float radius, float len, float str)\n{\n    float inCircle = ((1.0-abs(length(origin + pos)-(radius)) + len)-0.99) * str;\n    return clamp(inCircle, 0.0, 1.0);   \n}\n\n// ------ LINE \n\nfloat line(in vec2 p, in vec2 a, in vec2 b, float thickness)\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    //return clamp(((1.0 - d)-0.99)* 100.0 , 0.0, 1.0);\n\t//float n = 100.0 / thickness;\n    float n = 100.0 / getLineThickness(thickness);\n    return clamp(((1.0 - d) - (1.0 - 1.0/n)) * n , 0.0, 1.0);\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn line(p, a, b, 1.0);\n}\n\nfloat lineGlow(in vec2 p, in vec2 a, in vec2 b, float str )\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    float n = 10.0;\n    return 0.1 * str * clamp(((1.0 - d) - (1.0 - 1.0/n)) * n , 0.0, 1.0);\n}\n\n// ------- GEOM\n\nvec2 pointOnACircle(vec2 pos, float r, float a) {\n \treturn vec2(pos.x + r * sin(a),  pos.y + r * cos(a));\n}\n\n// ------ GRAPH\n\nfloat multCircle(vec2 origin, vec2 pos, float radius, float multiplier, \n           float cglow, float cglows, float lglow,\n           bool ccw, float angle_shift) {\n    float c = .0;\n    \n    c += circle(origin, pos, radius, 1.0);\n    c += circleLineGlow(origin, pos, radius, cglow, cglows);\n    \n    for (float i = 0.0; i <= LINE_COUNT; i++) {\n#ifdef ANIMATE_HALF_FILL\n        if (i > LINE_COUNT * \n            (.5 + .5 * smoothstep(-1., 1., sin(iTime*.5)))) break;\n#endif                \n        float rotation_dir = ccw ? -1. : 1.;\n        float angle1 = i * (2.*PI/LINE_COUNT);\n        float angle2 = multiplier * i * (2.*PI/LINE_COUNT);\n        \n        vec2 pos1 = pointOnACircle(pos, radius, angle_shift + angle1 * rotation_dir);\n        vec2 pos2 = pointOnACircle(pos, radius, angle_shift + angle2 * rotation_dir);\n        \n        c += line(origin, pos1, pos2, 0.8) * 0.5;\n        c += lineGlow(origin, pos1, pos2, lglow) * 0.5;\n    }\n    \n    return c;\n}\n\n/// =============== MAIN ===================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // origin\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime * 0.5;\n    \n    #define c(t, s) 0.5 + 0.25 * sin(t+s)\n    \n    vec3 colour1 = vec3(c(t,2.96), c(t,54.88), c(t,48.11));\n\tvec3 colour2 = vec3(c(t,12.51), c(t,2.58), c(t,71.99));\n    \n    vec3 c = vec3(0);\n    \n    bool clicked = iMouse.z > 0. || iMouse.w > 0.;\n    \n    #define C_RAD 0.9\n    #define C_POS vec2(0)\n    // 8.69 10.091 11.0 12.11 13.5 15.285 17.666 19.182\n    #define START_FRAME 102.5\n    \n    float speed = (clicked ? 0.1 : 0.5);\n    speed *= (0.4 + 0.15 * sin (iTime*0.1));\n    float M = START_FRAME + iTime * speed;\n    \n    float inCircle = circleFill(p, C_POS, C_RAD);\n    if (inCircle > .0) {\n   \t\tc += multCircle(p, C_POS, C_RAD, M, \n                        0.1, 0.5, 0.4,\n                       true, iTime*.05);\n        c *= colour1;\n    } else {\n    \tc += multCircle(p, C_POS, 2.0, START_FRAME + M * 0.05, \n                        0.1, 1.0, 0.9,\n                       false, -iTime*.01);\n    \tc *= colour2;\n    }\n    \n    c = clamp(c, 0.0, 1.0);\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 124, 166, 234], [254, 254, 322, 322, 463], [465, 465, 516, 516, 563], [565, 565, 620, 620, 701], [703, 703, 780, 780, 902], [904, 904, 985, 985, 1110], [1129, 1129, 1191, 1191, 1528], [1530, 1530, 1577, 1577, 1607], [1609, 1609, 1670, 1670, 1900], [1919, 1919, 1968, 1968, 2026], [2045, 2045, 2210, 2210, 3010], [3058, 3058, 3115, 3115, 4270]], "test": "valid"}
{"id": "4tdSDX", "name": "Iceberg", "author": "otaviogood", "description": "I had a lot of trouble getting the snow to look right. It's good enough, but it could still be better.", "tags": ["iceberg"], "likes": 75, "viewed": 5941, "published": "Public API", "date": "1483684461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 15.1; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n// Some computers were crashing, so I scaled this down by default.\n//#define HQ_NOISE\n\n// Makes compile times much faster.\n// Forces for loops to not unroll because compiler thinks the zero is not a constant.\n#define ZERO_TRICK max(0, -iFrame)\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat fade = 1.0;\nfloat exposure = 1.0;\n\n// lighting vars\nvec3 sunDir = normalize(vec3(0.93, 1.0, 1.0));\nconst vec3 sunCol = vec3(250.0, 220.0, 200.0) / 3555.0;\nconst vec3 horizonCol = vec3(0.95, 0.95, 0.95)*1.3;\nconst vec3 skyCol = vec3(0.03,0.45,0.95);\nconst vec3 groundCol = vec3(0.003,0.7,0.75);\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n// noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise1d(float uv)\n{\n    float fr = fract(uv);\n    float fl = floor(uv);\n    float h0 = Hash11(fl);\n    float h1 = Hash11(fl + 1.0);\n    return mixP(h0, h1, fr);\n}\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noiseValue(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*150.0)*7000.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.2;\n}\n\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\n{\n    // fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\n    // make clouds - just a horizontal plane with noise\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\n    n = pow(abs(n), 3.0);\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\n\n    // add the sun\n    finalColor += GetSunColorSmall(rayDir, sunDir);\n    return finalColor;\n}\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\nfloat cyl(vec3 p, float rad)\n{\n    return length(p.xy) - rad;\n}\n\nfloat sSphere(vec3 p, float rad)\n{\n    return length(p) - rad;\n}\n\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\nconst float sway = 0.015;\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface, a material index,\n// and the difference between the iceberg distance and the water distance.\nvec3 DistanceToObject(vec3 p)\n{\n    float dist = p.y;\n\n    if (abs(dist) < 0.07)  // Only calculate noise if we are close.\n    {\n        // Sum up different frequencies of noise to make water waves.\n        float waterNoise = noise2d(p.xz*4.0+localTime)*0.1 +\n            noise2d(p.xz*8.0+localTime)*0.03 +\n            noise2d(p.xz*16.0-localTime)*0.015 +\n            noise2d(p.xz*32.0-localTime)*0.005 +\n            noise2d(p.xz*64.0-localTime)*0.002;\n        // Fade the waves a bit in the distance.\n    \tdist += waterNoise * 0.2 * saturate(8.0/length(p.xz));\n    }\n    vec2 water = vec2(dist, 1.0);\n\n    p = RotateZ(p, sin(localTime)*sway);\n    // Sculpt the iceberg.\n    float slant = (p.y + p.x*0.25) / 1.0307;\n    slant -= cos(p.z*2.0)*0.0625;\n    dist = sSphere(p, 2.0) + sin(p.z*4.0)*0.125;\n    dist = smin(dist, sSphere(p + vec3(1.0, 11.85, 0.0), 12.0), -5.0);\n    float chop = cyl(p.xzy + vec3(1.5), 1.5);\n    float chop2 = cyl(p.xyz + vec3(0.0, -0.5, 0.0), 0.6) + sin(p.z*2.0)*0.125;\n    chop2 = min(chop2, -slant + 1.6);\n    chop2 = min(chop2, sdBox(p + vec3(-1.75, -0.74, -2.0), vec3(0.7)));\n    chop = smin(chop, chop2, -10.0);\n    chop = min(chop, chop2);\n    dist = -smin(-dist, chop, -30.0);\n    if (abs(dist) < 0.5)  // Only calculate noise if we are close.\n    {\n    \t//dist += noise1d(slant*4.0+1.333)*0.1 + noise1d(slant*8.0+1.333)*0.05;\n    \tdist += noiseValue(vec3(slant)*4.0)*0.1 + noiseValue(vec3(slant)*8.0)*0.05;\n        float snowNoise=0.0;\n   \t\tsnowNoise = noiseValue(p*4.0)*0.5*0.5;\n   \t\tsnowNoise += noiseValue(p*8.0)*0.125*0.25;\n        // prevent crashing on mac/chrome/nvidia\n#ifdef HQ_NOISE\n   \t\tsnowNoise += noiseValue(p*16.0)*0.125*0.0625;\n   \t\tsnowNoise += noiseValue(p*32.0)*0.0625*0.0625;\n#endif\n        //snowNoise -= abs(fract(p.z*0.5-p.y*0.05)-0.5)*2.0;\n        //snowNoise -= 0.95;\n        dist += snowNoise*0.25;\n    }\n    vec2 iceberg = vec2(dist, 0.0);\n    vec2 distAndMat = matmin(water, iceberg);\n    return vec3(distAndMat, water.x - iceberg.x);\n}\n\nvec3 TraceOneRay(vec3 camPos, vec3 rayVec, out vec3 normal, out vec3 distAndMat, out float t) {\n    normal = vec3(0.0);\n    distAndMat = vec3(0.0, -1.0, 1000.0);  // Distance and material\n    vec3 finalColor = vec3(0.0);\n\t// ----------------------------- Ray march the scene ------------------------------\n\tt = 0.0;\n\tconst float maxDepth = 32.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0.0);\n    const float smallVal = 0.00625;\n\t// ray marching time\n    for (int i = 210; i >= ZERO_TRICK; i--)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(pos);\n\n        // move down the ray a safe amount\n        t += distAndMat.x;\n        if (i == 0) t = maxDepth+0.01;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\n        //vec3 normalU = vec3(0.0);\n        //for( int i=ZERO_TRICK; i<4; i++ )\n        //{\n        //    vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        //    float dto = DistanceToObject(pos+0.0005*e).x;\n        //    normalU += e*dto;\n        //}\n        normal = normalize(normalU);\n\n        // Giant hack for border between water and snow to look nice.\n        if (abs(distAndMat.z) < smallVal*0.25) normal = vec3(0.0, 0.2, 0.0);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        vec3 distAndMatA = DistanceToObject(pos + normal * 0.4);\n        ambientS *= saturate(distAndMatA.x*2.5);\n        distAndMatA = DistanceToObject(pos + normal * 0.8);\n        ambientS *= saturate(distAndMatA.x*1.25);\n        float ambient = ambientS;\n        ambient *= saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        //ambient = max(0.05, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\n        ambient = max(0.15, ambient);\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = ZERO_TRICK; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.1, tempDist)*1.2;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // Trace a ray through the solid for sub-surface scattering\n        float scattering = 1.0;\n        iter = 0.05;\n\t\tfor (int i = ZERO_TRICK; i < 8; i++)\n        {\n            float tempDist = -DistanceToObject(pos - normal * iter).x;\n\t        scattering *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.001, tempDist);//*0.6;\n        }\n        scattering = saturate(scattering);\n        //scattering = (1.0-sunShadow)*(1.0-length(sunDir * iter));\n        scattering = saturate(1.0-iter);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.0);\n        // Underwater green glow\n        float fade = 1.0-saturate(abs(distAndMat.z)*3.5);\n        vec3 greenFade = mix(vec3(0.1, 0.995, 0.65)*0.95, vec3(0.75, 1.0, 1.0), fade*fade);\n        texColor += greenFade * fade;\n        texColor *= 0.75;\n        // iceberg\n        if (distAndMat.y == 0.0) {\n            texColor = vec3(1.0);\n        }\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(14.0)*sunCol * saturate(dot(sunDir, normal)) * (sunShadow*0.7+0.3);\n        // weighted average the near ambient occlusion with the far for just the right look\n\n        // apply the light to the texture.\n        finalColor = texColor * lightColor;\n        vec3 underwaterGlow = vec3(0.002, 0.6, 0.51);\n        // water\n        if (distAndMat.y == 1.0) {\n\t        finalColor += underwaterGlow*0.25 * length(normalU)*80.0;\n\t        finalColor += vec3(0.02, 0.5, 0.71)*0.35 * saturate(1.0-ambient);\n            finalColor += skyCol*0.02 * ambientS;\n        }\n        // iceberg\n        if (distAndMat.y == 0.0) {\n            float fade = saturate(1.0-pos.y);\n\t        // Add sky color\n            finalColor += (skyCol*0.6 + horizonCol*0.4)*1.5 * saturate(normal.y *0.5+0.5);\n\t\t\tvec3 rotPos = RotateZ(pos, sin(localTime)*sway);\n            float noiseScatter = 0.0;\n            float tempScale = 1.0;\n            for (int i = 0; i < 3; i++) {\n                noiseScatter += noiseValue(rotPos*32.0/tempScale)*0.25*tempScale;\n                tempScale *= 2.0;\n            }\n//            noiseValue(rotPos*32.0)*0.25 +\n  //              noiseValue(rotPos*16.0)*0.5 +\n    //            noiseValue(rotPos*8.0)*1.0;\n\t        finalColor += groundCol * 0.5 * max(-normal.y*0.5+0.5, 0.0) * (noiseScatter*0.3+0.6);\n            finalColor += underwaterGlow * 0.35 * saturate(0.5-saturate(abs(pos.y*3.0)));\n            finalColor += vec3(0.01, 0.55, 0.7) * saturate(scattering-sunShadow*0.3)*0.25;\n            finalColor = mix((underwaterGlow + vec3(0.5, 0.9, 0.8))*0.5, finalColor, saturate(distAndMat.z*64.0)*0.75+0.25);\n            finalColor *= 0.7;\n        }\n\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw background.\n        finalColor = GetEnvMap(rayVec, sunDir);\n        distAndMat.y = -1.0;\n    }\n    return finalColor;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    fade = 1.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 2.0;  // zoom in\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0,0);\n\n    // debugging camera\n    float mx=-iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*5.0;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 12.0;\n    const float t2 = 20.0;\n    const float t3 = 38.0;\n    // Repeat the animation after time t3\n    localTime = fract(localTime / t3) * t3;\n    if (localTime < t1)\n    {\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(0.0, 0.4, -8.0);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 2.0;\n        camPos.y += smoothstep(0.0, 1.0, alpha) * 2.0;\n        camPos.z += smoothstep(0.0, 1.0, alpha) * 4.0;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,-0.5,0.5);\n        camLookat.y -= smoothstep(0.0, 1.0, alpha) * 0.5;\n    } else if (localTime < t2)\n    {\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(2.0, 4.3, -0.5);\n        camPos.y -= alpha * 3.5;\n        camPos.x = sin(alpha*1.0) * 9.2;\n        camPos.z = cos(alpha*1.0) * 6.2;\n        camUp=normalize(vec3(0,1,-0.005 + alpha * 0.005));\n        camLookat=vec3(0,-1.5,0.0);\n        camLookat.y += smoothstep(0.0, 1.0, alpha) * 1.5;\n    } else if (localTime < t3)\n    {\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(-9.0, 1.3, -10.0);\n        //camPos.y -= alpha * 8.0;\n        camPos.x += alpha * 14.0;\n        camPos.z += alpha * 7.0;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0.0,0.0,0.0);\n    }\n#endif\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\tvec3 finalColor = vec3(0.0);\n\n    vec3 normal;\n    vec3 distAndMat;\n    float t;\n    finalColor = TraceOneRay(camPos, rayVec, normal, distAndMat, t);\n    float origDelta = distAndMat.z;\n    if (distAndMat.y == 1.0) {\n        vec3 ref = normalize(reflect(rayVec, normal));\n        ref.y = abs(ref.y);\n        vec3 newStartPos = (camPos + rayVec * t) + normal * 0.02; // nudge away.\n        float fresnel = saturate(1.0 - dot(-rayVec, normal));\n        fresnel = fresnel * fresnel * fresnel * fresnel * fresnel * fresnel;\n        fresnel = mix(0.05, 0.9, fresnel);\n        vec3 refColor = TraceOneRay(newStartPos, ref, normal, distAndMat, t);\n\t    finalColor += refColor * fresnel;\n    }\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= exposure;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0));//*saturate(fade));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdSDX.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1741, 1770, 1789, 1789, 1834], [1835, 1835, 1854, 1854, 1885], [1886, 1886, 1909, 1909, 1945], [1946, 1946, 1969, 1969, 2040], [2041, 2041, 2063, 2063, 2150], [2151, 2151, 2173, 2173, 2226], [2227, 2246, 2269, 2269, 2340], [2341, 2341, 2364, 2364, 2450], [2451, 2451, 2492, 2492, 2535], [2573, 2573, 2598, 2598, 2741], [2742, 2742, 2766, 2766, 3039], [3040, 3040, 3067, 3067, 3652], [3683, 3683, 3706, 3706, 3735], [3736, 3736, 3759, 3759, 3788], [3789, 3789, 3814, 3814, 3843], [3845, 3845, 3878, 3878, 3995], [3996, 3996, 4029, 4029, 4145], [4146, 4146, 4179, 4179, 4296], [4298, 4376, 4425, 4425, 4679], [4681, 4681, 4723, 4774, 5420], [5422, 5481, 5510, 5510, 5560], [5743, 5772, 5806, 5806, 5917], [5919, 5919, 5949, 5949, 5982], [5984, 5984, 6018, 6018, 6048], [6050, 6122, 6161, 6161, 6200], [6229, 6485, 6516, 6516, 8482], [8484, 8484, 8579, 8579, 15682], [15684, 15754, 15789, 15789, 19347], [20679, 20679, 20736, 20736, 22095]], "test": "valid"}
{"id": "4tGSDW", "name": "chainmail torus", "author": "balkhan", "description": "got inspired by this article : http://paulbourke.net/geometry/chainmail3d/", "tags": ["3d", "raymarching", "torus", "chain"], "likes": 7, "viewed": 172, "published": "Public", "date": "1484362454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I_MAX\t100\n#define E\t\t0.001\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat\tsdTorus( vec3 p, vec2 t );\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\tuv;\n\nfloat\tt;\nvec3\tbase;\n\n//#define X_ROT\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime/4.;\n    uv  = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3\tdir = camera(uv);\n    vec4\tcol = vec4(0.0);\n    vec3\tpos = vec3(.0, .0, 20.0);\n\n    #ifdef X_ROT\n\t    dir.x *= dir.x * sin(1.* atan(1.-dir.z, 1.-dir.y) );\n\t#endif\n    \n    vec4\tinter = (march(pos, dir));\n\n    if (inter.y == 1.)\n\t{\n        /*\n\t\t* taken from here : https://www.shadertoy.com/view/XsB3Rm\n\t\t*/\n\t\tvec3\tv = pos+inter.w*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(0.0, 0.0, 50.0);\n\t\tvec3\tlight_color = vec3(.3, .1, .0);\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 42.);\n        col.xyz = light_color * (specular) + diffuse*base;\n    }\n   \tfragColor = col;\n}\n\nfloat\tscene(vec3 p)\n{\n    vec2\trot = vec2( cos(t), sin(t) );\n    p.xz *= mat2( rot.x, rot.y, -rot.y, rot.x );\n    float\tmind = 1e5;\n    float\ttmp;\n\n\tp.xy = mod((p.xy), 2.4)-1.2;\n    \n\ttmp = mind = sdTorus(p, vec2(.8, .2) );\n    base = vec3(.75, 0., 0.);\n    p.x += 1.2;\n    p.yz *= mat2(0.,1.,-1.,0. );\n    mind = min(mind, sdTorus(p, vec2(.8, .2) ) );\n    if (mind != tmp)\n        base = vec3(0., 0., .75);\n    p.x -= 2.4;\n    mind = min(mind, sdTorus(p, vec2(.8, .2) ) );\n    if (mind != tmp)\n        base = vec3(0., 0., .75);\n    tmp = mind;\n    p.x += 2.4;\n    p.yz *= mat2(0.,-1.,1.,0. );\n    p.x -= 1.2;\n    p.y += 1.2;\n    p.xz *= mat2(0.,1.,-1.,0. );\n    mind = min(mind, sdTorus(p, vec2(.8, .2) ) );\n    if (mind != tmp)\n        base = vec3(0., .75, 0.);\n    tmp = mind;\n    p.y -= 2.4;\n    mind = min(mind, sdTorus(p, vec2(.8, .2) ) );\n    if (mind != tmp)\n        base = vec3(0., .75, 0.);\n    return(mind);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n\n    return length(q)-t.y;\n}\n\n//taken from an iq shader\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.85) * right + (uv.y-0.5) * up + fov * forw));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 369, 369, 1239], [1241, 1241, 1262, 1262, 2161], [2163, 2163, 2195, 2195, 2554], [2556, 2556, 2589, 2589, 2656], [2658, 2684, 2734, 2734, 2994], [2996, 2996, 3018, 3018, 3233]], "test": "error"}
{"id": "4tGSRw", "name": "[WIP] æ¡ã®è¯", "author": "lara", "description": "The flower from the manga \"Aku No Hana\".\n[url=http://plannueve.net/wp-content/uploads/2016/04/aku-no-hana-3877855-1-1140x860.jpg]Reference Image[/url]\n---\nI suck at shading :x", "tags": ["no", "aku", "hana"], "likes": 6, "viewed": 237, "published": "Public", "date": "1483470984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S 512   // Steps\n#define R 5.    // Sub steps\n#define P 0.001 // Precision\n#define D 100.   // Max distance\n#define A 5.    // AO steps\n\n#define T iTime\n#define PI 3.1415926\n#define TAU (PI*2.0)\n\nstruct Ray { vec3 o, d; }, _ray;\nstruct Camera { vec3 p, t; }, _cam;\nstruct Hit { vec3 p; float t, d; };\n\nvec2 _uv;\nfloat _d, _s;\nfloat _dfield;\nfloat _dgrass;\nfloat _dhead;\nfloat _dtentacles;\nfloat _deye;\nfloat _dstem;\nfloat _dsky;\n\n/* ============= */\n/* === UTILS === */\n/* ============= */\n\nfloat hash21(vec2 n)\n{\n    return fract(sin(dot(n,vec2(50159.91193,49681.51239)))*73943.1699);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdLine(vec3 p,vec3 a,vec3 b,float r)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p)-r;\n}\n\nfloat sdLineFlat(vec3 p,vec3 a,vec3 b,float r)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p)-r;\n}\n\n/* ============= */\n/* === SCENE === */\n/* ============= */\n\nfloat sdTentacles(vec3 p)\n{\n    float s = 40.;\n    float r = length(p);\n    \n    float a1 = atan(p.y,p.x);\n    float a2 = atan(p.z,length(p.xy));\n    \n    float f1 = mod(a1+PI,TAU/s)/TAU*s-.5;\n    float f2 = mod(a2+PI,TAU/s)/TAU*s-.5;\n    \n    if (a2 < -.8) return 1e10;\n    \n    float i = (hash21(vec2(floor(a1+PI)/TAU*s,floor((a2+PI)/TAU*s)))-.5)*TAU;\n    \n    p = vec3(r,f1,f2)+vec3(0,cos(i+T),cos(i+T))*.1;\n    \n    p.yz *= rot(r*TAU);\n    \n    vec3 p1 = vec3(1,0,0);\n    vec3 p2 = vec3(1.4+(i/TAU+.5)*.2,cos(i)*.2,sin(i)*.2);\n    \n    return sdLine(p,p1,p2,mix(.2,.0,length(p)-.6));\n}\n\nfloat sdField(vec3 p)\n{\n    float f = 6.;\n    \n    f += sin(p.x*.01)*10. * sin(p.z*.1);\n    f += textureLod(iChannel0,p.xz*.01,0.).x*.2;\n    \n    return p.y + f;\n}\n\nfloat sdGrass(vec3 p)\n{\n    vec3 p1 = p;\n    vec3 p2 = p+vec3(0.5,0,0.5);\n    \n    p1.xz = mod(p1.xz,1.)-.5;\n    p2.xz = mod(p2.xz,1.)-.5;\n    \n    float i1 = (hash21(floor(p.xz)*.001)-.5)*TAU;\n    float i2 = (hash21(floor(p.xz+.5)*.001)-.5)*TAU;\n    \n    float f = sin(1./exp(length(p.xz*.01))*20.-2.8)*5.;\n    float h = sdField(p)+f;\n    \n    return min(\n\t\tsdLine(p1,vec3(0,-5.-h,0),vec3(cos(i1)*.2,-4.-h,sin(i2)*.2),.1-sin(p.y-6.5+h)*.08),\n        sdLine(p2,vec3(0,-5.-h,0),vec3(cos(i2)*.2,-4.-h,sin(i1)*.2),.1-sin(p.y-6.5+h)*.08)\n    );\n}\n\n\n\nfloat scene(vec3 p)\n{\n    _d = 1e10;\n    \n    vec3 q;\n    float d = 1e10;\n    \n    _dgrass = sdGrass(p);\n    _dfield = smin(sdField(p),_dgrass,1.);\n    \n    _dsky = abs(length(p)-90.)-P;\n\n    // head\n    d = length(p)-1.;\n    d = max(d,-max(length(p.xy)-.5+abs(p.y)*max(sin(T),0.),p.z));\n    // eye lids\n    _dhead = d;\n    \n    // tentacles\n    q = p;\n    d = sdTentacles(q);\n    //q.xy *= rot(PI/8.);\n    //q.yz *= rot(-0.2);\n    //q.z -= .1;\n    //d = min(d,sdTentacles(q));\n    _dtentacles = smin(d,_dhead,.6);\n    \n    // eye\n    _deye = length(p+vec3(0,0,.2))-.8;\n    \n    // stem\n    q = p;\n    q.xy *= rot(sin(p.y*2.)*.05);\n    q.yz *= rot(sin(p.y*2.)*.02);\n    _dstem = max(length(q.xz)-.1,p.y);\n    \n    _d = min(_d,_dhead);\n    _d = min(_d,_dtentacles);\n    _d = min(_d,_deye);\n    _d = min(_d,_dstem);\n    _d = min(_d,_dfield);\n    _d = min(_d,_dgrass);\n    _d = min(_d,_dsky);\n    \n    //_d = min(_d,length(p.xy)-.1);\n    \n    return _d;\n}\n\n/* ================ */\n/* === MARCHING === */\n/* ================ */\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(P,0);\n    \n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\nHit march(Ray r)\n{\n    float t = 0.0, d;\n    \n    for(int i = 0; i < S; i++)\n    {\n        d = scene(r.o+r.d*t);\n        t += d/R;\n        \n        if (d < P || t > D) { _s = float(i); break; }\n    }\n    \n    return Hit(r.o+r.d*t, t, d);\n}\n\nRay lookAt(Camera cam, vec2 uv)\n{\n    vec3 d = normalize(cam.t-cam.p);\n    vec3 r = normalize(cross(d, vec3(0,1,0)));\n    vec3 u = cross(r, d);\n\n    return Ray(cam.p,normalize(r*uv.x + u*uv.y + d));\n}\n\n/* =============== */\n/* === SHADING === */\n/* =============== */\n\nfloat getAmbientOcclusion(Hit h) \n{    \n    float t = 0., a = 0.;\n    \n    for(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i/A*.1);\n        t += d;\n    }\n\n    return clamp(t/A*20.,0.,1.);\n}\n\nvec3 getColor(Hit h)\n{\n    if (h.d > P) { return vec3(0); }\n    \n    vec3 l = vec3(5,10,5);\n    vec3 c = vec3(0);\n    vec3 n = getNormal(h.p);\n\n    float diff = max(dot(n, normalize(l-h.p)),0.);\n    float spec = max(dot(reflect(normalize(h.p-l),n),normalize(_cam.p-h.p)),0.);\n    float ao = getAmbientOcclusion(h);\n    \n    if (_d == _dhead)\n    {\n        c += diff-hash21(h.p.xz)*.3;\n    }\n    else if (_d == _deye)\n    {\n        float f = 1.;\n        float l = length(h.p.xy);\n        float a = atan(h.p.y,h.p.x);\n        \n        // pupile\n        f *= 1.-step(l,.15+.05*max(sin(T),0.));\n        // iris\n        f *= 1.-step(l,.3)+(sin(a*37.+l)+1.)/4.*smoothstep(l,l+.1,.3);\n        c = vec3(f);\n    }\n    else if (_d == _dtentacles)\n    {\n        c = max(diff,.3)*vec3(length(h.p)-1.);\n       \n    }\n    else if (_d == _dgrass)\n    {\n        c = mix(vec3(0),vec3(0,.2,0)+spec*.5,1.-step(length(h.p.xz*.1),1.));\n    }\n    else if (_d == _dfield)\n    {\n        vec2 q = vec2(h.p.xz*.01);\n        //c = texture(iChannel1,q).r*vec3(.1,.4,.1);\n        //c += texture(iChannel1,q+vec2(.05)).b*vec3(.6,.2,0);\n        //c += .3;\n       \tc += ao*.3;\n    }\n    \n    \n    if (_d == _dsky)\n    {\n        vec3 p = h.p;\n        \n        p.yz *= rot(-T*.005);\n        \n        float s = 1000.;\n\n        float a1 = atan(p.z,p.x);\n        float a2 = atan(p.y,length(p.xz));\n\n        float f1 = (mod(a1+PI,TAU/s)/TAU*s-.5)*2.;\n        float f2 = (mod(a2+PI,TAU/s)/TAU*s-.5)*2.;\n        \n        vec2 q = vec2(floor((a1+PI)/TAU*s)/s,floor((a2+PI)/TAU*s)/s);\n        \n        float h1 = hash21(q);\n        float h2 = hash21(q+.1);\n        float f = step(h1,.01)*(1.-length(vec2(f1,f2)))*(1.+2.*step(h2,.1));\n        \n    \tfloat d = pow(length(h.p-_cam.p)/D,2.);\n    \ts = pow(max(dot(_ray.d,normalize(l)),0.),100.*d)*2.;\n        \n        f += s;\n        \n        c = vec3(f)-vec3(0,0,.2)*((a2+PI)/TAU-.7);\n    }\n    else\n    {\n        c *= 1./exp(length(h.p)/20.);\n    }\n   \n    // \"lense flare\"\n    return c + pow(max(dot(_ray.d,normalize(l)),0.),10.);\n}\n\n/* ============ */\n/* === MAIN === */\n/* ============ */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.yy;\n    vec2 uvm = iMouse.xy/iResolution.xy;\n    \n    _cam = Camera(vec3(0,2,-3), vec3(1,0,0));\n\n    if (iMouse.x > 10. || iMouse.y > 10.)\n    {\n        _cam.p.yz *= rot(-(uvm.y-.4)*2.);\n        _cam.p.xz *= rot((uvm.x-.5)*2.*PI);\n    }\n    else\n    {\n        _cam.p.xz *= rot(-.5);\n        _cam.p.yz *= rot(.1-(sin(T*.2)+1.)/2.);\n    }\n    \n    _ray = lookAt(_cam,_uv);\n    \n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)/iResolution.xy)*0.25;\n    \n    f += (hash21(_uv+iTime*.001)-.5)*.05;\n    \n    fragColor = vec4(getColor(march(_ray))*f, 1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 521, 521, 595], [597, 649, 690, 690, 783], [785, 785, 804, 804, 862], [864, 864, 908, 908, 974], [976, 976, 1024, 1024, 1090], [1153, 1153, 1180, 1180, 1742], [1744, 1744, 1767, 1767, 1907], [1909, 1909, 1932, 1932, 2451], [2455, 2455, 2476, 2476, 3407], [3479, 3479, 3503, 3503, 3658], [3660, 3660, 3678, 3678, 3899], [3901, 3901, 3934, 3934, 4101], [4170, 4170, 4205, 4205, 4382], [4384, 4384, 4406, 4406, 6422], [6482, 6482, 6539, 6539, 7157]], "test": "error"}
{"id": "4tGSWh", "name": "CS8EC v2", "author": "4onen", "description": "CS8EC, redone with radial mirroring to increase speed. On a dedicated graphics card, can support an infinite SIDE_COUNT.\n\nNote though, MAX_POLY_SIDE_COUNT changes do affect speed for values greater than ~256. Try not to raise that too much.", "tags": ["2d"], "likes": 9, "viewed": 255, "published": "Public", "date": "1484007009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Made by Matthew Dupree for fun. No profit, no credit.\n\n//Don't try stealing this to use for credit in CS8.\n//For one thing, you're probably not the only person in the class to find this.\n//If you both submit it and say \"Hey, look how smart we are!\" you two will\n//look pretty dumb to the academic counseling office.\n\n//Also, this is written in the wrong language. Go do your assignment in Python.\n\n//P.P.S. I know Python has an OpenGL library that could theoretically run this code\n//under the hood. That's not going to work either. The ShaderToy environment is\n//too complicated for someone in CS8 to replicate on-the-fly in Python.\n\n//Good luck!\n\n\n\n\n//The actual number of sides each polygon has in the shadertoy\n#define SIDE_COUNT 4\n//---------------------------------\n//CHANGE THE ABOVE VALUE FOR FUN!\n//---------------------------------\n\n//The maximum number of sides the polygon can have.\n//Necessary because loop counters can't be compared to dynamic numbers as the break condition.\n//Weird things happen if this is lower than SIDE_COUNT\n#define MAX_POLY_SIDE_COUNT 128\n\n//Pi. Does this really need explanation?\n#define PI 3.14159265358979323846264338\n//Epsilon, otherwise known as the programmer fudge factor.\n#define eps 0.01\n\n//Used to rotate things.\n//Returns a matrix that'll rotate a vector2 by angle radians about the origin.\nmat2 rotation(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,\n                s, c);\n}\n\nfloat toAngle(vec2 pos){\n    //Needed to flip the angle such that the angle given is from the vertical.\n    pos.y *= -1.0;\n    \n    //A piecewise function that smooths out atan's iffy output into a single\n    //value that increases all the way around the coordinate grid.\n    return step(0.0,pos.x)*(atan(pos.y/pos.x)-PI/2.0) \n         + step(0.0,-pos.x)*(atan(pos.y/pos.x)+PI/2.0)\n         + PI;//This PI avoid negative numbers, which make other math in here weird.\n}\n\n//Returns 1.0 when in the origin-centered rectangle given\nfloat smoothOriginRect(vec2 r, float w, float h){\n    float ret;\n    //If we have the right x coordinate, 1.0\n    ret =  smoothstep(0.0,eps,w/2.0-abs(r.x));\n    //If we have the right y coordinate, 1.0\n    ret *= smoothstep(0.0,eps,h/2.0-abs(r.y));\n    //Finally, multiply whether we have the right x and y.\n    return ret;\n}\n\n//Returns 1.0 at the very center of the given circle, dropping smoothly to the edge.\nfloat smoothPointBloom(vec2 r, vec2 center, float radius){\n    return 1.0-smoothstep(0.0,radius,length(center-r));\n}\n\n//Returns 1.0 when on the line given\n/*Inefficient version!\nfloat line(vec2 r, vec2 p1, vec2 p2, float lineWidth){\n    vec2 midpointRSpace = (p1+p2)/2.0;\n    \n    float angle = atan((p1.y-p2.y)/(p1.x-p2.x));\n    \n    vec2 rotatedSpaceCord = (r-midpointRSpace)*rotation(-angle);\n    \n    float lineLength = length(p1-p2);\n    \n    return smoothOriginRect(\n        rotatedSpaceCord,\n        lineLength+eps,\n        lineWidth\n    );\n}\nThis is a complete hack using rotational transformations on the r-coordinate. \nIt barely works and it does so with a lot of multiplications and trigonometric\nfunctions that could've been avoided. And, thanks to iq, (see comments) they are\nin the below version.\n*/\n\n//Returns 1.0 when on the line between the given points of width lineWidth.\n//All the credit to iq for this function. My abilities with dot products aren't\n//even close to that level of mastery.\nfloat line(vec2 r, vec2 p1, vec2 p2, float lineWidth)\n{\n    vec2 pa = r-p1, ba = p2-p1;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    return 1.0 - smoothstep(-eps/2.0, eps/2.0, d-lineWidth/10.0 );\n}\n//Again, props to iq for the above!\n\n//Returns 1.0 when on the described polygon's edge.\nfloat polygonWireframe(vec2 r, vec2 center, float radius, int sideCount, float lineWidth){\n    //Adjust our coordinate space so that the center of the polygon is the origin.\n    r -= center;\n    \n    //If we're outside any possible radius, break.\n    if(length(r)>radius+lineWidth) return 0.0;\n    //If the side count makes no sense, break.\n    if(sideCount<1) return 0.0;\n    \n    float ret = 0.0;\n    \n    //Point radius length up from center:\n    vec2 p0 = vec2(0.0, radius);\n    \n    //Angle of rotation swept by each edge:\n    float angle = 2.0*PI/float(sideCount);\n    //Angle of rotation of the currently checked pixel\n    float RSpaceAngle = toAngle(r);\n    //Rotation correction, such that drawing one line fills in all sides of the polygon.\n    r = rotation(-floor(RSpaceAngle/angle)*angle)*r;\n    \n    ret += line(r, p0, rotation(angle)*p0, lineWidth);\n    \n    \n    return ret;\n}\n\n//Returns 1.0 if the given point is on one of the lines of the described polygons.\n//Used to render polygons at each tip of a given polygon.\nfloat polyPointedPoly(vec2 r, vec2 center, float radius, int sideCount, float lineWidth){\n    //Adjust our coordinate space so that the center of the polygon is the origin.\n    r -= center;\n    \n    //If we're too far from this whole shape, don't even bother trying to render.\n    if(length(r)>radius+(radius*2.0/float(sideCount))+lineWidth) return 0.0;\n    //If we're doing something stupid, don't even bother trying to render.\n    if(sideCount < 1) return 0.0;\n    \n    float ret = 0.0;\n    \n    vec2 p0 = vec2(0.0, radius);\n    float angle = 2.0*PI/float(sideCount);\n    \n    //Angle of rotation of the currently checked fragment\n    float RSpaceAngle = toAngle(r)+angle/2.0;\n    //Rotation correction, such that drawing one line fills in all sides of the polygon.\n    r = rotation(-floor(RSpaceAngle/angle)*angle)*r;\n    \n    ret += polygonWireframe(r, p0, radius*2.0/float(sideCount), sideCount, lineWidth);\n    \n    return ret;\n}\n\n//Returns a vector 2 representing the position of this polygon's sideNumth point.\nvec2 getPolyPointN(vec2 center, float radius, int sideCount, int sideNum){\n    //This is the topmost point of the polygon.\n    vec2 p0 = vec2(0.0, radius);\n    //This is the angle swept between any two points of the polygon.\n    float angle = 2.0*PI/float(sideCount);\n    //This is the sideNumth point of the given polygon.\n    return center + p0*rotation(angle*float(sideNum));\n}\n\n//Returns a vector 2 representing the position of this polygon's sideNumth point,\n//adjusted by \"time\" to linearly phase toward the next side number.\n//Valid time values are 0.0 to 1.0\nvec2 getPolyPointNTimeAdjust(vec2 center, float radius, int sideCount, int sideNum, float time){\n    vec2 p0 = getPolyPointN(center, radius, sideCount, sideNum);\n    vec2 p1 = getPolyPointN(center, radius, sideCount, sideNum + 1);\n    //This point is time*100 percent of the distance from p0 to p1.\n    return p0*time + p1*(1.0-time);\n}\n\n//Returns a vector2 representing the position of the sideNumth point of the polyNumth polygon,\n//adjusted for time to linearly phase toward the next side number.\n//Valid time values are 0.0 to 1.0\nvec2 getPolyOfPolysPointNTimeAdjust(vec2 center, float radius, int sideCount, int polyNum, int sideNum, float time){\n    //Topmost poly center of the poly-of-polys\n    vec2 p0 = vec2(0.0, radius);\n    //Angle swept by any side of the poly-of-polys\n    float angle = 2.0*PI/float(sideCount);\n    //The center of the poly-of-polys polygon we care about.\n    vec2 p1 = p0*rotation(angle*float(polyNum));\n    //Finally, the time adjusted polygon point we actually care about.\n    return center + getPolyPointNTimeAdjust(p1, radius*2.0/float(sideCount), sideCount, sideNum, time);\n}\n\n//Main image, GLSL entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Make an aspect ratio out of it and align the origin to the center of the screen\n    vec2 r = -1.0 + 2.0*fragCoord/iResolution.xy;\n    r.x *= iResolution.x/iResolution.y;\n    \n    \n    //The current time, in two second loops.\n    //0.0 is 0 seconds, 1.0 is two seconds.\n    float time = mod(iTime,2.0)/2.0;\n    \n    //A list of colors. Have fun messing with these!\n    const vec3 bgColor = vec3(0.25,0.0,0.3);\n    const vec3 polyColor = vec3(5.0,0.0,5.0);\n    const vec3 lineColor = vec3(1.0,0.99,1.0);\n    const vec3 capColor = vec3(1.0);\n    \n    //Just some constants so that I don't have\n    //unlabeled numbers lying around everywhere.\n    //... Just mostly everywhere.\n    const float radius = 0.6;\n    const vec2 center = vec2(0.0);\n    \n    //Initially, set the background color.\n    vec3 ret = bgColor;\n    \n    \n    /* Inefficient version!\n    //Mix in the poly-pointed-poly on top.\n    ret = mix(ret,polyColor,polyPointedPoly(r, center, radius, SIDE_COUNT, 0.01));\n    \n    //Now the tricky bit. Cut the coordinate system such that \n    //every point is rotated into the 2pi/SIDE_COUNT space that\n    //contains one completely drawn polygon.\n    float angle = 2.0*PI/float(SIDE_COUNT);\n    r = rotation(-floor((toAngle(r)+angle/2.0)/angle)*angle)*r;\n    //Now if we draw in that 2pi/SIDE_COUNT space, it draws onto\n    //every polygon in the circle.\n\n\t\n\tAs you can see, the code in this inefficient comment used the poly-pointed-poly\n\tdraw function, then just replicated its functionality for the remaining draws.\n\t\n\tThe new version (below) just performs the poly-pointed-poly's draw operation\n\tfor it after setting up a similar coordinate space modification.\n\t*/\n    \n    \n    //Now the tricky bit. Cut the coordinate system such that \n    //every point is rotated into the 2pi/SIDE_COUNT space that\n    //contains one completely drawn polygon.\n    //This is the angle we need to cut\n    float angle = 2.0*PI/float(SIDE_COUNT);\n    //This is taking all of these slices and dropping them atop each other.\n    r = rotation(-floor((toAngle(r)+angle/2.0)/angle)*angle)*r;\n    //Now if we draw in that 2pi/SIDE_COUNT space, it draws onto\n    //every polygon space in the circle.\n    \n    //Next, mix in the poly-pointed-poly -- using only a single polygon draw!\n    //Notice, here, I'm moving the center of this polygon to where it would be\n    //on a poly-pointed-poly, and also reducing the radius to match.\n    ret = mix(ret,polyColor,polygonWireframe(r, vec2(0.0,radius), radius*2.0/float(SIDE_COUNT), SIDE_COUNT, 0.0));\n    \n    \n    \n    //Loop over every side, drawing the lines and dots.\n    for(int side=0; side<MAX_POLY_SIDE_COUNT; side++){\n        //If we're doing more sides than we have, don't bother.\n        if(side>=SIDE_COUNT) break;\n        \n        //This fetches the side points of the first and second polygons in the circle\n        vec2 p0 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, 0, side, time);\n        vec2 p1 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, 1, side+1, time);\n        //Draws a line between them\n        ret = mix(ret, lineColor, line(r, p0, p1, 0.01));\n        //And draws points onto the first polygon\n        ret = mix(ret, capColor, smoothPointBloom(r, p0, 0.015));\n        \n        //This fetches the side points of the negative first and first polygons in the circle\n        vec2 pNeg1 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, -1, side, time);\n        p0 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, 0, side+1, time);\n        //Then draws lines between them.\n        ret = mix(ret, lineColor, line(r, pNeg1, p0, 0.01));\n    }\n    \n    //Finally, output the return color.\n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1238, 1342, 1369, 1369, 1468], [1470, 1470, 1494, 1573, 1938], [1940, 1998, 2047, 2047, 2323], [2325, 2410, 2468, 2468, 2526], [3225, 3420, 3475, 3475, 3667], [3705, 3757, 3847, 3930, 4648], [4650, 4791, 4880, 4963, 5726], [5728, 5810, 5884, 5932, 6190], [6192, 6377, 6473, 6473, 6713], [6715, 6912, 7028, 7075, 7489], [7491, 7522, 7579, 7665, 11308]], "test": "valid"}
{"id": "4tGXWm", "name": "Phong blob test", "author": "Jabberwock", "description": "phong blob", "tags": ["3d"], "likes": 0, "viewed": 66, "published": "Public", "date": "1484551070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  vec3 lightPos = vec3(5.0* sin(iTime), 5.0* sin(iTime), 5.0);\n  const vec3 lightColor = vec3(0.1, 0.1, 0.7);\n  const vec3 SpecColor = vec3(1.0, 1.0, 1.0);\n\n  // Color of the object comes from background !\n  vec3 c = 0.25*background(n);\n    \n  vec3 l = normalize(lightPos - p);\n \n\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = dot(n, l);\n\n  c += diff*lightColor;\n  \n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 255, 255, 354], [356, 423, 458, 458, 531], [557, 671, 717, 717, 754], [756, 847, 877, 877, 895], [897, 985, 1015, 1015, 1038], [1040, 1086, 1108, 1108, 1304], [1306, 1346, 1377, 1377, 1597], [1599, 1704, 1755, 1755, 2190], [2192, 2297, 2354, 2354, 2805], [2808, 2828, 2854, 2854, 2926], [2928, 2989, 3017, 3034, 3465], [3607, 3607, 3664, 3664, 4417]], "test": "valid"}
{"id": "4tGXWz", "name": "GR - A Point on a Grid", "author": "bradleygriffith", "description": "A point on a grid.", "tags": ["grid", "point"], "likes": 0, "viewed": 70, "published": "Public", "date": "1483746786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358\n\nfloat whenEq(float x, float y) {\n  return 1.0 - abs(sign(x - y));\n}\n\nfloat whenNeq(float x, float y) {\n  return abs(sign(x - y));\n}\n\nfloat whenGt(float x, float y) {\n  return max(sign(x - y), 0.0);\n}\n\nfloat whenLt(float x, float y) {\n  return max(sign(y - x), 0.0);\n}\n\n// Taken from https://www.shadertoy.com/view/MdlGRr\nfloat IsGridLine(vec2 fragCoord, float spacing)\n{\n\t// Define the size we want each grid square in pixels\n\tvec2 vPixelsPerGridSquare = vec2(spacing);\n\t\n\t// Get a value in the range 0->1 based on where we are in each grid square\n\t// fract() returns the fractional part of the value and throws away the whole number part\n\t// This helpfully wraps numbers around in the 0->1 range\n\tvec2 vGridSquareCoords = fract(fragCoord / vPixelsPerGridSquare);\n\t\n\t// Convert the 0->1 co-ordinates of where we are within the grid square\n\t// back into pixel co-ordinates within the grid square \n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\n\t// step() returns 0.0 if the second parmeter is less than the first, 1.0 otherwise\n\t// so we get 1.0 if we are on a grid line, 0.0 otherwise\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\t\n\t// Combine the x and y gridlines by taking the maximum of the two values\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\n\treturn fIsGridLine;\n}\n\n// Useful for adjusting x or y distances in accordance with screen ratio.\nvec2 stepAdjustment () {\n    vec2 adjustment = vec2(1.0);\n\n    adjustment.x -= (1.0 - iResolution.y / iResolution.x) * whenGt(iResolution.y, iResolution.x);\n    adjustment.y -= (1.0 - iResolution.x / iResolution.y) * whenGt(iResolution.x, iResolution.y);\n   \n\treturn adjustment;\n}\n\n// Slope from degrees, adjusted for screen ratio.\nfloat normalizedSlopeForDegrees(float degrees) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n    float radians = degrees * (PI / 180.0);\n    float slope = tan(radians);\n\n    return ((slope * 100.0) / p.x) / (100.0 / p.y);\n}\n\n// Given x, a slope, and another point, find y for x.\nfloat yForXOnSlope(float x, float slope, vec2 p2) {\n\treturn -1.0 * ((slope * (p2.x - x)) - p2.y);\n}\n\n// Given y, a slope, and another point, find x for y.\nfloat xForYOnSlope(float y, float slope, vec2 p2) {\n    return ((y - p2.y) + (slope * p2.x)) / slope;\n}\n\nvec2 offsetsForUvAtDistanceOnSlope(float d, float slope) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n    float slopeAdjustment = 0.0;\n\n    slopeAdjustment += (iResolution.y / iResolution.x) * whenGt(iResolution.y, iResolution.x);\n    slopeAdjustment += (iResolution.x / iResolution.y) * whenGt(iResolution.x, iResolution.y);\n    \n    \n\treturn vec2(\n        ((d * p.x) * cos(atan(slope / slopeAdjustment))),\n        ((d * p.y) * sin(atan(slope / slopeAdjustment))) \n    );\n}\n\nfloat point(vec2 fragCoord, vec2 position, float width) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n\n    float dist = distance(fragCoord, position * iResolution.xy);\n    \n    return smoothstep(width, width + 1.0, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 stepAdjustment = stepAdjustment();\n    \n    vec2 position = vec2(0.5);\n    if (iMouse.z > 0.0) {\n        position = iMouse.xy / iResolution.xy;\n    }\n    \n    float pointWidth = 10.0;\n    float gridWidth = 20.0;\n    \n    // Test Config Here -----------------------------\n    \n    float angle = 45.0;\n    float slope = normalizedSlopeForDegrees(angle);\n    vec2 anchor = vec2(0.5);\n    \n    float x = (sin(iTime) / 4.0 * stepAdjustment.x) + 0.5;\n    position = vec2(x, yForXOnSlope(x, slope, anchor));\n    \n    //float y = (sin(iTime) / 4.0 * stepAdjustment.y) + 0.5;\n    //position = vec2(xForYOnSlope(y, slope, anchor), y);\n    \n    vec2 k = offsetsForUvAtDistanceOnSlope(0.0, slope);\n    position += k;\n    \n    //float reverseSlope = -(1.0 / slope);\n    //vec2 k2 = offsetsForUvAtDistanceOnSlope(0.0, reverseSlope);\n    //position += k2;\n   \t\n    // ----------------------------------------------\n    \n    float point = point(fragCoord, position, pointWidth);\n    float grid = IsGridLine(fragCoord, gridWidth);\n\n    fragColor = vec4(point - grid);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 58, 58, 93], [95, 95, 128, 128, 157], [159, 159, 191, 191, 225], [227, 227, 259, 259, 293], [295, 347, 396, 451, 1355], [1357, 1431, 1455, 1455, 1711], [1713, 1763, 1811, 1811, 1983], [1985, 2039, 2090, 2090, 2138], [2140, 2194, 2245, 2245, 2297], [2299, 2299, 2357, 2357, 2771], [2773, 2773, 2830, 2830, 2993], [2995, 2995, 3052, 3052, 4160]], "test": "valid"}
{"id": "4tGXzG", "name": "SmoothStep Sine", "author": "sandsfish", "description": "w/ some other options.", "tags": ["moire", "smoothstep", "sinewave"], "likes": 2, "viewed": 125, "published": "Public", "date": "1484722535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.2, pct, st.y) - \n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n\n    //float y = smoothstep(0.1,0.9,sin(iTime));\n    //float y = smoothstep(0.1,0.9,sin(st.x*iTime));\n    float y = smoothstep(0.1,0.9,sin(st.y*iTime*200.0));\n\n    vec3 color = vec3(y);\n    float pct = plot(st,y);\n    color = (1.0-pct)*color + pct*vec3(1.000,0.307,0.963)*.3;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 181, 181, 536]], "test": "valid"}
{"id": "4tGXzt", "name": "SoundEclipse", "author": "DuckMonster", "description": "Pretty simple audio visualizer", "tags": ["audiovisualization"], "likes": 19, "viewed": 1224, "published": "Public", "date": "1485368317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.2;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.0)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / (abs(dist - radius) + 0.005);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.6 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 0.6, 0.5 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency * 0.5;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.86, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\t//color += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 495], [497, 497, 526, 526, 618], [620, 620, 656, 656, 867], [869, 869, 904, 904, 968], [970, 970, 1012, 1012, 1490], [1492, 1492, 1543, 1543, 1795], [1798, 1798, 1855, 1855, 2290]], "test": "error"}
{"id": "4tGXzW", "name": "modified 2d Blocky Dissolve", "author": "electricity256", "description": "original shader: https://www.shadertoy.com/view/Xl2SRd\ni modified it a bit", "tags": ["2d", "effect", "transition", "dissolve"], "likes": 1, "viewed": 153, "published": "Public", "date": "1483299251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst float resolution = 5.0;\n    \nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(rand2(co.xy)*13.0,78.233))) * 43758.5453);\n}\n\n//float getRight(vec2 a){\n    \n//}\n\nfloat dist(vec2 a){\n    return pow(pow(a.x,2.0)+pow(a.y,2.0),0.5);\n}\n\nfloat closestEmptyDist(vec2 fc,float t){\n    float closestdist=resolution;\n    \n    for(float k=0.0;k<resolution*2.0;k++){\n        if(k>=resolution*2.0*(t)+2.0){\n        \tcontinue;   \n        }\n    \tfor(float v=0.0;v<resolution*2.0;v++){\n            if(v>=resolution*2.0*(t)+2.0){\n                continue;   \n            }\n            vec2 tmp2=vec2(\n                floor((fc.x+(v-resolution)*(t)+(1.0-t)) / resolution),\n                floor((fc.y+(k-resolution)*(t)+(1.0-t)) / resolution)\n            );\n            vec2 tmp3=vec2(\n                (v-resolution),\n                (k-resolution)\n            );\n        \tfloat tmp = rand(tmp2);\n            if(t < tmp){\n                float tmpdist=dist(tmp3);\n                if(closestdist>tmpdist){\n\t            \tclosestdist=tmpdist;\n                    \n                }\n            }else{\n             //   closestdist=0.0;\n            }\n        }\n    }\n    return (resolution-closestdist)/resolution;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 lowresxy = vec2(\n    \tfloor(fragCoord.x / resolution),\n    \tfloor(fragCoord.y / resolution)\n    );\n    \n    \n    float right = rand(vec2(\n    \tfloor((fragCoord.x+1.0) / resolution),\n    \tfloor(fragCoord.y / resolution)\n    ));\n    float left = rand(vec2(\n    \tfloor((fragCoord.x-1.0) / resolution),\n    \tfloor(fragCoord.y / resolution)\n    ));\n    float upper = rand(vec2(\n    \tfloor((fragCoord.x) / resolution),\n    \tfloor((fragCoord.y-1.0) / resolution)\n    ));\n    float lower = rand(vec2(\n    \tfloor((fragCoord.x) / resolution),\n    \tfloor((fragCoord.y+1.0) / resolution)\n    ));\n    \n    float curstage=(sin(iTime/7.0)+1.0)/2.0;\n    \n    if(curstage > rand(lowresxy)){\n        float bCurrent=0.999+floor((1.0+sin(1.0 * (fragCoord.x+fragCoord.y))/2.0));\n        float gCurrent=0.0;\n        float rCurrent=closestEmptyDist(fragCoord,curstage);\n            \n        /*if(curstage<right ){\n            gCurrent=1.0;\n        }\n        if(curstage<left ){\n            gCurrent=1.0;\n        }\n        if(curstage<upper ){\n            gCurrent=1.0;\n        }\n        if(curstage<lower ){\n            gCurrent=1.0;\n        }\n        \n        if(gCurrent!=1.0){\n            \n        }*/\n        \n\t\tfragColor = vec4(rCurrent,gCurrent,bCurrent,1.0);\n    }else{\n\t\tfragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 58, 58, 130], [131, 131, 151, 151, 233], [271, 271, 290, 290, 339], [341, 341, 381, 381, 1303], [1304, 1304, 1361, 1361, 2711]], "test": "valid"}
{"id": "4tKSRV", "name": "Swinning Pendulums", "author": "n1kk", "description": "some pendulums in motion with slightly different phase shift making nice patterns", "tags": ["circles", "patterns", "lines", "motion", "pendulum", "swing"], "likes": 12, "viewed": 314, "published": "Public", "date": "1485052836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getLineThickness(float thickness) {\n    // thickness optimized for resolution\n    return thickness * 400. / max(iResolution.x, iResolution.y); \n}\n\nfloat circle(vec2 origin, vec2 pos, float radius)\n{\n    float n = 100.0 / getLineThickness(1.0);\n    return clamp(((1.0-abs(length(origin + pos)-radius))-(1.0 - 1.0/n)) * n, 0.0, 1.0);\n}\n\nfloat circleFill(vec2 origin, vec2 pos, float radius)\n{\n    return clamp(((1.0-(length(origin+pos)-radius))-0.99)*150.0, 0.0, 1.0);   \n}\n\nfloat circleGlow(vec2 origin, vec2 pos, float radius, float len, float str)\n{\n    float inCircle = ((1.0-(length(origin + pos)-(radius + len)))-0.99) * str;\n    return clamp(inCircle, 0.0, 1.0);   \n}\n\n\n// courtesy of Inigo Quilez\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    //return clamp(((1.0 - d)-0.99)* 100.0 , 0.0, 1.0);\n\tfloat n = 100.0 / getLineThickness(1.5);\n    return clamp(((1.0 - d) - (1.0 - 1.0/n)) * n , 0.0, 1.0);\n}\n\nfloat lineGlow(in vec2 p, in vec2 a, in vec2 b, float str )\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    float n = 10.0;\n    return 0.1 * str * clamp(((1.0 - d) - (1.0 - 1.0/n)) * n , 0.0, 1.0);\n}\n\nvec2 pointOnACircle(vec2 pos, float r, float a) {\n \treturn vec2(pos.x + r * sin(a),  pos.y + r * cos(a));\n}\n\n//////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // origin\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 colour = vec3(0);\n    vec3 white = vec3(1);\n    \n    vec3 c = vec3(0);\n    \n    #define SWING_RADIUS 1.7\n    #define SWING_ANGLE 0.1\n    #define SWING_SPEED 5.5\n    #define PHASE_SHIFT_RATE 0.015\n    \n    #define SHIFT_X 0.0\n    #define SHIFT_Y -0.85\n    \n    #define BALL_COUNT 18.0\n    #define BALL_SIZE 0.045\n    #define BALL_GLOW_SIZE 0.4\n    #define BALL_GLOW_STR 0.09\n   \t\n    #define STRING_ALPHA 0.3\n    #define STRING_GLOW 0.25\n    #define SWING_ALPHA 0.05\n    \n    #define STRING_COLOR 0.8*vec3(1.0, 0.85, 0.0)\n    #define BALL_COLOR vec3(0.0, 0.4, 0.9)\n\n    #define START_FRAME_SHIFT 18.78\n\n    \n    for(float i = 1.0; i <= BALL_COUNT; i++) {\n    \tvec2 fixed_point = vec2(SHIFT_X, -SWING_RADIUS + SHIFT_Y);\n        float curr_phase = 1.0 - i * PHASE_SHIFT_RATE;\n        float ang_vel = cos(SWING_SPEED * (iTime + START_FRAME_SHIFT) * curr_phase);\n        float curr_raduis = SWING_RADIUS + i * 0.09;\n        float curr_swing = SWING_ANGLE  * ang_vel;\n        float curr_ball_radius = BALL_SIZE + i * 0.001;\n        vec2 ball_pos = pointOnACircle(fixed_point, curr_raduis, curr_swing);\n        //curr_ball_radius = curr_ball_radius + curr_ball_radius * (ang_vel > 0. ? 1. : -1.) * 0.1;\n        // ball\n        c += circleFill(p, ball_pos, curr_ball_radius);// * BALL_COLOR;        \n        c += circleGlow(p, ball_pos, curr_ball_radius, BALL_GLOW_SIZE, BALL_GLOW_STR);\n        // string\n        c += line(p, fixed_point, ball_pos) * STRING_ALPHA * STRING_COLOR;\n        c += lineGlow(p, fixed_point, ball_pos, STRING_GLOW) * STRING_COLOR;\n        // curve\n        c += circle(p, fixed_point, curr_raduis) * SWING_ALPHA;\n    }\n    \n    c = clamp(c, 0.0, 1.0);\n   \tcolour = white * c;\n    fragColor = vec4(colour, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 83, 151], [153, 153, 204, 204, 339], [341, 341, 396, 396, 477], [479, 479, 556, 556, 678], [681, 709, 756, 756, 1052], [1054, 1054, 1115, 1115, 1345], [1347, 1347, 1396, 1396, 1454], [1504, 1504, 1561, 1561, 3433]], "test": "valid"}
{"id": "4tKSRW", "name": "Blue Spoke Wheel", "author": "ptrgags", "description": "Another happy accident. I was in the process of making something along the lines of polar graph paper, but I'm taking this snapshot since I thought it looked cool.", "tags": ["2d", "grid", "distance", "polar"], "likes": 4, "viewed": 119, "published": "Public", "date": "1483276893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CENTER (iResolution.xy / 2.0)\n#define PI 3.1415\n#define TAU (2.0 * PI)\n\nvec2 rect_to_polar(vec2 rect) {\n    float r = length(rect);\n    float theta = atan(rect.y, rect.x);\n    \n    //Fix the coordinates so they go from 0 to 2PI\n    //instead of -PI to PI\n    if (theta < 0.0)\n        theta += TAU;\n    return vec2(r, theta);\n}\n\n//max component of 2-vector.\nfloat vecmax(vec2 p) {\n    return max(p.x, p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Centered UV coords accounting for aspect ratio\n\tvec2 uv = (fragCoord.xy - CENTER) / iResolution.y;\n    \n    //Convert to polar and normalize angle\n    vec2 polar = rect_to_polar(uv);\n    \n    //Rotate over time\n    polar.y += iTime;\n    \n    //Normalize the angle\n    polar.y /= TAU;\n    \n    //Divide into boxes\n    polar *= vec2(10.0, 24.0);\n    vec2 polar_uv = fract(polar);\n    \n    //Get distance from center of each box\n    vec2 dist = abs(polar_uv - 0.5);\n    \n    //The distance vector uses two channels for x and y.\n    //Take the max value to convert to a single color channel.\n    float brightness = vecmax(dist);\n    //Color the grid.\n    fragColor = brightness * vec4(0.0, 0.5, 1.0, 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKSRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 111, 111, 334], [336, 365, 387, 387, 415], [417, 417, 474, 527, 1186]], "test": "valid"}
{"id": "4tKSzy", "name": "Hypnotoad Eyes", "author": "mlkn", "description": "Possible sizecoding target.", "tags": ["eye", "distance", "morph", "hypnotoad"], "likes": 4, "viewed": 576, "published": "Public API", "date": "1485101050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define eyeSize 0.07\n#define speed1 2.5\n#define speed2 3.3\n#define colorFlickerSpeed 11.\n\nconst vec3 red = vec3(0.4, 0.05, 0.0);\nconst vec3 yellow = vec3(1.0, 0.8, 0.05);\nconst vec3 green = vec3(0.67, 0.6, 0.3);\n\nfloat getHypnoEyeDistance(vec2 p, vec2 center, float size, float t) {\n    vec2 c = p - center;\n\n    float sph = length(c * vec2(1., 0.8)) / (size * (1. + t) * 0.7);\n    \n    float el = length(c * vec2(0.6 + 0.1*t, 1.2 * (1. + t))) / size;\n    float staticEl = length(c * vec2(0.4, 1.15)) / size;\n    \n    c *= vec2(0.3, 0.55);\n    vec2 v = vec2(0., 1.1 * size);\n    float subSph = min(length(c + v), length(c - v)) / size;\n\n    return (1. - el) * (1. - sph) + (1. - t) * (1. - subSph * subSph) - (1. - staticEl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aR = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= aR;\n    \n    float t = abs(mod(iTime * speed1, 2.) - 1.);\n    float t2 = abs(mod(iTime * speed2, 2.) - 1.);\n\n    vec2 eyePos1 = vec2(aR / 4., 0.5);\n    vec2 eyePos2 = vec2(3. * aR / 4., 0.5);\n\n    float d = min(\n        getHypnoEyeDistance(uv, eyePos1, eyeSize, t),\n    \tgetHypnoEyeDistance(uv, eyePos2, eyeSize, t2)\n    );\n    vec3 col = mix(vec3(0), red, d * 3.);\n    col = mix(col, yellow, clamp((d - 0.5) * 1.5, 0., 1.));\n    col = mix(col, green, clamp((d - 0.5) * 0.4 + 0.15 * (sin(t * colorFlickerSpeed) + 1.), 0., 1.));\n\t\n    d = min(length(uv - eyePos1), length(uv - eyePos2));\n\n    col *= smoothstep(-0.02, 0.0, eyeSize*3.45 - d);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 282, 282, 727], [729, 729, 786, 786, 1560]], "test": "valid"}
{"id": "4tKXDR", "name": "Muscular cells", "author": "bleedingtiger2", "description": "Simple muscular-like cells made with Voronoi diagram.", "tags": ["procedural", "voronoi", "cell", "muscle", "muscular"], "likes": 1, "viewed": 549, "published": "Public API", "date": "1483874617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _CelAmount 150\n#define _Speed 0.08\n#define _Seed 0.0\n#define sqrtCellAmout sqrt(float(_CelAmount))\n\n\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898+_Seed, 78.233+_Seed)))* (43758.5453+_Seed));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float dist, minDist = 99999.0;\n    vec2 celPos, cellOffset;\n    for(float i=0.0; i<sqrtCellAmout; i++)\n    {\n        for(float j=0.0; j<sqrtCellAmout; j++)\n    \t{\n            celPos = vec2(i/sqrtCellAmout, j/sqrtCellAmout);\n    \t\t//cellOffset = vec2(rnd(celPos), rnd(vec2(celPos.x*dot(celPos.yx, vec2(284.4769, 7.95247)))));\n    \t\tcellOffset = vec2(rnd(celPos));\n            cellOffset += vec2(tan((iTime+50.0)*_Speed*cellOffset.x), sin((iTime+50.0)*_Speed*cellOffset.y)*2.0);\n            dist = distance(uv, celPos+cellOffset*0.07);\n            \n            if(dist < minDist)\n                minDist = dist;\n        }\n    }\n\tfragColor = vec4(vec3(minDist*3.5)+vec3(0.5, 0.0, 0.04), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 129, 129, 218], [221, 221, 278, 278, 1017]], "test": "valid"}
{"id": "4tKXRD", "name": "Radial Segments", "author": "cacheflowe", "description": "Trying out more radial mod logic for concentric layout. Also playing with color fade.", "tags": ["blackandwhite", "polar", "dazzle"], "likes": 7, "viewed": 690, "published": "Public API", "date": "1483330875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 4.;\t\t\t\t\t\t\t\t\t// adjust time\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    float radsPercent = atan(uv.x, uv.y) / TWO_PI;           \t\t// get angle to center\n    float dist = length(uv) * 5.; // distance(uv, center);   \t\t// multiply radius to achieve smaller rings\n    float ringSegments = 1. + floor(dist * 4.);\t\t\t\t \t\t// number of ring segments depends on radius\n    if(mod(ringSegments, 2.) == 0.) time = -time;            \t\t// reverse time for even-numbered rings\n    time *= ringSegments * 0.2;                              \t\t// increase time/spin moving out from center\n    time = 0.02 * sin(time);\t\t\t\t\t\t\t\t \t\t// remap time into an oscillation\n    float ringRadsOffset = 0.; // 6. * sin(ringSegments);    \t\t// possible unique offset per ring\n    radsPercent = mod(time + radsPercent + ringRadsOffset, 1.); \t// rotate individual rings\n    if(mod(ringSegments, 2.) == 1.) ringSegments++; \t\t\t\t// make sure we have even number of segments\n    float segment = radsPercent * ringSegments;\t\t\t\t\t\t// progress around circle\n    float segmentNumber = floor(segment);\t\t\t\t\t\t\t// iterate over ring segments - get segment number\n    float colFade = pow(fract(segment), 10.);\t\t\t\t\t\t// go from black to white on a curve at the end\n    vec3 col = vec3(colFade);\t\t\t\t\t\t\t\t\t\t// default to black\n    if(mod(segmentNumber, 2.) == 0.) col = vec3(1. - colFade);\t\t// color every other segment white\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 116, 116, 1590]], "test": "valid"}
{"id": "4tKXWw", "name": "Dots On Planes", "author": "cacheflowe", "description": "Dots on warped planes", "tags": ["3d", "grid", "plane", "dots"], "likes": 2, "viewed": 756, "published": "Public API", "date": "1484588077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 0.25;\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    uv *= vec2(0.35, 1.);\n    \n    // z-rotation\n    float zRot = 0.5 * sin(time);\n    uv *= mat2(cos(zRot), sin(zRot), -sin(zRot), cos(zRot));\n    \n    // 3d params\n    // 3d plane technique from: http://glslsandbox.com/e#37557.0 \n    float horizon = 0.5 * cos(time); \n    float fov = 0.25 + 0.015 * sin(time); \n\tfloat scaling = 0.1;\n    \n    // create a 2nd uv with warped perspective\n\tvec3 p = vec3(uv.x, fov, uv.y - horizon);      \n\tvec2 s = vec2(p.x/p.z, p.y/p.z) * scaling;\n    \n    // wobble the perspective-warped uv \n    float oscFreq = 12.;\n    float oscAmp = 0.03;\n    float zScroll = sin(time) * 0.1; // reverses direction between top & bottom\n    s += vec2(zScroll, oscAmp * sin(time + s.x * oscFreq));\n    \n    // y-rotation\n    float yRot = sin(time);\n    s *= mat2(cos(yRot), sin(yRot), -sin(yRot), cos(yRot));\n\t\n\t// normal drawing here\n    // draw dot grid\n    float gridSize = 50. + 2. * sin(time);\n    s = fract(s * gridSize) - 0.5;\n    float col = 1. - smoothstep(0.25 + 0.1 * sin(time), 0.35 + 0.1 * sin(time), length(s));\n    \n  \t// fade into distance\n\tcol *= p.z * p.z * 5.0;\n  \n\tfragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1291]], "test": "valid"}
{"id": "4tKXzm", "name": "Cake Day", "author": "s23b", "description": "It's the first birthday of my Shadertoy account today, so I thought I should make a cake for you guys :D\n\nA year ago I barely knew what a shader was, so thank you all for helping me along the way!", "tags": ["raymarching", "birthday", "cake"], "likes": 17, "viewed": 807, "published": "Public API", "date": "1483966109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED .1\n#define FOV 3.\n#define SLICES 12.\n#define CAKE_POS .15\n\n#define MAX_STEPS 100\n#define SHADOW_STEPS 100\n#define SHADOW_SOFTNESS 50.\n#define EPS .0001\n#define RENDER_DIST 5.\n#define AO_SAMPLES 5.\n#define AO_RANGE 20.\n#define LIGHT_COLOR vec3(1.,.5,.3)\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\n// simple hash function\nfloat hash(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 4; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// repeat space along an axis\nfloat tRepeat1(inout float p, float r) {\n    float id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// divide 2d space into s chunks around the center\nvoid tFan(inout vec2 p, float s) {\n    float k = s / PI / 2.;\n    tRotate(p, -floor((atan(p.y, p.x)) * k + .5) / k);\n}\n\n// rectangle distance\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n// sphere distance\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// cylinder distance r - radius, l - height\nfloat sdCylinder(vec3 p, float r, float l) {\n    p.xy = vec2(abs(p.y) - l, length(p.xz) - r);\n    return min(max(p.x, p.y), 0.) + length(max(p.xy, 0.));\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// intersection\nfloat opI(float a, float b) {\n    return max(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// smooth union\nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// the icing on the cake\nfloat sdIcingOnTheCake(vec3 p) {\n    \n    // twist\n    tRotate(p.xz, p.y * 3.);\n    \n    // add an infinite box\n    float d = sdRect(p.xz, vec2(.4));\n    \n    // add another box, rotated by 45 degrees, smoothly\n    tRotate(p.xz, PI / 4.);\n    d = opSU(d, sdRect(p.xz, vec2(.4)), .1);\n    \n    // add a slope\n    d += p.y + .2;\n    \n    // divide the distance, because by now it has been ruined, then intersect smoothly with a sphere\n    d = -opSU(-d * .5, -sdSphere(p, .5), .1);\n    return d;\n}\n\n// distance estimation of everything together\nfloat map(vec3 p) {\n    vec3 q = p;\n    \n    // rounded cylinder for the cake\n    float r = .02;\n    float d = sdCylinder(p, .5 - r, .2 -r) - r;\n    \n    // blend in the icing\n    tFan(q.xz, SLICES);\n\td = opSU(d, sdIcingOnTheCake((q - vec3(.4, .28, 0)) * 5.) / 5., .04);\n    \n    // cut the cake\n    tRotate(p.xz, PI / SLICES);\n    float slice = p.z;\n    float a = fract((floor(iTime * SPEED * SLICES)) / SLICES - .5) * PI * 2.;\n    tRotate(p.xz, a);\n    slice = (a < PI) ? opU(slice, p.z) : opI(slice, p.z);\n    return opS(d, slice);\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// get the soft shadow value\nfloat softShadow(vec3 ro, vec3 rd, float maxDist) {\n    float total = 0.;\n    float s = 1.;\n    \n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        float d = map(ro + rd * total);\n        if (d < EPS) {\n            s = 0.;\n            break;\n        }\n        if (maxDist < total) break;\n        s = min(s, SHADOW_SOFTNESS * d / total);\n        total += d;\n    }\n    \n    return s;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// ambient occlusion\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// texture function\nvec3 _texture(vec3 p) {\n    vec3 q = p;\n    q.y += .05;\n    tRepeat1(q.y, .095);\n    vec3 t = mix(fbm(fbm(p * 10.) + p * 10.) * vec3(.5) + vec3(.5),\n                fbm(p * 100.) * vec3(.5, .0, .0),1. - \n                saturate((opI(sdCylinder(p, .5, .175),sdCylinder(q, .48, .035)) + (fbm(p * 100.)- .5) * .02 ) * 100.));\n    return saturate(t);\n}\n\n// texture used for bump mapping\nfloat bumpTexture(vec3 p) {\n    vec3 q = p;\n    q.y += .05;\n    tRepeat1(q.y, .095);\n    float t = mix(fbm(fbm(p * 20.) + p * 10.) * .5 + .25,\n                fbm(p * 100.), 1. - \n                saturate((opI(sdCylinder(p, .5, .175),sdCylinder(q, .48, .035)) + (fbm(p * 100.)- .5) * .02 ) * 100.));\n    return saturate(t);\n}\n\n// bump mapping from Shane\nvec3 doBumpMap(vec3 p, vec3 nor, float bumpfactor) {\n    \n    vec2 e = vec2(.0001, 0);\n    float ref = bumpTexture(p);                 \n    vec3 grad = vec3(bumpTexture(p - e.xyy) - ref,\n                     bumpTexture(p - e.yxy) - ref,\n                     bumpTexture(p - e.yyx) - ref) / e.x;\n             \n    grad -= nor * dot(nor, grad);          \n                      \n    return normalize(nor + grad * bumpfactor);\n\t\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // transform mouse coordinates\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= 2.;\n    \n    // set up camera position\n    vec3 ro =  vec3(0, 0, -2);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // light is relative to the camera\n    vec3 light = ro + vec3(-.6, .1, -.1);\n    \n    vec2 rot = vec2(0);\n    if (iMouse.z > 0.) {\n    \t// rotate the scene using the mouse\n        rot = -mouse;\n    } else {\n        // otherwise rotate constantly as time passes\n        rot = vec2(-iTime * SPEED * PI + .3, .5);\n    }\n    \n    tRotate(rd.yz, rot.y);\n    tRotate(rd.xz, rot.x);\n    tRotate(light.yz, rot.y);\n    tRotate(light.xz, rot.x);\n    tRotate(ro.yz, rot.y);\n    tRotate(ro.xz, rot.x);\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    normal = doBumpMap( p, normal, .01);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light);\n    float shadow = softShadow(shadowStart, l, shadowDistance);\n    \n    // ambient light\n    float ambient = .25;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 4.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal) * .5 + .5;\n    \n    // add this all up\n\tfragColor.rgb = (ao * _texture(p)) * (ambient * (2. - LIGHT_COLOR) * .5 + (specular + diffuse) * shadow * LIGHT_COLOR);\n    \n    // fog\n    vec4 fogColor = vec4(vec3(0,.01,.014) * (2. - length(uv)), 1.);\n    fragColor = mix(fragColor, fogColor, saturate(dist * dist * .05));\n    \n    // if we passed the cake, then apply a dark glow, this makes the cake pop out\n    if (length(p) > .6) \n        fragColor *= saturate(1. - sqrt(steps / float(MAX_STEPS)) * 1.5);\n    \n    // gamma correction\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 355, 376, 376, 470], [472, 547, 569, 569, 1192], [1194, 1224, 1244, 1244, 1400], [1402, 1438, 1479, 1479, 1548], [1550, 1580, 1620, 1620, 1714], [1716, 1767, 1801, 1801, 1885], [1887, 1909, 1939, 1939, 2014], [2016, 2035, 2068, 2068, 2093], [2095, 2139, 2183, 2183, 2293], [2295, 2304, 2333, 2333, 2357], [2359, 2375, 2404, 2404, 2428], [2430, 2446, 2475, 2475, 2500], [2502, 2518, 2557, 2557, 2655], [2657, 2682, 2714, 2732, 3176], [3178, 3224, 3243, 3243, 3760], [3762, 3911, 3974, 3974, 4214], [4216, 4245, 4296, 4296, 4630], [4632, 4663, 4687, 4687, 4872], [4874, 4895, 4930, 4930, 5161], [5163, 5183, 5206, 5206, 5532], [5534, 5567, 5594, 5594, 5892], [5894, 5921, 5973, 5973, 6348], [6350, 6350, 6405, 6441, 8676]], "test": "error"}
{"id": "4tKXzV", "name": "Industrial Tunnel", "author": "Shane", "description": "Using cylindrical coordinates to construct a steel-plated tunnel with an industrial feel.", "tags": ["raymarching", "tunnel", "bump", "polar", "cylindrical"], "likes": 58, "viewed": 4126, "published": "Public API", "date": "1485252542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tIndustrial Tunnel\n\t-----------------\n\n\tUsing repeat cylindrical coordinates (polar plus Z) to construct a steel-plated tunnel \n\twith an industrial feel. I think I've mentioned it before, but I never quite appreciate \n\tjust how well Dr2's examples run until I try to construct a scene with a fraction of the \n\tdetail... then watch the FPS counter plummet. :)\n\n\tMy fastest machine pushes this scene out with ease. However, my slowest machine didn't\n\tfare as well. I'd set myself a limit of 40 FPS, but could only manage 30 FPS... for now, \n\tanyway. I could get to 40 FPS, but would really have to mess the code up, so I've left \n\tit alone. Obviously, the key to faster scenes is insuring that the distance function is \n\teasy to hone-in on and involves fewer instructions. Unfortunately, that's not so easy to \n\tachieve when adding more detail. On top of that, my slow machine isn't a fan of the \"atan\"\n\tfunction, which is pretty difficult to avoid when doing angular-based calculations.\n\n\tThe scene itself is very loosely based on a section of the Greenwich pedestrian tunnel. \n\tThe lighting is not very realistic, but works well enough. The scene relies on a heavy \n\tcurvature setting to give it a quasi hand painted look. Anyway, I'd like to put up a \n\tsimpler abstract geometric version at some stage that'll be easier to read, and\n\thopefully, faster.\n\n\n\t// Other examples:\n\n\t// Cylindrical-coordinate-based tunnel. I've seen it pop up in many forms on the net.\n\tTunnel #1 -  WAHa_06x36\n\thttps://www.shadertoy.com/view/4dfGDr\n\n\t// Great example making use of polar coordinates. Really stylish and great atmosphere.\n\tMetro Tunnel - fb39ca4\n\thttps://www.shadertoy.com/view/ldsGRS\n\n\t// Very cool. Amazingly detailed for a shader.\n\tGotthard Tunnel - dr2\n    https://www.shadertoy.com/view/MlSXRR\n\t\n\t\n\n*/\n\n// Maximum ray distance.\n#define FAR 50. \n\n// Comment this out to omit the detailing. Basically, the bump mapping won't be included.\n#define SHOW_DETAILS\n\n// Object ID, used for the gold trimming in the bump mapping section.\nfloat svObjID;\nfloat objID;\n\n#define TUN 0. // Tunnel: Basically, the metal plates.\n#define FLR 1. // Floor:  Concrete curbs and underflooring.\n#define MTL 2. // Metal:  The metallic mesh and the light casings.\n#define LGT 3. // Lights: The lights attached to the top mesh.\n#define BLT 4. // Bolts:  The hexagonal bolts.\n#define PIP 5. // Pipes:  The cyclinders beside the lights.\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Layered noise.\nfloat fBm(vec3 p){ \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15; \n    //return n3D(p)*.5333 + n3D(p*2.)*.2667 + n3D(p*4.)*.1333 + n3D(p*8.)*.0667; \n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    // return vec3(0, 0, t); // Straight path.\n    \n    // Curvy path. Weaving around the columns.\n    float a = sin(t*3.14159265/16. + 1.5707963*1.);\n    float b = cos(t*3.14159265/16.);\n    \n    return vec3(a*2., b*a, t);    \n}\n\n// Minimum - with corresponding object ID.\nvec2 objMin(vec2 a, vec2 b){ \n    \n    // Returning the minimum distance along with the ID of the\n    // object. This is one way to do it. There are others.\n    \n    //Equivalent to: return a.x < b.x ? a: b; \n    float s = step(a.x, b.x);\n    return s*a + (1. - s)*b;\n}\n\n// The tunnel scene. There's a bit of code, but it's nothing more than a bunch of boxes\n// and cylinders spread out around some repeat cylindrical coordinates.\nfloat map(vec3 p){\n    \n    const float depth = .1; // Depth of the rounded metal plates.\n    \n    // Mold the scene around the path.\n    p.xy -= camPath(p.z).xy;\n    \n    // The edge of the tunnel. Set at a radius of one, plus the depth.\n    float tun = (1. + depth) - length(p.xy); \n    \n    //////////////\n    \n    // The concrete floor. Just a plane, with a circular chunk cut out. It gives it\n    // a curb-like appearance.\n    float flr = p.y + .695;\n    flr = max(flr, tun - depth - .1);\n    \n    ///////////////\n    \n    // The tunnel walls. Due to the amount of detailing and the polar conversion, it \n    // looks more complicated than it actually is. To repeat across the XY plane we\n    // do something along the lines of \"p.xz = mod(p.xz, c) - c/2.\" To repeat around\n    // a circle in the XY plane, we convert to polar coordinates, \"p.xy = rot(angle),\"\n    // (angle is based on \"atan(p.y, p.x),\" then do the same thing. The rest is basic\n    // unit circle trigonometry, etc. By the way, this is a rough description, so if\n    // something doesn't quite make sense, it probably doesn't. :)\n    \n    // Converting the XY plane to polar coordinates. I'm handling the panels (six per\n    // circle) and the bolts (18 per circle) at the same time to share some calculations.\n    // I'd love to use the geometry of one to constuct the other - in order to save\n    // some instructions, but I'm leaving it alone for now.\n    vec3 q = p; \n    vec3 q2 = p;    \n    \n    float a = atan(q.y, q.x)/6.2831853; // Polar angle of \"p.xy\" coordinate.\n    float ia = (floor(a*6.) + .5)/6.*6.2831853; // Angle between \"PI/6\" intervals.\n    float ia2 = (floor(a*18.) + .5)/18.*6.2831853; // Angle between \"PI/18\" intervals.\n    \n     // Polar conversion for 6 segments, but offset every second panel... and shifted\n    // to the center-cell position (see the Z-repetition).\n    q.xy *= rot(ia + sign(mod(q.z + .25, 1.) - .5)*3.14159/18.);\n    q2.xy *= rot(ia2); // Polar conversion for 18 segments (for the bolts).\n   \n    // The X-coordinate is now the radial coordinate, which radiates from the center\n    // to infinity. We want to break it into cells that are 2 units wide, but centered\n    // in the middle. The result is that the panels will start at radius one.\n    q.x = mod(q.x, 2.) - 1.;\n    // Plain old linear Z repetion. We want the panels and bolts to be repeated in the\n    // Z-direction (down the tunnel) every half unit.\n    q.z = mod(q.z, .5) - .25; \n    \n    // Moving the bolts out to a distance of 2.1.\n    q2.x = mod(q2.x, (2. + depth)) - (2. + depth)/2.;\n    \n    // Now, it's just a case of drawing an positioning some basic shapes. Boxes and\n    // tubes with a hexagonal cross-section.\n    q = abs(q);\n    q2 = abs(q2);\n\n    // Bolts. Hexagon shapes spaced out eighteen times around the tunnel walls. The \n    // panels are spaced out in sixths, so that means three per panel.\n    float blt = max(max(q2.x*.866025 + q2.y*.5, q2.y) - .02, q.z - .08);\n\n    \n    // Putting in some extra rails where the mesh and curb meets the tunnel. The extra\n    // code is fiddly (not to mention, slows things down), but it makes the structure\n    // look a little neater.\n    q2 = p;\n    q2.xy *= rot(ia - sign(p.x)*3.14159/18.);\n    q2 = abs(q2);\n    \n    // Lines and gaps on the tunnel to give the illusion of metal plating.\n    float tunDetail = max(min(min(q.y - .06, q.z - .06), max(q2.y - .06, p.y)), \n                          -min(min(q.y - .01, q.z - .01), max(q2.y - .01, p.y))); \n \n    // Adding the tunnel details (with a circular center taken out) to the tunnel.\n    tun = min(tun, max(tunDetail, tun-depth));  \n    \n    ///////////////\n    \n    // The metalic mesh elements and light casings. The lights are calculated in this\n    // block too.\n        // The metalic mesh elements and light casings. The lights are calculated in this\n    // block too.\n       \n    q = abs(p);    \n    float mtl = max(q.x - .14, abs(p.y - .88) - .02);  // Top mesh.\n    mtl = min(mtl, max(q.x - .396, abs(p.y + .82) - .02)); // Bottom mesh.//.81\n    \n    q.z = abs(mod(p.z, 2.) - 1.);\n    \n    float lgt = max(max(q.x - .07, q.z - .07), abs(p.y - 1.) - .255);\n    float casings = max(max(q.x - .1, q.z - .1), abs(p.y - 1.) - .23);\n    \n    q.xz = abs(mod(q.xz, 1./8.) - .5/8.);\n    \n    mtl = max(mtl, -max(max(q.x - .045, q.z - .045), abs(abs(p.x) - .19) - .14)); // Holes in the mesh.\n    mtl = min(mtl, casings ); // Add the light casings to the top mesh.\n    \n    /*\n    // Alternative mesh setup with smaller holes. I like it more, but Moire patterns are a problem\n    // with smaller window sizes.\n    q = abs(p);    \n    float mtl = max(q.x - .13, abs(p.y - .88) - .02);  // Top mesh.\n    mtl = min(mtl, max(q.x - .396, abs(p.y + .82) - .02)); // Bottom mesh.//.81\n    \n    q.z = abs(mod(p.z, 2.) - 1.);\n    \n    float lgt = max(max(q.x - .07, q.z - .07), abs(p.y - 1.) - .255);\n    float casings = max(max(q.x - .1, q.z - .1), abs(p.y - 1.) - .23);\n    \n    q.xz = abs(mod(q.xz, 1./16.) - .5/16.);\n    \n    mtl = max(mtl, -max(max(q.x - .025, q.z - .025), abs(abs(p.x) - .19) - .155)); // Holes in the mesh.\n    mtl = min(mtl, casings ); // Add the light casings to the top mesh.\n    */    \n    ///////////////\n    \n    // Pipes. Electricity... water? Not sure what their function is, but I figured I \n    // should slow the distance function down even more, so put some in. :)\n    q = p;\n    const float th = 6.283/18.;\n    float sx = sign(p.x);\n    float pip = length(q.xy - vec2(sx*sin(th*1.4), cos(th*1.4))*1.05) - .015;\n    pip = min(pip, length(q.xy - vec2(sx*sin(th*1.6), cos(th*1.6))*1.05) - .015);\n    \n    ///////////////\n    \n    // Determine the overall closest object and its corresponding object ID. There's a way\n    // to save some cycles and take the object-ID calculations out of the distance function, \n    // but I'm leaving them here for simplicity.\n    vec2 d = objMin(vec2(tun, TUN), vec2(blt, BLT));\n    d = objMin(d, vec2(mtl, MTL));\n    d = objMin(d, vec2(lgt, LGT));\n    d = objMin(d, vec2(flr, FLR));\n\td = objMin(d, vec2(pip, PIP));\n    \n    ///////////////\n    \n    \n    objID = d.y; // Set the global object ID.\n    \n    return d.x; // Return the closest distance.\n    \n    \n}\n\n\n// Raymarching.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    }\n    return min(t, FAR);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.yz).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n\n    p.xy -= camPath(p.z).xy;\n\n    // Adding a bit of functional noise variations to the\n    // concrete floor and the tunnel. Not a great deal of \n    // effort went into it.\n    float res = 0.;\n    if(svObjID==FLR) {\n        p.xy *= 16.;\n        res = n3D(p*4.)*.66 + n3D(p*8.)*.34;\n        res = 1.-abs(res - .75)/.75;\n    }\n    else if(svObjID==TUN){\n        //res = fBm(p*16.);\n        res = n3D(p*16.)*.66 + n3D(p*32.)*.34;\n    }\n    \n    \n    // Subtle metal bump. More thought needs to be put into it. :)\n    if(svObjID==MTL){\n        \n        p.xz = abs(mod(p.xz + 1./8.,  1./8.) - .5/8.);\n        res = max(p.x, p.z) - .25/8.;\n        \n        res = max(res*8., 0.);\n        \n        //res = 1. - smoothstep(0., .5, res);    \n        \n    }\n    \n     \n    \n    return res; // Range: [0, 1].\n   \n}\n\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpFunction(p);                 \n    vec3 grad = (vec3(bumpFunction(p - e.xyy),\n                      bumpFunction(p - e.yxy),\n                      bumpFunction(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n// The normal function with some curvature rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 nr(vec3 p, inout float crv, float ef){ \n\t//ef/iResolution.y\n    vec2 e = vec2(ef/450., 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p);\t// The hit point itself - Doubled to cut down on calculations. See below.\n    \n    // Seven-tap curvature calculation. You can get away with four taps, but this is a little\n    // more accurate.\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*6.)*32. + .5, 0., 1.);\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.002, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 2.;\n    vec3 ro = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    \n    vec3 lk = camPath(iTime*speed + .5);  // \"Look At\" position.\n    //ro.y -= .1; // Hack to lower the camera.\n    //lk.y -= .1;\n    \n    vec3 lp = camPath(iTime*speed + 2.25); // Light position, somewhere near the moving camera.\n    lp.y += .6;\n    // Alternative. Moving the light to the right a bit. \n    //float th = 6.283*1./12.;\n    //lp += vec3(sin(th)*.6, cos(th)*.6, 0); \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    // Mild lens distortion to fit more of the scene in, and to mix things up a little.\n    vec3 rd = fwd + FOV*(u.x*rgt + u.y*up);\n    rd = normalize(vec3(rd.xy, (rd.z - length(rd.xy)*.3)*.7));\n    \n    // Swiveling the camera from left to right when turning corners.\n    float swivel = camPath(lk.z).x;\n    rd.xy = rot(swivel/48. )*rd.xy;\n    rd.xz = rot(swivel/16. )*rd.xz;\n \n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    svObjID = objID;\n    \n    // Surface hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Offset path. Only used for one thing here, but it's handy to have an\n    // adjusted hit point that aligns with the path contour.\n    vec3 pathSp = sp - camPath(sp.z);\n    \n    \n    // Normal with curvature component.\n    float crv = 1., ef = 12.; // ef - Edge and curvature factor.\n    vec3 sn = nr(sp, crv, ef);\n    \n    // Shadows and ambient self shadowing.\n    float sh = softShadow(sp, lp, 16.); // Soft shadows.\n    float ao = cao(sp, sn); // Ambient occlusion.\n    \n    // Light direction vector setup and light to surface distance.\n    lp -= sp;\n    float lDist = max(length(lp), .0001);\n    lp /= lDist;\n    \n    // Attenuation.\n    float atten = 1./(1.0 + lDist*.25 + lDist*lDist*.025);\n    \n    // Texturing the object.\n    const float tSize0 = 1./2.;\n    vec3 tx = tex3D(iChannel0, sp*tSize0, sn);\n    tx = smoothstep(0., .5, tx);\n\n    // Ugly \"if\" statements for object coloring. They do the job though. \n\tif(svObjID==BLT || svObjID==PIP) tx *= vec3(1.25, 1, .75);\n    else if(svObjID==TUN) tx *= vec3(1., .4, .2);    \n    else if(svObjID==MTL) tx *= vec3(1.1, .8, .7);\n    else if(svObjID==FLR) tx *= vec3(1.5, .78, .62);\n    else if(svObjID==LGT) tx *= vec3(5, 4, 3); // Really bright for fake glow.\n        \n        \n    // More fake lighting. This was just a bit of trial-and-error to produce some repetitive,\n    // slightly overhead, spotlights throughout the space. Cylinder in XY, sine repeat\n    // in the Z direction over three rows... Something like that. I tried to code in some\n    // flickering, but in the end, decided working lights were better. :)\n    \n    float spot = max(2. - length(pathSp.xy - vec2(0, 1.)), 0.)*(cos((sp.z + 1.)*3.14159)*.5+.5);\n    spot = smoothstep(0.5, 1., spot); \n    //float flicker = smoothstep(-1., -.9, sin(iTime*1. + hash(floor(sp.z/2.))*6.283));\n    //float flicker = sin(iTime*8. + hash(floor(sp.z/2.))*6.283)*.2 + 1.;\n    //spot *= flicker;\n    //tx += (tx)*spot*2.;\n\n\n   \n    // Function bump.\n    #ifdef SHOW_DETAILS\n    float bf =.005;\n    if(svObjID==FLR || svObjID==MTL) bf = .02;\n    sn = doBumpMap(sp, sn, bf/(1. + t/FAR));\n    // tx *= bumpFunction(sp)*.75 + .25; // Accentuates the bump, but not needed here.\n    #endif\n    \n    // Texture-based bump mapping.\n    float tbf = .03;\n    if(svObjID==LGT) tbf = .0;\n    sn = texBump(iChannel0, sp*tSize0*2., sn, tbf);\n \n    // Adding a bit of mold build-up to the scene. Very hacky, and in need of a tweak, but it works well enough.\n    float slm = fBm(sp*4.);\n    float slf = 1.;  // Slime factor.\n    if(svObjID!=TUN && svObjID!=FLR) slf = .75;\n    tx = mix(vec3(1), vec3(.25, .6, .2), (slm*.75 + .25)*slf)*tx; //\n    tx = mix(vec3(1), vec3(.25, .4, .15)*.1, (1.-abs(slm - .5)*2.)*.75*slf)*tx;\n \n    \n    // Diffuse, specular and Fresnel.\n    float dif = max(dot(lp, sn), 0.);\n    float spe = pow(max(dot(reflect(-lp, sn), -rd), 0.), 32.);\n    float fre = pow(clamp(dot(rd, sn) + 1., 0., 1.), 2.);\n\n    \n     \n    // Combining the terms above to produce the final color.\n    vec3 fc = tx*(dif + .125 + vec3(1, .8, .5)*fre*8. + vec3(1, .9, .7)*spot*4.) + vec3(1, .7, .5)*spe*1.;\n    fc *= atten*sh*ao*clamp(crv*1.5, 0., 1.);\n    \n \n    //fc = mix(vec3(1), vec3(.25, 1, .15)*.2, slm*.75)*fc; // More mold.\n \n    \n    // Mixing in some fog.\n    vec3 bg = vec3(.4, .35, .3);\n    fc = mix(fc, bg, smoothstep(0., .95, t/FAR));\n    \n    \n    // Post processing.\n    //float gr = dot(fc, vec3(.299, .587, .114));\n    //fc = fc*.5 + pow(min(vec3(1.5, 1, 1)*gr, 1.), vec3(1, 3, 16))*.5;\n    \n     // Approximate gamma correction.\n\tfragColor = vec4(sqrt(clamp(fc, 0., 1.)), 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2414, 2479, 2500, 2500, 2568], [2571, 2639, 2657, 2657, 3003], [3005, 3023, 3041, 3041, 3182], [3184, 3256, 3278, 3380, 3511], [3513, 3556, 3584, 3764, 3825], [3827, 3987, 4005, 4005, 10208], [10211, 10227, 10257, 10257, 10440], [10442, 10596, 10642, 10642, 11166], [11170, 11200, 11230, 11230, 12037], [12040, 12090, 12147, 12147, 12537], [12540, 12727, 12787, 12787, 13294], [13297, 13486, 13529, 13550, 14557], [14560, 14712, 14744, 14744, 14990], [14993, 15184, 15228, 15345, 16461], [16464, 16464, 16518, 16546, 21551]], "test": "error"}
{"id": "4tVSRy", "name": "360 stars with subtle scanlines", "author": "zproxy", "description": "360 stars with subtle scanlines", "tags": ["stars", "360"], "likes": 5, "viewed": 184, "published": "Public", "date": "1484815657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.1)));\n\n    vec3 col = col0;\n\n    for (int i = -90; i < 0; i++)\n    //for (int i = 0; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.1 + (float(i) * (1./600.) ))));\n        \n        // startrails, to make them visible for debugger\n        col1 *= (float(i) + 90. )/ 300.;\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\n\n\nfloat xstars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    vec3 q = fract(p*2.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 xstartrails(in vec3 rd)\n{\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = xstars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = xstars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\n    mo.x *= 4.2;\n    mo -= vec2(1.2,-0.1);\n\tmo.x *= iResolution.x/iResolution.y;\n    //mo.x += sin(time*0.15)*0.2;\n\t\n    vec3 ro = vec3(650., sin(0.0*0.2)*0.25+10.,0.0);\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 up = normalize(cross(right, eye));\n\t\n    vec3 rd = normalize((p.x*right + p.y*up)*1.00 + eye);\n    //rd.y += abs(p.x*p.x*0.015);\n    \n    \n    //left to right\n    //rd = roty(rd, time);\n    \n   \n    \n    vec3 col = startrails( rd);\n\n    \n    vec3 scanlines = xstartrails( rd);\n    \n    // cool. a subtle line\n  col += scanlines * 0.1;\n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 117], [122, 182, 203, 203, 346], [348, 403, 426, 439, 921], [1363, 1363, 1388, 1425, 1515], [2029, 2029, 2086, 2086, 3104]], "test": "valid"}
{"id": "4tVSzy", "name": "UFO IN THE FOG", "author": "XRNZ", "description": ":D", "tags": ["ufofog"], "likes": 0, "viewed": 83, "published": "Public", "date": "1484870530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Blobs\n// Eric Galin\n// Modif Emmanuel Schmuck : \"UFO in the fog\"\n// densitÃ© du fog ajustable dans la fonction mainImage\n// objet : specular + diffuse funky obtenue dans shadestep\n// \n// \"aura\" dans la fonction Aura\n// fog en plusieurs couches dans la fonction mainImage\n\nconst float pi = 3.1415;\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=12.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\nconst vec3 blue = vec3(0.2,0.2,0.7);\nconst vec3 red = vec3(0.7,0.2,0.2);\nconst vec3 black = vec3(0.0,0.0,0.0);\nconst vec3 white = vec3 (1.0,1.0,1.0);\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n\n\n// Diffuse de Phong\nfloat PhongDiff(vec3 n, vec3 l)\n{   \n    float ph = dot(n,l);\n    \n    if(ph<0.0){ph=0.0;}\n    \n    return ph;\n}\n\n//Specular de Phong\nfloat PhongSpec(vec3 n, vec3 l, vec3 rd, float a)\n{   \n    //reflection\n    vec3 r = normalize( 2.0*(dot(n,l))*n-l);\n    \n    float diff = 1.0*pow(dot(r,rd),a);\n    \n    return diff;\n}\n\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  \n   float t=8.0*float(n)/(float(Steps-1));\n    \n     vec3 cc = (0.5+0.5*cos(50.0*t))*vec3(1.0,1.0,1.0);\n   return cc;\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(float i, float t, vec3 p, vec3 n, vec3 rd, int s)\n{\n    \n const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n    \n    float alpha = 30.0;\n\n\t//animation de l'intensitÃ© et couleur en fonction du temps\n    \n    float f = 0.5+0.5* cos(3.0*t);\n    \n    //couleur\n    vec3 c = ShadeSteps(s);\n        \n    c = mix(c,vec3(f,0.0,1.0-f),0.5);\n    \n    vec3 l = normalize(lightPos - p);\n\n    float diff = PhongDiff(n,l);\n    \n    if(diff!=0.0){diff+=PhongSpec(n,l,rd,alpha);}\n    \n    c = c*(i+1.5*i*diff);\n\n\n  return c;\n}\n\n\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat turbulence(in vec3 p)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n\n//\"aura\" autour de l'objet, basÃ©e sur les steps de calcul\nvec3 Aura(vec3 cc, int s, float _smin, float _smax, float t){\n\t\n    vec3 c;\n\n    float mx;\n    \n    float offset = 30.0*cos(3.0*t) ;\n    \n    float smin = _smin+ offset;\n    float smax = _smax + offset;\n\n    mx=pow((1.0-abs(0.5*(smax+smin)-float(s))/(0.5*(smax-smin))),3.0);\n    \n    //couleur en fonction du step -> \"courbes de niveau\" colorÃ©es\n    c = 1.55*mx*vec3(1.0*mx*abs(cos(0.75*float(s)))\n                       ,0.0\n                        ,(1.0-mx)*abs(sin(0.51*float(s))));\n    \n    c = mix(cc,c,mx);\n    \n    return c;\n}\n\n//logistic curve\nfloat sigmoid(float x, float slope){\n    \n    return 1.0 / (1.0+exp(-slope*x));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //param de densitÃ© du fog\n  \n    float dens = 10.0;\n    \n    //couleur du fog\n    \n    vec3 fog = black;\n    \n    float moveSpeed = 8.0;\n    \n    \n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  //aller-retours vers l'objet\n  float a=iTime*0.5;\n  ro = rotateY(ro*(1.2+0.4*cos(0.1*moveSpeed*a)), a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n    \n  //diffuse intensity\n  float intensity = 1.7;\n\n  float t = SphereTrace(ro, rd, hit,s);\n    \n  vec3 pos=ro+t*rd;\n    \n  // Shade background\n \n  vec3 rgb = 0.75*white + 0.35*blue + 0.15*red;\n    \n\n    \n    //depth\n    float d = (t-rA)/(rB-rA);\n    \n\n    //courbe de densitÃ© du fog (logistic curve) normÃ©e\n    float b = sigmoid(d,dens);\n    \n\n    if (hit)\n  {\n                \n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\t\t\n\n      //objet blendÃ© avec le background selon la densitÃ©\n       rgb = mix(Shade(intensity,a,pos, n, rd, s),rgb,b);\n\n          \n  }\n   \n    //param de temps\n    float dt1 = 0.10*iTime;\n    float dt2 = 0.06*iTime;\n    \n    //offsets de position pour les turbulences\n    \n    float offsetX1 = pixel.x +4.0*cos(dt1)+2.4*sin(0.3*dt1);\n    float offsetY1 = pixel.y +4.0*sin (dt1)+2.4*cos(0.3*dt1);\n    float offsetZ1 = 1.0*b;\n    \n    float offsetX2 = pixel.x +3.0*cos(dt2)+3.0*sin(0.3*dt2);\n    float offsetY2 = pixel.y +3.0*sin (dt2)+3.0*cos(0.3*dt2);\n    float offsetZ2 = 1.0*b;\n\n    //turbulences multiples pour le fog\n    float turb1 = turbulence(5.0*vec3(offsetX1,offsetY1,offsetZ1));\n    float turb2 = turbulence(12.0*vec3(offsetX1,offsetY1,offsetZ1));\n    float turb3 = turbulence(5.0*vec3(offsetX2,offsetY2,offsetZ2));\n    float turb4 = turbulence(12.0*vec3(offsetX2,offsetY2,offsetZ2));\n\n   \n     float f =  0.9*b+0.10*(0.7*turb1+0.3*turb2);\n        \n     f = 0.5+abs(f*f-0.5);\n    \n     //si on est sur l'objet, on attenue le fog en fonction de la densitÃ©\n    if(hit){f = f * b * b;}\n    \n    //1Ã¨re couche de fog\n    rgb = mix(rgb,fog,f);\n    \n    f =  0.5*(0.7*turb3+0.3*turb4);\n    \n    f = f*f;\n    \n    //si on est sur l'objet, on attenue le fog en fonction de la densitÃ©\n    if(hit){f = f * b * b;}\n    \n    //deuxiÃ¨me couche de fog;\n    rgb = mix(rgb,fog,f);\n        \n\n    \n    if(!hit){\n        \n        \n        float auraStep = 200.0;\n        float auraWidth = 150.0;\n        float mx = sigmoid(0.5+0.5*cos(0.1*moveSpeed*a),0.33*dens);\n        \n        //\"aura\" animÃ©e autour de l'objet\n       rgb = mix(Aura(rgb,s,auraStep,auraStep+auraWidth,a),rgb,mx);\n    \n    }\n    \n\n  fragColor=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 676, 707, 707, 806], [808, 875, 910, 910, 983], [1009, 1123, 1169, 1169, 1206], [1208, 1299, 1329, 1329, 1347], [1349, 1437, 1467, 1467, 1490], [1492, 1538, 1560, 1560, 1756], [1758, 1798, 1829, 1829, 2049], [2051, 2156, 2207, 2207, 2642], [2644, 2749, 2806, 2806, 3257], [3260, 3280, 3306, 3306, 3378], [3382, 3402, 3435, 3435, 3514], [3516, 3536, 3587, 3607, 3720], [3903, 3964, 4026, 4026, 4526], [4529, 4529, 4553, 4553, 4596], [4598, 4598, 4624, 4624, 4993], [4995, 4995, 5024, 5049, 5212], [5215, 5274, 5335, 5335, 5808], [5810, 5827, 5863, 5863, 5909], [5912, 5912, 5969, 6005, 8713]], "test": "valid"}
{"id": "4tVXRV", "name": "Enhanced Sphere Tracing", "author": "patu", "description": "[url=http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf]Trace source[/url]", "tags": ["raymarching", "sky", "enchanced"], "likes": 64, "viewed": 5517, "published": "Public API", "date": "1485053089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\n\t\n\thttp://bit.ly/shadertoy-plugin\n \n\n\n*/\n\n\n// getNormalHex or getNormalCube\n#define getNormal getNormalCube\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n\n#define FOV 80.0\n#define FOG 1.\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\nvec3 \n    light = vec3(0.0), \n    p,\n    lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> \nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec3 map(vec3 o) {\n  \n    p = o;\n\n    p.y += 30. ;\n    \n    vec3 floor = vec3(\n        fBox2Cheap(p.xy, vec2(1000., 1.)),\n        2.,\n        0.\n    );\n    \n    p.y -= 30.;\n    \n    vec3 sphereS = vec3(\n        fSphere(p, 20.),\n        2.,\n        0.\n    );\n\n    vec3 \n        obj = vec3(FAR, -1.0, 0.0),\n        obj2 = obj;\n\n    pModPolar(p.zy, 5.);\n    pModPolar(p.zx, 4.);\n\n    pMirrorOctant(p.zy, vec2(min(t, 22.), min(t, 16.) ));\n    pMirrorOctant(p.xz, vec2(min(t, 16.), min(t, 16.) ));\n    \n    pR(p.zy, 1.2 );\n    \n    float pmp = pModPolar(p.xz, 5.);\n    \n\tpMirrorOctant(p.zy, vec2(4.5, 5.));\n    pMirrorOctant(p.xy, vec2(6., 4.));\n    \n    p.zy += 2.;\n    \n    pModPolar(p.xy, 5.);\n\n    obj = vec3(\n        fBox2Cheap(p.xy, vec2(2.4, .5) + vec2(sin(t) * 2., .5 + cos(t * 2.2) / 4.)),\n        2.0,\n        0.\n    );\n    \n    p.z -= 2.;\n    \n    obj2 = vec3(\n        fSphere(p, 2.),\n        1.,\n        0.\n    );\n    \n    obj = opU2(obj, obj2);\n    obj = opU2(obj, floor);\n    obj = opS2(obj, sphereS);\n    \n    return obj;\n}\n\n\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 90;\n\nvec3 trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 0.001;\n    float functionSign = map(o).x < 0. ? -1. : 1.;\n    vec3 mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.x;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) return vec3(INFINITY, 0., 0.);\n    \n    return vec3(candidate_t, mp.yz);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 20;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = .9;\n    float dist = 0.25;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        shade = min(shade, k*h/dist);\n       \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.7), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   \treturn normalize(vec3( \n   \t\tmap( pos + delta.xyy ).x - map( pos - delta.xyy ).x,\n   \t\tmap( pos + delta.yxy ).x - map( pos - delta.yxy ).x,\n   \t\tmap( pos + delta.yyx ).x - map( pos - delta.yyx ).x\n   ));\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n\n    float sdist = map(hitp + normal * dist).x;\n    return clamp(sdist / dist, 0.1, 1.0);\n}\n\nvec3 clouds(vec3 rd) {\n    float ctime = t / 14.;\n    vec2 uv = rd.xz / (rd.y + 0.6);\n\n    vec3 clouds = vec3(\n        fbm(\n            vec3(\n                uv.yx * 1.4 + vec2(ctime, 0.), ctime\n            ) \n        ) * 1.5\n    );\n    \n \n    clouds = pow(clouds, vec3(4.));\n\n    return clamp(clouds * rd.y, 0., 1.);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n    float sunSize = 3.;\n    float sunAmount = max(dot(rd, lightDir), .5);\n    float v = pow(1. - max(rd.y, .5), 4.);\n    vec3 sky = fromRGB(200,200,200) * v;\n    \n    sky += lightColour * sunAmount * sunAmount \n        + lightColour * min(pow(sunAmount, 12.0) * sunSize, sunSize);\n\n    return clamp(sky, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec3 obj) {\n    vec3 col = vec3(1.0);\n    \n    if (obj.y == 2.0) \n        col = vec3(1., .5, 0.) + clamp(mod(-t + p.z, 1.) - .5, 0.0, 0.75 ) * mod(t * 4., 1.);\n              \n    return col;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec3 obj) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1.0 / (1.0 + lDist * 0.025 + lDist * lDist * 0.02);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), .1);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.2), 2.0);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * 1.) * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n    \n    float t2 = t;\n    float \n        sk = sin(-t2 * .1) * 82.0, \n        ck = cos(-t2 * .1) * 82.0,\n    \tsh,\n        ao,\n        fog;\n    \n    light = vec3(20., 4., -10.);        \n    \n    vec3 \n        vuv = vec3(0., 1., -0.), // up\n    \tro = vec3(ck, -20., sk) + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 1.), // pos\n    \tvrp =  vec3(0., 0., 0.),\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n    \tsceneColor = rd,\n    \ttr = trace(ro, rd),\n        p2,\n        sn,\n        sky;\n    \n    ro += rd * tr.x;\n    \n    p2 = p;\n    \n    sn = getNormal(ro);\t\n    \n\n    fog = smoothstep(FAR * FOG, 0., tr.x) * 1.,\n    sh = softShadow(ro, light, 12.),\n    ao = getAO(ro, sn, 1.2);\n\t\n    ao *= 1. + saturate(getAO(ro + sn * .2, sn, 0.5));\n    ao *= saturate(getAO(ro + sn * 1.03, sn, 14.05));\n    \n    ro = p2; \n    \n    sky = Sky(rd, true, normalize(light));\n    \n    if (tr.x < FAR) { \n        sceneColor = saturate(doColor(ro, rd, sn, light, tr));\n        sceneColor *= ao;\n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.x * 4.2 / FAR));\n    } else {\n        sceneColor = sky + clouds(rd);\n    }\n\n    fragColor = vec4(clamp(sceneColor, 0., 1.), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 312, 312, 369], [371, 371, 393, 393, 473], [475, 487, 513, 513, 1134], [1136, 1136, 1155, 1155, 1327], [1418, 1418, 1441, 1441, 1470], [1471, 1471, 1494, 1494, 1523], [1524, 1524, 1549, 1549, 1578], [1580, 1580, 1610, 1610, 1639], [1641, 1701, 1774, 1774, 2060], [2062, 2062, 2094, 2094, 2136], [2138, 2138, 2172, 2172, 2217], [2219, 2219, 2250, 2250, 2299], [2301, 2301, 2332, 2332, 2384], [2386, 2386, 2417, 2417, 2464], [2466, 2506, 2526, 2526, 2551], [2553, 2553, 2573, 2573, 2608], [2610, 2610, 2630, 2630, 2675], [2677, 2716, 2736, 2736, 2761], [2763, 2763, 2781, 2781, 2831], [2834, 2978, 3018, 3018, 3139], [3141, 3169, 3206, 3206, 3297], [3299, 3412, 3462, 3462, 3852], [3854, 3946, 3989, 3989, 4039], [4041, 4041, 4087, 4087, 4195], [4197, 4233, 4261, 4261, 4342], [4344, 4401, 4435, 4435, 4461], [4463, 4463, 4495, 4495, 4520], [4522, 4522, 4540, 4540, 5555], [5700, 5700, 5728, 5728, 6849], [6852, 6852, 6897, 6897, 7413], [7436, 7436, 7465, 7465, 7697], [7732, 7732, 7765, 7765, 7979], [7982, 7982, 8031, 8031, 8123], [8125, 8125, 8147, 8147, 8444], [8446, 8446, 8497, 8497, 8818], [8820, 8820, 8867, 8867, 9048], [9050, 9050, 9123, 9123, 10049], [10051, 10051, 10106, 10106, 11567]], "test": "error"}
{"id": "4tVXWy", "name": "sh visualizer experiment", "author": "VirtuosoChris", "description": "experiment using spherical harmonics functions to make a \"blobby\" music visualizer.", "tags": ["visualizer", "sh"], "likes": 1, "viewed": 159, "published": "Public", "date": "1485748207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat frequency(float index)\n{\nreturn texture(iChannel0, vec2(index, 0)).x;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n\n\n// unrolled version of the above\nfloat SH_0_0( in vec3 s ) { vec3 n = s.zxy; return  k01; }\nfloat SH_1_0( in vec3 s ) { vec3 n = s.zxy; return -k02*n.y; }\nfloat SH_1_1( in vec3 s ) { vec3 n = s.zxy; return  k02*n.z; }\nfloat SH_1_2( in vec3 s ) { vec3 n = s.zxy; return -k02*n.x; }\nfloat SH_2_0( in vec3 s ) { vec3 n = s.zxy; return  k03*n.x*n.y; }\nfloat SH_2_1( in vec3 s ) { vec3 n = s.zxy; return -k03*n.y*n.z; }\nfloat SH_2_2( in vec3 s ) { vec3 n = s.zxy; return  k04*(3.0*n.z*n.z-1.0); }\nfloat SH_2_3( in vec3 s ) { vec3 n = s.zxy; return -k03*n.x*n.z; }\nfloat SH_2_4( in vec3 s ) { vec3 n = s.zxy; return  k05*(n.x*n.x-n.y*n.y); }\nfloat SH_3_0( in vec3 s ) { vec3 n = s.zxy; return -k06*n.y*(3.0*n.x*n.x-n.y*n.y); }\nfloat SH_3_1( in vec3 s ) { vec3 n = s.zxy; return  k07*n.z*n.y*n.x; }\nfloat SH_3_2( in vec3 s ) { vec3 n = s.zxy; return -k08*n.y*(5.0*n.z*n.z-1.0); }\nfloat SH_3_3( in vec3 s ) { vec3 n = s.zxy; return  k09*n.z*(5.0*n.z*n.z-3.0); }\nfloat SH_3_4( in vec3 s ) { vec3 n = s.zxy; return -k08*n.x*(5.0*n.z*n.z-1.0); }\nfloat SH_3_5( in vec3 s ) { vec3 n = s.zxy; return  k10*n.z*(n.x*n.x-n.y*n.y); }\nfloat SH_3_6( in vec3 s ) { vec3 n = s.zxy; return -k06*n.x*(n.x*n.x-3.0*n.y*n.y); }\n\n\nvec3 rot2(vec3 p, float th)\n{\n    vec3 p2;\n    p2.z = p.z * cos(th) - p.x * sin(th);\n    p2.x = p.z * sin(th)  +p.x * cos(th); \n    p2.y = p.y;\n    return p2;\n}\n\nfloat sdSphere2( vec3 p, float s )\n{ \n   // p.y *=1.75;\n    \n    vec3 pnorm = rot2(normalize(p), iTime);\n    \n    vec3 pnorm2 = pnorm;//rot2(normalize(p), 3.14159-iTime);\n    \n    vec3 pnorm3 = pnorm;//normalize(p * vec3(1.50, 1., 1.50));\n    \n    float invCoord = 1.0 / iChannelResolution[0].x;\n    \n    float bass0 = (texture( iChannel0, vec2(0, 0)).x);\n    float bass1 = texture(iChannel0, vec2(1.*invCoord, 0)).x;\n    float bass2 = texture(iChannel0, vec2(2.*invCoord, 0)).x;\n   \n    \n    bass0 = smoothstep(0.1, 1.0, bass0);\n    bass1 = smoothstep(.3, 1.0, bass1);\n    bass2 = smoothstep(.6, 1.0, bass2);\n    \n    s += 1.5*\n        ( \n          bass0*abs(SH_2_2(pnorm3)) \n         + bass1*abs(SH_1_1(pnorm3))\n    \t+ bass2*abs (SH_3_3(pnorm3))\n         );\n    \n    s +=  .750 *\n        (smoothstep(03., 0.8,frequency(1./12.))*abs(SH_3_0(pnorm))+\n        smoothstep(0.3, 0.8,frequency(2./12.))*abs(SH_3_1(pnorm))+\n        smoothstep(0.3, 0.8,frequency(3./12.))*abs(SH_3_2(pnorm))+\n        smoothstep(0.3, 0.8,frequency(4./12.))*abs(SH_3_4(pnorm))+\n        smoothstep(0.3, 0.8,frequency(5./12.))*abs(SH_3_5(pnorm))+\n        smoothstep(0.3, 0.8,frequency(6./12.))*abs(SH_3_6(pnorm))\n         +\n         \n         smoothstep(0.2, 0.8,frequency(7./12.))*abs(SH_2_0(pnorm2))+\n         smoothstep(0.2, 0.8,frequency(8./12.))*abs(SH_2_1(pnorm2))+\n         smoothstep(0.2, 0.8,frequency(9./12.))*abs(SH_2_3(pnorm2))+\n         smoothstep(0.2, 0.8,frequency(10./12.))*abs(SH_2_4(pnorm2))\n         \n         +\n         \n         smoothstep(0.1, 0.8,frequency(11./12.))*abs(SH_1_0(pnorm2))+\n         smoothstep(0.1, 0.8,frequency(1.))*abs(SH_1_2(pnorm2))\n        \n        \n        );\n    \n    return (length(p) - s);\n}\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    \n  \n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n\n // return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\n//----------------------------------------------------------------------\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = //opU\n        ( \n           // vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere2(    pos, 1. ), 86.9 ) \n                  );\n    \n\n    \n    \n//    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n//    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\t///res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.50, 2.0), vec2(0.45,0.15) ), 75.0 ) );\n//    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n//\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n//\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n//\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n//\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n//\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n//\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n//\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\n//    res = opU( res, vec2( opS(\n//\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n//\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n //   res = opU( res, vec2( opS(\n//\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n//\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n//\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n//\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n//\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n//\tres = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n//\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n//                                       65.0 ) );\n//\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\n//    res = opU( res, vec2(sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n\n //   res = opU( res, vec2(sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.0002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.2, 0.4, .50) +rd.y*0.4;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        //dif *= softshadow( pos, lig, 0.02, 2.5 );\n        //dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        //lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        //lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        //lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 ;//+ iTime;\n\n\t// camera\t\n\tvec3 ro = 2.5*vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 41], [43, 43, 73, 73, 120], [123, 123, 158, 158, 186], [621, 654, 681, 681, 712], [713, 713, 740, 740, 775], [776, 776, 803, 803, 838], [839, 839, 866, 866, 901], [902, 902, 929, 929, 968], [969, 969, 996, 996, 1035], [1036, 1036, 1063, 1063, 1112], [1113, 1113, 1140, 1140, 1179], [1180, 1180, 1207, 1207, 1256], [1257, 1257, 1284, 1284, 1341], [1342, 1342, 1369, 1369, 1412], [1413, 1413, 1440, 1440, 1493], [1494, 1494, 1521, 1521, 1574], [1575, 1575, 1602, 1602, 1655], [1656, 1656, 1683, 1683, 1736], [1737, 1737, 1764, 1764, 1821], [1824, 1824, 1853, 1853, 1984], [1986, 1986, 2022, 2041, 3695], [3699, 3699, 3732, 3732, 3859], [3937, 3937, 3970, 3970, 3996], [3998, 3998, 4028, 4028, 4061], [4063, 4063, 4093, 4093, 4122], [4124, 4124, 4148, 4148, 4280], [4357, 4357, 4382, 4382, 6628], [6630, 6630, 6670, 6670, 7261], [7264, 7264, 7338, 7338, 7599], [7601, 7601, 7633, 7633, 7854], [7856, 7856, 7898, 7898, 8197], [8202, 8202, 8241, 8241, 9822], [9824, 9824, 9876, 9876, 10053], [10055, 10055, 10112, 10112, 10713]], "test": "error"}
{"id": "4tySDG", "name": "warped Raymarch Kaleidoscope", "author": "ShaderLyf", "description": "ray marching spheres, did it wrong looks cool, modulating the sphere function and lerping through warped planes.\nNew to shaders, not sure sine waves are the best way to control everything in the mix function, want it to sustain for a bit. ", "tags": ["raymarch", "kaleidoscope", "warped"], "likes": 1, "viewed": 152, "published": "Public", "date": "1485559064", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float eps = 0.01;\nconst vec3 floorColor = vec3(0.5,0.0,1.0);\nconst vec3 otherColor = vec3(1.0,0.0,0.0);\nconst float PI = 3.141592658;\nconst float TAU = 2.0 * PI;\nconst float sections = 6.0;\n\nfloat sphere(vec3 p)\n{\n// p.x = mod(p.x+1.0,-2.);\n\n vec3 q = fract(p) * 1.0-0.5;\n    \n //q.z = (0.01*sin(iTime/20.0));\n  //vec3 q;   \n    \n q.x = cos(p.y+0.2*iTime);\n    \n q.y = sin(p.x+0.2*iTime);  \n //vec3 q = mod(p, 3.1);   \n //return length(q) - (q.x * sin(iTime/10.1)+1.9);\n return length(q) - (1.5);\n}\n\nfloat udBox( vec3 p )\n{\n  \n  vec3 q = fract(p)*0.1-0.05;\n    \n  q.x = cos(p.y+0.4*iTime);\n    \n  q.y = sin(p.x+0.4*iTime); \n  vec3 b = vec3(0.1,0.1,0.1);\n  return length(max(abs(q)-b,0.0));\n}\n\nfloat scene (vec3 p)\n{\n   //return udBox(cos(p)*0.1);\n   return sphere(cos(p)*1.0);\n   //return sphere(p);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n   \n    vec3 q = abs(p);\n    //q.x = mod(q.x+10.0,20.0)-10.0;\n    q.y = fract(q.y) * 2.0-1.0;\n    \n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i)\n    {\n    \tvec3 p = o + r *t;\n        float d = scene(p);\n       // vec3 norml = getNormal(p); \n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 normal;\n    vec3 ep = vec3(eps,0.0,0.0);\n    normal.x = scene(p+ep.xyz) - scene(p-ep.xyz);\n    normal.y = scene(p+ep.yxz) - scene(p-ep.yxz);\n    normal.z = scene(p+ep.yzx) - scene(p-ep.yzx);\n    return normalize(normal);\n}\n\nfloat calcShadowFactor(vec3 p, vec3 norm, vec3 lightDir)\n{\n    float t = .0;\n    vec3 rayStart = p + norm + eps*2.0;\n        for (int i =0; i<16;i++)\n        {\n            vec3 sP = rayStart - lightDir * t;\n            float dist = scene(sP);\n            if(dist < eps)\n            {\n                return 1.0;\n            }\n            t+=dist;\n        }\n    return 0.0;\n}\n\nvec2 pattern1(vec2 uv)\n{\n\tfloat s = sin(3.1416*iTime/16.0);\n    float c = sin(3.1416*iTime/16.0);\n    //float c = 1.0;\n    uv = uv*iResolution.xy - vec2(0.5);\n    vec2 point = vec2(c*uv.x - s*uv.y, s*uv.x + c*uv.y)*0.01;\n   // return vec2 (sin(point.x)+sin(point.y);\n    return vec2(sin(point.x),sin(point.y));\n}\n\nvec2 pattern2(vec2 uv)\n{\n    float time = iTime;\n    float r = sqrt(dot(uv,uv)); // These are equivalent I think\n    \n    float a = atan( uv.x, uv.y);\n    \n    float u = r*cos(a+r); // omg this is trppy\n    float v = r*sin(a+r);\n    return vec2(u,v);\n}\n\nvec2 pattern3(vec2 uv)\n{\n    float time = iTime;\n    float r = sqrt(dot(uv,uv)); // These are equivalent I think\n    \n    float a = atan( uv.y,uv.x );\n    \n    float u = cos(a+cos(r)/10.0)/r; // This is horribly mind manifesting!\n    float v = (sin(a+r)/r); \n    return vec2(u,v);\n}\n\nvec2 pattern4(vec2 uv)\n{\n    float time = iTime;\n    float r = sqrt(dot(uv,uv)); // These are equivalent I think\n    \n    float a = atan( uv.x, uv.y);\n    \n    float u = (uv.x * time *cos(1.0*r) - uv.y*sin(1.0*time*r)) * 0.01; //Yay it looks like a spiral\n    float v = (uv.y*time*cos(1.0*r) + uv.x*sin(1.0*time*r)) * 0.01;\n    return vec2(u,v);\n}\n\nvec2 pattern5(vec2 uv)\n{\n      float time = iTime;\n      float r = sqrt(dot(uv,uv));\n      float u = 0.1*uv.x/(0.11+r*0.5); // The r's here just make it look four quads\n      float v = 0.1*uv.y/(0.11+r*0.5);\n      return vec2(u,v);\n}\n\nvec2 pattern6(vec2 uv)\n{\n    float time = iTime;\n    float a = atan( uv.x, uv.y);\n    float r = sqrt(dot(uv,uv));\n    float u = 0.01*uv.y+0.01*cos(a*5.0)/r; // Looks cool, but a bit smashed, i'm doing it wrong!\n    float v = 0.01*uv.x+0.01*sin(a*5.0)/r;\n\treturn vec2(u,v);\n}\n\nvec2 pattern7(vec2 uv)\n{\n    float time = iTime;\n    float a = atan( uv.x, uv.y);\n    float r = sqrt(dot(uv.x,uv.x));\n    float u = 0.9/(r+0.5*uv.x); // Looks cool, but a bit smashed, i'm doing it wrong!\n    float v = 0.9/(r+0.5*uv.x);\n\treturn vec2(u,v);\n}\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat checker(vec2 uv)\n{\n    //float Size = abs(2.1+cos(iTime/50.0));\n    float Size = 15.0;\n    vec2 Pos = floor(uv * Size);\n    //float PatternMask = mod(Pos.x + mod(Pos.y, abs(1.1+sin(iTime/40.0))), abs(1.1+cos(iTime/40.0)));\n    //float PatternMask = mod(Pos.x + mod(Pos.y, abs(2.1*sin(iTime/40.0))),2.0);\n\tfloat PatternMask = mod(Pos.y + mod(Pos.x,1.0),9.0);\n    //return PatternMask * vec4(0.2, 0.2, 0.9, 1.0);\n    return PatternMask;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec4 finalColor = vec4(0.0,0.0,0.0,1.);\n    \n    uv = uv * 2.0 -1.0;\n    \n    //vec2 uv1 = vec2(pattern(uv),pattern(uv));\n    \n    vec2 uv1 = vec2(pattern2(uv));\n    vec2 uv2 = vec2(pattern5(uv));\n    //vec2 uv3 = vec2(pattern5(uv));\n    vec2 uv4 = vec2(pattern5(uv));\n    \n    float rad = length(uv);\n  \tfloat angle = atan(uv.y, uv.x);\n\n  \tfloat ma = mod(angle, TAU/sections);\n  \tma = abs(ma - PI/sections);\n   \tfloat time = iTime/10.0;\n  \tfloat x = cos(ma-time) * rad;\n  \tfloat y = sin(ma) * (rad);\n    \n    vec2 uv3 = vec2(x,y);\n    \n    uv.x *= iResolution.x / iResolution.y;\n    vec2 omix1 = mix(uv,uv2, 1.0*cos(iTime*0.4));\n    vec2 omix2 = mix(uv4,uv2, 1.0*sin(iTime*0.2));\n    vec2 omix = mix(omix1,uv1, cos(iTime*0.1));\n    \n   // vec2 mxer = mix(uv2, omix, 1.0*cos(iTime*0.5));\n    vec2 mxer = mix(uv2, uv3, impulse(2.0,(iTime*0.06)));\n    //vec2 mxr = cubicPulse(uv,uv1,1.0*sin(iTime));\n    \n    vec3 r = normalize(vec3(omix,1.0));\n    \n    vec3 o = vec3(0.0,0.0,-5.0);\n     //vec3 o = vec3(0.0,0.0,-3.0);\n    //float t = trace(o,r);\n    float t = 0.0;\n    float sq = sqrt(dot(uv,uv));\n    \n    for (int i = 0; i < 32; ++i)\n    {\n    \tvec3 p = o + r *t;\n        float d = scene(p);\n        \n        if (d < eps)\n        {\n        \tvec3 norml = getNormal(p);\n        \tvec3 ldir = vec3(1.0,-1.5,1.0);\n        //\tfloat diffuseFactor = max(dot(norml,-ldir),0.0);\n            float diffuseFactor = max(dot(norml,-ldir),0.0);\n\n        \tfloat shadow = calcShadowFactor(p,norml,ldir);   \n        \t//vec3 diffuseColor = vec3(abs (sin(iTime/10.0)),0.7,0.2);\n            float chk = checker(omix);\n            //vec3 diffuseColor = chk*vec3(texture(iChannel0,vec2(omix))).xyz;\n           \n            vec3 diffuseColor = chk*vec3(0.1,0.2,0.2+cos(iTime));\n        \t//finalColor = vec3(1,0,1)*max(dot(norml,vec3(sin(iTime),cos(iTime),0.33)),0.0);\n        \tfinalColor = vec4((1.5-shadow)*diffuseFactor*diffuseColor,1); \n        }\n        t += d;\n    }\n    \n    float fog = 0.2 / (1.1 +t*t*0.9);\n    \n   // vec4 fc *= vec4(finalColor+fog);\n    finalColor += fog;\n    \n    \n\tfragColor = vec4(finalColor);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tySDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 219, 246, 504], [506, 506, 529, 529, 697], [699, 699, 721, 752, 807], [809, 809, 845, 845, 1007], [1009, 1009, 1038, 1038, 1227], [1229, 1229, 1253, 1253, 1482], [1484, 1484, 1542, 1542, 1858], [1860, 1860, 1884, 1884, 2172], [2174, 2174, 2198, 2198, 2426], [2428, 2428, 2452, 2452, 2710], [2712, 2712, 2736, 2736, 3059], [3061, 3061, 3085, 3085, 3294], [3296, 3296, 3320, 3320, 3570], [3572, 3572, 3596, 3596, 3828], [3831, 3831, 3878, 3878, 3972], [3974, 3974, 4009, 4009, 4055], [4057, 4057, 4081, 4126, 4499], [4502, 4502, 4559, 4559, 6709]], "test": "error"}
{"id": "4tySWK", "name": "[ #02 ] - Electric field", "author": "Yrai", "description": "Using absolute sum of 3d perlin noise to generate electric field. Coloring could be much better, give suggestions.\n\nRef:\n- http://www.iquilezles.org/\n- https://www.shadertoy.com/user/candycat", "tags": ["3d", "noise", "lightning", "electric"], "likes": 40, "viewed": 2119, "published": "Public API", "date": "1485854657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define res_          iResolution\n#define time_         iTime\n#define detail_steps_ 13\n\n#define mod3_      vec3(.1031, .11369, .13787)\n\n\nvec3  hash3_3(vec3 p3);\nfloat perlin_noise3(vec3 p);\nfloat noise_sum_abs3(vec3 p);\nvec2  domain(vec2 uv, float s);\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = domain(fragCoord, 2.5);\n   \t\n    float electric_density = .9;\n    float electric_radius  = length(p) - .4;\n    float velocity = .1;\n    \n    float moving_coord = sin(velocity * time_) / .2 * cos(velocity * time_);\n    vec3  electric_local_domain = vec3(p, moving_coord);\n    float electric_field = electric_density * noise_sum_abs3(electric_local_domain); \n    \n    vec3 col = vec3(107, 148, 196) / 255.;\n \tcol += (1. - (electric_field + electric_radius));\n    for(int i = 0; i < detail_steps_; i++) {\n    \tif(length(col) >= 2.1 + float(i) / 2.)\n            col -= .3;\n    }\n    col += 1. - 4.2*electric_field;\n    \n    float alpha = 1.;\n    fragColor = vec4(col, alpha);\n}\n\n\nvec3 hash3_3(vec3 p3) {\n\tp3 = fract(p3 * mod3_);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n}\n\nfloat perlin_noise3(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3. - 2. * pf);\n    \n    return \tmix(\n    \tmix(\n            mix(\n                dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),\n                w.x),\n    \tw.z),\n        mix(\n            mix(\n                dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),\n                w.x),\n     \tw.z),\n\tw.y);\n}\n\n\nfloat noise_sum_abs3(vec3 p) {\n    float f = 0.;\n    p = p * 3.;\n    f += 1.0000 * abs(perlin_noise3(p)); p = 2. * p;\n    f += 0.5000 * abs(perlin_noise3(p)); p = 3. * p;\n\tf += 0.2500 * abs(perlin_noise3(p)); p = 4. * p;\n\tf += 0.1250 * abs(perlin_noise3(p)); p = 5. * p;\n\tf += 0.0625 * abs(perlin_noise3(p)); p = 6. * p;\n    \n    return f;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2.*uv.xy-res_.xy) / res_.y*s;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tySWK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[343, 343, 395, 395, 1079], [1082, 1082, 1105, 1105, 1264], [1266, 1266, 1295, 1295, 2182], [2185, 2185, 2215, 2215, 2526], [2528, 2528, 2559, 2559, 2603]], "test": "valid"}
{"id": "4tySzV", "name": "Plasma 2d", "author": "Tapped", "description": "A simple plasma effect made during Shadertoy compo on Solskogen\n\nOriginal source: ftp://ftp.no.scene.org/scene.org/parties/2016/solskogen16/livecoding/final-tapped.glsl", "tags": ["plasmaeffect"], "likes": 2, "viewed": 149, "published": "Public", "date": "1484914393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = vec2((fragCoord.x - iResolution.x*.5) / iResolution.y, (fragCoord.y - iResolution.y*.5) / iResolution.y);\n\n  uv *= 2.0;\n  float factor = 0.;\n  float f2 = 0.;\n  float radius = 0.54;\n  const int count = 20;\n  for(int i = 0;i != count;++i)\n  {\n    float offset = sin(2. * PI * float(i) / float(count) + iTime * 0.4);\n    float base = length(uv-vec2(offset, sin(iTime + 2. * PI * float(i) / float(count)))) + radius;\n  \n    factor += smoothstep(0., 1., 1.0 - base);\n    factor += 0.2 * smoothstep(0., 1., 1.0 - base - sin(iTime) * 0.05);\n    f2 += smoothstep(0., 1., 1.0 - base);\n    factor += 0.1 * factor * texture(iChannel0, uv).x;\n  }\n\n  vec3 color = vec3(factor * 0.4, factor, factor)*0.6 + vec3(0.1,(sin(iTime*0.5-0.4)*0.5+0.5)*0.3,0.3);\n  color += vec3(0, uv.y*0.4*factor, 0) + f2 * length(texture(iChannel1, uv).xyz);\n  fragColor = vec4(color,1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tySzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 82, 82, 947]], "test": "error"}
{"id": "llGSDm", "name": "Shader Wood", "author": "Valou", "description": "Shader Wood", "tags": ["wood"], "likes": 3, "viewed": 77, "published": "Public", "date": "1484577335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// BOIS ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 yellow=vec3(0.45,0.25,0.1);\nconst vec3 brown=vec3(0.65,0.40,0.15);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=0.5*(1.0+sin(sqrt(pow(p.y, 2.0)+pow(p.z, 2.0))*50.0+100.0*noise(p)));\n    return mix(yellow,brown,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(yellow,brown,t);\n}\n\n// Wood\n// p : Point\n// n : Normal\nvec3 wood(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (5.0*p,n);\n    return mix(yellow,brown,t);\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*checker(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 155, 179, 179, 222], [224, 255, 281, 281, 650], [726, 779, 814, 814, 883], [1038, 1095, 1130, 1130, 1246], [1248, 1289, 1328, 1353, 1391], [1393, 1418, 1452, 1477, 1541], [1543, 1578, 1610, 1635, 1703], [1705, 1775, 1820, 1820, 1862], [1939, 2121, 2199, 2199, 2434], [2511, 2552, 2580, 2580, 2653], [2655, 2701, 2734, 2753, 3207], [3209, 3266, 3304, 3304, 3385], [3462, 3462, 3519, 3519, 4088]], "test": "valid"}
{"id": "llGSDW", "name": "5. TRAVAIL SUR NOS MER(E)S", "author": "Koyce", "description": "Axel pour ton bonheur\nEt maintenant pour le mien", "tags": ["axel", "tutoriel"], "likes": 1, "viewed": 71, "published": "Public", "date": "1484319020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TUTORIEL FAIRE DES VAGUES\n\nvoid mainImage(out vec4 color, in vec2 pixCoords) //vec4 car quatre paramÃ¨tres dans la parenthÃ¨se\n{\n    float pi = 3.14159265359;\n    float radius = iResolution.y/3.5 + 10.0 * cos(iTime);\n    \n    \n    //  (cos(iTime) *20.0\n    \n    \n    if (pixCoords.y < 70.0 + cos(iTime) *20.0 + cos(pixCoords.x/20.0 + iTime * 15.0) * 20.0 )\n    {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    else if (pixCoords.y < 150.0 + cos(iTime) *40.0 + cos(pixCoords.x/35.0 + iTime * 5.0) *20.0 )\n    {\n        color = vec4(0.7, 0.0, 0.5, 1.0);\n    }\n    else if (pixCoords.y < 220.0 + cos(iTime) *50.0 + cos(pixCoords.x/40.0 + iTime * 2.0) *10.0 )\n    {\n        color = vec4(0.7, 0.8, 0.5, 1.0);\n    }\n    else\n    {\n        color = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    \n    \n    \n    /*\n    if (pixCoords.y < 100.0 +   cos(pixCoords.x/20.0 + iTime * 10.0)*20.0 )      //  (cos(iTime) *20.0\n    {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        color = vec4(1.0, 1.0, 1.0, 1.0);\n    }*/\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 131, 131, 1036]], "test": "valid"}
{"id": "llGSR3", "name": "checkerboard tunnel", "author": "abje", "description": "many tunnels, modification of https://www.shadertoy.com/view/lssGDn", "tags": ["tunnel", "checkerboard"], "likes": 4, "viewed": 530, "published": "Public API", "date": "1485206554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 checker(vec2 p) {\n    vec2 p2 = abs(fract(p)-0.5);\n    return vec2(mod(floor(p.x)+floor(p.y), 2.0),max(1.0-(-max(p2.x,p2.y)+0.5)*50.0,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = vec4(1.0);\n    \n    \n    float len = 0.0;\n    for ( float i = 5.0; i< 160.0; i++) {\n    \n        float size = i;\n        \n        vec2  pos = (2. * fragCoord.xy / iResolution.xy - 1.)\n                * vec2(iResolution.x / iResolution.y,1.);\n        vec2  rot = vec2(atan(pos.x, pos.y) / 3.14*size+iTime/(size-4.0),\n                         size / length(pos)*0.1+iTime+i*0.2);\n        vec2 check = checker(rot);\n        if (check.x == 1.0) {\n    \t\tfragColor = vec4(0.05*i);\n            break;\n        }\n        len = max(check.y,len);\n        \n    }\n    \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 147], [149, 149, 206, 206, 846]], "test": "valid"}
{"id": "llGXD1", "name": "wavewarp", "author": "nexor", "description": "wave warp", "tags": ["wave", "warp"], "likes": 3, "viewed": 84, "published": "Public", "date": "1484158729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define sin1(x) (.5+sin(x)*.5)\n#define cos1(x) (.5+cos(x)*.5)\n#define ss smoothstep\n\nconst float pi = 3.1415;\n#define resolution iResolution.xy\n#define time iTime\n\nvec2 mm(vec2 p)\n{\n\treturn vec2(min(p.x,p.y),max(p.x,p.y));\n}\nvec2 rc(vec2 p)\n{\n\tvec2 m=mm(p);\n\tfloat r=m.y/m.x;\n\tfloat s=step(p.y,p.x);\n\treturn vec2(mix(1.,r,s),mix(r,1.,s));\n}\n\nvec2 tr(vec2 p, vec2 res)\n{\n  p/=res;\n  p=-1.+2.*p;\n  return p*rc(res);\n}\n\nfloat gr(float t)\n{\n\treturn smoothstep(.0,1.,fract(time))*t+floor(time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col=vec3(.0);\n\tvec2 p=tr(fragCoord,resolution);\n    vec2 q=p;\n\tfloat a=atan(p.y,p.x);\n    p.x+=sin(q.y*50.+time)*.1;\n    p.y+=cos(q.x*50.+time)*.1;\n    p+=sin(a+1.2/length(q)-time)*.5;\n    p/=atan(1.,length(q));\n\tfloat d=1.2*length(p);\n\tfloat t=10.*sin(2.*pi*fract(time*.1));\n    col+= mix(\n        mix(vec3(1.,.5,.0),vec3(.0,1.,0),sin1(t+a*8.-d*20.)),\n        mix(vec3(1.,.0,.0),vec3(.0,.0,1.),sin1(t+a*8.-d*20.)),\n        1.-ss(1.,.99,d));\n    col *= ss(.1,.2,length(q));\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 205, 205, 248], [249, 249, 266, 266, 364], [366, 366, 393, 393, 439], [441, 441, 460, 460, 515], [517, 517, 574, 574, 1087]], "test": "valid"}
{"id": "llGXDm", "name": "Shader Rust", "author": "Valou", "description": "Shader Rust", "tags": ["rust"], "likes": 2, "viewed": 69, "published": "Public", "date": "1484577770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ROUILLE ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 rust=vec3(0.60,0.35,0.1);\nconst vec3 iron=vec3(0.8,0.8,0.8);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(rust,iron,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(rust,iron,t);\n}\n\n// Rouille\n// p : Point\n// n : Normal\nvec3 rouille(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (10.0*p,n);\n   \n    if(t<0.51)\n    {\n        vec3 brown = vec3(0.5,0.18,0.1);\n        t=noise(500.0*p);\n    \treturn mix(rust,brown,t);\n        \n    }\n    \n    if(t<0.53)\n    {\n        vec3 red = vec3(0.45,0.0,0.0);\n        t=0.0;\n    \treturn mix(red,rust,t);\n    }\n    \n    return mix(0.5*rust,iron,t);\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*rouille(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 158, 182, 182, 225], [227, 258, 284, 284, 653], [729, 782, 817, 817, 886], [1035, 1092, 1127, 1127, 1213], [1215, 1256, 1295, 1320, 1483], [1485, 1510, 1544, 1569, 1630], [1632, 1670, 1705, 1730, 2058], [2060, 2130, 2175, 2175, 2217], [2294, 2476, 2554, 2554, 2789], [2866, 2907, 2935, 2935, 3008], [3010, 3056, 3089, 3108, 3562], [3564, 3621, 3659, 3659, 3740], [3817, 3817, 3874, 3874, 4443]], "test": "valid"}
{"id": "llGXDw", "name": "lava_ball", "author": "sanctify", "description": "Lava ball", "tags": ["lavaball"], "likes": 1, "viewed": 100, "published": "Public", "date": "1484571893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nvec3 red=vec3(0.9,0.15,0.);\nvec3 grey=vec3(0.0,0.0,0.0);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(p.x+p.y+p.z,2.0);\n    return mix(red,grey,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.2*noise(2.0*p);\n    \n    // Scale\n    t/=(3.);\n\n    if(t>0.3){\n    \treturn t*(1.3+sin(iTime)/3.);\n    }\n    \n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(red,grey,t);\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 lava(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (22.5*p,n);\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n\n    if(t > 0.8 && t < 0.83){\n        vec3 black = vec3(.0,.0,.0);\n    \treturn black;\n    }\n    \n    if(t < 0.85 && t > 0.65){\n    \tt= 0.0;\n    }else if(t<0.65){\n        red = vec3(0.45,0.05,0.);\n    }else if(t<0.55){\n        red = vec3(0.85,0.15,0.);\n    }\n    \n    return mix(red,grey,t);\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return vec3(0.15,0.15,0.15);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*lava(p,n)*lightColor;//*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.25*iTime);\n    d=rotate(d,0.25*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 156, 180, 180, 223], [225, 256, 282, 282, 651], [727, 780, 815, 815, 884], [1018, 1075, 1110, 1110, 1174], [1176, 1217, 1256, 1281, 1463], [1465, 1490, 1524, 1549, 1609], [1611, 1648, 1680, 1705, 2115], [2117, 2187, 2232, 2232, 2274], [2351, 2533, 2611, 2611, 2846], [2923, 2964, 2992, 2992, 3027], [3029, 3075, 3108, 3127, 3592], [3594, 3651, 3689, 3689, 3770], [3847, 3847, 3904, 3904, 4475]], "test": "valid"}
{"id": "llGXRG", "name": "Lighting Blended Shapes", "author": "twitchingace", "description": "Messing around with displacement maps, blending, and normal calculation. Not entirely sure what's up with the waviness on the displacements (might be from floating points or my discrete steps). \n\nDefinitely not a faceless weezing. Don't even ask.", "tags": ["3d", "phong", "raymarch", "displacement", "lighting", "blending"], "likes": 6, "viewed": 198, "published": "Public", "date": "1484770108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 eye = vec3(0,0,10);\nvec3 lightPos = vec3(10., -2., 2.);\n\nvec3 sphere1Pos = vec3(-0.6, 0., 0.);\nfloat sphere1Rad = .55;\n\nvec3 eye1Pos = vec3(-.8, -.15, .53);\nfloat eye1Rad = .1;\n\nvec3 eye2Pos = vec3(-0.35, -.13, .53);\nfloat eye2Rad = .1;\n\nvec3 sphere2Pos = vec3(0.05, 0.6, -.5);\nfloat sphere2Rad = .25;\n\nvec3 sphere3Pos = vec3(0.7, 0.1, 0.);\nfloat sphere3Rad = .4;\n\nvec3 eye3Pos = vec3(.67, 0., .4);\nfloat eye3Rad = .07;\n\nvec3 eye4Pos = vec3(1., .0, .31);\nfloat eye4Rad = .07;\n\nvec3 cylinder1Pos = vec3(-0.25, .4, -0.2);\nvec2 cylinder1Size = vec2(.075, .55);\nvec3 cylinder1Rotate = vec3(-.8, 0., -0.6);\n\nvec3 cylinder2Pos = vec3(0.3, .4, -0.2);\nvec2 cylinder2Size = vec2(.075, .35);\nvec3 cylinder2Rotate = vec3(-.7, 0., 0.7);\n\nvec3 eyebrow1Pos = vec3(-0.8, -.25, .55);\nvec2 eyebrow1Size = vec2(.045, .175);\nvec3 eyebrow1Rotate = vec3(-.05, 0., -1.3);\n\nvec3 eyebrow2Pos = vec3(-0.3, -.25, .55);\nvec2 eyebrow2Size = vec2(.045, .175);\nvec3 eyebrow2Rotate = vec3(.05, 0., 1.3);\n\nvec3 eyebrow3Pos = vec3(0.65, -.1, .45);\nvec2 eyebrow3Size = vec2(.035, .11);\nvec3 eyebrow3Rotate = vec3(-.2, 0., -1.2);\n\nvec3 eyebrow4Pos = vec3(1.05, -.1, 0.32);\nvec2 eyebrow4Size = vec2(.035, .11);\nvec3 eyebrow4Rotate = vec3(.2, 0., 1.2);\n\nconst float maxIterations = 32.;\n\nstruct mat{\n\tfloat spec;\n    float diff;\n    float amb;\n    float shiny;\n};\n\nstruct ray{\n \tvec3 position;\n    vec3 direction;\n};\n    \nmat test = mat(.3,1.1,.01,1.);\n\n/*\n * Begin utility distance functions\n */\nmat3 rotMat(vec3 rotAm) {\n    mat3 matx = mat3(vec3(1., 0., 0.),\n                      vec3(0., cos(rotAm.x), sin(rotAm.x)),\n                      vec3(0., -sin(rotAm.x), cos(rotAm.x)));\n    mat3 maty = mat3(vec3(cos(rotAm.y), 0., -sin(rotAm.y)),\n                      vec3(0., 1., 0.),\n                      vec3(sin(rotAm.y), 0., cos(rotAm.y)));\n    mat3 matz = mat3(vec3(cos(rotAm.z), sin(rotAm.z), 0.),\n                      vec3(-sin(rotAm.z), cos(rotAm.z), 0.),\n                      vec3(0., 0., 1.));\n    \n    mat3 matrix = matz * maty * matx;\n    // Transpose the matrix (we need its inverse)\n    float temp1 = matrix[1][0];\n    float temp2 = matrix[2][0];\n    float temp3 = matrix[2][1];\n    matrix[1][0] = matrix[0][1];\n    matrix[2][0] = matrix[0][2];\n    matrix[2][1] = matrix[1][2];\n    matrix[0][1] = temp1;\n    matrix[0][2] = temp2;\n    matrix[1][2] = temp3;\n    \n    return matrix;\n}\n\nfloat smin( float a, float b)\n{\n    float h = clamp( 0.5+0.5*(b-a)/0.1, 0.0, 1.0 );\n    return mix( b, a, h ) - 0.1*h*(1.0-h);\n}\n\nfloat subtract( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat distCylinder( vec3 p, vec2 h, vec3 rot)\n{\n\tp = rotMat(rot) * p;  \n\tfloat u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / h.x;\n    float v = p.y / h.y + .5;\n    \n    float disp = texture(iChannel0, vec2(u * .1 + .1,v * .5 + .1)).r;\n    \n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)) - (disp * .05);\n}\n\nfloat distFlatSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat distSphere( vec3 p, float s )\n{\n    // Standard UV wrapping for a sphere\n    float u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / s / .5;\n    float v = (.5 - asin(p.y) / 3.14159) / s / .5;\n    float disp = texture( iChannel0,\n                           vec2(u,v)).r;\n    \n    // The exponential smooths out the displacement so we don't have crazy looking poles\n\treturn length(p)-s - (disp * 0.1 * (s / .5) * exp(1. - abs(p.y))/exp(1.));\n}\n\n// End utility distance functions\n\nfloat distFunc(vec3 p)\n{\n    // Basic shape\n    float d1 = distSphere(p - sphere1Pos, sphere1Rad);\n    float d2 = distSphere(p - sphere2Pos, sphere2Rad);\n    float d3 = distSphere(p - sphere3Pos, sphere3Rad);    \n    float d4 = distCylinder(p - cylinder1Pos, cylinder1Size, cylinder1Rotate);\n    float d5 = distCylinder(p - cylinder2Pos, cylinder2Size, cylinder2Rotate);\n    \n    // Eyebrows\n    float d6 = distCylinder(p - eyebrow1Pos, eyebrow1Size, eyebrow1Rotate);\n    float d7 = distCylinder(p - eyebrow2Pos, eyebrow2Size, eyebrow2Rotate);\n    float d8 = distCylinder(p - eyebrow3Pos, eyebrow3Size, eyebrow3Rotate);\n    float d9 = distCylinder(p - eyebrow4Pos, eyebrow4Size, eyebrow4Rotate);\n       \n    return smin(smin(smin(smin(smin(smin(min(min( d1, d2), d3), d4), d5), d6), d7), d8), d9);\n}\n\nfloat faceFunc(vec3 p){\n    float d1 = distFlatSphere(p - eye1Pos, eye1Rad);\n    float d2 = distFlatSphere(p - eye2Pos, eye2Rad);\n    float d3 = distFlatSphere(p - eye3Pos, eye3Rad);\n    float d4 = distFlatSphere(p - eye4Pos, eye4Rad);\n    \n    return min(min(min(d1, d2), d3), d4);\n}\n\n// Shamelessly ripped from IQ's https://www.shadertoy.com/view/Xds3zN\n// I'm honestly not quite sure how this works.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*distFunc( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*distFunc( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*distFunc( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*distFunc( pos + e.xxx ) ) ;\n}\n\nvec3 getNormalFace( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*faceFunc( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*faceFunc( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*faceFunc( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*faceFunc( pos + e.xxx ) ) ;\n}\n\nray lookAt(in vec2 uv, in vec3 targetPoint){\n\tvec3 forward = normalize(targetPoint - eye);\n    vec3 up = vec3(0.,1.0,0.0);\n    vec3 right = cross(forward, up);\n    up = cross(forward, right);\n    vec3 ro = eye + forward * .1 + right * uv.x + up * uv.y;\n    vec3 rd = forward;\n    return ray(ro,rd);\n}\n\nvec3 rayMarch(ray marcher){\n    float epsilon = 0.001;\n    float t = 0., d, d2;\n    vec3 targetSphere = sphere1Pos;\n    float targetRad = sphere1Rad;\n    vec3 point;\n    \n    for (float i = 0.; i < maxIterations; i++){\n        point = marcher.position + marcher.direction * t;\n        \n        d = distFunc(point);\n        if (d < epsilon){\n            // Calc phong illumination\n            vec3 normal = getNormal(point);\n            vec3 light1Dir = normalize(lightPos - point);\n            vec3 viewDir = normalize(eye - point);\n            vec3 reflection1 = reflect(light1Dir, normal);\n            // Add the ambient component\n            float Ip = test.amb;\n            // Add the diffuse component\n            Ip += max(0., test.diff * dot(light1Dir, normal));\n            // Add the specular component\n            Ip += max(0., pow(test.spec * dot(reflection1, viewDir), test.shiny));\n            return Ip * vec3(.816, 0.26, .96); //getNormal(point);\n        }\n        \n        d2 = faceFunc(point);\n        if (d2 < epsilon){\n            // Calc phong illumination\n            vec3 normal = getNormalFace(point);\n            vec3 light1Dir = normalize(lightPos - point);\n            vec3 viewDir = normalize(eye - point);\n            vec3 reflection1 = reflect(light1Dir, normal);\n            // Add the ambient component\n            float Ip = test.amb;\n            // Add the diffuse component\n            Ip += max(0., test.diff * dot(light1Dir, normal));\n            // Add the specular component\n            Ip += max(0., pow(test.spec * dot(reflection1, viewDir), test.shiny));\n            return Ip * vec3(1.);\n        }\n        \n        t+=min(d, d2);\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    eye = vec3(4. * cos(iTime * .6), 4. * (sin(iTime * .25) / 2. - .5), 10. * sin(iTime * .6));\n    lightPos = vec3(6. * sin(iTime + 0.2), cos(iTime + .2) * 6., 2.);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    ray eyeRay = lookAt(uv, vec3(0)); \n\tfragColor = vec4(rayMarch(eyeRay),1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1422, 1465, 1490, 1490, 2365], [2367, 2367, 2398, 2398, 2495], [2497, 2497, 2535, 2535, 2561], [2563, 2563, 2610, 2610, 2928], [2930, 2930, 2971, 2971, 2994], [2996, 2996, 3033, 3074, 3453], [3490, 3490, 3514, 3533, 4289], [4291, 4291, 4314, 4314, 4575], [4577, 4694, 4725, 4725, 4946], [4948, 4948, 4983, 4983, 5204], [5206, 5206, 5250, 5250, 5506], [5508, 5508, 5535, 5535, 7208], [7210, 7210, 7266, 7266, 7614]], "test": "error"}
{"id": "llKXRw", "name": "Scottish seazure quilt", "author": "JoaCHIP", "description": "Not really the intension, but hey... ", "tags": ["quilt"], "likes": 0, "viewed": 81, "published": "Public", "date": "1483638429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 grad(vec3 p)\n{\n\tconst float texture_width = 256.0;\n\tvec4 v = texture(iChannel0, vec2((p.x+p.z) / texture_width, (p.y+p.z) / texture_width));\n    return normalize(v.xyz*2.0 - vec3(1.0));\n}\n\n/* S-shaped curve for 0 <= t <= 1 */\nfloat fade(float t)\n{\n  return t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n}\n\n/* 3D noise */\nfloat noise(vec3 p)\n{\n  /* Calculate lattice points. */\n  vec3 p0 = floor(p);\n  vec3 p1 = p0 + vec3(1.0, 0.0, 0.0);\n  vec3 p2 = p0 + vec3(0.0, 1.0, 0.0);\n  vec3 p3 = p0 + vec3(1.0, 1.0, 0.0);\n  vec3 p4 = p0 + vec3(0.0, 0.3, 1.0);\n  vec3 p5 = p4 + vec3(1.0, 0.0, 0.0);\n  vec3 p6 = p4 + vec3(0.0, 1.0, 0.0);\n  vec3 p7 = p4 + vec3(1.0, 1.0, 0.0);\n\n  /* Look up gradients at lattice points. */\n  vec3 g0 = grad(p0);\n  vec3 g1 = grad(p1);\n  vec3 g2 = grad(p2);\n  vec3 g3 = grad(p3);\n  vec3 g4 = grad(p4);\n  vec3 g5 = grad(p5);\n  vec3 g6 = grad(p6);\n  vec3 g7 = grad(p7);\n\n  float t0 = p.x - p0.x;\n  float fade_t0 = fade(t0); /* Used for interpolation in horizontal direction */\n\n  float t1 = p.y - p0.y;\n  float fade_t1 = fade(t1); /* Used for interpolation in vertical direction. */\n\n  float t2 = p.z - p0.z;\n  float fade_t2 = fade(t2);\n\n  /* Calculate dot products and interpolate.*/\n  float p0p1 = (1.0 - fade_t0) * dot(g0, (p - p0)) + fade_t0 * dot(g1, (p - p1)); /* between upper two lattice points */\n  float p2p3 = (1.0 - fade_t0) * dot(g2, (p - p2)) + fade_t0 * dot(g3, (p - p3)); /* between lower two lattice points */\n\n  float p4p5 = (1.0 - fade_t0) * dot(g4, (p - p4)) + fade_t0 * dot(g5, (p - p5)); /* between upper two lattice points */\n  float p6p7 = (1.0 - fade_t0) * dot(g6, (p - p6)) + fade_t0 * dot(g7, (p - p7)); /* between lower two lattice points */\n\n  float y1 = (1.0 - fade_t1) * p0p1 + fade_t1 * p2p3;\n  float y2 = (1.0 - fade_t1) * p4p5 + fade_t1 * p6p7;\n\n  /* Calculate final result */\n  return (1.0 - fade_t2) * y1 + fade_t2 * y2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n =\n        noise(vec3(fragCoord.xy, iTime * 30.0)/128.0)/ 2.0 +\n        noise(vec3(fragCoord.xy, iTime * 32.0)/32.0) / 3.0 +\n        noise(vec3(fragCoord.xy, iTime * 64.0)/8.0) / 10.0;\n\tfragColor = vec4(mix(mix(vec3(1.0, 1.0, 0.0), vec3(1.7, 1.7, 1.3), n + 1.0), vec3(-1.3, -1.15, -1.0), n*0.5 + 0.5) , 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 192], [194, 231, 252, 252, 296], [298, 313, 334, 368, 1867], [1869, 1869, 1926, 1926, 2248]], "test": "error"}
{"id": "llKXWz", "name": "Blue wave", "author": "qmuntada", "description": "Simple 2D wave", "tags": ["2d", "radar"], "likes": 13, "viewed": 654, "published": "Public API", "date": "1483967837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 uv, vec2 pos, float rad)\n{\n\tfloat d = length(pos - uv) - rad;\n    \n\tfloat t = 1.0 - clamp(d, 0.0, 1.0);\n    \n    float dist = (rad) - distance(uv, pos);\n    dist = clamp(dist * 0.01, 0.0, 1.0);\n    t -= dist;\n    \n\treturn vec4(t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n    \n    float time = iTime * 0.25;\n   \tfloat iTime = floor(time);\n    float fTime = time - iTime;\n    \n    float radius = fTime * (iResolution.y * 0.5);\n    \n    vec2 uv2 = uv - center;\n    uv2 /= iResolution.xy;\n    uv2 *= vec2(2, 2);\n    \n\tvec4 col = circle(uv, center, radius);\n    col *= 1.0 - fTime;\n\t\n\tfragColor = col * vec4(0.2, 0.2, 1.0, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 249], [251, 251, 306, 306, 725]], "test": "valid"}
{"id": "llVSzc", "name": "Rolling shutter prop. (sober)", "author": "JamesGriffin", "description": "For demonstrating the rolling shutter effect", "tags": ["implicitequation", "rollingshutter"], "likes": 1, "viewed": 122, "published": "Public", "date": "1485339632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Constants\n    float delayCoeff = 0.8;\n    float rotationRate = 2.0;\n    float hubSize = 0.1;\n    float bladeThinness = 5.0; // Higher is thinner\n    int numBlades = 5; // Can only be 2, 3, 4, 5, 6 (otherwise defaults to 6)\n    // Transform coordinate system\n    vec2 xy = 4.0*(fragCoord.xy-0.5*iResolution.xy) / max(iResolution.x,iResolution.y);\n\t\n    // Work out the angle\n    float theta = rotationRate * (iTime - delayCoeff * xy.y);\n    // Rotation matrix\n    mat2 M = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    xy = M * xy;\n    float r = length(xy);\n    float a = 0.0;\n    float x = xy.x / r;\n    float y = xy.y / r;\n    if (r > hubSize + 1.0) { // Don't bother with calculations if out of bounds\n        a = -1.0;\n    } else {\n        float p = 0.0;\n        float q = 0.0;\n\n        if(numBlades == 2) {\n            // 2 bladed version\n            // p = cos(2t) and q = sin(2t)\n            p = (x*x - y*y);\n            // q = (2.0*x*y); (not used)\n        } else if(numBlades == 3) {\n            // 3 bladed version\n            // p = cos(3t) and q = sin(3t)\n            p = (x*x*x - 3.0*x*y*y);\n            // q = (3.0*x*x*y - y*y*y); (not used)\n        } else if (numBlades == 4) {    \n            // 4 bladed version\n            // p = cos(4t) and q = sin(4t)\n            p = (x*x*x*x - 6.0*x*x*y*y + y*y*y*y);\n            // q = (4.0*x*x*x*y - 4.0*x*y*y*y); (not used)\n        } else if (numBlades == 5) {    \n            // 5 bladed version\n            // This is p = cos(5t) and q = sin(5t)\n            p = (x*x*x*x*x - 10.0*x*x*x*y*y + 5.0*x*y*y*y*y);\n            // q = (5.0*x*x*x*x*y - 10.0*x*x*y*y*y + y*y*y*y*y); (not used)\n        } else {\n            // 6 bladed version\n            // This is p = cos(6t) and q = sin(6t)\n            p = (x*x*x*x*x*x - 15.0*x*x*x*x*y*y + 15.0*x*x*y*y*y*y - y*y*y*y*y*y);\n            // q = (6.0*x*x*x*x*x*y - 20.0*x*x*x*y*y*y + 6*x*y*y*y*y*y); (not used)\n        }\n\n        // RHS of the implicit equation\n        a = pow(0.5*(1.0 - p), bladeThinness) + hubSize;\n\n        // Rather than plot LHS < RHS, use this to smooth edges (AA for free)\n        a = min(a/r - 1.0, 0.1) / 0.1;\n    }\n    \n    \n    if(a < 0.0) {\n        // White background\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    } else {\n        // Compute a colour for the propellor\n    \tfragColor = vec4(1.0-a,1.0-a,1.0-a,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 74, 2431]], "test": "valid"}
{"id": "llVXRd", "name": "Geodesic tiling", "author": "tdhooper", "description": "Distributing points on a sphere, without the bunching at the poles you get from spherical coordinates.\n\nMinimal version of the technique: [url]https://www.shadertoy.com/view/llGXWc[/url]", "tags": ["sphere", "hexagon", "tile", "geodesic"], "likes": 408, "viewed": 23867, "published": "Public API", "date": "1485542133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MODEL_ROTATION vec2(.3, .25)\n#define CAMERA_ROTATION vec2(.5, .5)\n\n// 0: Defaults\n// 1: Model\n// 2: Camera\n#define MOUSE_CONTROL 1\n\n//#define DEBUG\n\n// 1, 2, or 3\n//#define LOOP 1\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\nfloat smax(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n    } else {\n        return m;\n    }\n}\n\n\n// --------------------------------------------------------\n// Icosahedron domain mirroring\n// Adapted from knighty https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvec3 facePlane;\nvec3 uPlane;\nvec3 vPlane;\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n    pbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :)\n\tpab=vec3(0,0,1);\n    \n    facePlane = pca;\n    uPlane = cross(vec3(1,0,0), facePlane);\n    vPlane = vec3(1,0,0);\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\n\n// --------------------------------------------------------\n// Triangle tiling\n// Adapted from mattz https://www.shadertoy.com/view/4d2GzV\n// --------------------------------------------------------\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2hex = mat2(1, 0, i3, 2. * i3);\nconst mat2 hex2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nstruct TriPoints {\n\tvec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 center;\n    vec2 ab;\n    vec2 bc;\n    vec2 ca;\n};\n\nTriPoints closestTriPoints(vec2 p) {    \n    vec2 pTri = cart2hex * p;\n    vec2 pi = floor(pTri);\n    vec2 pf = fract(pTri);\n    \n    float split1 = step(pf.y, pf.x);\n    float split2 = step(pf.x, pf.y);\n    \n    vec2 a = vec2(split1, 1);\n    vec2 b = vec2(1, split2);\n    vec2 c = vec2(0, 0);\n\n    a += pi;\n    b += pi;\n    c += pi;\n\n    a = hex2cart * a;\n    b = hex2cart * b;\n    c = hex2cart * c;\n    \n    vec2 center = (a + b + c) / 3.;\n    \n\tvec2 ab = (a + b) / 2.;\n    vec2 bc = (b + c) / 2.;\n    vec2 ca = (c + a) / 2.;\n\n    return TriPoints(a, b, c, center, ab, bc, ca);\n}\n\n\n// --------------------------------------------------------\n// Geodesic tiling\n// --------------------------------------------------------\n\nstruct TriPoints3D {\n\tvec3 a;\n    vec3 b;\n    vec3 c;\n\tvec3 center;\n    vec3 ab;\n    vec3 bc;\n    vec3 ca;\n};\n\nvec3 intersection(vec3 n, vec3 planeNormal, float planeOffset) {\n    float denominator = dot(planeNormal, n);\n    float t = (dot(vec3(0), planeNormal ) + planeOffset) / -denominator;\n    return n * t;\n}\n\n//// Edge length of an icosahedron with an inscribed sphere of radius of 1\n//float edgeLength = 1. / ((sqrt(3.) / 12.) * (3. + sqrt(5.)));\n//// Inner radius of the icosahedron's face\n//float faceRadius = (1./6.) * sqrt(3.) * edgeLength;\nfloat faceRadius = 0.3819660112501051;\n\n// 2D coordinates on the icosahedron face\nvec2 icosahedronFaceCoordinates(vec3 p) {\n    vec3 pn = normalize(p);\n    vec3 i = intersection(pn, facePlane, -1.);\n    return vec2(dot(i, uPlane), dot(i, vPlane));\n}\n\n// Project 2D icosahedron face coordinates onto a sphere\nvec3 faceToSphere(vec2 facePoint) {\n\treturn normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));\n}\n\nTriPoints3D geodesicTriPoints(vec3 p, float subdivisions) {\n    // Get 2D cartesian coordiantes on that face\n    vec2 uv = icosahedronFaceCoordinates(p);\n    \n    // Get points on the nearest triangle tile\n\tfloat uvScale = subdivisions / faceRadius / 2.;\n    TriPoints points = closestTriPoints(uv * uvScale);\n    \n    // Project 2D triangle coordinates onto a sphere \n    vec3 a = faceToSphere(points.a / uvScale);\n    vec3 b = faceToSphere(points.b / uvScale);\n    vec3 c = faceToSphere(points.c / uvScale);\n    vec3 center = faceToSphere(points.center / uvScale);\n    vec3 ab = faceToSphere(points.ab / uvScale);\n    vec3 bc = faceToSphere(points.bc / uvScale);\n    vec3 ca = faceToSphere(points.ca / uvScale);\n    \n    return TriPoints3D(a, b, c, center, ab, bc, ca);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Model/Camera Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Animation \n// --------------------------------------------------------\n\nconst float SCENE_DURATION = 6.;\nconst float CROSSFADE_DURATION = 2.;\n\nfloat time;\n\nstruct HexSpec {\n    float roundTop;\n    float roundCorner;\n\tfloat height;\n    float thickness;\n    float gap;    \n};\n    \nHexSpec newHexSpec(float subdivisions) {\n\treturn HexSpec(\n        .05 / subdivisions,\n        .1 / subdivisions,\n        2.,\n        2.,\n        .005\n    );\n}\n    \n// Animation 1\n    \nfloat animSubdivisions1() {\n\treturn mix(2.4, 3.4, cos(time * PI) * .5 + .5);\n}\n\nHexSpec animHex1(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float offset = time * 3. * PI;\n    offset -= subdivisions;\n    float blend = dot(hexCenter, pca);\n    blend = cos(blend * 30. + offset) * .5 + .5;\n    spec.height = mix(1.75, 2., blend);\n\n    spec.thickness = spec.height;\n\n    return spec;\n}\n\n// Animation 2\n\nfloat animSubdivisions2() {\n    return mix(1., 2.3, sin(time * PI/2.) * .5 + .5);\n}\n\nHexSpec animHex2(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float blend = hexCenter.y;\n    spec.height = mix(1.6, 2., sin(blend * 10. + time * PI) * .5 + .5);\n    \n    spec.roundTop = .02 / subdivisions;\n    spec.roundCorner = .09 / subdivisions;\n    spec.thickness = spec.roundTop * 4.;\n    spec.gap = .01;\n\n    return spec;\n}\n\n// Animation 3\n\nfloat animSubdivisions3() {\n\treturn 5.;\n}\n\nHexSpec animHex3(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float blend = acos(dot(hexCenter, pab)) * 10.;\n    blend = cos(blend + time * PI) * .5 + .5;\n    spec.gap = mix(.01, .4, blend) / subdivisions;\n\n    spec.thickness = spec.roundTop * 2.;\n\n\treturn spec;\n}\n\n// Transition between animations\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat transitionValues(float a, float b, float c) {\n    #ifdef LOOP\n        #if LOOP == 1\n            return a;\n        #endif\n        #if LOOP == 2\n            return b;\n        #endif\n        #if LOOP == 3\n            return c;\n        #endif\n    #endif\n    float t = time / SCENE_DURATION;\n    float scene = floor(mod(t, 3.));\n    float blend = fract(t);\n    float delay = (SCENE_DURATION - CROSSFADE_DURATION) / SCENE_DURATION;\n    blend = max(blend - delay, 0.) / (1. - delay);\n    blend = sineInOut(blend);\n    float ab = mix(a, b, blend);\n    float bc = mix(b, c, blend);\n    float cd = mix(c, a, blend);\n    float result = mix(ab, bc, min(scene, 1.));\n    result = mix(result, cd, max(scene - 1., 0.));\n    return result;\n}\n \nHexSpec transitionHexSpecs(HexSpec a, HexSpec b, HexSpec c) {\n    float roundTop = transitionValues(a.roundTop, b.roundTop, c.roundTop);\n    float roundCorner = transitionValues(a.roundCorner, b.roundCorner, c.roundCorner);\n\tfloat height = transitionValues(a.height, b.height, c.height);\n    float thickness = transitionValues(a.thickness, b.thickness, c.thickness);\n    float gap = transitionValues(a.gap, b.gap, c.gap);\n\treturn HexSpec(roundTop, roundCorner, height, thickness, gap);\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nconst vec3 FACE_COLOR = vec3(.9,.9,1.);\nconst vec3 BACK_COLOR = vec3(.1,.1,.15);\nconst vec3 BACKGROUND_COLOR = vec3(.0, .005, .03);\n\nstruct Model {\n    float dist;\n    vec3 albedo;\n    float glow;\n};\n\nModel hexModel(\n    vec3 p,\n    vec3 hexCenter,\n    vec3 edgeA,\n    vec3 edgeB,\n    HexSpec spec\n) {\n    float d;\n\n    float edgeADist = dot(p, edgeA) + spec.gap;\n    float edgeBDist = dot(p, edgeB) - spec.gap;\n    float edgeDist = smax(edgeADist, -edgeBDist, spec.roundCorner);\n\n    float outerDist = length(p) - spec.height;\n    d = smax(edgeDist, outerDist, spec.roundTop);\n\n    float innerDist = length(p) - spec.height + spec.thickness;\n    d = smax(d, -innerDist, spec.roundTop);\n    \n    vec3 color;\n\n    float faceBlend = (spec.height - length(p)) / spec.thickness;\n    faceBlend = clamp(faceBlend, 0., 1.);\n    color = mix(FACE_COLOR, BACK_COLOR, step(.5, faceBlend));\n    \n    vec3 edgeColor = spectrum(dot(hexCenter, pca) * 5. + length(p) + .8);    \n\tfloat edgeBlend = smoothstep(-.04, -.005, edgeDist);\n    color = mix(color, edgeColor, edgeBlend); \n\n    return Model(d, color, edgeBlend);\n}\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n        return m1;\n    } else {\n        return m2;\n    }\n}\n\nModel geodesicModel(vec3 p) {\n\n    pModIcosahedron(p);\n    \n    float subdivisions = transitionValues(\n        animSubdivisions1(),\n        animSubdivisions2(),\n        animSubdivisions3()\n   \t);\n\tTriPoints3D points = geodesicTriPoints(p, subdivisions);\n        \n\tvec3 edgeAB = normalize(cross(points.center, points.ab));\n\tvec3 edgeBC = normalize(cross(points.center, points.bc));\n    vec3 edgeCA = normalize(cross(points.center, points.ca));\n    \n    Model model, part;\n    HexSpec spec;\n\n\tspec = transitionHexSpecs(\n        animHex1(points.b, subdivisions),\n        animHex2(points.b, subdivisions),\n        animHex3(points.b, subdivisions)\n    );\n    part = hexModel(p, points.b, edgeAB, edgeBC, spec);\n    model = part;\n\n\tspec = transitionHexSpecs(\n        animHex1(points.c, subdivisions),\n        animHex2(points.c, subdivisions),\n        animHex3(points.c, subdivisions)\n    );\n    part = hexModel(p, points.c, edgeBC, edgeCA, spec);\n    model = opU(model, part);\n    \n\tspec = transitionHexSpecs(\n        animHex1(points.a, subdivisions),\n        animHex2(points.a, subdivisions),\n        animHex3(points.a, subdivisions)\n    );\n    part = hexModel(p, points.a, edgeCA, edgeAB, spec);\n    model = opU(model, part);\n    \n\treturn model;\n}\n\nModel map( vec3 p ){\n    mat3 m = modelRotation();\n    p *= m;  \n    #ifndef LOOP\n    \tpR(p.xz, time * PI/16.);\n    #endif\n    Model model = geodesicModel(p);\n    return model;\n}\n\n// --------------------------------------------------------\n// LIGHTING\n// Adapted from IQ https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nvec3 doLighting(Model model, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = normalize(vec3(.5,.5,-1.));\n    vec3 backLightPos = normalize(vec3(-.5,-.3,1));\n    vec3 ambientPos = vec3(0,1,0);\n    \n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(.9);\n    lin += 0.80 * amb * vec3(.5, .7, .8);\n    lin += 0.30 * bac * vec3(.25);\n    lin += 0.20 * fre * vec3(1);\n    \n    vec3 albedo = model.albedo;\n    vec3 col = mix(albedo * lin, albedo, model.glow);    \n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 8.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n    \n    vec3 color = BACKGROUND_COLOR;\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    vec3 ref = reflect(hit.ray.direction, hit.normal);\n\n    #ifdef DEBUG\n        color = hit.normal * 0.5 + 0.5;\n    #else \n        color = doLighting(\n            hit.model,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\nvec3 render(Hit hit){\n    shadeSurface(hit);\n\treturn hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 5.5;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n\n    #ifdef LOOP\n        #if LOOP == 1\n            time = mod(time, 2.);   \n        #endif\n        #if LOOP == 2\n            time = mod(time, 4.);   \n        #endif\n        #if LOOP == 3\n            time = mod(time, 2.);\n    \t#endif\n    #endif\n    \n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    \n    #ifndef DEBUG\n        color = linearToScreen(color);\n    #endif\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 394, 394, 439], [441, 441, 503, 503, 627], [629, 629, 668, 668, 827], [1166, 1166, 1190, 1223, 1762], [1764, 1764, 1800, 1800, 1937], [2492, 2492, 2528, 2528, 3073], [3327, 3327, 3391, 3391, 3529], [3808, 3850, 3891, 3891, 4017], [4019, 4076, 4111, 4111, 4193], [4195, 4195, 4254, 4303, 4968], [5163, 5163, 5231, 5231, 5274], [5276, 5276, 5300, 5300, 5398], [5547, 5547, 5593, 5593, 5805], [5807, 5807, 5849, 5849, 6156], [6158, 6158, 6180, 6180, 6258], [6260, 6260, 6283, 6283, 6362], [6707, 6707, 6747, 6747, 6865], [6891, 6891, 6918, 6918, 6969], [6971, 6971, 7025, 7025, 7321], [7339, 7339, 7366, 7366, 7422], [7424, 7424, 7478, 7478, 7800], [7818, 7818, 7845, 7845, 7859], [7861, 7861, 7915, 7915, 8172], [8208, 8208, 8234, 8234, 8273], [8275, 8275, 8326, 8326, 9006], [9009, 9009, 9070, 9070, 9496], [9835, 9835, 9935, 9935, 10738], [10740, 10786, 10818, 10818, 10906], [10908, 10908, 10937, 10937, 12151], [12153, 12153, 12173, 12173, 12331], [12523, 12523, 12592, 12592, 13289], [13983, 13983, 14014, 14014, 14271], [14277, 14277, 14307, 14307, 15108], [15245, 15245, 15278, 15278, 15716], [15718, 15718, 15739, 15739, 15783], [15958, 15958, 16022, 16022, 16200], [16202, 16202, 16300, 16300, 16452], [16652, 16652, 16685, 16685, 16719], [16721, 16721, 16758, 16758, 16802], [16804, 16804, 16861, 16861, 17853]], "test": "valid"}
{"id": "llVXRW", "name": "Color Mixing", "author": "Heavybrush", "description": "just a function example of color mix", "tags": ["mix", "color"], "likes": 0, "viewed": 75, "published": "Public", "date": "1483376132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 magenta = vec3(1.0,0.0,1.0);\n    vec3 cyan = vec3(0.0,1.0,1.0);\n    \n    vec3 color = vec3(0.0);\n    color = mix(magenta,cyan,abs(sin(iTime)));\n    \n    float alpha = 1.0;\n    \n\tfragColor = vec4(color,alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 324]], "test": "valid"}
{"id": "llVXWD", "name": "Le trip", "author": "Jabberwock", "description": "PK ?", "tags": ["3d"], "likes": 0, "viewed": 77, "published": "Public", "date": "1484491995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  vec3 lightPos = vec3(5.0* sin(iTime), 5.0* sin(iTime), 5.0);\n  const vec3 lightColor = vec3(0.1, 0.1, 0.5);\n  const vec3 SpecColor = vec3(1.0, 1.0, 1.0);\n\n  // Color of the object comes from background !\n  vec3 c = 0.25*background(n);\n    \n  vec3 l = normalize(lightPos - p);\n  vec3 reflet = reflect(-l,n);\n    \n\n\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = dot(n, l);\n\n  c += diff*lightColor;\n  c+= SpecColor*reflet;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n // rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 255, 255, 354], [356, 423, 458, 458, 531], [557, 671, 717, 717, 754], [756, 847, 877, 877, 895], [897, 985, 1015, 1015, 1038], [1040, 1086, 1108, 1108, 1304], [1306, 1346, 1377, 1377, 1597], [1599, 1704, 1755, 1755, 2190], [2192, 2297, 2354, 2354, 2805], [2808, 2828, 2854, 2854, 2926], [2928, 2989, 3017, 3034, 3521], [3663, 3663, 3720, 3720, 4473]], "test": "valid"}
{"id": "llVXzW", "name": "Mandelbrots", "author": "Tryton", "description": "Just a different type of mandelbrot fractal.", "tags": ["mandelbrot"], "likes": 2, "viewed": 491, "published": "Public API", "date": "1483389595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 MandelBrot(vec2 p){\n        float time = iTime;\n    \n        float coa = cos( time );\n        float sia = sin( time );\n        vec2 xy = mat2(coa,sia,-sia,coa)*p;\n        vec2 c =  xy;\n    \n        vec2 z=vec2(0);\n        float l=0.0;\n\n    \tint sinTimeFrac = int((sin(time) + 1.0)*2.0);\n    \n        for(int i=0;i<256;i++){\n            \n            for(int j=0;j<sinTimeFrac;j++){\n                z = mat2(z, -z.y, z.x)*z;\n            }\n            \n            z = mat2(z,-z.y,z.x)*z + c;\n            \n            if( dot(z,z)>4.0 ) break;\n            l++;\n        }\n    \n    \tif( dot(z,z)<4.0 )l=sqrt(dot(xy,z))*4.0;\n    \tfloat sl = (log(dot(z,z)/l));\n\t\n        float al = smoothstep( 0.1, 0.4, (sin(iTime)+1.0)/2.0);\n        l = mix( l, sl, al );\n\n        vec3 col = vec3(l*0.2,0.0,0.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    fragColor = vec4(MandelBrot(p),0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 818], [820, 820, 877, 877, 985]], "test": "valid"}
{"id": "llyXDW", "name": "Apollonian III", "author": "stduhpf", "description": "A fork of: [url]https://www.shadertoy.com/view/llKXzh[/url]\nI was wondering how the trick in the distance function works, whent i thought\n\"Hey, but if i rotate p by 45Â° around the y axis, it will (probably) be still a distance function!\"\nIt was worth it.", "tags": ["raymarching", "fractal", "distancefield", "kleinian", "apollonian", "vr", "copypaste"], "likes": 12, "viewed": 447, "published": "Public", "date": "1484329457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//most of the code comes from:https://www.shadertoy.com/view/llKXzh\n//i copy pasted the code an added a modification i found interesting\n\n// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Antialiasing level. Make it 1 if you have a slow machine\n#define AA 1\n\n\nvec3 map( vec3 p )\n{\n\tfloat scale = 1.0;\n    \n    float orb = 10000.0;\n\n    for( int i=0; i<6; i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n        p -= sign(p)*0.1; //iq's trick (amplified)\n        \n        float a=float(i)*acos(-1.)/4.; //my trick\n        p.xz*=mat2(cos(a),sin(a),-sin(a),cos(a));\n\n        \n        float r2 = dot(p,p);\n\t\tfloat k = 0.95/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\n        orb = min( orb, r2);\n\t}\n\n    float d1 = sqrt( min( min( dot(p.xy,p.xy), dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.02;\n    float d2 = abs(p.y);\n    float dmi = d2;\n    float adr = 0.7*floor((0.5*p.y+0.5)*8.0);\n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/scale, adr, orb );\n}\n\nvec3 trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  info = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.001*t;\n        \n        vec3  r = map( ro+rd*t );\n\t    float h = r.x;\n        info = r.yz;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec3( t, info );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = forwardSF( float(i), 16.0 );\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n    }\n\tao /= 16.0;\n\t\n    return clamp( ao*16.0, 0.0, 1.0 );\n}\n\n\nvec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )\n{\n    vec3 w = nor*nor;\n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 res = trace( ro, rd );;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n        float occ = pow( clamp(res.z*2.0,0.0,1.0), 1.2 );\n              occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n        vec3  lin = vec3(1.0,1.0,1.5)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n        \n      \tcol = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0,1.0,2.0) );  \n        col *= textureBox( iChannel0, pos, nor ).xyz;\n        col = col*lin;\n        col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n        col *= exp(-0.3*t);\n    }\n    col.z += 0.01;\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.15 + 0.005*iMouse.x;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.5 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.82,1.3,-0.3), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyXDW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[339, 339, 359, 359, 1054], [1056, 1056, 1094, 1094, 1428], [1430, 1430, 1474, 1474, 1729], [1731, 1731, 1767, 1767, 2031], [2033, 2033, 2075, 2075, 2369], [2372, 2372, 2432, 2432, 2610], [2612, 2612, 2651, 2651, 3393], [4384, 4384, 4478, 4478, 4585]], "test": "error"}
{"id": "llyXWh", "name": "Scrolling Dashed Lines", "author": "cacheflowe", "description": "Scrolling lines with the help of noise()", "tags": ["lines", "scrolling"], "likes": 23, "viewed": 1188, "published": "Public API", "date": "1484089540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #define FADES  1\n\n// 2D Random\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.2;\t\t\t\t\t\t\t\t\t// adjust time\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    float rowThickness = uv.y * 20.;\t\t\t\t\t\t\t\t// break y lines up\n    float rowIndex = floor(rowThickness);\t\t\t\t\t\t\t// break y lines up & get current index\n    float lineProgress = rowThickness - rowIndex;\t\t\t\t\t// get line progress 0-1\n    float dashLength = noise(vec2(time + rowIndex * 4., 1.)); \t\t// each line gets a random dash length\n    uv *= vec2(dashLength * 7., 1.);\t\t\t\t\t\t\t\t// calc dash lengths by multiplying x\n    float timeAdd = (mod(rowIndex, 2.) == 0.) ? time : -time;\t\t// move x in different directions\n    timeAdd *= 5.1;\t\t\t\t\t\t\t\t\t\t\t\t\t// increase x movement\n    float xOffset = rowIndex / 3.;\t\t\t\t\t\t\t\t\t// give lines x offset so they don't line up\n    uv += vec2(timeAdd + dashLength + xOffset, 0.);\t\t\t\t\t// move x position\n    float col = 0.;\t\t\t\t\t\t\t\t\t\t\t\t\t// default black\n    if(fract(uv.x) > 0.5) {\t\t\t\t\t\t\t\t\t\t\t// dash    \n        col = ceil(0.15 - distance(0.5, lineProgress));\t\t\t\t// only draw middle portion of line\n    }\n    // fade in/out\n    #ifdef FADES\n        float loopSecs = 2.;\n        float fadeTime = 1.;\n        if(abs(mod(time, loopSecs)) < fadeTime * 2.) {\t\t\t\t// fade in/out for looping purposes\n            col = mix(0., col, abs(-fadeTime + mod(time, loopSecs)));\t\n        }\n    #endif\n\tfragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 34, 61, 61, 136], [138, 225, 251, 251, 586], [589, 589, 646, 646, 2033]], "test": "valid"}
{"id": "ltGSDw", "name": "test sand", "author": "XRNZ", "description": "sand", "tags": ["sand"], "likes": 1, "viewed": 90, "published": "Public", "date": "1484577727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 blue=vec3(0.05,0.35,0.65);\nconst vec3 deepblue=vec3(0.05,0.05,0.85);\nconst vec3 green=vec3(0.15,0.95,0.75);\nconst vec3 red=vec3(0.75,0.35,0.35);\nconst vec3 black=vec3(0.0,0.0,0.0);\nconst vec3 white=vec3(1.0,1.0,1.0);\nconst vec3 violet=vec3(0.35,0.35,0.65);\nconst vec3 yellow=vec3(0.75,0.65,0.35);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(blue,green,v);\n}\n\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(blue,green,t);\n}\n\nfloat scaledNoise(float i,vec3 p, vec3 n){\n\n    float t=turbulence (i*p,n);;\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    return t;\n\n}\n\n\n//SAND\nvec3 sand(in vec3 p,in vec3 n)\n{\n    \n    vec3 cc;\n    \n    // turbulences multiples\n    float t0=scaledNoise(192.0,p,n);\n    float t1=scaledNoise(197.0,rotate(p,61.0),n);\n    \n    float t2=scaledNoise(1.95,rotate(p,118.0),n);\n    float t3=scaledNoise(1.25,rotate(p,18.0),n);\n    float t4=scaledNoise(1.75,rotate(p,158.0),n);\n\n    \n    // sol\n    cc = 0.3*mix(black,0.5*yellow,t0)\n        +0.4*mix(0.5*yellow,white,t1)\n        +0.7*mix(white,yellow,t2);\n    \n    \n\n    // \"canyon\"\n    \n    if(t4>0.50 && t4<0.90){\n        \n    \tfloat mx = 0.15*(5.0*pow((0.20-abs(0.70-t4)),0.55));\n        \n        cc =mix(cc,0.8*yellow+0.2*white,mx);\n    }\n    \n    \n    if(t3>0.50 && t3<0.90){\n        \n    \tfloat mx = 0.25*(5.0*pow((0.20-abs(0.70-t3)),0.65));\n        \n        cc =mix(cc,0.5*yellow+0.5*red,mx);\n    }\n\n\n\n    return cc;\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n\nvec3 wood(in vec3 p, in vec3 n)\n{\n    vec3 c1 = vec3(139,69,19);\n    vec3 c2 = vec3(205,133,63);\n    \n    \n    float d = sqrt(p.y*p.y+p.x*p.x);\n    \n   \n    p.x = p.x-0.10*noise(2.78*p);\n    //p = p + 0.1*noise(p*fract(p.x/(p.y*noise(2.0*p))));\n    \n   \n    \n    float v=0.5+0.5*sin(100.0*p.x);\n    \n    float t=turbulence (5.7*p,n);\n    \n    //t=1.0-pow((1.0-t*t),1.5);\n    \n    //t=0.5+abs(t-0.5);\n  ;\n    v = v -0.0*t + 0.0*noise(152.0*p);\n    \n    //vec3 cc = mix(c2/255.0,c1/255.0,v-2.0*noise(100.0*p));\n    vec3 cc = mix(1.3*c2/255.0,0.9*c1/255.0,pow(fract(v),2.0));\n   \n    \n    return cc;\n    \n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n    \n        //vec3 r = normalize( 2.0*(dot(n,l))*n-l);\n      \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n \n    //float diff = 0.5*(1.0+dot(n, l));\n    \n    //float diff = dot(n, l);\n    \n    //float alpha = 12.550;\n    \n    //float diff = 0.5*(1.0+dot(n, l)) + 0.5*pow(dot(r,vec3(0.0,0.0,-1.0)),alpha);\n    \n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.0*background(n)+1.00*sand(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.3, t, n))\n    {\t\n        //fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n        fragColor = vec4(shade(o+d*t,n),1.0);\n    }\n    fragColor=Vignetting(fragColor,xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 158, 182, 182, 225], [227, 258, 284, 284, 653], [729, 782, 817, 817, 886], [1271, 1328, 1363, 1363, 1450], [1453, 1494, 1533, 1558, 1721], [1723, 1748, 1782, 1807, 1869], [1871, 1871, 1913, 1913, 2046], [2049, 2056, 2088, 2088, 2879], [2881, 2951, 2996, 2996, 3038], [3041, 3041, 3074, 3074, 3644], [3721, 3903, 3981, 3981, 4216], [4293, 4334, 4362, 4362, 4435], [4437, 4483, 4516, 4535, 5333], [5335, 5392, 5430, 5430, 5511], [5588, 5588, 5645, 5645, 6262]], "test": "valid"}
{"id": "ltGSWD", "name": "Wavy Background Effect", "author": "gigaherz", "description": "I was reminiscing of the background in the main menu of the Sony PSP...\n\nThis is not accurate, nor meant to be. It's only a proof of concept.", "tags": ["2d", "waves", "background", "playstation", "psp"], "likes": 31, "viewed": 953, "published": "Public", "date": "1484331561", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \nfloat gradient(float p)\n{\n    vec2 pt0 = vec2(0.00,0.0);\n    vec2 pt1 = vec2(0.86,0.1);\n    vec2 pt2 = vec2(0.955,0.40);\n    vec2 pt3 = vec2(0.99,1.0);\n    vec2 pt4 = vec2(1.00,0.0);\n    if (p < pt0.x) return pt0.y;\n    if (p < pt1.x) return mix(pt0.y, pt1.y, (p-pt0.x) / (pt1.x-pt0.x));\n    if (p < pt2.x) return mix(pt1.y, pt2.y, (p-pt1.x) / (pt2.x-pt1.x));\n    if (p < pt3.x) return mix(pt2.y, pt3.y, (p-pt2.x) / (pt3.x-pt2.x));\n    if (p < pt4.x) return mix(pt3.y, pt4.y, (p-pt3.x) / (pt4.x-pt3.x));\n    return pt4.y;\n}\n\nfloat waveN(vec2 uv, vec2 s12, vec2 t12, vec2 f12, vec2 h12)\n{\n    vec2 x12 = sin((iTime * s12 + t12 + uv.x) * f12) * h12;\n\n    float g = gradient(uv.y / (0.5 + x12.x + x12.y));\n    \n\treturn g * 0.27;\n}\n\nfloat wave1(vec2 uv)\n{\n    return waveN(vec2(uv.x,uv.y-0.25), vec2(0.03,0.06), vec2(0.00,0.02), vec2(8.0,3.7), vec2(0.06,0.05));\n}\n\nfloat wave2(vec2 uv)\n{\n    return waveN(vec2(uv.x,uv.y-0.25), vec2(0.04,0.07), vec2(0.16,-0.37), vec2(6.7,2.89), vec2(0.06,0.05));\n}\n\nfloat wave3(vec2 uv)\n{\n    return waveN(vec2(uv.x,0.75-uv.y), vec2(0.035,0.055), vec2(-0.09,0.27), vec2(7.4,2.51), vec2(0.06,0.05));\n}\n\nfloat wave4(vec2 uv)\n{\n    return waveN(vec2(uv.x,0.75-uv.y), vec2(0.032,0.09), vec2(0.08,-0.22), vec2(6.5,3.89), vec2(0.06,0.05));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float waves = wave1(uv) + wave2(uv) + wave3(uv) + wave4(uv);\n    \n\tfloat x = uv.x;\n\tfloat y = 1.0 - uv.y;\n    \n    vec3 bg = mix(vec3(0.05,0.05,0.3),vec3(0.1,0.65,0.85), (x+y)*0.55);\n    vec3 ac = bg + vec3(1.0,1.0,1.0) * waves;\n\n    fragColor = vec4(ac, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 27, 27, 525], [527, 527, 589, 589, 729], [731, 731, 753, 753, 861], [863, 863, 885, 885, 995], [997, 997, 1019, 1019, 1131], [1133, 1133, 1155, 1155, 1266], [1268, 1268, 1325, 1325, 1642]], "test": "valid"}
{"id": "ltGSWz", "name": "Menger Sponge Distort-hhhzzzsss", "author": "hhhzzzsss", "description": "This is a simple Menger Sponge, rendered with raymarching. This is based on iq's article about iterative fractals: http://www.iquilezles.org/www/articles/menger/menger.htm", "tags": ["3d", "raymarching", "fractal", "menger", "sponge", "mengersponge"], "likes": 6, "viewed": 207, "published": "Public", "date": "1483819128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define distfar 6.0\n#define iterations 5.0\n\nfloat maxcomp(vec3 p) {\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdBox2D(vec2 p, vec2 b) {\n\tvec2  di = abs(p) - b;\n    float mc = max(di.x,di.y);\n    return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox2D(p.xy,vec2(1.0));\n  float db = sdBox2D(p.yz,vec2(1.0));\n  float dc = sdBox2D(p.zx,vec2(1.0));\n  return min(da,min(db,dc));\n}\n\nvec2 map(vec3 p) {\n    float d = sdBox(p,vec3(1.0));\n    \n    for (float i = 0.0; i < iterations; i++) {\n\n        float scale = pow(3.0,i);\n        vec3 q = mod(scale*p,2.0)-1.0;\n        q = 1.0-abs(q);\n        float c = sdCross(q*3.0)/(scale*3.0);\n        d = max(d,-c),1.0;\n        \n        p += scale/3.0;\n\t\t\n    }\n    \n    return vec2(d,1.0);\n    \n}\n\nvec3 calcnormal(vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return  normalize(n);\n}\n\nfloat softshadow (vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.001;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>distfar) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return 0.0;\n        res = min(res, 64.0*h.x/t);\n        t += h.x;\n    }\n    return res;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t > distfar) break;\n        vec2 d = map(ro + rd*t);\n        if (d.x < 0.0001) return vec3(t, d.y, i);\n        t += d.x;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,3.0);\n    vec3 rd = normalize(vec3(uv,-1.5));\n    \n    float theta = sin(iTime/2.0);\n    mat2 rot = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    ro.yz *= rot;\n    rd.yz *= rot;\n    theta = iTime/3.0;\n    rot = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    ro.xz *= rot;\n    rd.xz *= rot;\n    \n    vec3 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.8);\n    \n    if (t.y > 0.5) {\n        \n        vec3 pos = ro + rd*t.x;\n        vec3 lig = normalize(vec3(0.6,1.0,0.8));\n        vec3 nor = calcnormal(pos);\n        float refRange = 0.2;\n        \n        float occ = 1.0/(1.0+t.z/15.0);\n        float sha = softshadow(pos, lig);\n        float dif = max(0.0, dot(nor,lig));\n        float sky = 0.5+0.5*nor.y;\n        float ind = max(0.0, dot(nor,vec3(-1.0,-0.2,-1.0)*lig));\n        float ref = max(1.0-refRange,dot(-nor,rd))-1.0+refRange;\n        \n        col = vec3(0.8,1.0,1.2)*dif*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        col += vec3(0.2,0.3,0.4)*ind*occ;\n        col += vec3(0.2,0.2,0.3)*sky*occ;\n        col += pow(ref,2.0)*4.0*occ;\n        \n        col = pow(col,vec3(0.4545));\n        \n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 67, 67, 103], [105, 105, 136, 136, 227], [229, 229, 260, 260, 357], [359, 359, 387, 387, 532], [534, 534, 552, 552, 887], [889, 889, 914, 914, 1115], [1117, 1117, 1154, 1154, 1418], [1420, 1420, 1450, 1450, 1675], [1677, 1677, 1734, 1734, 3012]], "test": "valid"}
{"id": "ltGSzG", "name": "Unit square of norms", "author": "klacansky", "description": "Renders norm starting at 0 and ending at \"infinity\".", "tags": ["norm", "unitsquare"], "likes": 3, "viewed": 149, "published": "Public", "date": "1484764170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n\nconst float eps = 0.001;\n\n\nfloat norm(vec4 a, float l)\n{\n    vec4 p = abs(a);\n    return pow(pow(p.x, l) + pow(p.y, l) + pow(p.z, l), 1.0/l) - 1.0;\n}\n\n\n// central differenced normal\nvec4 normal(vec4 p, mat4 v, float l)\n{\n    vec4 e = vec4(eps, 0.0, 0.0, 0.0);\n    return normalize(vec4(norm(p + v*e, l) - norm(p - v*e, l),\n                \t \t  norm(p + v*e.yxyy, l) - norm(p - v*e.yxyy, l),\n                \t \t  norm(p + v*e.yyxy, l) - norm(p - v*e.yyxy, l), 0.0));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 o = vec4(2.0*uv - 1.0, 1.0, 1.0);\n    o.x *= iResolution.x/iResolution.y;\n    \n    vec4 d = vec4(0.0, 0.0, -1.0, 0.0);\n    \n    float s = sin((iTime/10.0)*5.0);\n    float c = cos((iTime/10.0)*5.0);\n    mat4 view = mat4(c, s, 0, 0.0,\n                     -s, c, 0.0, 0.0,\n                     0, 0.0, 1, 0.0,\n                     0.0, 0.0, 0.0, 1.0);\n    mat4 model = mat4(1.0, 0.0, 0.0, 0.0,\n                     0.0, 1.0, 0.0, 0.0,\n                     0.0, 0.0, 1.0, 0.0,\n                     0, 0.0, 0.0, 1.0);\n    \n    vec4 l = normalize(vec4(0.3, 0.1, 1.0, 0.0));\n    \n    o = view*model*2.0*o;\n    d = view*model*d;\n \n    fragColor = vec4(0.0);\n    float current_norm = iTime/2.0;\n \n    // ray march\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec4 p = (o + t*d);\n\t\tfloat tmp = norm(p, current_norm);\n        if (abs(tmp) < eps) {            \n            fragColor = max(dot(normal(p, view*model, current_norm), l), 0.0) * vec4(1.0);\n            return;\n        }\n        t += tmp;                \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGSzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 81, 81, 174], [177, 207, 245, 245, 492], [495, 495, 550, 550, 1633]], "test": "valid"}
{"id": "ltGXDm", "name": "Shader Sand", "author": "Valou", "description": "Shader Sand", "tags": ["sand"], "likes": 1, "viewed": 74, "published": "Public", "date": "1484577681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SABLE  ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 white=vec3(1.0,0.95,0.75);\nconst vec3 black=vec3(0.80,0.80,0.50);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(black,white,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(black,white,t);\n}\n\n// Sable\n// p : Point\n// n : Normal\nvec3 sable(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise (200.0*p);\n    return mix(black,white,t);\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*sable(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 157, 181, 181, 224], [226, 257, 283, 283, 652], [728, 781, 816, 816, 885], [1039, 1096, 1131, 1131, 1219], [1221, 1262, 1301, 1326, 1364], [1366, 1391, 1425, 1450, 1513], [1515, 1551, 1584, 1609, 1671], [1673, 1743, 1788, 1788, 1830], [1907, 2089, 2167, 2167, 2402], [2479, 2520, 2548, 2548, 2621], [2623, 2669, 2702, 2721, 3173], [3175, 3232, 3270, 3270, 3351], [3428, 3428, 3485, 3485, 4054]], "test": "valid"}
{"id": "ltGXW1", "name": "CPT raytraced box shadow", "author": "zproxy", "description": "https://www.shadertoy.com/view/XtGXDh", "tags": ["shadow"], "likes": 2, "viewed": 149, "published": "Public", "date": "1484130264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BMIN vec3(1.0)\n#define BMAX vec3(2.0,5.0,2.0)\n#define GROUND vec4(0.0,1.0,0.0,-1.0)\n\nbool collidePlane(vec3 P,vec3 V,vec4 plane, out float t) {    \n    float NPd=dot(plane.xyz,P)+plane.w;\n    float NV=dot(plane.xyz,V);\n    t=-NPd/NV;\n    return (NPd>0.0 && NV<0.0); //P not below/on or V not parallel/away\n}\n\nbool collideBox(vec3 P,vec3 V,vec3 bMin,vec3 bMax, out float t) {\n\t//from gamedev.net/topic/682750-problem-with-raybox-intersection-in-glsl/#entry5313405\n\t//from gamedev.net/resources/_/technical/math-and-physics/intersection-math-algorithms-learn-to-derive-r3033\n\t//from tavianator.com/fast-branchless-raybounding-box-intersections-part-2-nans\n\n\tvec3 invRay=1.0/V;\n\tvec3 tmin = (bMin - P) * invRay;\n\tvec3 tmax = (bMax - P) * invRay;\n\tvec3 tnear = min(tmin, tmax);\n\tvec3 tfar = max(tmin, tmax);\n\tfloat enter = max(tnear.x, max(tnear.y, tnear.z)); //max(tnear.x, 0.0)\n\tfloat exit = min(tfar.x, min(tfar.y, tfar.z));\n\tt=enter;\n\treturn exit > max(enter, 0.0); //exit>0.0 && enter<exit\n}\n\nvec3 boxNormal(vec3 bMin,vec3 bMax, vec3 colPt) {\n\t//checks the colPt against a plane for each face\n\t\n\tvec3 pMin=abs(colPt-bMin);\n\tvec3 pMax=abs(colPt-bMax);\n \n\tfloat eps=0.00001;\n\n  \tif(pMax.x<eps) {return vec3(1.0,0.0,0.0);} \n  \telse if(pMin.x<eps) {return vec3(-1.0,0.0,0.0);}\n  \telse if(pMax.y<eps) {return vec3(0.0,1.0,0.0);} \n  \telse if(pMin.y<eps) {return vec3(0.0,-1.0,0.0);}\n  \telse if(pMax.z<eps) {return vec3(0.0,0.0,1.0);} \n  \telse if(pMin.z<eps) {return vec3(0.0,0.0,-1.0);} \n  \telse {return vec3(0.0);}\n    \n    //alternative\n\t//vec3 n=vec3(0.0);\n\t//n-=vec3(pMin.x<eps?1.0:0.0,pMin.y<eps?1.0:0.0,pMin.z<eps?1.0:0.0);\n\t//n+=vec3(pMax.x<eps?1.0:0.0,pMax.y<eps?1.0:0.0,pMax.z<eps?1.0:0.0);\n\t//return normalize(n);\n\n}\n/*\nvec3 boxNormal(vec3 bMin,vec3 bMax, vec3 colPt) {\n\t//from blog.johnnovak.net/2016/10/22/the-nim-raytracer-project-part-4-calculating-box-normals\n\t//vec3 c = (bMin + bMax) * 0.5;\n\tvec3 p = colPt; //- c;\n\tvec3 d = (bMin - bMax) * 0.5;\n\tfloat bias = 1.0;//00001;\n\tvec3 q=p/abs(d)* bias;\n\t//q=floor(q);\n\treturn normalize(q);\n}*/\n\nvec3 calcPtLightCol(vec3 pos, vec3 nor, vec3 lightPos,vec3 lightAtten,\n\t\t\t\t\tvec3 lightCol,vec3 mtrlCol,float shininess,\n\t\t\t\t\tfloat strength) {\n\tvec3 lightDir=lightPos.xyz-pos;\n\tfloat lightDist=length(lightDir);\n\tlightDir=lightDir/lightDist;\n\n\t//\n\tfloat a = 1.0/(lightAtten.x+lightAtten.y*lightDist+lightAtten.z*lightDist*lightDist);\n\n\tvec3 reflectVec=reflect(-lightDir,nor);\n\tfloat NdotL = max(0.0,dot(nor,lightDir));\n\tfloat spec=0.0;\n\n\tif(NdotL > 0.0) {\n\t\tfloat NdotR = max(0.0, dot(nor, reflectVec));\n\t\tspec = pow(NdotR, shininess*128.0) * strength*a;\n\t}\n\n\tfloat diffuse=NdotL*a;\n\treturn lightCol*(mtrlCol*diffuse+spec);\n}\n\nfloat calcFlare(vec3 ro,vec3 rd,vec3 lightPos,float size) {\n\tvec3 viewLightDir=normalize(lightPos-ro);\n\tfloat viewLightDist=length(lightPos-ro);\n\tfloat q = dot(rd,viewLightDir)*0.5+0.5;\n\tfloat o = (1.0/viewLightDist)*size;\n\treturn clamp(pow(q,900.0/o)*1.0,0.0,2.0);\n}\n\nbool collideScene(vec3 ro,vec3 rd,out vec3 colPt, out vec3 nor) {\n\tfloat t=9999999.0,t2;\n\tbool hit=false;\n\n\tvec3 bMin=BMIN;\n\tvec3 bMax=BMAX;\n\tvec4 plane=GROUND;\n    \n\tif(collidePlane(ro,rd,plane,t2) && t2 < t) {\n\t\tt=t2;\n\t\tcolPt=ro+rd*t;\n\t\tnor=plane.xyz;\n\t\thit=true;\n\t} \n\t\n\tif(collideBox(ro,rd,bMin,bMax, t2) && t2 < t) {\n\t\tt=t2;\n\t\tcolPt=ro+rd*t;\n\t\tnor=boxNormal(bMin,bMax,colPt);\n\t\thit=true;\n\t}\n\t\n\treturn hit;\n}\n\nbool collideSceneP(vec3 ro,vec3 rd,out float t) {\n\tt=9999999.0;\n\tfloat t2;\n\tbool hit=false;\n\n\tvec3 bMin=BMIN;\n\tvec3 bMax=BMAX;\n\tvec4 plane=GROUND;\n\t\n\tif(collidePlane(ro,rd,plane,t2) && t2 < t) {\n\t\tt=t2;\n\t\thit=true;\n\t} \n\t\n\tif(collideBox(ro,rd,bMin,bMax, t2) && t2 < t) {\n\t\tt=t2;\n\t\thit=true;\n\t}\n\t\n\treturn hit;\n}\n\nvec3 checkerCol(vec3 texc, vec3 color0, vec3 color1) {\n    float q=clamp(mod(dot(floor(texc),vec3(1.0)),2.0),0.0,1.0);\n    return color1*q+color0*(1.0-q);\n}\n// https://www.shadertoy.com/view/XtGXDh\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 lightCol=vec3(2.0,1.9,0.8);\n\tvec3 lightAtten=vec3(0.6,0.01,0.001);\n\tvec3 lightPos=vec3(\n        cos(-iTime*0.6)*33.0 - 19.,\n        9.0 + sin(-iTime*0.6)*8.,\n        sin(-iTime*0.6)*33.0 - 19.\n    );\n\n\tvec3 col=vec3(0.0);\n\tvec3 pt,nor;\n\tbool hasHit=false;\n\t\n\tif(collideScene(ro,rd, pt,nor)) {\n\t\tvec3 matCol=checkerCol(pt*0.5,vec3(0.5),vec3(0.8));\n\t\tfloat tt,shd=1.0;\n        shd=(collideSceneP(lightPos,normalize(pt-lightPos),tt) && tt<length(pt-lightPos)-0.0001)?0.01:1.0;\n        vec3 light=calcPtLightCol(pt,nor,lightPos,lightAtten,lightCol,matCol,1.0,0.2);\n        vec3 amb=clamp(light,0.0,0.05)*matCol;\n\t\tcol+=light*shd+amb;\n\t\thasHit=true;\n\t}\n\n\n\tif(!hasHit || length(ro-lightPos)<length(ro-pt)) {\n\t\tcol=mix(col,lightCol*1.5,calcFlare(ro,rd,lightPos,0.15));\n\t}\n\t\n\treturn vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n\tfloat d=1.0/tan(fovy/2.0);\n\tvec3 v=vec3(screen.x*aspect,screen.y,-d);\n\tv=normalize(v);\n\treturn v;\n}\n\nmat3 orbitViewRot(float yaw,float pitch) {\n\tvec2 s=vec2(sin(pitch),sin(yaw));\n\tvec2 c=vec2(cos(pitch),cos(yaw));\n\treturn mat3(c.y,0.0,-s.y, s.y*s.x,c.x,c.y*s.x, s.y*c.x,-s.x,c.y*c.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat fovy=0.7854;\n\tfloat aspect=iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec2 scr = uv*2.0-1.0;\n\tvec2 ms = iMouse.xy / iResolution.xy;\n\tvec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.5,0.5):ms;\n\n\tfloat pitch=(ms2.y-0.5)*5.0-0.7;\n\tfloat yaw=(ms2.x-0.5)*5.0;\n\n\tmat3 viewRot=orbitViewRot(yaw,pitch);\n\n\tvec3 ro=viewRot*vec3(0.0,2.0,25.0);\n\tvec3 rd=normalize(viewRot*calcPrimaryRay(scr,fovy,aspect));\n\n\tvec3 col=render(ro,rd);\n\n\tif(length((uv-ms)*vec2(aspect,1.0)) < 0.01) {\n\t\tcol=mix(col,vec3(1.0),0.2);\n\t}\n\n\tfragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 151, 151, 315], [317, 317, 382, 661, 1000], [1002, 1002, 1051, 1101, 1729], [2059, 2059, 2201, 2201, 2683], [2685, 2685, 2744, 2744, 2952], [2954, 2954, 3019, 3019, 3365], [3367, 3367, 3416, 3416, 3676], [3678, 3678, 3732, 3732, 3834], [3835, 3876, 3907, 3907, 4716], [4718, 4718, 4776, 4776, 4877], [4879, 4879, 4921, 4921, 5064], [5066, 5066, 5123, 5123, 5679]], "test": "valid"}
{"id": "ltKSWD", "name": "Fourier - approximation", "author": "iq", "description": "Approximating a 50 point shape by 1, 2, 3, ..., 50 Fourier coefficients. The last coefficients are pretty small and therefore can be stored in very few bits or simply discarded, achieving data compression similar to JPG or MPG", "tags": ["2d", "approximation", "compression", "fourier", "dft"], "likes": 63, "viewed": 5004, "published": "Public API", "date": "1484542461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Approximating a 50 point shape by 1, 2, 3, ..., 50 Fourier coefficients, great for\n// shape compression. The last coefficients are pretty small and therefore they can be \n// stored in very few bits (or completely discarded as in this example)\n//\n// Some related info: http://www.iquilezles.org/www/articles/fourier/fourier.htm\n\n\nfloat hash( float n ) \n{\n    return fract( n*63.0*fract( n*0.3183099 ) );\n}\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  d = pa - ba*h;\n\treturn dot(d,d);\n}\n\nfloat sdPointSq( in vec2 p, in vec2 a )\n{\n    vec2 d = p - a;\n\treturn dot(d,d);\n}\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\n//=================================================================================================\n// digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n//=================================================================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 2.0/iResolution.y;\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\n\n    vec3 col = vec3(1.0);\n\n    vec2 path[50];\n    \n    //------------------------------------------------------\n    // generate a path of 50 random points\n    //------------------------------------------------------\n    {\n        vec2 d = vec2(1000.0);\n        vec2 q = vec2(0.25,0.7);\n        path[0] = q;\n        float dir = 0.0;\n        for( int i=1; i<50; i++ )\n        {\n            float h = float(i)/50.0;\n            dir += 1.7*(-1.0+2.0*hash(float(i)));\n            q += 0.16*vec2( cos(dir), sin(dir) );\n            q = mix( q, path[0], pow(h,16.0) );\n            path[i] = q;\n        }\n    }\n\n    //------------------------------------------------------\n    // draw path\n    //------------------------------------------------------\n    {\n        vec2 d = vec2(1000.0);\n        for( int i=0; i<49; i++ )\n        {\n            vec2 a = path[i+0];\n            vec2 b = path[i+1];\n            d = min( d, vec2(sdSegmentSq( p,a,b ), sdPointSq(p,a) ) );\n        }\n        d = sqrt( min( d, vec2(sdSegmentSq( p, path[49], path[0] ), sdPointSq(p,path[49]) ) ) );\n\n        col = mix( col, vec3(0.7,0.7,0.7), 1.0-smoothstep(0.0,1.0*e,d.x) );\n        col = mix( col, vec3(0.9,0.2,0.0), 1.0-smoothstep(5.0*e,6.0*e,d.y) );\n    }\n\n    //------------------------------------------------------\n    // compute fourier transform of the path\n    //------------------------------------------------------\n\n\n    vec2 fcs[50];\n    for( int k=0; k<50; k++ )\n    {\n        vec2 fc = vec2(0.0);\n        for( int i=0; i<50; i++ )\n        {\n            float an = -6.283185*float(k)*float(i)/50.0;\n            fc += cmul(path[i],vec2(cos(an),sin(an)));\n        }\n        fcs[k] = fc;\n    }\n\n    //------------------------------------------------------\n    // inverse transform using only n<=25 coefficients\n    //------------------------------------------------------\n    float n = min(mod(2.0*iTime,30.0),25.0);\n    float ni = floor(n);\n    float nf = fract(n);\n    n = ni + smoothstep(0.0,1.0,nf);\n    \n    {\n    float d = 1000.0;\n    vec2 oq, fq;\n    for( int i=0; i<50; i++ )\n    {\n        vec2 q = vec2(0.0);\n        for( int k=0; k<25; k++ )\n        {\n            float w = clamp( n-float(k), 0.0, 1.0 );\n            \n            float w1 = 6.283185*float(k)*float(i)/50.0;\n            q += w*cmul( fcs[k], vec2( cos(w1), sin(w1) ) )/50.0;\n            \n            float w2 = 6.283185*float(49-k)*float(i)/50.0;\n            q += w*cmul( fcs[49-k], vec2( cos(w2), sin(w2) ) )/50.0;\n        }\n\n        if( i==0 ) fq=q; else d = min( d, sdSegmentSq( p, q, oq ) );\n        oq = q;\n    }\n    d = sqrt( min( d, sdSegmentSq( p, oq, fq ) ) );\n\n    col = mix( col, vec3(0.1,0.1,0.2), 1.0-smoothstep(0.0*e,2.0*e,d) );\n    col *= 0.75 + 0.25*smoothstep( 0.0, 0.3, sqrt(d) );\n\n    }\n\n    //------------------------------------------------------\n    // print number of coefficients and vignette\n    //------------------------------------------------------\n\tcol *= 1.0 - PrintInt( (p-vec2(0.85,0.6))*4.0, 2.0*n );\n    col *= 1.0 - 0.15*length(p);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKSWD.jpg", "access": "shaders20k", "license": "mit", "functions": [[1412, 1412, 1436, 1436, 1487], [1489, 1489, 1543, 1543, 1667], [1669, 1669, 1710, 1710, 1750], [1752, 1752, 1782, 1782, 1837], [3164, 3164, 3210, 3210, 3526], [3629, 3629, 3686, 3686, 6835]], "test": "error"}
{"id": "ltKSzD", "name": "Checkerboard Stairs Zoom", "author": "cacheflowe", "description": "A simple checkboard test. Changing black & white to gradients really transformed the look on this one. I'm learning the basics, slowly.", "tags": ["zoom", "blackandwhite", "checkerboard"], "likes": 7, "viewed": 660, "published": "Public API", "date": "1483426772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\t // center coordinates\n    float time = iTime * 2.;\t\t\t\t\t  \t\t\t\t // adjust time\n    float dist = length(uv) * 5.0;\t\t\t\t\t\t\t\t\t // adjust distance from center\n    float cellSizeAdjust = dist/2. + dist * sin(PI + time);\t\t     // adjust cell size from center\n    float zoom = 4. * sin(time);\t\t\t\t\t\t\t\t\t // oscillate zoom\n    uv *= 7. + cellSizeAdjust + zoom;                                // zoom out\n\tvec3 col = vec3(1. - fract(uv.y)); \t\t\t\t\t\t\t     // default fade to black\n    if(floor(mod(uv.x, 2.)) == floor(mod(uv.y, 2.))) {\t\t\t\t // make checkerboard when cell indices are both even or both odd\n        col = vec3(fract(uv.x)); \t\t\t\t\t\t\t\t\t // use fract() to make the gradient along x & y\n\t}\n    col = smoothstep(0.3,0.7, col);\t\t\t\t\t\t\t\t\t // smooth out the color\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 116, 116, 963]], "test": "valid"}
{"id": "ltKXDG", "name": "A shit with an old video face", "author": "Gonzague", "description": "Its, a shit, with actually, an old retro style video, talking about shampoo, as a face.\nThis shit is a bit more nervous than the britney spears one.", "tags": ["shitvideoface"], "likes": 3, "viewed": 853, "published": "Public API", "date": "1485799880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AA 1\n\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdEllipsoid( in vec2 p, in vec2 c, in vec2 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(r.x,r.y);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 udSegment( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n    vec3 w = normalize( cross( c-b, a-b ) );\n    vec3 u = normalize( c-b );\n    vec3 v = normalize( cross( w, u ) );\n\n    vec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n    vec2 b2 = vec2( 0.0 );\n    vec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n    vec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n    vec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n    return vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec4( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.yzw, a.yzw, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    vec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n//---------------------------------------------------------------------------\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(n+vec3(0.0,13.1,31.3))*158.5453123);\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//---------------------------------------------------------------------------\n\nconst float pi = 3.1415927;\n\nfloat mapShell( in vec3 p, out vec4 matInfo ) \n{\n    \n    const float sc = 1.0/1.0;\n    p -= vec3(0.05,0.12,-0.09);    \n\n    p *= sc;\n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    float n = (log(r)/b - t)/(2.0*pi);\n\n    const float th = 0.11;\n    float nm = (log(th)/b-t)/(2.0*pi);\n\n    n = min(n,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + 2.0*pi*ni));\n    float r2 = r1 * 3.019863;\n    \n    //-------\n\n    float h1 = q.z + 1.5*r1 - 0.5;\n    float d1 = sqrt( (r1-r)*(r1-r) + h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5;\n    float d2 = sqrt( (r2-r)*(r2-r) + h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n\n\n    float di = texture( iChannel2, vec2(t+r,0.5) ).x;\n    d += 0.002*di;\n    \n    matInfo = vec4(dx,dy,r/0.4,t/3.14159);\n\n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d/sc;\n}\n\nvec3 opTwist( vec3 p, float k )\n{\n    float cx = -0.1;\n    p.x -= cx;\n    float  c = cos(k);\n    float  s = sin(k);\n    mat2   m = mat2(c,-s,s,c);\n    vec2   q = m*p.xz;\n    return vec3(q.x+cx,p.y,q.y);\n}\n\nvec2 snail( vec3 p, out vec4 matInfo )\n{\n    vec3 head = vec3(-0.05,1.8,-0.3);\n    \n    vec3 q = p;\n\n    // body\n    vec4 b1 = sdBezier( vec3(-0.15,-0.65,0.0), vec3(-0.1,0.9+0.1,0.0), head+vec3(1,0.01,0.0), p );\n    float d1 = b1.x;\n    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));\n    float d2 = sdSphere( q, vec4(0.0,-0.3,0.0,0.085) );\n   d1 = smin( d1, d2, 0.03 );\n\n    b1 = sdBezier( vec3(-0.85,0.0,0.0), vec3(-0.6,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );\n    d2 = b1.x;\n    d2 -= 0.1 - 0.06*b1.y;\n    //d1 = smin( d1, d2, 0.03 );\n    matInfo.xyz = b1.yzw;\n    \n    //d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );\n    \n    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;\n\n    vec3 sq = vec3( q.xy, abs(q.z) );\n    \n    // top antenas\n    vec3 af = 0.05*sin(12.9*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );\n    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );\n    float d3 = b2.x;\n    d3 -= 0.03 - 0.025*b2.y;\n    d1 = smin( d1, d3, 0.04 );\n//d3 = sdEllipsoid( sq, vec3(-0.3,0.2,0.3),  vec3(af) );\n     //d3 = smin( d3, sdEllipsoid( sq,vec3(-0.3,0.2,0.3), vec3(af) ), 0.05 );\n    //d3 = smax( d3, -sdEllipsoid( sq, vec3(-0.3,0.2,0.3), vec3(af) ), 0.02 );\n    //d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.016) + vec4(af,0.0) );\n\t\n    d1 = smin( d1, d3, 0.01 );    \n    \n    // bottom antenas\n    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );\n    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.2,0.18)+bf );\n    d3 = b3.x;\n    d3 -= 0.025 - 0.02*b3.y;\n    d1 = smin( d1, d3, 0.06 );\n    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );\n    d1 = smin( d1, d3, 0.02 );\n    \n    // bottom\n    vec3 pp = p-vec3(-0.17,0.15,0.0);\n    float angle = 8.6;\n    angle = (angle / 180.0) * 3.14;\n    float co = 0.988771078;\n    float si = 0.149438132;\n    co = cos(angle);\n    si = sin(angle);\n    pp.xy = mat2(co,-si,si,co)*pp.xy;\n    //d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );\n    //d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );\n    \n    // disp\n    float dis = texture( iChannel1, 1.0*p.xy ).x * 1.3;\n    float dx = 3.5 + 12.0*(1.0-smoothstep(0.5,1.0,b1.y / 3.5));\n    d1 -= 0.005*dis*dx*0.5;\n        \n    return vec2(d1,1.0);\n}\n    \nfloat mapDrop( in vec3 p )\n{\n    p -= vec3(-0.26,0.25,-0.02);\n    p.x -= 2.5*p.y*p.y;\n    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );\n}\n\nfloat mapLeaf( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    \n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n \n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    \n    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);// + 1.0*sin(5.0*p.x)*sin(5.0*p.z);\n    float rr = sin( ph );\n    rr = rr*rr;    \n    rr = rr*rr;    \n    p.y += 0.005*rr;\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;\n    \n    rr = sin( ph*2.0 );\n    rr = rr*rr;    \n    rr *= 0.5+0.5*sin( p.x*12.0 );\n\n    float ri = 0.035*rr;\n    \n    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );\n\n    float d2 = p.y-0.02;\n    d = smax( d, -d2, 0.02 );\n    \n    return d;\n}\n\nvec2 mapOpaque( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    //--------------\n    vec2 res = snail( p, matInfo );\n   \n     \n    //---------------\n    vec4 tmpMatInfo;\n    float d4 = mapShell( p, tmpMatInfo );    \n    //if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }\n    //res = vec2(d4, 2.0);\n    //---------------\n    \n    // plant\n    //vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );\n    //d4 = b3.x;\n    //d4 -= 0.04 - 0.02*b3.y;\n    //if( d4<res.x  ) { res = vec2(d4,3.0); }\n    \n    //----------------------------\n    \n    float d5 = mapLeaf( p );\n    if( d5<res.x ) res = vec2(d5,4.0);\n        \n    return res;\n}\n\nvec3 calcNormalOpaque( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + \n                      e.yyx*mapOpaque( pos + e.yyx, kk ).x + \n                      e.yxy*mapOpaque( pos + e.yxy, kk ).x + \n                      e.xxx*mapOpaque( pos + e.xxx, kk ).x );\n}\n\n//=========================================================================\n\nfloat mapLeafWaterDrops( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    vec3 s = p;\n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n  \n    vec3 q = p;\n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    //---------------\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = r*(1.0-r)*(1.0-r)*6.0;\n    float d0 = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r) );\n    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );\n    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );\n    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );\n    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );\n\n    d3 = max( d3, p.y-0.01);\n    \n    float d = min( min(d1,d4), min(d2,d3) );\n    \n    return d;\n}\n\nvec2 mapTransparent( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    float d5 = mapDrop( p );\n    vec2  res = vec2(d5,4.0);\n\n    float d6 = mapLeafWaterDrops( p );\n    res.x = min( res.x, d6 );\n\n    return res;\n}\n\nvec3 calcNormalTransparent( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + \n                      e.yyx*mapTransparent( pos + e.yyx, kk ).x + \n                      e.yxy*mapTransparent( pos + e.yxy, kk ).x + \n                      e.xxx*mapTransparent( pos + e.xxx, kk ).x );\n}\n\n//=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n    float ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash1(float(i));\n        ap *= sign( dot(ap,nor) ) * h*0.1;\n        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n    ao /= 32.0;\n    \n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\nfloat calcSSS( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n    float occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.002 + 0.11*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        occ += (h-mapOpaque(pos-h*dir, kk).x);\n    }\n    occ = clamp( 1.0 - 11.0*occ/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec4 kk;    \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float h = mapOpaque(ro + rd*t, kk ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n        if( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 sunDir = normalize( vec3(0.2,0.1,0.02) );\n\nvec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )\n{\n    float eps = 0.002;\n    vec2 britneyOffset = vec2(1.0, -0.5);\n    vec2 britneyTexOffset = vec2(0.3, -0.2);\n\tfloat britneyRadius = 0.3;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalOpaque( pos, eps );\n\tvec2 britneyScale = vec2(2.0, 2.0);\n\n    vec3 mateD = vec3(0.0);\n    vec3 mateS = vec3(0.0);\n    vec2 mateK = vec2(0.0);\n    vec3 mateE = vec3(0.0);\n\n    float focc = 1.0;\n    float fsha = 1.0;\n\tint check = 0;\n\tvec3 britney = vec3(0.0);\n    if( m<1.5 ) // snail body\n    {\n\t\t\n\t\tvec2 texpos = (pos.xy * 2.0 + britneyOffset);\n        if (texpos.x >= 0.6 && texpos.x <= 1.2 && texpos.y >= 0.2 && texpos.y <= 0.9)\n\t\t\tcheck = 1;\n\t\tvec2 d8 = vec2(texpos.x - 0.9, texpos.y - 0.55);\n\t\tif (sqrt(d8.x * d8.x + d8.y * d8.y) >= britneyRadius)\n            check = 0;\n        float dis = texture( iChannel1, 5.0*pos.xy ).x;\n\t\tvec4 col0 = texture(iChannel0, (pos.xy + britneyTexOffset) * britneyScale);\n\t\t//if (col0.x <= 0.5 && col0.z <= 0.5)\n\t\t//\tcheck = 0;\n\t\tbritney = vec3(col0.xyz);\n        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );\n        be = 1.0-smoothstep( -0.01, 0.01, be );        \n        \n        float ff = abs(matInfo.x-0.20);\n        \n        mateS = 6.0*mix( 0.7*vec3(2.0,1.7,1.0), vec3(2.5,1.8,0.9), ff );\n        mateS += 2.0*dis;\n        mateS *= 1.5;\n        mateS *= 1.0 + 0.5*ff*ff;\n        mateS *= 1.0-0.5;\n        \n        mateD = vec3(1.0,0.8,0.4);\n        mateD *= dis;\n        mateD *= 0.015;\n        mateD += vec3(0.8,0.4,0.3)*0.15*0.01;\n        \n        mateK = vec2( 60.0, 0.7 + 1.0*dis );\n        \n        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );\n        f = 1.0-pow( f, 8.0 );\n        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);\n        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);\n        \n        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));\n        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );\n    }\n    else if( m<2.5 ) // shell\n    {\n        mateK = vec2(0.0);\n        \n        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );\n        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );\n        \n        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );\n        \n        vec3 ral = texture( iChannel1, vec2(2.0*matInfo.w+matInfo.z*0.5,0.5) ).xxx;\n        mateD *= 0.25 + 0.75*ral;\n        \n        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );\n        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));\n        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );\n        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;\n        \n        mateK = vec2( 64.0, 0.2 );\n        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;\n    }\n    else if( m<3.5 ) // plant\n    {\n        mateD = vec3(0.05,0.1,0.0)*0.2;\n        mateS = vec3(0.1,0.2,0.02)*25.0;\n        mateK = vec2(5.0,1.0);\n        \n        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n        mateD += 0.2*fre*vec3(1.0,0.5,0.1);\n        \n        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;\n        mateS *= 0.5 + 1.5*te;\n        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);\n    }\n    else //if( m<4.5 ) // leave\n    {\n        vec3 p = pos - vec3(-1.8,0.6,-0.75);\n        vec3 s = p;\n        p = mat3(0.671212, 0.366685, -0.644218,\n                -0.479426, 0.877583,  0.000000,\n                 0.565354, 0.308854,  0.764842)*p;\n\n        vec3 q = p;\n        p.y += 0.2*exp(-abs(2.0*p.z) );\n\n        float v = smoothstep( 0.01, 0.02, abs(p.z));\n        \n        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );\n\n        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;\n\n        float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n        r = r*(1.0-r)*(1.0-r)*6.0;\n        float ff = length(p.xz/vec2(2.0,r));\n\n        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );\n        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );\n        mateD *= 1.0 + 0.25*te;\n        \n        mateS = vec3(0.15,0.2,0.02)*0.8;\n        mateS *= 1.0 + 0.2*rr;\n        \n        mateD *= 0.8;\n        mateS *= 0.8;\n\n        mateK = vec2(64.0,0.25);\n        \n        //---------------------\n        \n        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);\n        nor = normalize( nor );\n\n        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );\n        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );\n        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );\n        float dd = min(d1,min(d2,d4));\n        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);\n        \n        d1 = sdEllipsoid( q.xz, vec2( 0.5, 0.20), 1.0*vec2(0.15,0.15) );\n        d2 = sdEllipsoid( q.xz, vec2( 0.8,-0.15), 0.5*vec2(0.15,0.15) );\n        d4 = sdEllipsoid( q.xz, vec2(-0.5,-0.20), 1.0*vec2(0.04,0.04) );\n        d1 = abs(d1);\n        d2 = abs(d2);\n        d4 = abs(d4);\n        dd = min(d1,min(d2,d4));\n        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);\n        \n        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );\n        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );\n        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;\n        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    \n    }\n    \n  \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n    float sss = calcSSS( pos, nor );\n    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;\n    \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float sha = calcSoftshadow( pos, sunDir, 20.0 ); \n    dif1 *= sha*fsha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    vec3 col = 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;\n    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);\n    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;\n\n    col *= mateD;\n\n    col += .4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS;\n  \n    col = pow(col,vec3(0.6,0.8,1.0));\n    \n    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;\n    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y;\n    col += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0));        \n\n    col += mateE;\n\tif (check == 1)\n    {\n        col = mix(col, britney, 0.5);\n    }\n    return col;        \n}\n\nvec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )\n{\n    vec3 oriCol = col;\n    \n    float dz = depth - t;\n    float ao = clamp(dz*50.0,0.0,1.0);\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormalTransparent( pos, 0.002 );\n    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    vec3  ref = reflect( -rd, nor );\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );\n\n\n    float ds = 1.6 - col.y;\n    \n    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );\n\n    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );\n    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);\n    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    \n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );\n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );\n    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,texture( iChannel1, 0.8*nor.xy ).x)*(0.1+0.9*fre*fre);\n    \n    // hide aliasing a bit\n    col = mix( col, oriCol, smoothstep(0.6,1.0,fre) ); \n    \n    return col;\n}\n\n//--------------------------------------------\n\nvec2 intersectOpaque( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapOpaque( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x*0.9;\n    }\n    return res;\n}\n\nvec2 intersectTransparent( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTransparent( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x;\n    }\n    return res;\n}\n\nvec3 background( in vec3 d )\n{\n    // cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                                     d.xy/d.z;\n    \n    vec3  col = vec3( 0.0 );\n    for( int i=0; i<200; i++ )\n    {\n        float h = float(i)/200.0;\n        float an = 25.0*2.2831*h;\n        vec2  of = vec2( cos(an), sin(an) ) * h;\n\n        vec3 tmp = texture( iChannel2, uv*0.25 + 0.0075, 4.0 ).yxz;\n        col = smax( col, tmp, 0.5 );\n    }\n    \n    \n    return col;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    //-----------------------------\n\n    vec3 col = background( rd );\n    \n    //-----------------------------\n    \n    float mindist = 1.0;\n    float maxdist = 4.0;\n\n    vec4 matInfo;\n    vec2 tm = intersectOpaque( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeOpaque( ro, rd, tm.x, tm.y, matInfo );\n        maxdist = tm.x;\n    }\n\n    //-----------------------------\n    \n    tm = intersectTransparent( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeTransparent( ro, rd, tm.x, tm.y, matInfo, col, maxdist );\n    }\n\n    //-----------------------------\n    \n    float sun = clamp(dot(rd,sunDir),0.0,1.0);\n    col += 1.0*vec3(1.5,0.8,0.7)*pow(sun,4.0);\n\n    //-----------------------------\n\n    return pow( col, vec3(0.45) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n    vec3 cw = normalize(rt-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    #if AA<2\n    \n        vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n        float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n        vec3  ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n        vec3  ta = vec3(-0.6,0.2,0.0);\n        mat3  ca = setCamera( ro, ta, 0.0 );\n        vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n        vec3 col = render( ro, rd );\n    \n    #else\n\n        vec3 col = vec3(0.0);\n        for( int m=0; m<AA; m++ )\n        for( int n=0; n<AA; n++ )\n        {\n            vec2 rr = vec2( float(m), float(n) ) / float(AA);\n\n            vec2 p = (-iResolution.xy+2.0*(fragCoord.xy+rr))/iResolution.y;\n            float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n            vec3 ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n            vec3 ta = vec3(-0.6,0.2,0.0);\n            mat3 ca = setCamera( ro, ta, 0.0 );\n            vec3 rd = normalize( ca * vec3(p,-2.8) );\n\n            col += render( ro, rd );\n        }    \n        col /= float(AA*AA);\n    #endif\n        \n    col = 1.05*col + vec3(0.0,0.0,0.04);\n        \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 55, 55, 91], [93, 93, 147, 147, 211], [213, 213, 267, 267, 322], [324, 324, 357, 357, 412], [414, 414, 466, 466, 589], [591, 591, 633, 633, 763], [765, 765, 796, 796, 883], [885, 949, 978, 978, 1004], [1005, 1005, 1052, 1052, 1530], [1532, 1532, 1581, 1581, 2018], [2020, 2020, 2061, 2061, 2156], [2158, 2158, 2196, 2196, 2327], [2328, 2328, 2366, 2366, 2501], [2503, 2503, 2544, 2544, 2639], [2641, 2641, 2679, 2679, 2773], [2854, 2854, 2878, 2878, 2920], [2922, 2922, 2945, 2945, 3005], [3007, 3007, 3043, 3043, 3307], [3417, 3417, 3465, 3465, 4924], [4926, 4926, 4959, 4959, 5130], [5132, 5132, 5172, 5172, 7470], [7476, 7476, 7504, 7504, 7640], [7642, 7642, 7670, 7670, 8409], [8411, 8411, 8455, 8455, 9102], [9104, 9104, 9156, 9156, 9459], [9538, 9538, 9576, 9576, 10401], [10403, 10403, 10452, 10452, 10630], [10632, 10632, 10689, 10689, 11012], [11091, 11091, 11133, 11133, 11471], [11473, 11473, 11516, 11516, 11867], [11869, 11869, 11926, 11926, 12225], [12275, 12275, 12360, 12360, 18920], [18922, 18922, 19041, 19041, 20103], [20153, 20153, 20261, 20261, 20554], [20556, 20556, 20669, 20669, 20963], [20965, 20965, 20995, 21016, 21507], [21510, 21510, 21549, 21585, 22382], [22384, 22384, 22439, 22439, 22629], [22631, 22631, 22688, 22688, 23909]], "test": "error"}
{"id": "ltKXRm", "name": "Difference Blend Mode", "author": "ptrgags", "description": "I wanted to try implementing some of the layer blend modes in GIMP. For starters, here is the \"Difference\" blend mode. ", "tags": ["2d", "texture", "difference", "blendmode", "gimp"], "likes": 3, "viewed": 203, "published": "Public", "date": "1483658777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Get the texture color\n    vec4 image = texture(iChannel0, uv);\n    \n    //Make a simple sine wave stripe\n    float mask_pattern = 0.5 * sin(8.0 * uv.x - iTime) + 0.5;\n    vec4 mask = mask_pattern * vec4(1.0);\n    \n    //Absolute difference blend mode as described at\n    //https://docs.gimp.org/en/gimp-concepts-layer-modes.html\n    vec4 difference = abs(mask - image);\n    \n\tfragColor = difference;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 512]], "test": "error"}
{"id": "ltKXRt", "name": "Hypnofrog eyes", "author": "OmskCrow", "description": "All glory to the Hypnotoad", "tags": ["hypno", "hypnotoad", "frog"], "likes": 1, "viewed": 203, "published": "Public", "date": "1485479127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat circle(vec2 a, vec2 b) {\n    vec2 c = a - b;\n \treturn sqrt(c.x * c.x + c.y * c.y);\n}\n\nfloat ellipse(vec2 a, vec2 b, float xMult, float yMult) {\n    vec2 c = a - b;\n \treturn sqrt(c.x * c.x * xMult + c.y * c.y * yMult);\n}\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float switchSpeedMult = 8.0;//ÑÐºÐ¾ÑÐ¾ÑÑÑ ÑÐ°ÑÑÐ¸ÑÐµÐ½Ð¸Ñ Ð·ÑÐ°ÑÐºÐ¾Ð²\n    const float screenScale = 2.0;\n    vec2 centerOffset = vec2(iResolution.x/iResolution.y * 0.5, 0.0);      \n    vec2 screenCoord = ((fragCoord - iResolution.xy * 0.5) / iResolution.y) * screenScale - centerOffset;\n  \tfloat frameOffset = 0.0;\n    \n    if(screenCoord.x < -iResolution.x/iResolution.y * 0.5) {\n        screenCoord.x += iResolution.x/iResolution.y;\n        frameOffset = M_PI;\n    }\n    \n    \n    float stateSwitch = (sin(iTime * switchSpeedMult + frameOffset) + 1.0) * 0.5;\n    \n    float state1 = min(ellipse(screenCoord, vec2(-0.12,0.0), 0.3, 1.5), \n                           ellipse(screenCoord, vec2(0.12,0.0), 0.3, 1.5));\n    \n    float state2 = min(min(min(ellipse(screenCoord, vec2(-0.15,-0.01), 0.6, 1.0),\n                               ellipse(screenCoord, vec2(0.17,-0.01), 0.6, 1.0)),\n                       \t       circle(screenCoord, vec2(-0.01,0.14))),\n                       \t\t   circle(screenCoord, vec2(0.01,-0.17)));\n                       \n\tfloat uv = mix(state1, state2, stateSwitch);\n    float circleDist = circle(screenCoord, vec2(0.0, 0.0));\n    float eyeRadius = iResolution.x/iResolution.y * 0.4;\n    \n    float blackBorder = 0.17;\n    float redBorder = 0.20;\n    float yellowBorder = 0.25 + rand(vec2(iTime, iTime))/15.0;\n    \n    if(uv < blackBorder) fragColor = vec4(0.1,0.1,0.1,1.0);\n    else if(uv < redBorder) fragColor = vec4(1.0,0.0,0.0,1.0);\n    else if(uv < yellowBorder) {\n        float blend = (uv - redBorder) / (yellowBorder - redBorder);\n    \tfragColor = mix(vec4(1.0,1.0,0.0,1.0), vec4(0.5,0.5,0.0,1.0), blend);        \n    }\n    else if(circleDist < eyeRadius) fragColor = vec4(0.5,0.5,0.0,1.0);        \n\telse fragColor = vec4(0.0,0.0,0.0,1.0);        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 78, 78, 138], [140, 140, 197, 197, 273], [503, 503, 560, 560, 2367]], "test": "valid"}
{"id": "ltVSDz", "name": "Prismoid", "author": "lherm", "description": "Some fun with folding space.", "tags": ["raymarch"], "likes": 4, "viewed": 511, "published": "Public API", "date": "1483976839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/Xt2XDt by Cabbibo\n\n#define PI 3.14159165\n\nconst int S = 100; // steps\nconst float D = 100.; // max distance\nconst float P = 0.001; // intersection precision\n\n//-------------------\n// Camera\n//-------------------\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n//-------------------\n// Modelling\n//-------------------\n\nvec2 map(in vec3 p)\n{\n    float s = 1000.;\n    for (int i = 0; i < 4; i++)\n    {\n        p = abs(p);\n        p -= .5;\n        pR(p.xz, sin(iTime * .001) * 90.);\n        pR(p.yx, sin(iTime * .001) * 90.);\n        s = min(s, sdTriPrism(p, vec2(.5)));\n    }\n    vec2 res = vec2(s, 1.);\n    return res;\n}\n\nvec2 trace(in vec3 ro, in vec3 rd)\n{\n    float h = P*2.;\n    float t = 0.;\n    float id = -1.;\n    float res = -1.;\n    \n    for (int i = 0; i < S; i++)\n    {\n        if (h<P || t>D) break;\n        vec3 r = ro + rd*t;\n        h = map(r).x;\n        t += h;\n        id = map(r).y;\n    }\n    \n    if (t < D) res = t;\n    if (t > D) id = -1.;\n    \n    return vec2(res, id);\n}\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// From Connor Bell\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render(in vec2 res, in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.);\n    vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    if (res.y > -.5)\n    {\n        vec3 p = ro + rd*res.x;\n        vec3 norm = calcNormal(p);      \n        vec3 lightDir = normalize(lightPos - p);\n        float match = max( 0. , dot( lightDir , norm ));\n        float occ = calcAO(p, norm);\n        \n        if (res.y == 1.)\n        {\n            color = norm * match * occ * (1.0-calcAO(p, rd));\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 4.);\n    vec3 ta = vec3(0., 0., 0.);\n    \n    // Camera Matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0. );  // 0.0 is the camera roll\n    \n    // Create view ray\n\tvec3 rd = normalize( camMat * vec3(uv.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = trace(ro, rd);\n    \n    vec3 color = render(res, ro, rd);\n    color = pow(color, vec3(.4545));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 255, 319, 319, 497], [500, 500, 530, 530, 573], [575, 575, 611, 611, 698], [700, 700, 732, 732, 774], [834, 834, 855, 855, 1134], [1136, 1136, 1172, 1172, 1507], [1509, 1509, 1540, 1540, 1766], [1768, 1788, 1862, 1862, 2123], [2125, 2125, 2167, 2167, 2466], [2468, 2468, 2518, 2518, 2982], [2984, 2984, 3041, 3041, 3532]], "test": "valid"}
{"id": "ltVSRd", "name": "firstshomam", "author": "Shoma_M", "description": "first", "tags": ["first"], "likes": 2, "viewed": 87, "published": "Public", "date": "1485505206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0);\n    for (int i = 0; i < 200; i++) {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n    \tuv -= 0.5; //åç¹ä¸­å¿ã«\n        uv.x *= iResolution.x / iResolution.y; //xyã®å¹çµ±ä¸\n        \n    \tfloat t = iTime + float(i) * 0.1;\n    \tuv.x += 0.2 * sin(t * 2.); \n    \tuv.y += 0.2 * sin(t * 3.); //åç¹ä½ç½®ãç§»å\n    \n    \tfloat c = 1.0 / ( length(uv) * length(uv) ); //ä¸­å¿ããã®è·é¢ã®2ä¹ã®éæ°\n    \tc *= 0.0001; //é©å½\n    \n\t\tfragColor += vec4(c, c * .2, c , 1.0); //è²å¤æ´\n    \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 592]], "test": "valid"}
{"id": "ltVSz3", "name": "Hexagon #1", "author": "WuTangTan", "description": "Coloured hexagons in a looping animation.", "tags": ["procedural", "2d", "animation", "hexagon"], "likes": 10, "viewed": 543, "published": "Public API", "date": "1485294394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec4 h2rgb(float c) {\n  return  clamp(abs( fract(c + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st *= 4.0;\n    st = fract(st)*2.-1.;\n\n    //int N = int(mod(iTime + st.x / 4.0, 6.0) + 3.0);\n    int N = 6;\n\n    float a = atan(st.x,st.y)+PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r)*r-a)*length(st);\n    \n    vec3 color = vec3(step(0.1, mod(d - iTime / 5.0, 0.2)));\n    fragColor = vec4(color,1.0) * h2rgb(fract(d - iTime / 5.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 76, 76, 153], [155, 155, 212, 212, 656]], "test": "valid"}
{"id": "ltVXRW", "name": "multi sunset", "author": "nexor", "description": "Want to see the sunset but you are not able to get there? Here's a digitized version of a still sunset with multiple reflections.", "tags": ["wavy", "chill"], "likes": 6, "viewed": 133, "published": "Public", "date": "1483373933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define sin1(x) (.5+sin(x)*.5)\n#define cos1(x) (.5+cos(x)*.5)\n#define ss smoothstep\nconst float pi_2 = asin(1.);\nconst float pi   = pi_2 * 2.;\nconst float pi2  = pi_2 * 4.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tvec3 col=vec3(.0);\n    float scale = iResolution.y/iResolution.x;\n\tvec2 p=-1.+2.*uv;\n\tp.x*=1./scale;\n\tp*=1.4;\n\n\tfloat d=length(p);\n\tp.y*=.6;\n\tfloat e=length(p\n\t\t+.5*ss(.0,-.6,p.y)\n\t\t*vec2(cos(iTime*1.5+p.y*scale*8000.),.0));\n    col+=1.;\n\tcol*=ss(.8,.79,mix(e,d,step(.0,p.y)));\n\tcol+=.4;\n\tcol*=vec3(1.,.5,.0)/(d*mix(e,d,step(.0,p.y)));\n\tcol*=sqrt(.6);\n\tcol*=mix(1.,.7,step(.0,p.y));\n\tfragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 255, 255, 712]], "test": "error"}
{"id": "ltVXzc", "name": "SDF Interpolation", "author": "Linus", "description": "Signed distance field interpolation to interpolate between shapes.", "tags": ["distancefield"], "likes": 0, "viewed": 256, "published": "Public", "date": "1485347355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//==================\n\nconst bool RENDER_DISTANCE = false;\nconst bool RENDER_SHAPE = true;\n\n//==================\n\nstruct Figure {\n\tvec2  position;\n    float size;\n};\n\nvec2 rotateAround(vec2 vec, vec2 point, float angle) {\n    vec -= point;\n\tvec *= mat2(sin(angle), cos(angle), cos(angle), -sin(angle));\n    vec += point;\n    return vec;\n}\n    \nfloat signedCircleDistance(Figure circle, vec2 uv) {\n    \n\treturn length(circle.position - uv) - circle.size;\n}\n\nfloat signedSquareDistance(Figure square, vec2 uv) {\n    vec2 delta = abs(square.position - uv);\n \treturn max(delta.x, delta.y) - square.size;   \n}\n\nvec2 uvCoords(in vec2 fragCoord) {\n    float pixelsInUnit = min(iResolution.x, iResolution.y);\n    vec2 offset = ((pixelsInUnit - iResolution.xy) * 0.5) / pixelsInUnit;\n    return (fragCoord / pixelsInUnit) + offset;\n}\n\nvec4 signedDistanceToColor(float dist) {\n\tfloat intensity = 1.0 - exp(-abs(dist/20.0));\n    \n   \tvec4 distanceColor = vec4(\n    \tdist < 0.0 ? intensity : 0.0,\n        dist > 0.0 ? intensity : 0.0,\n        0.0, \n        0.0\n    );\n    vec4 shapeColor = vec4(smoothstep(1.0, 0.0, abs(dist) * 3.0 ));\n    \n    vec4 color;\n    if(RENDER_DISTANCE) { color += distanceColor; }\n    if(RENDER_SHAPE) { color += shapeColor; }\n    \n    return  color;\n}\n\nfloat signedDistanceFigureA(vec2 uv) {\n    uv = rotateAround(uv, vec2(50.0, 50.0), iTime / 12.0);\n    \n    Figure circle0 = Figure (vec2(50.0, 65.0), 15.0);\n    Figure square0 = Figure (vec2(50.0, 35.0), 25.0);\n    Figure square1 = Figure (vec2(22.5, 35.0), 15.0);\n    \n    return min(signedCircleDistance(circle0, uv), \n           min(signedSquareDistance(square0, uv),\n           \t   signedSquareDistance(square1, uv)\n           ));\n}\n\nfloat signedDistanceFigureB(vec2 uv) {\n    \n    uv = rotateAround(uv, vec2(50.0, 50.0), -iTime / 3.14);\n    Figure square0 = Figure (vec2(50.0, 50.0), 30.0);\n    Figure circle0 = Figure (vec2(70.0, 35.0), 20.0);\n    vec2 offset = vec2(sin(iTime) * 31.0, 0.0);\n    square0.position += offset;\n    circle0.position += offset;\n    \n    \n    return min(signedSquareDistance(square0, uv), signedCircleDistance(circle0, uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = uvCoords(fragCoord) * 100.0;\n    \n    Figure circle0 = Figure (vec2(50.0, 65.0), 15.0);\n    Figure square0 = Figure (vec2(50.0, 35.0), 25.0);\n    Figure square1 = Figure (vec2(50.0, 50.0), 30.0);\n    Figure square2 = Figure (vec2(40.0, 50.0), 10.0);\n    Figure circle1 = Figure (vec2(70.0, 35.0), 20.0);\n    \n    float distA = signedDistanceFigureA(uv);\n    float distB = signedDistanceFigureB(uv);\n    float t = cos(iTime / 2.0) * 0.5 + 0.5;\n    float distT = mix(distA, distB, t);\n    fragColor = signedDistanceToColor(distT);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 220, 220, 337], [343, 343, 395, 395, 454], [456, 456, 508, 508, 603], [605, 605, 639, 639, 823], [825, 825, 865, 865, 1267], [1269, 1269, 1307, 1307, 1705], [1707, 1707, 1745, 1745, 2128], [2130, 2130, 2187, 2187, 2729]], "test": "valid"}
{"id": "ltVXzd", "name": "Epilepsy #FirstShader", "author": "Moritz", "description": "A epileptic circle, probably way to complicated.", "tags": ["2d", "test", "firstshader"], "likes": 5, "viewed": 495, "published": "Public API", "date": "1485525437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/**\n * sharpness: 0 - 1, 1 = 100%\n * size: 0 - 1, 1 = iResolution.y\n * thickness: 1 = 100%, 2 = 50%, ...\n */\nfloat donut(vec2 fragCoord, vec2 center, float sharpness, float size, float thickness) {\n    float dist = distance(center, fragCoord);\n    float distPer = (1.0 - (dist * 2.0 / iResolution.y) / size);\n    float color = clamp(distPer, 0.0, 1.0) * thickness;\n\n    if (color > 1.0 + sharpness) {\n        color = (1.0 + sharpness) - (color - 1.0);\n    }\n\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat shake(float time, float n, float smallShaking, float largeShaking, float slDiff) {\n    const float sinMax = 1.0;\n    float small = (1.0 - slDiff) + sin(time * smallShaking) / (sinMax / slDiff);\n    float large = sin(time * largeShaking);\n    return n * (small * large);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime * 16.0;\n    float smallLargeShakeDiff = 0.6;\n    \n    float shaking = iResolution.x / 20.0;\n    vec2 screeCenter = vec2(iResolution.xy / 2.0);\n\n    vec2 centerR = vec2(\n        screeCenter.x + shake(t, shaking, 5.2, 2.6, smallLargeShakeDiff),\n        screeCenter.y + shake(t, shaking, 5.3, 2.8, smallLargeShakeDiff)\n    );\n\n    vec2 centerG = vec2(\n        screeCenter.x + shake(t, shaking, 5.1, 2.5, smallLargeShakeDiff),\n        screeCenter.y + shake(t, shaking, 5.4, 2.7, smallLargeShakeDiff)\n    );\n\n    vec2 centerB = vec2(\n        screeCenter.x + shake(t, shaking, 5.5, 2.4, smallLargeShakeDiff),\n        screeCenter.y + shake(t, shaking, 5.0, 2.9, smallLargeShakeDiff)\n    );\n\n    float sharpness = 0.1;\n    float size = 0.85 + shake(t, 0.1, 6.2, 1.9, 0.2);\n    float thickness = 5.0;\n\n    fragColor = vec4(\n        0.0 + 0.8 * donut(fragCoord, centerR, sharpness, size, thickness),\n        0.0 + 0.8 * donut(fragCoord, centerG, sharpness, size, thickness),\n        0.1 + 0.8 * donut(fragCoord, centerB, sharpness, size, thickness),\n        1.0\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 110, 198, 198, 496], [498, 498, 586, 586, 775], [777, 777, 832, 832, 1913]], "test": "valid"}
{"id": "ltVXzV", "name": "Metaball Lights Loader", "author": "VoidChicken", "description": "A 2d loader that glows.", "tags": ["2d", "light", "metaball", "loader"], "likes": 7, "viewed": 208, "published": "Public", "date": "1485139734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float p = acos(-1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy,\n         q = ( 2.*fragCoord-R ) / R.y;\n \tvec3 c = vec3(0);\n    float b = length(q)/2.;\n    c*=1.-b;\n    float t= sin(iTime*p/3.)*2.*p;\n    vec2 a = vec2(cos(t),sin(t))/2.;\n    vec2 d = vec2(cos(t+p),sin(t+p))/2.;\n    float z = .2;\n    float k = .01;\n    float aspo = abs(length(q-d)-z);\n    if (aspo<k) {\n    \tc=1.-vec3(aspo/k);    \n    }\n    float l = length(q-a);\n    if (l<z-k/2.) {\n        c=vec3(pow(1.-(l/(z-k/2.)),1./4.));\n    }\n   \n    vec2 dca = normalize(a-q);\n    vec2 dcb = normalize(d-q);\n    vec3 k1 = vec3(248,251,234)/256.;\n    vec3 k2 = vec3(204,210,244)/256.;\n   \tvec3 add_a = mix(k2,k1,dot(dca,vec2(1,0)*.5+.5))/abs(l-(z-k/2.));\n   \tvec3 add_b = mix(k2,k1,dot(dcb,vec2(1,0)*.5+.5))/aspo;\n    add_a/=50.;\n    add_b/=50.;\n   \tc+=(add_a+add_b);\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 899]], "test": "error"}
{"id": "ltySRt", "name": "Cellular Blocks", "author": "Shane", "description": "Fast, animated 2d cellular block algorithm. The blocks have been added to a back plane and raymarched to give a pseudo 3D block effect.", "tags": ["voronoi", "triangle", "block"], "likes": 78, "viewed": 2921, "published": "Public API", "date": "1485681274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tFast Cellular Blocks\n\t--------------------\n\n\tAfter looking at IQ and Aiekick's 2D Voronoi triangle-metric examples (the ones that \n\tlook like blocks), I thought it'd be interesting to raymarch the pattern onto a back \n\tplane to see just how 3D it looked. The result was an interesting voxelized look with\n\tmore depth than the regular, or bump mapped, examples you see around. After that, I \n\tfigured I'd add some variance by rounding things off, combining layers, etc, but ran \n\tinto speed problems.\n\n\tAt that stage, I wondered whether the much faster cellular tiled approach could emulate \n\tthe pattern, and thankfully, it could. I came up with the layered repeat-tile approach \n    a while back, and have explained it in other examples. The result, here, is an \n\tartifact-free, animated triangle metric at a small fraction of the cost.\n\n    Unlike my other cellular tiled examples, this one is animated. It was a proof of concept, \n\twhich was put in as an afterthought, so probably needs some tuning. Nevertheless, it\n\tworks well enough for the purpose of this demonstration.\n\n\tAt best, a normal animated Voronoi algorithm utilizing the triangle metric would have \n\tnine iterations (many use more) consisting of several operations. The algorithm used \n\there uses just four, each with a fraction of the operations.\n\n\tI haven't utilized the speed to its full potential. However, there are still two \n\traymarched layers - each containing a more expensive distance metric - and my slowest \n\tcomputer can handle it easily. I'll do something more interesting with it later.\n\n\tBy the way, I made a very basic example with very little code for anyone who'd like to\n\tlook at the algorithm without having to sift through a bunch of window dressing. The\n\tlink is below.\n\n\t// The main inspiration for this, and practically all the other examples.\n\tBlocks -IQ\n    https://www.shadertoy.com/view/lsSGRc\n\n\n\t// Just the cellular block algorithm.\n    Fast, Minimal Animated Blocks - Shane\n\thttps://www.shadertoy.com/view/MlVXzd\n\n*/\n\n\n// Far plane. Redundant here, but included out of habit.\n#define FAR 10. \n\nfloat objID = 0.; // Object ID. Used to identify the large block and small block layers.\n\n\n/*\n\n// Just the function itself. Everything else can be ignored, if you just want to produce repeat\n// block tile patterns.\n\n// Distance metric. A slightly rounded triangle is being used, which looks a little more organic.\nfloat dm(vec2 p){\n    \n    p = fract(p) - .5;\n    \n    //return max(abs(p.x)*.866025 + (p.y)*.5, -(p.y)); // Regular triangle metric.\n    \n    return (dot(p, p)*4.*.25 + .75)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    //return (1.-(dot(p, p)*4.*.5 + .5)*.5)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    //return (1.-dot(p, p)*4.*.166)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    \n    //return max(-max(abs(p.x)*.866025 - p.y*.5, p.y) + .25, max(abs(p.x)*.866025 + p.y*.5, -p.y));\n    //return (length(p) + .5)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    \n}\n\n\n// Very cheap wrappable cellular tiles. This one produces a block pattern on account of the\n// metric used, but other metrics will produce the usual patterns.\n//\n// Construction is pretty simple: Plot two points in a wrappble cell and record their distance. \n// Rotate by a third of a circle then repeat ad infinitum. Unbelievably, just one rotation \n// is needed for a random looking pattern. Amazing... to me anyway. :)\n//\n// Note that there are no random points at all, no loops, and virtually no setup, yet the \n// pattern appears random anyway.\nfloat cell(vec2 p){\n\n    \n    // Matrix to rotate the layer by TAU/3. radians - or 120 degrees -\n    // which makes sense when dealing with the equilateral triangle metric.\n    const mat2 m = mat2(-.5, .866025, -.866025, -.5);    \n    \n    // Abstract varitation, just for fun.\n    //const mat2 m = mat2(-1, 1, -1, -1)*.7071;\n    //const mat2 m = mat2(.5, .866025, -.866025, .5);\n     \n    // Two rotating point plus offset\n    const float offs = .666 - .166;\n    vec2 a = sin(vec2(1.93, 0) + iTime)*.166;\n    float d0 = dm(p + vec2(a.x, 0));\n    float d1 = dm(p + vec2(0, offs + a.y));\n    \n    // Rotate the layer, and plot another two points.\n    p = m*(p + .5);\n    float d2 = dm(p + vec2(a.x, 0));\n    float d3 = dm(p + vec2(0, offs + a.y)); \n    \n    // Find the distance to the nearest point.\n    // It works with just one rotation and four points very well.\n    return min(min(d0, d1), min(d2, d3))*2.;    \n\n     \n    // Add another two points and a rotation, and the pattern looks even more random.\n    //p = m*(p + .5);\n    //float d4 = dm(p +  vec2(a.x, 0));\n    //float d5 = dm(p +  vec2(0, offs + a.y));\n    \n    //return min(min(min(d0, d1), min(d2, d3)), min(d4, d5))*2.;\n         \n    \n}\n\n*/\n\n// Distance metric. A slightly rounded triangle is being used, which looks a little more organic.\nfloat dm(vec2 p){\n    \n    p = fract(p) - .5;\n    \n    //return max(abs(p.x)*.866025 + (p.y)*.5, -(p.y)); // Regular triangle metric.\n    \n    return (dot(p, p)*4.*.25 + .75)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    //return (1.-(dot(p, p)*4.*.5 + .5)*.5)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    //return (1.-dot(p, p)*4.*.166)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    \n    //return max(-max(abs(p.x)*.866 - p.y*.5, p.y) + .25, max(abs(p.x)*.866025 + p.y*.5, -p.y));\n    //return (length(p) + .5)*max(abs(p.x)*.866025 + p.y*.5, -p.y);\n    \n}\n\n// Distance metric for the second pattern. It's just a reverse triangle metric.\nfloat dm2(vec2 p){\n    \n    p = fract(p) - .5;   \n    \n    //return max(abs(p.x)*.866025 + -p.y*.5, p.y); \n    return (dot(p, p)*4.*.25 + .75)*max(abs(p.x)*.866025 - p.y*.5, p.y);\n    \n    //return max(-max(abs(p.x)*.866025 + p.y*.5, -p.y) + .2, max(abs(p.x)*.866025 - p.y*.5, p.y));\n    //return (length(p)*1. + .5)*max(abs(p.x)*.866025 - p.y*.5, p.y);\n    \n}\n\n// Very cheap wrappable cellular tiles. This one produces a block pattern on account of the\n// metric used, but other metrics will produce the usual patterns.\n//\n// Anyway, plot two points in a wrappble cell and record the minimum distance, rotate by a third\n// of a circle whilst storing the overall minimum, then repeat ad infinitum. In this case just\n// one rotation is needed for a random looking pattern. Amazing.\n//\n// Note that there are no random points at all, no loops, and virtually no setup, yet the \n// pattern appears random anyway.\n//\n// By the way, this particular function combines two patterns for the large and small blocks,\n// but the original is commented out above, for anyone interested.\nfloat cell(vec2 q){\n\n    \n    // SETUP.\n    //\n    // Matrix to rotate the layer by TAU/3. radians - or 120 degrees -\n    // which makes sense when dealing with the equilateral triangle metric.\n    const mat2 m = mat2(-.5, .866025, -.866025, -.5);    \n    \n    // Abstract varitation, just for fun.\n    //const mat2 m = mat2(-1, 1, -1, -1)*.7071;\n    //const mat2 m = mat2(.5, .866025, -.866025, .5);\n     \n    // FIRST PATTERN.\n    // Two rotating points plus offset\n    vec2 p = q;\n    const float offs = .666 - .166;\n    vec2 a = sin(vec2(1.93, 0) + iTime)*.166;\n    float d0 = dm(p + vec2(a.x, 0));\n    float d1 = dm(p + vec2(0, offs + a.y));\n    \n    // Rotate the layer, and plot another two points.\n    p = m*(p + .5);\n    float d2 = dm(p + vec2(a.x, 0));\n    float d3 = dm(p + vec2(0, offs + a.y)); \n    \n    // Find the distance to the nearest point.\n    // It works with just one rotation and four points very well.\n    float l1 = min(min(d0, d1), min(d2, d3))*2.; \n    \n    \n    // SECOND PATTERN... The small blocks, just to complicate things. :)\n    p = q;\n    d0 = dm2(p + vec2(a.x, 0));\n    d1 = dm2(p + vec2(0, offs + a.y));\n    \n    // Rotate the layer, and plot another two points.\n    p = m*(p + .5);\n    d2 = dm2(p + vec2(a.x, 0));\n    d3 = dm2(p + vec2(0, offs + a.y)); \n    \n    // Find the distance to the nearest point.\n    // It works with just one rotation and four points very well.\n    float l2 = min(min(d0, d1), min(d2, d3))*2.; \n    \n    \n    // COMBINING PATTERNS.\n    objID = step(l1, -(l2 - .4)); // Object, or pattern, ID.\n \n    // Combine layers.\n    return max(l1, -(l2 - .4));\n\n   \n    \n}\n\n// The heightmap. We're combining two patterns, each with their own distance metric, so the cell\n// function is more complicated than it normally would be. However, there's another that has been\n// commented out that people can refer to, if they're interested.\nfloat heightMap(vec3 p){\n \n    return cell(p.xy*2.); // Just one layer.\n \n}\n\n// The distance function. Just a heightmap function applied to a plane. Pretty standard stuff.\nfloat map(vec3 p){\n   \n    float tx = heightMap(p);\n    \n    return 1.2 - p.z + (.5 - tx)*.125;\n    \n}\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 nr(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(2./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n\n    \n    e = vec2(2./450., 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 2., occ = 0.;\n    for(float i=0.; i<6.; i++){\n    \n        float hr = .01 + i*.75/5.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.8;\n    }\n    \n    return clamp(1.0 - occ, 0., 1.);    \n    \n    \n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\nvoid mainImage( out vec4 fragColor, vec2 u ){\n\n    // Unit direction ray, ray origin (camera position), and light.\n    vec3 rd = normalize(vec3(u - iResolution.xy*.5, iResolution.y)), \n         ro = vec3(-iTime*.125, -iTime*.05, 0), l = ro + vec3(.5, -1.5, -1.);\n    \n    /*\n    // Mild perspective and lens effects.\n    r = normalize(vec3(r.xy, (r.z - length(r.xy)*.2)*1.2));\n    vec2 a = sin(vec2(1.57, 0) - 3.14159/32.);\n    r.yz = mat2(a, -a.y, a.x) * r.yz;\n    r.xz = r.xz*mat2(a, -a.y, a.x);\n    */\n\n    \n    // Raymarching against a back plane usually doesn't require many iterations -\n    // nor does it require a far-plane break - buy I've given it a few anyway.\n    float d, t = 0.;\n    \n    for(int i=0; i<64;i++){\n        \n        d = map(ro + rd*t); // Distance the nearest surface point.\n        if(abs(d)<0.001 || t>FAR) break; // The far-plane break is redundant here.\n        t += d*.86; // The accuracy probably isn't needed, but just in case.\n    }\n    \n    //t = min(t, FAR); // Capping \"t\" to the far plane. Not need here.    \n    \n    float svObjID = objID; // Store the object ID just after raymarching.\n    \n    vec3 sCol = vec3(0); // Scene color.\n    \n    // Edge and curvature variables. Passed into the normal function.\n    float edge = 0., crv = 1.;\n    \n    if(t<FAR){\n    \n        vec3 p = ro + rd*t, n = nr(p, edge, crv);//normalize(fract(p) - .5);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n\n        // Attenuation and extra shading.\n        float atten = 1./(1. + d*d*.05);\n        float shade = heightMap(p);\n        \n        \n        // Texturing. Because this is a psuedo 3D effect that relies on the isometry of the\n        // block pattern, we're texturing isometrically... groan. :) Actually, it's not that \n        // bad. Rotate, skew, repeat. You could use tri-planar texturing, but it's doesn't\n        // look quite as convincing in this instance.\n        //\n        // By the way, the blocks aren't perfectly square, but the texturing doesn't seem to\n        // be affected.\n        vec2 tuv = vec2(0);\n        vec3 q = p;\n        const mat2 mr3 = mat2(.866025, .5, -.5, .866025); // 60 degrees rotation matrix.\n        q.xy *= mr3; // Rotate by 60 degrees to the starting alignment.\n        if((n.x)>.002) tuv = vec2((q.x)*.866 - q.y*.5, q.y); // 30, 60, 90 triangle skewing... kind of.\n        q.xy *= mr3*mr3; // Rotate twice for 120 degrees... It works, but I'll improve the logic at some stage. :)\n        if (n.x<-.002) tuv = vec2((q.x)*.866 - q.y*.5, q.y);\n        q.xy *= mr3*mr3; // Rotate twice.\n        if (n.y>.002) tuv = vec2((q.x)*.866 - q.y*.5, q.y);\n        \n        // Pass in the isometric texture coordinate, roughly convert to linear space (tx*tx), and\n        // make the colors more vibrant with the \"smoothstep\" function.\n        vec3 tx = texture(iChannel0, tuv*2.).xyz;\n        tx = smoothstep(.05, .5, tx*tx);\n        \n        if(svObjID>.5) tx *= vec3(2, .9, .3); // Add a splash of color to the little blocks.\n       \n        \n        float ao = cao(p, n); // Ambient occlusion. Tweaked for the this example.\n       \n       \n        float diff = max(dot(l, n), 0.); // Diffuse.\n        float spec = pow(max(dot(reflect(l, n), rd), 0.), 6.); // Specular.\n        //diff = pow(diff, 4.)*0.66 + pow(diff, 8.)*0.34; // Ramping up the diffuse.\n        \n        \n        // Cheap way to add an extra color into the mix. Only applied to the small blocks.\n        if(svObjID>.5) {\n        \tfloat rg = dot(sin(p*6. + cos(p.yzx*4. + 1.57/3.)), vec3(.333))*.5 + .5;\n        \ttx = mix(tx, tx.zxy, smoothstep(0.6, 1., rg));\n        }\n\n        \n        // Applying the lighting.\n        sCol = tx*(diff + .5) + vec3(1, .6, .2)*spec*3.;\n        \n        \n        // Alternative, mild strip overlay.\n        //sCol *= clamp(sin(shade*6.283*24.)*3. + 1., 0., 1.)*.35 + .65;\n        \n        \n        // Adding some cheap environment mapping to help aid the illusion a little more.\n        sCol += (sCol*.75 + .25)*eMap(reflect(rd, n), n)*3.; // Fake environment mapping.\n        \n        //sCol = pow(sCol, vec3(1.25))*1.25; More contrast, if you were going for that look.\n        \n        // Using the 2D block value to provide some extra shading. It's fake, but gives it a\n        // more shadowy look.\n        sCol *= (smoothstep(0., .5, shade)*.75 + .25);\n         \n        // Applying curvature, edging, ambient occlusion and attenuation. You could apply this\n        // in one line, but I thought I'd seperate them for anyone who wants to comment them\n        // out to see what effect they have.\n        sCol *= min(crv, 1.)*.7 + .3;\n        sCol *= 1. - edge*.85;\n        sCol *= ao*atten;\n \n        \n    }\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(sCol, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltySRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4723, 4821, 4838, 4838, 5366], [5368, 5448, 5466, 5466, 5808], [5810, 6521, 6540, 6714, 8147], [8149, 8410, 8434, 8434, 8485], [8487, 8582, 8600, 8600, 8684], [8686, 8752, 8804, 8871, 9770], [9772, 9924, 9956, 9956, 10218], [10220, 10288, 10306, 10306, 10652], [10654, 10909, 10937, 10937, 11559], [11561, 11561, 11606, 11675, 16493]], "test": "error"}
{"id": "ltyXDw", "name": "Marbre veinÃ©", "author": "CocoAll", "description": "Marbre veinÃ©", "tags": ["marbrevein"], "likes": 2, "viewed": 72, "published": "Public", "date": "1484572083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 blue =vec3(0.05,0.15,0.45);\nconst vec3 green =vec3(0.09,0.48,0.21);\nconst vec3 white = vec3(1.0);\nconst vec3 black = vec3 (0.0);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(white,black,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(white,black,t);\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 marble(in vec3 p,in vec3 n)\n{\n    vec3 ret;\n    \n    // Add scaled noises\n    float t = turbulence (7.0*p,n);\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    \n    ret = mix(black,white,t);\n    \n    float veine1 = turbulence (3.0*p,n);\n    if(veine1 > 0.72 && veine1 < 0.73){\n    \tret = blue;\n    }\n    \n    float veine2 = turbulence (5.0*p,n);\n    if(veine2 > 0.37 && veine2 < 0.38){\n    \tret = green;\n    }\n    \n    float veine3 = turbulence (6.0*p,n);\n    if(veine3 > 0.67 && veine3 < 0.68){\n    \tret = vec3(0.85,0.17,0.31);\n    }\n    \n    return ret;\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+marble(p,n)*diff*lightColor;\n    \n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.4, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 156, 180, 180, 223], [225, 256, 282, 282, 651], [727, 780, 815, 815, 884], [1101, 1158, 1193, 1193, 1281], [1283, 1324, 1363, 1388, 1551], [1553, 1578, 1612, 1637, 1700], [1702, 1739, 1773, 1773, 2337], [2339, 2409, 2454, 2454, 2496], [2573, 2755, 2833, 2833, 3068], [3145, 3186, 3214, 3214, 3287], [3289, 3335, 3368, 3387, 3841], [3843, 3900, 3938, 3938, 4019], [4096, 4096, 4153, 4153, 4722]], "test": "valid"}
{"id": "ltyXWh", "name": "Camera Ray from P,V", "author": "sibaku", "description": "A simple example of how to generate world space camera rays from a given OpenGL-style projection and view matrix.", "tags": ["raytracing", "ray", "projection", "cameraray", "projectionmatrix"], "likes": 7, "viewed": 186, "published": "Public", "date": "1484084924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n*\n* This is just a simple demonstration on how to generate camera rays in world space\n* given a OpenGL-style projection and view matrix\n*\n* Most of the file is just setup to show something, like intersection code \n* and the generation of the projection and view matrix and their inverses.\n*\n* The only relevant part for this demo are the createRay and main function\n*\n*/\n\n\n#define INF 3.402823466e+38\n\n// This assumes the pixel position px to be in [0,1], \n// which can be done by (x+0.5)/w or (y+0.5)/h (or h-y +0.5 for screens\n// with top left origin) to sample pixel centers\nvec3 createRay(vec2 px, mat4 PInv, mat4 VInv)\n{\n\t \n\t// convert pixel to NDS\n\t// [0,1] -> [-1,1]\n\tvec2 pxNDS = px*2. - 1.;\n\n\t// choose an arbitrary point in the viewing volume\n\t// z = -1 equals a point on the near plane, i.e. the screen\n\tvec3 pointNDS = vec3(pxNDS, -1.);\n\n\t// as this is in homogenous space, add the last homogenous coordinate\n\tvec4 pointNDSH = vec4(pointNDS, 1.0);\n\t// transform by inverse projection to get the point in view space\n\tvec4 dirEye = PInv * pointNDSH;\n\n\t// since the camera is at the origin in view space by definition,\n\t// the current point is already the correct direction (dir(0,P) = P - 0 = P\n\t// as a direction, an infinite point, the homogenous component becomes 0\n\t// the scaling done by the w-division is not of interest, as the direction\n\t// in xyz will stay the same and we can just normalize it later\n\tdirEye.w = 0.;\n\n\t// compute world ray direction by multiplying the inverse view matrix\n\tvec3 dirWorld = (VInv * dirEye).xyz;\n\n\t// now normalize direction\n\treturn normalize(dirWorld); \n}\n\n\n\nstruct Sphere\n{\n\t\tvec3 center;\n\t\tfloat r;\n};\n\nstruct Box\n{\n\t\tvec3 bmin;\n\t\tvec3 bmax;\n};\n\n    \n// Box from center and half size\nBox makeBox(vec3 center, vec3 halfSize)\n{\n \treturn Box(center-halfSize,center + halfSize);   \n}\n\nstruct Hit\n{\n  vec3 n;\n  float t;\n    \n};\n\nvec3 computeNormalSphere(vec3 p,Sphere s)\n{\n\treturn normalize(p - s.center);\n}\nvec3 computeNormalBox(vec3 p,Box b)\n{\n    \n\t// project on edges\n\n\tvec3 center = (b.bmax + b.bmin)/2.;\n\tvec3 halfSize = (b.bmax - b.bmin)/2.;\n\tvec3 nx = vec3(1.,0.,0.);\n\tvec3 ny = vec3(0.,1.,0.);\n\tvec3 nz = vec3(0.,0.,1.);\n\n\tvec3 f1 = center + nx*halfSize.x;\n\tvec3 f2 = center - nx*halfSize.x;\n\n\tvec3 f3 = center + ny*halfSize.y;\n\tvec3 f4 = center - ny*halfSize.y;\n\n\tvec3 f5 = center + nz*halfSize.z;\n\tvec3 f6 = center - nz*halfSize.z;\n\n\n\t// compute side distance\n\tif(abs(dot(f1-p,nx)) < 0.00001)\n\t{\n\t\treturn nx;\n\t}\n\tif(abs(dot(f2-p,nx)) < 0.00001)\n\t{\n\t\treturn -nx;\n\t}\n\tif(abs(dot(f3-p,ny)) < 0.00001)\n\t{\n\t\treturn ny;\n\t}\n\tif(abs(dot(f4-p,ny)) < 0.00001)\n\t{\n\t\treturn -ny;\n\t}\n\n\tif(abs(dot(f5-p,nz)) < 0.00001)\n\t{\n\t\treturn nz;\n\t}\n\tif(abs(dot(f6-p,nz)) < 0.00001)\n\t{\n\t\treturn -nz;\n\t}\n\n\n\n\treturn normalize(vec3(1.,1.,1.));\n}\n\nbool intersectAABB(Box b, vec3 p, vec3 dir,out Hit h)\n{\n\t\tfloat tmin;\n\t\tfloat tmax;\n\t\tfloat tymin;\n\t\tfloat tymax;\n\t\tfloat tzmin;\n\t\tfloat tzmax;\n\n\t\tvec3 dirFrac = vec3(1.)/dir;\n\n\t\tvec3 bminOrig = b.bmin - p;\n\t\tvec3 bmaxOrig = b.bmax - p;\n\n\t\tvec3 bminOrigFrac = bminOrig * dirFrac;\n\t\tvec3 bmaxOrigFrac = bmaxOrig * dirFrac;\n\t\tif(dirFrac.x >= 0.)\n\t\t{\n\t\t\t\ttmin = bminOrigFrac.x;\n\t\t\t\ttmax = bmaxOrigFrac.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\ttmin = bmaxOrigFrac.x;\n\t\t\t\ttmax = bminOrigFrac.x;\n\t\t}\n\n\t\tif(dirFrac.y >= 0.)\n\t\t{\n\t\t\t\ttymin = bminOrigFrac.y;\n\t\t\t\ttymax = bmaxOrigFrac.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\ttymin = bmaxOrigFrac.y;\n\t\t\t\ttymax = bminOrigFrac.y;\n\t\t}\n\n\t\n    \tif ( (tmin> tymax)|| (tymin> tmax))\n\t\t\t\treturn false;\n    \n\t\tif (tymin> tmin)\n\t\t\t\ttmin = tymin;\n\t\tif (tymax < tmax)\n\t\t\t\ttmax = tymax;\n\n\t\tif(dirFrac.z >= 0.)\n\t\t{\n\t\t\t\ttzmin = bminOrigFrac.z;\n\t\t\t\ttzmax = bmaxOrigFrac.z;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\ttzmin = bmaxOrigFrac.z;\n\t\t\t\ttzmax = bminOrigFrac.z;\n\t\t}\n    if ( (tmin> tzmax)|| (tzmin> tmax))\n\t\t\t\treturn false;\n\t\tif (tzmin > tmin)\n\t\t\t\ttmin = tzmin;\n\t\tif (tzmax < tmax)\n\t\t\t\ttmax = tzmax;\n\n\n    \tfloat t = tmin >= 0. ? tmin : tmax;\n    \t\n    \n    \n    \n    \th = Hit(computeNormalBox(p + t*dir, b),t);\n\n\t\treturn t >= 0.;\n    \n\n}\n\nbool intersectSphere(Sphere s,vec3 p, vec3 dir,out Hit h)\n{\n\n\tvec3 oc = p - s.center;\n\n\tfloat loc = dot(dir,oc);\n\n\tfloat discr = loc*loc - dot(oc,oc) + s.r*s.r;\n\n\tif(discr < 0.)\n\t\treturn false;\n\n    float t;\n\tif(abs(discr) < 0.00001)\n\t{\n\t\tt = -loc;\n        \n\t}\n\telse{\n\t\tfloat sq = sqrt(discr);\n\t\tt = -loc - sq;\n        // if inside use outgoing one\n        t = t < 0. ? -loc + sq : t;\n        \n\t}\n\t\n    h = Hit(computeNormalSphere(p+t*dir,s),t);\n\t\n    return t >= 0.;\n\n}\n\nbool intersectScene(vec3 p, vec3 dir,out Hit h)\n{\n    Hit ht;\n    h.t = INF;\n    bool hit = false;\n    Sphere s1 = Sphere(vec3(0.,0.,0.), 1.);\n    \n    \n   \tBox b1 = makeBox(vec3(0.,-2.,0.),vec3(20.,0.5,20.));\n    Box b2 = makeBox(vec3(-3.,0.,0.), vec3(1.,1.,1.));\n    \n    if(intersectSphere(s1,p,dir,ht))\n    {\n     \th = ht;  \n        hit = true;\n    }\n    if(intersectAABB(b1,p,dir,ht) && ht.t < h.t)\n    {\n     \th = ht;  \n        hit = true;\n    }\n    if(intersectAABB(b2,p,dir,ht) && ht.t < h.t)\n    {\n     \th = ht;  \n        hit = true;\n    }\n    \n    return hit;\n    \n}\n\n\n// matrix operations\nmat4 translate(vec3 t)\n{\n \treturn mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(t,1.)\n        );\n}\nmat4 translateInv(vec3 t)\n{\n \treturn translate(-t);   \n}\n\nmat4 scale(vec3 s)\n{\n \treturn mat4(\n        vec4(s.x,0.,0.,0.),\n        vec4(0.,s.y,0.,0.),\n        vec4(0.,0.,s.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\nmat4 scaleInv(vec3 s)\n{\n \treturn scale(1./s);   \n}\n\nmat4 rightToLeft()\n{\n    // 1 0 0  0\n    // 0 1 0  0\n    // 0 0 -1 0\n    // 0 0 0  1\n \treturn scale(vec3(1.,1.,-1.));\n}\n\nmat4 rightToLeftInv()\n{\n    // same matrix\n    return rightToLeft();\n}\n\t\n\nmat4 ortho(float l, float r, float b, float t, float n, float f)\n{\n\n    \n       // translation and scale\n    return scale(vec3(2./(r-l),2./(t-b),2./(f-n))) * \n                 translate(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.));\n    \n}\n\nmat4 orthoInv(float l, float r, float b, float t, float n, float f)\n{\n    return translateInv(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.)) *\n        scaleInv(vec3(2./(r-l),2./(t-b),2./(f-n)));\n}\n\nmat4 projection(float n, float f)\n{\n \t// n 0 0 0\t0\n    // 0 n 0 0\t0\n    // 0 0 n+f\t-fn\n    // 0 0 1\t0\n    return mat4(\n        vec4(n,0.,0.,0.),\n        vec4(0.,n,0.,0.),\n        vec4(0.,0.,n+f,1.),\n        vec4(0.,0.,-f*n,0.)\n        );\n}\n\nmat4 projectionInv(float n, float f)\n{\n \t// 1/n \t0 \t0 \t\t0\n    // 0 \t1/n\t0 \t\t0\n    // 0\t0\t0 \t\t1\n    // 0\t0\t-1/fn\t(f+n)/fn\n    \n    return mat4(\n        vec4(1./n,0.,0.,0.),\n        vec4(0.,1./n,0.,0.),\n        vec4(0.,0.,0.,-1./(f*n)),\n        vec4(0.,0.,1.,(f+n)/(f*n))\n        );\n}\n\n\nmat4 perspective(float fov, float aspect, float n, float f)\n{\n \t   float l = tan(fov/2.)*n;\n       float b = l/aspect;\n    \n    \treturn ortho(-l,l,-b,b,n,f)*\n            projection(n,f)*rightToLeft();\n}\n\n\nmat4 perspectiveInv(float fov, float aspect,float n, float f)\n{\n     float l = tan(fov/2.)*n;\n       float b = l/aspect;\n    \n    return rightToLeftInv()*\n        projectionInv(n,f)*\n        orthoInv(-l,l,-b,b,n,f);\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n \t\n    vec3 z = normalize(eye-center);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = cross(z,x);\n    \n    mat4 v = mat4(\n        vec4(x.x,y.x,z.x,0.),\n        vec4(x.y,y.y,z.y,0.),\n        vec4(x.z,y.z,z.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n    \n    return v*translate(-eye);\n}\n\nmat4 lookAtInv(vec3 eye, vec3 center, vec3 up)\n{\n \tvec3 z = normalize(eye-center);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = cross(z,x);  \n    \n    return translateInv(-eye)*mat4(\n        vec4(x,0.),\n        vec4(y,0.),\n        vec4(z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  \n    \n    float aspect = iResolution.x / iResolution.y;\n \n    \n    float lightRadius = 6.;\n    float lightHeight = 5.;\n    vec3 lightPos = vec3(sin(iTime+0.5)*lightRadius,lightHeight,cos(iTime+0.5)*lightRadius);\n    \n    \n    vec3 eye = vec3(4,1.,4.);\n\n    vec2 relativeMouse = iMouse.z <= 0. ? vec2(.5/iResolution.xy) : iMouse.xy/iResolution.xy-.5;\n\teye += vec3(0.,relativeMouse.yx)*12.;\n    vec3 center = vec3(0.,1.,0.);\n   \n    \n   \n    // inverse projection and view matrices\n    mat4 PInv = perspectiveInv(radians(90.),aspect,0.1,100.);\n    mat4 VInv = lookAtInv(eye,center,vec3(0.,1.,0.));\n    \n    \n    // normalization of screen coordinates\n    // already includes +0.5\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 rayDir = createRay(uv,PInv,VInv);\n   \tHit h;\n    \n    \n    \n    \n    if(!intersectScene(eye,rayDir,h))\n    {\n        fragColor = vec4(vec3(0.2,0.2,0.2),1.0);\n    }\n    else\n    {\n        vec3 hitpoint = eye + h.t * rayDir;\n        \n        vec3 l = normalize(lightPos-hitpoint);\n        \n        \n     \tfragColor = vec4(dot(h.n,l)); \n        \n  \n        \n    }\n    \n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 581, 628, 676, 1609], [1707, 1740, 1781, 1781, 1835], [1880, 1880, 1923, 1923, 1958], [1959, 1959, 1996, 2022, 2777], [2779, 2779, 2834, 2834, 3984], [3986, 3986, 4045, 4045, 4456], [4458, 4458, 4507, 4507, 5034], [5037, 5058, 5082, 5082, 5210], [5211, 5211, 5238, 5238, 5267], [5269, 5269, 5289, 5289, 5427], [5428, 5428, 5451, 5451, 5478], [5480, 5480, 5500, 5564, 5599], [5601, 5601, 5624, 5643, 5671], [5675, 5675, 5741, 5779, 5905], [5907, 5907, 5976, 5976, 6093], [6095, 6095, 6130, 6196, 6334], [6336, 6336, 6374, 6456, 6618], [6621, 6621, 6682, 6682, 6823], [6826, 6826, 6889, 6889, 7043], [7045, 7045, 7090, 7090, 7379], [7381, 7381, 7429, 7429, 7667], [7673, 7673, 7730, 7730, 8853]], "test": "valid"}
{"id": "ltyXWR", "name": "crowded chains", "author": "FabriceNeyret2", "description": "( not sure how to be smarter with the near-plane )", "tags": ["3d", "raymarching", "spheremarching"], "likes": 12, "viewed": 758, "published": "Public API", "date": "1483799585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    float T = iTime+20., \n        closest = 999.;\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d,c; p.x-=.4; // init ray \n    r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);         // camera rotations\n    d = p;                                       // ray dir = ray0-vec3(0) \n    d = normalize(p);                            \n  //p = -normalize(p); p *= 2.2/sqrt(1.-p.z*p.z/dot(p.xyz,p.xyz)); // sin(acos(x)) = sqrt(1-x*x) // camera in free space\n  //p.z -= 2.*T;\n    p -= 6.*d;                                   // near-plane\n  //p.xy -= 2.;                                  // camera in free space\n    \n    f -= f;\n   \n    for (float i=1.; i>0.; i-=.01)  {\n        \n        vec4 u=floor(p/18.+3.5), t = p, ta,v;\n        c = p/p*1.2;\n\n\t    float x=1e9,x1=1e9;\n\n#define mod4(t)         ( mod(t+2.,4.)-2. )\n#define setbox(t,h,w,d)  abs(t)/vec4(h,w,d,1)\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z)) -(r) )\n#define dsphere(t,r)    ( length((t).xyz) -(r) )\n#define dcyl(t,r)       ( length((t).xy) -(r) )\n#define union(a,b)       min(a,b)\n#define sub(a,b)         max(a,-(b))\n        \n        ta.xy = floor((t.xy+2.)/4.),                      // chains displacement\n        t.z -= 2.*T*sign( mod(ta.x+ta.y,2.) -.5 ) ;\n\n        // --- base '+' cross section\n        ta = setbox(mod4(t),1,3,16); x =          dcyl(ta,.5);  \n        ta = setbox(mod4(t),3,1,16); x = union(x, dcyl(ta,.5) ); // ( try dbox or dcyl )\n        \n        // --- woodcut-like strategy to make a chain : progressive carving\n        \n        // NB: it's easier to use setbox(3size), dbox(.5),\n        //     but it's more stable doing setbox(3proportion>=1), dbox(r)\n        //ta = setbox(mod4(t+vec4( 0,0,2,0)), 3,1,.5);x = sub(x,  dbox(ta,.55) );\n        ta = setbox(mod4(t+vec4( 0,0,2,0)), 6,2,1);x = sub(x,  dbox(ta,.27) );\n        ta = setbox(mod4(t-vec4(.8,0,0,0)),.6,3,2); x = sub(x,  dbox(ta,.5) );\n        ta = setbox(mod4(t+vec4(.8,0,0,0)),.6,3,2); x = sub(x,  dbox(ta,.5) );\n        \n        //ta = setbox(mod4(t               ),2,6,1); x = sub(x,  dbox(ta,.27) );\n        ta = setbox(mod4(t               ),1,3,.5); x = sub(x,  dbox(ta,.55) );\n        ta = setbox(mod4(t-vec4(0,.8,2,0)),3,.6,2); x = sub(x,  dbox(ta,.5) );\n        ta = setbox(mod4(t+vec4(0,.8,2,0)),3,.6,2); x = sub(x,  dbox(ta,.5) );\n        \n        //ta = setbox(mod4(t-vec4( 0,0,1,0)),2,2,.2); x = sub(x,  dbox(ta,.55) );\n        //ta = setbox(mod4(t+vec4( 0,0,1,0)),2,2,.2); x = sub(x,  dbox(ta,.55) );\n        ta = setbox(mod4(t-vec4( 0,0,1,0)),10,10,1); x = sub(x,  dbox(ta,.12) );\n        ta = setbox(mod4(t+vec4( 0,0,1,0)),10,10,1); x = sub(x,  dbox(ta,.12) );\n       \n\n        x1 = dsphere(mod4(t),.3);          // red spheres\n        closest = min(closest, x1);        // glow footprint\n        // x = min(x1,x);                  // uncomment to display the spheres\n        if (x==x1) c  = vec4(2.,.3,0,0);\n        // if (cos(.25*T)>0.) c += vec4(2.,.3,0,0)*pow(abs((x-x1)),.2)*(.5+.5*cos(.5*T));  // glow1: thanks squid !\n\n        if (x<-.01) c = vec4(.9);          // near-plane cut parts\n        \n        \n        if(x<.01)                          // hit !\n            { f = i*i*c; break;  }         // color texture + black fog \n        \n        p -= d*x*.7;                       // march ray\n     }\n\n     f += vec4(1,0,0,0) * exp(-closest)*(.5+.5*cos(.5*T)); // glow2 - thanks kuvkar ! \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 199, 199, 3546]], "test": "valid"}
{"id": "ltyXzm", "name": "Concentric Plasma", "author": "cacheflowe", "description": "Colorful plasma", "tags": ["plasma", "concentric"], "likes": 11, "viewed": 697, "published": "Public API", "date": "1483569005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718;\n// #define FADES  1\n\nfloat saw(float rads) {\n    rads += PI * 0.5; // sync oscillation up with sin()\n    float percent = mod(rads, PI) / PI;\t\t\t\t\n    float dir = sign(sin(rads));\n    return dir * (2. * percent  - 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set time & centered position\n    float time = 10. + iTime * 0.5;\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\t// calc additive distance from control points\n    float dist = 0.;\n    for(int ii = 1; ii < 5; ii++) {\n        float i = float(ii);\n        float rads = 1.75 * sin(time / 1./i);\t// oscillate control point radius\n        float ctrlX = sin(sin(uv.x / time) + sin(uv.y + time * i) + cos(time + time) * sin(time * i));\n        float ctrlY = sin(sin(uv.y + time) + sin(uv.x + time / i) + cos(time + time) * cos(time * i));\n        vec2 ctrlPoint = rads + vec2(ctrlX, ctrlY);\n      \tdist += (10. + 7. * sin(time * 0.5)) * distance(uv, ctrlPoint);\n    }\n    // oscillate color components by distance factor. smoothstep for contrast boost\n    vec3 col = vec3(\n        smoothstep(0.1, 0.8, abs(sin(time + dist * 0.11)) * 0.5 + 0.2),\n        smoothstep(0.1, 0.8, abs(cos(time + dist * 0.22)) * 0.37 + 0.4),\n        smoothstep(0.1, 0.8, abs(sin(time + dist * 0.33)) * 0.15 + 0.4)\n    );\n\t// vignette outside of center\n    float vignetteInner = 0.75;\n    float vignetteDarkness = 0.4;\n    col -= smoothstep(0., 0.7, max(0., length(uv) - vignetteInner) * vignetteDarkness);\n    // fade in/out\n    #ifdef FADES\n        float loopSecs = 4.;\n        float fadeTime = 1.;\n        if(abs(mod(time, loopSecs)) < fadeTime * 2.) {\t\t// fade in/out for looping purposes\n            col = mix(vec3(1.), col, abs(-fadeTime + mod(time, loopSecs)));\t\n        }\n    #endif\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 103, 103, 277], [279, 279, 336, 372, 1857]], "test": "valid"}
{"id": "MlGSz3", "name": "Fourier vs Spline interpolation ", "author": "revers", "description": "Fork of iq's [url=https://www.shadertoy.com/view/4lGSDw]Fourier - interpolation[/url] that compares Fourier (green) with Catmull-Rom Spline (black) interpolation. Fourier produces more round shape but is over 3 times slower than CatmullRom on my videocard", "tags": ["2d", "spline", "fourier", "catmullrom"], "likes": 34, "viewed": 2294, "published": "Public API", "date": "1485217525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// revers: This is fork of iq's \"Fourier - interpolation\" [ https://www.shadertoy.com/view/4lGSDw ].\n//         It compares Fourier (green line) with Catmull-Rom (black line) interpolation. \n//         Fourier version produces more round shape, but is slower (over 3 times on my video card)\n//         than Catmull-Rom.\n//\n//         Comment out SHOW_CATMULL_ROM / SHOW_FOURIER to see a single curve.\n\n\n// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A set of 38 points gets interpolated by computing the DFT (Discrete Fourier Transform)\n// and then its inverse, and evaluating the it at more than 38 points. This results in\n// an interpolation sort of made of cosine/sine waves. Would be nice to do a regular\n// Hermite spline interpolation as well to compare.\n//\n// More info: http://www.iquilezles.org/www/articles/fourier/fourier.htm\n//\n// Original drawing (kind of), here:\n// https://mir-s3-cdn-cf.behance.net/project_modules/disp/831a237863325.560b2e6f92480.png\n\n\n\n//--------------------------------------------------------------------------------------\n// Additions by revers:\n\n#define SHOW_CATMULL_ROM\n#define SHOW_FOURIER\n\n/**\n * Tension. Default Catmul-Rom matrix\n * has tension equal to 0.5.\n *\n * Values below 0.5 will cause sharp edges,\n * values above 0.5 will produce more curly lines.\n */\n#define T 0.7\n\n/**\n * Catmull-Rom Matrix\n */\nconst mat4 CRM = mat4(-T,        2.0 - T,  T - 2.0,         T,\n                       2.0 * T,  T - 3.0,  3.0 - 2.0 * T,  -T,\n                      -T,        0.0,      T,               0.0,\n                       0.0,      1.0,      0.0,             0.0);\n/**\n * Catmull-Rom Spline Interpolation\n */\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n//=======================================================================================\n\nfloat sdSegmentSq(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec2 d = pa - ba * h;\n\treturn dot(d, d);\n}\n\nfloat sdPointSq(vec2 p, vec2 a) {\n\tvec2 d = p - a;\n\treturn dot(d, d);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat e = 1.0 / iResolution.x;\n\tvec2 uv = fragCoord / iResolution.x;\n    \n    vec3 col = vec3(1.0);\n\n    const int NUM = 41;\n    \n    vec2 path[NUM];\n    \n    //------------------------------------------------------\n    // path\n    //------------------------------------------------------\n    {\n        path[ 0] = vec2( 0.098, 0.062 );\n        path[ 1] = vec2( 0.098, 0.062 );\n        path[ 2] = vec2( 0.352, 0.073 );\n        path[ 3] = vec2( 0.422, 0.136 );\n        path[ 4] = vec2( 0.371, 0.085 );\n        path[ 5] = vec2( 0.449, 0.140 );\n        path[ 6] = vec2( 0.352, 0.187 );\n        path[ 7] = vec2( 0.379, 0.202 );\n        path[ 8] = vec2( 0.398, 0.202 );\n        path[ 9] = vec2( 0.266, 0.198 );\n        path[10] = vec2( 0.318, 0.345 );\n        path[11] = vec2( 0.402, 0.359 );\n        path[12] = vec2( 0.361, 0.425 );\n        path[13] = vec2( 0.371, 0.521 );\n        path[14] = vec2( 0.410, 0.491 );\n        path[15] = vec2( 0.410, 0.357 );\n        path[16] = vec2( 0.502, 0.482 );\n        path[17] = vec2( 0.529, 0.435 );\n        path[18] = vec2( 0.426, 0.343 );\n        path[19] = vec2( 0.449, 0.343 );\n        path[20] = vec2( 0.504, 0.335 );\n        path[21] = vec2( 0.664, 0.355 );\n        path[22] = vec2( 0.748, 0.208 );\n        path[23] = vec2( 0.738, 0.277 );\n        path[24] = vec2( 0.787, 0.308 );\n        path[25] = vec2( 0.748, 0.183 );\n        path[26] = vec2( 0.623, 0.081 );\n        path[27] = vec2( 0.557, 0.099 );\n        path[28] = vec2( 0.648, 0.116 );\n        path[29] = vec2( 0.598, 0.116 );\n        path[30] = vec2( 0.566, 0.195 );\n        path[31] = vec2( 0.584, 0.228 );\n        path[32] = vec2( 0.508, 0.083 );\n        path[33] = vec2( 0.457, 0.140 );\n        path[34] = vec2( 0.508, 0.130 );\n        path[35] = vec2( 0.625, 0.071 );\n        path[36] = vec2( 0.818, 0.093 );\n        path[37] = vec2( 0.951, 0.066 );\n        path[38] = vec2( 0.547, 0.081 );\n        path[39] = vec2( 0.098, 0.062 );\n        path[40] = vec2( 0.098, 0.062 );\n    }\n\n\t//------------------------------------------------------\n\t// draw path\n\t//------------------------------------------------------\n\t{\n\t\tvec2 d = vec2(1000.0);\n\t\tfor (int i = 0; i < (NUM - 1); i++) {\n\t\t\tvec2 a = path[i + 0];\n\t\t\tvec2 b = path[i + 1];\n\t\t\td = min(d, vec2(sdSegmentSq(uv, a, b), sdPointSq(uv, a)));\n\t\t}\n\t\td.x = sqrt(d.x);\n\t\td.y = sqrt(min(d.y, sdPointSq(uv, path[NUM - 1])));\n\t\tcol = mix(col, vec3(0.9, 0.2, 0.0), 1.0 - smoothstep(5.0 * e, 6.0 * e, d.y));\n\t}\n\n#ifdef SHOW_CATMULL_ROM\n\t//------------------------------------------------------\n\t// Catmull-Rom interpolation\n\t// (added by revers)\n\t//------------------------------------------------------\n\t{\n\t\tfloat d = 1e5;\n\t\tfloat ani = min(mod((12.0 + iTime) / 10.1, 1.3), 1.0) * float(NUM);\n\n\t\tvec2 p = path[0];\n\n\t\tfor (int i = 0; i < NUM - 3; i++) {\n\t\t\tfloat fi = float(i);\n\n\t\t\tif (fi > ani) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec2 A = path[i + 0];\n\t\t\tvec2 B = path[i + 1];\n\t\t\tvec2 C = path[i + 2];\n\t\t\tvec2 D = path[i + 3];\n\n\t\t\tfor (float t = 0.0; t <= 1.01; t += 0.1) {\n\t\t\t\tvec2 q = interpolate(A, B, C, D, t);\n\n\t\t\t\td = min(d, sdSegmentSq(uv, p, q));\n\t\t\t\tp = q;\n\n\t\t\t\tif (fi + t > ani) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td = sqrt(d);\n\n\t\tcol = mix(col, vec3(0.1, 0.1, 0.2), 1.0 - smoothstep(0.0 * e, 2.0 * e, d));\n\t\tcol *= 0.75 + 0.25 * smoothstep(0.0, 0.13, sqrt(d));\n\t}\n#endif\n\n#ifdef SHOW_FOURIER\n    vec2 p = uv;\n    //------------------------------------------------------\n   // compute fourier transform of the path\n   //------------------------------------------------------\n\tvec2 fcsX[20];\n\tvec2 fcsY[20];\n\tfor (int k = 0; k < 20; k++) {\n\t\tvec2 fcx = vec2(0.0);\n\t\tvec2 fcy = vec2(0.0);\n\t\tfor (int i = 1; i < NUM - 2; i++) {\n\t\t\tfloat an = -6.283185 * float(k) * float(i - 1) / float(NUM - 3);\n\t\t\tvec2 ex = vec2(cos(an), sin(an));\n\t\t\tfcx += path[i].x * ex;\n\t\t\tfcy += path[i].y * ex;\n\t\t}\n\t\tfcsX[k] = fcx;\n\t\tfcsY[k] = fcy;\n\t}\n    //------------------------------------------------------\n    // inverse transform with 6x evaluation points\n    //------------------------------------------------------\n\t{\n\t\tfloat ani = min(mod((12.0 + iTime) / 10.1, 1.3), 1.0);\n\t\tfloat d = 1000.0;\n\t\tvec2 oq;\n\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tfloat h = ani * float(i) / 256.0;\n\t\t\tvec2 q = vec2(0.0);\n\n\t\t\tfor (int k = 0; k < 20; k++) {\n\t\t\t\tfloat w = (k == 0 || k == 19) ? 1.0 : 2.0;\n\n\t\t\t\tfloat an = -6.283185 * float(k) * h;\n\t\t\t\tvec2 ex = vec2(cos(an), sin(an));\n\t\t\t\tq.x += w * dot(fcsX[k], ex) / float(NUM - 3);\n\t\t\t\tq.y += w * dot(fcsY[k], ex) / float(NUM - 3);\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\td = min(d, sdSegmentSq(p, q, oq));\n\t\t\toq = q;\n\t\t}\n\t\td = sqrt(d);\n\t\tcol = mix(col, vec3(0.1, 0.8, 0.2), 1.0 - smoothstep(0.0 * e, 2.0 * e, d));\n\t\tcol *= 0.75 + 0.25 * smoothstep(0.0, 0.13, sqrt(d));\n\t}\n#endif\n    //------------------------------------------------------\n\n\tcol *= 1.0 - 0.3 * length(fragCoord / iResolution.xy - 0.5);\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGSz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1687, 1731, 1794, 1794, 2159], [2251, 2251, 2294, 2294, 2423], [2425, 2425, 2458, 2458, 2496], [2498, 2498, 2525, 2525, 2587], [2589, 2589, 2641, 2641, 7507]], "test": "error"}
{"id": "MlGXDm", "name": "Shader Lava", "author": "Valou", "description": "Shader Lava", "tags": ["lava"], "likes": 0, "viewed": 66, "published": "Public", "date": "1484577858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// LAVE ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 lave=vec3(0.99,0.0,0.0);\nconst vec3 lavedure=vec3(0.29,0.0,0.0);\nconst vec3 brown=vec3(0.2,0.1,0.0);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(lave,brown,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(lave,brown,t);\n}\n\n// Lave\n// p : Point\n// n : Normal\nvec3 lava(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (10.0*p,n);\n   \n    if(t<0.5)\n    {\n        vec3 red = vec3(0.25,0.0,0.0);\n        float u=turbulence(25.0*p+iTime*1.0,n);\n        \n        // w= 1 sur le bord, 0 dans la lave\n        float w=2.0*t;\n        // w= 1 dans la lave 0 bord\n        w=1.0-w;\n        \n    \tvec3 lave=mix(lave,red,u);\n        lave=mix(lave,lavedure,w);\n        return lave;\n        \n    }\n\n    \n        vec3 black = vec3(0.,0.0,0.0);\n        t=turbulence(35.0*p,n);\n    \treturn mix(black,brown,t);\n\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = lava(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.25*iTime);\n    d=rotate(d,0.25*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.5, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 155, 179, 179, 222], [224, 255, 281, 281, 650], [726, 779, 814, 814, 883], [1072, 1129, 1164, 1164, 1251], [1253, 1294, 1333, 1358, 1521], [1523, 1548, 1582, 1607, 1669], [1671, 1706, 1738, 1763, 2262], [2264, 2334, 2379, 2379, 2421], [2498, 2680, 2758, 2758, 2993], [3070, 3111, 3139, 3139, 3212], [3214, 3260, 3293, 3312, 3741], [3743, 3800, 3838, 3838, 3919], [3996, 3996, 4053, 4053, 4624]], "test": "valid"}
{"id": "MlGXDw", "name": "Metal rouillÃ©", "author": "CocoAll", "description": "Metal", "tags": ["metal"], "likes": 1, "viewed": 85, "published": "Public", "date": "1484572048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 blue =vec3(0.05,0.15,0.45);\nconst vec3 green =vec3(0.09,0.48,0.21);\nconst vec3 white = vec3(1.0);\nconst vec3 black = vec3 (0.0);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(white,black,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(white,black,t);\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 marble(in vec3 p,in vec3 n)\n{    \n    // Add scaled noises\n    float t = turbulence (9.0*p,n);\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    \n    if(t > 0.97){\n        if(t<0.973)\n        {\n            return vec3(0.0,0.0,0.00);\n        }\n        else{\n            return mix(vec3(0.55,0.20,0.05),vec3(0.45,0.10,0.0),0.34557);\n        }\n    \t\n    }\n\n    return  vec3(noise(1.0*p));\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+marble(p,n)*diff*lightColor;\n    \n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.4, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 156, 180, 180, 223], [225, 256, 282, 282, 651], [727, 780, 815, 815, 884], [1101, 1158, 1193, 1193, 1281], [1283, 1324, 1363, 1388, 1551], [1553, 1578, 1612, 1637, 1700], [1702, 1739, 1773, 1802, 2167], [2169, 2239, 2284, 2284, 2326], [2403, 2585, 2663, 2663, 2898], [2975, 3016, 3044, 3044, 3117], [3119, 3165, 3198, 3217, 3671], [3673, 3730, 3768, 3768, 3849], [3926, 3926, 3983, 3983, 4552]], "test": "valid"}
{"id": "MlKSDz", "name": "Equations", "author": "Gottfried", "description": "using shaders to solve equations", "tags": ["2d", "equation"], "likes": 1, "viewed": 136, "published": "Public", "date": "1483974344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    //float x = fragCoord.x- 250.;\n\t//float y = fragCoord.y- 200.;\n    //vec2( 300., 200.);\n    //float circle = sqrt(x*x + y*y);\n    //pow(x, 2);\n    //clamp(10. -abs( len -100.), 0., 1.);\n    \n    //if( abs( len -100.) <10.){\n    //\tfragColor += vec4(1, vec3(0));\n    //}\n    \n    //fragColor =vec4( abs( len -100.) <10. , vec3(0));\n    //fragColor =vec4( 10. -abs( len -100.), vec3(0));// AA\n\n    //Geometric parameters\n    float scale= iResolution.y /2.;\n    vec2 center= fragCoord.xy -iResolution.xy /2.; \n    vec2 pos;\n    float radius= scale /1.5;\n    //float width= scale /5.;\n    float width= 40.;\n    float c;\n\n    //coloring parameters\n    //float p= scale /50.;\n    //float a= scale /1000000.;\n    //float b= scale *.0;\n    \n    float p= 1.1; //2.\n    float a= .02;\n    float b= .0;\n\n    //time parameters\n    float rate= .5;\n    float amp= scale/1.25;\n    \n    //Red Circle\n    pos= center - vec2( amp, 0.) *sin(iTime *rate *.5);\n    c= width -abs( length( pos) -radius);\n    fragColor += vec4( pow(c,p)*a +b, vec3(0.));\n    \n    //Green Circle\n    pos= center - vec2( amp, 0.) *sin(iTime *rate *2.); \n    c = width -abs( length( pos) -radius);\n    fragColor += vec4( 0., pow(c,p)*a +b, vec2(0.));\n    \n    //Blue Circle\n    pos= center - vec2( amp, 0.) *sin(iTime *rate); \n    c = width -abs( length( pos) -radius);\n    fragColor += vec4( vec2(0.), pow(c,p)*a +b, 0.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 571, 1533]], "test": "valid"}
{"id": "MlKSRy", "name": "Fractal Experiment 24", "author": "aiekick", "description": "click for see the full fractal 1/(zÂ²+c)", "tags": ["fractal", "experiment", "24"], "likes": 5, "viewed": 416, "published": "Public API", "date": "1484853638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on is shader : https://www.shadertoy.com/view/MltXz2\n\n// z * z\nvec2 zmul(vec2 a, vec2 b)\n{\n\t//return vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n    return mat2(a,-a.y,a.x)*b;\n}\n\n// 1 / z\nvec2 zinv(vec2 a)\n{\n\treturn vec2(a.x, -a.y) / dot(a,a);\n}\n\nconst float AA = 2.;\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n    \n    \n    for( float m=0.; m<AA; m++ )\n    for( float n=0.; n<AA; n++ )\n    {\n        vec2 offset = vec2(m,n) / AA - 0.5;\n        vec2 uv = ((g+offset)*2.-si)/min(si.x,si.y) ;\n        uv *= 30. * (sin(10.6+iTime * 0.01)*.5+.5);//zoom\n        uv += vec2(-0.2985584,0.558329);\n        if (iMouse.z > 0.)\n            uv = ((g+offset)*2.-si)/min(si.x,si.y) * 2.;\n        vec2 z = uv;\n        vec2 c = vec2(0.59,0.8596);\n        float it = 0.;\n        for (int i=0;i<600;i++)\n        {\n            z = zinv(zmul(z, z) + c);\n            if( log2(log2(dot(z,z)))>1.3 ) break;\n            it++;\n        }\n        if (it <  99.5)\n        {\n        \tfloat sit = it - log2(dot(zinv(0.1/z),zinv(0.1/z)));\n        \tfragColor += 0.5 + 0.5*cos( 3.0 + sit*0.075 + vec4(0.0,0.6,1.0,1.0));\n        }\n    }\n    \n    fragColor /= AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 72, 99, 149, 182], [184, 193, 212, 212, 250], [278, 278, 335, 335, 1236]], "test": "valid"}
{"id": "MlKSWm", "name": "Sparks drifting", "author": "Sjeiti", "description": "Particles by modulo (could use some speed optimisations):\n- divide space into grid by mod\n- rotate radial gradient inside grid cell by time + prng(grid index)\n- distort by interpolated noise because spherical sparks look stupid", "tags": ["procedural", "fire", "particles", "sparks"], "likes": 228, "viewed": 8185, "published": "Public", "date": "1484686007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//\t\t\t\t\t\t\t noise functions.\n//\t\t\tAuthor : Ian McEwan, Ashima Arts.\n//\tMaintainer : ijm\n//\t\t Lastmod : 20110822 (ijm)\n//\t\t License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//\t\t\t\t\t\t\t Distributed under the MIT License. See LICENSE file.\n//\t\t\t\t\t\t\t https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n\t\t return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n\t{ \n\tconst vec2\tC = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4\tD = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n\tvec3 i\t= floor(v + dot(v, C.yyy) );\n\tvec3 x0 =\t v - i + dot(i, C.xxx) ;\n\n// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min( g.xyz, l.zxy );\n\tvec3 i2 = max( g.xyz, l.zxy );\n\n\t//\t x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//\t x1 = x0 - i1\t+ 1.0 * C.xxx;\n\t//\t x2 = x0 - i2\t+ 2.0 * C.xxx;\n\t//\t x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;\t\t\t// -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n\ti = mod289(i); \n\tvec4 p = permute( permute( permute( \n\t\t\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t\t\t + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t\t\t + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3\tns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\t//\tmod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ );\t\t// mod(j,N)\n\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\tvec3 p0 = vec3(a0.xy,h.x);\n\tvec3 p1 = vec3(a0.zw,h.y);\n\tvec3 p2 = vec3(a1.xy,h.z);\n\tvec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n\t//vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tvec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n\t}\n\n//////////////////////////////////////////////////////////////\n\n// PRNG\n// From https://www.shadertoy.com/view/4djSRW\nfloat prng(in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n//////////////////////////////////////////////////////////////\n\nfloat PI = 3.1415926535897932384626433832795;\n\nfloat noiseStack(vec3 pos,int octaves,float falloff){\n\tfloat noise = snoise(vec3(pos));\n\tfloat off = 1.0;\n\tif (octaves>1) {\n\t\tpos *= 2.0;\n\t\toff *= falloff;\n\t\tnoise = (1.0-off)*noise + off*snoise(vec3(pos));\n\t}\n\tif (octaves>2) {\n\t\tpos *= 2.0;\n\t\toff *= falloff;\n\t\tnoise = (1.0-off)*noise + off*snoise(vec3(pos));\n\t}\n\tif (octaves>3) {\n\t\tpos *= 2.0;\n\t\toff *= falloff;\n\t\tnoise = (1.0-off)*noise + off*snoise(vec3(pos));\n\t}\n\treturn (1.0+noise)/2.0;\n}\n\nvec2 noiseStackUV(vec3 pos,int octaves,float falloff,float diff){\n\tfloat displaceA = noiseStack(pos,octaves,falloff);\n\tfloat displaceB = noiseStack(pos+vec3(3984.293,423.21,5235.19),octaves,falloff);\n\treturn vec2(displaceA,displaceB);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\tfloat time = iTime;\n\t\tvec2 resolution = iResolution.xy;\n\tvec2 drag = iMouse.xy;\n\tvec2 offset = iMouse.xy;\n\t\t//\n\tfloat xpart = fragCoord.x/resolution.x;\n\tfloat ypart = fragCoord.y/resolution.y;\n\t//\n\tfloat clip = 210.0;\n\tfloat ypartClip = fragCoord.y/clip;\n\tfloat ypartClippedFalloff = clamp(2.0-ypartClip,0.0,1.0);\n\tfloat ypartClipped = min(ypartClip,1.0);\n\tfloat ypartClippedn = 1.0-ypartClipped;\n\t//\n\tfloat xfuel = 1.0-abs(2.0*xpart-1.0);//pow(1.0-abs(2.0*xpart-1.0),0.5);\n\t//\n\tfloat timeSpeed = 0.5;\n\tfloat realTime = timeSpeed*time;\n\t//\n\tvec2 coordScaled = 0.01*fragCoord - 0.02*vec2(offset.x,0.0);\n\tvec3 position = vec3(coordScaled,0.0) + vec3(1223.0,6434.0,8425.0);\n\tvec3 flow = vec3(4.1*(0.5-xpart)*pow(ypartClippedn,4.0),-2.0*xfuel*pow(ypartClippedn,64.0),0.0);\n\tvec3 timing = realTime*vec3(0.0,-1.7,1.1) + flow;\n\t//\n\tvec3 displacePos = vec3(1.0,0.5,1.0)*2.4*position+realTime*vec3(0.01,-0.7,1.3);\n\tvec3 displace3 = vec3(noiseStackUV(displacePos,2,0.4,0.1),0.0);\n\t//\n\tvec3 noiseCoord = (vec3(2.0,1.0,1.0)*position+timing+0.4*displace3)/1.0;\n\tfloat noise = noiseStack(noiseCoord,3,0.4);\n\t//\n\tfloat flames = pow(ypartClipped,0.3*xfuel)*pow(noise,0.3*xfuel);\n\t//\n\tfloat f = ypartClippedFalloff*pow(1.0-flames*flames*flames,8.0);\n\tfloat fff = f*f*f;\n\tvec3 fire = 1.5*vec3(f, fff, fff*fff);\n\t//\n\t// smoke\n\tfloat smokeNoise = 0.5+snoise(0.4*position+timing*vec3(1.0,1.0,0.2))/2.0;\n\tvec3 smoke = vec3(0.3*pow(xfuel,3.0)*pow(ypart,2.0)*(smokeNoise+0.4*(1.0-noise)));\n\t//\n\t// sparks\n\tfloat sparkGridSize = 30.0;\n\tvec2 sparkCoord = fragCoord - vec2(2.0*offset.x,190.0*realTime);\n\tsparkCoord -= 30.0*noiseStackUV(0.01*vec3(sparkCoord,30.0*time),1,0.4,0.1);\n\tsparkCoord += 100.0*flow.xy;\n\tif (mod(sparkCoord.y/sparkGridSize,2.0)<1.0) sparkCoord.x += 0.5*sparkGridSize;\n\tvec2 sparkGridIndex = vec2(floor(sparkCoord/sparkGridSize));\n\tfloat sparkRandom = prng(sparkGridIndex);\n\tfloat sparkLife = min(10.0*(1.0-min((sparkGridIndex.y+(190.0*realTime/sparkGridSize))/(24.0-20.0*sparkRandom),1.0)),1.0);\n\tvec3 sparks = vec3(0.0);\n\tif (sparkLife>0.0) {\n\t\tfloat sparkSize = xfuel*xfuel*sparkRandom*0.08;\n\t\tfloat sparkRadians = 999.0*sparkRandom*2.0*PI + 2.0*time;\n\t\tvec2 sparkCircular = vec2(sin(sparkRadians),cos(sparkRadians));\n\t\tvec2 sparkOffset = (0.5-sparkSize)*sparkGridSize*sparkCircular;\n\t\tvec2 sparkModulus = mod(sparkCoord+sparkOffset,sparkGridSize) - 0.5*vec2(sparkGridSize);\n\t\tfloat sparkLength = length(sparkModulus);\n\t\tfloat sparksGray = max(0.0, 1.0 - sparkLength/(sparkSize*sparkGridSize));\n\t\tsparks = sparkLife*sparksGray*vec3(1.0,0.3,0.0);\n\t}\n\t//\n\tfragColor = vec4(max(fire,sparks)+smoke,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKSWm.jpg", "access": "shaders20k", "license": "mit", "functions": [[365, 365, 386, 386, 434], [436, 436, 457, 457, 505], [507, 507, 529, 529, 567], [569, 569, 597, 597, 648], [650, 650, 673, 673, 2805], [2871, 2925, 2951, 2951, 3101], [3214, 3214, 3267, 3267, 3658], [3660, 3660, 3725, 3725, 3896], [3898, 3898, 3955, 3955, 6557]], "test": "valid"}
{"id": "MlKSzm", "name": "Growing Mandelbulb", "author": "geoff", "description": "The mandelbulb's power is increased over time, showing how higher powers of the fractal are related to smaller ones. Rotate the fractal with the mouse.", "tags": ["fractal"], "likes": 1, "viewed": 512, "published": "Public API", "date": "1483673294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\tThe BRDF used in this shader is based on those used by Disney and Epic Games.\n\t\n\tThe input parameters and individual components are modelled after the ones\n\tdescribed in\n\n\t\thttps://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n\tThe various components are then combined based on Disney's PBR shader, found here\n\n\t\thttps://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\t\n\tI'd recommend reading this for a description of what the parameters in this BRDF do\n\n\t\thttp://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\n\t\n*/\n\n#define ITERS 20\n#define POWER ((iTime / 5.0) + 1.0)\n#define BAILOUT 2.0\n\n//Ray march detail - lower numbers increase detail\n#define DETAIL 0.5\n\n#define OCC_STRENGTH 4.0\n#define OCC_ITERS 25\n\n\nfloat closeObj = 0.0;\nconst float PI = 3.14159;\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nmat3 rotZ(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c,  -s, 0.0,\n                  s,   c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n//From http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandelbulb(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < ITERS ; i++) {\n\t\tr = length(z);\n\t\tif (r>BAILOUT) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, POWER-1.0)*POWER*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,POWER);\n\t\ttheta = theta*POWER;\n\t\tphi = phi*POWER;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n    \nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\n\nfloat lastx = radians(180.0);\nfloat lasty = 0.0;\n\nvec2 mapMat(vec3 p){\n    \n    //Map\n    mat3 mouserot = rotZ(radians(lastx) / 1.5) * rotX(radians(lasty) / 1.5);\n     \n    vec2 bulb = vec2(mandelbulb(mouserot * p), 3.0);\n    \n    return bulb;\n}\n\n//Returns the min distance\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    float d = 0.0;\n    float w = 1.3;\n    float ld = 0.0;\n    float ls = 0.0;\n    float s = 0.0;\n    float cerr = 10000.0;\n    float ct = 0.0;\n    float pixradius = DETAIL / iResolution.y;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 512; i++){\n        ld = d;\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        \n        //Detect intersections missed by over-relaxation\n        if(w > 1.0 && abs(ld) + abs(d) < s){\n            s -= w * s;\n            w = 1.0;\n            t += s;\n            continue;\n        }\n        s = w * d;\n        \n        float err = d / t;\n        \n        if(abs(err) < abs(cerr)){\n            ct = t;\n            cerr = err;\n        }\n        \n        //Intersect when d / t < one pixel\n        if(abs(err) < pixradius){\n            inter = 1;\n            break;\n        }\n        \n        t += s;\n        if(t > 20.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(cerr < 0.2 && inter != 1){\n    \tct = -2.0;\n        closeObj = cerr;\n    }else if(inter == 0){\n        ct = -1.0;\n    }\n    return ct;\n}\n\n//Approximate normal\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0);\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < OCC_ITERS; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(occ * OCC_STRENGTH, 0.0, 1.0);\n}\n\nvec3 colour(vec3 p, float id){\n    \n    if(id == 1.0){\n       return vec3(0.0);\n    }\n    \n    vec3 n = normal(p);\n    \n    float o = occlusion(p, n);\n    return vec3(o);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 0.0, -2.5);\n    \n    lastx += iMouse.x - 0.5;\n\tlasty += iMouse.y - 0.5;\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv, 1.5));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(1.0);\n    //If intersected\n    if(d > 0.0){\n        //Colour the point\n        col = colour(c, closeObj);\n        col *= 1.0 / exp(d * 0.25);\n    }else if(d == -2.0){\n        col = vec3(0.25) * (1.0 / exp(closeObj * 600.0));\n    }else{\n        col = vec3(0.0);\n    }\n    \n    col = pow( col, vec3(0.4545) );\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[867, 867, 886, 886, 1027], [1029, 1029, 1048, 1048, 1189], [1191, 1191, 1210, 1210, 1350], [1352, 1482, 1510, 1510, 2033], [2039, 2039, 2067, 2067, 2127], [2180, 2180, 2200, 2215, 2375], [2377, 2404, 2422, 2422, 2448], [2450, 2450, 2480, 2480, 3562], [3564, 3585, 3605, 3605, 3881], [3909, 3909, 3943, 3943, 4208], [4210, 4210, 4240, 4240, 4385], [4387, 4387, 4443, 4443, 5129]], "test": "valid"}
{"id": "MlKXWm", "name": "Distance Blobs", "author": "cacheflowe", "description": "A wannabe reaction-diffusion, but not at all :-P ", "tags": ["blobs", "distance"], "likes": 16, "viewed": 979, "published": "Public API", "date": "1484693681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.;\t\t\t\t\t\t\t\t\t// adjust time\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    float timeOsc = sin(time) * 0.05;\t\t\t\t\t\t\t\t// oscillation helper\n    float dist = 0.;\t\t\t\t\t\t\t\t\t\t\t\t// start distance count from 0\n    for(float i=10.; i < 60.; i++) {\t\t\t\t\t\t\t\t// create x control points\n        float rads = timeOsc + i;\t\t\t\t\t\t\t\t\t// get rads for control point\n        vec2 ctrlPoint = vec2(sin(rads), cos(rads));\t\t\t\t// control points in a circle \n        ctrlPoint *= abs(cos(rads)) * 5.;\t\t\t\t\t\t\t// oscillate control point radius - the magic happens w/abs()\n        dist += sin(i + 35. * distance(uv, ctrlPoint));\t\t\t\t// sum up oscillated distance between control points\n    }\n\tfragColor = vec4(vec3(dist),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 821]], "test": "valid"}
{"id": "MlKXzK", "name": "Foggy Snow Field", "author": "clayjohn", "description": "This is an experiment in using raymarching to design a simple scene with nice lighting. It is supposed to look like a farmers field as you drive by.", "tags": ["raymarching", "field", "snow"], "likes": 9, "viewed": 701, "published": "Public API", "date": "1485128919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nI wanted to practice designing scenes use SDF and raymarching so I threw this together over \nthe last few days to see what I could come up with. its just a simple plane for the\nground and some normal mapping. Lots of code is borrowed or adapted from other\nshaders here on the site.\n\nMost heavily used:\nhttps://www.shadertoy.com/view/MtdSRn\nhttps://www.shadertoy.com/view/Xds3zN\n*/\n\n\nfloat hash(vec2 p) {\n  p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(vec2 x) {\n  vec2 p = floor(x);\n  vec2 f = fract(x);\n  f = f*f*f*((6.0*f-15.0)*f+10.0);\n  vec2 a = vec2(0.0, 1.0);\n  float h = mix(mix(hash(p+a.xx), hash(p+a.yx), f.x), \n                mix(hash(p+a.xy), hash(p+a.yy), f.x), f.y);\n\n  return h;\n}\n\nfloat groundDetail(vec2 x) {\n  float h = 0.0;\n  float a = 0.5;\n  float p = 1.0;\n  h = smoothstep(0.5, 1.0, noise(x*0.05))*2.0;\n  for (int i = 0;i < 3;i++) {\n    h+= noise(x*p)*abs(a);\n    p*=2.0;\n    a*=-0.5;\n  }\n\n  return h+cos(x.y*0.5)+sin((x.x+x.y)*0.4);\n}\n\n//sdPrimitives borrowed from iqs raymarching primitives\n//https://www.shadertoy.com/view/Xds3zN\n//and from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//from iq's smin article\n//http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 postPos(vec3 p) {\n  return mod(p, vec3(2.0, 0.0, 0.0))-(vec3(1.0, 0.25, 2.0));\n}\n\nfloat groundDistance(vec3 p) {\n  float bfact =0.3;\n  vec3 post = postPos(p+vec3(0.05, 0.25, 0.0));\n  return smin( p.y, length(post)-0.01, bfact );\n}\n\nfloat postDistance(vec3 p) {\n  float dist1 = sdCylinder(postPos(p), vec2(0.035, 0.25));\n\n  return dist1;\n}\n\nfloat wireDistance(vec3 p) {\n  float h = -abs(cos(p.x*3.14159/2.0))*0.05-0.07;\n  float d = 1.0;\n  for (int i=0;i<3;i++) {\n    h+= sin(p.x+float(i)*17.49)*0.03;\n  d = min(sdCapsule(postPos(p), vec3(-2.0, h+float(i)*0.1, .0), vec3(2.0, h+float(i)*0.1, .0), 0.002), d);\n  }\n  return d;\n}\n\n// Distance to ground, posts, and wire\nvec2 map(vec3 p) { \n  vec2 d = opU( vec2(groundDistance(p), 1.0), \n             vec2(postDistance(p), 2.0)) ; \n  d = opU(d, vec2(wireDistance(p), 3.0));\n  return d;\n}\n\nfloat detail(vec3 p) { \n    return (p.y - groundDetail(p.xz*32.0)*0.002); \n}\n\n//normal functions adapted from Shane\n//https://www.shadertoy.com/view/MtdSRn\nvec3 normalMap(in vec3 p){\n  \n    vec2 e = vec2(-1., 1.)*.001;  \n    \n\tfloat d1 = detail(p + e.yxx), d2 = detail(p + e.xxy);\n\tfloat d3 = detail(p + e.xyx), d4 = detail(p + e.yyy); \n    \n    vec3 n1 = normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );\n\treturn n1;   \n}\n\nvec3 normal(in vec3 p){\n  \n    vec2 e = vec2(-1., 1.)*.001;  \n    \n\tfloat d1 = map(p + e.yxx).x, d2 = map(p + e.xxy).x;\n\tfloat d3 = map(p + e.xyx).x, d4 = map(p + e.yyy).x; \n    \n    vec3 n1 = normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );\n\treturn n1;   \n}\n\n//adapted from iq's raymarching primitives\n//https://www.shadertoy.com/view/Xds3zN\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, h*54.0 );\n        t += clamp( h, 0.001, 0.1 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return smoothstep(0.05, 0.2, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime;\n    \n    //uncomment to move camera and look around\n  vec2 m = vec2(0.5);//(2.0*(iMouse.xy-(iResolution.xy*0.5)));\n  // Unit direction ray.\n  vec3 rd = normalize(vec3(fragCoord.xy - iResolution.y*.5+m, iResolution.y));\n  \n  // most of the main ray marching block is borrowed from Shane\n  //https://www.shadertoy.com/view/MtdSRn\n  vec3 ro = vec3(time*.4, .5, .2);\n  vec2 d = vec2(0.0);\n  float t = 0.0;\n  for(int i=0; i<32; i++) {\n\td = map(ro + rd*t); \n    \n    if(abs(d.x)<.001*(t*.125 + 1.) || t>10.) break; \n    \n    t += d.x;\n  }\n  //location of intersection\n  vec3 sp = ro + rd*t;\n  // light direction  \n  vec3 ld = normalize(vec3(-0.276, cos(time)*0.35+0.3, 0.613));  \n  //color of the sun\n  vec3 sun = mix(vec3(1.0, .9, 0.7), vec3(1.0, 1.0, 0.95), ld.y);\n  //fog color, runs from white to color of sky\n  // then mixs in the sunset color based on height of sun\n  vec3 fog = mix(vec3(1.0), vec3(.65, .77, .98), smoothstep(0.0, 0.5, rd.y));\n  vec3 sunset = mix(vec3(1.04, 0.9, 0.7), vec3(1.04, .95, .87), smoothstep(0.0, 0.2, ld.y+(rd.y)));\n  \n  fog = mix(fog, sunset, smoothstep(.8, .99, pow(dot(rd, ld), 0.6*rd.y+ld.y*2.0)));\n\n  //sky color with sun mixed in\n  vec3 sky = mix(vec3(.65, .77, .98), sun, smoothstep(.98,1.0, pow(dot(rd, ld), 4.0)));\n\n  //checks type of material intersected with and applys lighting based on that\n  vec3 col;\n  //snow\n  if (d.y<1.9) {\n  vec3 n = mix(normalMap(sp), vec3(0., 1., 0.), smoothstep(3.0, 6.0, t));\n    \n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(reflect(rd, n), ld), 0.), 32.)*0.6;\n\n  dif *= shadow(sp, ld, 0.02, 2.0);\n  col = sun*sun*spe+mix(sunset, vec3(0.9, 0.9, 1.0), ld.y*2.0)*dif;\n  } else if (d.y<2.5) { //posts\n    vec3 n = normal(sp);\n    \n    float dif = max(dot(ld, n), 0.0); \n    \n    col = mix(sunset*sunset, vec3(0.5, 0.3, 0.05), ld.y*2.0)*dif;\n  } else if (d.y>2.5) { //wire\n   \tvec3 n = normal(sp);\n    \n    float dif = max(dot(ld, n), 0.0); \n    float spe = pow(max(dot(reflect(rd, n), ld), 0.), 4.)*0.5;\n    \n    col = sun*sun*spe+mix(sunset*sunset, vec3(0.7), ld.y*2.0)*dif;\n  }\n  //mix the ground with the sky based on distance\n  col = mix(col, sky, smoothstep(5.95, 6.0, t*ld.y));\n  //mix the fog in overtop of everything else\n  vec3 c = mix(col, fog*fog, smoothstep(0.0, 1.5, t*0.2));\n\n  fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[387, 387, 407, 407, 500], [502, 502, 523, 523, 757], [759, 759, 787, 787, 1018], [1020, 1198, 1229, 1229, 1320], [1322, 1322, 1358, 1358, 1457], [1459, 1459, 1511, 1511, 1638], [1640, 1640, 1670, 1670, 1703], [1705, 1785, 1826, 1826, 1919], [1921, 1921, 1943, 1943, 2006], [2008, 2008, 2038, 2038, 2156], [2158, 2158, 2186, 2186, 2264], [2266, 2266, 2294, 2294, 2550], [2552, 2591, 2609, 2609, 2757], [2759, 2759, 2781, 2781, 2835], [2837, 2915, 2941, 2941, 3186], [3188, 3188, 3211, 3211, 3452], [3454, 3537, 3607, 3607, 3870], [3872, 3872, 3929, 3929, 6254]], "test": "valid"}
{"id": "MlVSDD", "name": "planets", "author": "sanctify", "description": "planets", "tags": ["planets"], "likes": 1, "viewed": 93, "published": "Public", "date": "1484494359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define T iTime\n\n// Falloff : attenuation en fonction de la distance\n// x : distance\n// r : distance limite\n// a : coefficient de ponderation\nfloat Falloff(in float x,in float r,in float a)\n{\n    if (x<r)\n    {\n        float t = x / r;\n        return a*(1.0-t*t)*(1.0-t*t)*(1.0-t*t);\n    }\n    else \n    {\n        return 0.0;\n    }\n}\n\n// Cercle\n// c  : Centre\n// r  : Rayon\n// cc : Couleur cercle\n// uv : position pixel\nvec4 Circle(in vec2 c,in float r,in vec4 cc, in vec2 uv)\n{\n  float l=length(uv-c);\n  \n  // Dans le cercle si distance < rayon\n  if (l<r)\n  {\n    return Falloff(l,r,1.0)*cc;\n  }\n  // Else ancienne couleur\n  else\n  {\n    return vec4(0.0);\n  }\n}\n\n// Cercle\n// c  : Centre\n// r  : Rayon\n// cc : Couleur cercle\n// uv : position pixel\n// old : ancienne couleur\nvec4 Trajectoire(in vec2 c,in float r,in vec4 cc, in vec2 uv)\n{\n  float l=length(uv-c);\n  \n  if (l<r)\n  {\n      if (abs(l-r)<1./iResolution.y)\n     {\n     \treturn vec4(1.0,1.0,1.0,1.0);\n     }\n     else{\n      \treturn vec4(0.0);\n     }\n  }\n  else{\n    return vec4(0.0);\n  }\n}\n\nvec2 RandomPoint(in float k)\n{\n    vec2 vec = vec2(cos(350.0*k),sin(225.0*k));\n        return vec;\n}\n\nfloat RandomRadius(in float k)\n{\n    return 0.25+0.125*sin(258.5*k);\n}\nfloat RandomOffset(in float k)\n{\n    return 3.14*(1.0+sin(158.5*k));\n}\n\n\nbool isOnEllipse(vec2 uv, vec2 c, vec2 dim, float angle,float deltaX, float deltaY)\n{\n    uv *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    uv.x -= deltaX;\n    uv.y += deltaY;\n\tc = pow(abs(uv - c)/ dim, vec2(2));\n\tfloat d = c.x/0.45 + c.y/0.90;\n    return d < 1. && d > .98;\n}\n\n// Image \nvoid mainImage( out vec4 c, in vec2 p )\n{\n  //ellipse parameters \n   vec2 uv = 2. * p / R - 1.;\n   uv.x *= R.x / R.y;\n   c.rgb = vec3(0);\n   vec2 center = vec2(0, 0);\n   vec2 dim = vec2(.5, 1); \n\n    \n  // CoordonnÃ©es sur [.,.] x [-0.5,0.5]\n  uv = (p.xy-iResolution.xy/vec2(1.25)) / iResolution.y;\n\n  vec2 q=RandomPoint(2.0)+0.125;\n  //Creation du soleil\n  c = c+Circle(q,0.45,vec4(1.0,0.85,0.0,1.0),uv-0.25);\n  c= c+Trajectoire(q,0.34,vec4(1.0,0.85,0.0,1.0),uv-0.25);\n    \n  //GÃ©nÃ©ration des ellipses \n  if (isOnEllipse(uv, center-0.15, dim*.425, 0.75,0.02,0.225)){\n      c.rgb = vec3(1, 1, 1);\n  }\n  if (isOnEllipse(uv, center-0.15, dim*.425, 0.75,0.02,0.575)){\n      c.rgb = vec3(1, 1, 1);\n  }\n  //Fin de gÃ©nÃ©ration des Ellipses\n\n    \n  //Planete Bleue\n  q=RandomPoint(2.0) + RandomRadius(1.25)*vec2(sin(1.25*T),cos(1.25*T+RandomOffset(2.0)));\n  c = c+Circle(q+0.25,0.05,vec4(0.0,0.0,1.0,1.0),uv-0.25);\n  \n    \n  //Planete rose\n  q=RandomPoint(2.0) + RandomRadius(1.25)*vec2(sin(1.125*T),cos(1.125*T+RandomOffset(2.0)));\n  c = c+Circle(q+0.25,0.05,vec4(0.55,0.0,1.0,1.0),uv);\n\n    \n  //Planete verte + orbite + satellite\n  q=RandomPoint(2.0)+0.125;\n  q=q + RandomRadius(1.0)*vec2(sin(0.75*T),cos(0.75*T+RandomOffset(1.0)));\n  c = c+Circle(q+0.25,0.15,vec4(0.0,1.0,0.0,1.0),uv);\n  c= c+Trajectoire(q+0.25,0.15,vec4(0.0,1.0,0.0,1.0),uv);\n    \n  q=q + RandomRadius(-0.125)*vec2(sin(5.5*T),cos(5.5*T+RandomOffset(1.0)));  \n  c = c+Circle(q+0.25,0.025,vec4(0.0,1.0,0.0,1.0),uv);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 167, 216, 216, 358], [360, 445, 503, 503, 687], [689, 800, 863, 863, 1075], [1077, 1077, 1107, 1107, 1177], [1179, 1179, 1211, 1211, 1249], [1250, 1250, 1282, 1282, 1320], [1323, 1323, 1408, 1408, 1614], [1616, 1626, 1667, 1691, 3114]], "test": "valid"}
{"id": "MlVSDW", "name": "Grid Noise Warp", "author": "cacheflowe", "description": "Warping a grid with noise", "tags": ["grid", "warp"], "likes": 18, "viewed": 999, "published": "Public API", "date": "1484459853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718\n\n// 2D Random\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.;\t\t\t\t\t\t\t\t\t// adjust time\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    float dist = pow(length(uv), 0.5);\n    float uvDeformMult = 1. + dist * cos(noise(uv * 2.) + 2. * noise(uv * 3.) + time);\n    uv *= 1. + 0.15 * sin(time) * uvDeformMult;\n    float divisor = 12.;\n    float col = min(\n        smoothstep(0.1, 0.25, abs(sin(uv.x * divisor))),\n        smoothstep(0.1, 0.25, abs(sin(uv.y * divisor)))\n    );\n\tfragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 72, 99, 99, 174], [176, 263, 289, 289, 624], [626, 626, 683, 683, 1198]], "test": "valid"}
{"id": "MlVSRD", "name": "Chill Out Sculptur", "author": "dee909", "description": "Just a relaxing scuptur :)\n\nModeled with http://stephaneginier.com/archive/editSDF/", "tags": ["relaxsculpturdee909"], "likes": 6, "viewed": 176, "published": "Public", "date": "1483400207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADERTOY\n#define SHADERTOY_ZOOM 1.0\n#define BLEND_COLOR\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\nvarying vec2 vUV;\nuniform mat4 uBaseTransform;\nuniform vec3 uBaseColor;\nuniform vec3 uBaseMod;\nuniform vec3 uEllipsoidSides;\nuniform float uRoundRadius;\nuniform float uChamferRadius;\nuniform vec2 uColumns;\nuniform vec2 uStairs;\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + .5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  } \n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  vec4 tmpPrim_156 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);\nvec4 tmpPrim_157 = vec4(sdTorus(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-2.41)), vec2(1.49,0.26)) * 1.0, vec3(0.845866875,0.85,0.7983359375));\nvec4 tmpComb_399 = opUnion(tmpPrim_156, tmpPrim_157);\nvec4 tmpPrim_158 = vec4(sdTorus(pMod((mat4(1.0101120471954346,0.28705546259880066,0.0,0.0,-0.28705546259880066,1.0101120471954346,0.0,0.0,0.0,0.0,1.0501081943511963,0.0,0.06102079153060913,-0.21472446620464325,-0.2601988911628723,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(1.36,0.5)) * 0.9522828440977849, vec3(0.845866875,0.85,0.7983359375));\nvec4 tmpComb_400 = tmpComb_399;\nvec4 tmpComb_401 = opSubStairs(tmpComb_400, tmpPrim_158, vec2(0.17,1.69));\nvec4 tmpPrim_159 = vec4(sdEllipsoid(pMod((mat4(0.25112131237983704,-0.2825120985507965,-0.9258104562759399,0.0,0.7474100589752197,0.6643630266189575,4.644800100095381e-9,0.0,0.6150742173194885,-0.6919600367546082,0.3779881000518799,0.0,0.362551212310791,-0.4078710079193115,0.268617182970047,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.5,1.52,0.5)) * 1.0000000012999473, vec3(0.46729687500000006,0.5884537500000001,0.9));\nvec4 tmpComb_402 = tmpComb_401;\nvec4 tmpComb_403 = opUnionStairs(tmpComb_402, tmpPrim_159, vec2(0.84,1.62));\nvec4 tmpPrim_160 = vec4(sdTorus(pMod((mat4(0.5727498531341553,0.8041792511940002,-0.15891283750534058,0.0,-0.8191083073616028,0.5539072751998901,-0.14915919303894043,0.0,-0.03192776069045067,0.21559768915176392,0.9759598970413208,0.0,0.701280951499939,-0.5455323457717896,0.421924889087677,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(1.09,0.07)) * 0.9999999171907704, vec3(0.6595734375,0.9299999999999999,0.8326464374999999));\nvec4 tmpComb_404 = tmpComb_403;\nvec4 tmpComb_405 = opUnionRound(tmpComb_404, tmpPrim_160, 0.14);\nvec4 tmpPrim_161 = vec4(sdEllipsoid(pMod((mat4(1.0,0.0,0.0,0.0,0.0,0.9679820537567139,-0.25101903080940247,0.0,0.0,0.25101903080940247,0.9679820537567139,0.0,0.4602626860141754,-1.420561671257019,0.592455267906189,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.71,0.4,1.0)) * 1.0, vec3(0.6006421874999999,0.97,0.8370311874999998));\nvec4 tmpComb_406 = tmpComb_405;\nvec4 tmpComb_407 = opSubColumns(tmpComb_406, tmpPrim_161, vec2(0.17,7.97));\nreturn tmpComb_407;\n}\n\nfloat mapDistance(const in vec3 point) {\n  float tmpComb_408 = opUnion(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdTorus(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-2.41)), vec2(1.49,0.26)) * 1.0);\nfloat tmpComb_409 = tmpComb_408;\nfloat tmpComb_410 = opSubStairs(tmpComb_409, sdTorus(pMod((mat4(1.0101120471954346,0.28705546259880066,0.0,0.0,-0.28705546259880066,1.0101120471954346,0.0,0.0,0.0,0.0,1.0501081943511963,0.0,0.06102079153060913,-0.21472446620464325,-0.2601988911628723,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(1.36,0.5)) * 0.9522828440977849, vec2(0.17,1.69));\nfloat tmpComb_411 = tmpComb_410;\nfloat tmpComb_412 = opUnionStairs(tmpComb_411, sdEllipsoid(pMod((mat4(0.25112131237983704,-0.2825120985507965,-0.9258104562759399,0.0,0.7474100589752197,0.6643630266189575,4.644800100095381e-9,0.0,0.6150742173194885,-0.6919600367546082,0.3779881000518799,0.0,0.362551212310791,-0.4078710079193115,0.268617182970047,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.5,1.52,0.5)) * 1.0000000012999473, vec2(0.84,1.62));\nfloat tmpComb_413 = tmpComb_412;\nfloat tmpComb_414 = opUnionRound(tmpComb_413, sdTorus(pMod((mat4(0.5727498531341553,0.8041792511940002,-0.15891283750534058,0.0,-0.8191083073616028,0.5539072751998901,-0.14915919303894043,0.0,-0.03192776069045067,0.21559768915176392,0.9759598970413208,0.0,0.701280951499939,-0.5455323457717896,0.421924889087677,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(1.09,0.07)) * 0.9999999171907704, 0.14);\nfloat tmpComb_415 = tmpComb_414;\nfloat tmpComb_416 = opSubColumns(tmpComb_415, sdEllipsoid(pMod((mat4(1.0,0.0,0.0,0.0,0.0,0.9679820537567139,-0.25101903080940247,0.0,0.0,0.25101903080940247,0.9679820537567139,0.0,0.4602626860141754,-1.420561671257019,0.592455267906189,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.71,0.4,1.0)) * 1.0, vec2(0.17,7.97));\nreturn tmpComb_416;\n}\n    \nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 16; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera \n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, vUV, uInvSize), 1.0);\n}\n\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "MlVSRW", "name": "Green Scanner", "author": "Heavybrush", "description": "a green scanner using the abs sin of iGlobalTime", "tags": ["green", "scanner"], "likes": 1, "viewed": 102, "published": "Public", "date": "1483370535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat plot(vec2 uv,float pct) {\n\treturn smoothstep(pct - 0.01,pct,uv.y) - smoothstep(pct,pct + 0.01, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float y = abs(sin(iTime));\n    vec3 color = vec3(0.0,y,0.0);\n    \n    float pct = plot(uv,y);\n    color = (1.0 - pct) * color + pct * vec3(-0.5,0.5,0.0);\n    \n    float alpha = 1.0;\n    \n\tfragColor = vec4(color,alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVSRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 57, 57, 135], [137, 137, 194, 194, 469]], "test": "valid"}
{"id": "MlVSWR", "name": "Juliabulb - hhhzzzsss", "author": "hhhzzzsss", "description": "This program is a modified version of my mandelbulb program, displaying a morphing juliabulb instead.", "tags": ["3d", "raymarching", "fractal", "occlusion", "ambientocclusion", "juliabulb"], "likes": 5, "viewed": 278, "published": "Public", "date": "1483916726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define distfar 6.0\n#define iterations 4\n\nvec3 c;\n\nfloat calcfractal(vec3 coord) {\n    vec3 orbit = coord;\n    float dz = 1.0;\n    \n    for (int i=0; i<iterations; i++) {\n        \n        float r = length(orbit);\n    \tfloat o = acos(orbit.z/r);\n    \tfloat p = atan(orbit.y/orbit.x);\n        \n        dz = 8.0*r*r*r*r*r*r*r*dz;\n        \n        r = r*r*r*r*r*r*r*r;\n        o = 8.0*o;\n        p = 8.0*p;\n        \n        orbit = vec3( r*sin(o)*cos(p), r*sin(o)*sin(p), r*cos(o) ) + c;\n        \n        if (dot(orbit,orbit) > 4.0) break;\n    }\n    float z = length(orbit);\n    return 0.5*z*log(z)/dz;\n}\n\nvec2 map(vec3 p) {\n    return vec2(calcfractal(p.xzy),1.0);\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>distfar) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return vec3(t, h.y, i);\n        t += h.x;\n    }\n    return vec3(0.0);\n}\n\nvec3 calcnormal(vec3 p) {\n    vec2 e = vec2(0.0001,0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow (vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.01;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>1.0) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return 0.0;\n        res = min(res, 4.0*h.x/t);\n        t += h.x;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (2.0)*uv-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,-1.4);\n    vec3 rd = normalize(vec3(uv,1.5));\n    float the = 1.5*sin(iTime/30.0-1.0);\n    mat2 rmat = mat2(cos(the),sin(the),-sin(the),cos(the));\n    rd.yz *= rmat;\n    ro.yz *= rmat;\n    the = iTime/20.0;\n    rmat = mat2(cos(the),sin(the),-sin(the),cos(the));\n    rd.xz *= rmat;\n    ro.xz*= rmat;\n    c = vec3(0.6*sin(0.5*iTime),0.6*cos(0.784*iTime-1.203),0.6*sin(iTime*0.439485));\n    \n    vec3 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.8);\n    \n    if (t.z > 0.0) {\n        vec3 pos = ro + rd*t.x;\n        vec3 nor = calcnormal(pos);\n        vec3 lig = normalize(vec3(0.3,1.0,0.3));\n        vec3 rdy = dot(nor, rd) * nor;\n        vec3 rdx = rd - rdy;\n        vec3 ref = rdx - rdy;\n        \n        float occ = clamp(0.0,1.0,1.0/(1.0+pow(t.z/30.0,3.0)));\n        float sha = softshadow(pos, lig);\n        float dif = max(0.0,dot(lig,nor));\n        float sky = max(0.0,nor.y);\n        float ind = max(0.0,dot(-lig,nor));\n        float spec = pow( max(0.0,dot(ref,lig)) , 20.0);\n        \n        col  = dif*vec3(0.9,0.8,0.7)*vec3(sha);\n        col += sky*vec3(0.16,0.20,0.24)*occ;\n        col += ind*vec3(0.40,0.48,0.40)*occ;\n        col += 0.1*occ;\n        col += spec*sha*vec3(0.9,0.8,0.7);\n        \n        col = pow(col,vec3(0.45));\n    }\n    \n\tfragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 600], [602, 602, 620, 620, 663], [665, 665, 695, 695, 918], [920, 920, 945, 945, 1144], [1146, 1146, 1183, 1183, 1441], [1444, 1444, 1501, 1501, 2927]], "test": "valid"}
{"id": "MlVSzw", "name": "Single sample gaussian noise", "author": "stubbe", "description": "Based on hornet's noise experiments ( https://www.shadertoy.com/view/4ssXRX )\nLeft: 8-tap gaussian'ish noise (by central limit)\nRight: 1-tap gausisan noise (by inverting cumulated distribution function)", "tags": ["noise", "random", "gaussian", "rnd", "rand", "errorfunction"], "likes": 26, "viewed": 1500, "published": "Public API", "date": "1483694655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on hornet's 'noise distributions' shader (https://www.shadertoy.com/view/4ssXRX)\n\n// An experiment in the viability of generating gaussian noise directly from a single\n// uniform noise sample.\n\n// Intuitively, it is clear that if we bend or warp the output of a uniform noise then we are\n// also changing the distribution of that noise. In general, uniform noise can be shaped into\n// a specific distribution by mapping it though its corresponding inverted\n// cumulative probability distribution function.\n\n// It is well known that the anti-derivative of the gaussian function is the error function.\n// The error function unfortunately doesn't have a closed form expression. To get around this, a variant\n// of Sergei Winitzki's highly accurate approximation is used instead.\n// In practice, a simpler approximation would probably be satisfactory.\n\n// It is unclear if this has any practical use :)\n\nconst int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\nconst float PI = 3.1415926535;\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat _trunc( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n8rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    \n    float nrnd4 = nrand( n + 0.19*t );\n    float nrnd5 = nrand( n + 0.23*t );\n    float nrnd6 = nrand( n + 0.29*t );\n    float nrnd7 = nrand( n + 0.31*t );\n    \n\treturn (nrnd0+nrnd1+nrnd2+nrnd3 +nrnd4+nrnd5+nrnd6+nrnd7) / 8.0;\n}\n\nconst float ALPHA = 0.14;\nconst float INV_ALPHA = 1.0 / ALPHA;\nconst float K = 2.0 / (PI * ALPHA);\n\nfloat inv_error_function(float x)\n{\n\tfloat y = log(1.0 - x*x);\n\tfloat z = K + 0.5 * y;\n\treturn sqrt(sqrt(z*z - y * INV_ALPHA) - z) * sign(x);\n}\n\nfloat gaussian_rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat x = nrand( n + 0.07*t );\n    \n\treturn inv_error_function(x*2.0-1.0)*0.15 + 0.5;\n}\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( _trunc(t,NUM_BUCKETS_F), _trunc(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = n8rand( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = gaussian_rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat o;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < .5 )\n\t{\n\t\to = n8rand( uv );\n        idx = 1;\n        uvrange = vec2( 0.0, 0.5 );\n\t}\n\telse\n\t{\n\t\to = gaussian_rand( uv );\n        idx = 2;\n        uvrange = vec2( 0.5, 1.0 );\n\t}\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(uv.x - 0.5) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1138, 1192, 1215, 1215, 1283], [1284, 1328, 1370, 1370, 1414], [1415, 1445, 1479, 1479, 1503], [1505, 1505, 1529, 1529, 1935], [2037, 2037, 2072, 2072, 2180], [2182, 2182, 2213, 2213, 2329], [2331, 2331, 2411, 2411, 3117], [3119, 3119, 3176, 3176, 3672]], "test": "valid"}
{"id": "MlVXRG", "name": "Brainfarm", "author": "lherm", "description": "Playing with fractals", "tags": ["raymarch"], "likes": 3, "viewed": 587, "published": "Public API", "date": "1484854395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on code from Cabbibo, IQ and Connor Bell\n\n#define PI 3.1415926\n#define M 100\n#define MD 20.\n#define P 0.01\n\n// ----------\n// USEFUL FUNCTIONS\n// ----------\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n// ----------\n// DISTANCE FUNCTIONS FROM IQ\n// ----------\n\n\nvec3 opRep(in vec3 p, in float c)\n{\n    return mod(p, c)-(c*.5);\n}\n\n// ----------\n// CAMERA\n// ----------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// ----------\n// MODELLING\n// ----------\n\nfloat trap;\n\nvec2 DE(in vec3 p)\n{\n    #define REP\n    #ifdef REP\n    p.z -= iTime;\n    p = opRep(p, 3.5);\n    #else\n    p.z -= 1.5;\n    #endif\n    pR(p.xy, -PI / 4.);\n    float d = 1000.;\n    float o = 1.;\n    float sz = 1.9;\n    for (int i = 0; i < 15; i++)\n    {\n        if (p.x + p.y < 0.) p.xy = -p.yx;\n        pR(p.xy, (PI / 10.) * sin(iTime * .5));\n        p = abs(p);\n        if (p.x + p.z < 0.) p.xz = -p.zx;\n        pR(p.zx, (PI / 10.) * sin(iTime * .5));\n        if (p.y + p.z < 0.) p.yz = -p.zy;\n        p = sz*p - o * (sz-1.);\n        d = min(d, length(p)*pow(sz,-float(i)-1.));\n        if (dot(p, p) < 256.) trap = distance(p, vec3(0.));\n        \n    }\n    float res = d;\n    return vec2(res, 1.);\n}\n\nvec2 trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    float id = -1.;\n    for (int i = 0; i < M; i++)\n    {\n        vec2 m = DE(ro+rd*t);\n        if (m.x < P || t > MD) break;\n        t += m.x;\n        id = m.y;\n    }\n    if (t > MD) id = -1.;\n    return vec2(t, id);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor , float io )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = DE(aopos).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec3 eps = vec3(P, 0., 0.);\n    return normalize(vec3(\n\t    DE(p+eps.xyy).x - DE(p-eps.xyy).x,\n\t    DE(p+eps.yxy).x - DE(p-eps.yxy).x,\n\t    DE(p+eps.yyx).x - DE(p-eps.yyx).x ));\n}\n\nvec3 render(in vec2 res, in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.);\n    vec3 lightPos = vec3(1., 4., 3.);\n    if (res.y > -.5)\n    {\n        vec3 p = ro + rd * res.x;\n        vec3 n = calcNormal(p);\n        vec3 lightDir = normalize(lightPos - p);\n        float match = max(0., dot(lightDir, n));\n        float occ = calcAO(p, n, 1.);\n        color = vec3(trap) * match * occ;\n    }\n    else\n    {\n        color = mix(vec3(0.), vec3(1.), rd.y);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 ro = vec3(0., 0., 4.);\n    vec3 ta = vec3(0.);\n    mat3 camMat = calcLookAtMatrix(ro, ta, 0.); // 0. is camera roll\n    vec3 rd = normalize(camMat * vec3(uv.xy, 2.));\n    \n    vec2 res = trace(ro, rd);\n    vec3 color = render(res, ro, rd);\n    // Fog taken from https://www.shadertoy.com/view/4s2XRd\n    color = mix(color, vec3(0.), smoothstep(5., 20., res.x));\n    color = abs(sin(vec3(.1245, .235, .8423) * color + iTime));\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 203, 203, 335], [397, 397, 432, 432, 463], [504, 504, 568, 568, 746], [748, 748, 780, 780, 822], [879, 879, 899, 899, 1578], [1580, 1580, 1616, 1616, 1854], [1857, 1857, 1910, 1910, 2206], [2208, 2208, 2236, 2236, 2420], [2422, 2422, 2472, 2472, 2902], [2904, 2904, 2961, 2961, 3492]], "test": "valid"}
{"id": "MlySD1", "name": "Mandelflow 3", "author": "guil", "description": "Another mod of Mandelflow : https://www.shadertoy.com/view/XtKSDz with some borowings from Curvature average : https://www.shadertoy.com/view/XsfXzs.\n\nI used AA to blur different bailout values.", "tags": ["2d", "fractal"], "likes": 11, "viewed": 215, "published": "Public", "date": "1484163984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 4\n#define time iTime\n#define ITER 256\n#define K 0.065\n\n#define csqr(z)  mat2(z,-z.y,z.x) * z \n\nfloat bailout = 1e2;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = -1.0 + 2.0 * (fragCoord.xy+vec2(float(m),float(n))/float(AA)) / iResolution.xy;\n        p.x *= iResolution.x/iResolution.y;\n        bailout = bailout * 4.;\n        float t = smoothstep(0.0,1.0,((-cos(time*.1+2.)+1.0)/2.0));\n        \n        float zoom = 1.0/(t*63.0+1.0);\n        \n        vec2 c = vec2(-p.y-0.5,p.x);\n        c= c/dot(c,c);\n        c -= t*vec2(-2.94,4.1)*8.0;\n        c *= zoom;\n        vec2 z = vec2(0.0);\n        \n    \tint k=0;\n        \n        \n\t    float curv = 0.;\n        float rz = 0.;\n        \n        for(int i=0; i<ITER; i++ )\n    \t{\n            z = c + csqr(z);                     \t\t\n            curv = (z.x*z.y/dot(z,z)+.35)*2.;\n\t\t\trz = K* curv +(1.-K)*rz;\n            if( dot(z,z)>bailout){k=i;break;}\n        }\n        rz = exp(-1.7*rz);\n        if(dot(z,z)>bailout)\n            col +=vec3(0.55,0.3,0.1)*(float(k)/50.0)+vec3(0.2*rz,rz,1.-2.5*rz)*0.9;\n    }\n    col /= float(AA*AA);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlySD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "MlyXRm", "name": "Seeing faces", "author": "lherm", "description": "Playing with some ideas based on iq's two tweets https://www.shadertoy.com/view/MsfGzM", "tags": ["raymarch"], "likes": 2, "viewed": 150, "published": "Public", "date": "1483570279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f (in vec3 p)\n{\n    p.z -= iTime;\n    return length(cos(p+p.z-p.x+iTime)+.5*sin(p.x+p.y*.1-iTime*.5)) - clamp(1. * abs(sin(iTime *.7)), .7, 1.);\n}\n\nvoid mainImage( out vec4 c, in vec2 u )\n{\n    vec3 p = .5-vec3(u, 1.)/iResolution;\n    p.y += .3;\n    p.x = -abs(p.x);\n    vec3 o = p;\n    for (int i = 0; i < 200; i++)\n    {\n        o += f(o)*p;\n    }\n\tc = vec4(vec3(1.) * f(o-p) * vec3(f(o-p)*cos(iTime+o.x), f(o-p), f(o-p) * cos(p.x + p.y + o.x)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 152], [154, 154, 195, 195, 459]], "test": "valid"}
{"id": "MlyXzc", "name": "Rolling Hills VR", "author": "Tempally", "description": "VR version of Rolling Hills by David Hoskins.\nI had to apply some speedups to make it VR-ready", "tags": ["3d", "grass"], "likes": 20, "viewed": 813, "published": "Public", "date": "1485289066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rolling hills. By David Hoskins, November 2013.\n// https://www.shadertoy.com/view/Xsf3zX\n\n// v.2.00 Uses eiffie's 'Circle of Confusion' function\n//\t\t  for blurred ray marching into the grass.\n// v.1.02 Camera aberrations.\n// v.1.01 Added better grass, with wind movement.\n\n// VR version by Tempally, 2017.\n\n// Let's redefine MOD2 to perform MULs, not DIVs:\n#define MOD2 vec2(0.3247122237916646, 0.134707348285849)\n\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\nvec3 sunColour = vec3(1.0, .8, .25);// let's our sun will be more yellow\n\n//--------------------------------------------------------------------------\n// Noise functions...\n\n/* original Hash function is too slow for VR\nfloat Hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n        p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n   so, let's replace it with the faster one: */\nfloat Hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat Hash(vec2 p)\n{\n    p  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+ 0.0), Hash(n+ 1.0),f.x),\n                    mix( Hash(n+57.0), Hash(n+58.0),f.x),f.y);\n    return res;\n}\n\nvec2 Voronoi( in vec2 x )\n{\n\tvec2 p = floor( x );\n\tvec2 f = fract( x );\n\tfloat res=100.0,id;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2 b = vec2( float(i), float(j) );\n\t\tvec2 r = vec2( b ) - f  + Hash( p + b );\n\t\tfloat d = dot(r,r);\n\t\tif( d < res )\n\t\t{\n\t\t\tres = d;\n\t\t\tid  = Hash(p+b);\n\t\t}\t\t\t\n    }\n\treturn vec2(max(.4-sqrt(res), 0.0),id);\n}\n\n\n//--------------------------------------------------------------------------\nvec2 Terrain( in vec2 p)\n{\n\tfloat type = 0.0;\n\tvec2 pos = p*0.003;\n\tfloat w = 50.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = w * 0.62;\n\t\tpos *= 2.5;\n\t}\n\n\treturn vec2(f, type);\n}\n\n//--------------------------------------------------------------------------\nvec2 Map(in vec3 p)\n{\n\tvec2 h = Terrain(p.xz);\n    return vec2(p.y - h.x, h.y);\n}\n\n//--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw = w*0.6;\n\t\txy = 2.0 * xy;\n\t}\n\treturn f;\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\n// Merge grass into the sky background for correct fog colouring...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n\tfloat fogAmount = clamp(dis*dis* 0.0000012, 0.0, 1.0);\n\treturn mix( rgb, GetSky(dir), fogAmount );\n}\n\n//--------------------------------------------------------------------------\nvec3 DE(vec3 p)\n{\n\tfloat base = Terrain(p.xz).x - 1.9;\n\tfloat height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;\n\t//p.y += height;\n\tfloat y = p.y - base-height;\n\ty = y*y;\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*4.0+p.zx*12.3)*.12+vec2(sin(iTime*2.3+1.5*p.z),sin(iTime*3.6+1.5*p.x))*y*.5));\n\tfloat f = ret.x * .6 + y * .58;\n\treturn vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);\n}\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat CircleOfConfusion(float t)\n{\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\n}\n\n//--------------------------------------------------------------------------\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)/(b-a),0.,1.);\n}\n\n//--------------------------------------------------------------------------\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\n{\n\tfloat d = 0.0;\n\t// Only calculate cCoC once is enough here...\n\tfloat rCoC = CircleOfConfusion(dist*.3);\n\tfloat alpha = 0.0;\n\t\n\tvec4 col = vec4(mat*0.15, 0.0);\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (col.w > .99) break;\n\t\tvec3 p = rO + rD * d;\n\t\t\n\t\tvec3 ret = DE(p);\n\t\tret.x += .5 * rCoC;\n\n\t\tif (ret.x < rCoC)\n\t\t{\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\n\t\t\t// Mix material with white tips for grass...\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\n\t\t\tcol += vec4(gra * alpha, alpha);\n\t\t}\n\t\td += max(ret.x * .7, .1);\n\t}\n\tif(col.w < .2)\n\t\tcol.xyz = vec3(0.1, .15, 0.05);\n\treturn col.xyz;\n}\n\n//--------------------------------------------------------------------------\n// Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n\tfloat h = dot(sunLight,normal);\n\tmat = mat * sunColour*(max(h, 0.0)+.2);\n}\n\n//--------------------------------------------------------------------------\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\n{\n\tvec3 mat;\n\tif (type == 0.0)\n\t{\n\t\t// Random colour...\n\t\tmat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.025));\n\t\t// Random shadows...\n\t\tfloat t = FractalNoise(pos.xz * .1)+.5;\n\t\t// Do grass blade tracing...\n\t\tmat = GrassBlades(pos, dir, mat, dis) * t;\n\t\tDoLighting(mat, pos, normal,dir, dis);\n\t}\n\tmat = ApplyFog(mat, dis, dir);\n\treturn mat;\n}\n\n//--------------------------------------------------------------------------\n// Home in on the surface by dividing by two and split...\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\n{\n\tfloat halfwayT = 0.0;\n\tfor (int n = 0; n < 5; n++)\n\t{\n\t\thalfwayT = (oldT + t ) * .5;\n\t\tif (Map(rO + halfwayT*rD).x < .05)\n\t\t{\n\t\t\tt = halfwayT;\n\t\t}else\n\t\t{\n\t\t\toldT = halfwayT;\n\t\t}\n\t}\n\treturn t;\n}\n\n//--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\n{\n    float t = 5.;\n\tfloat oldT = 0.0;\n\tfloat delta = 0.;\n\tvec2 h = vec2(1.0, 1.0);\n\tbool hit = false;\n\tfor( int j=0; j < 70; j++ )\n\t{\n\t    vec3 p = rO + t*rD;\n\t\th = Map(p); // ...Get this position's height mapping.\n\n\t\t// Are we inside, and close enough to fudge a hit?...\n\t\tif( h.x < 0.05)\n\t\t{\n\t\t\thit = true;\n            break;\n\t\t}\n\t\n\t\tdelta = h.x + (t*0.03);\n\t\toldT = t;\n\t\tt += delta;\n\t}\n    type = h.y;\n    resT = BinarySubdivision(rO, rD, t, oldT);\n\treturn hit;\n}\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\treturn vec3(200.0 * sin(3.54*t)+55.0,  12.0+sin(t*.3)*6.5, 200.0 * cos(2.0*t) -94.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb)\n{\n\t// Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\t\n\t// Then...\n\t#define CONTRAST 1.1\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t// Vignette...\n\t//rgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n// Let's make separate function performing common calcs for VR and monitor output:\n\nvec3 drawImage(in vec3 cameraPos, in vec3 dir)\n{\n\tfloat distance;\n\tfloat type;\n\tif( !Scene(cameraPos, dir, distance, type) )\n\t\treturn GetSky(dir); // Missed scene, now just get the sky...\n\telse\n\t{\n\t\t// Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * dir;\n\t\t// Get normal from sampling the high definition height map\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\n\t\tvec2 p = vec2(0.1, 0.0);\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\n\t\tnor = cross(v2, v3);\n\t\tnor = normalize(nor);\n\n\t\t// Get the colour using all available data...\n\t\treturn TerrainColour(pos, dir, nor, distance, type);\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat gTime = (iTime*5.0+2352.0)*.006;\n        vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\tvec3 camTar;\n\t\n\tif (xy.y < .13 || xy.y >= .87)\n\t{\n\t\t// Top and bottom cine-crop - what a waste! :)\n\t\tfragColor=vec4(vec4(0.0));\n\t\treturn;\n\t}\n\n\tvec3 cameraPos = CameraPath(gTime + 0.0);\n        cameraPos.x -= 3.0;\n\tcamTar\t = CameraPath(gTime + .009);\n\tcameraPos.y += Terrain(CameraPath(gTime + .009).xz).x;\n\tcamTar.y = cameraPos.y;\n\t\n\tfloat roll = .4*sin(gTime+.5);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\n\tvec3 col = drawImage(cameraPos, dir);\n\t\n\t// bri is the brightness of sun at the centre of the camera direction.\n\t// Yeah, the lens flares is not exactly subtle, but it was good fun making it.\n\tfloat bri = dot(cw, sunLight)*.75;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8;\n\n\t\t// glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t// glare2 is the yellow ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t// glare3 is a purple splodge...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\n\t}\n\tcol = PostEffects(col);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------\n\n// VR entry point with cutting unnecessary pixels\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    fragCoord.x-=iResolution.x*.25;\n    fragCoord.y-=iResolution.y*.5;\n    if (length(fragCoord.xy)>iResolution.x*.225) discard;\n\t\n    vec3 pos= CameraPath((iTime+2352.0)*.006);\n    pos.y += Terrain(pos.xz).x;\n\n    vec3 col = drawImage(fragRayOri + pos, fragRayDir);\n    // Yes, the glares are out of VR.\n    // Because roll is no good in VR,\n    // and it takes too much time to recalculate cp/cu/cv from dir.\n    col = PostEffects(col);\t\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[648, 868, 891, 891, 929], [931, 931, 951, 951, 1040], [1042, 1042, 1068, 1068, 1308], [1310, 1310, 1337, 1337, 1673], [1676, 1753, 1779, 1779, 1965], [1967, 2044, 2065, 2065, 2125], [2127, 2204, 2236, 2236, 2368], [2370, 2503, 2528, 2528, 2824], [2826, 2971, 3028, 3028, 3130], [3132, 3209, 3226, 3226, 3605], [3607, 3759, 3793, 3793, 3850], [3852, 3929, 3971, 3971, 4007], [4009, 4086, 4156, 4156, 4853], [4855, 4958, 5050, 5050, 5126], [5128, 5205, 5282, 5282, 5633], [5635, 5770, 5840, 5840, 6036], [6038, 6115, 6184, 6184, 6650], [6652, 6729, 6757, 6757, 6846], [6848, 6925, 6953, 6972, 7302], [7388, 7388, 7436, 7436, 8143], [8146, 8146, 8203, 8203, 9869], [9949, 9999, 10093, 10093, 10564]], "test": "valid"}
{"id": "Mt3SWX", "name": "Hessian 3D and curvature", "author": "iq", "description": "Computing second derivatives for Value Noise analytically, and curvature from it. Not super useful. See [url]https://www.shadertoy.com/view/MdsSRs[/url] for the 2D case, [url]https://www.shadertoy.com/view/XttSz2[/url] for the analytical normals in use.", "tags": ["3d", "derivative", "analytic", "hessian"], "likes": 19, "viewed": 1083, "published": "Public API", "date": "1483850929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical second derivatibes of value noise and fbm made with it. Used second\n// derivatives to compute curvature.\n\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n//---------------------------------------------------------------\n// return.x = value noise\n// return.xyz = derivatives\n// out dd     = hessian (second derivatives)\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x, out mat3 dd )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    // cubic interpolation vs quintic interpolation\n#if 0\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    vec3 ddu = 6.0 - 12.0*w;\n#else\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    vec3 ddu = 60.0*w*(1.0+w*(-3.0+2.0*w));\n#endif\n    \n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    dd = mat3( ddu.x*(k1 + k4*u.y + k6*u.z + k7*u.y*u.z), \n               du.x*(k4+k7*u.z)*du.y,\n               du.x*(k6+k7*u.y)*du.z,\n              \n               du.y*(k4+k7*u.z)*du.x,\n               ddu.y*(k2 + k5*u.z + k4*u.x + k7*u.z*u.x),\n               du.y*(k5+k7*u.x)*du.z,\n              \n               du.z*(k6+k7*u.y)*du.x,\n               du.z*(k5+k7*u.x)*du.y,\n               ddu.z*(k3 + k6*u.x + k5*u.y + k7*u.x*u.y) );\n\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n//---------------------------------------------------------------\n\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nvec4 fbmd( in vec3 x, out mat3 s )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    s = mat3(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        mat3 dd;\n        vec4 n = noised(f*x*scale,dd);\n        a += b*n.x;                // accumulate values\t\t\n        d += b*n.yzw*f*scale;      // accumulate derivatives\n        s += b*dd*f*f*scale*scale; // accumulate second derivative\n        b *= 0.5;\n        f *= 1.8;\n    }\n\n\treturn vec4( a, d );\n}\n\nvec4 map( in vec3 p, out mat3 s )\n{\n    \n    mat3 dd;\n\tvec4 d1 = fbmd( p, dd );\n    d1.x -= 0.33;\n\td1.x *= 0.7;\n    d1.yzw = 0.7*d1.yzw;\n    dd *= 0.7;\n    // clip to box\n    vec4 d2 = sdBox( p, vec3(1.5) );\n    if(d1.x>d2.x)\n    {\n        s = dd;\n        return d1;\n    }\n    \n    \n    s = mat3(0.0);\n    return d2;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd, out mat3 resS )\n{\n\tvec4 res = vec4(-1.0);\n    resS = mat3(0.0);\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float tmax = dis.y;\n    float t = dis.x;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        mat3 dd;\n\t\tvec4 hnor = map( pos, dd );\n        res = vec4(t,hnor.yzw);\n        resS = dd;\n\t\tif( hnor.x<0.0001 ) break;\n\t\tt += hnor.x;\n        if( t>tmax ) break;\n\t}\n\n\tif( t>tmax ) res = vec4(-1.0);\n\treturn res;\n}\n\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        mat3 kk;\n        ao += clamp( map( pos + nor*0.001 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*5.0, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n   \n\t// camera anim\n    float an = 0.1*iTime;\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\n\tvec3 ta = vec3( 0.0 );\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    mat3 dd;\n    vec4 tnor = interesect( ro, rd, dd );\n\tfloat t = tnor.x;\n\n    if( t>0.0 )\n\t{\n\t\tvec3  pos = ro + t*rd;\n        vec3  nor = normalize(tnor.yzw);\n        float occ = calcAO( pos, nor );\n\n        \n        vec3 d = tnor.yzw;\n\n        // compute curvature\n\t\tmat4 mm = mat4( dd[0].x, dd[0].y, dd[0].z, d.x,\n                        dd[1].x, dd[1].y, dd[1].z, d.y,\n                        dd[2].x, dd[2].y, dd[2].z, d.z,\n                        d.x, d.y, d.z, 0.0 );\n\t\tfloat k = -determinant(mm)/(dot(d,d)*dot(d,d));\n\n        // shape it a bit\n        k = sign(k)*pow( abs(k), 1.0/3.0 );\n        \n        if( k<0.0) col = vec3(1.0,0.7,0.2); else col = vec3(0.2,0.8,1.0); col *= abs(k*0.2);\n        if( abs(k)<0.0001 ) col = vec3(0.1);\n\n        col *= occ;\n        col *= 0.7 + 0.3*nor.y;\n\t}\n\n    col = sqrt(col);\n\t\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3SWX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1201, 1201, 1224, 1224, 1260], [1494, 1494, 1533, 1533, 3128], [3197, 3197, 3250, 3250, 3428], [3430, 3430, 3466, 3466, 3939], [3941, 3941, 3976, 3976, 4259], [4261, 4298, 4349, 4349, 4617], [4619, 4631, 4689, 4689, 5181], [5184, 5310, 5346, 5346, 5610], [5612, 5612, 5654, 5654, 5976], [5979, 5979, 6036, 6036, 7308]], "test": "valid"}
{"id": "MtGSD1", "name": "Mandelflow 2", "author": "guil", "description": "A mod of Mandelflow : https://www.shadertoy.com/view/XtKSDz with some borowings from Curvature average : https://www.shadertoy.com/view/XsfXzs.\n\nI used AA to blur different bailout values.", "tags": ["2d", "fractal"], "likes": 9, "viewed": 179, "published": "Public", "date": "1484151602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 4\n#define time iTime\n#define ITER 256\n\n#define csqr(z)  mat2(z,-z.y,z.x) * z \n\nfloat bailout = 1e2;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = -1.0 + 2.0 * (fragCoord.xy+vec2(float(m),float(n))/float(AA)) / iResolution.xy;\n        p.x *= iResolution.x/iResolution.y;\n        bailout = bailout * 4.;\n        float t = smoothstep(0.0,1.0,((-cos(time*.1+2.)+1.0)/2.0));\n        \n        float zoom = 1.0/(t*63.0+1.0);\n        \n        vec2 c = vec2(-p.y-0.5,p.x);\n        c -= t*vec2(-2.94,4.1)*8.0;\n        c *= zoom;\n        vec2 z = vec2(0.0);\n    \tint k=0;\n        \n        vec2 oldz1 = vec2(1);\n\t    //vec2 oldz2 = vec2(1);\n\t    float curv = 0.;\n        \n        for(int i=0; i<ITER; i++ )\n    \t{\n            z = c + csqr(z);\n            vec2 tmp = vec2(1.,1.);\n            if (i > 0)\n\t\t\t{\n\t\t\t    //tmp = (z-oldz1)/(oldz1-oldz2);\n                tmp = oldz1/z;\n\t\t\t}\n            //tmp = z;\n            //tmp = csqr(z);\n            \n\t\t\t//curv = atan(tmp.y,tmp.x);\n            //curv=(sin(2.*curv)+1.)*.5;\n            \n             curv = tmp.x*tmp.y/dot(tmp,tmp)+.5;\n\t\t\t\n\t\t\t//oldz2 = oldz1;\n\t\t\toldz1 = z;\n\t\t\t\n            if( dot(z,z)>bailout){k=i;break;}\n        }\n        \n        if(dot(z,z)>bailout)\n            col +=vec3(0.49,0.2,0.0)*(float(k)/50.0)+vec3(0.0,curv,1.-2.5*curv)*0.9;\n    }\n    col /= float(AA*AA);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGSD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "MtGSDw", "name": "test metal", "author": "XRNZ", "description": "metal", "tags": ["metal"], "likes": 0, "viewed": 131, "published": "Public", "date": "1484577663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 blue=vec3(0.05,0.35,0.65);\nconst vec3 deepblue=vec3(0.05,0.05,0.85);\nconst vec3 green=vec3(0.15,0.95,0.75);\nconst vec3 red=vec3(0.75,0.35,0.35);\nconst vec3 black=vec3(0.0,0.0,0.0);\nconst vec3 white=vec3(1.0,1.0,1.0);\nconst vec3 violet=vec3(0.35,0.35,0.65);\nconst vec3 yellow=vec3(0.75,0.65,0.35);\nconst vec3 rust=vec3(183.0/255.0,70.0/255.0,14.0/255.0);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(blue,green,v);\n}\n\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(blue,green,t);\n}\n\nfloat scaledNoise(float i,vec3 p, vec3 n){\n\n    float t=turbulence (i*p,n);;\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    return t;\n\n}\n\n\n\nvec3 metal(in vec3 p,in vec3 n)\n{\n    \n    vec3 cc;\n    \n    // turbulences multiples\n    float t0=scaledNoise(7.0,p,n);\n    float t1=scaledNoise(8.0,rotate(p,0.0),n);\n    float t2=scaledNoise(15.0,rotate(p,161.0),n);\n    float t3=scaledNoise(5.0,rotate(p,131.0),n);\n    float t4=scaledNoise(5.0,rotate(p,61.0),n);\n    float t5=scaledNoise(25.0,rotate(p,31.0),n);\n    \n    \n\n    //couleur de base, metal brossÃ©\n    \n    cc =   mix(0.8*white,0.3*white,\n               turbulence(vec3(5.0*p.x,500.0*p.y,1.0*p.z),n)\n              *(1.0-0.7*noise(200.0*p)));\n    \n\n    \n    //taches\n    \n     if(t4>0.65){\n   \t cc = mix(cc,0.8*cc+0.2*rust,t0);\n        }\n    \n        if(t3>0.75){\n    cc = mix(cc,0.75*cc+0.25*rust,t0);\n  \t      }\n\n    \n    //rouille\n   \n     if(t5>0.95){\n        \n    \tfloat mx = clamp(-0.5*noise(155.0*p)+(1.0/0.05)*(t5-0.95),0.0,1.0);\n        \n        cc = mix(0.3*rust,rust,mx);\n    }\n\n        \n    if(t1>0.95){\n        \n    \tfloat mx = clamp(-0.5*noise(155.0*p)+(1.0/0.05)*(t1-0.95),0.0,1.0);\n        \n       cc = mix(0.3*rust,rust,mx);\n    }\n\n\n\n    return cc;\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n    \n        //vec3 r = normalize( 2.0*(dot(n,l))*n-l);\n      \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n \n    //float diff = 0.5*(1.0+dot(n, l));\n    \n    //float diff = dot(n, l);\n    \n    //float alpha = 12.550;\n    \n    //float diff = 0.5*(1.0+dot(n, l)) + 0.5*pow(dot(r,vec3(0.0,0.0,-1.0)),alpha);\n    \n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.0*background(n)+1.00*metal(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.3, t, n))\n    {\t\n        //fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n        fragColor = vec4(shade(o+d*t,n),1.0);\n    }\n    fragColor=Vignetting(fragColor,xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 158, 182, 182, 225], [227, 258, 284, 284, 653], [729, 782, 817, 817, 886], [1328, 1385, 1420, 1420, 1507], [1510, 1551, 1590, 1615, 1778], [1780, 1805, 1839, 1864, 1926], [1928, 1928, 1970, 1970, 2103], [2107, 2107, 2140, 2140, 3187], [3189, 3259, 3304, 3304, 3346], [3425, 3607, 3685, 3685, 3920], [3997, 4038, 4066, 4066, 4139], [4141, 4187, 4220, 4239, 5038], [5040, 5097, 5135, 5135, 5216], [5293, 5293, 5350, 5350, 5967]], "test": "valid"}
{"id": "MtGSRG", "name": "2D Voro Flower", "author": "aiekick", "description": "2D Voro Flower", "tags": ["2d", "flower", "voro"], "likes": 3, "viewed": 557, "published": "Public API", "date": "1484756826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float df(vec2 uv)\n{\n\tuv *= 5.;\n\tfloat a = atan(uv.x, uv.y)/6.28318*5.;\n\tfloat d = length( uv) - mix(0.5,3.0,abs(fract(a)-.5));\n\treturn smoothstep(0.,1., (d)+0.01);\n}\n\nvoid mainImage( out vec4 fC, vec2 fG )\n{\n\tvec2 p = fG /= iResolution.y / 10.;\n\t\n    float d = 9.;\n    \n    for(int x=-1;x<=1;x++)\n    for(int y=-1;y<=1;y++)\n    {\t\n        p = vec2(x,y);\n        vec2 a = sin( iTime + 9. * fract(sin((floor(fG)+p)*mat2(2,5,5,2))));\n\t\tp += .5 + .35*a - fract(fG);\n        p *= mat2(cos(a.x),-sin(a.x),sin(a.x),cos(a.x))*cos(a.y);\n        d = min(d, df(p));\n    }\n\t\n\tvec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.5 + 0.5*cos(10.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfC = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGSRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 165], [167, 167, 207, 207, 761]], "test": "valid"}
{"id": "MtGSWz", "name": "Bello", "author": "wizgrav", "description": "Simple concectric circles for testing clubber modulators.\n\nElectro swing https://goo.gl/VTGmz7", "tags": ["2d", "clubber"], "likes": 8, "viewed": 4000, "published": "Public API", "date": "1483819399", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R abs(sin(iTime * 1.33))\n#define CLUBBER_G abs(cos(iTime * 0.66))\n#define CLUBBER_B abs(sin(iTime) * cos(iTime))\n#define CLUBBER_A min(abs(cos(iTime * 0.33)),abs(sin(iTime * 0.66)))\n#endif\n// Clubber end\n\nvoid mainImage(out vec4 color, vec2 fragCoord) {\n     vec2 uv = fragCoord/iResolution.xy;\n     float aspect = iResolution.x/iResolution.y;\n     uv.x *= aspect;\n     vec3 rv = vec3(0.);\n     vec2 center = vec2(0.5 * aspect,0.5);\n     rv.x = max(0.4, CLUBBER_R);\n     rv.y = mix(0.05, rv.x * 0.6, CLUBBER_G);\n     rv.z = mix(rv.y * 1.2, rv.x * 0.9, CLUBBER_B);\n     rv *= 0.49;\n     float d = distance(center, uv);\n     float f = fwidth(d) * 3.;\n     float c1 = smoothstep(rv.x - f, rv.x + f, d);\n     float c2 = smoothstep(rv.y - f, rv.y + f, d);\n     float c3 = smoothstep(rv.z - f, rv.z + f, d);\n    color.rgb = abs(CLUBBER_A - vec3(c3 < 1. ? ( c2 < 1. ? c2 : 1.0 - c3):c1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 341, 389, 389, 1019]], "test": "valid"}
{"id": "MtGSzK", "name": "Smooth pixelation", "author": "anastadunbar", "description": "Pixelation with smoothness.", "tags": ["2d", "boxblur", "smooth"], "likes": 0, "viewed": 569, "published": "Public API", "date": "1484936017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grayscale(vec3 c){return(c.r+c.g+c.b)/3.;}\nvec3 draw(vec2 uv){\n\t//return texture(iChannel0,uv).rgb;\n\t//return vec3(floor(uv.x*iResolution.x)==floor(mod(float(iFrame),iResolution.x))?1.:0.);\n\t//return vec3(grayscale(texture(iChannel0,uv).rgb)>0.5);\n\treturn vec3(fract((length(uv-.5)*12.)+iTime)>0.5?1.:0.);\n}\nconst int size=8;\nfloat fsize=float(size);\nvec3 sum(vec2 uv){\n\tvec3 total=vec3(0.);\n\tfor(int i=0;i<size*size;i++){\n\t\ttotal+=draw(uv+(vec2(mod(float(i),fsize),floor(float(i)/fsize))/iResolution.xy));\n\t}\n\treturn total;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec2 res=iResolution.xy/fsize;\n\tfragColor=vec4(sum(floor(uv*res)/res)/pow(fsize,2.),1.);\n\t//Compared with:\n\t//fragColor=vec4(draw(floor(uv*res)/res),1.);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 48], [49, 49, 68, 253, 313], [357, 357, 375, 375, 532], [533, 533, 586, 586, 781]], "test": "valid"}
{"id": "MtGXDm", "name": "Shader Marble", "author": "Valou", "description": "Shader Marble", "tags": ["marble"], "likes": 1, "viewed": 105, "published": "Public", "date": "1484577796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// MARBRE ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 black=vec3(0.0,0.0,0.0);\nconst vec3 white=vec3(1.0,1.0,1.0);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(black,white,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n \n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(black,white,t);\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 marble(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (7.0*p,n);\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    \n    if(t<0.46)\n    {\n        vec3 black2 = vec3(0.,0.,0.);\n        t=0.0;\n    \treturn mix(black2,black,t);\n    }\n    \n    float t2=turbulence (2.0*p,n);\n    \n    if(t2>0.46 && t2<0.465)\n    {\n        vec3 black2 = vec3(0.,0.,0.);\n        t=0.0;\n    \treturn mix(black2,black,t2);\n    }\n    \n    t2=turbulence (5.0*p,n);\n    \n    if(t2>0.56 && t2<0.57)\n    {\n        vec3 black2 = vec3(0.,0.,0.);\n        t=0.0;\n    \treturn mix(black2,black,t2);\n    }\n    \n    return mix(black,white,t);\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*marble(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 157, 181, 181, 224], [226, 257, 283, 283, 652], [728, 781, 816, 816, 885], [1034, 1091, 1126, 1126, 1214], [1216, 1257, 1296, 1321, 1487], [1489, 1514, 1548, 1573, 1636], [1638, 1675, 1709, 1734, 2343], [2345, 2415, 2460, 2460, 2502], [2579, 2761, 2839, 2839, 3074], [3151, 3192, 3220, 3220, 3293], [3295, 3341, 3374, 3393, 3846], [3848, 3905, 3943, 3943, 4024], [4101, 4101, 4158, 4158, 4727]], "test": "valid"}
{"id": "MtGXDw", "name": "CrackedLava", "author": "Jabberwock", "description": "Best Lava Texture that i made in 2 hours, from Rusty metal", "tags": ["3d"], "likes": 2, "viewed": 90, "published": "Public", "date": "1484574336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 blue=vec3(1.0,0.30,0.0);\nconst vec3 green =vec3(0.30,0.30,0.30);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)/*+floor(p.y)+floor(p.z)*/,2.0);\n    return mix(blue,green,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{ // Utiliser ces couleurs pour le mÃ©tal rouillÃ©.\n    //const vec3 blue=vec3(1.52,0.87,0.23);\n\t//const vec3 green=vec3(0.5,0.5,0.5);\n    \n    \n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    //t/=(0.6);//1.0+0.25+0.125+0.025\n    // Modifier 0.8 pour changer la frÃ©quence des taches. rÃ©duire 0.8 augmente la frÃ©quence\n    if(t>0.2 && t<= 0.8){\n        return (0.6*t);\n    }else{\n        return 0.0;\n    }\n    return t;\n     \n   \n}\n\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(blue,green,t);\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 marble(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (10.0*p,n);\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    if(t<=0.8){\n       if((abs(sin(iTime))*2.0) > 1.0){\n             return (abs(sin(iTime))*2.0) * (blue*0.7/t);\n        }else{\n            return blue*0.7/t;\n        }\n       \n    }\n    return mix(blue,green,t);\n}\n/*if((abs(sin(iTime))*2.0) > 1.0){\n             return (abs(sin(iTime))*2.0) * (blue*0.7/t);\n        }else{\n            return blue*0.7/t;\n        }*/\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(1.0, 1.0,1.0);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.1*background(n)+0.7*marble(p,n);//*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 157, 181, 181, 224], [226, 257, 283, 283, 652], [728, 781, 816, 816, 885], [1038, 1095, 1130, 1130, 1221], [1223, 1264, 1303, 1471, 1833], [1836, 1861, 1895, 1920, 1982], [1984, 2021, 2055, 2080, 2413], [2566, 2636, 2681, 2681, 2723], [2800, 2982, 3060, 3060, 3295], [3372, 3413, 3441, 3441, 3514], [3516, 3562, 3595, 3614, 4067], [4069, 4126, 4164, 4164, 4245], [4322, 4322, 4379, 4379, 4948]], "test": "valid"}
{"id": "MtGXWh", "name": "Portal Pool", "author": "4DICE7", "description": "My first shader - an attempt to create an abstract portal to another dimension!\n\nIterations of pulsing, breathing circles that draw inwards.\n\nDrawing upon the code described by 'phil' at https://www.shadertoy.com/view/ltBXRc", "tags": ["circle", "sinusoid", "vortex", "portal", "calm"], "likes": 25, "viewed": 994, "published": "Public", "date": "1484080373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* My first shader - an attempt to create an abstract portal to another dimension!\n*\n* Drawing upon the code described by 'phil' at https://www.shadertoy.com/view/ltBXRc\n**/\n\n\n/**\n* Applies smooth displacement to the circumference of the circle.\n**/\nfloat variation(vec2 v1, vec2 v2, float strength, float speed) {\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.;\n}\n\n/**\n* Draws a circle with smooth variation to its circumference over time. \n* @rad - the radius of the circle\n* @width - how thick the circle is\n* @index - what circle is currently being drawn? Currently, every odd circle is drawn with opposing displacement for effect\n**/\nvec3 paintCircle (vec2 uv, vec2 center, float rad, float width, float index) {\n    vec2 diff = center-uv;\n    float len = length(diff);\n    float scale = rad;\n\tfloat mult = mod(index, 2.) == 0. ? 1. : -1.; \n    len += variation(diff, vec2(rad*mult, 1.0), 7.0*scale, 2.0);\n    len -= variation(diff, vec2(1.0, rad*mult), 7.0*scale, 2.0);\n    float circle = smoothstep((rad-width)*scale, (rad)*scale, len) - smoothstep((rad)*scale, (rad+width)*scale, len);\n    return vec3(circle);\n}\n\n/**\n* A ring consists of a wider faded circle with an overlaid white solid inner circle. \n**/\nvec3 paintRing(vec2 uv, vec2 center, float radius, float index){\n     //paint color circle\n    vec3 color = paintCircle(uv, center, radius, 0.075, index);\n    //this is where the blue color is applied - change for different mood\n    color *= vec3(0.3,0.85,1.0);\n    //paint white circle\n    color += paintCircle(uv, center, radius, 0.015, index);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //define our primary 'variables'\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    const float numRings = 20.;\n    const vec2 center = vec2(0.5);\n    const float spacing = 1. / numRings;\n    const float slow = 30.;\n    const float cycleDur = 1.;\n    const float tunnelElongation = .25;\n    float radius = mod(iTime/slow, cycleDur);\n    vec3 color;\n\n    //this provides the smooth fade black border, which we will mix in later\n    float border = 0.25;\n    vec2 bl = smoothstep(0., border, uv); // bottom left\n    vec2 tr = smoothstep(0., border, 1.-uv); // top right\n    float edges = bl.x * bl.y * tr.x * tr.y;\n\n    //push in the left and right sides to make the warp square\n    uv.x *= 1.5;\n    uv.x -= 0.25; \n    \n    //do the work\n    for(float i=0.; i<numRings; i++){\n   \t\tcolor += paintRing(uv, center, tunnelElongation*log(mod(radius + i * spacing, cycleDur)), i ); //these are the fast circles\n        color += paintRing(uv, center, log(mod(radius + i * spacing, cycleDur)), i); //these are essentially the same but move at a slower pace\n    }\n\n    //combined, these create a black fade around the edges of our screen\n    color = mix(color, vec3(0.), 1.-edges); \n    color = mix(color, vec3(0.), distance(uv, center));\n    //boom!\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 253, 317, 317, 415], [417, 690, 768, 768, 1171], [1173, 1267, 1331, 1357, 1633], [1636, 1636, 1693, 1730, 2964]], "test": "valid"}
{"id": "MtKSDR", "name": "Infinite Polygon Lines Repeated", "author": "cacheflowe", "description": "Playing with repeating infinite lines in the arrangement of a polygon ", "tags": ["lines", "polygon", "repeating"], "likes": 8, "viewed": 657, "published": "Public API", "date": "1483933822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718\n\n// infinite line function from http://stackoverflow.com/a/26902185/352456\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 point) {\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    return abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.7;\t\t\t\t\t\t\t\t\t// adjust time\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    float dist = length(uv);\t\t\t\t\t\t\t\t\t\t// get dist from center\n    uv *= 1. + (0.75 + sin(time) * 0.25 * dist);\t\t\t\t\t// bulge based on dist from center\n    float rot = 0.5 + 0.75 * sin(time) * dist;\t\t\t\t\t\t// oscillate rotation\n    uv *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\t\t\t// rotate\n    float segmentRads = TWO_PI / 6.;\n    float col = 1.;\n    float distThresh = 0.07 + 0.01 * cos(time);\n    float radius = 0.2 + 0.0 * abs(sin(time));\n    float distToLine = 9999.;\n    float totalDist = 0.;\n    float fractZoom = 4. + 1.0 * sin(PI + time);\n    float fractRepeat = 0.55 + 0.1 * sin(PI + time);;\n    for(int i = 0; i < 6; i++) {\n        float curRads = float(i) * segmentRads;\n        float nextRads = float(i + 1) * segmentRads;\n        vec2 point1 = vec2(radius * sin(curRads), radius * cos(curRads));\n        vec2 point2 = vec2(radius * sin(nextRads), radius * cos(nextRads));\n        float dist = distanceToLine(point1, point2, uv);\n        distToLine = min(distToLine, fractRepeat * fract(fractZoom * dist));\n    }\n    if(distToLine < distThresh) {\n        col = smoothstep(0.3, 0.8, distToLine / distThresh);\n    }\n    col += sin(-time) * (length(uv) * 0.35);\n\tfragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 133, 185, 185, 310], [312, 312, 369, 369, 1719]], "test": "valid"}
{"id": "MtKSWD", "name": "Spring Thing", "author": "turlmeh", "description": "Spring Oscillation", "tags": ["spring"], "likes": 3, "viewed": 205, "published": "Public", "date": "1484466352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timescale = iTime*3.5;\n    float PI = 3.1415926535897932384626433832795;\n    \n    vec2 R = iResolution.xy;\n\tvec2 relpos = .5*(fragCoord - 0.5*R)/R.y;\n    relpos.y += .25;\n    \n    float xpos = 0.;\n    float ypos = sin(timescale)*0.1+0.25;\n    \n    vec4 R4 = vec4(R.x, R.y, R.x, R.y);\n    vec4 relMouse = .5*(iMouse - 0.5*R4)/R.y;\n    relMouse.y += .25;\n    relMouse.w += .25;\n    \n    if(length(relMouse.xy - vec2(xpos, ypos)) < 0.02) {\n        ypos = relMouse.y;\n    }\n    \n    float rad = length(relpos - vec2(xpos, ypos))*50.;\n    \n    float coils = 12.0;\n    float spring = 0.01*sin(coils*2.*PI*(0.5-relpos.y)/(0.5-ypos));\n\t\n    fragColor = vec4(rad > 1. && (abs(relpos.x-spring) > 0.001 || relpos.y < ypos));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 783]], "test": "error"}
{"id": "MtKXz3", "name": "Tunnel of thorns", "author": "balkhan", "description": "tunnel fx", "tags": ["3d", "raymarching"], "likes": 2, "viewed": 176, "published": "Public", "date": "1485298736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\n//#define PULSE // uncomment this line to get it pulsing\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2(.35+sin(t)/2.+f.x/iResolution.x, sin(-t)/3.+f.y/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 20.0);\n\tvec3\tbase;\n\n    pos.z -= 400.;\n    pos.z -= t*20.;\n\n    vec4\tinter = (march(pos, dir));\n\n\tif (inter.y == 1.)\n\t{\n\t\tvec3\tv = pos+inter.w*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = pos+vec3(100.0, 10.0, -10.0);\n\t\tvec3\tlight_color = vec3(.3, .7, .5);\n        vec3\tvl = normalize( (light_pos - v) );\n\t\tfloat\tdiffuse  = max(0.15, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0., dot(vl, ref_ev)), 3. );\n        base.xyz = texture(iChannel0, vec2( (v.zz)*.042)).xyz;\n        col.xyz = light_color * (specular) + diffuse * (base-inter.x/200.); // light + fake (AO distance based)\n        col.xyz += inter.w / 200.; // add more fake\n    }\n    c_out =  vec4(col,1.0);\n}    \n\nfloat\tde(vec3 p)\n{\n\tfloat\tmind = 1e5;\n\tfloat\ta = cos( cos(t/3.+(p.x*p.x+p.y*p.y)*.005)*- cos(t/4.+(p.z*p.z) *.03)) * 4.;\n\tvec3\tpr = p*.35;\n\n\trotate(pr.xy, (cos(a)*cos(t*8.+length(p.z+p.x+p.y) )*.05+sin(t) ));\n\n\tpr.xy*=2.;\n\tpr.xyz -= floor(pr.xyz);\n\tpr -= .5;\n    \n    mind = length(-abs(pr.zz)+abs(pr.xy)) - .1;\n    \n\treturn (mind);\n}\n\nfloat\tde_4(vec3 p) // cylinder\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p;\t\n\tvec2\tq;\n    \n\tq = vec2(length(pr.yx) - 4., pr.z );\n    #ifdef PULSE\n    q.y = rot(q.xy, vec2(-1.+sin(t*10.), 0.)).x;\n\t#else\n    q.y = rot(q.xy, vec2(-1., 0.)).x;\n    #endif\n\tmind = length(q) - 3.5;\n\n\treturn mind;\n}\n\nfloat\tde_2(vec3 p)\n{\n    return (de(p)-de_4(p)/8.);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    vec2\trot = vec2( cos(t/2.), sin(t/2.) );\n\tp.x += rot.x*5.;\n\tp.y += rot.y*5.;\n\n\tmind = de_2(p);\n\t\n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y+dist.x;\n    return (step);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    e /= 100.;\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.85) * right + (uv.y-0.5) * up + fov * forw));\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKXz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[372, 372, 415, 415, 1359], [1365, 1365, 1383, 1383, 1699], [1701, 1701, 1733, 1733, 1983], [1985, 1985, 2005, 2005, 2038], [2040, 2040, 2061, 2061, 2204], [2207, 2207, 2239, 2239, 2635], [2651, 2651, 2691, 2691, 2766], [2768, 2768, 2796, 2796, 2904], [2907, 2907, 2957, 2957, 3232], [3234, 3234, 3256, 3256, 3470]], "test": "error"}
{"id": "MtKXzc", "name": "My Bars", "author": "arda", "description": "Ongoing experiment...", "tags": ["retro", "bars", "90s", "vaporwave"], "likes": 20, "viewed": 1550, "published": "Public API", "date": "1485350537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy;\n    float C = 1.-U.y/R.y;\n\tU =5.* ( U+U-R) / R.y;         // normalized coordinates\n    U.y = 1.-U.y*2.;                   // swap vertical\n    U /= 1.+U.y/10.;                // perspective\n    U.y -= iTime;\n    U = abs(fract(U)-.50);           // distance to axis\n    U = .1/ sqrt(U);                // turn to blured line\n    O = (U.x*C+U.y*C*2.) * vec4(.3,.3,1.,0) * C + vec4(.4,0.1,.2,0.) * C; // combine H&V + color * inverted fade\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "MdjGz3", "previewfilepath": "https://soundcloud.com/ernesto-vaughn/macintosh-plus-floral-shoppe-9", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ernesto-vaughn/macintosh-plus-floral-shoppe-9", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 508]], "test": "valid"}
{"id": "MtV3Ry", "name": "Colored Mandelbrot Set", "author": "AxleMike", "description": "Colored Mandelbrot Set\nBased on https://blogs.msdn.microsoft.com/shawnhar/2006/12/12/technicolor-julias/", "tags": ["mandelbrot"], "likes": 0, "viewed": 517, "published": "Public API", "date": "1484961464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Alexander Lemke, 2017\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 uv = fragCoord.xy / iResolution.yy;\n    \n    float z = 1.0 + cos(iTime * 0.125) * 0.99;\n    vec2 o = (iMouse.z > 0.0) ? iMouse.xy / iResolution.xy * vec2(2.0) - vec2(2.2, 1.3) : -vec2(1.2, 0.32);    \n    vec2 c = (uv - vec2(0.5)) * z + o;\n    \n    vec2 v = vec2(0);\n    float m = 0.0; \n    const float r = 5.0;   \t    \n    for (int i = 0; i < 256; ++i)\n    {\n        v = vec2(v.x * v.x - v.y * v.y, 2.0 * v.x * v.y) + c;\n        m = (dot(v, v) < (r * r)) ? (m + 1.0) : m;\n        v = clamp(v, -r, r);\n    }  \n    fragColor = (int(m) != 256) ? sin(m / vec4(4, 8, 12, 1)) * 0.25 + 0.75 : vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtV3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "MtVSDD", "name": "phong_specular", "author": "sanctify", "description": "A phong and specular effect", "tags": ["phongspecular"], "likes": 0, "viewed": 111, "published": "Public", "date": "1484494142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.0,0.5, 0.0), vec3(0.0, 0.6, 0.0),vec3(0.0,0.8,0.0));\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  vec3 lightPos = vec3(5.0*sin(iTime), 5.0*cos(iTime), 5.0*sin(iTime));\n  const vec3 lightColor = vec3(0.0, 0.75, 0.0);\n  const vec3 SpecC = vec3(0.25, .25, .25);\n  const vec3 objColor = vec3(1.0, 1.0, 1.0);\n    \n  // Color of the object comes from background !\n  vec3 c = 0.1*background(n);\n  vec3 l = normalize(lightPos - p);\n    \n  //Gestion du reflet\n  vec3 reflet = reflect(-l,n);\n    \n  float specAngle;\n  float specular;\n\n  // PHONG\n  float diff = dot(n, l);\n    \n  if(diff <0.0){\n     diff = 0.0;\n  }else{\n  \tspecAngle = max(dot(reflet, l), 0.0);\n    specular = pow(specAngle, 12.0);\n  }\n  c += objColor*diff*lightColor;\n    \n  //SPECULAR\n  c+= SpecC*specular;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n  vec4 c = vec4(0,0,0,1);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0)+c;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 280, 280, 379], [381, 448, 483, 483, 556], [582, 696, 742, 742, 779], [781, 872, 902, 902, 920], [922, 1010, 1040, 1040, 1063], [1065, 1111, 1133, 1133, 1329], [1331, 1371, 1402, 1402, 1622], [1624, 1729, 1780, 1780, 2215], [2217, 2322, 2379, 2379, 2830], [2833, 2853, 2879, 2879, 2954], [2956, 3017, 3045, 3062, 3746], [3888, 3888, 3945, 3945, 4726]], "test": "valid"}
{"id": "MtVSRy", "name": "Fractal Experiment 25", "author": "aiekick", "description": "click for see the full fractal 1/(zÂ²+c)", "tags": ["fractal", "experiment", "25"], "likes": 3, "viewed": 398, "published": "Public API", "date": "1484853839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on is shader : https://www.shadertoy.com/view/MltXz2\n\n// z * z\nvec2 zmul(vec2 a, vec2 b)\n{\n\t//return vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n    return mat2(a,-a.y,a.x)*b;\n}\n\n// 1 / z\nvec2 zinv(vec2 a)\n{\n\treturn vec2(a.x, -a.y) / dot(a,a);\n}\n\nconst float AA = 2.;\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n    \n    \n    for( float m=0.; m<AA; m++ )\n    for( float n=0.; n<AA; n++ )\n    {\n        vec2 offset = vec2(m,n) / AA - 0.5;\n        vec2 uv = ((g+offset)*2.-si)/min(si.x,si.y) ;\n        uv *= 30. * (sin(10.6+iTime * 0.01)*.5+.5);//zoom\n        uv += vec2(-0.46022,0.746155);\n        if (iMouse.z > 0.)\n            uv = ((g+offset)*2.-si)/min(si.x,si.y) * 2.;\n        vec2 z = uv;\n        vec2 c = vec2(0.66,1.23);\n        float it = 0.;\n        for (int i=0;i<600;i++)\n        {\n            z = zinv(zmul(z, z) + c);\n            if( log2(log2(dot(z,z)))>1.3 ) break;\n            it++;\n        }\n        if (it <  99.5)\n        {\n        \tfloat sit = -it/pow(length(z),0.88);\n            fragColor += 0.5 + 0.5*cos( 3.0 + sit*0.2 + vec4(1,0,1,1));\n        }\n    }\n    \n    fragColor /= AA * AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 72, 99, 149, 182], [184, 193, 212, 212, 250], [278, 278, 335, 335, 1214]], "test": "valid"}
{"id": "MtVXW1", "name": "Blinn-Phong Lighting", "author": "sakib", "description": "Simple Blinn-Phond lighting model", "tags": ["lighting", "blinnphong"], "likes": 0, "viewed": 279, "published": "Public", "date": "1484259463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/********************************************************************\nBlinn-Phong Shading\n\nAuthor : Sakib Saikia 1/12/2017\n********************************************************************/\n\n#define PI 3.141592\n\nvec3 spherePos = vec3(0.0,0.0,0.0);\nfloat sphereRadius = 1.0;\nvec3 albedo = vec3(1.0,0.0,0.0);\nvec3 bgColor = vec3(0.6,0.6,0.6);\nvec3 eye = vec3(0.0,0.0,-2.0);\nvec3 ambient = vec3(0.02);\nvec3 spec = vec3(1.0);\nfloat gloss = 50.0;\n\n// Construct inverse LookAt matrix. Convert from view space to world space\n// eyePos \t- eye/camera position in World Space\n// v \t\t- LookAt position in world space\nmat3 invLookAt(vec3 eyePos, vec3 v)\n{\n    vec3 worldUpDir = vec3(0.0,1.0,0.0);\n    vec3 viewLookDir = normalize(v - eyePos);\n    vec3 viewRightDir = normalize(cross(worldUpDir, viewLookDir));\n    vec3 viewUpDir = normalize(cross(viewLookDir, viewRightDir));\n    \n    return mat3(viewRightDir, viewUpDir, viewLookDir);\n}\n\nvec3 getLightDir()\n{\n    float azimuth = 0.25 * PI;\n    float zenith = 0.5 * PI + iTime;\n    return vec3(cos(azimuth) * sin(zenith), sin(azimuth) * sin(zenith), cos(zenith));\n}\n\n// Sphere ray trace\n// p - ray trace origin in world space\n// d - ray direction in world space\n// o - sphere origin in world space\n// r - sphere radius\n// See : http://www.cs.virginia.edu/~gfx/Courses/2008/AdvancedGraphics/lectures/lecture07_implicit.pdf\nfloat rayTrace(vec3 p, vec3 d, vec3 o, float r)\n{\n    vec3 op = p - o;\n    \n    float a = 1.0;\n    float b = 2.0 * dot(d, op);\n    float c = dot(op, op) - r * r;\n    \n    float t = b*b - 4.0*a*c;\n    if(t >= 0.0)\n    {\n        return (-b - sqrt(t))/(2.0 * a);\n    }\n    else\n    {\n        return -1.0;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixelColor = bgColor;\n    \n    // NDC\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Inverse View matrix\n    mat3 viewMat = invLookAt(eye, spherePos); \n    \n    // Ray direction in world space\n    vec3 rayDir = viewMat * normalize(vec3(p.xy, 0.75));\n    \n    // Ray trace!\n    float t = rayTrace(eye, rayDir, spherePos, sphereRadius);\n    \n    if(t > 0.0)\n    {\n        vec3 pos = eye + t * rayDir;\n        vec3 n = normalize(pos - spherePos);\n        vec3 l = normalize(getLightDir());\n        vec3 v = normalize(-eye);\n        vec3 h = normalize(l - v);\n        \n        // -- Ambient \n        pixelColor = albedo * ambient;\n        \n        // -- Diffuse \n    \tpixelColor += albedo * max(dot(n, l), 0.0);\n        \n        // -- Specular\n        // Use clamp() instead of max() as dot product between normalized vectors\n        // can be above 1.0 due to floating point imprecision. pow() can make those errors worse.\n        // See iq's comment here https://www.shadertoy.com/view/XtGXW1\n        pixelColor += spec * pow(clamp(dot(n,h), 0.0, 1.0), gloss);\n    }\n    \n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(pixelColor,gamma),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 609, 646, 646, 928], [930, 930, 950, 950, 1106], [1108, 1363, 1412, 1412, 1677], [1679, 1679, 1736, 1736, 2933]], "test": "valid"}
{"id": "MtVXzc", "name": "Basic Raymarcher", "author": "hexointed", "description": "A simple ray marcher with phong ligting.", "tags": ["raymarching"], "likes": 1, "viewed": 533, "published": "Public API", "date": "1485349362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float epsilon = 0.001;\n\nfloat scene(vec3, inout int);\nbool march (out vec3, in vec3, in vec3, inout int);\nvec3 calc_gradient(in vec3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 cameraFocalPoint = cameraPosition - vec3(0.0, 0.0, 1.0);\n    cameraPosition.xy += (fragCoord.xy - iResolution.xy/2.0) / iResolution.xx;\n\n    vec3 hitPosition;\n    int id = 1;\n    \n    bool hit = march(hitPosition, cameraPosition, cameraPosition - cameraFocalPoint, id);\n    \n    if(id == 0)\n    \tfragColor = vec4 (1.0, 1.0, 1.0, 1.0);\n    if(id == 1)\n        fragColor = vec4 (1.0, 0.0, 0.0, 1.0);\n    \n    if(!hit) {\n        fragColor*=0.0;\n        return;\n    }\n    \n    vec3 normal = normalize(calc_gradient(hitPosition));\n    vec3 light = vec3(2.0 * sin(iTime), 2.0 * cos(iTime), 0.0);\n    vec3 lm = normalize(light - hitPosition);\n    vec3 rm = normalize(2.0 * dot(lm, normal) * normal - lm);\n    vec3 v = normalize(cameraPosition - hitPosition);\n    \n    fragColor.xyz *= vec3(0.2, 0.2, 0.2) +\n        0.3 * dot(lm, normal) +\n        0.4 * pow(clamp(dot(rm, v),0.0,1.0), 4.0);\n}\n\nvec3 calc_gradient(vec3 p) {\n    vec3 delta = vec3(epsilon, 0.0, 0.0);\n    int id;\n \treturn normalize(vec3 (\n        (scene(p + delta.xyz,id) - scene(p,id))/ epsilon, \n        (scene(p + delta.yxz,id) - scene(p,id))/ epsilon, \n        (scene(p + delta.zyx,id) - scene(p,id))/ epsilon\n   \t));\n    \n}\n\nbool march(out vec3 endPosition, in vec3 startPosition, in vec3 direction, inout int id) {\n    \n    vec3 mdir = normalize(direction);\n    endPosition = startPosition;\n    \n    for(int i = 0; i < 400; i++) {\n        float distance = scene(endPosition,id);\n        \n        if(distance < epsilon)\n            return true;\n        \n        if(distance > 1000.0)\n            return false;\n        \n        endPosition += distance * mdir;\n    }\n    \n    return false;\n    \n}\n\nfloat scene (vec3 p, inout int id) {\n\tfloat s1 = sqrt(p.x*p.x + p.y*p.y + (p.z - 2.0)*(p.z - 2.0)) - 0.5;\n    float s2 = length(p - vec3(2.0 * sin(-iTime), cos(iTime), 0.0)) - 0.2;\n    \n    if(s1 < s2) id = 0;\n    else id = 1;\n    \n    return min(s1,s2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 193, 193, 1135], [1137, 1137, 1165, 1165, 1435], [1437, 1437, 1527, 1527, 1906], [1908, 1908, 1944, 1944, 2164]], "test": "error"}
{"id": "MtySDD", "name": "OJ - Fibber 28, scene 2", "author": "rammoskar", "description": "Full demo: https://www.youtube.com/watch?v=kw5uLHZiRpY\nCurrently a bit uglier then the original", "tags": ["3d", "morph"], "likes": 21, "viewed": 316, "published": "Public", "date": "1484343815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus62( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length6(q)-t.y;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b) //, float k )\n{\n\tfloat k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\n\n//uniform float tick;\n//uniform sampler2D noiseP;\n//uniform vec2 windowSize;\n\n#define MAT_BLOCK 1.0\n#define MAT_LIGHT 2.0\n#define MAT_SPHERE 3.0\n#define MAT_WATER 4.0\n#define MAT_S2_OBJECT 5.0\n#define MAT_DRILL 6.0\n#define MAT_S3_BLOCK 7.0\n#define MAT_BALL 8.0\n#define MAT_S2_BLOCK 9.0\n#define MAT_S4_FLOOR 10.0\n#define MAT_S4_MIRROR 11.0\n#define MAT_S1_TORUS 12.0\n#define MAT_S5_BLOB 13.0\n#define MAT_S5_FLOOR 14.0\n#define MAT_S5_PILLAR 15.0\n#define MAT_MORPH 16.0\n#define MAT_S6_ROOF 17.0\n#define MAT_S2_WATER 18.0\n#define MAT_S6_WATER 19.0\n#define MAT_TEXT 20.0\n#define MAT_TEXT2 21.0\n\n#define EPS 0.01\n\n#define SCENE_0 20\n#define SCENE_1 50\n#define SCENE_2 80\n#define SCENE_3 110\n#define SCENE_4 140\n#define SCENE_5 170\n#define SCENE_6 200\n#define SCENE_7 210\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\nvec2 unn(vec2 a, float dis, float mat)\n{\n\treturn a.x < dis ? a : vec2(dis, mat);\n}\n\n\n\nmat3 rot(float x, float y, float z)\n{\n\tfloat cx = cos(x);\n\tfloat sx = sin(x);\n\tfloat cy = cos(y);\n\tfloat sy = sin(y);\n\tfloat cz = cos(z);\n\tfloat sz = sin(z);\n\tmat3 xm = mat3(1, 0, 0,\n\t\t\t\t\t0, cx, -sx,\n\t\t\t\t\t0, sx, cx);\n\tmat3 ym = mat3(cy, 0, sy,\n\t\t\t  \t\t0, 1, 0,\n\t\t\t  \t\t-sy, 0, cy);\n\tmat3 zm = mat3(cz, -sz, 0,\n\t\t\t\t\tsz, cz, 0,\n\t\t\t\t\t0, 0, 1);\n\treturn xm * ym * zm; \n}\n\n\n\n\n\n\n\n\n\nvec2 water_2(vec3 p, vec3 rd)\n{\n\tfloat t = iTime - float(SCENE_1);\n\tif(rd.y > 0.0){\n\t\treturn vec2(999999, MAT_WATER);\n\t}\n\t\n\tfloat wdis = distance(p.xz, vec2(0, 6));\n\tfloat w = 0.0; \n\tfloat d = \n\t\t(sin(-t * 3.0 + 5.0 * wdis)) * w;// + \n\t\t//TODO texture length(texture(noiseP, p.xz*0.5 + vec2(0, tick*0.1)))*0.1 + \n\t\t//TODO texture length(texture(noiseP, p.xz*0.5 + vec2(tick*0.13, 0)))*0.1;\n\td *= 0.1 * smoothstep(0.0, 5.0, t);\n\n\tfloat h = p.y - d * 0.1;\n\t\n\tfloat dis = (0.1 -p.y)/rd.y;\n\n\treturn vec2(max(h, dis), MAT_S2_WATER);\n}\n\n\n\n\n\nbool inRefraction = false;\n\n\nvec2 scene(vec3 p, vec3 rd)\n{\n\tfloat t = mod(iTime,30.0);// - float(SCENE_1);\n\tvec3 s = vec3(1);\n\tvec3 q = mod(p, s) - 0.5 * s;\n\tivec3 n = ivec3(floor(p / s));\n\t\n\t\t\t\t\t\n\tfloat mt = 10.0;\n\tfloat siz = 1.5 + 0.5 * sin(t * 0.3);\n\tvec3 pm = p - vec3(0, 0.5 + sin(t) * 0.1 * t, 0);\n\tfloat a = sphere(pm * rot(t * 0.8, t * 0.5, t * 1.4), siz);\n\tfloat b = sdTorus(pm * rot(t * 0.8, t * 0.5, t * 1.4), vec2(siz, siz * 0.4));\n\tfloat c = sdTorus88(pm * rot(t * 0.8, t * 0.5, t * 1.4), vec2(siz, siz * 0.4));\n\t\n\tfloat t1 = smoothstep(mt*0.0, mt*1.0, t);\n\tfloat t2 = smoothstep(mt*1.0, mt*2.0, t); \n\tfloat t3 = smoothstep(mt*2.0, mt*3.0, t);\n\t\n\tfloat mdis = a*(1.0-t1) + b*t1*(1.0-t2) + c*t2; \n\t\n\tvec2 res = sunk(water_2(p, rd),\n\t\t\t\t\tvec2(mdis, MAT_BALL),\n\t\t\t\t\t0.8);\n\t\n\tfloat roomDis = -sphere(vec3(n), 20.0);//-sdBox(n - vec3(0, 10, 0), vec3(50, 10, 50));\n\tif (roomDis < 0.0) {\n\t\t//res = un(res, vec2(udRoundBox(q, vec3(0.4), 0.1), MAT_S2_BLOCK));\n\t\tvec2 np = vec2(p.x + p.y * 0.5, p.y * 0.5 + p.z);\n\t\tres = un(res, vec2(sdHexPrism(q.xzy + + 0.04 * (0.5 - 0.5/*texture(noiseP, np).x*/), vec2(0.5, 0.5)), MAT_S2_BLOCK));\n\t} else {\n\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\tfloat a = max(roomDis - 1.73, b + EPS); // TODO 1.73 kan vara for mycket \n\t\tres = un(res, vec2(max(EPS, a), -1));\n\t}\n\treturn res;\n}\n\n\nvec3 getNormal(vec3 p, vec3 rd, vec3 ro)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = scene(p + ep.xyz, rd).x - scene(p - ep.xyz, rd).x;\n    normal.y = scene(p + ep.yxz, rd).x - scene(p - ep.yxz, rd).x;\n    normal.z = scene(p + ep.yzx, rd).x - scene(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, float mint, float maxt, float shadowAmbient)\n{\n    for( float t=mint; t < maxt; )\n    {\n        float h = scene(ro + rd*t, rd).x;\n        if( h<0.01 )\n            return shadowAmbient;\n        t += h;\n    }\n    return 1.0;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt )\n{\n\tfloat res = 1.0;\n    float t = mint;\n   for( float t=mint; t < maxt; )\n    {\n\t\tvec2 res = scene( ro + rd*t, rd );\n\t\tfloat h = res.x;\n\t\tfloat m = res.y;\n\t\tif (m  > 0.0) {\n       \t res = min( res, h );\n\t\t}\n\t\tt += h;\n        if( h<0.01 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n/*vec3 applyFog(vec3 rgb, float dis, vec3 rayDir, vec3 sunDir, vec3 p)\n{\n\tfloat fogAmount = 1.0 - exp(-dis*0.005);\n\tfloat sunAmount = 0; //max(0.0, dot(rayDir, sunDir));\n\tvec3 fogColor = mix(vec3(0.3), vec3(1.0,0.9,0.7), pow(sunAmount,12.0));\n\treturn mix(rgb, fogColor, fogAmount);\n}*/\n#define jumps 4\n#define imax 600\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 eye = vec3(0);\n\tvec3 light = vec3(0);\n\tvec3 tar = vec3(0);\n\tbool waterRefract = false;\n\tfloat lightInvSize = 0.5;\n\tfloat shadowAmbient = 0.3;\n\tfloat lightIntensity = 0.004;\n\tbool lightCollision = false;\n\tfloat refJumpDistance = 0.02;\n\tbool shadows = true;\n\tfloat tmax = 800.0;\n\tvec3 skyColor = vec3(0);\n\tbool cubicDis = false;\n\tvec3 rollV = vec3(0, 1, 0);\n    \n\tfloat time = iTime - float(SCENE_1);\n    time *= 0.2;\n    float r = 6.0 + 2.0 * sin(time * 0.1);\n    eye = vec3(cos(time * 0.5) * r, 2, sin(time * 0.5) * r);\n    tar = vec3(0, 1, 0);\n    light = vec3(-10, 5, -10);\n    lightIntensity = 0.001;\n    lightCollision = true;\n    refJumpDistance = 0.1;\n    shadowAmbient = 0.4;\n    shadows = false;\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(rollV, dir)); \n \tvec3 up = cross(dir, right);\n    \n    float u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (iResolution.y/iResolution.x); \n\n    vec3 color = skyColor;\n      \n    float t = 0.0;\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\t\n\tfloat ref = 1.0;\n\tfloat lightAura = 0.0;\n    float breakVar = 0.0;\n\tfor(int j = 0; j < jumps; ++j)\n    {\n        if (breakVar > 0.5) {\n            break;\n        }\n    \tt = 0.0;\n    \t for(int i = 0; i < imax; ++i)\n   \t\t {\n             if (t >= tmax) {\n             \tbreak;\n             }\n\t        vec3 p = ro + rd * t;\n\t        vec2 dm = scene(p, rd);\n\t        float d = dm.x;\n\t        float m = dm.y;\n\t\t\t\n\t\t\t\n\t        if(d < EPS || i == imax || t >= tmax) \n\t        {\n\t        \tvec3 x0 = light;\n\t        \tvec3 x1 = ro;\n\t        \tvec3 x2 = ro + rd;\n\t        \tfloat ldis = pow(length(cross(x2 - x1, x1 - x0)),2.0) / pow( distance(x2, x1), 2.0); \n\t        \tvec3 normal = getNormal(p, rd, ro);\n\t\t\t\t\n\t\t\t\tvec3 invLight = normalize(light - p);\n\t        \tfloat diffuse = max(0.,dot(invLight, normal));\n\t        \tvec3 refrd = reflect(rd, normal);\n\t        \t\n\n\t        \tvec3 n = floor(p);\n\t\t\t\tvec3 c = vec3(0.5);\n\t\t\t\t\n\t\t\t\tif(m == MAT_BLOCK){\n\t\t\t\t\tc = vec3(sin(n.y) * 0.1 + 0.3, sin(n.y) * 0.1 +0.1, sin(n.y) * 0.1 + 0.1)*1.1;\n\t\t\t\t}\n\t\t\t\telse if(m == MAT_SPHERE){\n\t\t\t\t\tc = vec3(0, 0.5, 0);\n\t\t\t\t}\n\t\t\t\telse if(m == MAT_WATER){\n\t        \t\tc = vec3(1); \n\t\t\t\t}\n\t\t\t\telse if (m == MAT_S2_OBJECT) {\n\t\t\t\t\tc = vec3(1, 0, 0);\n\t\t\t\t} else if (m == MAT_DRILL) {\n\t\t\t\t\t\n\t\t\t\t} else  if (m == MAT_S3_BLOCK) {\n\t\t\t\t\t/*if (n.z == 16) {\n\t\t\t\t\t\tc = sin(2*distance(vec2(n.xy), vec2(0, 0)) ) > 0 ? vec3(0.1, 0.2, 0.6) : vec3(0.01, 0.01, 0.01);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = vec3(0.1, 0.2, 0.6);\n\t\t\t\t\t}*/\n\t\t\t\t\tc = vec3(sin(n.x)*0.5 + 0.5, sin(n.y)*0.5 + 0.5, sin(n.z)*0.5 + 0.5);\n\t\t\t\t} else if (m == MAT_BALL) {\n\t\t\t\t\tc = vec3(0.5);\n\t\t\t\t} else if (m == MAT_S2_BLOCK) {\n\t\t\t\t\tint t = int(iTime - float(SCENE_1));\n\t\t\t\t\tc = vec3(n.y * 0.05, n.y * 0.08, n.y * 0.03);//vec3(sin(n) * 0.1);\n\t\t\t\t\t//if (int(n.y) % 6 == t % 6) {\n\t\t\t\t\t//\tc.r = 1;\n\t\t\t\t\t//}\n\t\t\t\t\tclamp(c, 0.0, 1.0);\n\t\t\t\t} else if (m == MAT_S4_FLOOR) {\n\t\t\t\t\t\n\t\t\t\t} else if (m == MAT_S4_MIRROR) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t} else if (m == MAT_S1_TORUS) {\n\t\t\t\t\t\n\t\t\t\t} else if (m == MAT_S5_BLOB) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t} else if (m == MAT_S5_FLOOR) {\n\t\t\t\t\tc = vec3(0.9);\n\t\t\t\t} else if (m == MAT_S5_PILLAR) {\n\t\t\t\t\tc = vec3(0.8, 0, 0);\n\t\t\t\t} else if (m == MAT_MORPH) {\n\t\t\t\t\tvec3 pc = p + vec3(90);\n\t        \t\tvec3 matCol = vec3(pc.x/10.0, (pc.x + pc.z) / 5.0, pc.z/8.0);\n\t        \t\tc = (sin(matCol) + 1.0) * 0.5;\n\t\t\t\t} else if (m == MAT_S6_ROOF) {\n\t\t\t\t\tc = vec3(0, 0, 1);\n\t\t\t\t} else if (m == MAT_S2_WATER) {\n\t\t\t\t\tc = vec3(0.3, 0.3, 0.6);\n\t\t\t\t} else if (m == MAT_S6_WATER) {\n\t\t\t\t\tc = vec3(0.6, 0.6, 1.0);\n\t\t\t\t} else if (m == MAT_TEXT) {\n\t\t\t\t\tc = vec3(1, 0, 0);\n\t\t\t\t}\n\t\t\t\t\n\t        \tif (inRefraction) {\n\t\t\t\t\t\n\t        \t} else {\n\t\t\t\t\tc = 0.7*c* (1.0 + diffuse);\n\t\t\t\t\tif(shadows && m != MAT_S5_BLOB){\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t        \tc += specular(normal, -invLight, normalize(eye - p), 70.0);\n\t        \t}\n\t            \n\t            float dis = length(light - p);\n\t            float disFact = 1.0 / (1.0 + lightIntensity*dis*dis * (cubicDis ? dis : 1.0 ));\n\t            c *= disFact;\n\t\t\t\t\n\t\t\t\t\t        \t\n\t        \tfloat tl = -dot(x1 - x0, x2 - x1)/pow(distance(x2,x1),2.0);\n\t        \tif(tl > 0.0 && ((lightCollision && distance(eye, light) < distance(eye, p)) || !lightCollision)){\n\t        \t\tlightAura = max(lightAura, 1.0/(0.01 + lightInvSize*ldis));\n\t        \t}\n\t\t\t\t//color = applyFog(color, distance(eye, p), rd, vec3(0, 0, 1), p);\n\n\t\t\t\tcolor = mix(color, c, ref);\n\t\t\t\t\n\t\t\t\tif(m == MAT_WATER || m == MAT_S2_WATER || m == MAT_S6_WATER){\n\t\t\t\t\tif (waterRefract) {\n\t\t\t\t\t\trd = refract(rd, normal, 1.0/1.333); \n\t\t\t\t\t\tro = p + rd*0.02;\n\t\t\t\t\t\tinRefraction = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trd = reflect(rd, normal);\n\t\t\t\t\t\tro = p + rd*0.02;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trd = reflect(rd, normal);\n\t         \t\t//ro = p + rd*0.02;\n\t         \t\tro = p + rd*refJumpDistance;\n\t\t\t\t}\n\n\t\t\t\t\n\t            if(m == MAT_LIGHT){\n\t            \tcolor = vec3(0.5, 0.5, 0.5);\n\t            }\n\n\t        \t\n\t        \tif (m == MAT_WATER) {\n\t        \t\t//inRefraction = true;\n\t        \t\tref = 0.8;\n\t        \t} else if (m == MAT_S6_WATER) {\n\t\t\t\t\tref *= 0.8;\n\t        \t} else if (m == MAT_S5_BLOB) {\n\t        \t\tref = 0.7;\n\t        \t} else if (m == MAT_S4_MIRROR) {\n\t        \t\tref = 0.9;\n        \t\t} else if (m == MAT_BALL) {\n\t\t\t\t\tref *= 0.4;\n\t       \t\t} else if (m == MAT_S2_WATER) {\n\t\t\t\t\tref *= 0.5;\n\t       \t\t} else if (m == MAT_MORPH) {\n\t        \t\tref *= 0.4;\n\t        \t} else {\n\t\t        \tref = 0.0;\n\t        \t}\n\t        \tif (ref <= 0.01) {\n\t        \t\t//j = 10000;\n\t\t\t\t\tbreakVar = 1.0;\t        \t\t\n\t        \t}\n\t           \tbreak;\n\t        }\n\t\n\t        t += d;\n    \t}\n    }\n    \n   \n    fragColor = vec4(color + vec3(lightAura),  1.0); \n}\n\n\n  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtySDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 57], [59, 59, 90, 90, 128], [130, 130, 161, 161, 257], [260, 260, 293, 293, 358], [360, 360, 396, 396, 430], [434, 434, 479, 479, 519], [521, 521, 546, 546, 604], [606, 606, 631, 631, 696], [698, 698, 733, 733, 800], [802, 802, 837, 837, 903], [905, 941, 986, 986, 1095], [1097, 1097, 1139, 1139, 1232], [1235, 1235, 1287, 1287, 1414], [1418, 1418, 1454, 1454, 1538], [2307, 2307, 2332, 2332, 2361], [2363, 2363, 2389, 2389, 2521], [2523, 2523, 2559, 2559, 2720], [2723, 2723, 2763, 2763, 2805], [2809, 2809, 2846, 2846, 3172], [3182, 3182, 3213, 3213, 3711], [3746, 3746, 3775, 3775, 5081], [5084, 5084, 5126, 5126, 5405], [5408, 5408, 5472, 5472, 5597], [5599, 5599, 5644, 5644, 6272], [6274, 6274, 6357, 6357, 6535], [6538, 6538, 6612, 6612, 6909], [7230, 7230, 7285, 7285, 12962]], "test": "valid"}
{"id": "MtySDW", "name": "seasickness simulator", "author": "azsteak", "description": "test", "tags": ["2d", "sea"], "likes": 2, "viewed": 85, "published": "Public", "date": "1484324020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 color;\nvec2 coord;\n\nconst float eyeToScreenDistance = 1.0;\nfloat eyeHeight =100.0;\n\nfloat coefHeightDif = 5.0;\n\nfloat waterHeight;\nfloat waveLength = 0.01;\nfloat waveHeight = 40.0;\nfloat transSpeed = 20.0;\n\nvoid drawSun(){\n    vec2 pos = vec2(100,iResolution.y/1.2);\n    \n    \n    if(distance(pos,coord) < iResolution.x/10.0){\n        color = vec4(0.8,0.8,0.2,1.0);\n    }\n}\nvoid wave(float dist){\n    \n    float y = eyeToScreenDistance + (waterHeight/2.0-eyeHeight) / dist + dist;\n    \n    float waveheightCoef = waveHeight/pow(dist,coefHeightDif);\n    \n    float wave = sin(waveLength*coord.x*pow(dist,4.0)+iTime*transSpeed/dist);\n    \n    float rotation = coord.x/-10.0;\n    float animatedRotation = rotation * cos(iTime) ;\n    \n    float height = wave*waveheightCoef+y+waterHeight+animatedRotation;\n    \n    if(coord.y<height){\n        //color = vec4(0,0,max(1.1/pow(dist,coefColorDegrade),0.4),1.0);\n        color = vec4(0,0.1*dist,dist,1.0);\n    }\n    \n}\nvoid rotateScreen(float angle){\n    coord.x = coord.x*cos(angle) + coord.y * sin(angle);\n    coord.y =-coord.x*sin(angle) + coord.y * cos(angle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    waterHeight = iResolution.y/2.0;\n    color = fragColor;\n    coord = fragCoord;\n    //rotateScreen(iTime*1.0);\n    color = vec4(0.6,0.6,1.0,1.0);\n    \n    float coefScreen = iResolution.y/5.0;\n    eyeHeight = cos(iTime*2.0)*coefScreen+2.5*coefScreen;\n    \n    \n    drawSun();\n    for(float d = 4.0 ; d > 1.0 ; d-=0.4){\n        wave(d);\n    }\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtySDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 227, 227, 378], [379, 379, 401, 401, 964], [965, 965, 996, 996, 1112], [1114, 1114, 1171, 1171, 1546]], "test": "valid"}
{"id": "MtySDy", "name": "Green-Mandelbrot", "author": "Moritz", "description": "Zoom into the Mandelbrot Set", "tags": ["fractal", "mandelbrot"], "likes": 3, "viewed": 482, "published": "Public API", "date": "1485667373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int granularity = 180;\nconst float zoomTimeLength = 25.0;\nconst float maxZoom = 80.0;\nconst float minZoom = 0.0001;\nconst vec2 center = vec2(0.3855, 1.0114);\nconst float speed = zoomTimeLength / (maxZoom / minZoom);\nconst vec3 baseColor = vec3(0.6, 0.9, 0.0);\n\nvec2 complexTimes(vec2 a, vec2 b) {\n    return mat2(a,-a.y,a.x) * b;\n}\n\nint mand(vec2 z0) {\n    vec2 z = z0;\n\n    for (int t = 1; t < granularity; t++) {\n        if (dot(z,z) > 2.0) {\n            return t;\n        }\n        z = complexTimes(z, z) + z0;\n    }\n    \n    return granularity;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = mod(iTime, zoomTimeLength);\n    float tf = t / zoomTimeLength;\n    \n    float scale = maxZoom / (t / speed);\n    scale = pow(scale, tf);\n    \n    vec2 coord = (fragCoord / iResolution.xy - 0.5) * 2.0;\n    coord *= scale;\n    coord += center;\n    coord.y *= iResolution.y / iResolution.x;\n    \n    int res = mand(coord);\n    \n    vec3 color = (1.4 - tf) * 2.0 * baseColor * (float(res) / float(granularity));\n\n    if (res == granularity) {\n    \tcolor = vec3(0);;\t\n    }\n    \n\n    //color.x += 1.0 - tf;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtySDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 302, 302, 337], [339, 339, 358, 358, 556]], "test": "valid"}
{"id": "MtySRG", "name": "Dick-stribution", "author": "Patapom", "description": "Custom distribution shape for a noise with balls!\n", "tags": ["noise"], "likes": 4, "viewed": 155, "published": "Public", "date": "1484758842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modification of https://www.shadertoy.com/view/4ssXRX\n// I'm being a dick...\n\nconst int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 4096;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat trunc2( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\n\nfloat mapCDF( float x ) {\n    x = clamp( x, 0.0, 1.0 );\n    if ( x < 0.01171875 ) {\n        // Hairs\n        return 84.375 * x;\n    } else if ( x < 0.2265625 ) {\n        // Balls\n        const float a = 0.375714, b = 4.07111, c = -37.1765, d = 198.689, e = -369.137;\n        return a + x * (b + x * (c + x * (d + x * e)));\n\t} else {\n        // Tip\n\t    const float a = 0.655355, b = 0.378746, c = -0.035822;\n\t\treturn a + x * (b + x * c);\n    }\n}\n\nfloat n2rand_special( vec2 n ) {\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n    float value = 0.5 * mapCDF( nrnd0 );\n    return nrand( n + 0.11*t ) < 0.5 ? value : 1.0 - value;\t// Mirror the dick...\n}\n\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\nfloat n4rand_inv( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    float nrnd4 = nrand( n + 0.19*t );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n\n/*\n//alternate Gaussian,\n//thanks to @self_shadow\nfloat n4rand( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( iTime ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( iTime + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n*/\n/*\n//Mouse Y give you a curve distribution of ^1 to ^8\n//thanks to Trisomie21\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\t\n\tfloat p = 1. / (1. + iMouse.y * 8. / iResolution.y);\n\tnrnd0 -= .5;\n\tnrnd0 *= 2.;\n\tif(nrnd0<0.)\n\t\tnrnd0 = pow(1.+nrnd0, p)*.5;\n\telse\n\t\tnrnd0 = 1.-pow(nrnd0, p)*.5;\n\treturn nrnd0; \n}\n*/\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( trunc2(t,NUM_BUCKETS_F), trunc2(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = n1rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<3 )\n\t\t\tr = n2rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<4 )\n\t\t\tr = n2rand_special( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<5 )\n\t\t\tr = n3rand( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = n4rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat o;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < 1.0/5.0 )\n\t{\n\t\to = n1rand( uv );\n        idx = 1;\n        uvrange = vec2( 0.0/5.0, 1.0/5.0 );\n\t}\n\telse if ( uv.x < 2.0 / 5.0 )\n\t{\n\t\to = n2rand( uv );\n        idx = 2;\n        uvrange = vec2( 1.0/5.0, 2.0/5.0 );\n\t}\n\telse if ( uv.x < 3.0 / 5.0 )\n\t{\n\t\to = n2rand_special( uv );\n        idx = 3;\n        uvrange = vec2( 2.0/5.0, 3.0/5.0 );\n\t}\n\telse if ( uv.x < 4.0 / 5.0 )\n\t{\n\t\to = n3rand( uv );\n        idx = 4;\n        uvrange = vec2( 3.0/5.0, 4.0/5.0 );\n\t}\n\telse\n\t{\n\t\to = n4rand( uv );\n        idx = 5;\n        uvrange = vec2( 4.0/5.0, 5.0/5.0 );\n\t}\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(uv.x - 1.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 2.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 3.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 4.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 1.0/4.0) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtySRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 334, 357, 357, 425], [426, 470, 512, 512, 556], [557, 587, 621, 621, 645], [647, 647, 671, 671, 751], [752, 752, 776, 776, 906], [908, 908, 933, 933, 1353], [1355, 1355, 1387, 1387, 1575], [1577, 1577, 1601, 1601, 1773], [1774, 1774, 1798, 1798, 2013], [2014, 2014, 2042, 2042, 2428], [3042, 3042, 3122, 3122, 4012], [4014, 4014, 4071, 4071, 5124]], "test": "valid"}
{"id": "MtySWw", "name": "SandSphereTest", "author": "Jabberwock", "description": "Hi", "tags": ["3d"], "likes": 0, "viewed": 68, "published": "Public", "date": "1484577982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 red=vec3(1.0,1.0,1.0);\nconst vec3 yellow=vec3(0.95,0.85,0.45);\n\n// Simple color\n// p : Point on object\n// n : Normal at point\nvec3 color(in vec3 p,in vec3 n)\n{\n    return vec3(1,1,1);\n}\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v =  p.x * 10.0;//v=mod(floor(40.0*p.x)/*+floor(p.y)+floor(p.z)*/,2.1);\n    v -= floor(v);\n    v= pow(v ,2.0);\n    return mix(red,yellow,v);\n}\n\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    float t = noise(300.0*p);\n    if(t<0.935){\n        return mix(red,yellow,t);\n    }else{\n        return vec3(5.0);\n    }\n   \n    //return checker(p+a*noise(120.*p),n); \n    //return checker(p+a*noise(1.5*p),n);\n}\n\n// Color sine wave\nvec3 sine(in vec3 p,in vec3 n)\n{\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    float v=0.5*(1.0+cos(70.0*sqrt(dot(pa,pa))));\n        return mix(red,yellow,v);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-4.0);\n    const vec3 lightColor = vec3(1.0);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.55*warped(p,n,0.3);//*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtySWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 128, 163, 163, 232], [234, 316, 340, 340, 383], [385, 416, 442, 442, 811], [962, 1024, 1057, 1057, 1083], [1085, 1142, 1177, 1177, 1330], [1332, 1332, 1377, 1377, 1593], [1595, 1614, 1646, 1646, 1765], [1842, 2024, 2102, 2102, 2337], [2414, 2455, 2483, 2483, 2556], [2558, 2604, 2637, 2656, 3105], [3107, 3164, 3202, 3202, 3283], [3360, 3360, 3417, 3417, 3986]], "test": "valid"}
{"id": "MtyXDR", "name": "Gas Giant PZ043", "author": "nothke", "description": "MY FIRST THING!\n\nOriginal planet base by glkt: https://www.shadertoy.com/view/XlGSDR", "tags": ["planet"], "likes": 2, "viewed": 156, "published": "Public", "date": "1483840536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \n\nconst float radius = 0.7;\nconst vec3 sunDir = vec3(.707,.707,0.);\n\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nvec3 rotateX(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\nfloat hash( vec3 p ) {\n    float h = dot(p,vec3(127.1,311.7,79.1));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// from iq\nfloat OrenNayar( in vec3 l, in vec3 n, in vec3 v, float r )\n{\n\t\n    float r2 = r*r;\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, l);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\nfloat noise( in vec3 p ) { // base noise\n\n    // iq 3d noise\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    float v = mix( mix( mix( hash( i + vec3(0.,0.,0.) ), \n                             hash( i + vec3(1.,0.,0.) ), u.x),\n                        mix( hash( i + vec3(0.,1.,0.) ), \n                             hash( i + vec3(1.,1.,0.) ), u.x), u.y),\n                   mix( mix( hash( i + vec3(0.,0.,1.) ), \n                             hash( i + vec3(1.,0.,1.) ), u.x),\n                        mix( hash( i + vec3(0.,1.,1.) ), \n                             hash( i + vec3(1.,1.,1.) ), u.x), u.y),u.z); \n    \n       // bubble style\n    //v = v * 2. - .5;    \n    //v = abs(cos(v));\n    //v = clamp(v*10.-9.5,0.,1.);\n    //float sv = abs(sin(v));    \n    //v = mix(sv,cv,sv);\n    \n    return 1.-v;\n   \n}\n\nvec3 getP(vec2 uv){           \n    \n    float r = sqrt(radius - uv.x*uv.x - uv.y*uv.y);  \n    \n    vec3 p = vec3(uv.x,uv.y,r);\n    \n\tp = rotateX(p,-iMouse.y/(iResolution.y*0.15));\n    p = rotateY(p,-iMouse.x/(iResolution.x*0.3));\n    \n    //float n = noise(p*20.);\n    float n = 0.;\n    \n    p *= 1.+n/10.;\n    \n    return p;    \n}\n\nvec3 getColor(vec2 uv){\n    \n    float d = length(uv);\n    vec3 c = vec3(0.,0.,0.);\n    \n    // planet\n    \n    if ( radius*1.2 - d > 0.){ \n\n        vec3 p = getP(uv);\n        vec3 py = vec3(p.z,0, p.x);\n        \n        float nsd = noise(py * 5.);\n\n        \n        float ns = noise(0.02 * iTime + p * (4.));// + sin(iTime)));\n        float ns2 = noise(iTime + p * 6.);\n        \n        float t = iTime * 0.06;\n        \n        float strOffset = 0.;\n        strOffset += 2. * (1.3 + noise(t + py * 5.));\n        strOffset += 2. * (0.34 + noise((t+2.34) + p * 0.3));\n        strOffset += 3. * (2.78 + noise((t+34.56) + p * 7.3));\n        // Adds a little bit of lattitude variety to stripes:\n        strOffset += 0.1 + sin(p.y * 15.45) * 0.9;\n        //strOffset *= 1. * noise(py * 2.);\n        \n        float str = 0.;\n        str = sin(strOffset + p.y * 30.); // the birth of stripes\n        \n        float strClamped = clamp(str,0.,1.); // use clamped for coloring\n        \n        //str = clamp(str,0.,1.); // to CLAMP ? ...\n        str = abs(str); // or to ABS ?\n        \n        \n        \n        //str += hash(p)*0.1; // fuzz\n        \n        //str += 2. * (cos(p.x) * sin(p.z));\n        //str*=1. * noise(py * 30. + iTime);\n        \n        /*\n        float offset = 4. * noise(p * 0.4);\n        float numOfStripes = 4.;\n        float thickness = 0.1 * ns2;\n        \n        float inM = mod(offset + p.y, 1. / numOfStripes);\n        //float less = 0.1 * nsd + 0.4 + 0.03 * ns2;\n        float less = thickness;\n        \n        //float str = smoothstep(0., 1., inM);\n        float str = inM < less ? 1. : 0.;\n        */\n        \n        vec3 stripes = vec3(0.4, 0.4, 0) * str;\n        \n        float light = 0.;\n        light += clamp(dot(sunDir,p),0.,1.);\n        //light += OrenNayar(sunDir,p,vec3(1,1,1),1.);\n        \n        float light2 = clamp(dot(vec3(.707,0,.707),p),0.,1.) / 4.;\n\n        float specular = pow(light,10.);\n\n        float rim = pow(length(uv)/radius,8.) /30.;\n\n        //light += specular + rim;\n        \n        // BASE\n        //c += vec3(0,0.2,0.2);\n        c += vec3(0.6,0.4,0.1);\n                \n        // noise test\n        //c.r = noise(4.786+p*10.);\n        //c.r = clamp(c.r, 0., 1.);\n        \n        c += stripes;\n        \n        // mult green a bit to get a reddish color of odd stripes\n        c.g *= 1. - strClamped*0.15 * (1. +p.y  * 3.);\n        // mult red a bit to get greenish color\n        c.r *= 1. - strClamped*0.15 * (1. -p.y  * 2.);\n        // lil bit more shading\n        c.b += sin(p.y * 3.) *0.2;\n        \n        //c = vec3(1.,.9,.7)+ stripes;\n        //c = vec3(strClamped, strClamped, strClamped);\n        \n        \n        // LIGHT\n        c *= light;\n        //c *= light;\n        //c += vec3(2.,.5,.5) * specular;\n        //c += vec3(.1,.4,.8) * rim;\n        //c += vec3(.1,.5,.8) * light2;\n    }\n    \n    return c;\n}\n\nfloat gamma = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3 c = getColor(uv);\n\tfragColor = vec4(pow(c, vec3(1./gamma)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 103, 103, 224], [226, 226, 256, 256, 376], [378, 378, 400, 400, 488], [490, 501, 562, 562, 840], [842, 842, 868, 902, 1695], [1697, 1697, 1716, 1716, 2028], [2030, 2030, 2053, 2053, 4913], [4935, 4935, 4992, 4992, 5164]], "test": "valid"}
{"id": "MtyXzt", "name": "Fractal Seizure", "author": "hhhzzzsss", "description": "Maybe it's too late but this shader may cause epilepsy...\nUpdate: smooth shading\nUpdate: better smooth shading", "tags": ["2d", "fractal", "juliaset", "flashingcolors"], "likes": 4, "viewed": 208, "published": "Public", "date": "1485403887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 randDisplacement() {\n    return vec2(fract(sin(iTime*14237.14238)*23403.24234),\n                fract(sin(iTime*35034.24809)*23473.42303));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv *= 0.7+0.3*sin(iTime*14.2354);\n    uv.x *= iResolution.x / iResolution.y;\n    float theta = iTime*10.0;\n    mat2 rot = mat2 (cos(theta), sin(theta), -sin(theta), cos(theta));\n    uv *= rot;\n    uv += 0.4*randDisplacement();\n    \n    vec2 z = uv;\n    vec2 c = vec2(-0.73+0.05*cos(30.5142*iTime+0.3),0.3+0.1*sin(10.0*iTime+0.9));\n    \n    float iterations = -1.0;;\n    for (float i = 0.0; i < 200.0; i++) {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if (dot(z,z) > 256.0) {\n            iterations = i;\n            break;\n        }\n    }\n    \n    iterations = iterations + 2.0 - log(log(length(z)))/log(2.0);\n    \n    float hue = pow(iterations/50.0,0.4+0.2*sin(4.534243*iTime));\n    hue += iTime*10.0;\n    \n\tfragColor = vec4(hsv2rgb(vec3(hue,1.0,1.0)) ,1.0);\n    \n    if (iterations < 0.0) fragColor = vec4(vec3(0.0),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 218, 218, 339], [341, 341, 398, 398, 1324]], "test": "valid"}
{"id": "XlcSDX", "name": "Lines2", "author": "azsteak", "description": "youhouuuu", "tags": ["lines"], "likes": 0, "viewed": 85, "published": "Public", "date": "1484324559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float animSpeed = 10.0;\n\nvoid mainImage( out vec4 color, in vec2 fragCoord )\n{\n    color = vec4(0,0,0,1);\n    float size = 10.0;\n    float intensity = cos((fragCoord.x+fragCoord.y)*0.01+iTime*animSpeed)*tan(fragCoord.x*fragCoord.y)*0.8;\n    if(sin(fragCoord.y/size) < mod(sin(fragCoord.x/size+3.14*iTime),cos(iTime))){\n        color = vec4(intensity,0,0,1);\n    }else if(-sqrt(cos(fragCoord.y/size-3.14*iTime)) < sin(fragCoord.x/size)){\n        color = vec4(0,intensity,0,1);\n    }\n    else if(cos(fragCoord.y/size+3.14*iTime) < cos(fragCoord.x/size)){\n        color = vec4(0,0,intensity,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcSDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 78, 78, 599]], "test": "valid"}
{"id": "XlGSDG", "name": "Simple YT Raytracer", "author": "Loeizd", "description": "from tutorial https://www.youtube.com/watch?v=9g8CdctxmeU", "tags": ["simple", "raytracer"], "likes": 0, "viewed": 121, "published": "Public", "date": "1485543046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from tutorial https://www.youtube.com/watch?v=9g8CdctxmeU\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t// a sphere centered at the origin has equation  |xyz| = r\n    // meaning |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n    //...\n    \n    vec3 oc=ro - sph.xyz;\n    float b=(2.0+sin(iTime*8.0)*0.002)*dot(oc,rd);\n    float c=dot(oc,oc) - sph.w*sph.w;\n    float h=b*b - 4.0*c;\n    if(h<0.0) return -1.0;\n    float t=(-b - sqrt(h))/2.0;\n    return t;\n}\n\nvec3 nSphere(in vec3 pos, in vec4 sph)\n{\n    return (pos - sph.xyz)/sph.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd)\n{\n \treturn -ro.y/rd.y;   \n}\n\nvec3 nPlane(in vec3 pos)\n{\n \treturn vec3(0.0, 1.0, 0.0);   \n}\n\n//vec4 sph1 = vec4(0.0, 1.0+sin(iTime*2.3), 0.0, 1.0);\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n    vec4 sph1 = vec4(0.0, 1.0+sin(iTime*2.3), 0.0, 1.0);\n    \n    resT= 1000.0;\n    float id = -1.0;\n    float tsph = iSphere(ro, rd, sph1); //intersect with sphere\n    float tpla = iPlane(ro, rd); //intersect with a plane\n    if(tsph > 0.0)\n    {\n        id=1.0;\n        resT=tsph;\n    }\n    if(tpla > 0.0 && tpla < resT)\n    {\n        id=2.0;\n        resT=tpla;\n    }\n    return id;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //vec3 light = normalize(vec3(0.97,sin(iTime*3.0)*1.5+1.0,0.9));//0.57+sin(iTime*3.0)*1.5));//vec3(0.57703));\n\tvec3 light = normalize(vec3(0.57,0.57,0.57));\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t\n    //define ray origin and direction\n    vec3 ro = vec3(0.0,1.0,3.0*sin(iTime*0.4)+6.0);\n    vec3 rd = normalize(vec3(-1.0+2.0*uv*vec2(1.78,1.0),-1.0));\n    \n    //ray intersect with 3d scene\n    float t;\n    float id = intersect(ro, rd, t);\n    \n    vec4 sph1 = vec4(0.0, 1.0+sin(iTime*2.3), 0.0, 1.0);\n    \n    //draw black by default\n    vec3 c1 = vec3(1.0,1.0,1.0);\n    vec3 c2 = vec3(0.1,0.1,0.15);\n    vec3 col = mix(c2, c1, pow(vec3(uv.x*uv.y,uv.x*uv.y,uv.x*uv.y),vec3(4.0)));// vec3(0.3, 0.3, 0.3);\n    if(id>0.5 && id<1.5)    \n    {\n        //if we hit the sphere, we draw white\n        vec3 pos = ro + t*rd;\n        vec3 nor = nSphere(pos, sph1);\n        float dif = dot(nor, light) + pow(dot(nor, light),60.0);\n        col = vec3(0.71,0.7,0.73)*dif + vec3(0.3,0.3,0.3);\n    }\n    else if(id>1.5)\n    {\n        //we hit the plane\n        vec3 pos = ro+t*rd;\n        vec3 nor = nPlane(pos);\n        float amb = smoothstep(0.0, sph1.w+(sin(-iTime*2.3)*0.5+0.3), length(pos.xz-sph1.xz));\n        col = vec3(0.4,0.4,0.45) + amb*vec3(0.4,0.4,0.4);\n    }\n    \n\t//vec3 col = vec3(uv.y);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 114, 238, 458], [460, 460, 500, 500, 536], [538, 538, 576, 576, 602], [604, 604, 630, 630, 665], [667, 722, 779, 779, 1166], [1169, 1169, 1226, 1345, 2608]], "test": "valid"}
{"id": "XlGSDV", "name": "Test Shader - Raymarch", "author": "Rxanadu", "description": "Test raymarch shader based off YT video from 'dila'", "tags": ["test", "raymarch", "dila"], "likes": 1, "viewed": 96, "published": "Public", "date": "1485887444", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p){\n    vec3 q = fract(p) * 2.0 - 1.0;\n\treturn length(q) - 0.25;\n}\n\nfloat trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 32; ++i){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0.0, iTime, iTime);\n    \n    float t = trace(o, r);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 81], [83, 83, 112, 112, 256], [258, 258, 315, 315, 760]], "test": "valid"}
{"id": "XlGSRd", "name": "Box2Sphere [oo]", "author": "pthextract", "description": "No use of defines in this copy of another shader.\n\t\t[url]https://www.shadertoy.com/view/llyXzc[/url]\n\nSupport for Occulus(3D?)  and stereoscopy 3D, but not VR mode.", "tags": ["sphere", "box", "stereoscopy"], "likes": 3, "viewed": 192, "published": "Public", "date": "1485376356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Created by pthextract in 2017-Jan-24\n/*Now with HmdWarpcode for Occulus ripped from:\n\thttps://www.shadertoy.com/view/MsS3WG */\n\nvec2 HmdWarp(vec2 uv)\n{\n\t// screen space transform(Side by Side)\n\tuv = vec2((mod(uv.x,1.0)-0.5)*2.0+0.2*sign(uv.x), uv.y);\n\n\t// HMD Parameters\n\tvec2 ScaleIn = vec2(1.0);\n\tvec2 LensCenter = vec2(0.0,0.0);\n\tvec4 HmdWarpParam = vec4(1.0,0.22, 0.240, 0.00);\n\tvec2 Scale = vec2(1.0);\n\n\t// Distortion\n\tvec2 theta  = (uv - LensCenter) * ScaleIn; // Scales to [-1, 1]\n\tfloat  rSq    = theta.x * theta.x + theta.y * theta.y;\n\tvec2 rvector= theta * (HmdWarpParam.x + HmdWarpParam.y * rSq\n\t\t\t       + HmdWarpParam.z * rSq * rSq\n\t\t\t       + HmdWarpParam.w * rSq * rSq * rSq);\n\treturn LensCenter + Scale * rvector;\n}\n\nvec4 rend(vec2 uv,float s, float zm)\n    //BORDER AND BACKGROUND\n{vec4 c=.4-.4*vec4(.6,.8,.2,1.)-vec4(0.,.06*uv*uv,1.);\n    if ( (uv.x*uv.x>.77)|| (uv.y*uv.y>.24) ) return c-vec4(.05);\n    uv.x-=s;\t\n \tif (uv.x*uv.y<.11) c+=vec4(.05);\n    if (uv.x*uv.y<.14) c-=vec4(.05);    \n \t uv.x+=s+s;\n\t float f=cos((iTime)*2.), zoff=1.+zm*5.,xd=sin (iTime) *.5, yd=cos (iTime) *.5;\n \tf*=f;\n   \tfor (float x=-.5;x<=.5;x+=.1)for (float y=-.5;y<=.5;y+=.1)for (float z=-.5;z<=.5;z+=.1)//loops \n            if((max(abs(x),max(abs(y),abs(z)))>.39)||fract(iDate.w/5.)<.5) //just rim of cube\n        \t{ \n            vec3 nu=normalize(vec3(x,y,z))*.7;\n             vec2 xy=vec2(xd+x *f+(1.-f)* nu.x,yd+y *f+(1.-f)* nu.y);\n              float zz=z *f+(1.-f)* nu.z+zoff;\n            if(length(xy/zz-uv)<.06/zz)   c+=.08-vec4(.3,.5,1,1)*.08*(fract(x+y+z));\n        \t}           \n return c;\n}\nvoid mainImage( out vec4 C, in vec2 uv )\n{//float s2=.05;\n vec2 R=iResolution.xy;\n     float M=iMouse.x/R.x;\n    float zm=iMouse.y/R.y;\n     float s2=M/5.;//EYES WIDE APART?\n uv+=.5;uv/= R;\n\n if (s2>.02)\n {s2-=2.*s2*float(uv.x<.5);\n  if (M<.6) {uv.x=fract(uv.x*2.);}}\n uv-=.5;uv.x*=R.x/R.y;\n    if (M>=.6)  {uv=HmdWarp(uv);s2/=2.;}\nC=rend(uv,s2,zm);\n}", "image_inputs": [{"id": "MsjGz3", "previewfilepath": "https://soundcloud.com/espenvh/heightened-senses", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/espenvh/heightened-senses", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 153, 194, 733], [735, 735, 801, 801, 1602], [1603, 1603, 1645, 1660, 1954]], "test": "valid"}
{"id": "XlGSWm", "name": "- Pradera del desierto -", "author": "FranciscoGarcia", "description": "Figuras con intersecciones y gradientes", "tags": ["2d", "aub", "ab"], "likes": 2, "viewed": 406, "published": "Public", "date": "1484926799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float nubes(vec2 uv, float rad, vec2 pos) {\n   \tuv.y += 0.09*cos(9.0*uv.x + 2.5*iTime);\n   return 1.-smoothstep(rad,rad+0.60,length(uv-pos + 0.23*uv.y)); \n}\n\nfloat pradera(vec2 uv, float rad, vec2 pos, float offset) {\n   return 1.-smoothstep(rad,rad+offset,length(uv-pos));\n}\n\nfloat cac(vec2 uv, vec2 pos) {\n    uv -= pos;\n    float rad = sin(9.0*atan(uv.y,uv.x) + 0.7*cos(5.0*uv.y + 4.0*iTime));\n   return 1.-smoothstep(0.38*rad,0.38*rad+0.01,length(uv+pos));\n}\n\nfloat cac2(vec2 uv, vec2 pos) {\n    uv -= pos;\n    float rad = 1.2*cos(6.0*atan(uv.y,uv.x) - 10.0*uv.x - sin(uv.y+5.0*iTime));\n   return 1.-smoothstep(0.25*rad,0.25*rad + 0.01,length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    //Colores\n    vec3 azl = vec3(0.2588, 1.0, 0.8784);\n    vec3 ock = vec3(0.9490, 0.9686, 0.6980);\n    vec3 cfe = vec3(0.7137, 0.7294, 0.5411);\n    vec3 bck = vec3(0.6117, 0.5137, 0.1215);\n    vec3 pln = vec3(0.6705, 0.2784, 0.0);\n    vec3 nb = vec3(0.8196, 1.0, 0.8862);\n    vec3 col = vec3(0.0);\n    \n    //Nubes,pradera,hierba\n    float pra1 = pradera(p,1.0,vec2(-1.4,-1.6),0.03);\n    float pra2 = pradera(p,1.0,vec2(1.4,-1.6),0.03);\n    float pra = pradera(p,2.0,vec2(0.0,-2.3),0.01);\n\tfloat ca1 = cac(p,vec2(0.0,-0.4));\n    float ca2 = cac2(p,vec2(1.0,-0.64));\n    float ca3 = cac2(p,vec2(-1.0,-0.64));\n    \n    //Movimiento nbs\n    float nub1 = nubes(3.0*p, 0.44, vec2(4.0, 1.5 + 0.1*cos(p.y + iTime)));\n    nub1 += nubes(3.0*p, 0.64, vec2(0.5, 2.5 + 0.2*sin(p.y + iTime)));\n    nub1 += nubes(3.0*p, 0.45, vec2(-3.4, 1.3 + 0.1*cos(p.y + iTime)));\n    \n   \tcol = mix(ock,azl,p.y);\n    col = mix(col,cfe,pra1);\n    col = mix(col,cfe,pra2);\n    col = mix(col,bck,pra);\n    col = mix(col,pln,ca1);\n    col = mix(col,pln,ca2-(pra*ca2));\n    col = mix(col,pln,ca3-(pra*ca3));\n    col = mix(col,nb,nub1);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 156], [158, 158, 217, 217, 275], [277, 277, 307, 307, 462], [464, 464, 495, 495, 654], [656, 656, 713, 713, 1972]], "test": "valid"}
{"id": "XlGSWW", "name": "Alien Radial Noise", "author": "Heavybrush", "description": "a modular radial noise", "tags": ["noise", "circle", "radial", "animated", "glitch", "alien"], "likes": 2, "viewed": 290, "published": "Public", "date": "1484259745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float alpha = 1.0;\n\n\tfloat d = 1.0-distance(vec2(0.5),uv);\n    color = vec3(abs(sin(mod(10000.0 + iTime,d))));\n    \n\tfragColor = vec4(color,alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 286]], "test": "valid"}
{"id": "XlGXDR", "name": "Repeating circles", "author": "cacheflowe", "description": "Playing with repetition/grid via fract()", "tags": ["circles", "grid"], "likes": 13, "viewed": 627, "published": "Public API", "date": "1483762461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 2.5;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t\t\t\t// center coordinates\n    vec2 uvRepeat = fract(uv * 4.) - 0.5;\t\t\t\t\t\t\t\t\t\t// set repeating grid and center the circle (-0.5)\n    float distanceOsc = 8. * distance(uv, uvRepeat);\t\t\t\t\t\t\t// increase oscillation freq per distance\n    float radius = 0.25 + 0.15 * sin(time + distanceOsc);\t\t\t\t\t\t// use distance from center as oscillation offset\n    float col = smoothstep(radius - radius * 0.1, radius, length(uvRepeat));\t// smoothstep to antialias edge\n    fragColor = vec4(vec3(col), 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 641]], "test": "valid"}
{"id": "XlGXRm", "name": "OJ - Fibber 28, scene 5", "author": "rammoskar", "description": "Full demo: https://www.youtube.com/watch?v=kw5uLHZiRpY", "tags": ["3d"], "likes": 12, "viewed": 1888, "published": "Public", "date": "1483479886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAT_S5_BLOB 13.0\n#define MAT_S5_FLOOR 14.0\n#define MAT_S5_PILLAR 15.0\n\n\n#define EPS 0.01\n\n\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\n\nvec2 scene(vec3 p, vec3 rd)\n{\n\tfloat t = iTime;\n\tvec2 res = vec2(99999, -1);\n\tvec3 s = vec3(1);\n\tvec3 q = mod(p, s) - 0.5 * s;\n\tivec3 n = ivec3(floor(p / s));//TODO! ivec3(trunc(p / s));\n\t\n\tfloat blob = sphere(p, 4.0);\n\tblob +=  0.15 * sin(- t * 2.0 + p.y * 0.75 ) +\n\t  \t0.1 * sin( t * 1.5 + p.x*1.5) +\n\t\t0.2 * sin( t * 1.0 + p.z);\n\tres = un(res, vec2(blob, MAT_S5_BLOB));\n\t\n\t\n\tfloat roomDis = -sdBox(vec3(n), vec3(40.0, 15.0, 40.0));\n\tif (roomDis < 0.0) {\n\t\tfloat box = udRoundBox(q, vec3(0.4), 0.1);\n\t\tres = un(res, vec2(box, MAT_S5_FLOOR));\n\t} else {\n\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\tfloat a = max(roomDis - 1.73, b + EPS); // TODO 1.73 kan vara for mycket \n\t\tres = un(res, vec2(max(EPS, a), -1));\n\t}\n\t\n\t{\n\t\tvec3 s2 = vec3(30, 10, 30);\n\t\tvec3 q2 = mod(vec3(n), s2) - 0.5 * s2;\n\t\tfloat pDis = sdCylinder(vec3(q2.x, n.y, q2.z), vec3(0, 0, 4));\n\t\tif (pDis < 0.0) {\n\t\t\tfloat box = udRoundBox(q, vec3(0.4), 0.1);\n\t\t\tres = un(res, vec2(box, MAT_S5_PILLAR));\n\t\t} else {\n\t\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\t\tfloat a = max(pDis - 1.73, b + EPS); // TODO 1.73 kan vara for mycket \n\t\t\tres = un(res, vec2(max(EPS, a), -1));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n\nvec3 getNormal(vec3 p, vec3 rd, vec3 ro)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = scene(p + ep.xyz, rd).x - scene(p - ep.xyz, rd).x;\n    normal.y = scene(p + ep.yxz, rd).x - scene(p - ep.yxz, rd).x;\n    normal.z = scene(p + ep.yzx, rd).x - scene(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int jumps = 2;\n\tconst int imax = 600;\n\tfloat tmax = 800.0;\n\tvec3 skyColor = vec3(0);\n\tbool cubicDis = false;\n\tvec3 rollV = vec3(0, 1, 0);\n\t\n    float time = iTime;\n    vec3 eye = vec3(15.0*sin(time/5.0), 3.0, 15.0*cos(time/5.0)); \n    vec3 tar = vec3(0, 0, 0);\n    float r = 6.0; \n    float azi = time;\n    float pol = 0.5 * time;\n    float x = r*cos(pol)*sin(azi);\n    float y = r*sin(pol)*sin(azi);\n    float z = r*cos(azi);\n\n    vec3 light = vec3(x, y, z);\n    float shadowAmbient = 0.7;\n    float lightInvSize = 30.0;\n    float lightIntensity = 0.01;\n\n    float refJumpDistance = 1.0;\n    \n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(rollV, dir)); \n \tvec3 up = cross(dir, right);\n    \n    float u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (iResolution.y/iResolution.x);\n\n    vec3 color = skyColor;\n      \n    float t = 0.0;\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\t\n\tfloat ref = 1.0;\n\tfloat lightAura = 0.0;\n    float breakVar = 0.0;\n\tfor(int j = 0; j < 2; ++j)\n    {\n        if (breakVar >= 0.5) {\n        \tbreak;\n        }\n    \tt = 0.0;\n        for(int i = 0; i < imax; ++i)\n   \t\t {\n             if (t >= tmax) {\n                 break;\n             }\n\t        vec3 p = ro + rd * t;\n\t        vec2 dm = scene(p, rd);\n\t        float d = dm.x;\n\t        float m = dm.y;\n\t\t\t\n\t\t\t\n\t        if(d < EPS || i == imax || t >= tmax) \n\t        {\n\t        \tvec3 x0 = light;\n\t        \tvec3 x1 = ro;\n\t        \tvec3 x2 = ro + rd;\n\t        \tfloat ldis = pow(length(cross(x2 - x1, x1 - x0)),2.0) / pow( distance(x2, x1), 2.0); \n\t        \tvec3 normal = getNormal(p, rd, ro);\n\t\t\t\t\n\t\t\t\tvec3 invLight = normalize(light - p);\n\t        \tfloat diffuse = max(0.,dot(invLight, normal));\n\t        \tvec3 refrd = reflect(rd, normal);\n\t        \t\n\n\t\t\t\tvec3 c = vec3(0.5);\n\t\t\t\t\n\t\t\t\tif (m == MAT_S5_BLOB) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t} else if (m == MAT_S5_FLOOR) {\n\t\t\t\t\tc = vec3(0.9);\n\t\t\t\t} else if (m == MAT_S5_PILLAR) {\n\t\t\t\t\tc = vec3(0.8, 0, 0);\n\t\t\t\t} \n                c = 0.7*c* (1.0 + diffuse);        \n                c += specular(normal, -invLight, normalize(eye - p), 70.0);\n\t        \t\n\t            \n\t            float dis = length(light - p);\n\t            float disFact = 1.0 / (1.0 + lightIntensity*dis*dis * (cubicDis ? dis : 1.0 ));\n\t            c *= disFact;\n\t\t\t\t\n\t\t\t\t\t        \t\n\t        \tfloat tl = -dot(x1 - x0, x2 - x1)/pow(distance(x2,x1),2.0);\n\t        \tif(tl > 0.0 && (distance(eye, light) < distance(eye, p))){\n\t        \t\tlightAura = max(lightAura, 1.0/(0.01 + lightInvSize*ldis));\n\t        \t}\n\n\t\t\t\tcolor = mix(color, c, ref);\n\t\t\t\t\n\t\t\t\t\n                rd = reflect(rd, normal);\n\t         \tro = p + rd*refJumpDistance;\n\t\t\t\t\n\t        \t\n\t        \t if (m == MAT_S5_BLOB) {\n\t        \t\tref = 0.7;\n\t        \t} else {\n\t\t        \tref = 0.0;\n\t        \t}\n\t        \tif (ref <= 0.01) {\n\t        \t\tbreakVar = 1.0;       \t\t\n\t        \t} \n\t           \tbreak;\n\t        }\n\t\n\t        t += d;\n    \t}\n    }\n    \n   \n    fragColor = vec4(color + vec3(lightAura),  1.0);\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 132, 132, 157], [160, 160, 191, 191, 287], [290, 290, 326, 326, 360], [363, 363, 408, 408, 448], [452, 452, 477, 477, 506], [509, 509, 538, 538, 1752], [1755, 1755, 1797, 1797, 2076], [2079, 2079, 2143, 2143, 2268], [2271, 2271, 2328, 2328, 5378]], "test": "valid"}
{"id": "XlGXWW", "name": "Wallpaper 1", "author": "Xor", "description": "This is my first wallpaper shader for my desktop background. It generates a new wallpaper every 10 seconds.\n\n2021 Update: Cleaned up the code, added AA (supersampling), and fixed a flickering issue related to iDate.", "tags": ["2d", "noise", "pixel", "xor"], "likes": 6, "viewed": 239, "published": "Public", "date": "1484267885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2\n\nfloat n1(float x)\n{\n    return fract(cos(x*36.1)*924.);\n}\nfloat box_n1(vec2 x)\n{\n    vec2 c = ceil(x);\n \treturn fract(cos(c.x*36.1+c.y*47.9)*924.);   \n}\n\nvec3 n3(float n)\n{\n\treturn fract(cos(n*vec3(36.1,47.9,29.8))*924.);\n}\n\nvec3 color(vec2 c)\n{\n    vec2 cs = cos(iTime*.01 + vec2(0,1.57));\n\tvec2 coord = (c+c - iResolution.xy)/iResolution.y;\n    vec2 rot = coord*mat2(cs.x,-cs.y,cs.yx)*2.;\n    float box = box_n1(rot)*.5+box_n1(rot*=4.)*.3+box_n1(rot*=4.)*.1+box_n1(rot*=2.)*.1;\n    \n    float seed = floor(iDate.w/10.);\n    float grad = smoothstep(-3.,3.,coord.x+coord.y*(n1(seed++)-.5));\n    vec3 col = 1.-mix(n3(seed++),n3(seed++),grad)*(.8+.2*cos(box*8.+iTime));\n    float shade = .5+.5*smoothstep(-.8-1.2*n1(seed++),.8*n1(seed++),coord.y);\n    return col*col*col*col * shade;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 total = vec3(0);\n    \n    for(int a = 0;a<AA*AA;a++)\n    {\n        total += color(fragCoord + vec2(a%AA,a/AA)/float(AA));\n    }\n    total /= float(AA*AA);\n    \n\tfragColor = vec4(total,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 33, 33, 71], [72, 72, 94, 94, 166], [168, 168, 186, 186, 237], [239, 239, 259, 259, 797], [798, 798, 855, 855, 1054]], "test": "valid"}
{"id": "XlKSD1", "name": "Better Stickman Rendering", "author": "voz", "description": "Thanks to https://www.shadertoy.com/view/XtySRD", "tags": ["rendering", "stickman", "better"], "likes": 4, "viewed": 623, "published": "Public API", "date": "1484194595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCopyright (c) 2016, CrazedCoding@gmail.com.\nPermission is hereby DENIED, with prejudice (lol f***\nyou), to anyone/everyone obtaining a copy of this\nsoftware and associated documentation files (the\n\"Software\"), pending a written admition (the\n\"Admition\") of how wildly jealous of my coding skills\n(and good looks) they are, to deal in the Software\nwithout restriction, including without limitation the\nrights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the\nSoftware, subject to the following conditions: DO\nNOT EVEN CONTINUE READING THIS COPYRIGHT UNTIL YOU\nHAVE WRITTEN AND DELIVERED YOUR ADMITION; DO NOT LOOK\nAT THIS SOFTWARE; IF YOU FOUND THIS SOFTWARE BY \nFOLLOWING LINKS IN MY POSTS (SPREAD THROUGHOUT \nCYBERSPACE) THEN QUIT WASTING TIME ON FACEBOOK/YOUTUBE \nSTALKING ME AND SPEND MORE TIME LEARNING BASIC \nCALCULUS AND COMPUTER SCIENCE SO YOU CAN WRITE YOUR \nOWN F***ING CODE; BETTER YET, CONTACT ME AND I WILL \nTUTOR YOU AT A RATE OF $12.50 AN HOUR IN THOSE\nSUBJECTS... THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\nWARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\nBUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \nARISING FROM, OUT OF OR IN CONNECTION WITH THE \nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\nvec3 eye = vec3 (0.0);\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    //return length(bp - rp) - r;\n    \n    vec3 oc = eye - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return FAR;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return length(bp - rp) - r;\n}\n\nfloat sdCapsule(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,eye-a);\n    float e = dot(eye-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((eye+ray*t1)-(a+ray2*t2));\n    return dist > r || t2 < r || t2 > length(a-b)+r? FAR : length(pa - ba * h) - r;\n}\n\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\nvec4  saved_stance[NUM_ANGLES];\nvec4  stance[NUM_ANGLES];\n\nfloat saved_shoulderRot = 0.0;\nfloat shoulderRot = 0.0;\n\nfloat saved_hipRot = 0.0;\nfloat hipRot = 0.0;\n\nfloat saved_lean = 0.0;\nfloat lean = 0.0;\n\n//body joints\nvec3 head = vec3(0.0);\n\nvec3 bSpine = vec3(0.0);\nvec3 uSpine = vec3(0.0);\n\nvec3 leftShoulder = vec3(0.0);\nvec3 rightShoulder = vec3(0.0);\n\nvec3 leftElbow = vec3(0.0);\nvec3 rightElbow = vec3(0.0);\n\nvec3 leftWrist = vec3(0.0);\nvec3 rightWrist = vec3(0.0);\n\nvec3 leftFinger = vec3(0.0);\nvec3 rightFinger = vec3(0.0);\n\nvec3 leftHip = vec3(0.0);\nvec3 rightHip = vec3(0.0);\n\nvec3 leftKnee = vec3(0.0);\nvec3 leftAnkle = vec3(0.0);\n\nvec3 rightKnee = vec3(0.0);\nvec3 rightAnkle = vec3(0.0);\n\nconst vec3 downY = vec3(0.0, -1.0, 0.0);\nfloat minY = 0.0;\n\nvoid load_stance() {\n    \n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n    \tstance[i] = saved_stance[i];\n    \n    shoulderRot = (saved_shoulderRot);\n    hipRot = (saved_hipRot);\n    lean = (saved_lean);\n    \n    head = vec3(0.0, GR/E, 0.0);\n    \n    ///////////////////////////////////////////////////////////////\n    //Spine////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = head/GR;\n    uSpine = -bSpine;\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulders////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    leftShoulder = bSpine+vec3(1.0, 0.0, 0.0)/E;\n    rightShoulder = bSpine-vec3(1.0, 0.0, 0.0)/E;\n    \n    ///////////////////////////////////////////////////////////////\n    //Elbows///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftElbow = downY/GR;\n\n    float leftArmOmega = stance[ELBOWS].x;\n    float leftArmTheta = stance[ELBOWS].y;\n    \n    hangingLeftElbow = rotatePoint(rotatePoint(hangingLeftElbow, vec3(1.0, 0.0, 0.0), leftArmOmega), vec3(0.0, 0.0, 1.0), leftArmTheta);\n    \n    leftElbow = leftShoulder+hangingLeftElbow;\n        \n    vec3 hangingRightElbow = downY/GR;\n    \n    float rightArmOmega = stance[ELBOWS].z;\n    float rightArmTheta = stance[ELBOWS].w;\n    \n    hangingRightElbow = rotatePoint(rotatePoint(hangingRightElbow, vec3(1.0, 0.0, 0.0), rightArmOmega), vec3(0.0, 0.0, -1.0), rightArmTheta);\n    \n    rightElbow = rightShoulder+hangingRightElbow;\n    \n    ///////////////////////////////////////////////////////////////\n    //Wrists///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftWrist = downY/E;\n\n    float leftForeArmOmega = leftArmOmega+stance[WRISTS].x;\n    float leftForeArmTheta = leftArmTheta+stance[WRISTS].y;\n    \n    straightLeftWrist = rotatePoint(rotatePoint(straightLeftWrist, vec3(1.0, 0.0, 0.0), leftForeArmOmega), vec3(0.0, 0.0, 1.0), leftForeArmTheta);\n    \n    leftWrist = leftElbow+straightLeftWrist;\n        \n    vec3 straightRightWrist = downY/E;\n    \n    float rightForeArmOmega = rightArmOmega+stance[WRISTS].z;\n    float rightForeArmTheta = rightArmTheta+stance[WRISTS].w;\n    \n    straightRightWrist = rotatePoint(rotatePoint(straightRightWrist, vec3(1.0, 0.0, 0.0), rightForeArmOmega), vec3(0.0, 0.0, -1.0), rightForeArmTheta);\n    \n    rightWrist = rightElbow+straightRightWrist;\n    \n    ///////////////////////////////////////////////////////////////\n    //Fingers//////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftFingers = downY/PI/E;\n\n    float leftFingersOmega = leftForeArmOmega+stance[FINGERS].x;\n    float leftFingersTheta = leftForeArmTheta+stance[FINGERS].y;\n    \n    straightLeftFingers = rotatePoint(rotatePoint(straightLeftFingers, vec3(1.0, 0.0, 0.0), leftFingersOmega), vec3(0.0, 0.0, 1.0), leftFingersTheta);\n    \n    leftFinger = leftWrist+straightLeftFingers;\n        \n    vec3 straightRightFingers = downY/PI/E;\n    \n    float rightFingersOmega = rightForeArmOmega+stance[FINGERS].z;\n    float rightFingersTheta = rightForeArmTheta+stance[FINGERS].w;\n    \n    straightRightFingers = rotatePoint(rotatePoint(straightRightFingers, vec3(1.0, 0.0, 0.0), rightFingersOmega), vec3(0.0, 0.0, -1.0), rightFingersTheta);\n    \n    rightFinger = rightWrist+straightRightFingers;\n    \n    \n    ///////////////////////////////////////////////////////////////\n    //Hips/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    leftHip = uSpine+vec3(circle(hipRot), 0.0).xzy/E/GR;\n    rightHip = uSpine-vec3(circle(hipRot), 0.0).xzy/E/GR;\n    ///////////////////////////////////////////////////////////////\n    //Knees////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftKnee = downY/GR;\n\n    float leftKneeOmega = stance[KNEES].x;\n    float leftKneeTheta = stance[KNEES].y;\n    \n    hangingLeftKnee = rotatePoint(rotatePoint(hangingLeftKnee, vec3(1.0, 0.0, 0.0), leftKneeOmega), vec3(0.0, 0.0, 1.0), leftKneeTheta);\n    \n    leftKnee = leftHip+hangingLeftKnee;\n        \n    vec3 hangingRightKnee = downY/GR;\n    \n    float rightKneeOmega = stance[KNEES].z;\n    float rightKneeTheta = stance[KNEES].w;\n    \n    hangingRightKnee = rotatePoint(rotatePoint(hangingRightKnee, vec3(1.0, 0.0, 0.0), rightKneeOmega), vec3(0.0, 0.0, -1.0), rightKneeTheta);\n    \n    rightKnee = rightHip+hangingRightKnee;\n    \n    ///////////////////////////////////////////////////////////////\n    //Ankles///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 straightLeftAnkle = downY/GR;\n\n    float leftAnkleOmega = leftKneeOmega+stance[ANKLES].x;\n    float leftAnkleTheta = leftKneeTheta+stance[ANKLES].y;\n    \n    straightLeftAnkle = rotatePoint(rotatePoint(straightLeftAnkle, vec3(1.0, 0.0, 0.0), leftAnkleOmega), vec3(0.0, 0.0, 1.0), leftAnkleTheta);\n    \n    leftAnkle = leftKnee+straightLeftAnkle;\n        \n    vec3 straightRightAnkle = downY/GR;\n    \n    float rightAnkleOmega = rightKneeOmega+stance[ANKLES].z;\n    float rightAnkleTheta = rightKneeTheta+stance[ANKLES].w;\n    \n    straightRightAnkle = rotatePoint(rotatePoint(straightRightAnkle, vec3(1.0, 0.0, 0.0), rightAnkleOmega), vec3(0.0, 0.0, -1.0), rightAnkleTheta);\n    \n    rightAnkle = rightKnee+straightRightAnkle;\n    \n    ///////////////////////////////////////////////////////////////\n    //Lean/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = rotatePoint(bSpine, vec3(1.0, 0.0, 0.0), lean);\n    head = rotatePoint(head, vec3(1.0, 0.0, 0.0), lean);\n    \n    leftShoulder = rotatePoint(leftShoulder, vec3(1.0, 0.0, 0.0), lean);\n    rightShoulder = rotatePoint(rightShoulder, vec3(1.0, 0.0, 0.0), lean);\n    leftElbow = rotatePoint(leftElbow, vec3(1.0, 0.0, 0.0), lean);\n    rightElbow = rotatePoint(rightElbow, vec3(1.0, 0.0, 0.0), lean);\n    leftWrist = rotatePoint(leftWrist, vec3(1.0, 0.0, 0.0), lean);\n    rightWrist = rotatePoint(rightWrist, vec3(1.0, 0.0, 0.0), lean);\n    leftFinger = rotatePoint(leftFinger, vec3(1.0, 0.0, 0.0), lean);\n    rightFinger = rotatePoint(rightFinger, vec3(1.0, 0.0, 0.0), lean);\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulder Rotation////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n\n    leftShoulder = rotatePoint(leftShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightShoulder = rotatePoint(rightShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftElbow = rotatePoint(leftElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightElbow = rotatePoint(rightElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftWrist = rotatePoint(leftWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightWrist = rotatePoint(rightWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftFinger = rotatePoint(leftFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightFinger = rotatePoint(rightFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    \n    ///////////////////////////////////////////////////////////////\n    //Hip Rotation/////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    //MIN calc\n \tfloat lowestY = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(bSpine.y, uSpine.y),\n                                                                            leftShoulder.y),\n                                                                        rightShoulder.y),\n                                                                    leftElbow.y),\n                                                                rightElbow.y),\n                                                            leftWrist.y),\n                                                        rightWrist.y),\n                                                    leftFinger.y), \n                                                rightFinger.y), \n                                            leftHip.y), \n                                        rightHip.y), \n                                    leftKnee.y), \n                                leftAnkle.y),\n                            rightKnee.y),\n                        rightAnkle.y);\n    minY = min(lowestY, minY);\n}\n\nfloat dfScene(vec3 rp, vec3 rd) {\n    \n    float msd = 99.0;\n    \n    float scale = GR;\n    \n    //hip\n    msd = min(msd, sdSphere(rp, rd, leftHip, 0.06*scale));\n    msd = min(msd, sdSphere(rp, rd, rightHip, 0.06*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftHip, rightHip, 0.02*scale));\n    //left thigh\n    msd = min(msd, sdSphere(rp, rd, leftKnee, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftHip, leftKnee, 0.02*scale));\n    //left shin\n    msd = min(msd, sdSphere(rp, rd, leftAnkle, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftKnee, leftAnkle, 0.015*scale));\n    //right thigh\n    msd = min(msd, sdSphere(rp, rd, rightKnee, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightHip, rightKnee, 0.02*scale));\n    //right shin\n    msd = min(msd, sdSphere(rp, rd, rightAnkle, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightKnee, rightAnkle, 0.015*scale));\n    //spine\n    msd = min(msd, sdSphere(rp, rd, bSpine, 0.04*scale));\n    msd = min(msd, sdSphere(rp, rd, uSpine, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, bSpine, uSpine, 0.02*scale));\n    //shoulder\n    msd = min(msd, sdSphere(rp, rd, leftShoulder, 0.05*scale));\n    msd = min(msd, sdSphere(rp, rd, rightShoulder, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftShoulder, rightShoulder, 0.02*scale));\n    //left upper arm\n    msd = min(msd, sdSphere(rp, rd, leftElbow, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftShoulder, leftElbow, 0.02*scale));\n    //left lower arm\n    msd = min(msd, sdSphere(rp, rd, leftWrist, 0.03*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftElbow, leftWrist, 0.015*scale));\n    //left finger\n    msd = min(msd, sdSphere(rp, rd, leftFinger, 0.015*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftWrist, leftFinger, 0.01*scale));\n    //right upper arm \n    msd = min(msd, sdSphere(rp, rd, rightElbow, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightShoulder, rightElbow, 0.02*scale));\n    //right lower arm\n    msd = min(msd, sdSphere(rp, rd, rightWrist, 0.03*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightElbow, rightWrist, 0.015*scale));\n    //right finger\n    msd = min(msd, sdSphere(rp, rd, rightFinger, 0.015*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightWrist, rightFinger, 0.01*scale));\n    //head\n    msd = min(msd, sdSphere(rp, rd, head, 0.15));\n    \n    return msd;\n}\n\nvec3 surfaceNormal(vec3 p, vec3 rd) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy, rd), d2 = dfScene(p - e.xyy, rd);\n\tfloat d3 = dfScene(p + e.yxy, rd), d4 = dfScene(p - e.yxy, rd);\n\tfloat d5 = dfScene(p + e.yyx, rd), d6 = dfScene(p - e.yyx, rd);\n\tfloat d = dfScene(p, rd) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor, vec3 rd) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos, rd)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 8; i++) {\n        rp = ro + rd * d;\n        eye = rp;\n        float ns = dfScene(rp, rd);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = vec3(1.0, 0.0, 0.0); //surface colour\n        vec3 n = surfaceNormal(rp, rd);\n        float ao = calcAO(rp, n, rd);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\nconst int numWeights = 512;\n\nvec3 weights[numWeights];\n\nfloat lowAverage()\n{\n    const int iters = numWeights;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.25)).r;\n        \n        product *= sound;\n        sum += sound;\n        \n        weights[i].r = sound;\n    }\n    for(int i = 0; i < iters; i++)\n        weights[i].gb = vec2(sum/float(iters), pow(product, 1.0/float(iters)));\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nvoid clear_stance()\n{\n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n        stance[i] = vec4(0.0);\n    shoulderRot = 0.0;\n    hipRot = 0.0;\n    lean = 0.0;\n}\n\nvoid dance1()\n{\n    clear_stance();\n\tfloat twist = time;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    vec2 twistCircle = circle(twist*GR)*GR;\n    \n    stance[ELBOWS].x = twistCircle.x;\n    stance[ELBOWS].y = twistCircle.x/PI;\n    stance[ELBOWS].z = twistCircle.y;\n    stance[ELBOWS].w = twistCircle.y/PI;\n    \n    stance[WRISTS].x = (stance[ELBOWS].x*.5+.5);\n    stance[WRISTS].z = (stance[ELBOWS].z*.5+.5);\n    \n    shoulderRot = sin(PI+twist*PI*3.0)/PI/GR;\n    hipRot = sin(twist*PI*3.0)/PI/GR;\n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance2()\n{\n    clear_stance();\n\tfloat run = time*PI;\n    \n    vec2 runCircleA = circle(run)*.5+.5;\n    vec2 runCircleB = circle(run+PI)*.5+.5;\n    \n    stance[ELBOWS].x = (runCircleA.x*2.0-1.0)*GR;\n    stance[ELBOWS].z = (runCircleB.x*2.0-1.0)*GR;\n    \n    stance[KNEES].x = runCircleA.x*2.0-1.0;\n    stance[KNEES].z = runCircleB.x*2.0-1.0;\n    stance[ANKLES].x = runCircleA.y;\n    stance[ANKLES].z = runCircleB.y;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance3()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI/2.0+sin(wave)/PI;\n    stance[ELBOWS].w = PI/2.0+sin(wave+PI/2.0)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance4()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI+sin(wave)/PI;\n    stance[ELBOWS].w = PI+sin(wave+PI/2.0)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance5()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI+sin(wave)/PI;\n    stance[ELBOWS].w = PI+sin(wave+PI/2.0)/PI;\n    \n    stance[ELBOWS].x = sin(wave)/PI;\n    stance[ELBOWS].z = sin(wave)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid save_stance(float factor)\n{\n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n    {\n        saved_stance[i] += (stance[i]-saved_stance[i])*factor;\n    }\n    \n    saved_shoulderRot += (shoulderRot-saved_shoulderRot)*factor;\n    saved_hipRot += (hipRot-saved_hipRot)*factor;\n    saved_lean += (lean-saved_lean)*factor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float height = max(lowAverage(), last_height)-1.0/60.0;\n    beat = clip(height);\n    last_height = height;\n    \n    float dance = time/PI/PI;\n    float v1 =  smoothstep(-1.0, 1.0/5.0, saw(dance));\n    float v2 =  smoothstep(1.0/5.0, 2.0/5.0, saw(dance));\n    float v3 =  smoothstep(2.0/5.0, 3.0/5.0, saw(dance));\n    float v4 =  smoothstep(3.0/5.0, 4.0/5.0, saw(dance));\n    float v5 =  smoothstep(4.0/5.0, 1.0, saw(dance));\n    dance1();\n    save_stance(v1);\n    dance2();\n    save_stance(v2);\n    dance3();\n    save_stance(v3);\n    dance4();\n    save_stance(v4);\n    dance5();\n    save_stance(v5);\n    load_stance();\n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, minY+1.25, -3.5);\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    eye = ro;\n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [{"id": "MdBGR3", "previewfilepath": "https://soundcloud.com/coolio/gangstas-paradise", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/coolio/gangstas-paradise", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKSD1.jpg", "access": "shaders20k", "license": "x11", "functions": [[2565, 2565, 2584, 2584, 2636], [2638, 2638, 2690, 2724, 3298], [3300, 3300, 3360, 3360, 3879], [5493, 5493, 5513, 5513, 14493], [14495, 14495, 14528, 14528, 16842], [16844, 16844, 16881, 16881, 17211], [17213, 17218, 17261, 17261, 17558], [17560, 17573, 17608, 17608, 18390], [18448, 18448, 18468, 18468, 18963], [18965, 18965, 18986, 18986, 19115], [19117, 19117, 19132, 19132, 19721], [19723, 19723, 19738, 19738, 20199], [20201, 20201, 20216, 20216, 20750], [20752, 20752, 20767, 20767, 21293], [21295, 21295, 21310, 21310, 21915], [21917, 21917, 21949, 21949, 22229], [22231, 22231, 22286, 22286, 23403]], "test": "timedout"}
{"id": "XlKSRD", "name": "GR - A Noise Wave", "author": "bradleygriffith", "description": "noise wave", "tags": ["noisewave"], "likes": 2, "viewed": 77, "published": "Public", "date": "1483318116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358\n\n//  `rand` and `noise` taken from \n//  http://thebookofshaders.com/\nfloat rand (in float _x) {\n    return fract(sin(_x)*1e4);\n}\n\nfloat noise (in float _x) {\n    float i = floor(_x);\n    float f = fract(_x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(rand(i), rand(i + 1.0), u);\n}\n\nfloat noiseWave(vec2 uv, float y, float height, float volatility, bool animate) {\n    float x = uv.x;\n    if (animate) {\n    \tx += iTime * 0.25;\n    }\n    \n    // Define wave \n    float variance = (height / 2.0) * -1.0;\n \tvariance += noise(x * PI * volatility) * height;\n    \n    // Adjust y\n    y += variance;\n    \n    return smoothstep(y, y + 0.007, uv.y);\n}\n\nvec4 noiseWaveLine(vec2 uv, float y, float height, float width, float volatility) {\n\t// Define line constraints\n\tfloat h = width / 2.0;\n    float top = y + h;\n    float bottom = y - h;\n    \n    float topWave = noiseWave(uv, top, height, volatility, true);\n    float bottomWave = noiseWave(uv, bottom, height, volatility, true);\n    \n    return vec4(bottomWave - topWave);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float p = 1.0 / iResolution.y; // 1 pixel.\n\t\n    float y = 0.5;\n    if (iMouse.z > 0.0) {\n        y = iMouse.y / iResolution.y;\n    }\n    \n    float height = 100.0 * p; // Normalized by multiplying against p.\n    float width = 2.0 * p; // Normalized by multiplying against p.\n\tfloat volatility = 5.0;\n\n    fragColor = vec4(noiseWaveLine(uv, y, height, width, volatility));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 94, 120, 120, 153], [155, 155, 182, 182, 316], [318, 318, 399, 399, 678], [680, 680, 763, 791, 1053], [1056, 1056, 1113, 1113, 1534]], "test": "valid"}
{"id": "XlKSWG", "name": "crowded 23", "author": "FabriceNeyret2", "description": "Mouse control preempt time.\nChange #EPS for sharper.", "tags": ["raytracing"], "likes": 6, "viewed": 522, "published": "Public API", "date": "1485692273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define EPS .001 // smaller = sharper & more contrasted\n\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    float T = iTime+20., \n        closest = 999.;\n    vec2 R = iResolution.xy,\n         m = iMouse.xy/R;\n    vec4 p = vec4((w-.5*R)/R.y,-.5,0), d,c;      // init ray \n    p.z -= .4;                                   // view angle width / zoom\n  //r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);         // camera rotations\n  //d = p;                                       // ray dir = ray0-vec3(0) \n    d = normalize(p);\n    if (length(m)>.01) p.z = -30.*(1.-m.y), T = 30.*m.x; // mouse control preempts.\n    else p.z -= 60.;                             // camera distance.\n    \n    f -= f;\n   \n    for (float i=1.; i>0.; i-=.01)  {\n        \n        vec4 //u = floor(p/18.+3.5), \n            t = p, ta;\n            c = p/p*1.2;\n\t    float x=1e9,x1=1e9;\n\n#define smod(t,n)       ( mod(t+(n)/2., n) - (n)/2.  )\n#define setbox(t,h,w,d)   abs(t) / vec4(h,w,d,1)\n#define setboxU(t)        abs(t)\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z)) -(r) )\n#define dsphere(t,r)    ( length((t).xyz) -(r)       )\n#define dcyl(t,r)       ( length((t).xy ) -(r)       )\n#define union(a,b)        min(a,b)\n#define sub(a,b)          max(a,-(b))\n        \n        r(t.xz,.13); r(t.yz,.2); r(t.xy,.1);         // object rotation\n        // the object\n        \n        ta = -cos(t); x =  abs(.2+ (ta.x+ta.y+ta.z)/3. + smoothstep(1.,0.,p.z+60.));      \n\t\n        x = sub(x,dsphere(smod(t,1.),.5) );\n  \n        \n        //x1 = dsphere(t,.3);                   // red spheres\n        x1 = dsphere(smod(t,3.*6.28),.3);       \n        //x1 = dsphere(t+vec4(4,8,8,0),.3);     \n        closest = min(closest, x1);          // glow footprint\n        x = min(x1,x);                   // uncomment to display the spheres\n        if (x==x1) c  = vec4(2.,.3,0,0);\n        // if (cos(.25*T)>0.) c += vec4(2.,.3,0,0)*pow(abs((x-x1)),.2)*(.5+.5*cos(.5*T));  // glow1: thanks squid !\n\n        // if (x<-.01) c = vec4(0,0,1,0);          // DEBUG: too thin or near-plane cut parts\n             \n        if(x<EPS)                           // hit ! \n            {   x = i+.01*(1.-abs(x)/EPS);  // decrease banding\n                f = x*x*c; break;           // color texture + black fog \n            }\n        p -= d*x;                           // march ray\n     }\n\n     f += vec4(1,0,0,0) * exp(-closest/4.); //*(.5+.5*cos(.5*T)); // glow2 - thanks kuvkar ! \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 255, 255, 2568]], "test": "valid"}
{"id": "XlKSWw", "name": "Voronoi Intersection Pattern", "author": "parameterized", "description": "was going to cut a tree but this is easeir", "tags": ["procedural", "2d", "voronoi", "intersection", "easing", "merging"], "likes": 1, "viewed": 502, "published": "Public API", "date": "1484582377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//(n1x, n1y, n2x, n2y) n=closest points\nvec4 voronoi(vec2 pos, float jitter)\n{\n\tvec2 posi = floor(pos);\n\tvec2 pos2 = vec2(0, 0);\n\tfloat dist = 0.0;\n\tvec2 n1 = vec2(0, 0);\n\tvec2 n2 = vec2(0, 0);\n\tfloat n1d = 9.0;\n\tfloat n2d = 9.0;\n\tfor (int i=-2; i < 2; i++) {\n\t\tfor (int j=-2; j < 2; j++) {\n\t\t\tpos2 = posi+vec2(i,j)+vec2(0.5)+(vec2(rand(posi+vec2(i,j)), rand(posi+vec2(i,j)+0.5))*2.0-1.0)*jitter*0.5;\n\t\t\tdist = dot(pos-pos2, pos-pos2);\n\t\t\tif (dist < n2d) {\n\t\t\t\tif (dist < n1d) {\n\t\t\t\t\tn2d = n1d;\n\t\t\t\t\tn1d = dist;\n\t\t\t\t\tn2 = n1;\n\t\t\t\t\tn1 = pos2;\n\t\t\t\t} else {\n\t\t\t\t\tn2d = dist;\n\t\t\t\t\tn2 = pos2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vec4(n1, n2);\n}\n\nvec4 voronoi(vec2 pos)\n{\n\treturn voronoi(pos, 1.0);\n}\n\nfloat easeInOutCubic(float t)\n{\n    return t<0.5 ? 4.0*t*t*t : (t-1.0)*(2.0*t-2.0)*(2.0*t-2.0)+1.0;\n}\n\nfloat triangleWave(float t)\n{\n    return 1.0 - 2.0*abs(floor(t*0.5+0.5)-t*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-vec2(iResolution.x/2.0,0)) / min(iResolution.x, iResolution.y);\n    float pos = easeInOutCubic(triangleWave(iTime))-0.5;\n    vec3 col = vec3(0.95);\n    vec4 vpts = voronoi(uv*8.0, sin(iTime/2.0)*0.5+0.5);\n    float t = easeInOutCubic(triangleWave(iTime));\n    col = distance(uv*8.0,vpts.xy*t+vpts.zw*(1.0-t))<0.1+0.5*(1.0-t) ? vec3(1.0-distance(uv*8.0,vpts.zw)-distance(uv*8.0,vpts.xy)) : col;\n\tfragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 87], [89, 129, 167, 167, 718], [720, 720, 744, 744, 773], [775, 775, 806, 806, 876], [878, 878, 907, 907, 959], [961, 961, 1018, 1018, 1465]], "test": "valid"}
{"id": "XlKSzy", "name": "Fog Test", "author": "CocoAll", "description": "Trying to do a fog effect", "tags": ["fog"], "likes": 2, "viewed": 142, "published": "Public", "date": "1484823414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blobs\n// Eric Galin\n\nconst int Steps = 600;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=20.0; // Minimum\n\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.65, 0.4, 0.5);\n\n  // Color of the object comes from background !\n  vec3 c = 0.25*background(n);\n    \n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n    \n  float b = (t-rA)/(rB-rA);\n  b = b*b*b;\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n  vec3 fog = vec3((0.5,0.5,0.5)*(0.9+0.01*noise(30.0*pixel.xyx+0.8*sin(iTime))+0.05*noise(10.0*pixel.xyx+0.5*cos(iTime))));//noise(pixel))*cos(iTime)+0.5); \n  rgb = mix(rgb,fog,b);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 256, 256, 299], [301, 332, 358, 358, 730], [748, 748, 779, 779, 878], [880, 947, 982, 982, 1055], [1081, 1195, 1241, 1241, 1278], [1280, 1371, 1401, 1401, 1419], [1421, 1509, 1539, 1539, 1562], [1564, 1610, 1632, 1632, 1828], [1830, 1870, 1901, 1901, 2121], [2123, 2228, 2279, 2279, 2714], [2716, 2821, 2878, 2878, 3329], [3332, 3352, 3378, 3378, 3450], [3452, 3513, 3541, 3558, 3930], [4072, 4072, 4129, 4129, 5109]], "test": "valid"}
{"id": "XlKXDz", "name": "Volumetric Cloudscape CS371", "author": "asm4", "description": "Zander Majercik and Minh Tuan Tran's Cloud scene extended from their final project in Prof. Morgan McGuire's CS371 Computational Graphics class at Williams College.", "tags": ["clouds", "volumetric"], "likes": 14, "viewed": 460, "published": "Public", "date": "1483912201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Cloudscape with hyperboloid cloud features\n// Tuan Tran and Zander Majercik\n// Based on work by inigo quilez https://www.shadertoy.com/view/XslGRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n#define Vector3 vec3\n#define Color3 vec3\n#define Matrix3 mat3\n#define Point3 vec3\n#define Color4 vec4\n#define Vector2 vec2\n#define Radiance4 vec4\n#define Point2 vec2\n#define float2 vec2\n#define float3 vec3\n#define lerp mix\n\n#define g3d_SceneTime iTime\n\n#define pi 3.141592653589793\n\nvec3 sundir = normalize( vec3(0.5, 0.2, -1.0) );\n\n\n/////////////////////Morgan McGuire's Noise Function from G3D//////////////////////\n// All noise functions are designed for values on integer scale.\n// They are tuned to avoid visible periodicity for both positive and\n// negative coordinates within a few orders of magnitude.\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(Point2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise1(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise1(Point2 x) {\n    float2 i = floor(x);\n    float2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(lerp(lerp(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tlerp(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    float2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise1(Point3 x) {\n    const float3 step = float3(110, 241, 171);\n\n    float3 i = floor(x);\n    float3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    float3 u = f * f * (3.0 - 2.0 * f);\n    return lerp(lerp(lerp( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   lerp( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               lerp(lerp( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   lerp( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nfloat noise(float x, const int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = 100.0;\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * noise1(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat noise(Point2 x, const int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat2 shift = float2(100, 50);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * noise1(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat noise(Point3 x, const int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat3 shift = float3(100, 75, 50);\n    \n        if (numOctaves == 4){\n    \t#define numOctaves 4\n    }\n    if (numOctaves == 3){\n        #ifndef numOctaves\n    \t\t#define numOctaves 3\n        #endif\n    }\n    if (numOctaves == 2){\n        #ifndef numOctaves\n    \t\t#define numOctaves 2\n        #endif\n    }\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * noise1(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// Worley Noise taken from https://github.com/Erkaman/glsl-worley by Erkaman. MIT License.\n// Permutation polynomial: (34x^2 + x) mod 289\nVector3 permute(Point3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nVector3 dist(Vector3 x, Vector3 y, Vector3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\n\n/** Worley noise function */\nVector2 worley(Point3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tVector3 Pi = mod(floor(P), 289.0);\n \tVector3 Pf = fract(P) - 0.5;\n\n\tVector3 Pfx = Pf.x + Vector3(1.0, 0.0, -1.0);\n\tVector3 Pfy = Pf.y + Vector3(1.0, 0.0, -1.0);\n\tVector3 Pfz = Pf.z + Vector3(1.0, 0.0, -1.0);\n\n\tVector3 p = permute(Pi.x + Vector3(-1.0, 0.0, 1.0));\n\tVector3 p1 = permute(p + Pi.y - 1.0);\n\tVector3 p2 = permute(p + Pi.y);\n\tVector3 p3 = permute(p + Pi.y + 1.0);\n\n\tVector3 p11 = permute(p1 + Pi.z - 1.0);\n\tVector3 p12 = permute(p1 + Pi.z);\n\tVector3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tVector3 p21 = permute(p2 + Pi.z - 1.0);\n\tVector3 p22 = permute(p2 + Pi.z);\n\tVector3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tVector3 p31 = permute(p3 + Pi.z - 1.0);\n\tVector3 p32 = permute(p3 + Pi.z);\n\tVector3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tVector3 ox11 = fract(p11*K) - Ko;\n\tVector3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tVector3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tVector3 ox12 = fract(p12*K) - Ko;\n\tVector3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tVector3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tVector3 ox13 = fract(p13*K) - Ko;\n\tVector3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tVector3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tVector3 ox21 = fract(p21*K) - Ko;\n\tVector3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tVector3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tVector3 ox22 = fract(p22*K) - Ko;\n\tVector3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tVector3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tVector3 ox23 = fract(p23*K) - Ko;\n\tVector3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tVector3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tVector3 ox31 = fract(p31*K) - Ko;\n\tVector3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tVector3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tVector3 ox32 = fract(p32*K) - Ko;\n\tVector3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tVector3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tVector3 ox33 = fract(p33*K) - Ko;\n\tVector3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tVector3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tVector3 dx11 = Pfx + jitter*ox11;\n\tVector3 dy11 = Pfy.x + jitter*oy11;\n\tVector3 dz11 = Pfz.x + jitter*oz11;\n\n\tVector3 dx12 = Pfx + jitter*ox12;\n\tVector3 dy12 = Pfy.x + jitter*oy12;\n\tVector3 dz12 = Pfz.y + jitter*oz12;\n\n\tVector3 dx13 = Pfx + jitter*ox13;\n\tVector3 dy13 = Pfy.x + jitter*oy13;\n\tVector3 dz13 = Pfz.z + jitter*oz13;\n\n\tVector3 dx21 = Pfx + jitter*ox21;\n\tVector3 dy21 = Pfy.y + jitter*oy21;\n\tVector3 dz21 = Pfz.x + jitter*oz21;\n\n\tVector3 dx22 = Pfx + jitter*ox22;\n\tVector3 dy22 = Pfy.y + jitter*oy22;\n\tVector3 dz22 = Pfz.y + jitter*oz22;\n\n\tVector3 dx23 = Pfx + jitter*ox23;\n\tVector3 dy23 = Pfy.y + jitter*oy23;\n\tVector3 dz23 = Pfz.z + jitter*oz23;\n\n\tVector3 dx31 = Pfx + jitter*ox31;\n\tVector3 dy31 = Pfy.z + jitter*oy31;\n\tVector3 dz31 = Pfz.x + jitter*oz31;\n\n\tVector3 dx32 = Pfx + jitter*ox32;\n\tVector3 dy32 = Pfy.z + jitter*oy32;\n\tVector3 dz32 = Pfz.y + jitter*oz32;\n\n\tVector3 dx33 = Pfx + jitter*ox33;\n\tVector3 dy33 = Pfy.z + jitter*oy33;\n\tVector3 dz33 = Pfz.z + jitter*oz33;\n\n\tVector3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tVector3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tVector3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tVector3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tVector3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tVector3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tVector3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tVector3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tVector3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tVector3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\n\tVector3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\n\tVector3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\n\tVector3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\n\treturn sqrt(d11.xy); // F1, F2\n}\n\n\n//Taken from http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n/**\n    A hyperboloid intersection function\n    when the point is far within the hyperboloid (centered at the origin)\n*/\nfloat sdCappedHyperboloid( Point3 p, Vector3 c) // modified from iq: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n{\n    Vector2 q = Vector2( length(p.xz), -(3. * p.y * p.y + 0.6) ); //altered portion of sdCappedCone, making the sides curve quadratically\n    Vector2 v = Vector2( c.z * c.y / c.x, -c.z );\n    Vector2 w = v - q;\n    Vector2 vv = Vector2( dot(v, v), v.x * v.x );\n    Vector2 qv = Vector2( dot(v, w), v.x * w.x );\n    Vector2 d = max(qv, 0.0) * qv / vv;\n\n    return sqrt( dot(w, w) - max(d.x, d.y) ) * sign(max(q.y * v.x - q.x * v.y, w.y));//added to make the clouds random\n}\n\n/** Create a series of hyperboloid clouds */\nfloat repeatedHyperboloid(Point3 P, Point3 C) {\n    Point3 Q = Point3(cos(P.x * 0.75), P.y - 0.1, sin(P.z * 0.75));\n\tfloat distance = sdCappedHyperboloid(Q, C);\t\n    return distance;\n}\n\n\n/** further randomize the value in fbm to achieve desired effect */\nfloat map(Point3 Q, int lod) {\n\tfloat hyperboloid = repeatedHyperboloid(Q * .05, Point3(1.3, 2.0, 1.3));\n    //float sphereDist = repeatedSphere(Q  * .05, spherePrim);\n\t//float triDist = repeatedTriangularPrism(Q);\n\n    float d = -.1 - min(1.25*Q.y, 12.*hyperboloid);//+ min(1.25 * Q.y, min( triDist * 0.75, min(12. * hyperboloid, 7. * sphereDist)));\n    \n    if (Q.y < 0.0 || hyperboloid < 0.0){//|| sphereDist < 0.0 || triDist < 0.0) {\n        float fbm = clamp(noise(Q * 0.25 + .6 * g3d_SceneTime, lod) + 0.5, 0., 2.); //Perlin noise\n\n        // Add Worley noise to achieve cumulus-like cloud pattern.\n        // Inspired by Horizon:zero Dawn http://advances.realtimerendering.com/s2015/index.html\n        d += 6.25 * fbm - 6. * length(worley(Q * 0.001, 0., false)) \n             - 2. * length(worley(Q * 0.01 + Point3 (0.3, 0.5, 0.3), 0., false))\n             - 0.5 * length(worley(Q * 0.1 + 0.4, 0., false));\n    }\n    \n    return clamp(d, 0., 1.5);\n}\n\n\n\n/** Return a shade of cloud color */\nColor4 shade(float dif, float den) {\n    // color map\n    Color4 color = Color4(mix(Color3(1.) * 0.85, Color3(0.5), den), den);\n    Color3 lin = Color3(0.65, 0.7, 0.75) * 1.5 + Color3(0.9, 0.5, 0.4) * dif;        \n    color.rgb *= lin;\n\n    // front to back blending    \n    color.a *= 0.6;\n    color.rgb *= color.a;\n    return color;\n}\n\n\n/** Ray marching through a noise function to create cloud-like image */\nvoid march(const int samples, Point3 P, Vector3 w, int lod, inout float t, inout Color4 sum) {\n    P = P + Vector3(0., 9., 0.) - Vector3(0.0, -0.0, 3.0) *  2.0 * g3d_SceneTime;\n    \n    for (int i = 0; i < samples; i++) {\n        // Break if our cloud is dense\n        if (sum.a > 0.99) {\n            break;\n        }\n\n        Vector3 pos = P + t * w;\n        float den = map(pos, lod) * 1.1;\n\n        if (den > 0.01) {\n            float dif = clamp(den - noise(pos + 0.6 * sundir, lod), 0.0, 1.0);\n            Color4 color = shade(dif, den);\n            sum += color * (1.0 - sum.a);\n        }\n\n        t += min( 0.06 + 0.025 * t, 0.6 + 0.0025 * t);\n    }\n} \n\n\n\n/** Using raymarch to create cloud layers */\nColor4 raymarch( Point3 P, Vector3 w) {\n    Color4 sum = Color4(0.0);\n    float t = 0.0;\n\n    // Different level of detail\n    //march(50, P, w, 5, t, sum);\n    march(100, P, w, 4, t, sum);\n    march(150, P, w, 3, t, sum);\n    march(50, P, w, 2, t, sum);\n\n\n    return clamp(sum, 0.0, 1.0);\n}\n\n\n/** Calculating the background sky */\nColor3 backgroundColor(Point3 P, Vector3 w, float sun) {\n    Color3 col = Color3(0.);\n    \n    // The sky\n    float hort = 1. - clamp(abs(w.y), 0., 1.);\n    col += 0.5*vec3(.99,.5,.0)*exp2(hort*8.-8.);\n    col += 0.1*vec3(.8,.6,0.7)*exp2(hort*3.-3.);\n    col += 0.55*vec3(.9,.4,.6);\n\n    \n    // The sun\n    col += .2*vec3(0.6,0.3,0.2)*pow( sun, 2.0 );\n    col += .5*vec3(1.,.9,.9)*exp2(sun*650.-650.);\n    col += .1*vec3(1.,1.,0.1)*exp2(sun*100.-100.);\n    col += .3*vec3(1.,.7,0.)*exp2(sun*50.-50.);\n    col += .5*vec3(1.,0.3,0.05)*exp2(sun*10.-10.); \n       \n    return clamp(col, 0.0, 1.0);\n}\n\n\n/** Render the cloudscape */\nColor4 render( Point3 P, Vector3 w ) {\n    float sun = clamp(dot(sundir, w), 0.0, 1.0);\n\n    // background sky\n    // To change background, uncomment the above block and comment this line\n    Color3 color = backgroundColor(P, w, sun);\n\n    // clouds    \n    Radiance4 result = raymarch(P, w);\n    result *= Color4(pow(color, Color3(0.3)), 0.9);\n    color = 0.9 * color * (1.0 - result.w) + 1.1* result.xyz;\n\n    // sun glare\n\tcolor += Color3(0.2, 0.15, 0.07) * pow( sun, 2.0 );\n    color = clamp(color, 0.0, 1.);\n\n    return Color4( color, 1.0 );\n}\n\n//iq https://www.shadertoy.com/view/4dKGWm\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n//camera work from iq https://www.shadertoy.com/view/4dKGWm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\n    // camera\n    float an = 0.0 - 1.25- 1.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3(5.7*sin(an),-3.0,5.7*cos(an));\n    vec3 ta = vec3(0.0,-4.,0.0);\n\n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-3.5) );\n    \n    fragColor = render(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXDz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[848, 848, 869, 869, 899], [900, 900, 922, 922, 1010], [1012, 1012, 1035, 1035, 1167], [1170, 1170, 1194, 1194, 1837], [1840, 1906, 1930, 1930, 2708], [2711, 2711, 2755, 2755, 2922], [2925, 2925, 2970, 2970, 3249], [3252, 3252, 3297, 3297, 3748], [3750, 3888, 3915, 3915, 3960], [3962, 3962, 4034, 4034, 4119], [4122, 4151, 4215, 4215, 8926], [8929, 9017, 9037, 9037, 9110], [9113, 9234, 9371, 9371, 9844], [9846, 9891, 9938, 9938, 10075], [10078, 10146, 10176, 10176, 11102], [11106, 11143, 11179, 11196, 11479], [11482, 11554, 11648, 11648, 12212], [12217, 12262, 12301, 12301, 12553], [12556, 12594, 12650, 12650, 13190], [13193, 13222, 13260, 13260, 13770], [13772, 13815, 13870, 13870, 14048], [14050, 14110, 14167, 14167, 14556]], "test": "valid"}
{"id": "XlKXWG", "name": "Flaming Sphere 2", "author": "dr2", "description": "Fireball with Voronoi landscape", "tags": ["voronoi", "raymarch", "lanscape"], "likes": 4, "viewed": 624, "published": "Public API", "date": "1485704513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Flaming Sphere 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Fireball with Voronoi landscape.\n\nvec2 Hashv2v2 (vec2 p);\nfloat Noiseff (float p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst float pi = 3.14159;\nmat3 vuMat;\nvec3 qHit, qnHit, vuPos, fBallPos, sunDir;\nfloat tCur, dstFar, fBallRad;\n\nfloat VorDist (vec2 p)\n{\n  vec3 dv;\n  vec2 ip, fp, g, b;\n  ip = floor (p);\n  fp = fract (p);\n  dv = vec3 (8.);\n  b.x = 0.;\n  for (float gy = -1.; gy <= 1.; gy ++) {\n    for (float gx = -1.; gx <= 1.; gx ++) {\n      g = vec2 (gx, gy);\n      dv.z = length (g + 0.8 * Hashv2v2 (ip + g) - fp);\n      b.y = step (dv.z, dv.y) * (dv.z - dv.y);\n      dv.xy += b + step (dv.z, dv.x) * (dv.zx - dv.xy - b);\n    }\n  }\n  return dv.y - dv.x;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 4. * smoothstep (0., 0.8, VorDist (0.07 * p));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, 0.4 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  float h;\n  h = GrndHt (p.xz);\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy), e.x,\n     h - GrndHt (p.xz + e.yx)));\n}\n\nfloat FBallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float h, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  h = dstFar;\n  if (d >= 0.) {\n    h = - b - sqrt (d);\n    qHit = ro + h * rd;\n    qnHit = (qHit - p) / s;\n  }\n  return h;\n}\n\nfloat FBallLum (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, fr, f;\n  p = ro + dHit * rd - fBallPos;\n  dp = (fBallRad / 30.) * rd;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    q = 4. * p;   q.y -= 5. * tCur;\n    f = Fbm3 (q);\n    q = 7. * p;   q.y -= 9. * tCur;\n    f += Fbm3 (q);\n    s = length (p);\n    fr = max (1. - 0.9 * s / fBallRad, 0.);\n    g += max (0.15 * fr * (f - 0.55), 0.);\n    if (s > fBallRad || g > 1.) break;\n  }\n  return g;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.2, 0.3, 0.55) + 0.1 * pow (1. - max (rd.y, 0.), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = 0.5 * Fbm2 (0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz));\n  col = SkyBg (rd) + 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 flmCol, col, vn;\n  float dstGrnd, dstFbHit, fIntens, f;\n  dstFbHit = FBallHit (ro, rd, fBallPos, fBallRad);\n  fIntens = (dstFbHit < dstFar) ? FBallLum (ro, rd, dstFbHit) : 0.;\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = VaryNf (1.3 * ro, GrndNf (ro), 3.);\n    col = (mix (vec3 (0.9), vec3 (1.),\n       clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.))) *\n       (0.3 + 0.8 * max (0., max (dot (vn, sunDir), 0.))) +\n       0.5 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), max (f * f - 0.1, 0.));\n  } else col = SkyCol (ro, rd);\n  if (dstFbHit < dstFar) {\n    ro += rd * dstFbHit;\n    rd = reflect (rd, qnHit);\n    col = 0.9 * col + 0.08 + 0.25 * max (dot (qnHit, sunDir), 0.) * (1. +\n       4. * pow (max (0., dot (sunDir, rd)), 128.));\n  }\n  f = clamp (0.7 * fIntens, 0., 1.);\n  f *= f;\n  flmCol = (1. + 0.4 * Noiseff (10. * tCur)) *\n     mix (vec3 (1., 0.4, 0.1), vec3 (1., 1., 0.5), f * f);\n  col = mix (col, flmCol, min (1.2 * fIntens * fIntens, 1.));\n  if (dstFbHit < dstFar) {\n    dstGrnd = GrndRay (ro, rd);\n    col = mix (col, ((dstGrnd < dstFar) ? vec3 (0.4, 0.4, 0.5) :\n       SkyCol (ro, rd)), pow (1. - abs (dot (rd, qnHit)), 3.));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.35 * t) * sin (0.12 * t) * cos (0.1 * t) +\n     26. * sin (0.032 * t), 1. + 3. * sin (0.21 * t) * sin (1. + 0.23 * t),\n     10. * t);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 2.;\n  vuPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * vuPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 0.1 * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  vuMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur += 100.;\n  dstFar = 200.;\n  fBallRad = 3.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  fBallPos = TrackPath (tCur + 5.5 + 4. * sin (0.5 * tCur));\n  fBallPos.y += 8.;\n  VuPM (tCur);\n  ro = vuPos;\n  ro.y += 7.;\n  rd = normalize (vec3 (uv, 2.5)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXWG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[429, 429, 453, 453, 859], [861, 861, 884, 884, 942], [944, 944, 978, 978, 1471], [1473, 1473, 1495, 1495, 1647], [1649, 1649, 1701, 1701, 1920], [1922, 1922, 1969, 1969, 2400], [2402, 2402, 2424, 2424, 2496], [2498, 2498, 2530, 2530, 2822], [2824, 2824, 2859, 2859, 4184], [4186, 4186, 4212, 4212, 4376], [4378, 4378, 4399, 4399, 4998], [5000, 5000, 5056, 5056, 5511], [5634, 5634, 5658, 5658, 5708], [5710, 5710, 5734, 5734, 5781], [5783, 5783, 5807, 5807, 5980], [5982, 5982, 6006, 6006, 6245], [6247, 6247, 6272, 6272, 6402], [6404, 6404, 6429, 6429, 6608], [6610, 6610, 6636, 6636, 6930], [6932, 6932, 6953, 6953, 7092], [7094, 7094, 7115, 7115, 7375], [7377, 7377, 7406, 7406, 7608], [7610, 7610, 7649, 7649, 7872]], "test": "error"}
{"id": "XlKXWW", "name": "360 rotating scanlines", "author": "zproxy", "description": "360 rotating scanlines", "tags": ["360"], "likes": 2, "viewed": 127, "published": "Public", "date": "1484367889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define xWebGLTexture360height iResolution.y \n#define xWebGLTexture360height iResolution.y\n\n\n#define uIPD 0.0\n    \nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n  \nfloat stars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    //vec3 q = fract(p*2.)-0.5;\n    vec3 q = fract(p*3.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 startrails(in vec3 rd)\n{\n    //rd *= rotationMatrix(vec3(1.0, 0.0, 0.0), 90.);\n    \n    rd *= rotationMatrix(vec3(0.0, 1.0, 0.0), ((-0. -  iMouse.x) / 360.) * 3.14);\n    //rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), 90.);\n    rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), ((90. + cos(iTime) * 1. -  iMouse.y) / 360.) * 3.14);\n    \n\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = stars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\n\n void mainImage0( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD )\n {\n  \n    vec3 col = startrails( rd);\n\n  \n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n    \n\tfragColor = vec4(col, 1.0);\n }\n\n \n\n// called by drawArrays\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n    bool drag = iMouse.w > 0.0;\n    \n    float grid = 16.;\n    float gridt = 2.;\n    \n    bool indexx = int(int(fragCoord.x  / grid) * int(grid)) == int(fragCoord.x);\n    bool indexy = int(int(fragCoord.y  / grid) * int(grid)) == int(fragCoord.y);\n    //bool indext = int(int(float(iFrame)  / grid) * int(grid)) == int(iFrame);\n    bool indext = int(int(float(iTime)  / gridt) * int(gridt)) == int(iTime);\n    \n    if (drag || (indext&&(indexy||indexx)))\n\n\n    {\n   if ( int(fragCoord.x + 2.) > int(iMouse.x))\n   if ( int(fragCoord.x - 2.) < int(iMouse.x))\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n      if ( int(fragCoord.y + 2.) > int(iMouse.y))\n   if ( int(fragCoord.y - 2.) < int(iMouse.y))\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    }\n    \n\t// can we show the noise we just was sent too?\n\n\t//if (gl_FragCoord.x < float(noiseSize))\n\t//\tif (gl_FragCoord.y < float(noiseSize))\n\t//\t{\n\t//\n\t//\t\t// if its a black bar. then we did not upload it?\n\t//\t\tgl_FragColor = texture(iChannel0, gl_FragCoord.xy / vec2(iResolution));\n\t//\t\treturn;\n\t//\t}\n\n\n\n//discard;\n\n\t// void mainImage0( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD  ) \n\t// \n\t\n\t// P:\\vr\\x360horizonclouds\n\n\t//float IPD = 0.005;\n\t//float IPD = 0.05;\n\t// frame565 cant see stereo diff?\n\t//float IPD = 5.0; \n\n\t// perhaps because IPD is not used in the underlying main?\n\t//float IPD = 50.0; \n\n\t//float IPD = 1.0; \n\t//float IPD = 0.5; //too much \n\t//float IPD = 0.05; // rocks feel bit too close.\n\t//float IPD = 0.02; // too much. thing too close.\n\t//float IPD = 0.002; // too much. thing too close.\n\t//float IPD = 0.2; // too much?\n\t//float IPD = 0.02; // too much.\n\t//float IPD = 0.01; // too much.\n\t//float IPD = 0.2; // too much\n\t//float IPD = 0.05; // could be a slider. feels ok. can we up it a bit?\n\t//float IPD = 0.1; // yellow thing bit too close? \n\t//float IPD = 0.075; // \n\t//float IPD = 0.066; // too much \n\t// float IPD = 0.01; // \n\n\t//float IPD = 0.002; // too much.\n\n\n\n\t\n\tbool RvL = true;\n\t \n\tvec4 fragColorR = vec4(1.0, 0.0, 0.0, 1.0);\n\tvec2 fragCoordR = vec2(gl_FragCoord.x, gl_FragCoord.y / 1.0);\n\tvec2 texCoordR0 = vec2((iResolution.x - fragCoordR.x)/iResolution.x, fragCoordR.y/(iResolution.y/1.0))  + vec2(0.25, 0.0);\n\tvec2 thetaphiR = ((texCoordR0 * vec2(2.0, 2.0)) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n\tvec3 rayDirectionR = vec3(cos(thetaphiR.y) * cos(thetaphiR.x ), sin(thetaphiR.y), cos(thetaphiR.y) * sin(thetaphiR.x ));\n\n\n\n    \n\tmainImage0(\n\tfragColorR, \n\t fragCoordR, \n\tthetaphiR , \n\t rayDirectionR, \n\t uIPD  \n\t\n\t);\n\t\n\t// lets not shadow the non stereo area.\n\t//fragColorLvR.rgb *= \n\t//\t1.0 - abs(RvL ? thetaphiR.y : thetaphiL.y) * 0.6;\n\t\n\tfragColor = fragColorR;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 162, 162, 628], [635, 635, 662, 662, 750], [756, 756, 780, 849, 939], [1751, 1751, 1845, 1845, 2067], [2072, 2096, 2153, 2153, 4953]], "test": "valid"}
{"id": "XlKXzD", "name": "Japanese Wave Pattern", "author": "Shane", "description": "I tend to call them fish scale tiles, but I've heard them referred to as Japanese wave patterns, European tiles, etc. Either way, it's just an excuse to play around with 2D polar coordinates.", "tags": ["grid", "wave", "polar", "tile", "scales"], "likes": 34, "viewed": 1255, "published": "Public API", "date": "1483845019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tJapanese Wave Pattern\n\t---------------------\n\n\tI tend to call them fish scale tiles, but I've heard them referred to as Japanese wave \n\tpatterns, European tiles, etc. Either way, it's just an excuse to play around with 2D \n\tpolar coordinates.\n\n\tThis particular design is based on something I came across on the net years ago. I'm \n\tnot sure who originally came up with it, but I see it frequently in various forms all \n\tover the net. I have a feeling that the originals were hand drawn, because I don't \n\tthink anyone would ever get bored enough to code one... :)\n\n\tConceptually, there's nothing difficult here, but the routines are a little fiddly. In \n\tessence, the texture is constructed from a series of fan-like shapes made up of \n\tcombinations of strategically placed circles. Decorating the tiles involves a few steps, \n\tdue to the intricate details. However, it's essentially nothing more than a few lines \n\tand shapes rendered on a polar grid.\n\n\tGetting finely detailed images to look right on everyone's system is impossible. I find \n\tthe biggest problem is the large range in PPIs these days. What looks right on my \n\tsystem might not look that great on someone elses.\n\n\tI coded this using the 800x450 canvas on a 17 inch laptop with 1920x1080 resolution, so \n\tthe resulting image physically looks the size of Samsung phone in side view. However, \n\tit's not uncommon for people to have systems with PPIs way in excess of that these days, \n\twhich would result in a much smaller image, and thus, squashed details. Unfortunately, \n\tit's not possibe to control that.\n\n\tIn order to show the repeat texture qualities, I've opted for scales that look the same \n\tsize at different resolutions. That may or may not have been the best choice.\n\n    There's a compile option to distinguish between alternating scale layers and another \n\toption to turn off the highlights, just in case a rippling, hardened scale is messing \n\twith your sense of physical correctness. It disturbs mine a bit. :)\n\n\tOther examples:\n\n\t// I deliberately refrained from looking at Kuvkar's rendition in the hope that I could \n    // bring something new to the table. I didn't. :D\n\tEuropean Cobblestone Tiles - kuvkar\n\thttps://www.shadertoy.com/view/ldyXz1\n\n\t// Awesome usage of fish scales would be putting it mildly. :)\n\tKelp Forest - BigWIngs\n\thttps://www.shadertoy.com/view/llcSz8\n\n\t// Fabrices take on it. I might look into it more closely.\n\tHexagonal Tiling 5 - FabriceNeyret2\n    https://www.shadertoy.com/view/4dKXz3\n\n\n*/\n\n// Cheap bump highlights.\n#define SHOW_HIGHLIGHTS\n\n// Distinguishes between the two layers by changing the color of one.\n//#define SHOW_ALTERNATE_LAYERS\n   \n\n// A cheap hack to store a bump value.\nfloat bumpValue;\n\n// Fabrices consice, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n\n// Decorating each scale. For all intents and purposes, this is a demonstration of converting\n// an N by N square grid to N by N disc-like polar cells and drawing some things in them.\n// The code looks more involved than it really is, due to the coloring, decision making, etc. \nvec3 scaleDec(vec2 p, float layerID){\n\n    // Square grid partioning for the scales. This will be further partitioned into a polar\n    // grid to draw some details.\n    p = mod(p, vec2(.9, .5)) - vec2(.9, .5)/2.;\n\n\n    \n    // Mover the center of the disc to the top of the cell. In fact, we've moved it slightly \n    // higher to allow for the thicker fan border.\n    p -= vec2(-.05, -.28);\n    \n\n    \n    // Pinching the design together along X to match the fact that we're drawing circles slightly\n    // squashed along X... Technically ellipses.\n    // We're also multiply by a scalar factor or 14. This breaks each scale into a 14x14 grid, \n    // which we'll convert to polar coordinates. See the radius (r) and angle (a) lines below.\n    p *= 14./vec2(.95, 1); \n    \n    float r = length(p); // Radius. The radial part of the polar coordinate.\n    float patID = step(.5, fract(r/2.)); // Pattern ID. Either lines or the sinusoidal design.\n     \n    \n    // Rotate: I've given the layer IDs values of one and negative-one, in order to spin the\n    // discs in opposing directions... I figured it might look more interesting. Commenting it\n    // out stops the rotation.\n    p *= r2(-iTime/12.*layerID); \n    //p *= r2(-iTime/48.*(floor(r) + 4.)*spin); // Rotate sections at differt rates.\n    //if(patID>.5) p *= r2(-iTime/12.*spin);  // Only rotate half the sections.\n    \n    \n    // Controls the amount of vertical lines in each polar segment. Just to make things difficult,\n    // I wanted a higher density of lines and squiggles as we moved down the scale.\n    float vLineNum = floor(r)*12. + 16.;    \n    if(patID>.5)  vLineNum /= 2.; // Lower the frequency where rendering the squiggly bits.\n    \n    \n    // Angle of the pixel in the grid with respect to the center.\n    float a = atan(p.y, p.x);\n    // Partioning the angles into a number of segments.\n    float ia = floor(a*vLineNum/6.2831853);\n    ia = (ia + .5)/vLineNum*6.2831853; \n    \n    // Rotating by the segment angle above.\n    p *= r2(ia);\n    p.x = fract(p.x) - .5; \n    \n\t// The vertical lines.\n    float vLine = abs(p.y) - .05;  \n    vLine = smoothstep(0., fwidth(vLine), vLine)*.75 + .25;//step(0., d);////clamp(fwidth(vLine), 0., .1)*2.\n    if(patID>.5) vLine = 1.; // No vertical lines every second segment.\n    \n    // Horizontal partitioning lines.\n    float hLine = abs(fract(r + .5) - .5) - .05;\n    hLine = smoothstep(0., fwidth(hLine)*1., hLine);  \n \n    // Scale border - Smooth (trial and error) version of: if(r>7.15) hLine1 *= .05;\n    hLine *= .05 + smoothstep(0., fwidth(7.2 - r), 7.2-r)*.95; \n    \n    // Every second partition, draw a sinusoidal pattern.\n    if(patID>.5){\n        \n        // Line, centered in the partition, perturbed sinusoidally.\n        float wave = sin(a*vLineNum/2.)*.2;\n        float hLine2 = abs(fract(r + wave) - .5) - .04;\n        hLine2 = smoothstep(0., fwidth(hLine2)*1., hLine2);\n        // Place some dots in amongst the sinusoid.\n        float dots = length(p - vec2(wave*.5, 0)) - .07;\n        dots = smoothstep(0., fwidth(dots), dots);\n        hLine2 = min(hLine2, dots);\n        hLine2 = hLine2*.8 + .2;\n        \n        hLine = min(hLine, hLine2);\n    }\n    \n    \n    // Combining the horizontal line patterns and the vertical lines.   \n    vec3 col = vec3(1)*min(vLine, hLine);\n    \n\t// Color up every second partition according to object ID. I did this out of \n    // sheer boredom. :)\n    if(patID<.5) {        \n        \n        if (layerID > 0.) col *= vec3(.7, .9, 1.3);\n        else col *= vec3(.8, 1.2, 1.4);\n    }\n    \n    // Apply some color, dependent on segment number.\n    vec3 gradCol = pow(vec3(1.5, 1, 1)*max(1. - floor(r)/7.*.7, 0.), vec3(1, 2, 10)); \n    //vec3 gradCol = pow(vec3(1.5, 1, 1)*max(1. - (r)/7.*.7, 0.), vec3(1, 2, 10)); \n    //vec3 gradCol = pow(vec3(1.5, 1, 1)*max(1. - (r)/7.*.7, 0.), vec3(1, 3, 16)); \n\n    // Very simple bump value. It's a global variable, separate to the coloring. It's\n    // a bit of hack added after the fact, but it works.\n    //bumpFunc = cos(r*6.283)*.5 + .5;\n    bumpValue = 1. - clamp(-cos(r*6.283*1.)*2. + 1.5, 0., 1.)*1.;\n   \n    \n    // Return the final color.\n    return col*(min(gradCol, 1.)*.98 + .02);\n    \n    \n    \n}\n\n// Basically, three circular shapes combined in such a way as to create a fan. The result \n// is a grid \"half\" filled with fan shapes. A second layer - offset appropriately - is \n// required to fill in the entire space to create the overall scale texture.\n//\n// By the way, the procedure below is pretty simple, but a little difficult to describe. \n// Isolating the function and running it by itself is the best way to grasp it.\nfloat scalesMask(vec2 p){\n\n    \n    const float fwScale = 3.; // \"fwidth\" smoothing scale. Controls border blurriness to a degree.\n \n    // Repeat space: Breaking it up into .9 by .5 squares... just to be difficult. :)\n    // I wanted the scales to overlap slightly closer together, which meant bringing the centers\n    // closer together. This meant offsetting everything... You have my apologies. :)\n    p = mod(p, vec2(.9, .5)) - vec2(.9, .5)/2.;\n \n    \n    // Draw a circle, centered at the top of the .9 by .5 rectangle.\n    float c = length(p +  vec2(.0, .25)); \n    c = smoothstep(0.,  min(fwidth(c), .01)*fwScale, c - .5);\n\n    float mask = c;\n\n    // Chopped off two partial circles at the top left and top right. They're positioned in such\n    // a way to create a fan shape.\n    //\n    // The \"sign\" business is just a repetitive trick to take care of two quadrants at once.\n    // \"sign(p.x)\" has the effect of an \"if\" statement.\n    c = length(p - vec2(sign(p.x)*.9, -1.)*.5);\n    \n    \n    // Combine the three circular shapes to create the fan.\n    return max(mask, smoothstep(0., min(fwidth(c), .01)*fwScale, .5 - c));\n    \n}\n\n// The decrotated scale tiles. Render one set of decorated fans, combine them with the\n// other set, then add some highlighting and postprocessing.\nvec3 scaleTile(vec2 p){\n    \n    // Contorting the scale a bit to add to the hand-drawn look.\n    vec2 scale = vec2(3, -2.);\n    \n    // One set of scale tiles, which take up half the space.\n    float sm = scalesMask(p*scale); // Mask.\n    vec3 col = sm*scaleDec(p*scale + vec2(-.5, -.25), 1.); // Decoration.\n    float bf2 = bumpValue*sm;\n    \n    // The other set of scale tiles.\n    float sm2 = scalesMask(p*scale + vec2(-.45, -.75)); // Mask.\n    vec3 col2 = sm2*scaleDec(p*scale + vec2(-.5, -.75) + vec2(-.45, -.25), -1.); // Decoration.\n    \n    \n    #ifdef SHOW_ALTERNATE_LAYERS\n    // A simple way to distinguish between the two layers.\n    col2 = col2*.7 + col2.yxz*.3;\n    #endif\n    \n    // Add some highlighting.\n    bumpValue = max(bf2, bumpValue*sm2);\n    col = max(col, col2);\n    \n    // Toning the color down a bit. This was a last minute thing.\n    return col*.8 + col.zxy*.2;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates. Feel free to tweak it, if you want.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/450.; // iResolution.y;\n\n    // Perturbing - and shifting - the screen coordinates for a bit of a wavy effect. It\n    // gives the texture a kind of hand-drawn feel.\n    uv += sin(uv*3.14159*3. - sin(uv.yx*3.14159*6. + iTime*.5))*.0075 + vec2(0, .125);\n \n    \n    // Producing the scale tile.\n    vec3 col = scaleTile(uv);\n    #ifdef SHOW_HIGHLIGHTS\n    float bf = bumpValue; // Saving the bump value.\n    \n    // Taking a second nearby sample, in order to produce some cheap highlighting.\n    vec3 col2 = scaleTile(uv + .5/450.);// 450.;\n    float bf2 = bumpValue;\n    \n    // Color-based, or texture based bump.\n    float bump = max(dot(col2 - col, vec3(.299, .587, .114)), 0.)*4.;\n    // Adding a cheap and nasty functional bump. It effectively adds some extra contour.\n    bump += max(bf2 - bf, 0.)*2.;\n    \n    \n    // Add the rough highlighting.\n    col = col + vec3(1, 1, 1.5)*(col*.9 + .1)*bump;\n    //col = col*(vec3(.5, .7, 1)*bump*8. + 1.);\n    #endif\n    \n    // Rought gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2724, 2766, 2784, 2784, 2852], [2856, 3135, 3172, 3299, 7354], [7356, 7785, 7810, 7810, 8926], [8928, 9076, 9099, 9169, 9977], [9979, 9979, 10035, 10099, 11195]], "test": "valid"}
{"id": "XlKXzG", "name": "Mandelbrot zoom Meep edition", "author": "MeepMu", "description": "A simple Mandelbrot zoom", "tags": ["fractal"], "likes": 1, "viewed": 123, "published": "Public", "date": "1484810694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITS 1024\n#define ZOOMSPEED 10.\n#define ZOOMX -1.74995768370609350360221450607069970727110579726252077930242837820286008082972804887218672784431700831100544507655659531379747541999999995\n#define ZOOMY 0.00000000000000000278793706563379402178294753790944364927085054500163081379043930650189386849765202169477470552201325772332454726999999995\n\nstruct Complex {\n float r;\n float i;\n};\n\nfloat magSq(Complex c) {\n    return (c.r*c.r) + (c.i*c.i);\n}\n\nComplex complexMultiply(Complex first, Complex second) {\n    float r1r2;\n    float r1i2;\n    float i1r2;\n    float i1i2;\n    \n    r1r2 = first.r * second.r;\n    r1i2 = first.r * second.i;\n    i1r2 = first.i * second.r;\n    i1i2 = -(first.i*second.i);\n    \n    Complex c = Complex(r1r2 + i1i2, r1i2 + i1r2);\n    \n    return c;\n}\n\nComplex complexAdd(Complex first, Complex second) {\n    Complex c;\n    c.i = first.i + second.i;\n    c.r = first.r + second.r;\n    return c;\n}\n\n//from https://gist.github.com/eieio/4109795\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 c = vec3(h,s,v);\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 coord = vec2(fragCoord.x-(iResolution.x/2.),fragCoord.y-(iResolution.y/2.));\n  vec3 color;\n  bool inf = false;\n  float its = 0.;\n    \n  Complex z = Complex(0.0, 0.0);\n  Complex c = Complex((coord.x)/(ZOOMSPEED*pow(2.,iTime))+ZOOMX, (coord.y)/(ZOOMSPEED*pow(2.,iTime))+ZOOMY);\n    \n  for(int i = 0; i < MAXITS; i++) {\n    if(magSq(z) > 4.) {inf = true; break;}\n    z = complexMultiply(z,z);\n    z = complexAdd(z,c);\n    its += 1.;\n  }\n    if(inf) {\n        color = hsv2rgb(its*.01, 1., 1.);\n    } else {\n        color = vec3(0,0,0);\n    }\n  fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 393, 417, 417, 453], [455, 455, 511, 511, 782], [784, 784, 835, 835, 926], [928, 973, 1014, 1014, 1201], [1203, 1203, 1260, 1260, 1837]], "test": "valid"}
{"id": "XlKXzK", "name": "Potato", "author": "Ske", "description": "potato", "tags": ["potato"], "likes": 1, "viewed": 75, "published": "Public", "date": "1485039524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n    float fl = floor(p);\n  float fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float n = noise(vec3(uv * 5.0, iTime));\n    float distanceFromCenter = length(uv - vec2(0.5, 0.5)) * 2.5;\n    distanceFromCenter *= 0.5 + 0.5 * n;\n    fragColor = vec4(vec3(distanceFromCenter), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 58], [60, 60, 81, 81, 177], [179, 179, 199, 199, 269], [271, 271, 292, 292, 496], [498, 498, 520, 520, 565], [566, 566, 586, 586, 631], [632, 632, 650, 650, 689], [691, 691, 711, 711, 1202], [1204, 1204, 1261, 1261, 1509]], "test": "valid"}
{"id": "XlVSWW", "name": "360 sphere lines", "author": "zproxy", "description": "360 sphere lines", "tags": ["360"], "likes": 0, "viewed": 93, "published": "Public", "date": "1484365249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n  \nfloat stars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    vec3 q = fract(p*2.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 startrails(in vec3 rd)\n{\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = stars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\n    mo.x *= 4.2;\n    mo -= vec2(1.2,-0.1);\n\tmo.x *= iResolution.x/iResolution.y;\n    //mo.x += sin(time*0.15)*0.2;\n\t\n    vec3 ro = vec3(0., 0.,0.0);\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 up = normalize(cross(right, eye));\n\t\n    vec3 rd = normalize((p.x*right + p.y*up)*1.00 + eye);\n    //rd.y += abs(p.x*p.x*0.015);\n    \n    \n    //left to right\n    //rd = roty(rd, time);\n    \n   \n    \n    vec3 col = startrails( rd);\n\n  \n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 117], [123, 123, 147, 184, 274], [783, 783, 840, 840, 1738]], "test": "valid"}
{"id": "XlVXDz", "name": "BVH Tracing Experiment", "author": "stubbe", "description": "Speeding up triangle raytracing with a hardcoded Bounding Volume Hierarchy.\nEncoding the BV tree in the Abstract Syntax Tree of the source code :)\nThe tracing would be fast enough for larger models to be feasable, if the compiler didn't start choking :/", "tags": ["triangle", "intersection", "bvh", "mesh", "plucker", "bunny", "stanford"], "likes": 71, "viewed": 4157, "published": "Public API", "date": "1484259560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tracing of 292 polygon Stanford bunny in pure GLSL.\n\n// A hardcoded bounding volume hierarchy is used to speed up the trace.\n// By doing this we are effectively encoding the bounding volume tree in the\n// Abstract Syntax Tree :)\n\n// Unfortunately, at this point the compilation times seem like more of showstopper\n// than the actual tracing performance (yet again). It is possible that the compilation\n// time can be improved by massaging the code or by going multipass. \n\n// The triangle intersection test uses PlÃ¼cker coordinates, which\n// seem particularly well suited for this use case. The PlÃ¼cker coordinates\n// for the edges can be precomputed and the PlÃ¼cker coordinates for the ray\n// can be shared between all triangles. The intersection test itself then\n// reduces to just 6 dot products.\n\n#define USE_HIERARCHY 1\n#define SHOW_HIERARCHY 1\n#define USE_PLUCKER_COORDINATES 1\n\nconst float MAX_DIST = 1000.0;\n\nbool intersectBox(vec3 pos, vec3 invDir, vec3 mn, vec3 mx, float t)\n{\n#if USE_HIERARCHY\n    vec3 t0 = (mn - pos) * invDir;\n    vec3 t1 = (mx - pos) * invDir;\n    \n    float tmin = max(max(min(t0.x, t1.x), min(t0.y, t1.y)), min(t0.z,t1.z));\n    float tmax = min(min(max(t0.x, t1.x), max(t0.y, t1.y)), max(t0.z,t1.z));\n    return tmax >= tmin && tmin < t;\n#else\n    return true;\n#endif\n}\n\n#if USE_PLUCKER_COORDINATES\nvoid intersect_triangle(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, inout float min_t, out vec3 outNormal)\n{\n    // Can be shared between all triangles\n    vec3 center_u = dir;\n    vec3 center_v = cross(dir, pos);\n    \n    // Constant\n    vec3 v0_u = (v1 - v0);\n    vec3 v0_v = cross(v1, v0);\n    \n    vec3 v1_u = (v2 - v1);\n    vec3 v1_v = cross(v2, v1);\n    \n    vec3 v2_u = (v0 - v2);\n    vec3 v2_v = cross(v0, v2);\n    \n    vec3 normal = normalize(cross(v1 - v0, v2 - v0));\n    float q = dot(dir, normal);\n    \n    // 6 dot intersection test\n    if(dot(v0_u, center_v) + dot(v0_v, center_u) > 0.0 &&\n       dot(v1_u, center_v) + dot(v1_v, center_u) > 0.0 &&\n       dot(v2_u, center_v) + dot(v2_v, center_u) > 0.0)\n    {\n        \n        float t = -dot(pos - v0, normal) / q;\n        if(t < min_t)\n        {\n            outNormal = normal;\n            min_t = t;\n        }\n    }\n}\n\n#else\nfloat tripleProduct(vec3 a, vec3 b, vec3 c)\n{\n    return dot(a, cross(b, c));\n}\nvoid intersect_triangle(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, inout float min_t, out vec3 outNormal)\n{\n    if(tripleProduct(v0 - pos, v1 - pos, dir) < 0.0 && tripleProduct(v1 - pos, v2 - pos, dir) < 0.0 && tripleProduct(v2 - pos, v0 - pos, dir) < 0.0)\n    {\n        vec3 normal = normalize(cross(v1 - v0, v2 - v0));\n        float t = -dot(pos - v0, normal) / dot(dir, normal);\n        if(t < min_t)\n        {\n            outNormal = normal;\n            min_t = t;\n        }\n    }\n}\n#endif\n\n\n#define I(_v0x, _v0y, _v0z, _v1x, _v1y, _v1z, _v2x, _v2y, _v2z) intersect_triangle(pos, dir, vec3(_v0x, _v0y, _v0z), vec3(_v1x, _v1y, _v1z), vec3(_v2x, _v2y, _v2z), t, outNormal);\n#define B(_mnx, _mny, _mnz, _mxx, _mxy, _mxz) intersectBox(pos, invDir, vec3(_mnx, _mny, _mnz), vec3(_mxx, _mxy, _mxz), t)\n\nfloat numNodesVisited = 0.0;\nfloat intersectMesh(vec3 pos, vec3 dir, out vec3 outNormal)\n{\n    vec3 invDir = 1.0 / dir;\n    float t = MAX_DIST;\n    if(B( -23.890,   5.254, -45.197,    84.233, 112.514,  41.428))\n    {\n        numNodesVisited += 1.0;\n        I(  29.227,  44.540, -18.707,    46.160,  49.961, -16.626,    36.519,  43.722, -26.357);\n        I(  31.117, 112.434, -26.499,    23.362, 106.939, -20.396,    29.543, 111.693, -11.766);\n        I(  49.960,  29.367, -21.494,    38.374,  16.789, -19.974,    28.565,  32.567, -26.427);\n        I(  10.393,  14.842,  -6.125,    31.863,  15.076, -17.091,    13.467,   8.858, -17.503);\n        I(  19.874,   7.225,  37.050,    31.453,  15.389,  34.744,    17.848,  17.253,  29.948);\n        I(  28.902,  94.550, -20.603,    36.363,  93.381, -19.850,     9.658,  79.936,  -7.294);\n        I(  54.832,   5.352, -12.991,    54.923,   5.376,   0.265,    22.396,   5.312, -18.550);\n        I(  47.881,  72.038,  23.292,    48.752,  75.249,  10.750,    27.161,  64.590,  20.211);\n        I(  22.396,   5.312, -18.550,    54.923,   5.376,   0.265,    -6.453,   5.376,  22.765);\n        I(  32.651,  59.562, -16.574,    46.160,  49.961, -16.626,    29.227,  44.540, -18.707);\n        I(  21.051,  31.485, -14.744,    31.863,  15.076, -17.091,     6.239,  21.570,  -4.279);\n        I(  22.396,   5.312, -18.550,    13.467,   8.858, -17.503,    31.863,  15.076, -17.091);\n        I(  42.551,  64.352,  31.091,    47.881,  72.038,  23.292,    27.161,  64.590,  20.211);\n        I(  27.724,  41.869,  39.777,    31.181,  27.114,  41.307,    39.498,  46.218,  40.304);\n        I(  36.519,  43.722, -26.357,    28.565,  32.567, -26.427,    29.227,  44.540, -18.707);\n        I(  31.863,  15.076, -17.091,    28.565,  32.567, -26.427,    38.374,  16.789, -19.974);\n        I(  29.237,  68.702,  -1.372,    48.752,  75.249,  10.750,    50.796,  72.233,  -1.508);\n        I(  28.565,  32.567, -26.427,    31.863,  15.076, -17.091,    21.051,  31.485, -14.744);\n        I(  43.605,  63.727, -11.608,    29.237,  68.702,  -1.372,    50.796,  72.233,  -1.508);\n        I(  67.266,   5.336,  25.762,    -6.453,   5.376,  22.765,    70.472,   5.295,   5.591);\n        I(   5.592,  48.569, -20.200,    32.651,  59.562, -16.574,    29.227,  44.540, -18.707);\n        I(  27.161,  64.590,  20.211,    23.549,  47.895,  31.616,    42.551,  64.352,  31.091);\n        I(  41.233,  32.639, -26.832,    28.565,  32.567, -26.427,    36.519,  43.722, -26.357);\n        I(  36.363,  93.381, -19.850,    28.902,  94.550, -20.603,    30.041, 103.613, -30.601);\n        I(  32.651,  59.562, -16.574,    29.237,  68.702,  -1.372,    43.605,  63.727, -11.608);\n        I(  42.551,  64.352,  31.091,    23.549,  47.895,  31.616,    27.724,  41.869,  39.777);\n        I(  29.237,  68.702,  -1.372,    32.651,  59.562, -16.574,    11.323,  68.510, -10.695);\n        I(  46.470,   5.312,  32.180,    -6.453,   5.376,  22.765,    67.266,   5.336,  25.762);\n        I(  41.233,  32.639, -26.832,    49.960,  29.367, -21.494,    28.565,  32.567, -26.427);\n        I(  38.196, 110.779, -23.468,    31.117, 112.434, -26.499,    29.543, 111.693, -11.766);\n        I(  31.117, 112.434, -26.499,    35.363, 105.769, -30.643,    30.041, 103.613, -30.601);\n        I(  31.181,  27.114,  41.307,    27.724,  41.869,  39.777,    16.296,  28.902,  30.711);\n        I(  48.752,  75.249,  10.750,    29.237,  68.702,  -1.372,    27.161,  64.590,  20.211);\n        I(  19.874,   7.225,  37.050,    12.698,   5.310,  28.182,    46.470,   5.312,  32.180);\n        I(  54.923,   5.376,   0.265,    70.472,   5.295,   5.591,    -6.453,   5.376,  22.765);\n        I(  42.551,  64.352,  31.091,    27.724,  41.869,  39.777,    39.498,  46.218,  40.304);\n        I(  19.874,   7.225,  37.050,    46.470,   5.312,  32.180,    31.453,  15.389,  34.744);\n        I(  10.393,  14.842,  -6.125,     6.239,  21.570,  -4.279,    31.863,  15.076, -17.091);\n        I(  30.041, 103.613, -30.601,    35.363, 105.769, -30.643,    36.363,  93.381, -19.850);\n        I(  22.617,  96.787,  -2.459,    38.196, 110.779, -23.468,    29.543, 111.693, -11.766);\n        I(  36.363,  93.381, -19.850,    13.185,  81.566,  -0.511,     9.658,  79.936,  -7.294);\n        I(  17.848,  17.253,  29.948,    31.453,  15.389,  34.744,    31.181,  27.114,  41.307);\n        I(  31.181,  27.114,  41.307,    16.296,  28.902,  30.711,    17.848,  17.253,  29.948);\n        I(  22.617,  96.787,  -2.459,    13.185,  81.566,  -0.511,    35.530,  95.245, -14.819);\n        I(  35.530,  95.245, -14.819,    38.196, 110.779, -23.468,    22.617,  96.787,  -2.459);\n        I(  32.651,  59.562, -16.574,     5.592,  48.569, -20.200,    17.374,  62.435, -15.596);\n        I(  17.374,  62.435, -15.596,    11.323,  68.510, -10.695,    32.651,  59.562, -16.574);\n        I(  31.863,  15.076, -17.091,    54.832,   5.352, -12.991,    22.396,   5.312, -18.550);\n        I(  12.698,   5.310,  28.182,    -6.453,   5.376,  22.765,    46.470,   5.312,  32.180);\n        I(  30.041, 103.613, -30.601,    23.362, 106.939, -20.396,    31.117, 112.434, -26.499);\n        I(  35.530,  95.245, -14.819,    13.185,  81.566,  -0.511,    36.363,  93.381, -19.850);\n        if(B( -23.890,   5.254, -45.197,    30.041, 112.514,  39.777))\n        {\n            numNodesVisited += 1.0;\n            I(  13.977,  65.434,  17.522,    12.460,  52.312,  27.631,    27.161,  64.590,  20.211);\n            I( -19.512,  57.556,  24.398,   -22.722,  64.221,  26.361,   -22.557,  60.116,   7.864);\n            I( -17.363,  54.556,   2.177,   -17.016,  62.738,  -6.631,    -5.463,  58.637, -11.137);\n            I(  11.323,  68.510, -10.695,     5.592,  48.569, -20.200,    -5.463,  58.637, -11.137);\n            I(  -4.712,  55.313,  24.599,    12.460,  52.312,  27.631,    13.977,  65.434,  17.522);\n            I(  11.323,  68.510, -10.695,    17.374,  62.435, -15.596,     5.592,  48.569, -20.200);\n            I( -17.016,  62.738,  -6.631,   -17.363,  54.556,   2.177,   -22.557,  60.116,   7.864);\n            I(  -2.565,  77.949, -12.458,    -5.463,  58.637, -11.137,    -7.096,  82.828, -11.379);\n            I( -19.512,  57.556,  24.398,    -5.818,  62.804,  33.935,   -14.483,  70.881,  32.905);\n            I(  12.460,  52.312,  27.631,    23.549,  47.895,  31.616,    27.161,  64.590,  20.211);\n            I(  -4.712,  55.313,  24.599,    13.977,  65.434,  17.522,     1.501,  65.005,  25.918);\n            I(  -2.565,  77.949, -12.458,    11.323,  68.510, -10.695,    -5.463,  58.637, -11.137);\n            I(  -4.712,  55.313,  24.599,     1.501,  65.005,  25.918,    -5.818,  62.804,  33.935);\n            I( -15.295,  55.173,  17.340,   -22.557,  60.116,   7.864,   -17.363,  54.556,   2.177);\n            I( -22.722,  64.221,  26.361,   -19.512,  57.556,  24.398,   -14.483,  70.881,  32.905);\n            I( -19.512,  57.556,  24.398,   -22.557,  60.116,   7.864,   -15.295,  55.173,  17.340);\n            I(  -7.096,  82.828, -11.379,    -5.463,  58.637, -11.137,   -17.016,  62.738,  -6.631);\n            I(  -4.712,  55.313,  24.599,    -5.818,  62.804,  33.935,   -19.512,  57.556,  24.398);\n            if(B( -20.512,   5.254, -26.427,    29.227,  58.637,  39.777))\n            {\n                numNodesVisited += 1.0;\n                I( -16.082,  36.272,  -1.183,    -7.136,  23.835,  15.087,   -10.108,  31.132,  20.984);\n                I( -17.363,  54.556,   2.177,   -16.082,  36.272,  -1.183,   -20.512,  46.442,   9.215);\n                I(  -5.434,   7.631,  -1.448,     8.905,   5.275,  -5.377,    -0.457,   5.254,  12.882);\n                I( -20.512,  46.442,   9.215,   -15.295,  55.173,  17.340,   -17.363,  54.556,   2.177);\n                I(  -0.457,   5.254,  12.882,    -1.815,  11.859,   7.485,    -5.434,   7.631,  -1.448);\n                I(  -0.457,   5.254,  12.882,    22.396,   5.312, -18.550,    -6.453,   5.376,  22.765);\n                I(  -5.434,   7.631,  -1.448,    -1.815,  11.859,   7.485,     6.420,  13.852,   6.828);\n                I(   8.905,   5.275,  -5.377,    22.396,   5.312, -18.550,    -0.457,   5.254,  12.882);\n                I(   6.239,  21.570,  -4.279,    10.393,  14.842,  -6.125,     6.420,  13.852,   6.828);\n                I( -16.082,  36.272,  -1.183,    -7.554,  24.985,  -1.506,    -7.136,  23.835,  15.087);\n                I( -20.512,  46.442,   9.215,   -16.082,  36.272,  -1.183,   -10.108,  31.132,  20.984);\n                I(  -7.554,  24.985,  -1.506,     6.239,  21.570,  -4.279,    -7.136,  23.835,  15.087);\n                I(  -5.434,   7.631,  -1.448,     6.420,  13.852,   6.828,    10.393,  14.842,  -6.125);\n                I(   6.239,  21.570,  -4.279,     7.373,  19.886,  20.273,    -7.136,  23.835,  15.087);\n                I(   6.420,  13.852,   6.828,     7.373,  19.886,  20.273,     6.239,  21.570,  -4.279);\n                if(B( -17.363,   5.275, -26.427,    29.227,  58.637,   2.177))\n                {\n                    numNodesVisited += 1.0;\n                    I(  29.227,  44.540, -18.707,    21.051,  31.485, -14.744,     5.592,  48.569, -20.200);\n                    I( -16.082,  36.272,  -1.183,    -8.192,  44.902, -14.455,    -7.554,  24.985,  -1.506);\n                    I(   2.113,  32.445, -16.716,    21.051,  31.485, -14.744,     6.239,  21.570,  -4.279);\n                    I(  29.227,  44.540, -18.707,    28.565,  32.567, -26.427,    21.051,  31.485, -14.744);\n                    I(   2.113,  32.445, -16.716,    -7.554,  24.985,  -1.506,    -8.192,  44.902, -14.455);\n                    I(  -7.554,  24.985,  -1.506,     2.113,  32.445, -16.716,     6.239,  21.570,  -4.279);\n                    I(   2.113,  32.445, -16.716,     5.592,  48.569, -20.200,    21.051,  31.485, -14.744);\n                    if(B(  -5.434,   5.275, -18.550,    22.396,  14.842,  -1.448))\n                    {\n                        numNodesVisited += 1.0;\n                        I(   8.905,   5.275,  -5.377,    10.393,  14.842,  -6.125,    13.467,   8.858, -17.503);\n                        I(  13.467,   8.858, -17.503,    22.396,   5.312, -18.550,     8.905,   5.275,  -5.377);\n                        I(   8.905,   5.275,  -5.377,    -5.434,   7.631,  -1.448,    10.393,  14.842,  -6.125);\n                    }\n                    if(B( -17.363,  32.445, -20.200,     5.592,  58.637,   2.177))\n                    {\n                        numNodesVisited += 1.0;\n                        I(   5.592,  48.569, -20.200,    -8.192,  44.902, -14.455,    -5.463,  58.637, -11.137);\n                        I( -17.363,  54.556,   2.177,    -8.192,  44.902, -14.455,   -16.082,  36.272,  -1.183);\n                        I(   5.592,  48.569, -20.200,     2.113,  32.445, -16.716,    -8.192,  44.902, -14.455);\n                        I(  -5.463,  58.637, -11.137,    -8.192,  44.902, -14.455,   -17.363,  54.556,   2.177);\n                    }\n                }\n                if(B( -20.512,   5.254,   6.828,    27.724,  57.556,  39.777))\n                {\n                    numNodesVisited += 1.0;\n                    I(  -1.426,  35.928,  28.698,     7.373,  19.886,  20.273,    16.296,  28.902,  30.711);\n                    I(  -1.426,  35.928,  28.698,    -1.693,  44.654,  30.415,   -10.108,  31.132,  20.984);\n                    I(  23.549,  47.895,  31.616,    16.296,  28.902,  30.711,    27.724,  41.869,  39.777);\n                    I(  16.296,  28.902,  30.711,    23.549,  47.895,  31.616,    12.460,  52.312,  27.631);\n                    I(  -1.426,  35.928,  28.698,    16.296,  28.902,  30.711,    -1.693,  44.654,  30.415);\n                    I( -20.512,  46.442,   9.215,   -10.108,  31.132,  20.984,   -15.620,  41.254,  19.235);\n                    I(  16.296,  28.902,  30.711,    12.460,  52.312,  27.631,    -1.693,  44.654,  30.415);\n                    I( -10.108,  31.132,  20.984,     7.373,  19.886,  20.273,    -1.426,  35.928,  28.698);\n                    I( -15.620,  41.254,  19.235,   -10.108,  31.132,  20.984,    -1.693,  44.654,  30.415);\n                    if(B( -10.108,   5.254,   6.828,    19.874,  31.132,  37.050))\n                    {\n                        numNodesVisited += 1.0;\n                        I(   7.373,  19.886,  20.273,    10.061,  10.217,  10.792,     7.338,  15.426,  24.843);\n                        I(  16.296,  28.902,  30.711,     7.373,  19.886,  20.273,    17.848,  17.253,  29.948);\n                        I(  -6.453,   5.376,  22.765,    10.061,  10.217,  10.792,    -0.457,   5.254,  12.882);\n                        I(  17.848,  17.253,  29.948,     7.373,  19.886,  20.273,     7.338,  15.426,  24.843);\n                        I(  10.061,  10.217,  10.792,    -6.453,   5.376,  22.765,     7.338,  15.426,  24.843);\n                        if(B( -10.108,   5.254,   6.828,    10.061,  31.132,  20.984))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  -1.815,  11.859,   7.485,    -0.457,   5.254,  12.882,    10.061,  10.217,  10.792);\n                            I(   7.373,  19.886,  20.273,     6.420,  13.852,   6.828,    10.061,  10.217,  10.792);\n                            I( -10.108,  31.132,  20.984,    -7.136,  23.835,  15.087,     7.373,  19.886,  20.273);\n                            I(  10.061,  10.217,  10.792,     6.420,  13.852,   6.828,    -1.815,  11.859,   7.485);\n                        }\n                        if(B(  -6.453,   5.310,  22.765,    19.874,  17.253,  37.050))\n                        {\n                            numNodesVisited += 1.0;\n                            I(   1.372,   8.036,  29.638,     7.338,  15.426,  24.843,    -6.453,   5.376,  22.765);\n                            I(   7.338,  15.426,  24.843,     1.372,   8.036,  29.638,    12.698,   5.310,  28.182);\n                            I(   1.372,   8.036,  29.638,    -6.453,   5.376,  22.765,    12.698,   5.310,  28.182);\n                            if(B(   7.338,   5.310,  24.843,    19.874,  17.253,  37.050))\n                            {\n                                numNodesVisited += 1.0;\n                                I(  12.698,   5.310,  28.182,    17.848,  17.253,  29.948,     7.338,  15.426,  24.843);\n                                I(  17.848,  17.253,  29.948,    12.698,   5.310,  28.182,    19.874,   7.225,  37.050);\n                            }\n                        }\n                    }\n                    if(B( -20.512,  41.254,   9.215,    12.460,  57.556,  30.415))\n                    {\n                        numNodesVisited += 1.0;\n                        I(  -4.712,  55.313,  24.599,   -15.620,  41.254,  19.235,    -1.693,  44.654,  30.415);\n                        I(  12.460,  52.312,  27.631,    -4.712,  55.313,  24.599,    -1.693,  44.654,  30.415);\n                        if(B( -20.512,  41.254,   9.215,    -4.712,  57.556,  24.599))\n                        {\n                            numNodesVisited += 1.0;\n                            I( -20.512,  46.442,   9.215,   -15.620,  41.254,  19.235,   -15.295,  55.173,  17.340);\n                            I( -15.295,  55.173,  17.340,   -15.620,  41.254,  19.235,    -4.712,  55.313,  24.599);\n                            I(  -4.712,  55.313,  24.599,   -19.512,  57.556,  24.398,   -15.295,  55.173,  17.340);\n                        }\n                    }\n                }\n            }\n            if(B( -23.890,  60.116, -45.197,    30.041, 112.514,  33.935))\n            {\n                numNodesVisited += 1.0;\n                I( -23.890,  67.722,   7.029,   -17.016,  62.738,  -6.631,   -22.557,  60.116,   7.864);\n                I(  13.185,  81.566,  -0.511,    16.882,  71.507,   3.675,     9.658,  79.936,  -7.294);\n                I(   4.804,  89.171, -14.353,    -2.582,  90.300,  -3.292,     6.386,  90.644,  -8.426);\n                I(  -9.317,  87.905,  -8.589,   -19.342,  78.162,   1.291,   -21.594,  86.379,   5.909);\n                I(   7.052,  92.853,   3.030,    29.543, 111.693, -11.766,     9.680, 100.125,  -4.998);\n                I(  -9.317,  87.905,  -8.589,    -7.096,  82.828, -11.379,   -19.342,  78.162,   1.291);\n                I(  -9.317,  87.905,  -8.589,   -21.594,  86.379,   5.909,    -2.582,  90.300,  -3.292);\n                I(   9.680, 100.125,  -4.998,    23.362, 106.939, -20.396,     6.386,  90.644,  -8.426);\n                I(  -7.096,  82.828, -11.379,   -17.016,  62.738,  -6.631,   -19.342,  78.162,   1.291);\n                I(  23.362, 106.939, -20.396,     9.680, 100.125,  -4.998,    29.543, 111.693, -11.766);\n                I(   9.680, 100.125,  -4.998,     6.386,  90.644,  -8.426,    -2.582,  90.300,  -3.292);\n                I(  22.617,  96.787,  -2.459,    29.543, 111.693, -11.766,     7.052,  92.853,   3.030);\n                I(  11.323,  68.510, -10.695,    16.882,  71.507,   3.675,    29.237,  68.702,  -1.372);\n                I(  -2.155, 100.336, -20.624,    -9.317,  87.905,  -8.589,    -2.582,  90.300,  -3.292);\n                I(  -2.582,  90.300,  -3.292,     4.804,  89.171, -14.353,    10.608, 101.517, -28.954);\n                I( -19.342,  78.162,   1.291,   -17.016,  62.738,  -6.631,   -23.890,  67.722,   7.029);\n                I(  -2.155, 100.336, -20.624,    -2.582,  90.300,  -3.292,    10.608, 101.517, -28.954);\n                I(   9.658,  79.936,  -7.294,    16.882,  71.507,   3.675,    11.323,  68.510, -10.695);\n                if(B(  -9.317,  68.510, -45.197,    30.041, 112.514,  -7.294))\n                {\n                    numNodesVisited += 1.0;\n                    I(  -7.096,  82.828, -11.379,     6.276,  90.716, -42.755,     4.598,  84.129, -36.359);\n                    I(   6.386,  90.644,  -8.426,     4.805,  78.931, -10.328,     4.804,  89.171, -14.353);\n                    I(   6.386,  90.644,  -8.426,    28.902,  94.550, -20.603,     9.658,  79.936,  -7.294);\n                    I(  -4.246,  94.470, -23.641,    -7.096,  82.828, -11.379,    -9.317,  87.905,  -8.589);\n                    I(   4.804,  89.171, -14.353,     3.331,  82.537, -19.617,    19.485,  93.621, -38.630);\n                    I(  19.485,  93.621, -38.630,    21.241, 104.227, -36.329,     4.804,  89.171, -14.353);\n                    I(  18.309,  97.114, -45.197,     4.598,  84.129, -36.359,     6.276,  90.716, -42.755);\n                    I(   3.270,  94.083, -34.316,     6.276,  90.716, -42.755,    -7.096,  82.828, -11.379);\n                    I(  -2.155, 100.336, -20.624,    -4.246,  94.470, -23.641,    -9.317,  87.905,  -8.589);\n                    I(   4.598,  84.129, -36.359,    19.485,  93.621, -38.630,     3.331,  82.537, -19.617);\n                    I(  19.485,  93.621, -38.630,     4.598,  84.129, -36.359,    18.309,  97.114, -45.197);\n                    I(   3.270,  94.083, -34.316,    -7.096,  82.828, -11.379,    -4.246,  94.470, -23.641);\n                    I(   4.804,  89.171, -14.353,    21.241, 104.227, -36.329,    10.608, 101.517, -28.954);\n                    I(   6.386,  90.644,  -8.426,     9.658,  79.936,  -7.294,     4.805,  78.931, -10.328);\n                    if(B(  -7.096,  68.510, -36.359,    11.323,  89.171,  -7.294))\n                    {\n                        numNodesVisited += 1.0;\n                        I(   4.598,  84.129, -36.359,    -2.565,  77.949, -12.458,    -7.096,  82.828, -11.379);\n                        I(   3.331,  82.537, -19.617,    -2.565,  77.949, -12.458,     4.598,  84.129, -36.359);\n                        if(B(  -2.565,  68.510, -19.617,    11.323,  89.171,  -7.294))\n                        {\n                            numNodesVisited += 1.0;\n                            I(   4.805,  78.931, -10.328,     9.658,  79.936,  -7.294,    11.323,  68.510, -10.695);\n                            I(   4.805,  78.931, -10.328,     3.331,  82.537, -19.617,     4.804,  89.171, -14.353);\n                            I(   3.331,  82.537, -19.617,     4.805,  78.931, -10.328,    -2.565,  77.949, -12.458);\n                            I(  -2.565,  77.949, -12.458,     4.805,  78.931, -10.328,    11.323,  68.510, -10.695);\n                        }\n                    }\n                    if(B(  -4.462,  90.644, -45.197,    30.041, 112.514,  -8.426))\n                    {\n                        numNodesVisited += 1.0;\n                        I(  -4.462, 103.480, -33.056,     3.270,  94.083, -34.316,    -4.246,  94.470, -23.641);\n                        I(  -4.462, 103.480, -33.056,    -4.246,  94.470, -23.641,    -2.155, 100.336, -20.624);\n                        I(  28.902,  94.550, -20.603,    23.362, 106.939, -20.396,    30.041, 103.613, -30.601);\n                        I(  -2.155, 100.336, -20.624,     1.880, 110.211, -37.066,    -4.462, 103.480, -33.056);\n                        I(  -2.155, 100.336, -20.624,    10.608, 101.517, -28.954,     1.880, 110.211, -37.066);\n                        if(B(  -4.462,  90.716, -45.197,    21.241, 112.514, -28.954))\n                        {\n                            numNodesVisited += 1.0;\n                            I(   8.380, 107.664, -43.984,    18.309,  97.114, -45.197,     6.276,  90.716, -42.755);\n                            I(  16.220, 112.514, -41.004,    18.309,  97.114, -45.197,     8.380, 107.664, -43.984);\n                            I(   1.880, 110.211, -37.066,    16.220, 112.514, -41.004,     8.380, 107.664, -43.984);\n                            I(  10.608, 101.517, -28.954,    16.220, 112.514, -41.004,     1.880, 110.211, -37.066);\n                            if(B(  -4.462,  90.716, -43.984,     8.380, 110.211, -33.056))\n                            {\n                                numNodesVisited += 1.0;\n                                I(   8.380, 107.664, -43.984,    -4.462, 103.480, -33.056,     1.880, 110.211, -37.066);\n                                I(  -4.462, 103.480, -33.056,     8.380, 107.664, -43.984,     3.270,  94.083, -34.316);\n                                I(   8.380, 107.664, -43.984,     6.276,  90.716, -42.755,     3.270,  94.083, -34.316);\n                            }\n                            if(B(  10.608,  93.621, -45.197,    21.241, 112.514, -28.954))\n                            {\n                                numNodesVisited += 1.0;\n                                I(  16.220, 112.514, -41.004,    21.241, 104.227, -36.329,    18.309,  97.114, -45.197);\n                                I(  21.241, 104.227, -36.329,    19.485,  93.621, -38.630,    18.309,  97.114, -45.197);\n                                I(  10.608, 101.517, -28.954,    21.241, 104.227, -36.329,    16.220, 112.514, -41.004);\n                            }\n                        }\n                        if(B(   6.386,  90.644, -20.603,    28.902, 106.939,  -8.426))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  23.362, 106.939, -20.396,    28.902,  94.550, -20.603,     6.386,  90.644,  -8.426);\n                        }\n                    }\n                }\n                if(B( -23.890,  60.116,  -4.998,    29.237, 100.125,  33.935))\n                {\n                    numNodesVisited += 1.0;\n                    I(  -2.582,  90.300,  -3.292,     7.052,  92.853,   3.030,     9.680, 100.125,  -4.998);\n                    I(  -4.205,  93.740,   8.040,     7.052,  92.853,   3.030,    -2.582,  90.300,  -3.292);\n                    I(   3.630,  88.539,  19.402,   -14.117,  88.406,  16.907,    -6.772,  83.070,  27.367);\n                    I(   5.315,  80.260,  17.000,    -5.818,  62.804,  33.935,     1.501,  65.005,  25.918);\n                    I(   5.315,  80.260,  17.000,     1.501,  65.005,  25.918,    13.977,  65.434,  17.522);\n                    I(   5.315,  80.260,  17.000,    -6.772,  83.070,  27.367,    -5.818,  62.804,  33.935);\n                    I(  -6.772,  83.070,  27.367,     5.315,  80.260,  17.000,     3.630,  88.539,  19.402);\n                    I(  10.398,  89.710,   3.888,    -4.205,  93.740,   8.040,     3.630,  88.539,  19.402);\n                    I(  -4.205,  93.740,   8.040,   -14.117,  88.406,  16.907,     3.630,  88.539,  19.402);\n                    I(   7.052,  92.853,   3.030,    -4.205,  93.740,   8.040,    10.398,  89.710,   3.888);\n                    if(B( -23.890,  60.116,  -3.292,    -2.582,  93.740,  33.935))\n                    {\n                        numNodesVisited += 1.0;\n                        I( -21.594,  86.379,   5.909,   -14.117,  88.406,  16.907,    -4.205,  93.740,   8.040);\n                        I( -23.890,  67.722,   7.029,   -20.018,  77.263,  24.491,   -19.342,  78.162,   1.291);\n                        I( -22.722,  64.221,  26.361,   -20.018,  77.263,  24.491,   -22.557,  60.116,   7.864);\n                        I( -21.594,  86.379,   5.909,   -19.342,  78.162,   1.291,   -20.018,  77.263,  24.491);\n                        I( -21.594,  86.379,   5.909,   -20.018,  77.263,  24.491,   -14.117,  88.406,  16.907);\n                        I( -20.018,  77.263,  24.491,   -23.890,  67.722,   7.029,   -22.557,  60.116,   7.864);\n                        if(B( -21.594,  86.379,  -3.292,    -2.582,  93.740,   8.040))\n                        {\n                            numNodesVisited += 1.0;\n                            I( -21.594,  86.379,   5.909,    -4.205,  93.740,   8.040,    -2.582,  90.300,  -3.292);\n                        }\n                        if(B( -22.722,  62.804,  16.907,    -5.818,  88.406,  33.935))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  -6.772,  83.070,  27.367,   -14.117,  88.406,  16.907,   -20.018,  77.263,  24.491);\n                            I( -20.018,  77.263,  24.491,   -14.483,  70.881,  32.905,    -6.772,  83.070,  27.367);\n                            I( -20.018,  77.263,  24.491,   -22.722,  64.221,  26.361,   -14.483,  70.881,  32.905);\n                            I(  -5.818,  62.804,  33.935,    -6.772,  83.070,  27.367,   -14.483,  70.881,  32.905);\n                        }\n                    }\n                    if(B(   3.630,  64.590,  -2.459,    29.237,  96.787,  20.211))\n                    {\n                        numNodesVisited += 1.0;\n                        I(  13.185,  81.566,  -0.511,    13.977,  65.434,  17.522,    16.882,  71.507,   3.675);\n                        I(   5.315,  80.260,  17.000,    13.977,  65.434,  17.522,    10.398,  89.710,   3.888);\n                        I(  10.398,  89.710,   3.888,    13.977,  65.434,  17.522,    13.185,  81.566,  -0.511);\n                        I(   5.315,  80.260,  17.000,    10.398,  89.710,   3.888,     3.630,  88.539,  19.402);\n                        if(B(  13.977,  64.590,  -1.372,    29.237,  71.507,  20.211))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  29.237,  68.702,  -1.372,    16.882,  71.507,   3.675,    27.161,  64.590,  20.211);\n                            I(  16.882,  71.507,   3.675,    13.977,  65.434,  17.522,    27.161,  64.590,  20.211);\n                        }\n                        if(B(   7.052,  81.566,  -2.459,    22.617,  96.787,   3.888))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  10.398,  89.710,   3.888,    22.617,  96.787,  -2.459,     7.052,  92.853,   3.030);\n                            I(  10.398,  89.710,   3.888,    13.185,  81.566,  -0.511,    22.617,  96.787,  -2.459);\n                        }\n                    }\n                }\n            }\n        }\n        if(B(  31.117,   5.281, -30.643,    84.233, 112.434,  41.428))\n        {\n            numNodesVisited += 1.0;\n            I(  59.223,  63.991, -11.887,    68.242,  51.547,  -9.495,    57.814,  53.833, -13.205);\n            I(  55.152,  50.349,  35.401,    71.848,  51.513,  25.795,    62.428,  60.189,  28.382);\n            I(  59.223,  63.991, -11.887,    76.141,  55.116,   2.216,    68.242,  51.547,  -9.495);\n            I(  76.141,  55.116,   2.216,    59.223,  63.991, -11.887,    63.770,  69.473,   6.074);\n            I(  76.141,  55.116,   2.216,    63.770,  69.473,   6.074,    67.757,  64.533,  19.785);\n            I(  55.152,  50.349,  35.401,    62.428,  60.189,  28.382,    39.498,  46.218,  40.304);\n            I(  62.428,  60.189,  28.382,    42.551,  64.352,  31.091,    39.498,  46.218,  40.304);\n            I(  32.651,  59.562, -16.574,    57.814,  53.833, -13.205,    46.160,  49.961, -16.626);\n            I(  59.223,  63.991, -11.887,    57.814,  53.833, -13.205,    43.605,  63.727, -11.608);\n            I(  67.757,  64.533,  19.785,    62.428,  60.189,  28.382,    71.848,  51.513,  25.795);\n            I(  67.757,  64.533,  19.785,    71.848,  51.513,  25.795,    76.141,  55.116,   2.216);\n            I(  43.605,  63.727, -11.608,    57.814,  53.833, -13.205,    32.651,  59.562, -16.574);\n            if(B(  31.181,   5.281, -26.832,    84.233,  55.116,  41.428))\n            {\n                numNodesVisited += 1.0;\n                I(  76.141,  55.116,   2.216,    77.160,  40.036,  20.248,    77.444,  31.786,   9.293);\n                I(  76.141,  55.116,   2.216,    77.444,  31.786,   9.293,    74.177,  41.443,  -6.972);\n                I(  82.997,  31.685,   9.758,    79.977,  21.759,   3.088,    74.104,  25.026,   2.433);\n                I(  82.997,  31.685,   9.758,    84.233,  23.274,  10.809,    79.977,  21.759,   3.088);\n                I(  74.177,  41.443,  -6.972,    77.444,  31.786,   9.293,    74.104,  25.026,   2.433);\n                I(  74.104,  25.026,   2.433,    77.444,  31.786,   9.293,    82.997,  31.685,   9.758);\n                I(  74.378,   5.281,  16.983,    67.266,   5.336,  25.762,    70.472,   5.295,   5.591);\n                I(  79.977,  21.759,   3.088,    84.233,  23.274,  10.809,    70.472,   5.295,   5.591);\n                I(  71.848,  51.513,  25.795,    77.160,  40.036,  20.248,    76.141,  55.116,   2.216);\n                I(  84.233,  23.274,  10.809,    74.378,   5.281,  16.983,    70.472,   5.295,   5.591);\n                if(B(  31.863,   5.295, -26.832,    79.977,  55.116,   5.591))\n                {\n                    numNodesVisited += 1.0;\n                    I(  63.936,  34.695, -15.736,    63.092,  22.043, -13.910,    49.960,  29.367, -21.494);\n                    I(  74.104,  25.026,   2.433,    63.936,  34.695, -15.736,    74.177,  41.443,  -6.972);\n                    I(  74.104,  25.026,   2.433,    63.092,  22.043, -13.910,    63.936,  34.695, -15.736);\n                    I(  36.519,  43.722, -26.357,    49.960,  29.367, -21.494,    41.233,  32.639, -26.832);\n                    I(  63.936,  34.695, -15.736,    49.960,  29.367, -21.494,    36.519,  43.722, -26.357);\n                    if(B(  31.863,   5.295, -21.494,    79.977,  29.367,   5.591))\n                    {\n                        numNodesVisited += 1.0;\n                        I(  56.439,  14.206, -12.568,    49.960,  29.367, -21.494,    63.092,  22.043, -13.910);\n                        I(  54.832,   5.352, -12.991,    56.439,  14.206, -12.568,    54.923,   5.376,   0.265);\n                        I(  54.923,   5.376,   0.265,    65.393,  12.979,  -1.685,    70.472,   5.295,   5.591);\n                        I(  56.439,  14.206, -12.568,    54.832,   5.352, -12.991,    31.863,  15.076, -17.091);\n                        I(  38.374,  16.789, -19.974,    56.439,  14.206, -12.568,    31.863,  15.076, -17.091);\n                        I(  56.439,  14.206, -12.568,    65.393,  12.979,  -1.685,    54.923,   5.376,   0.265);\n                        I(  49.960,  29.367, -21.494,    56.439,  14.206, -12.568,    38.374,  16.789, -19.974);\n                        if(B(  56.439,   5.295, -13.910,    79.977,  25.026,   5.591))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  63.092,  22.043, -13.910,    74.104,  25.026,   2.433,    65.393,  12.979,  -1.685);\n                            I(  63.092,  22.043, -13.910,    65.393,  12.979,  -1.685,    56.439,  14.206, -12.568);\n                            I(  79.977,  21.759,   3.088,    70.472,   5.295,   5.591,    74.104,  25.026,   2.433);\n                            I(  74.104,  25.026,   2.433,    70.472,   5.295,   5.591,    65.393,  12.979,  -1.685);\n                        }\n                    }\n                    if(B(  36.519,  34.695, -26.357,    76.141,  55.116,   2.216))\n                    {\n                        numNodesVisited += 1.0;\n                        I(  56.677,  42.754, -18.934,    63.936,  34.695, -15.736,    36.519,  43.722, -26.357);\n                        I(  56.677,  42.754, -18.934,    36.519,  43.722, -26.357,    46.160,  49.961, -16.626);\n                        I(  57.814,  53.833, -13.205,    56.677,  42.754, -18.934,    46.160,  49.961, -16.626);\n                        if(B(  56.677,  34.695, -18.934,    76.141,  55.116,   2.216))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  57.814,  53.833, -13.205,    68.242,  51.547,  -9.495,    56.677,  42.754, -18.934);\n                            I(  76.141,  55.116,   2.216,    74.177,  41.443,  -6.972,    68.242,  51.547,  -9.495);\n                            I(  63.936,  34.695, -15.736,    56.677,  42.754, -18.934,    68.242,  51.547,  -9.495);\n                            I(  63.936,  34.695, -15.736,    68.242,  51.547,  -9.495,    74.177,  41.443,  -6.972);\n                        }\n                    }\n                }\n                if(B(  31.181,   5.281,   9.293,    84.233,  51.513,  41.428))\n                {\n                    numNodesVisited += 1.0;\n                    I(  42.713,  30.459,  41.428,    62.886,  37.383,  34.118,    49.208,  41.972,  39.966);\n                    I(  55.136,  21.712,  33.819,    64.278,  17.090,  29.077,    62.886,  37.383,  34.118);\n                    I(  55.260,  14.605,  29.121,    46.470,   5.312,  32.180,    67.266,   5.336,  25.762);\n                    I(  55.136,  21.712,  33.819,    55.260,  14.605,  29.121,    64.278,  17.090,  29.077);\n                    I(  62.886,  37.383,  34.118,    42.713,  30.459,  41.428,    55.136,  21.712,  33.819);\n                    I(  55.152,  50.349,  35.401,    62.886,  37.383,  34.118,    71.848,  51.513,  25.795);\n                    I(  55.152,  50.349,  35.401,    49.208,  41.972,  39.966,    62.886,  37.383,  34.118);\n                    I(  55.260,  14.605,  29.121,    67.266,   5.336,  25.762,    64.278,  17.090,  29.077);\n                    if(B(  31.181,   5.312,  29.121,    55.260,  50.349,  41.428))\n                    {\n                        numNodesVisited += 1.0;\n                        I(  31.181,  27.114,  41.307,    46.751,  10.309,  33.683,    42.713,  30.459,  41.428);\n                        I(  39.498,  46.218,  40.304,    31.181,  27.114,  41.307,    42.713,  30.459,  41.428);\n                        I(  46.751,  10.309,  33.683,    55.136,  21.712,  33.819,    42.713,  30.459,  41.428);\n                        if(B(  31.181,   5.312,  29.121,    55.260,  27.114,  41.307))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  46.751,  10.309,  33.683,    55.260,  14.605,  29.121,    55.136,  21.712,  33.819);\n                            I(  46.470,   5.312,  32.180,    46.751,  10.309,  33.683,    31.453,  15.389,  34.744);\n                            I(  31.181,  27.114,  41.307,    31.453,  15.389,  34.744,    46.751,  10.309,  33.683);\n                            I(  46.751,  10.309,  33.683,    46.470,   5.312,  32.180,    55.260,  14.605,  29.121);\n                        }\n                        if(B(  39.498,  30.459,  35.401,    55.152,  50.349,  41.428))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  39.498,  46.218,  40.304,    42.713,  30.459,  41.428,    49.208,  41.972,  39.966);\n                            I(  55.152,  50.349,  35.401,    39.498,  46.218,  40.304,    49.208,  41.972,  39.966);\n                        }\n                    }\n                    if(B(  62.886,   5.281,   9.293,    84.233,  51.513,  34.118))\n                    {\n                        numNodesVisited += 1.0;\n                        I(  82.997,  31.685,   9.758,    82.012,  25.699,  22.449,    84.233,  23.274,  10.809);\n                        I(  77.160,  40.036,  20.248,    64.278,  17.090,  29.077,    75.235,  30.358,  20.462);\n                        I(  75.235,  30.358,  20.462,    82.012,  25.699,  22.449,    82.997,  31.685,   9.758);\n                        I(  67.266,   5.336,  25.762,    82.012,  25.699,  22.449,    75.235,  30.358,  20.462);\n                        I(  67.266,   5.336,  25.762,    75.235,  30.358,  20.462,    64.278,  17.090,  29.077);\n                        I(  77.160,  40.036,  20.248,    62.886,  37.383,  34.118,    64.278,  17.090,  29.077);\n                        if(B(  67.266,   5.281,  10.809,    84.233,  25.699,  25.762))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  74.378,   5.281,  16.983,    82.012,  25.699,  22.449,    67.266,   5.336,  25.762);\n                            I(  82.012,  25.699,  22.449,    74.378,   5.281,  16.983,    84.233,  23.274,  10.809);\n                        }\n                        if(B(  62.886,  30.358,   9.293,    82.997,  51.513,  34.118))\n                        {\n                            numNodesVisited += 1.0;\n                            I(  71.848,  51.513,  25.795,    62.886,  37.383,  34.118,    77.160,  40.036,  20.248);\n                            I(  75.235,  30.358,  20.462,    82.997,  31.685,   9.758,    77.444,  31.786,   9.293);\n                            I(  77.160,  40.036,  20.248,    75.235,  30.358,  20.462,    77.444,  31.786,   9.293);\n                        }\n                    }\n                }\n            }\n            if(B(  31.117,  60.189, -30.643,    67.757, 112.434,  31.091))\n            {\n                numNodesVisited += 1.0;\n                I(  48.752,  75.249,  10.750,    63.770,  69.473,   6.074,    50.796,  72.233,  -1.508);\n                I(  50.796,  72.233,  -1.508,    63.770,  69.473,   6.074,    59.223,  63.991, -11.887);\n                if(B(  31.117,  63.727, -30.643,    59.223, 112.434,  -1.508))\n                {\n                    numNodesVisited += 1.0;\n                    I(  38.196, 110.779, -23.468,    36.363,  93.381, -19.850,    35.363, 105.769, -30.643);\n                    I(  31.117, 112.434, -26.499,    38.196, 110.779, -23.468,    35.363, 105.769, -30.643);\n                    I(  50.796,  72.233,  -1.508,    59.223,  63.991, -11.887,    43.605,  63.727, -11.608);\n                    I(  38.196, 110.779, -23.468,    35.530,  95.245, -14.819,    36.363,  93.381, -19.850);\n                }\n                if(B(  42.551,  60.189,   6.074,    67.757,  75.249,  31.091))\n                {\n                    numNodesVisited += 1.0;\n                    I(  42.551,  64.352,  31.091,    62.428,  60.189,  28.382,    47.881,  72.038,  23.292);\n                    I(  67.757,  64.533,  19.785,    48.752,  75.249,  10.750,    47.881,  72.038,  23.292);\n                    I(  48.752,  75.249,  10.750,    67.757,  64.533,  19.785,    63.770,  69.473,   6.074);\n                    I(  62.428,  60.189,  28.382,    67.757,  64.533,  19.785,    47.881,  72.038,  23.292);\n                }\n            }\n        }\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.25+1.0;\n    \n    vec3 viewDir = normalize(vec3((fragCoord.xy - iResolution.xy*0.5) / iResolution.y, 1.0));\n    \n    vec3 camUp = vec3(0,1,0);\n    vec3 camTarget = vec3(30,50,9);\n    vec3 camPos = camTarget + vec3(cos(time)*150.0,50.0,sin(time)*150.0);\n    \n    vec3 forward = normalize(camTarget - camPos);\n    vec3 left = normalize(cross(forward, camUp));\n    vec3 up = cross(left, forward);\n\n    mat3 viewToWorld = mat3(left, up, forward);\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec3 worldNormal;\n    float t = intersectMesh(camPos, worldDir, worldNormal);\n\n    vec3 color = vec3(.45,.5,.55) + vec3(.3,.4,.5)*worldDir.y;\n    if(t < MAX_DIST)\n    {\n        const vec3 lightDir = normalize(vec3(1,.9,.3));\n        color = max(.1 + .9*dot(worldNormal,lightDir),0.)*vec3(1.1,.85,.6);\n        color += (.5 + .5*worldNormal.y)*vec3(.1,.2,.4)*.375;\n        color += max(.4 + .6*dot(worldNormal,lightDir*vec3(-1,1,-1)),0.)*0.0875;\n        color += vec3(.03);  \n        color *= .8;\n    }\n\n#if SHOW_HIERARCHY && USE_HIERARCHY\n    color += numNodesVisited*.02;\n#endif\n    \n    fragColor = vec4(pow(color,vec3(.4545)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[923, 923, 992, 992, 1308], [3145, 3145, 3206, 3206, 42729], [42732, 42732, 42789, 42789, 43950]], "test": "valid"}
{"id": "XlVXRw", "name": "glitch art", "author": "bpt", "description": "started with [url]https://www.shadertoy.com/view/MlyXzw[/url] ended up with some odd glitch art that I find somehow interesting.  This code is slop with no plan only poking at numbers and transforms until something interesting happened.", "tags": ["glitch"], "likes": 2, "viewed": 155, "published": "Public", "date": "1483589427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define mouse iMouse.xy\n#define resolution iResolution.xy\n#define time ((iTime+(sin(iTime*0.02)*0.5+0.5))*0.075)\n\n#define PI 3.14159265359\n\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nfloat box( vec2 st, vec2 size) {\n    st = smoothstep( size,size - 4.0 / resolution.y, abs(st));\n    return st.x * st.y;\n}\n\nfloat shape( vec2 st, float size) {\n    return  box(st, size * vec2(1.0,1.0 / 4.0)) + box(st, size * vec2(1.0 / 4.0,1.0));\n}\n\nvec2 pow_xy( vec2 a, vec2 b ) {\n\treturn vec2( pow( abs(a.x), b.x ), pow( abs(a.y), b.y ) );\n}\n\nvoid genImage( out vec4 fragColor, vec2 uv, float t )\n{\n    uv *= rotate2d(cos(t*t) * PI);\n    \n    uv = mix( uv * .25, 1.-uv*0.5+cos(t*1.2), sin(t*10.1)*0.5+0.5 );\n    \n    float duv = dot(uv,uv);\n    \n    uv = fract(uv/(duv*(3.0+1.5*sin(time*2.1))))*2.0-1.0;\n\n    uv *= rotate2d(sin(t+fract(time*0.25)*2.0*PI+sin(time*20.1)) * PI);\n    \n    duv = dot(uv,uv);\n\t\n    uv = mix( uv, uv * duv * duv, cos(t*11.1+1.2) * 0.5 + 0.5 );\n\t\n    uv = mix( uv, pow_xy( uv, vec2(duv*.5) ), cos(time)*sin(time*1.5*sin(time*0.1)) * 0.5 + 0.5 );\n\n    fragColor = vec4(shape(uv,max(0.51,3.24*duv)*abs(sin(t*10.1-sin(13.*duv*mix(duv,1.-duv,cos(t*0.1+mod(time,t))*0.5+0.5))))));\n}\n\n\nfloat dot2( vec2 v )\n{\n\treturn dot(v,v);\n}\n\nvoid draw( out vec4 fragColor, vec2 surfacePosition )\n{\n   float t = 3100.0 + time * .000053;\n   float spin = 221.0+cos(t*2.0+time*0.01)*1900.0;\n\t\n   vec4 a, b;\n\t\n   genImage( a, surfacePosition.xy * log(1000.0+500.0*cos(t)), spin*abs(sin( t * 0.2 + time*0.0001 )) + spin*cos(t*0.02) + 1.20 );\t\n\t\n   genImage( b, resolution*surfacePosition.xy * log(1000.0+500.0*cos(t*12.3)), spin*abs(sin( t * 11.2 + time*0.00001 )) + spin*cos(t*10.02) );\n\t\n   fragColor = mix( a, b, sin(time*20.5+32.0*cos(t*1.5))*0.5+0.5 );\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n\n    draw( fragColor, uv );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 169, 169, 234], [236, 236, 268, 268, 357], [359, 359, 394, 394, 483], [485, 485, 516, 516, 578], [580, 580, 635, 635, 1240], [1243, 1243, 1265, 1265, 1285], [1287, 1287, 1342, 1342, 1800], [1802, 1802, 1859, 1859, 1943]], "test": "valid"}
{"id": "XlySDW", "name": "Sea distances", "author": "GinCastaway", "description": "IsartDigital Sea", "tags": ["sea"], "likes": 1, "viewed": 121, "published": "Public", "date": "1484295538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool inSea(in vec2 coords, float distWave) {\n    float pi2 = 3.14 * 2.0;\n    \n    float ampli = 0.06 / distWave;\n    float ratioSpeed = 2.0;\n    float waves = 2.0 * (distWave * 0.8);\n    //float waves = 1.0/iTime; ==> Effet de noiret\n    \n    float eyeDistScreen = 1.0;\n    float eyeHeightScreen = 0.45;\n    //float heightBonus = iMouse.y / 100.0;\n    \n    float fullDist = eyeDistScreen + distWave;\n    float height = ((distWave * (eyeHeightScreen /*+ heightBonus*/)) / fullDist) /*- heightBonus*/;\n    \n    \n    float wave = ampli * cos((iTime * ratioSpeed) + coords.x * waves * pi2) + height;\n   \n    return (coords.y < wave);\n}\n\nbool inSun(in vec2 coords, float radius) {\n    vec2 center = vec2(3.0 * iResolution.x / 4.0, 3.0 * iResolution.y / 4.0);\n    \n    float radiusSun = cos(iTime) * 2.0 + (iResolution.y * radius) / 100.0;\n    float distSun = sqrt(pow(coords.x - center.x, 2.0) + pow(coords.y - center.y, 2.0));\n    \n    return distSun < radiusSun;\n}\n\n/*\nbool inBoat(in vec2 coords) {\n    \n    \n}\n*/\n\nvoid mainImage(out vec4 color, in vec2 pixCoords) {\n    pixCoords.y += iResolution.y/2.0 * cos((iTime * 0.3) * 1.0 * (2.0 * 3.14)) * 0.10;\n    //pixCoords.x += iResolution.x/4.0 * cos(iTime);\n    \n    vec2 i = vec2(cos(iTime), sin(iTime));\n    vec2 j = vec2(-sin(iTime), cos(iTime));\n        \n    //pixCoords.x = (pixCoords.x * i.x + pixCoords.y * i.y);\n    //pixCoords.y = (pixCoords.y * j.x + pixCoords.y * j.y);\n    \n    // Texture2D(iChannel0, pixCoords.xy/iResolution.xy);\n    \n\tvec2 coords = pixCoords.xy / iResolution.xy;\n    \n    float colorSea = 0.50;\n    \n    vec4 skyColor = vec4(0.9, pixCoords.y / iResolution.y, 0.0, 1.0);\n    vec4 waveColor =  vec4(0.1, 0.1, colorSea, 1.0);\n    \n    /* == Background == */\n    color = skyColor;\n    \n    /* == Sun == */\n    if ( inSun(pixCoords, 15.0) ) { color = vec4(1.0, 1.0, 0.0, 1.0); }\n    //if ( inSun(pixCoords, 15.0) ) { color = texture(iChannel0, pixCoords.xy/iResolution.xy); }\n    \n    /* == Waves == */\n    float k;\n    \n    for (float i = 1.0; i <= 20.0; ++i) {\n        k = 1.0 / i;\n        \n        if ( inSea(coords, i) ) {\n            color = ((1.0 - k) * skyColor) + (k * waveColor);\n            return;\n        }\n    }\n    \n    /* == Boat == */\n    //if ( inBoat(pixCoords) ) { color = vec4(0.0, 0.0, 0.0, 1.0); }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlySDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 631], [633, 633, 675, 675, 961], [1012, 1012, 1063, 1063, 2294]], "test": "valid"}
{"id": "XlySRV", "name": "Poetic Sunset", "author": "ramours", "description": "Simple sunset inspired by the work of Baku Hashimoto and Patricio Gonzalez Vivo.", "tags": ["procedural", "sunset", "fbm"], "likes": 5, "viewed": 216, "published": "Public", "date": "1484902707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 colorA = vec3(0.39, 0.26, 0.31);\nvec3 colorB = vec3(0.71,0.733,0.82);\nvec3 colorC = vec3(0.19, 0.06, 0.11);\nvec3 colorD = vec3(0.71,0.733,0.82);\nvec3 sunColorA = vec3(0.97,0.,0.);\nvec3 sunColorB = vec3(0.97,0.92,0.3);\n\n// makes a pseudorandom number between 0 and 1\nfloat hash(float n) {\n  return fract(sin(n)*93942.234);\n}\n\nvec4 noise(in vec2 uv)\n{\n\tvec2 r=(456.789*sin(789.123*uv.xy));\n\treturn vec4(fract(r.x*r.y));\n}\n\n// smoothsteps a grid of random numbers at the integers\nfloat noise2(vec2 p) {\n  vec2 w = floor(p);\n  vec2 k = fract(p);\n  k = k*k*(3.-2.*k); // smooth it\n  \n  float n = w.x + w.y*57.;\n  \n  float a = hash(n);\n  float b = hash(n+1.);\n  float c = hash(n+57.);\n  float d = hash(n+58.);\n  \n  return mix(\n    mix(a, b, k.x),\n    mix(c, d, k.x),\n    k.y);\n}\n\n// rotation matrix\nmat2 m = mat2(0.6,0.8,-0.8,0.6);\n\n// fractional brownian motion (i.e. photoshop clouds)\nfloat fbm(vec2 p) {\n  float f = 0.;\n  f += 0.5000*noise2(p); p *= 2.02*m;\n  f += 0.2500*noise2(p); p *= 2.01*m;\n  f += 0.1250*noise2(p); p *= 2.03*m;\n  f += 0.0625*noise2(p);\n  f /= 0.9375;\n  return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime*.2;\n    vec3 color = vec3(0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 center = vec2(0.5*ratio, (sin(time)+1.)*.4);\n    float dist = distance(uv, center);\n    float initialRadius = .12;\n    \n    // Pick the sky's gradient\n    vec3 t = vec3(cos(uv.y)*cos(uv.y),\n                  sin(uv.y),\n                  sin(uv.y));\n    color = mix(colorA, colorB, t);\n    color = mix(color, colorC, 1.-center.y);\n    \n  \t//color.r *= 1.1;\n    \n    // add \"atmospheric halo\"\"\n    color = mix(color, colorD, smoothstep(uv.y+0.4, uv.y+0.8, center.y));\n    \n    float radius;\n    \n    // add water reflection\n    if (uv.y > .0 && uv.y < .2)\n    {\n        radius = initialRadius+0.02+fbm(uv*40000.)*0.2;\n    }\n    // add the sun color & distortion\n    else\n    {\n    \tradius = initialRadius+fbm(uv*4000.)*0.02;\n    }\n    \n    float p = 1.-step(radius, dist);\n    color += mix(sunColorA, sunColorB, center.y-.1)*p*5.5;\n\n    // add lighting \"auras\" around the sun\n    radius = initialRadius*3.+fbm(uv*center*sin(iTime*.3));\n    p = 1.-smoothstep(radius, radius+0.4, dist);;\n    color += p*0.08*sunColorA;\n\n    radius = initialRadius*1.+fbm(uv*center*2.*abs(sin(iTime*.6)))*0.12;\n    p = 1.-smoothstep(radius, radius+0.4, dist);;\n    color += p*0.12*sunColorB;\n    \n    color *= 1.4;\n\n    // Body of water\n    radius = 0.15+noise(uv).y*0.02;\n    p = 1.-smoothstep(radius, radius+0.1, uv.y);\n    color = mix(color, colorC, vec3(p*1.1*max(.2, (1.-smoothstep(.1, .9, center.y)))));\n    color *= smoothstep(-0.1, .22, uv.y);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlySRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 297, 318, 318, 354], [356, 356, 380, 380, 450], [452, 508, 530, 530, 803], [858, 912, 931, 931, 1115], [1117, 1117, 1172, 1172, 2822]], "test": "valid"}
{"id": "XlySW1", "name": "heroes of the storm", "author": "geniikw", "description": "welcome to heros of the storm.\nwe are restaurance.", "tags": ["hexagon"], "likes": 2, "viewed": 202, "published": "Public", "date": "1484058188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/XsB3Dz\n\n/**/\nfloat hexf(vec2 p)\n{\n\tvec2 V = vec2(.866,.5);\n    vec2 v = abs ( p * mat2( V, -V.y, V.x) );\t\n\n\treturn ceil( 1. - max(v.y, dot( v, V)) *1.1  );\n}\n/**/\n\n/**FabriceNeyret2\nvoid mainImage( out vec4 O,  vec2 p )\n{\n\tp = ( 2.*p - (O.xy=iResolution.xy) ) / O.y;\n\n\tvec2 V = vec2(.866,.5);\n    vec2 v = abs ( p * mat2( V, -V.y, V.x) );\t\n    float a = atan(p.x,p.y)/6.28 - iTime/10.,\n          l = length(p), r, \n          h = .5 * ceil( 1. - max(v.y, dot( v, V)) *1.65  );\n       // h = .5 * hexf( p*1.5);\n        \n    a = 1.3 * mod(a , .33);\n    r = l*l *a * 5.;\n\n     O =  r > .25 && r <  1.3 * a  \n         ? vec4(a ,r, .8 , 1)\n         : mix( vec4(.2, .2, .3-.07*p.y, 0) * (1.-.55*l) * .4,\t\n\t            vec4(0, 0, h ,0), \n\t             abs(h));\n}\n/**/\n\n/**/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n \t vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n \t float tau = 3.1415926535*2.0;\n     float a = atan(p.x,p.y)/tau - iTime/10.;\n     float r = length(p)*0.75;\n        \n     a = mod(a , .333);\n     a *= 1.3;\n     \n     r *= r*a*9.;\n    \n     vec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.y;\n \t uv.x -= 0.77;\n\n     vec3 bcol = vec3(0.2,0.2,0.3-0.07*uv.y)*(1.0-0.55*length(uv)) * 0.4;\t\t\n     vec3 hex = vec3(0.,0.,0.5*hexf(uv*1.5));\t \n     vec3 col = mix(bcol, hex, (length(hex)));\n\n     if(r > 0.25 && r <1.3 * a){\n     \tfragColor = vec4(a ,r, 0.8 , 1.0);\n     }\n     else{\n     \tfragColor = vec4(col,1.0);\n    }\n }\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlySW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 46, 66, 66, 190], [794, 799, 855, 855, 1486]], "test": "valid"}
{"id": "XlySWz", "name": "Twisted Box Intersecting Sphere", "author": "sea", "description": "Experiement", "tags": ["raymarching", "sphere", "intersection", "box", "twisting"], "likes": 4, "viewed": 191, "published": "Public", "date": "1483743155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 spin (vec3 p, float r)\n{\n    r *= 3.1415926 / 180.0;\n    float x = p.x * cos(r) - p.z * sin(r);\n    float z = p.x * sin(r) + p.z * cos(r);\n    return vec3(x, p.y, z);\n}\n\nfloat sphere (vec3 p, float r)\n{\n    return (p.x * p.x + p.y * p.y + p.z * p.z) * r;\n}\n\nfloat box (vec3 p)\n{\n    p = spin(p, p.y * 360.0 * iTime * 0.1);\n    // p.xz += p.y + 0.5;\n    return length(max((abs(p) * 4.0) - 2.0, 0.0));\n}\n\nfloat ren (vec3 p)\n{\n    float b = box(p);\n    float s = sphere(p, 1.25);\n    return s > 1.0 ? b < 1.0 ? 0.0 : 1.0 : 1.0;\n}\n\nvec3 normal (vec3 p)\n{\n    return normalize(vec3(\n        ren(vec3(p.x - 0.1, p.y, p.z)) - ren(vec3(p.x + 0.1, p.y, p.z)),\n        ren(vec3(p.x, p.y - 0.1, p.z)) - ren(vec3(p.x, p.y + 0.1, p.z)),\n        ren(vec3(p.x, p.y, p.z - 0.1)) - ren(vec3(p.x, p.y, p.z + 0.1))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ws = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    ws.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.5);\n    vec3 rd = normalize(vec3(ws * 1.0, 1.0));\n    \n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0, 0.0, 0.0);\n    for (float i = 0.0; i < 2.8; i += 0.01)\n    {\n        vec3 p = ro + rd * i;\n        p = spin(p, iTime * 200.0);\n        if (ren(p) < 1.0)\n        {\n            color = vec3(dot(normalize(p - light), normal(p)));\n            break;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlySWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 173], [175, 175, 207, 207, 261], [263, 263, 283, 283, 406], [408, 408, 428, 428, 531], [533, 533, 555, 555, 805], [807, 807, 864, 864, 1406]], "test": "valid"}
{"id": "XlyXDK", "name": "Carpenter Brut", "author": "WuTangTan", "description": "Carpenter Brut's logo", "tags": ["2d", "music", "outrun"], "likes": 8, "viewed": 1025, "published": "Public API", "date": "1485873382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define LINE_THICKNESS 0.0015\n#define LINE_SHINE 0.0016\n\n#define POINT_SCALE 625.0\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nfloat colorStrength(float dist){\n \t   return 1.0 - smoothstep(LINE_THICKNESS - LINE_SHINE,\n                            LINE_THICKNESS + LINE_SHINE,\n                            dist);\n}\n\nvec2 rotate(vec2 pos, float rad){\n    mat2 rot = mat2(vec2(cos(rad), -sin(rad)), vec2(sin(rad), cos(rad)));\n    pos -= 0.5;\n    pos *= rot;\n    pos += 0.5;\n    return pos;\n}\n\nfloat segment(vec2 diff, vec2 dir, vec2 dim) {\n    float projDist \t= dot(diff, dir);\n\tfloat dist = 0.0;\n\n    dist += length(diff - dir * dim.x) * step(dim.x, projDist);\n    dist += length(diff) * (1.0 - step(0.0, projDist));\n    dist += length(diff - dir * projDist) * (step(0.0, projDist) - step(dim.x, projDist));\n    return dist - dim.y;\n}\n\nfloat line(vec2 st, float x1, float y1, float x2, float y2) {\n    vec2 lineStart = vec2(x1 / POINT_SCALE, y1 / POINT_SCALE);\n    vec2 lineEnd = vec2(x2 / POINT_SCALE, y2 / POINT_SCALE);\n    vec2 seg = lineEnd - lineStart;\n\treturn colorStrength(segment(st - lineStart, normalize(seg), vec2(length(seg), LINE_THICKNESS)));\n}\n\nfloat logoPart(vec2 st) {\n    float d = 0.0\n        + line(st, 313.0,015.0, 168.5,119.5) \n        + line(st, 168.5,119.5, 127.5,244.0)\n        + line(st, 127.5,244.0, 168.5,215.5)\n        + line(st, 168.5,215.5, 188.0,150.5)\n        + line(st, 188.0,150.5, 312.5,061.0)\n        + line(st, 312.5,061.0, 382.5,109.0)\n        + line(st, 382.5,109.0, 444.5,109.0)\n        + line(st, 444.5,109.0, 313.0,015.0)\n        \n        + line(st, 244.5,120.0, 205.5,148.5)\n        + line(st, 205.5,148.5, 312.0,149.5)\n        + line(st, 312.0,149.5, 358.5,177.0)\n        + line(st, 358.5,177.0, 392.5,177.0)\n        + line(st, 392.5,177.0, 312.5,120.5)\n        + line(st, 312.5,120.5, 244.5,120.0)\n        \n        + line(st, 301.5,157.5, 261.0,156.5)\n        + line(st, 261.0,156.5, 217.5,190.0)\n        + line(st, 217.5,190.0, 190.5,271.5)\n        + line(st, 190.5,271.5, 217.0,252.5)\n        + line(st, 217.0,252.5, 231.5,208.0)\n        + line(st, 231.5,208.0, 301.5,157.5)\n        \n        + line(st, 312.5,190.0, 267.5,189.0)\n        + line(st, 267.5,189.0, 242.5,207.5)\n        + line(st, 242.5,207.5, 313.0,208.5)\n        + line(st, 313.0,208.5, 401.5,279.0)\n        + line(st, 401.5,279.0, 393.5,254.5)\n        + line(st, 393.5,254.5, 312.5,190.0);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    st.y = st.y * -1. + 1.;\n\tst.x -= 0.25;\n    st.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = vec3(0.);    \n    vec3 pink = vec3(247, 129, 226) / 255.;\n    \n    float d = 0.0;\n    float rotation = TWO_PI / 5.0;\n    vec2 uv = st;\n\td += logoPart(uv);\n\tuv = rotate(uv, rotation);\n\td += logoPart(uv);\n\tuv = rotate(uv, rotation);\n\td += logoPart(uv);\n\tuv = rotate(uv, rotation);\n\td += logoPart(uv);\n\tuv = rotate(uv, rotation);\n\td += logoPart(uv);\n    color = min(d, 1.0) * pink;\n    \n    float noiseValue = 0.0;\n    uv = st * 5.0;\n    uv += vec2(0.2, 1.0) * iTime;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    noiseValue  = 0.5000*noise( uv ); uv = m*uv;\n    noiseValue += 0.2500*noise( uv ); uv = m*uv;\n    noiseValue += 0.1250*noise( uv ); uv = m*uv;\n    noiseValue += 0.0625*noise( uv ); uv = m*uv;\n    color -= (1.0-noiseValue)*0.5;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "lsB3zt", "previewfilepath": "https://soundcloud.com/carpenter_brut/roller-mobster?in=carpenter_brut/sets/carpenter-brut-ep-ii-black-bvs", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/carpenter_brut/roller-mobster?in=carpenter_brut/sets/carpenter-brut-ep-ii-black-bvs", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyXDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 196, 196, 317], [319, 319, 345, 345, 800], [802, 802, 834, 834, 986], [988, 988, 1021, 1021, 1161], [1163, 1163, 1209, 1209, 1505], [1507, 1507, 1568, 1568, 1829], [1831, 1831, 1856, 1856, 3089], [3091, 3091, 3148, 3148, 4076]], "test": "valid"}
{"id": "Xtd3D7", "name": "Dancing shape factory", "author": "mlkn", "description": "Dancing shape factory!\nPlay with xMult, yMult and r to get different result.", "tags": ["2d", "animation", "loop", "distancefunctions", "morph"], "likes": 3, "viewed": 464, "published": "Public API", "date": "1484520092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265\n#define loopTime 3.5\n\nfloat xMult = 4.5;\nfloat yMult = 6.;\nfloat r = 0.04;\n\n// https://www.shadertoy.com/view/MstGRr\nfloat getBoxDist(vec2 p, vec2 size, float radius) {\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nvec2 rotateAroundPoint(vec2 p, vec2 c, float angle) {\n\tvec2 t = p - c;\n    vec2 rot = vec2(\n        cos(angle) * t.x - sin(angle) * t.y,\n        sin(angle) * t.x + cos(angle) * t.y\n    );\n\treturn c + rot;\n}\n\nvec2 squishAroundPoint(vec2 p, vec2 c, float squish) {\n\treturn (p - c) * vec2(1. / squish, squish) + c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    p.x *= aspectRatio;\n    vec2 center = vec2(0.5 * aspectRatio, 0.5);\n \n    float t = mod(iTime, loopTime) / loopTime;\n    float loopN = mod(iTime / loopTime + 2., 4.);\n\n    if (t > 0.8) { // zoom in\n        p = (p - center)*(1. - (t - 0.8) * 2.5) + center + vec2((t - 0.8) * 1.67, 0.0);\n    }\n\n    vec2 gridPoint = vec2(floor(p.x * xMult + 0.5)/xMult, floor(p.y * yMult + 0.5)/yMult);\n    \n    float morph = 0., squish = 1., angle = 0.;\n    \n    float xEven = mod(p.x * xMult + 0.5, 2.) > 1. ? 1. : 0.;\n    float yEven = mod(p.y * yMult + 0.5, 2.) > 1. ? 1. : 0.;\n \n    if (xEven * yEven > 0.5) { // main points\n        if (t < 0.1) {\n            squish = 1. + 0.4 * sin(t * M_PI * 10.);\n            morph = 1.;\n        } else if (t < 0.3) {\n            squish = 1. + 0.4 * sin((t - 0.1) * M_PI * 5. / 2.);\n            morph = 1. - sin((t - 0.1) * M_PI * 5. / 2.);\n        } else if (t < 0.4) {\n            squish = 1.4 - 0.6 * sin((t - 0.3) * M_PI * 5.);\n        } else if (t < 0.5) {\n            squish = 0.8 + 0.2 * sin((t - 0.4) * M_PI * 5.);\n        } else if (t < 0.56) {\n            angle = (0.56 - t) * 2.0;\n        } else if (t < 0.7) {\n            angle = mix(0., M_PI / 4., (t - 0.56) / 0.14);\n            r = mix(r, r * 0.7, (t - 0.56) / 0.14);\n        } else if (t < 0.8) {\n            r = mix(r * 0.7, r * 1.3, (t - 0.7) * 10.);\n            angle = M_PI / 4.;\n        } else if (t < 0.9) {\n            r = mix(r * 1.3, r * 0.75, (t - 0.8) * 10.);\n            angle = mix(M_PI / 4., 2.*M_PI + 3.*M_PI / 2., (t-0.8) * 10.);\n            morph = (t - 0.8) * 10.;\n        } else {\n            r = mix(r * 0.75, r * 0.5, (t - 0.9) * 10.);\n            angle = 2.*M_PI + 3.*M_PI / 2.;\n            morph = 1.;\n        }\n    } else { // hor - vert - diag\n        float tStart = yEven > 0.5 ? 0.2 :\n        \txEven > 0.5 ? 0.35 : 0.75;\n        morph = 1.;\n\n        if (t < tStart) r = 0.0;\n        else if (t < tStart + 0.05) r *= (t - tStart) * 6.;\n        else if (t < 0.9) r *= 0.3;\n        else r *= mix(0.3, 0.9, (t - 0.9) * 2.);\n    }\n      \n    p = squishAroundPoint(p, gridPoint, squish);\n    p = rotateAroundPoint(p, gridPoint, angle);\n        \n    float bDist = getBoxDist(p - gridPoint, vec2(r), 0.0);\n    float cDist = length(p - gridPoint) - r;\n    float d = mix(bDist, cDist, morph);\n    \n    float loopFillerMix = clamp((abs(loopN - 1.0 - 2.) - 0.9) * 10., 0., 1.); // [0, 1]\n    float edge = smoothstep(r / 6., r / 4., d);\n    float innerEdge = smoothstep(r / 160., r / 16., d + loopFillerMix * 0.1);\n    \n\tfragColor = vec4(mix(vec3(0), vec3(1), max(edge, (1. - innerEdge))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtd3D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 141, 192, 192, 308], [310, 310, 363, 363, 516], [518, 518, 572, 572, 623], [625, 625, 680, 680, 3381]], "test": "valid"}
{"id": "XtGSDR", "name": "Line Drawing", "author": "gigatron", "description": "Try to drawing magician x with vector;", "tags": ["line", "draw", "vector"], "likes": 4, "viewed": 173, "published": "Public", "date": "1483719801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\n#define lf 10.0 // bold fct\n\nvec4 l( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    vec4 c = vec4(0.9,0.95,0.9,1.0);\n    \n    \n    return smoothstep(lf/iResolution.y, 0., d ) * c;\n}\n \n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 RotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Triangle\n{\n    vec3 a; vec2 aUV;\n    vec3 b; vec2 bUV;\n    vec3 c; vec2 cUV;\n    vec3 n;\n};\n\n\nTriangle triangles[4];\n\nvoid createCube( void )\n{\n    vec3 verts[8];\n\n    verts[0] = vec3( -1.0, -1.0, -0.0 );\n    verts[1] = vec3( -1.0, -1.0,  0.0 );\n    verts[2] = vec3( -1.0,  1.0, -0.0 );\n    verts[3] = vec3( -1.0,  1.0,  0.0 );\n    verts[4] = vec3(  1.0, -1.0, -0.0 );\n    verts[5] = vec3(  1.0, -1.0,  0.0 );\n    verts[6] = vec3(  1.0,  1.0, -0.0 );\n    verts[7] = vec3(  1.0,  1.0,  0.0 );\n\n    triangles[0].a = verts[1]; triangles[0].aUV = vec2(0.0,0.0);\n    triangles[0].b = verts[5]; triangles[0].bUV = vec2(1.0,0.0);\n    triangles[0].c = verts[7]; triangles[0].cUV = vec2(1.0,1.0);\n    triangles[0].n = vec3( 0.0, 0.0, 0.0 );\n    triangles[1].a = verts[1]; triangles[1].aUV = vec2(0.0,0.0),\n    triangles[1].b = verts[7]; triangles[1].bUV = vec2(1.0,1.0),\n    triangles[1].c = verts[3]; triangles[1].cUV = vec2(0.0,1.0),\n    triangles[1].n = vec3( 0.0, 0.0, 0.0 );\n\n    triangles[2].a = verts[5]; triangles[2].aUV = vec2(0.0,0.0);\n    triangles[2].b = verts[4]; triangles[2].bUV = vec2(1.0,0.0);\n    triangles[2].c = verts[6]; triangles[2].cUV = vec2(1.0,1.0);\n    triangles[2].n = vec3( 0.0, 0.0, 0.0 );\n    triangles[3].a = verts[5]; triangles[3].aUV = vec2(0.0,0.0);\n    triangles[3].b = verts[6]; triangles[3].bUV = vec2(1.0,1.0);\n    triangles[3].c = verts[7]; triangles[3].cUV = vec2(0.0,1.0);\n    triangles[3].n = vec3( 0.0, 0.0, 0.0 );\n\n     \n}\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 pixelShader( in vec3 nor, in vec2 p, in float z, in vec3 wnor )\n{\n    vec4 cl = vec4(0);\n    p *= 2.0;\n    p.y = p.y-0.5;\n    // set vector points over own texture ;\n    cl += l(p-vec2(-.56,0.61),vec2(0.0,0.0),vec2(.17,-.33));\n    cl += l(p-vec2(-.39,0.28),vec2(0.0,0.0),vec2(.10,-.15));\n    cl += l(p-vec2(-.29,0.13),vec2(0.0,0.0),vec2(.15,-.15));\n    cl += l(p-vec2(-.14,-.02),vec2(0.0,0.0),vec2(.55,-.35));\n    cl += l(p-vec2(0.4,-0.36),vec2(0.0,0.0),vec2(.15,-.08));\n    cl += l(p-vec2(0.55,-0.44),vec2(0.0,0.0),vec2(.35,0.01));\n    cl += l(p-vec2(0.90,-0.43),vec2(0.0,0.0),vec2(.34,.11));\n    cl += l(p-vec2(1.24,-0.32),vec2(0.0,0.0),vec2(.34,.16));\n    cl += l(p-vec2(1.58,-0.16),vec2(0.0,0.0),vec2(.42,.46));\n    \n    cl += l(p-vec2(0.46,-0.13),vec2(0.0,0.0),vec2(.10,0.03));\n    cl += l(p-vec2(0.56,-0.10),vec2(0.0,0.0),vec2(.24,0.02));\n  \n    cl += l(p-vec2(-.55,0.64),vec2(0.0,0.0),vec2(.48,.58));\n    cl += l(p-vec2(-.05,1.22),vec2(0.0,0.0),vec2(.48,-.18));\n    cl += l(p-vec2(0.45,1.03),vec2(0.0,0.0),vec2(.48,-.08));\n    cl += l(p-vec2(0.95,0.95),vec2(0.0,0.0),vec2(.48,-.10));\n    cl += l(p-vec2(1.45,0.85),vec2(0.0,0.0),vec2(.48,-.08));\n    \n    cl += l(p-vec2(0.28,0.10),vec2(0.0,0.0),vec2(.10,0.03));\n    \n    cl += l(p-vec2(0.23,0.24),vec2(0.0,0.0),vec2(.14,-0.00));\n    \n    cl += l(p-vec2(-.04,0.23),vec2(0.0,0.0),vec2(.19,-0.05));\n    cl += l(p-vec2(-.04,0.23),vec2(0.0,0.0),vec2(.07,0.15));\n    cl += l(p-vec2(0.03,0.38),vec2(0.0,0.0),vec2(.03,0.19));\n    \n    cl += l(p-vec2(-.13,0.66),vec2(0.0,0.0),vec2(.19,-0.08));\n    cl += l(p-vec2(-.55,0.62),vec2(0.0,0.0),vec2(.19,0.04));\n    \n    cl += l(p-vec2(-.35,0.66),vec2(0.0,0.0),vec2(.22,-0.00));\n    \n    cl += l(p-vec2(.22,0.76),vec2(0.0,0.0),vec2(.50,0.20));\n    \n    cl += l(p-vec2(.26,-0.01),vec2(0.0,0.0),vec2(.20,0.05));\n    cl += l(p-vec2(.46,0.04),vec2(0.0,0.0),vec2(.20,0.02));\n    cl += l(p-vec2(.66,0.06),vec2(0.0,0.0),vec2(.20,0.01));\n    \n    cl += l(p-vec2(.43,0.76),vec2(0.0,0.0),vec2(.20,0.04));\n    cl += l(p-vec2(.63,0.80),vec2(0.0,0.0),vec2(.22,0.04));\n\n    cl += l(p-vec2(-.38,0.53),vec2(0.0,0.0),vec2(.28,0.09));\n    \n    cl += l(p-vec2(-.10,0.62),vec2(0.0,0.0),vec2(.08,-0.01));\n    cl += l(p-vec2(0.45,0.68),vec2(0.0,0.0),vec2(.03,0.09));\n \n    return vec3(cl.xyz);\n}\n    \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n        \nmat4 mdv = setTranslation( 0.0, 0.0, -2.0 ) * \n\t\t       setRotation( 0.,0. , 0. )*   setRotation( t*0.5,-t*0.8 , 0. )*\n               RotationAxisAngle(vec3(0.0,0.0,0.0), 0.5 );\n \n    vec2 px = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n       \n  //  vec2 uv = fragCoord / iResolution.xy;\n    \n  //  vec3 tx=texture(iChannel0,uv).xyz;\n    \n    createCube();\n\t \n    float scl = mod(fragCoord.y ,2.0);\n    \n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n\n    // clear zbuffer\n    float mindist = -1000000.0;\n\n    \n        // transform to eye space\n        vec3 ep0 = (mdv * vec4(triangles[1].a,1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(triangles[1].b,1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(triangles[1].c,1.0)).xyz;\n        vec3 nor = (mdv * vec4(triangles[1].n,0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0/ep0.z;\n        float w1 = 1.0/ep1.z;\n        float w2 = 1.0/ep2.z;\n\n        vec2 cp0 = 2.0*ep0.xy * -w0;\n        vec2 cp1 = 2.0*ep1.xy * -w1;\n        vec2 cp2 = 2.0*ep2.xy * -w2;\n\n        // fetch vertex attributes, and divide by z\n        vec2 u0 = triangles[1].aUV * w0;\n        vec2 u1 = triangles[1].bUV * w1;\n        vec2 u2 = triangles[1].cUV * w2;\n\n        // calculate areas for subtriangles\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n\t\t\n        // if all positive, point is inside triangle\n        if( all(greaterThan(di,vec3(-10.0))) )\n        {\n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n\n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n            vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n             uv *= z;\n \n\n\t\t\t\t// perform lighting/shading\n\t\t\t\tcolor = pixelShader( nor, uv, z, triangles[1].n );\n\t  \n    }\n\n    fragColor = vec4(color,1.0)*scl;\n     \n}", "image_inputs": [{"id": "Ms2GRV", "previewfilepath": "https://soundcloud.com/qp0-records/physical-presence-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/qp0-records/physical-presence-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 88, 88, 323], [327, 327, 374, 374, 731], [733, 733, 780, 780, 1184], [1186, 1186, 1236, 1236, 1352], [1479, 1479, 1504, 1504, 2819], [2821, 2821, 2854, 2854, 2886], [2888, 2888, 2958, 2958, 5156], [5164, 5164, 5219, 5219, 7229]], "test": "valid"}
{"id": "XtGSzK", "name": "fractal test 3876568", "author": "Jespertheend", "description": "Trying to get into the somewhat more interesting fractals.", "tags": ["fractal", "test"], "likes": 2, "viewed": 675, "published": "Public API", "date": "1484939264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FRACTAL_ITERATIONS 14\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nvec2 map( vec3 p )\n{\n    p += 3.;\n    p = mod(p, 6.);\n    p -= 3.;\n    \n    \n    float rot = iTime*0.1;\n    mat2 m1 = mat2(sin(rot), cos(rot), cos(rot), -sin(rot));\n    float rot2 = iTime*0.085;\n    mat2 m2 = mat2(sin(rot2), cos(rot2), cos(rot2), -sin(rot2));\n    vec3 q = p;\n    float d = 5e10;\n    float s = 1.;\n    int hitIter = 0;\n    for( int i=0; i<FRACTAL_ITERATIONS; i++ )\n    {\n        float sph = length(p) - 1.;\n        //sph = sdBox(p, vec3(0.5));\n        sph /= s;\n        \n        p = abs(p);\n        \n        p += normalize(vec3(-1.,-1.,-1.));\n        float m = 1.6;\n        p *= m;\n        s *= m;\n        p.xy = p.xy*m1;\n        p.yz = p.yz*m2;\n        \n        if(sph < d){\n            d = sph;\n            hitIter = i;\n        }\n   }\n\n   return vec2(d,float(hitIter));\n}\n\n#define AO_SAMPLES 4.\n#define AO_RANGE 50.\n#define saturate(x) clamp(x, 0., 1.)\nfloat calculateAO(vec3 p, vec3 n) {\n\n    float r = 0., w = 1., d;\n\n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n\n    return 1.-saturate(r * AO_RANGE);\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.003, 0);\n    return normalize(vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n\t));\n}\n\nvec2 raymarch(in vec3 ro, in vec3 rd){\n    float t = 0.;\n    for(int i=0; i<100; i++){\n        vec3 p = ro + t * rd;\n        vec2 res = map(p);\n        if(res.x < 0.001*t  || t > 100.){\n            return vec2(t, res.y);\n        }\n        t += res.x;\n    }\n    return vec2(t, 0.);\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = raymarch(ro,rd);\n    float z = res.x;\n    float iters = res.y / float(FRACTAL_ITERATIONS);\n    iters = pow(iters, 0.5);\n    vec3 iterColor = mix(vec3(.3,.5,.9), vec3(.8,.4,.1), iters);\n    vec3 pos = ro + rd * z;\n    vec3 nor = getNormal(pos);\n    vec3 l = normalize(vec3(1.,0.4,0.8));\n    float b = dot(l, nor);\n    vec3 col = vec3(b*0.5+0.5);\n    col = iterColor * col;\n    \n    float ao = calculateAO(pos, nor);\n    col = col * ao;\n    \n    vec3 bgCol = vec3(0.5, 0.1, 0.);\n    float fogAmount = 1. - exp(-z*0.3);\n    col = mix(col, bgCol, clamp(fogAmount, 0., 1.));\n    \n    return col;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float camDist = 3.5;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m -= 0.5;\n    m *= 5.;\n    if(iMouse.x <= 0. && iMouse.y <= 0.){\n        m = vec2(iTime*0.2,-1.);\n    }\n    vec3 camPos = vec3(cos(m.x)*camDist,0.,sin(m.x)*camDist);\n    camPos.y = -m.y;\n    \n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0.), 0.);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(camMat * vec3(uv, 1.5));\n    \n    vec3 col = render(ro, rd);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 58, 58, 89], [91, 91, 122, 122, 213], [215, 215, 235, 235, 1004], [1086, 1086, 1121, 1121, 1342], [1345, 1345, 1369, 1369, 1565], [1567, 1567, 1605, 1605, 1849], [1851, 1851, 1887, 1887, 2495], [2497, 2497, 2561, 2561, 2739], [2741, 2741, 2798, 2798, 3360]], "test": "valid"}
{"id": "XtGXDm", "name": "marble_sphere", "author": "sanctify", "description": "marble", "tags": ["marble"], "likes": 0, "viewed": 167, "published": "Public", "date": "1484559700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 black=vec3(0.,0.,0.);\nconst vec3 white=vec3(0.9,0.9,0.9);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(p.x+p.y+p.z,2.0);\n    return mix(black,white,v);\n}\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(0.35*p);\n    t-=0.25*noise(2.0*p);\n    //t+=0.2*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    // Scale\n    t/=(0.75);\n\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(black,white,t);\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 marble(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence (22.5*p,n);\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    \n    if(t<0.55){\n    \tvec3 black = vec3(0.15,0.15,0.15);\n        return black;\n    }\n    \n    return mix(black,white,t);\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*marble(p,n);//*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\t\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 156, 180, 180, 223], [225, 256, 282, 282, 651], [727, 780, 815, 815, 884], [1030, 1087, 1122, 1122, 1189], [1191, 1232, 1271, 1296, 1448], [1450, 1475, 1509, 1534, 1597], [1599, 1636, 1670, 1695, 1939], [1941, 2011, 2056, 2056, 2098], [2175, 2357, 2435, 2435, 2670], [2747, 2788, 2816, 2816, 2889], [2891, 2937, 2970, 2989, 3445], [3447, 3504, 3542, 3542, 3623], [3700, 3700, 3757, 3757, 4326]], "test": "valid"}
{"id": "XtGXRK", "name": "Camouflage", "author": "cacheflowe", "description": "Built on top of one of my recent shaders: https://www.shadertoy.com/view/MlKXWm", "tags": ["camouflage"], "likes": 15, "viewed": 1082, "published": "Public API", "date": "1485122113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #define BW 1\n\nfloat patternForPos(vec2 uv, float reso, float time) {\n    float timeOsc = sin(time) * 0.15;\t\t\t\t\t\t\t\t// oscillation helper\n    float dist = 0.;\t\t\t\t\t\t\t\t\t\t\t\t// start distance count from 0\n    for(float i=10.; i < 60.; i++) {\t\t\t\t\t\t\t\t// create x control points\n        float rads = timeOsc + i;\t\t\t\t\t\t\t\t\t// get rads for control point\n        vec2 ctrlPoint = vec2(sin(rads), cos(rads));\t\t\t\t// control points in a circle \n        ctrlPoint *= abs(cos(rads)) * 15.;\t\t\t\t\t\t\t// oscillate control point radius - the magic happens w/abs()\n        dist += sin(i + reso * distance(uv, ctrlPoint));\t\t\t// sum up oscillated distance between control points\n    }\n    return dist;\n}\n\nvec2 rotateCoord(vec2 uv, float rads) {\n    uv *= mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n\treturn uv;\n}\n\nvec3 colFromRGB(float r, float g, float b) {\n    return vec3(r, g, b) / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime / 4.;\n    // grab postion and rotate per layer\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    vec2 uv2 = rotateCoord(uv + 1., time + 1.);\n    vec2 uv3 = rotateCoord(uv * 2., time + 2.);\n    vec2 uv4 = rotateCoord(uv + 1.5, time + 3.);\n    // create pattern at different resolutions\n\tfloat col = patternForPos(uv, 4., time);\n\tfloat col2 = patternForPos(uv2, 9., time);\n\tfloat col3 = patternForPos(uv3, 3., time);\n\tfloat col4 = patternForPos(uv3, 2.25, time);\n    // create final pattern\n    vec3 color = vec3(0);\n    #ifdef BW\n    \tfloat colorSum = col + col2 + col3 + col4;\n        color = vec3(sin(colorSum * 2.));\n    #else\n        if(col2 + col + col4 > 2.85) color = colFromRGB(53., 58., 65.);\n        else if(col2 < 0.81) color = colFromRGB(102., 86., 58.);\n        else if(abs(col4 * col3) > 4.5) color = colFromRGB(80., 120., 77.);\n        else color = colFromRGB(199., 188., 125.);\n    #endif\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 71, 71, 679], [681, 681, 720, 720, 795], [797, 797, 841, 841, 876], [878, 878, 935, 935, 1938]], "test": "valid"}
{"id": "XtGXRV", "name": "Dithering with Noise ", "author": "nide", "description": "Based on https://www.shadertoy.com/view/4t2SDh\nAdded dithered and non-dithered gradients with 5 bit quanization", "tags": ["noise", "random", "rnd", "distribution", "trianglenoise"], "likes": 13, "viewed": 253, "published": "Public", "date": "1484903367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modification of https://www.shadertoy.com/view/4ssXRX\n// Added a second way to do triangle noise without doing\n// a second random sample.\n\nconst int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat trunc_( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\n\nfloat n2rand_faster( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = fract(sin(dot(( n + 0.07*t ).xy, vec2(12.9898, 78.233)))* 43758.5453);\n\n    // Convert uniform distribution into triangle-shaped distribution.\n    float orig = nrnd0*2.0-1.0;\n    nrnd0 = orig*inversesqrt(abs(orig));\n    nrnd0 = max(-1.0,nrnd0); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!\n    nrnd0 = nrnd0-sign(orig)+0.5;\n    \n    // Result is range [-0.5,1.5] which is\n    // useful for actual dithering.\n    // convert to [0,1] for histogram.\n    return (nrnd0+0.5) * 0.5;\n}\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\nfloat n4rand_inv( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    float nrnd4 = nrand( n + 0.19*t );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n/*\n//alternate Gaussian,\n//thanks to @self_shadow\nfloat n4rand( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( iTime ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( iTime + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n*/\n/*\n//Mouse Y give you a curve distribution of ^1 to ^8\n//thanks to Trisomie21\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\t\n\tfloat p = 1. / (1. + iMouse.y * 8. / iResolution.y);\n\tnrnd0 -= .5;\n\tnrnd0 *= 2.;\n\tif(nrnd0<0.)\n\t\tnrnd0 = pow(1.+nrnd0, p)*.5;\n\telse\n\t\tnrnd0 = 1.-pow(nrnd0, p)*.5;\n\treturn nrnd0; \n}\n*/\n#define STEPS 32.0\n#define QUANTIZE(x, steps) (floor(x*steps)/steps)\nfloat gradient( vec2 uv, vec2 interval )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n    return t;\n}\n\nfloat distribution( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( trunc_(t,NUM_BUCKETS_F), trunc_(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = n1rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<3 )\n\t\t\tr = n2rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<4 )\n\t\t\tr = n2rand_faster( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<5 )\n\t\t\tr = n3rand( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = n4rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat normalizedNoise;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < 1.0/5.0 )\n\t{\n\t\tnormalizedNoise = n1rand( uv );\n        idx = 1;\n        uvrange = vec2( 0.0/5.0, 1.0/5.0 );\n\t}\n\telse if ( uv.x < 2.0 / 5.0 )\n\t{\n\t\tnormalizedNoise = n2rand( uv );\n        idx = 2;\n        uvrange = vec2( 1.0/5.0, 2.0/5.0 );\n\t}\n\telse if ( uv.x < 3.0 / 5.0 )\n\t{\n\t\tnormalizedNoise = n2rand_faster( uv );\n        idx = 3;\n        uvrange = vec2( 2.0/5.0, 3.0/5.0 );\n\t}\n\telse if ( uv.x < 4.0 / 5.0 )\n\t{\n\t\tnormalizedNoise = n3rand( uv );\n        idx = 4;\n        uvrange = vec2( 3.0/5.0, 4.0/5.0 );\n\t}\n\telse\n\t{\n\t\tnormalizedNoise = n4rand( uv );\n        idx = 5;\n        uvrange = vec2( 4.0/5.0, 5.0/5.0 );\n\t}\n    //display histogram\n\n    float o = normalizedNoise;\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + distribution( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    //display gradients\n    else if ( uv.y < 5.0 / 8.0 ) {\n        float b = gradient( uv, uvrange )*0.5;\n        float f = 2.0;\n        float offset = sin(iTime*f*3.14*2.0)*0.5+0.5;\n        if ( uv.y < 2.0 / 4.0) {\n            b = offset*0.25+b;\n        } else if (uv.y < 4.5 / 8.0) {\n            b += (-0.5+2.0*normalizedNoise)/STEPS; // [-0.5;1.5[ \n        }\n        if ( uv.y < 3.0 / 8.0 ) {\n            b += (-0.5+2.0*normalizedNoise)/STEPS; // [-0.5;1.5[ \n        }\n        o = QUANTIZE(b, STEPS);\n    } \n    \n\t//display lines\n\tif ( abs(uv.x - 1.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 2.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 3.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 4.0/5.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 1.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 1.0/2.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 3.0/8.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 5.0/8.0) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 395, 418, 418, 486], [487, 531, 573, 573, 617], [618, 648, 682, 682, 706], [708, 708, 732, 732, 812], [813, 813, 837, 837, 967], [969, 969, 1000, 1000, 1539], [1540, 1540, 1564, 1564, 1736], [1737, 1737, 1761, 1761, 1976], [1977, 1977, 2005, 2005, 2391], [3072, 3072, 3114, 3114, 3180], [3182, 3182, 3265, 3265, 4154], [4156, 4156, 4213, 4213, 6029]], "test": "valid"}
{"id": "XtGXWW", "name": "SandRose", "author": "balkhan", "description": "a little experiment", "tags": ["raymarching"], "likes": 8, "viewed": 205, "published": "Public", "date": "1484630834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching defines\n\n#define I_MAX\t150\n#define EPSIL\t0.00001\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n// these defines change the shapes\n\n#define MAGIC\n#define INVERSION\n#define FIRST\n\n//change the colors\n\n//#define COLOR_AO\n#define COLOR_SAHARA\n#define COLOR_SINS\n\nfloat\tde(vec3 pos);\nmat4\tlookat(vec3 eye, vec3 target, vec3 up);\nvec2 \tcmult(vec2 a, vec2 b);\nvec4\tmarch(vec3 pos, vec3 dir);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\tcol = vec4(0.0);\n\tvec3\tdir = normalize(vec3(fragCoord.xy - iResolution.xy/2.0, -iResolution.y));\n    vec3\tpos = vec3(-2.0, 0.0, 2.0);\n    mat4\tlook = lookat(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    dir = vec3(dot(dir, look[0].xyz), dot(dir, look[1].xyz), dot(dir, look[2].xyz));\n   \tvec4 inter = (march(pos, dir));\n\n    #ifdef COLOR_AO\n    col.xyz = vec3(1.0-inter.w/float(I_MAX));\n    #elif defined COLOR_SAHARA\n    col.z += (sin(      inter.w/float(I_MAX)));\n  \tcol.x += (sin(1.57+ inter.w/float(I_MAX)));\n    col.y += (sin(0.78+ inter.w/float(I_MAX)));\n    #else\n    col.z += (1. * (0. + sin(inter.w/float(I_MAX))));\n    col.y += (1. * ( + sin(sin(iTime)*.05+inter.w/float(I_MAX))));\n \tcol.x += pow(sin(inter.x*(0.+sin(iTime+3.14+inter.w/float(I_MAX)))/5.), 20.);\n    #endif\n   \tfragColor = col;\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = de(p)*.5;\n        dist.y += dist.x;\n        if (dist.x < EPSIL)\n        {\n            step.y=dist.x;\n            break;\n        }\n        step.w++;\n    }step.x = dist.y;\n    return (step);\n}\n\nfloat\tde(vec3 pos)\n{\n    pos.yz*=mat2(cos(iTime), sin(iTime),-sin(iTime),cos(iTime));\n\tvec3 z = pos;\n\tfloat r = 0.0;\n\t\tr = length(z);\n #ifdef FIRST\n\t\tfloat theta = asin( z.z/r );\n #else\n \t\tfloat theta = asin((z.x/r+z.y/r)*z.z/r);//2nd\n #endif\n\t\tfloat phi = atan((z.y/r), (z.x/r));\n\t\ttheta = theta * 5.0;\n\t\tphi = phi * 10.0;\n #ifdef INVERSION\n        theta = cmult(vec2(theta), vec2(r,1.0/r)).x;\n #endif\n #ifdef FIRST\n\t\tz = vec3(z.x+sin(theta), z.y-cos(theta+(iTime/2.)*20.), cos(-phi)*(z.z)*(sin(phi)/1.) );\n #else\n\t\tz = vec3(z.x+sin(z.z+theta), z.y-cos(z.z+theta+(iTime/2.)*20.), (z.z) );\n #endif\n #ifdef MAGIC\n \t\tz*=pos+length(z)/5.;\n #endif\n \tr = r-length(z)/4.-.2025;\n\treturn r-.3;\n}\n\nmat4\tlookat(vec3 e, vec3 ta, vec3 up)\n{\n    vec3 z = normalize(e - ta);    \n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);     \n\n    mat4 orientation = mat4(\n       \t\t\t\t\t\tx.x, y.x, z.x, 0.0,\n       \t\t\t\t\t\tx.y, y.y, z.y, 0.0,\n       \t\t\t\t\t\tx.z, y.z, z.z, 0.0,\n       \t\t\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\n    mat4 translation = mat4(\n         \t\t\t\t\t1.0, 0.0, 0.0, 0.0,\n         \t\t\t\t\t0.0, 1.0, 0.0, 0.0, \n         \t\t\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t\t\t\t\t-e.x,-e.y,-e.z, 1.0);\n\n    return (orientation * translation);\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 449, 505, 505, 1327], [1329, 1329, 1361, 1361, 1720], [1722, 1722, 1742, 1742, 2409], [2411, 2411, 2450, 2450, 2923], [2925, 2925, 2954, 2954, 3021]], "test": "error"}
{"id": "XtGXzc", "name": "Van Dammed CheckerBoard", "author": "slarsen", "description": "wew", "tags": ["checkerboard"], "likes": 0, "viewed": 382, "published": "Public API", "date": "1485196968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROWS 9.0\n#define COLUMNS 16.0\n\n\t//Functions for optimizing out conditionals\n//returns 0.0 if !=, 1.0 if ==\nfloat when_eq(float x, float y) \n{\n  return 1.0 - abs(sign(x - y));\n}\n//returns 0.0 if ==, 1.0 if !=\nfloat when_neq(float x, float y) \n{\n  return abs(sign(x - y));\n}\n\t//Math Helper Functions\n//My round function, no webgl provided implementation I guess...\nfloat round(float x)\n{\n    return floor(x + 0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //slowly circularly scrolling UV for checkerboard\n    vec2 MovingUV = vec2(uv.x + 2.0*sin(iTime /8.0),uv.y + 2.0*cos(iTime /8.0));\n//Uncomment to stop checkerboard scrolling\n\t//MovingUV = uv;\n    \n    //texture0, van damme\n    vec4 texture0 = texture(iChannel0, uv);\n    //texture1, fast scrolling color noise\n    vec4 texture1 = texture(iChannel1, uv + 4.0 * iTime);\n    \n    //create floats with values of either 0.0 or 1.0 \n    //corresponding to rounded modulus of MovingUV.x/.y and Columns/Rows\n    float column = round(COLUMNS/2.0 * mod(MovingUV.x, 1.0/(COLUMNS/2.0)));\n    float row = round(ROWS/2.0 * mod(MovingUV.y, 1.0/(ROWS/2.0)));\n\n    //if both row and column are equal, use inverted texture\n    fragColor = when_eq(row, column)*(vec4(1.0) - texture0);\n    \n    //if both row and column are not equal, use texture0 + texture1\n    fragColor += when_neq(row,column)*(texture0/2.0 + texture1/2.0);\n       \n    fragColor.a = 1.0;    \n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 115, 149, 149, 184], [185, 216, 251, 251, 280], [282, 371, 393, 393, 422], [423, 423, 480, 480, 1476]], "test": "error"}
{"id": "XtKSWD", "name": "bloc", "author": "FabriceNeyret2", "description": "Mouse control preempt time.\nChange #EPS for sharper.\n\nplay with the 2D graph here: [url]https://www.desmos.com/calculator/p3ugg70d4e[/url]", "tags": ["raytracing", "spheremarching"], "likes": 10, "viewed": 708, "published": "Public API", "date": "1484415214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n// play with the 2D graph here: https://www.desmos.com/calculator/p3ugg70d4e\n\n#define EPS .001 // smaller = sharper & more contrasted\n\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    float T = iTime+20., \n        closest = 999.;\n    vec2 R = iResolution.xy,\n         m = iMouse.xy/R;\n    vec4 p = vec4((w-.5*R)/R.y,-.5,0), d,c;      // init ray \n    p.z -= .4;                                   // view angle width / zoom\n//  r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);         // camera rotations\n  //d = p;                                       // ray dir = ray0-vec3(0) \n    d = normalize(p);\n    if (length(m)>.01) p.z = -30.*(1.-m.y), T = 30.*m.x; // mouse control preempts.\n    else p.z -= 30.;                             // camera distance.\n    \n    f -= f;\n   \n    for (float i=1.; i>0.; i-=.01)  {\n        \n        vec4 //u = floor(p/18.+3.5), \n            t = p, ta;\n            c = p/p*1.2;\n\t    float x=1e9,x1=1e9;\n\n#define smod(t,n)       ( mod(t+(n)/2., n) - (n)/2.  )\n#define setbox(t,h,w,d)   abs(t) / vec4(h,w,d,1)\n#define setboxU(t)        abs(t)\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z)) -(r) )\n#define dsphere(t,r)    ( length((t).xyz) -(r)       )\n#define dcyl(t,r)       ( length((t).xy ) -(r)       )\n#define union(a,b)        min(a,b)\n#define sub(a,b)          max(a,-(b))\n        \n        r(t.xz,.13); r(t.yz,.2); r(t.xy,.1);         // object rotation\n        // the object\n        ta = setboxU(t);           x =       dbox(ta,10.) ;\n        ta = setboxU(t+1.);        x = sub(x,dbox(ta,7.) );\n        ta = setboxU(smod(t,5.));  x = sub(x,dbox(ta,2.)) ;\n    //  ta = setboxU(fract(t+.5)); x = sub(x,dbox(ta,.9)) ;   // aliased. thanks TimoKinnunen !\n        ta = setboxU(smod(t,1.))+.45; x = sub(x,dbox(ta,.9)); // (should be +.5 . why ?)\n\n        x1 = dsphere((t),.3);          // red spheres\n        closest = min(closest, x1);         // glow footprint\n        // x = min(x1,x);                   // uncomment to display the spheres\n        if (x==x1) c  = vec4(2.,.3,0,0);\n        // if (cos(.25*T)>0.) c += vec4(2.,.3,0,0)*pow(abs((x-x1)),.2)*(.5+.5*cos(.5*T));  // glow1: thanks squid !\n\n        // if (x<-.01) c = vec4(0,0,1,0);          // DEBUG: too thin or near-plane cut parts\n             \n        if(x<EPS)                           // hit ! \n            {   x = i+.01*(1.-abs(x)/EPS);  // decrease banding\n                f = x*x*c; break;           // color texture + black fog \n            }\n        p -= d*x;                           // march ray\n     }\n\n     f += vec4(1,0,0,0) * exp(-closest/4.); //*(.5+.5*cos(.5*T)); // glow2 - thanks kuvkar ! \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 333, 333, 2749]], "test": "valid"}
{"id": "XtKXDh", "name": "Informer", "author": "voz", "description": "Better dance moves, plus cool music.", "tags": ["informer"], "likes": 2, "viewed": 746, "published": "Public API", "date": "1484188577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\nvec3 eye = vec3 (0.0);\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    //return length(bp - rp) - r;\n    \n    vec3 oc = eye - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return FAR;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return length(bp - rp) - r;\n}\n\nfloat sdCapsule(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,eye-a);\n    float e = dot(eye-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((eye+ray*t1)-(a+ray2*t2));\n    return dist > r || t2 < r || t2 > length(a-b)+r? FAR : length(pa - ba * h) - r;\n}\n\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\nvec4  saved_stance[NUM_ANGLES];\nvec4  stance[NUM_ANGLES];\n\nfloat saved_shoulderRot = 0.0;\nfloat shoulderRot = 0.0;\n\nfloat saved_hipRot = 0.0;\nfloat hipRot = 0.0;\n\nfloat saved_lean = 0.0;\nfloat lean = 0.0;\n\n//body joints\nvec3 head = vec3(0.0);\n\nvec3 bSpine = vec3(0.0);\nvec3 uSpine = vec3(0.0);\n\nvec3 leftShoulder = vec3(0.0);\nvec3 rightShoulder = vec3(0.0);\n\nvec3 leftElbow = vec3(0.0);\nvec3 rightElbow = vec3(0.0);\n\nvec3 leftWrist = vec3(0.0);\nvec3 rightWrist = vec3(0.0);\n\nvec3 leftFinger = vec3(0.0);\nvec3 rightFinger = vec3(0.0);\n\nvec3 leftHip = vec3(0.0);\nvec3 rightHip = vec3(0.0);\n\nvec3 leftKnee = vec3(0.0);\nvec3 leftAnkle = vec3(0.0);\n\nvec3 rightKnee = vec3(0.0);\nvec3 rightAnkle = vec3(0.0);\n\nconst vec3 downY = vec3(0.0, -1.0, 0.0);\nfloat minY = 0.0;\n\nvoid load_stance() {\n    \n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n    \tstance[i] = saved_stance[i];\n    \n    shoulderRot = (saved_shoulderRot);\n    hipRot = (saved_hipRot);\n    lean = (saved_lean);\n    \n    head = vec3(0.0, GR/E, 0.0);\n    \n    ///////////////////////////////////////////////////////////////\n    //Spine////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = head/GR;\n    uSpine = -bSpine;\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulders////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    leftShoulder = bSpine+vec3(1.0, 0.0, 0.0)/E;\n    rightShoulder = bSpine-vec3(1.0, 0.0, 0.0)/E;\n    \n    ///////////////////////////////////////////////////////////////\n    //Elbows///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftElbow = downY/GR;\n\n    float leftArmOmega = stance[ELBOWS].x;\n    float leftArmTheta = stance[ELBOWS].y;\n    \n    hangingLeftElbow = rotatePoint(rotatePoint(hangingLeftElbow, vec3(1.0, 0.0, 0.0), leftArmOmega), vec3(0.0, 0.0, 1.0), leftArmTheta);\n    \n    leftElbow = leftShoulder+hangingLeftElbow;\n        \n    vec3 hangingRightElbow = downY/GR;\n    \n    float rightArmOmega = stance[ELBOWS].z;\n    float rightArmTheta = stance[ELBOWS].w;\n    \n    hangingRightElbow = rotatePoint(rotatePoint(hangingRightElbow, vec3(1.0, 0.0, 0.0), rightArmOmega), vec3(0.0, 0.0, -1.0), rightArmTheta);\n    \n    rightElbow = rightShoulder+hangingRightElbow;\n    \n    ///////////////////////////////////////////////////////////////\n    //Wrists///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftWrist = downY/E;\n\n    float leftForeArmOmega = leftArmOmega+stance[WRISTS].x;\n    float leftForeArmTheta = leftArmTheta+stance[WRISTS].y;\n    \n    straightLeftWrist = rotatePoint(rotatePoint(straightLeftWrist, vec3(1.0, 0.0, 0.0), leftForeArmOmega), vec3(0.0, 0.0, 1.0), leftForeArmTheta);\n    \n    leftWrist = leftElbow+straightLeftWrist;\n        \n    vec3 straightRightWrist = downY/E;\n    \n    float rightForeArmOmega = rightArmOmega+stance[WRISTS].z;\n    float rightForeArmTheta = rightArmTheta+stance[WRISTS].w;\n    \n    straightRightWrist = rotatePoint(rotatePoint(straightRightWrist, vec3(1.0, 0.0, 0.0), rightForeArmOmega), vec3(0.0, 0.0, -1.0), rightForeArmTheta);\n    \n    rightWrist = rightElbow+straightRightWrist;\n    \n    ///////////////////////////////////////////////////////////////\n    //Fingers//////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftFingers = downY/PI/E;\n\n    float leftFingersOmega = leftForeArmOmega+stance[FINGERS].x;\n    float leftFingersTheta = leftForeArmTheta+stance[FINGERS].y;\n    \n    straightLeftFingers = rotatePoint(rotatePoint(straightLeftFingers, vec3(1.0, 0.0, 0.0), leftFingersOmega), vec3(0.0, 0.0, 1.0), leftFingersTheta);\n    \n    leftFinger = leftWrist+straightLeftFingers;\n        \n    vec3 straightRightFingers = downY/PI/E;\n    \n    float rightFingersOmega = rightForeArmOmega+stance[FINGERS].z;\n    float rightFingersTheta = rightForeArmTheta+stance[FINGERS].w;\n    \n    straightRightFingers = rotatePoint(rotatePoint(straightRightFingers, vec3(1.0, 0.0, 0.0), rightFingersOmega), vec3(0.0, 0.0, -1.0), rightFingersTheta);\n    \n    rightFinger = rightWrist+straightRightFingers;\n    \n    \n    ///////////////////////////////////////////////////////////////\n    //Hips/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    leftHip = uSpine+vec3(circle(hipRot), 0.0).xzy/E/GR;\n    rightHip = uSpine-vec3(circle(hipRot), 0.0).xzy/E/GR;\n    ///////////////////////////////////////////////////////////////\n    //Knees////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftKnee = downY/GR;\n\n    float leftKneeOmega = stance[KNEES].x;\n    float leftKneeTheta = stance[KNEES].y;\n    \n    hangingLeftKnee = rotatePoint(rotatePoint(hangingLeftKnee, vec3(1.0, 0.0, 0.0), leftKneeOmega), vec3(0.0, 0.0, 1.0), leftKneeTheta);\n    \n    leftKnee = leftHip+hangingLeftKnee;\n        \n    vec3 hangingRightKnee = downY/GR;\n    \n    float rightKneeOmega = stance[KNEES].z;\n    float rightKneeTheta = stance[KNEES].w;\n    \n    hangingRightKnee = rotatePoint(rotatePoint(hangingRightKnee, vec3(1.0, 0.0, 0.0), rightKneeOmega), vec3(0.0, 0.0, -1.0), rightKneeTheta);\n    \n    rightKnee = rightHip+hangingRightKnee;\n    \n    ///////////////////////////////////////////////////////////////\n    //Ankles///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 straightLeftAnkle = downY/GR;\n\n    float leftAnkleOmega = leftKneeOmega+stance[ANKLES].x;\n    float leftAnkleTheta = leftKneeTheta+stance[ANKLES].y;\n    \n    straightLeftAnkle = rotatePoint(rotatePoint(straightLeftAnkle, vec3(1.0, 0.0, 0.0), leftAnkleOmega), vec3(0.0, 0.0, 1.0), leftAnkleTheta);\n    \n    leftAnkle = leftKnee+straightLeftAnkle;\n        \n    vec3 straightRightAnkle = downY/GR;\n    \n    float rightAnkleOmega = rightKneeOmega+stance[ANKLES].z;\n    float rightAnkleTheta = rightKneeTheta+stance[ANKLES].w;\n    \n    straightRightAnkle = rotatePoint(rotatePoint(straightRightAnkle, vec3(1.0, 0.0, 0.0), rightAnkleOmega), vec3(0.0, 0.0, -1.0), rightAnkleTheta);\n    \n    rightAnkle = rightKnee+straightRightAnkle;\n    \n    ///////////////////////////////////////////////////////////////\n    //Lean/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = rotatePoint(bSpine, vec3(1.0, 0.0, 0.0), lean);\n    head = rotatePoint(head, vec3(1.0, 0.0, 0.0), lean);\n    \n    leftShoulder = rotatePoint(leftShoulder, vec3(1.0, 0.0, 0.0), lean);\n    rightShoulder = rotatePoint(rightShoulder, vec3(1.0, 0.0, 0.0), lean);\n    leftElbow = rotatePoint(leftElbow, vec3(1.0, 0.0, 0.0), lean);\n    rightElbow = rotatePoint(rightElbow, vec3(1.0, 0.0, 0.0), lean);\n    leftWrist = rotatePoint(leftWrist, vec3(1.0, 0.0, 0.0), lean);\n    rightWrist = rotatePoint(rightWrist, vec3(1.0, 0.0, 0.0), lean);\n    leftFinger = rotatePoint(leftFinger, vec3(1.0, 0.0, 0.0), lean);\n    rightFinger = rotatePoint(rightFinger, vec3(1.0, 0.0, 0.0), lean);\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulder Rotation////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n\n    leftShoulder = rotatePoint(leftShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightShoulder = rotatePoint(rightShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftElbow = rotatePoint(leftElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightElbow = rotatePoint(rightElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftWrist = rotatePoint(leftWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightWrist = rotatePoint(rightWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftFinger = rotatePoint(leftFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightFinger = rotatePoint(rightFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    \n    ///////////////////////////////////////////////////////////////\n    //Hip Rotation/////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    //MIN calc\n \tfloat lowestY = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(bSpine.y, uSpine.y),\n                                                                            leftShoulder.y),\n                                                                        rightShoulder.y),\n                                                                    leftElbow.y),\n                                                                rightElbow.y),\n                                                            leftWrist.y),\n                                                        rightWrist.y),\n                                                    leftFinger.y), \n                                                rightFinger.y), \n                                            leftHip.y), \n                                        rightHip.y), \n                                    leftKnee.y), \n                                leftAnkle.y),\n                            rightKnee.y),\n                        rightAnkle.y);\n    minY = min(lowestY, minY);\n}\n\nfloat dfScene(vec3 rp, vec3 rd) {\n    \n    float msd = 99.0;\n    \n    float scale = GR;\n    \n    //hip\n    msd = min(msd, sdSphere(rp, rd, leftHip, 0.06*scale));\n    msd = min(msd, sdSphere(rp, rd, rightHip, 0.06*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftHip, rightHip, 0.02*scale));\n    //left thigh\n    msd = min(msd, sdSphere(rp, rd, leftKnee, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftHip, leftKnee, 0.02*scale));\n    //left shin\n    msd = min(msd, sdSphere(rp, rd, leftAnkle, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftKnee, leftAnkle, 0.015*scale));\n    //right thigh\n    msd = min(msd, sdSphere(rp, rd, rightKnee, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightHip, rightKnee, 0.02*scale));\n    //right shin\n    msd = min(msd, sdSphere(rp, rd, rightAnkle, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightKnee, rightAnkle, 0.015*scale));\n    //spine\n    msd = min(msd, sdSphere(rp, rd, bSpine, 0.04*scale));\n    msd = min(msd, sdSphere(rp, rd, uSpine, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, bSpine, uSpine, 0.02*scale));\n    //shoulder\n    msd = min(msd, sdSphere(rp, rd, leftShoulder, 0.05*scale));\n    msd = min(msd, sdSphere(rp, rd, rightShoulder, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftShoulder, rightShoulder, 0.02*scale));\n    //left upper arm\n    msd = min(msd, sdSphere(rp, rd, leftElbow, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftShoulder, leftElbow, 0.02*scale));\n    //left lower arm\n    msd = min(msd, sdSphere(rp, rd, leftWrist, 0.03*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftElbow, leftWrist, 0.015*scale));\n    //left finger\n    msd = min(msd, sdSphere(rp, rd, leftFinger, 0.015*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftWrist, leftFinger, 0.01*scale));\n    //right upper arm \n    msd = min(msd, sdSphere(rp, rd, rightElbow, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightShoulder, rightElbow, 0.02*scale));\n    //right lower arm\n    msd = min(msd, sdSphere(rp, rd, rightWrist, 0.03*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightElbow, rightWrist, 0.015*scale));\n    //right finger\n    msd = min(msd, sdSphere(rp, rd, rightFinger, 0.015*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightWrist, rightFinger, 0.01*scale));\n    //head\n    msd = min(msd, sdSphere(rp, rd, head, 0.15));\n    \n    return msd;\n}\n\nvec3 surfaceNormal(vec3 p, vec3 rd) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy, rd), d2 = dfScene(p - e.xyy, rd);\n\tfloat d3 = dfScene(p + e.yxy, rd), d4 = dfScene(p - e.yxy, rd);\n\tfloat d5 = dfScene(p + e.yyx, rd), d6 = dfScene(p - e.yyx, rd);\n\tfloat d = dfScene(p, rd) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor, vec3 rd) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos, rd)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 8; i++) {\n        rp = ro + rd * d;\n        eye = rp;\n        float ns = dfScene(rp, rd);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = vec3(1.0, 0.0, 0.0); //surface colour\n        vec3 n = surfaceNormal(rp, rd);\n        float ao = calcAO(rp, n, rd);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\nconst int numWeights = 512;\n\nvec3 weights[numWeights];\n\nfloat lowAverage()\n{\n    const int iters = numWeights;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.25)).r;\n        \n        product *= sound;\n        sum += sound;\n        \n        weights[i].r = sound;\n    }\n    for(int i = 0; i < iters; i++)\n        weights[i].gb = vec2(sum/float(iters), pow(product, 1.0/float(iters)));\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nvoid clear_stance()\n{\n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n        stance[i] = vec4(0.0);\n    shoulderRot = 0.0;\n    hipRot = 0.0;\n    lean = 0.0;\n}\n\nvoid dance1()\n{\n    clear_stance();\n\tfloat twist = time;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    vec2 twistCircle = circle(twist*GR)*GR;\n    \n    stance[ELBOWS].x = twistCircle.x;\n    stance[ELBOWS].y = twistCircle.x/PI;\n    stance[ELBOWS].z = twistCircle.y;\n    stance[ELBOWS].w = twistCircle.y/PI;\n    \n    stance[WRISTS].x = (stance[ELBOWS].x*.5+.5);\n    stance[WRISTS].z = (stance[ELBOWS].z*.5+.5);\n    \n    shoulderRot = sin(PI+twist*PI*3.0)/PI/GR;\n    hipRot = sin(twist*PI*3.0)/PI/GR;\n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance2()\n{\n    clear_stance();\n\tfloat run = time*PI;\n    \n    vec2 runCircleA = circle(run)*.5+.5;\n    vec2 runCircleB = circle(run+PI)*.5+.5;\n    \n    stance[ELBOWS].x = (runCircleA.x*2.0-1.0)*GR;\n    stance[ELBOWS].z = (runCircleB.x*2.0-1.0)*GR;\n    \n    stance[KNEES].x = runCircleA.x*2.0-1.0;\n    stance[KNEES].z = runCircleB.x*2.0-1.0;\n    stance[ANKLES].x = runCircleA.y;\n    stance[ANKLES].z = runCircleB.y;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance3()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI/2.0+sin(wave)/PI;\n    stance[ELBOWS].w = PI/2.0+sin(wave+PI/2.0)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance4()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI+sin(wave)/PI;\n    stance[ELBOWS].w = PI+sin(wave+PI/2.0)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance5()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    stance[ELBOWS].x = PI/2.0+sin(wave);\n    stance[ELBOWS].z = PI/2.0+sin(wave+PI);\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid save_stance(float factor)\n{\n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n    {\n        saved_stance[i] += (stance[i]-saved_stance[i])*factor;\n    }\n    \n    saved_shoulderRot += (shoulderRot-saved_shoulderRot)*factor;\n    saved_hipRot += (hipRot-saved_hipRot)*factor;\n    saved_lean += (lean-saved_lean)*factor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float height = max(lowAverage(), last_height)-1.0/60.0;\n    beat = clip(height);\n    last_height = height;\n    \n    float dance = time/PI/PI;\n    float v1 =  smoothstep(-1.0, 1.0/5.0, saw(dance));\n    float v2 =  smoothstep(1.0/5.0, 2.0/5.0, saw(dance));\n    float v3 =  smoothstep(2.0/5.0, 3.0/5.0, saw(dance));\n    float v4 =  smoothstep(3.0/5.0, 4.0/5.0, saw(dance));\n    float v5 =  smoothstep(4.0/5.0, 1.0, saw(dance));\n    dance1();\n    save_stance(v1);\n    dance2();\n    save_stance(v2);\n    dance3();\n    save_stance(v3);\n    dance4();\n    save_stance(v4);\n    dance5();\n    save_stance(v5);\n    load_stance();\n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, minY+1.25, -3.5);\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    eye = ro;\n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [{"id": "XdBGzc", "previewfilepath": "https://soundcloud.com/yanivi/yanivi-vs-snow-informer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/yanivi/yanivi-vs-snow-informer", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1077, 1077, 1096, 1096, 1148], [1150, 1150, 1202, 1236, 1810], [1812, 1812, 1872, 1872, 2391], [4005, 4005, 4025, 4025, 13005], [13007, 13007, 13040, 13040, 15354], [15356, 15356, 15393, 15393, 15723], [15725, 15730, 15773, 15773, 16070], [16072, 16085, 16120, 16120, 16902], [16960, 16960, 16980, 16980, 17475], [17477, 17477, 17498, 17498, 17627], [17629, 17629, 17644, 17644, 18233], [18235, 18235, 18250, 18250, 18711], [18713, 18713, 18728, 18728, 19262], [19264, 19264, 19279, 19279, 19805], [19807, 19807, 19822, 19822, 20157], [20159, 20159, 20191, 20191, 20471], [20473, 20473, 20528, 20528, 21645]], "test": "timedout"}
{"id": "XtKXDz", "name": "Radial Progress", "author": "mende", "description": "Radial progress bar", "tags": ["progress"], "likes": 0, "viewed": 221, "published": "Public", "date": "1483904813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.141592;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tfloat x = (uv.x - 0.5) * 2.0;\n    float y = (uv.y - 0.5) * 2.0;\n    float d = sqrt(x * x + y * y);\n    vec4 color = vec4(0,0,0,1);\n    if(d > 0.5 && d < 0.8) {\n\t\tfloat theta = atan(y, x) / pi;\n  \t\tfloat b = (theta * 0.5) + 0.5;\n        if(b < sin(iTime) * 0.5 + 0.5)\n    \t\tcolor = vec4(1, b, 0, 1);\n    }\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 451]], "test": "valid"}
{"id": "XtKXRy", "name": "E360 stars with subtle scanlines", "author": "zproxy", "description": "E360 stars with subtle scanlines", "tags": ["stars", "360"], "likes": 2, "viewed": 80, "published": "Public", "date": "1484816841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define xWebGLTexture360height iResolution.y \n#define xWebGLTexture360height iResolution.y\n\n\n#define uIPD 0.0\n    \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n} \n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    vec3 col0 = stars( normalize(rotx(rd, -iTime * 0.01)));\n\n    vec3 col = col0;\n\n   \n    return col;\n}\n\n\n\nfloat xstars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    vec3 q = fract(p*2.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 xstartrails(in vec3 rd)\n{\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = xstars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = xstars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\n\n\n void mainImage0( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD )\n {\n    \n    rd *= rotationMatrix(vec3(0.0, 1.0, 0.0), ((-0. -  iMouse.x * 2.) / 360.) * 3.14);\n    //rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), 90.);\n    rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), ((90. + cos(iTime) * 1. -  iMouse.y * 2.0) / 360.) * 3.14);\n    \n\n     \n    vec3 col = startrails( rd);\n\n    \n    vec3 scanlines = xstartrails( rd);\n    \n    // cool. a subtle line. blink out. blink in\n  col += scanlines * 0.19 * (0.8 + sin(iTime * 0.1));\n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n    \n\tfragColor = vec4(col, 1.0);\n }\n\n \n\n// called by drawArrays\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n    bool drag = iMouse.w > 0.0;\n    \n    float grid = 16.;\n    float gridt = 2.;\n    \n    bool indexx = int(int(fragCoord.x  / grid) * int(grid)) == int(fragCoord.x);\n    bool indexy = int(int(fragCoord.y  / grid) * int(grid)) == int(fragCoord.y);\n    //bool indext = int(int(float(iFrame)  / grid) * int(grid)) == int(iFrame);\n    bool indext = int(int(float(iTime)  / gridt) * int(gridt)) == int(iTime);\n    \n    if (drag || (indext&&(indexy||indexx)))\n\n\n    {\n   if ( int(fragCoord.x + 2.) > int(iMouse.x))\n   if ( int(fragCoord.x - 2.) < int(iMouse.x))\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n      if ( int(fragCoord.y + 2.) > int(iMouse.y))\n   if ( int(fragCoord.y - 2.) < int(iMouse.y))\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    }\n    \n\t \n\t\n\tbool RvL = true;\n\t \n\tvec4 fragColorR = vec4(1.0, 0.0, 0.0, 1.0);\n\tvec2 fragCoordR = vec2(gl_FragCoord.x, gl_FragCoord.y / 1.0);\n\tvec2 texCoordR0 = vec2((iResolution.x - fragCoordR.x)/iResolution.x, fragCoordR.y/(iResolution.y/1.0))  + vec2(0.25, 0.0);\n\tvec2 thetaphiR = ((texCoordR0 * vec2(2.0, 2.0)) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n\tvec3 rayDirectionR = vec3(cos(thetaphiR.y) * cos(thetaphiR.x ), sin(thetaphiR.y), cos(thetaphiR.y) * sin(thetaphiR.x ));\n\n\n\n    \n\tmainImage0(\n\tfragColorR, \n\t fragCoordR, \n\tthetaphiR , \n\t rayDirectionR, \n\t uIPD  \n\t\n\t);\n\t\n\t// lets not shadow the non stereo area.\n\t//fragColorLvR.rgb *= \n\t//\t1.0 - abs(RvL ? thetaphiR.y : thetaphiL.y) * 0.6;\n\t\n    //if (thetaphiR.y >0.0)\n    //    fragColorR.b += (0.1 + thetaphiR.y * 0.3);\n \t//else\n    //    fragColorR.g += 0.05;\n    \n\tfragColor = fragColorR;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 179, 200, 200, 343], [346, 346, 391, 391, 857], [864, 864, 891, 891, 979], [984, 1039, 1062, 1075, 1557], [1559, 1559, 1588, 1588, 1693], [1697, 1697, 1722, 1759, 1849], [2364, 2364, 2458, 2458, 3089], [3094, 3118, 3175, 3175, 4888]], "test": "valid"}
{"id": "XtKXWG", "name": "Colander hat", "author": "balkhan", "description": "requested by public_int_i", "tags": ["3d", "raymarching", "joke"], "likes": 5, "viewed": 165, "published": "Public", "date": "1485825147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\nvec2\trot_t;\nvec3\tbase;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-5.0, 5.0, 60.0);\n    t = iTime;\n\trot_t = vec2( cos(t), sin(t) );\n\n    vec4\tinter = (march(pos, dir));\n\tif (inter.y == 1.)\n\t{\n\t\tvec3\tv = pos+inter.w*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(100.0, 100.0, 700.0);\n\t\tvec3\tlight_color = vec3(.4, .5, .4);\n        vec3\tvl = normalize( (light_pos - v) );\n\t\tfloat\tdiffuse  = max(0., dot(vl, n));\n\t\tfloat\tspecular = pow(max(0., dot(vl, ref_ev)), 20. );\n\n    \tv.zy *= mat2(rot_t.x, rot_t.y, -rot_t.y, rot_t.x);\n        vec2\tuv_map = vec2(\n        \t\t\t\t\t\t.5 + atan(v.z, v.x)/6.28 ,\n        \t\t\t\t\t\t.5 - asin(v.y/5.)/3.14 );\n        base.xyz = vec3(.45,.45,.4);\n        base.xyz =1.5* texture(iChannel0, vec2( (uv_map.xy) )).xyz;\n\n        col.xyz = light_color * (specular) + diffuse * base;\n    }\n    c_out =  vec4(col,1.0);\n}    \n\nfloat sdCappedCylinder( vec3 p, vec2 h ); // iq's sdf\nfloat sdTorus( vec3 p, vec2 t );\n\nfloat\tde_0(vec3 p) // Collander\n{\n\tfloat\tmind = 1e5;\n\tfloat\tsphere_dist = 1e5;\n    float\tsphere_dist_2 = 1e5;\n    \n    sphere_dist   = mind = length(p) -15.4;\n    sphere_dist_2 = mind = max(mind, -(length(p-vec3(0.,-1.5, -0.)) -15.3 ) );\n\n    vec3 d = p;\n\tif (mind >= sphere_dist) // punch some holes in it\n    {\n        d.yz *= mat2(cos(1.57),sin(1.57),-sin(1.57),cos(1.57) );\n        if (dot(d.x,d.x)+dot(d.y,d.y) < 196. ) // but not too much\n    \td.yx = mod(d.yx, 2.)-1.;\n        mind = max(mind, -sdCappedCylinder(d, vec2(.81,20.2) ) );\n    }\n    \n    // add some handles\n\n    mind = min(mind, max(-sphere_dist, min(mind, sdTorus(p-vec3(-16.,1.5,0.), vec2(3.5, 1.5) ) ) ) );\n   \tmind = min(mind, max(-sphere_dist, min(mind, sdTorus(p-vec3(+16.,1.5,0.), vec2(3.5, 1.5) ) ) ) );\n    \n    // add a rope to stick to head\n\n    p.zy *= mat2(.0, 1., -1., .0);\n    mind = min(mind, max(-sphere_dist, min(mind, sdTorus(p-vec3(-0.,0.,-2.), vec2(15., .75) ) ) ));\n    \n\treturn (mind);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = (vec2(length(p.xy),p.z )) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    p.zy *= mat2(rot_t.x, rot_t.y, -rot_t.y, rot_t.x);\t// view from angle\n\n\tmind = de_0(p);\n\t\n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\ts = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            s.y = 1.;\n            break;\n        }\n        s.x++;\n    }\n    s.w = dist.y+dist.x;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKXWG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[337, 337, 380, 380, 1392], [1486, 1486, 1519, 1519, 2465], [2467, 2467, 2500, 2500, 2565], [2567, 2567, 2609, 2609, 2704], [2706, 2706, 2727, 2727, 2863], [2866, 2866, 2898, 2898, 3279], [3295, 3295, 3335, 3335, 3410], [3412, 3412, 3440, 3440, 3548], [3551, 3551, 3601, 3601, 3861], [3863, 3863, 3885, 3885, 4091]], "test": "error"}
{"id": "XtV3Rd", "name": "- Bouncing ball - ", "author": "FranciscoGarcia", "description": "SimulaciÃ³n de bouncing.", "tags": ["bouncing", "movimiento"], "likes": 2, "viewed": 103, "published": "Public", "date": "1484543158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circulo(in vec2 p, float rad, vec2 pos){\n    \n    p -=pos;\n    p = p-vec2(0.0,-0.4);\n\tp.y -= 0.6*abs(cos(cos(p.x*1.4) + 4.2*iTime));\n    return 1.-step(rad, length(p));\n}\n\nfloat circulo2(in vec2 p, float rad, vec2 pos){\n    \n    p -=pos;\n    p = p-vec2(0.0,-0.4);\n\tp.y -= 0.6*abs(sin(cos(p.x*1.4) + 4.2*iTime));\n    return 1.-step(rad, length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    \n    float cir = circulo(p,0.5,vec2(-1.0,0.0));\n    float cir2 = circulo2(p,0.5,vec2(1.0,0.0));\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(cir)*vec3(1.0,1.0,0.0);\n    col += vec3(cir2)*vec3(1.0,0.0,0.0);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtV3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 176], [178, 178, 225, 225, 355], [357, 357, 414, 414, 781]], "test": "valid"}
{"id": "XtVSWW", "name": "Strange fractal", "author": "stduhpf", "description": "Its a Knighty's pleudeo kleinian mod.\nThhs formula can produce really interesting shapes, but when i go too far from the origin, the DE starts to be innacurate.\n", "tags": ["fractal", "experiment", "kleinian", "glitched"], "likes": 3, "viewed": 154, "published": "Public", "date": "1484391762", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define s vec3(.75,.75,.8)\n#define fr_it 8\n#define scale .7\n#define maxi .75\n\n#define stereo\n\n\nvec2 map(vec3 p) //distance to the fractal\n{\n\n    float k=1.;\n    for( int i =0;i<fr_it;i++)\n    {\n        p=2.*clamp(p,-s,s)-p;//boxfold (repetition)\n        //p=mod(p+s,2.*s)-s; //infinite repetition\n    p-=sign(p)*.03;\nfloat a = float(i)*acos(-1.)/4.;\nvec2 x = vec2(cos(a),sin(a));\n    p.yz*=mat2(x,-x.y,x.x);\n        float f = max(scale/dot(p,p),maxi);\n        p*=f;\n        k*=f*1.1;\n    }\n    return vec2(max(length(p.xz)-.9,length(p.xz)*abs(p.y)/length(p))/k,\n(length(p.xz)-.4 >(abs(p.y)/length(p)))?1:2);\n}\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  r = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.002*t;\n        \n         r = map( ro+rd*t );\n\t    float h = r.x;\n        if( h<precis||t>maxd ) break;\n        t += .8*h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec2( t, r.y );\n}\n\nvec3 normal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\nfloat ao(vec3 p, vec3 n)\n{\n    const float ao_it =8.;\n    float d=0.;\n    float sm =0.;\n    for(float i=1.;i<ao_it;i++)\n    {\n        d+=.08;\n        float h = map(p+d*n).x;\n        sm+=(d-h)/pow(2.,i);\n    }\n    return 1.-sm*4.;\n\n}\nvec3 getCol(float i)\n{\n    if(i==1.)\n        return vec3(.3,.28,.04);\n     if(i==2.)\n        return vec3(.01,.2,.4);\n return vec3(0);   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec3 ro = s;\n    ro.z=40.*sin(.01*iTime);\n    vec2 mse=3.14*(2.*iMouse.xy-iResolution.xy)/iResolution.x;\n    if(iMouse.xy==vec2(0))\n        mse=vec2(-2.3,-.7);\nmat3 r = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nr*= mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n    \n#ifdef stereo\n    ro+=r*vec3(0,0,.02*(float(uv.x>0.)-.5));\n    uv.x=uv.x*2.+(uv.x>0.?-1.:1.)*iResolution.x/iResolution.y;\n\tuv.y*=2.;\n#endif\n    \n    \n    vec3 rd = normalize(vec3(uv,1))*r;\n    vec3 c=vec3(0);\n    \n    vec2 i = intersect(ro,rd);\n    if(i.y!=0.)\n    {\n        vec3 p = ro+i.x*rd,\n        n=normal(p,i.x);\n        c= getCol(i.y);\n        float l =dot(n,-rd)*ao(p,n);\n        c*=l*4.;\n        //c=vec3(ao(p,n));\n    }\n    c=mix(c,vec3(.5,.55,.6),i.x<0.?1.:i.x/20.);\n    \n\tfragColor = pow(vec4(c,1.0),vec4(1.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 139, 139, 609], [610, 610, 652, 652, 959], [961, 961, 1001, 1001, 1256], [1257, 1257, 1283, 1283, 1489], [1490, 1490, 1512, 1512, 1628]], "test": "valid"}
{"id": "XtVSzd", "name": "tunnel effect", "author": "bysse", "description": "Tunnel effect...\nSuggested music to this would be:\nhttps://soundcloud.com/biot13013/neros-day-at-disneyland-4", "tags": ["tunneleffect"], "likes": 3, "viewed": 396, "published": "Public", "date": "1485466133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 tunnel(vec2 uv) {\n    return vec2(\n        max(0.0, 1.0 / length(uv)),\n        3.1415 + atan(uv.x, uv.y)\n        );\n}\n\nvec3 map(vec2 uv, float t) {\n    vec2 d = texture(iChannel0, uv + vec2( 0.0, t)).xy;\n    uv.y += 0.25 * d.y;\n\treturn vec3(\n        sin(3.1415 * fract(2.0 * uv.x)),\n    \tabs(cos(2.0 * (uv.y + uv.x))),\n    \tabs(sin(2.0 * (uv.y + uv.x)))\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 2.0 * iTime;\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;    \n    uv.x *= iResolution.x / iResolution.y;\n    uv += .1 * vec2(sin(1.37 * t), cos(1.11 * t));\n    vec2 b = tunnel(uv);\n    vec3 color = map(b + vec2(t + .25 * sin(t), sin(b.x + t)), t) / b.x;\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 122], [124, 124, 152, 152, 371], [373, 373, 430, 430, 742]], "test": "error"}
{"id": "XtVXRd", "name": "woah shapes", "author": "kevpegan", "description": "shapes", "tags": ["shapes"], "likes": 0, "viewed": 72, "published": "Public", "date": "1485461899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool CheckCircle(vec2 centerPoint, float radius, vec2 currPoint)\n{\n    if(length(currPoint - centerPoint) <= radius)\n    {\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //PREMADE VARIABLES\n    float recWidth  = .1;\n    float recHeight = .3;\n    vec2  recCenter = vec2(.8,.5);\n    \n    vec2 circleCenter1 = vec2(.2,.2);\n    vec2 circleCenter2 = vec2(.3,.2);\n    vec2 circleCenter3 = vec2(.25,.3);\n    \n    vec2 circleUV;\n    \n    float circleColor1 = .7;\n    float circleColor2 = .5;\n    float circleColor3 = .3;\n    float rectangleColor = .5;\n    \n    vec4 BG;\n    vec4 Layer1;\n    vec4 Layer2;\n    vec4 Layer3;\n    vec4 Layer4;\n    \n    float circleSharedRadius = .1;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    circleUV = uv;\n    \n    circleUV.y *= (iResolution.y / iResolution.x);    \n    \n    BG = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    //ENDPREMADE VARIABLES\n    \n    //MOVE RECTANGLE\n    recCenter.x *= sin(iTime) * .5;\n    recCenter.x += .5;\n    \n    //check rectangle\n    if(length(uv.x - recCenter.x) <= recWidth &&\n       length(uv.y - recCenter.y) <= recHeight)\n    {\n        \n        Layer1 = BG * rectangleColor;\n    }\n    \n    //checkCircle1    \n    if(CheckCircle(circleCenter1, circleSharedRadius, circleUV))\n    {\n        Layer2 = BG * circleColor1;\n    }\n    //checkCircle2  \n    if(CheckCircle(circleCenter2, circleSharedRadius, circleUV))\n    {\n        Layer3 = BG * circleColor2;\n    }\n    //checkCircle3   \n    if(CheckCircle(circleCenter3, circleSharedRadius, circleUV))\n    {\n        Layer4 = BG * circleColor3;\n    }\n    \n    vec4 Composite = mix(BG, Layer1, Layer1.a);\n    Composite = mix(Composite, Layer2, Layer2.a);\n    Composite = mix(Composite, Layer3, Layer3.a);\n    Composite = mix(Composite, Layer4, Layer4.a);\n    \n    fragColor = Composite;    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 169], [171, 171, 228, 252, 1856]], "test": "valid"}
{"id": "XtVXRW", "name": "Equirectangular stereo VR cam", "author": "Nesvi7", "description": "This is a camera for rendering 360 stereo SBS/OU images/video for VR.", "tags": ["camera", "vr", "renderer", "equirectangular"], "likes": 6, "viewed": 309, "published": "Public", "date": "1483295102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//By Nestor Vina\n\n/* With the GetEquirectangularStereoDirection function you can easily adapt existing shadertoys to\n * view them in VR equirectangular stereo images. This only affects the origin and direction of the\n * ray and you can see it in the mainImage function.\n * \n * The ideal scenario is to render this in very high resolutions, so if you comment the OverUnder \n * define you will be able to render the L and R eye independently and compose them in photoshop \n * for example. \n *\n * The best option is to use a custom renderer in SBS outside shadertoy to achieve the highest \n * resolution posible. So if you have one talk me about it, because with that we can even render\n * stereo video.\n *\n */\n\n#define OverUnder\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.01;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265358979323846264338327;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n\n//Stereo equirectangular part\nstruct StereoOutput{\n vec3 dir,originOffset;   \n};\n    \nStereoOutput GetEquirectangularStereoDirection(vec2 uv, float ipd){\n    #ifdef OverUnder\n        bool r = uv.y < 0.5;\n\n        if(r)\n            uv.y = uv.y*2.0;\n        else\n            uv.y = (uv.y-0.5)*2.0;\n\n        StereoOutput stereoOutput;\n        vec2 tp = ((uv*2.0)-vec2(1.0));\n        tp *= vec2(PI,PI*0.5); \n        stereoOutput.dir = vec3(cos(tp.y)*cos(tp.x),\n                                sin(tp.y),\n                                cos(tp.y)*sin(tp.x));\n        stereoOutput.dir.y = -stereoOutput.dir.y;\n        float angle = atan(stereoOutput.dir.z,stereoOutput.dir.x);\n        float ipdInfluence = 1.0-abs(dot(stereoOutput.dir,vec3(0.0,1.0,0.0)));\n\n        if(r)\n            angle -= PI/2.0;\n        else\n            angle += PI/2.0;\n\n        stereoOutput.originOffset = vec3(cos(angle),0.0,sin(angle))*ipd*0.5*ipdInfluence;\n    \n    #else\n        StereoOutput stereoOutput;\n        vec2 tp = ((uv*2.0)-vec2(1.0));\n        tp *= vec2(PI,PI*0.5); \n        stereoOutput.dir = vec3(cos(tp.y)*cos(tp.x),\n                                sin(tp.y),\n                                cos(tp.y)*sin(tp.x));\n        stereoOutput.dir.y = -stereoOutput.dir.y;\n        float angle = atan(stereoOutput.dir.z,stereoOutput.dir.x);\n        float ipdInfluence = 1.0-abs(dot(stereoOutput.dir,vec3(0.0,1.0,0.0)));\n\n        #if 1 //R\n            angle -= PI/2.0;\n        #else //L\n            angle += PI/2.0;\n        #endif\n        \n\n        stereoOutput.originOffset = vec3(cos(angle),0.0,sin(angle))*ipd*0.5*ipdInfluence;\n    #endif\n    return stereoOutput;    \n}\n\n//Operations\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 rotate( vec3 p, vec3 rot ){\n    rot.z = -rot.z;\n    mat3 ry = mat3(cos(rot.y), 0.0,-sin(rot.y),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(rot.y), 0.0, cos(rot.y)  );\n    \n\tmat3 rz = mat3(cos(rot.z),-sin(rot.z), 0.0,\n\t\t\t   sin(rot.z), cos(rot.z), 0.0,\n\t\t\t   0.0, 0.0, 1.0 );\n     \n\tmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(rot.x), sin(rot.x), \n\t\t\t   0.0,-sin(rot.x), cos(rot.x) );\n    return p*rz*ry*rx;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n//Primitives some/all of them by iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//Map\n\nvec2 K2SOEyes(vec3 p){\n    float theDist;    \n    \n    const float ipd = 0.37;\n    const float eyeHeight = 0.0;\n    float eyeL = length(p-vec3(-ipd,eyeHeight,-0.75))-0.15;\n    float eyeR = length(p-vec3(ipd,eyeHeight,-0.75))-0.15;\n    \n    \n    float eyeLHole = length((p-vec3(-ipd,eyeHeight,-0.9))*vec3(1.0,1.0,0.2))-0.07;\n    float eyeRHole = length((p-vec3(ipd,eyeHeight,-0.9))*vec3(1.0,1.0,0.2))-0.07;\n    \n    theDist = min(eyeL,eyeR);\n    theDist = max(theDist,-eyeLHole);\n    theDist = max(theDist,-eyeRHole);\n    return vec2(theDist,3.0);\n}\n\nvec2 K2SOHead( vec3 p ){\n\tvec2 theDist;\n    \n    const float cutSeparation = -0.9;\n    float verticalCutL = -p.x + cutSeparation;\n    float verticalCutR = p.x + cutSeparation;\n    \n    //return vec2(verticalCutR,0.0);\n    theDist = vec2(smin(length((p+vec3(0.0,-0.3,0.0))*vec3(1.0,0.8,0.9))-1.0,verticalCutL,-8.0),0.0);    \n    theDist.x = smin(theDist.x,verticalCutR,-8.0);  \n    \n    float horizontalCut = p.y - 0.5;\n    float horizontalCutTop = -p.y - 0.9;\n    \n    theDist.x = max(theDist.x,horizontalCut);\n    theDist.x = smin(theDist.x,horizontalCutTop,-8.0);\n    \n    const float ipd = 0.37;\n    const float eyeHeight = 0.0;\n    float eyeL = sdCapsule(p,vec3(-ipd,eyeHeight,0.0), vec3(-ipd,eyeHeight,-2.0),0.15);\n    float eyeR = sdCapsule(p,vec3(ipd,eyeHeight,0.0), vec3(ipd,eyeHeight,-2.0),0.15);\n    \n    theDist.x = max(theDist.x,-eyeL);\n    theDist.x = max(theDist.x,-eyeR);\n    \n    float mouthGroove = sdBox((p+vec3(0.0,-0.9,+1.0))*vec3(4.0*min(p.y+1.11-2.0,1.0),1.0,1.0),vec3(0.5,0.5,0.5));\n    theDist.x = max(theDist.x, -mouthGroove);\n    \n    float mouth = sdBox(p+vec3(0.0,-0.65,0.7),vec3(0.23,0.2,0.4));\n    mouth = max(mouth, -sdBox(p+vec3(0.0,-0.9,0.8),vec3(0.13,0.2,0.4)));\n    theDist = opU(theDist, vec2(mouth,1.0));//boca\n    \n    float mouthLateralThingL = sdBox(p+vec3(0.3+p.z*0.08,-0.75,0.6),vec3(0.07,0.07,0.4));\n    float mouthLateralThingR = sdBox(p+vec3(-0.3-p.z*0.08,-0.75,0.6),vec3(0.07,0.07,0.4));\n    theDist = opU(theDist, vec2(mouthLateralThingL,1.0));\n    theDist = opU(theDist, vec2(mouthLateralThingR,1.0));\n    \n    float cheekL = sdBox(p+vec3(0.3,-0.53,0.6),vec3(0.1,0.1,0.4));\n    cheekL = max(cheekL,-sdBox(p+vec3(0.4,-0.66,0.7),vec3(0.1,0.1,0.4)));\n    cheekL = min(cheekL,sdBox((p+vec3(0.26,-0.53,1.04))*rotationXY(vec2(0.0,-1.0)),vec3(0.03,0.03,0.05)));\n    float cheekR = sdBox(p+vec3(-0.3,-0.53,0.6),vec3(0.1,0.1,0.4));\n    cheekR = max(cheekR,-sdBox(p+vec3(-0.4,-0.66,0.7),vec3(0.1,0.1,0.4)));\n    cheekR = min(cheekR,sdBox((p+vec3(-0.26,-0.53,1.04))*rotationXY(vec2(0.0,1.0)),vec3(0.03,0.03,0.05)));\n    \n    theDist = opU(theDist, vec2(cheekL,1.0));\n    theDist = opU(theDist, vec2(cheekR,1.0));\n    \n    float chin = sdBox(p+vec3(0.0,-0.8,0.65),vec3(0.13,0.2,0.4));\n    chin = max(chin, -sdBox((p+vec3(0.0,-0.9,1.2))*rotationXY(vec2(-0.8,0.0)),vec3(0.5,0.13,0.4)));\n    theDist = opU(theDist, vec2(chin,2.0));\n    \n    float mandible = sdBox(p+vec3(0.0,-0.65,0.4),vec3(1.-p.y*0.9,0.2,0.2));\n    \n    theDist = opU(vec2(mandible,2.0),theDist);\n    \n    theDist = opU(theDist,K2SOEyes(p));\n    \n    return theDist;\n}\n\nvec2 K2SONeck(vec3 p ){\n\tfloat theDist = sdCappedCylinder(p+vec3(0.0,-1.0,0.0),vec2(0.25,0.7));\n    \n    return vec2(theDist,0.0);\n}\n\nvec2 K2SOBody(vec3 p ){\n    p += vec3(0.0,0.1,0.0);\n\tfloat theDist = sdEllipsoid(p+vec3(0.0,-3.5,-0.8), vec3(2.3,2.4,2.0) );\n    theDist = max(theDist, -(length(p+vec3(0.0,-0.85,0.3))-0.9));   \n    theDist = smin(theDist,-(length(p+vec3(5.0,-4.0,0.0))-3.0),-2.0); \n    theDist = smin(theDist,-(length(p+vec3(-5.0,-4.0,0.0))-3.0),-2.0);  \n    theDist = smin(theDist,length((p+vec3(0.0,-4.0,4.5))*vec3(7.0,1.0,1.0))-3.0,2.0);\n    theDist = max(theDist,-p.z-1.2);\n    \n    float shoulder = sdCappedCone( (p+vec3(2.8,-2.8,-0.7))*rotationXY(vec2(PI*0.5,-PI*0.5)), vec3(1.0,1.0,1.0) );\n    shoulder = max(shoulder, -(length(p+vec3(3.,-2.8,-0.7))-1.0));\n    shoulder = min(shoulder, sdCappedCone( (p+vec3(-2.8,-2.8,-0.7))*rotationXY(vec2(PI*0.5,PI*0.5)), vec3(1.0,1.0,1.0) ));\n    shoulder = max(shoulder, -(length(p+vec3(-3.,-2.8,-0.7))-1.0));\n    \n    theDist = smin(theDist, shoulder,8.0);\n    \n    return vec2(theDist,0.0);    \n}\n\nvec2 K2SOArms(vec3 p){\n    float theDist;\n    \n    vec3 armLP = p + vec3(-0.5,0.0,0.0);\n    float armL = sdCapsule(armLP,-vec3(2.8,-2.8,-0.7),-vec3(2.8,-5.0,-0.7),0.6);   \n    armL = max(armL, -armLP.x-3.3);\n    armL = max(armL, armLP.x+2.8);\n    \n    vec3 armRP = (p + vec3(0.5,0.0,0.0))*vec3(-1.0,1.0,1.0);\n    float armR = sdCapsule(armRP,-vec3(2.8,-2.8,-0.7),-vec3(2.8,-5.0,-0.7),0.6);   \n    armR = max(armR, -armRP.x-3.3);\n    armR = max(armR, armRP.x+2.8);\n    \n    theDist = min(armL,armR);\n    \n    return vec2(theDist,0.0);\n}\n\n\nvec2 K2SO( vec3 p ){\n    vec2 result = opU(K2SOHead(p*rotationXY(vec2(0.0,sin(iTime)))),K2SONeck(p));\n    result = opU(result,K2SOBody(p));\n    result = opU(result,K2SOArms(p));\n\treturn result;\n    \n}\n\nvec2 map( vec3 p) {\n    float theDist = length(p)-1.0;\n    theDist = min(theDist,K2SO((p+vec3(0.0,0.0,-20.0))/3.0).x*3.0);\n    theDist = min(theDist,sdBox( rotate((p+vec3(-10.0,0.0,-10.0)),vec3(709.26,2.3,2.1)),vec3(2.0,2.0,2.0)));\n    theDist = min(theDist,sdCappedCylinder( rotate((p+vec3(+10.0,0.0,-10.0)),vec3(709.26,2.3,2.1)),vec2(2.0,2.0)));\n    theDist = min(theDist,sdBox( rotate((p+vec3(0.0,-10.0,-10.0)),vec3(1.5,2.3,1.0)),vec3(10.0,1.0,1.0)));\n    theDist = min(theDist,sdBox( rotate((p+vec3(0.0,10.0,-10.0)),vec3(-1.5,2.3,1.0)),vec3(10.0,1.0,1.0)));\n    \n    return vec2(theDist,0.0);\n}\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 material( vec3 v, vec3 n, vec3 eye ) {    \n    //Texturing \n    vec2 uv = v.xz;    \n    vec3 albedo = vec3(0.5,0.0,0.0);\n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float diffuse = dot(sunDir,n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    \n    return albedo+diffuse+ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    StereoOutput stereoOutput = GetEquirectangularStereoDirection(fragCoord.xy/iResolution.xy, 0.65);\n\tvec3 dir = stereoOutput.dir;\n\tvec3 eye = vec3( 0.0, 0.0, 10.0 ) + stereoOutput.originOffset;\n\n\tmat3 rot = rotationXY( vec2(0,0));//vec2(-0.2, iTime/2.0 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\n    vec2 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(0.3,0.3,0.3,1.0);//Background color\n        return;\n\t}\n\t\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    vec3 fogColor = vec3(0.3,0.3,0.3);\n    \n    if( rayResult.y == 0.0 )\n    \tfragColor = vec4(material( pos, n, eye ), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1107, 1107, 1174, 1174, 2667], [2669, 2682, 2723, 2723, 2794], [2796, 2796, 2828, 2828, 3199], [3201, 3201, 3234, 3234, 3260], [3262, 3262, 3292, 3292, 3325], [3327, 3327, 3358, 3358, 3515], [3517, 3553, 3584, 3584, 3671], [3673, 3673, 3725, 3725, 3852], [3854, 3854, 3897, 3897, 3957], [3959, 3959, 4003, 4003, 4296], [4298, 4298, 4340, 4340, 4439], [4448, 4448, 4470, 4470, 4996], [4998, 4998, 5022, 5022, 7567], [7569, 7569, 7592, 7592, 7701], [7703, 7703, 7726, 7726, 8629], [8631, 8631, 8653, 8653, 9166], [9169, 9169, 9189, 9189, 9369], [9371, 9371, 9390, 9390, 9969], [9970, 9986, 10054, 10054, 10383], [10385, 10406, 10454, 10454, 10630], [10632, 10632, 10657, 10657, 10961], [10965, 10965, 11007, 11007, 11043], [11045, 11045, 11088, 11109, 11415], [11417, 11417, 11474, 11474, 12160]], "test": "error"}
{"id": "XtVXWw", "name": "Scrolling Squound Tunnel", "author": "cacheflowe", "description": "tunnel test from iq's demo", "tags": ["tunnel", "arrows"], "likes": 37, "viewed": 2805, "published": "Public API", "date": "1484594273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\nfloat polygon(vec2 p, int vertices, float size) {\n    float a = atan(p.x, p.y) + 0.2;\n    float b = 6.28319 / float(vertices);\n    return cos(floor(0.5 + a / b) * b - a) * length(p) - size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    \n    //////////////////////////////////////////////////////\n    // Create tunnel coordinates (p) and remap to normal coordinates (uv)\n    // Technique from @iq: https://www.shadertoy.com/view/Ms2SWW\n\t// and a derivative:   https://www.shadertoy.com/view/Xd2SWD\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\t\t// normalized coordinates (-1 to 1 vertically)\n    vec2 uvOrig = p;\n    // added twist by me ------------\n    float rotZ = 1. - 0.07 * sin(1. * sin(length(p * 1.5)));\n    p *= mat2(cos(rotZ), sin(rotZ), -sin(rotZ), cos(rotZ));\n\t//-------------------------------\n    float a = atan(p.y,p.x);\t\t\t\t\t\t\t\t\t\t\t\t// angle of each pixel to the center of the screen\n    float rSquare = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\t// modified distance metric (http://en.wikipedia.org/wiki/Minkowski_distance)\n    float rRound = length(p);\n    float r = mix(rSquare, rRound, 0.5 + 0.5 * sin(time * 2.)); \t\t\t// interp between round & rect tunnels\n    vec2 uv = vec2( 0.3/r + time, a/3.1415927 );\t\t\t\t\t\t\t// index texture by (animated inverse) radious and angle\n    //////////////////////////////////////////////////////\n\n    // subdivide to grid\n    uv += vec2(0., 0.25 * sin(time + uv.x * 2.));\t\t\t// pre-warp\n    vec2 uvDraw = fract(uv * 7. + 5. * sin(time)) - 0.5;\t// create grid\n\n    // alter polygon direction by pre-rotating coords\n    float rot = PI/2.;\n    uvDraw *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\n\n    // draw arrow\n    float antialias = 8./iResolution.y;\n    vec2 rectPos = uvDraw + vec2(0., -0.08);\n    float col = smoothstep(antialias, 0., polygon(rectPos, 4, 0.12)); \t // antialiased rect\n    vec2 triPos = uvDraw + vec2(-0.047, 0.15);\n    col = max(col, smoothstep(antialias, 0., polygon(triPos, 3, 0.12))); // antialiased triangle\n\n    // darker towards center, light towards outer\n    col = col * r * 1.5;\n    col += 0.15 * length(uvOrig);\n    fragColor = vec4(vec3(col), 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 109, 109, 251], [253, 253, 310, 310, 2269]], "test": "valid"}
{"id": "XtVXzm", "name": "Blob Multilight", "author": "Jabberwock", "description": "Multilight", "tags": ["3d"], "likes": 0, "viewed": 77, "published": "Public", "date": "1484551204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n    \n  // point light\n  vec3 lightPos = vec3(5.0*\tcos(iTime), 5.0*sin(iTime), 5.0);\n  const vec3 lightColor = vec3(0.2, 0.5, 0.2);\n  \n  vec3 lightPos1 = vec3(5.0*\tcos(iTime), 5.0*-sin(iTime), 5.0);\n  const vec3 lightColor1 = vec3(0.5, 0.2, 0.2);\n\n  // Color of the object comes from background !\n  vec3 c = 0.25*background(n);\n    \n  vec3 l = normalize(lightPos - p);\n  vec3 l1 = normalize(lightPos1 - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n  float diff1 = 0.5*(1.0+dot(n, l1));\n\n  c += diff*lightColor;\n  c += diff1*lightColor1;\n    \n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime*0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 279, 279, 378], [380, 447, 482, 482, 555], [581, 695, 741, 741, 778], [780, 871, 901, 901, 919], [921, 1009, 1039, 1039, 1062], [1064, 1110, 1132, 1132, 1328], [1330, 1370, 1401, 1401, 1621], [1623, 1728, 1779, 1779, 2214], [2216, 2321, 2378, 2378, 2829], [2832, 2852, 2878, 2878, 2950], [2952, 3013, 3041, 3063, 3672], [3814, 3814, 3871, 3871, 4624]], "test": "valid"}
{"id": "XtySDm", "name": "test marbre", "author": "XRNZ", "description": "marbre", "tags": ["marbre"], "likes": 1, "viewed": 94, "published": "Public", "date": "1484577603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Noise ---------------------------------------------------------------\n\n// Hashing function, use sin instead of table with permutations\n// n : Real value\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\n// Noise\n// x : Point in space\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 blue=vec3(0.05,0.35,0.65);\nconst vec3 deepblue=vec3(0.05,0.05,0.85);\nconst vec3 green=vec3(0.15,0.95,0.75);\nconst vec3 red=vec3(0.75,0.35,0.35);\nconst vec3 black=vec3(0.0,0.0,0.0);\nconst vec3 white=vec3(1.0,1.0,1.0);\nconst vec3 violet=vec3(0.35,0.35,0.65);\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(blue,green,v);\n}\n\n\n// Turbulence\n// p : Point\n// n : Normal\nfloat turbulence(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n// Turbulence with color\nvec3 scaled(in vec3 p,in vec3 n)\n{\n    // Add scaled noises\n    float t=turbulence(p,n);\n\n    return mix(blue,green,t);\n}\n\nfloat scaledNoise(float i,vec3 p, vec3 n){\n\n    float t=turbulence (i*p,n);;\n    t=1.0-pow((1.0-t*t),4.0);\n    t=0.5+abs(t-0.5);\n    t=1.0-pow((1.0-t*t),2.0);\n    return t;\n\n}\n\n// Marble\n// p : Point\n// n : Normal\nvec3 marble(in vec3 p,in vec3 n)\n{\n    \n    vec3 cc;\n    \n    // turbulences multiples\n    float t1=scaledNoise(7.0,p,n);\n    \n    float t2=scaledNoise(2.25,rotate(p,38.0),n);\n\n    \n    float t3=scaledNoise(2.18,rotate(p,148.0),n);\n    \n    float t4=scaledNoise(6.5,rotate(p,48.0),n);\n    \n\n\n    //couleur de base, double marbrÃ©\n    cc = 0.6*mix(black,white,t1)+0.5*mix(white, violet,t4);\n\n    //veines violettes avec falloff\n    if(t2>0.70 && t2<0.90){\n        \n    \tfloat mx = 25.0*pow((0.10-abs(0.80-t2)),1.65);\n        \n        cc =mix(cc,violet,mx);\n    }\n    \n    //veines blanches avec falloff\n    if(t3>0.70 && t3<0.90){\n        \n    \tfloat mx = 25.0*pow((0.10-abs(0.80-t3)),1.65);\n        \n        cc =mix(cc,white,mx);\n    \n    }\n\n\n    return cc;\n}\n\n// Warped checker\n// p : Point\n// n : Normal\n// a : amount of warping\nvec3 warped(in vec3 p,in vec3 n,in float a)\n{\n    return checker(p+a*noise(2.0*p),n);\n}\n\n\nvec3 wood(in vec3 p, in vec3 n)\n{\n    vec3 c1 = vec3(139,69,19);\n    vec3 c2 = vec3(205,133,63);\n    \n    \n    float d = sqrt(p.y*p.y+p.x*p.x);\n    \n   \n    p.x = p.x-0.10*noise(2.78*p);\n    //p = p + 0.1*noise(p*fract(p.x/(p.y*noise(2.0*p))));\n    \n   \n    \n    float v=0.5+0.5*sin(100.0*p.x);\n    \n    float t=turbulence (5.7*p,n);\n    \n    //t=1.0-pow((1.0-t*t),1.5);\n    \n    //t=0.5+abs(t-0.5);\n  ;\n    v = v -0.0*t + 0.0*noise(152.0*p);\n    \n    //vec3 cc = mix(c2/255.0,c1/255.0,v-2.0*noise(100.0*p));\n    vec3 cc = mix(1.3*c2/255.0,0.9*c1/255.0,pow(fract(v),2.0));\n   \n    \n    return cc;\n    \n}\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n\tvec3 oc = o-c;\n    \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n       \n    if (t<=0.0) return false;\n    \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n    \n    // Normal\n    n=(o+t*d-c)/r;\n\n   return true;\n }\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n  \n    vec3 l = normalize(lightPos - p);\n    \n        //vec3 r = normalize( 2.0*(dot(n,l))*n-l);\n      \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n \n    //float diff = 0.5*(1.0+dot(n, l));\n    \n    //float diff = dot(n, l);\n    \n    //float alpha = 12.550;\n    \n    //float diff = 0.5*(1.0+dot(n, l)) + 0.5*pow(dot(r,vec3(0.0,0.0,-1.0)),alpha);\n    \n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.0*background(n)+1.00*marble(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\t\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n\treturn c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n    \n\t// Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n\tvec3 d = normalize(vec3(uv, 1.0));\n\t\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n    \n\tvec3 n;\n    float t;\n    \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.3, t, n))\n    {\t\n        //fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n        fragColor = vec4(shade(o+d*t,n),1.0);\n    }\n    fragColor=Vignetting(fragColor,xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtySDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 158, 182, 182, 225], [227, 258, 284, 284, 653], [729, 782, 817, 817, 886], [1231, 1288, 1323, 1323, 1410], [1413, 1454, 1493, 1518, 1681], [1683, 1708, 1742, 1767, 1829], [1831, 1831, 1873, 1873, 2006], [2008, 2045, 2079, 2079, 2804], [2806, 2876, 2921, 2921, 2963], [2966, 2966, 2999, 2999, 3569], [3646, 3828, 3906, 3906, 4141], [4218, 4259, 4287, 4287, 4360], [4362, 4408, 4441, 4460, 5260], [5262, 5319, 5357, 5357, 5438], [5515, 5515, 5572, 5572, 6189]], "test": "valid"}
{"id": "XtySDV", "name": "Circleboi goes", "author": "connor_breen", "description": "Watch that circle boi go", "tags": ["time", "drawing", "overlap"], "likes": 0, "viewed": 73, "published": "Public", "date": "1485887666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rad1 = 0.1;\n    float rad2= 0.1;\n    vec2 center1 = vec2(0.2,0.2);\n    vec2 center2 = vec2(0.3,0.3);\n    vec3 col1= vec3(1.0,0.5,0.3);\n    vec3 col2= vec3(0.9,0.6,0.9);\n    vec3 col3= vec3(0.2,0.0,0.7);\n    vec3 bg = vec3(1.0,1.0,1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float offset = 0.1*sin(iTime);\n    uv.y = uv.y * (iResolution.y) / iResolution.x;\n    center1.x += offset;\n    if (distance(uv, center1) < rad1 && distance(uv,center2) < rad2)\n        fragColor = vec4(col3, 1.0);\n    else if (distance(uv, center1) < rad1)\n        fragColor = vec4(col1,1.0);\n    else if (distance(uv, center2) < rad2)\n        fragColor= vec4(col2,1.0);\n    else\n        fragColor = vec4(bg,1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtySDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 766]], "test": "valid"}
{"id": "XtySDy", "name": "Re Generators", "author": "wizgrav", "description": "Clubber rewired version of the awesome shader by kali  https://www.shadertoy.com/view/Xtf3Rn This guy is the math sculptor <3\n\nBoom Generators: https://goo.gl/XH88Gf", "tags": ["raymarching", "fractal", "clubber"], "likes": 4, "viewed": 4464, "published": "Public API", "date": "1485599935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R abs(sin(iTime))\n#define CLUBBER_G abs(cos(iTime))\n#define CLUBBER_B abs(sin(iTime*2.))\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\n// \"GENERATORS REDUX\" by Kali \n\n// Reworked by eiffie to run faster and under ANGLE:\n//\n// -Made the sphere raytraced \n// -Soft AO shadows\n// -Various great optimizations\n// \n// Thanks eiffie!!!\n\n\n// Original description:\n// Same fractal as \"Ancient Temple\" + rotations, improved shading \n// (better coloring, AO and  shadows), some lighting effects, and a path for the camera  \n// following a liquid metal ball. \n\n\n//#define ENABLE_HARD_SHADOWS // turn off to enable faster AO soft shadows \n//#define ENABLE_VIBRATION\n//#define ENABLE_POSTPROCESS // Works better on window view rather than full screen\n\n\n#define RAY_STEPS 70\n#define SHADOW_STEPS 50\n#define LIGHT_COLOR vec3(.85,.9,1.)\n#define AMBIENT_COLOR vec3(.8,.83,1.)\n#define FLOOR_COLOR vec3(1.,.7,.9)\n#define ENERGY_COLOR vec3(1.,.7,.4)\n#define BRIGHTNESS .9\n#define GAMMA 1.3\n#define SATURATION .85\n\n\n#define detail .00005\n#define t iTime*.25\n\n\n\nvec3 lightdir=normalize(vec3(0.5,-0.3,-1.));\nvec3 ambdir=normalize(vec3(0.,0.,1.));\nconst vec3 origin=vec3(0.,3.11,0.);\nvec3 energy=vec3(0.01);\n#ifdef ENABLE_VIBRATION\nfloat vibration=sin(iTime*60.)*.0013;\n#else\nfloat vibration=0.;\n#endif\nfloat det=0.0;\nvec3 pth1;\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nvec3 path(float ti) {\nreturn vec3(sin(ti),.4-sin(ti*.632)*.3,cos(ti*.5))*.5;\n}\n\nfloat Sphere(vec3 p, vec3 rd, float r){//A RAY TRACED SPHERE\n\tfloat b = dot( -p, rd );\n\tfloat inner = b * b - dot( p, p ) + r * r;\n\tif( inner < 0.0 ) return -1.0;\n\treturn b - sqrt( inner );\n}\n\nvec2 de(vec3 pos) {\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.xz=abs(.5-mod(tpos.xz,1.));\n\tvec4 p=vec4(tpos,1.);\n\tfloat y=max(0.,.35-abs(pos.y-3.35))/.35;\n\tfor (int i=0; i<8; i++) {//LOWERED THE ITERS\n\t\tp.xyz = abs(p.xyz)-vec3(-0.02,1.98,-0.02);\n\t\tp=p*(2.0+vibration*y)/clamp(dot(p.xyz,p.xyz),.4,1.)-vec4(0.5,1.,0.4,0.);\n\t\tp.xz*=mat2(-0.416, -0.91,mix(0.7,.91,CLUBBER_G),mix(-0.8,-.416,CLUBBER_B));\n\t}\n\tfloat fl=pos.y-3.013;\n\tfloat fr=(length(max(abs(p.xyz)-vec3(0.1,5.0,0.1),vec3(0.0)))-0.05)/p.w;//RETURN A RRECT\n\t//float fr=length(p.xyz)/p.w;\n\tfloat d=min(fl,fr);\n\td=min(d,-pos.y+3.95);\n\tif (abs(d-fl)<.001) hid=1.;\n\treturn vec2(d,hid);\n}\n\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx).x-de(p-e.yxx).x,\n\t\t\tde(p+e.xyx).x-de(p-e.xyx).x,\n\t\t\tde(p+e.xxy).x-de(p-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {//THIS ONLY RUNS WHEN WITH HARD SHADOWS\n\tfloat sh=1.0;\n\tfloat totdist =2.0*det;\n\tfloat dist=10.;\n\tfloat t1=Sphere((pos-.005*sdir)-pth1,-sdir,0.015);\n\tif (t1>0. && t1<.5) {\n\t\tvec3 sphglowNorm=normalize(pos-t1*sdir-pth1);\n\t\tsh=1.-pow(max(.0,dot(sphglowNorm,sdir))*1.2,3.);\n\t} \n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<.6 && dist>detail) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p).x;\n\t\t\t\tsh = min( sh, max(50.*dist/totdist,0.0) );\n\t\t\t\ttotdist += max(.01,dist);\n\t\t\t}\n\t\t}\n\t\n    return clamp(sh,0.1,1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*40.;\n\tfloat totao = 0.0;\n    float sca = 14.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - 5.0*totao, 0., 1.0 );\n}\n\nfloat texture(vec3 p) {\n\tp=abs(.5-fract(p*10.));\n\tvec3 c=vec3(3.);\n\tfloat es, l=es=0.;\n\tfor (int i = 0; i < 10; i++) { \n\t\t\tp = abs(p + c) - abs(p - c) - p; \n\t\t\tp/= clamp(dot(p, p), .0, 1.);\n\t\t\tp = p* -1.5 + c;\n\t\t\tif ( mod(float(i), 2.) < 1. ) { \n\t\t\t\tfloat pl = l;\n\t\t\t\tl = length(p);\n\t\t\t\tes+= exp(-1. / abs(l - pl));\n\t\t\t}\n\t}\n\treturn es;\n}\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {//PASSING IN THE NORMAL\n\t#ifdef ENABLE_HARD_SHADOWS\n\t\tfloat sh=shadow(p, lightdir);\n\t#else\n\t\tfloat sh=calcAO(p,-2.5*lightdir);//USING AO TO MAKE VERY SOFT SHADOWS\n\t#endif\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh;\n\tfloat y=3.35-p.y;\n\tvec3 amb=max(.5,dot(dir,-n))*.5*AMBIENT_COLOR;\n\tif (hid<.5) {\n\t\tamb+=max(0.2,dot(vec3(0.,1.,0.),-n))*FLOOR_COLOR*pow(max(0.,.2-abs(3.-p.y))/.2,1.5)*2.;\n\t\tamb+=energy*pow(max(0.,.4-abs(y))/.4,2.)*max(0.2,dot(vec3(0.,-sign(y),0.),-n))*2.;\n\t}\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,10.);\n\tvec3 col;\n\tfloat energysource=pow(max(0.,.04-abs(y))/.04,4.)*2.;\n\tif (hid>1.5) {col=vec3(1.); spec=spec*spec;}\n\telse{\n\t\tfloat k=texture(p)*.23+.2; \n\t\tk=min(k,1.5-energysource);\n\t\tcol=mix(vec3(k,k*k,k*k*k),vec3(k),.3);\n\t\tif (abs(hid-1.)<.001) col*=FLOOR_COLOR*1.3;\n\t}\n\tcol=col*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;\t\n\tif (hid<.5) { \n\t\tcol=max(col,energy*2.*energysource);\n\t}\n\tcol*=min(1.,ao+length(energy)*.5*max(0.,.1-abs(y))/.1);\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tfloat ey=mod(t*.5 + (CLUBBER_A),1.);\n\tfloat glow,eglow,ref,sphdist,totdist=glow=eglow=ref=sphdist=0.;\n\tvec2 d=vec2(1.,0.);\n\tvec3 p, col=vec3(0.);\n\tvec3 origdir=dir,origfrom=from,sphNorm;\n\t\n\t//FAKING THE SQUISHY BALL BY MOVING A RAY TRACED BALL\n\tvec3 wob=cos(dir*500.0*length(from-pth1)+(from-pth1)*250.+iTime*10.)*0.0005;\n\tfloat t1=Sphere(from-pth1+wob,dir,mix(0.,0.02,CLUBBER_R));\n\tfloat tg=Sphere(from-pth1+wob,dir,mix(0.0,0.03,CLUBBER_R));\n\tif(t1>0.){\n\t\tref=1.0;from+=t1*dir;sphdist=t1;\n\t\tsphNorm=normalize(from-pth1+wob);\n\t\tdir=reflect(dir,sphNorm);\n\t} \n\telse if (tg>0.) { \n\t\tvec3 sphglowNorm=normalize(from+tg*dir-pth1+wob);\n\t\tglow+=pow(max(0.,dot(sphglowNorm,-dir)),5.);\n\t};\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d.x>det && totdist<3.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*60.)*(1.+ref*5.);\n\t\t\ttotdist+=d.x; \n\t\t\tenergy=ENERGY_COLOR*(1.5+sin(iTime*20.+p.z*10. + 6.*(CLUBBER_R)))*.25;\n\t\t\tif(d.x<0.015)glow+=max(0.,.015-d.x)*exp(-totdist);\n\t\t\tif (d.y<.5 && d.x<0.03){//ONLY DOING THE GLOW WHEN IT IS CLOSE ENOUGH\n\t\t\t\tfloat glw=min(abs(3.35-p.y-ey),abs(3.35-p.y+ey));//2 glows at once\n\t\t\t\teglow+=max(0.,.03-d.x)/.03*\n\t\t\t\t(pow(max(0.,.05-glw)/.05,5.)\n\t\t\t\t+pow(max(0.,.15-abs(3.35-p.y))/.15,8.))*1.5;\n\t\t\t}\n\t\t}\n\t}\n\tfloat l=pow(max(0.,dot(normalize(-dir.xz),normalize(lightdir.xz))),2.);\n\tl*=max(0.2,dot(-dir,lightdir));\n\tvec3 backg=.5*(1.2-l)+LIGHT_COLOR*l*.7;\n\tbackg*=AMBIENT_COLOR;\n\tif (d.x<=det) {\n\t\tvec3 norm=normal(p-abs(d.x-det)*dir);//DO THE NORMAL CALC OUTSIDE OF LIGHTING (since we already have the sphere normal)\n\t\tcol=light(p-abs(d.x-det)*dir, dir, norm, d.y)*exp(-.2*totdist*totdist); \n\t\tcol = mix(col, backg, 1.0-exp(-1.*pow(totdist,1.5)));\n\t} else { \n\t\tcol=backg;\n\t}\n\tvec3 lglow=LIGHT_COLOR*pow(l,30.)*.5;\n\tcol+=glow*(backg+lglow)*1.3;\n\tcol+=pow(eglow,2.)*energy*.015;\n\tcol+=lglow*min(1.,totdist*totdist*.3);\n\tif (ref>0.5) {\n\t\tvec3 sphlight=light(origfrom+sphdist*origdir,origdir,sphNorm,2.);\n\t\tcol=mix(col*.3+sphlight*.7,backg,1.0-exp(-1.*pow(sphdist,1.5)));\n\t}\n\treturn col; \n}\n\nvec3 move(inout mat2 rotview1,inout mat2 rotview2) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=atan(advec.x,advec.z);\n\trotview1=mat2(cos(an),sin(an),-sin(an),cos(an));\n\t\t  an=advec.y*1.7;\n\trotview2=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tpth1 = path(t+.3)+origin+vec3(0.,.01,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tvec2 uv2=uv;\n#ifdef ENABLE_POSTPROCESS\n\tuv*=1.+pow(length(uv2*uv2*uv2*uv2),4.)*.07;\n#endif\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.);\n\tmat2 rotview1, rotview2;\n\tvec3 from=origin+move(rotview1,rotview2);\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x);\n\tdir.yz*=rotview2;\n\tdir.xz*=rotview1;\n\tvec3 color=raymarch(from,dir); \n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tcolor=pow(color,vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n#ifdef ENABLE_POSTPROCESS\n\tvec3 rain=pow(texture(iChannel0,uv2+iTime*7.25468).rgb,vec3(1.5));\n\tcolor=mix(rain,color,clamp(iTime*.5-.5,0.,1.));\n\tcolor*=1.-pow(length(uv2*uv2*uv2*uv2)*1.1,6.);\n\tuv2.y *= iResolution.y / 360.0;\n\tcolor.r*=(.5+abs(.5-mod(uv2.y     ,.021)/.021)*.5)*1.5;\n\tcolor.g*=(.5+abs(.5-mod(uv2.y+.007,.021)/.021)*.5)*1.5;\n\tcolor.b*=(.5+abs(.5-mod(uv2.y+.014,.021)/.021)*.5)*1.5;\n\tcolor*=.9+rain*.35;\n#endif\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtySDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1443, 1443, 1462, 1462, 1509], [1512, 1512, 1533, 1533, 1590], [1592, 1592, 1631, 1652, 1783], [1785, 1785, 1804, 1804, 2421], [2424, 2424, 2445, 2445, 2608], [2610, 2610, 2645, 2684, 3181], [3184, 3184, 3232, 3232, 3554], [3556, 3556, 3579, 3579, 3893], [3895, 3895, 3956, 3979, 4975], [4977, 4977, 5021, 5021, 7046], [7048, 7048, 7100, 7100, 7338], [7341, 7341, 7398, 7398, 8505]], "test": "valid"}
{"id": "XtySWy", "name": "Spirals all the way down", "author": "al13n", "description": "A rope consisting of two ropes (defined recursively) twisted in a spiral.\n\nUse mouse to stop and move around.", "tags": ["raymarching", "fractal", "spiral"], "likes": 35, "viewed": 908, "published": "Public API", "date": "1485563502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define R .3\n#define S .2\n#define its 1\n\nvec3 color;\n\nfloat DE(vec3 p) {\n    float which0;\n    for (int i = 0; i < its; ++i) {\n        float r = length(p.xy)-1.;\n        float a = atan(p.y, p.x)/PI + fract((sqrt(float(i)+1.)-1.)*iTime/3.)*2.;\n        float t = p.z/(R*2.)-a+.5;\n        float z = floor(t)+a;\n        p = vec3(r,p.z-z*R*2., z)/S;\n        float which = step(.5, fract(t*.5));\n        if (i == 0) {\n            which0 = which;\n            color += vec3(1, 1, 1) * step(.95, fract(p.z/100.+which*.5-iTime/6.));\n        } else if (i == 1) {\n            color -= vec3(0,.5,.5)*which;\n            color.y = step(.5, fract(p.z/1.+iTime)) * (1.-which0);\n        } else if (i == 2) {\n            color -= vec3(.5,0,.5)*which*(1.-which0);\n        } else if (i == 3) {\n            color -= vec3(1,1,0)*which;\n        } else if (i == 4) {\n           color *= 1.+.5*which;\n        }\n    }\n    if (which0 > .5)\n        color = color.yzx;\n    return (length(p.xy)-1.)*pow(S,float(its));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    vec3 origin;\n    if (iMouse.z <= 0.)\n        origin = vec3(vec2(cos(iTime*1.1),sin(iTime*1.7)) * .4, fract(iTime/60.)*60.*2.);\n    else\n        origin = vec3((iMouse.xy-iMouse.zw) / iResolution.xy * 2., 0.);\n    float unit_pixsize = 1./(iResolution.x+iResolution.y);\n\n    vec3 direction = normalize(vec3(uv, 1));\n    \n    const float diameter = 1000.;\n    const int maxit = 50;\n    \n    vec3 p = origin;\n    int it = maxit;\n    for (int i = 1; i <= maxit; ++i) {\n        if (length(p - origin) > diameter) {\n            color = vec3(1,1,1);\n            it = i;\n            break;\n        }\n        color = vec3(1,1,1);\n        float d = DE(p);\n        float pixsize = unit_pixsize * distance(p, origin);\n        if (d < pixsize*.1) {\n            it = i;\n            break;\n        }\n        p += direction * d;\n    }\n\n    float t = 1. - float(it) / float(maxit);\n    fragColor = vec4(color*t,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtySWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 117, 117, 1033], [1035, 1035, 1092, 1092, 2059]], "test": "valid"}
{"id": "XtyXRK", "name": "Voronoi Experiment 8", "author": "aiekick", "description": "Voronoi Experiment 8", "tags": ["voronoi", "experiment", "8"], "likes": 4, "viewed": 437, "published": "Public API", "date": "1484869304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nfloat df(vec2 uv)\n{\n\treturn max(abs(uv.x)*.866 - uv.y*.5,uv.y);\n}\n\nvoid mainImage( out vec4 fC, vec2 fG )\n{\n\tvec2 p = fG /= iResolution.y / 10.;\n\t\n    float d = 9.;\n    \n    for(int x=-3;x<=3;x++)\n    for(int y=-3;y<=3;y++)\n    {\t\n        p = vec2(x,y);\n        vec2 a = sin( iTime + 9. * fract(sin((floor(fG)+p)*mat2(2,5,5,2))));\n\t\tp += .5 + .35*a - fract(fG);\n        p *= mat2(cos(a.x),-sin(a.x),sin(a.x),cos(a.x)) * cos(a.y*1.5) * 5.;\n        d = min(d, df(p));\n    }\n\t\n\tfC = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyXRK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 138, 157, 157, 203], [205, 205, 245, 245, 628]], "test": "valid"}
{"id": "XtyXWz", "name": "kifs-variant", "author": "nshelton", "description": "pulsing ifs. control the iteration offset with a mouse click and drag.\nfog is dynamically set based on iteration count, decrease for higher fps", "tags": ["raymarch", "ifs"], "likes": 17, "viewed": 667, "published": "Public API", "date": "1483750638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define MAX_ITER 20\n#define MAX_ITER 50\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nmat3 ir;\n\nfloat DE(vec3 p) \n{\n\tvec3 p_o = p;\n    float d = 1e10;\n    \n    float s = 1.; //sin(iTime /60.0) / 10.0 + 0.6;\n    vec3 t = vec3(0.1 + 0.2 * iMouse.xy/iResolution.xy, 0.1 + 0.1 * sin(iTime/200.));\n    \n    \n    vec3 dim = vec3(0.01, 0.9, 0.02);\n    \n    for ( int i = 0; i < 6; i ++)\n    {\n        p -= t*s;\n        p = (ir * (p-t/s));\n        \n     \td = min\t(d, udBox(p*s, dim/s  )/s ) ;\n\n \t\tp = abs(p);\n        \n        float circleSize = 0.03 * (sin(iTime + length(p_o) * 5.) ) + 0.01;\n        d = min(d, length(p - t) - circleSize/s);\n        s *= s;\n\t\t\n    }\n\n\n    return d;\n}\n\n\nfloat lighting( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.01;\n    \n    float k = 12.0;\n    \n    for( int i = 0; i < 2; i++ )\n    {\n        float h = DE(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        \n        res = min( res,k * h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 gradient(vec3 p) {\n\tvec2 e = vec2(0., 0.0001);\n\n\treturn normalize(\n\t\tvec3(\n\t\t\tDE(p+e.yxx) - DE(p-e.yxx),\n\t\t\tDE(p+e.xyx) - DE(p-e.xyx),\n\t\t\tDE(p+e.xxy) - DE(p-e.xxy)\n\t\t)\n\t);\n}\n\n\n\n\n//http://iquilezles.org/www/articles/fog/fog.htm\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float b = .9 + 20.0 / float(MAX_ITER);\n    float fogAmount = 1.0 - exp( -distance*b );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.1,0.1,0.0), \n                           vec3(1.0,0.9,0.7),\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    vec3 cam = vec3(0,0, - sin(iTime /32. ) - 2.0);\n    vec3 ray = normalize( vec3(uv, 1.0));\n    \n    vec3 color = vec3(0.1, 0.1, 0.2);\n    vec3 p;\n    float depth = 0.0;\n    bool hit = false;\n    float iter = 0.0;\n    \n    float fog = 0.0;\n    vec3 sun = normalize( vec3(1,1,1));\n\n    ir = rotationMatrix(normalize(vec3(sin(iTime/50.0),sin(iTime/100.0),sin(iTime/150.0))), 1.5 + iTime/30.0);\n    \n    mat3 mv = rotationMatrix(vec3(0,1,0), iTime/10.0);\n        \n    cam = mv * cam;\n    ray = mv * ray;\n        \n    for( int i= 0; i < MAX_ITER; i ++) {\n        p = depth * ray + cam;\n        float dist = DE(p);\n        \n  \n        \tdepth += dist;\n         \n        \n        if ( dist < 0.001)\n        {\n        \thit = true;\n            break;\n        }\n        \n        iter ++;\n    }\n    float fakeAO = 1.0 - iter / float(MAX_ITER);    \n    vec3 n = gradient(p);\n    \n\n    if (hit) {\n    \tcolor = vec3(fakeAO + dot(-ray,n) / 2.0);\n    }\n\n    \n   //color *= fakeAO;\n    \n\tcolor = applyFog(color, depth, ray, sun) ;\n    \n    color *= vec3(1.0 - fog);\n    \n    color = pow(color, vec3(0.7));\n\n    \n\tfragColor = vec4(color ,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 88, 88, 528], [531, 531, 562, 562, 600], [612, 612, 631, 631, 1193], [1196, 1196, 1237, 1237, 1509], [1511, 1511, 1534, 1534, 1689], [1694, 1743, 1988, 1988, 2324], [2327, 2327, 2384, 2384, 3644]], "test": "valid"}
{"id": "XtyXzD", "name": "Dancing Stickman", "author": "voz", "description": "Dancing,Stickman", "tags": ["dancing", "stickman"], "likes": 5, "viewed": 549, "published": "Public API", "date": "1484183487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, .5, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere(vec3 rp, vec3 bp, float r) {\n    return length(bp - rp) - r;\n}\n\nfloat sdCapsule(vec3 rp, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\nvec4  stance[NUM_ANGLES];\nfloat shoulderRot = 0.0;\nfloat hipRot = 0.0;\nfloat lean = 0.0;\n\n//body joints\nvec3 head = vec3(0.0);\n\nvec3 bSpine = vec3(0.0);\nvec3 uSpine = vec3(0.0);\n\nvec3 leftShoulder = vec3(0.0);\nvec3 rightShoulder = vec3(0.0);\n\nvec3 leftElbow = vec3(0.0);\nvec3 rightElbow = vec3(0.0);\n\nvec3 leftWrist = vec3(0.0);\nvec3 rightWrist = vec3(0.0);\n\nvec3 leftFinger = vec3(0.0);\nvec3 rightFinger = vec3(0.0);\n\nvec3 leftHip = vec3(0.0);\nvec3 rightHip = vec3(0.0);\n\nvec3 leftKnee = vec3(0.0);\nvec3 leftAnkle = vec3(0.0);\n\nvec3 rightKnee = vec3(0.0);\nvec3 rightAnkle = vec3(0.0);\n\nconst vec3 downY = vec3(0.0, -1.0, 0.0);\nfloat minY = 0.0;\n\nvoid load_stance() {\n    \n    head = vec3(0.0, GR/E, 0.0);\n    \n    ///////////////////////////////////////////////////////////////\n    //Spine////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = head/GR;\n    uSpine = -bSpine;\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulders////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    leftShoulder = bSpine+vec3(1.0, 0.0, 0.0)/E;\n    rightShoulder = bSpine-vec3(1.0, 0.0, 0.0)/E;\n    \n    ///////////////////////////////////////////////////////////////\n    //Elbows///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftElbow = downY/GR;\n\n    float leftArmOmega = stance[ELBOWS].x;\n    float leftArmTheta = stance[ELBOWS].y;\n    \n    hangingLeftElbow = rotatePoint(rotatePoint(hangingLeftElbow, vec3(1.0, 0.0, 0.0), leftArmOmega), vec3(0.0, 0.0, 1.0), leftArmTheta);\n    \n    leftElbow = leftShoulder+hangingLeftElbow;\n        \n    vec3 hangingRightElbow = downY/GR;\n    \n    float rightArmOmega = stance[ELBOWS].z;\n    float rightArmTheta = stance[ELBOWS].w;\n    \n    hangingRightElbow = rotatePoint(rotatePoint(hangingRightElbow, vec3(1.0, 0.0, 0.0), rightArmOmega), vec3(0.0, 0.0, -1.0), rightArmTheta);\n    \n    rightElbow = rightShoulder+hangingRightElbow;\n    \n    ///////////////////////////////////////////////////////////////\n    //Wrists///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftWrist = downY/E;\n\n    float leftForeArmOmega = leftArmOmega+stance[WRISTS].x;\n    float leftForeArmTheta = leftArmTheta+stance[WRISTS].y;\n    \n    straightLeftWrist = rotatePoint(rotatePoint(straightLeftWrist, vec3(1.0, 0.0, 0.0), leftForeArmOmega), vec3(0.0, 0.0, 1.0), leftForeArmTheta);\n    \n    leftWrist = leftElbow+straightLeftWrist;\n        \n    vec3 straightRightWrist = downY/E;\n    \n    float rightForeArmOmega = rightArmOmega+stance[WRISTS].z;\n    float rightForeArmTheta = rightArmTheta+stance[WRISTS].w;\n    \n    straightRightWrist = rotatePoint(rotatePoint(straightRightWrist, vec3(1.0, 0.0, 0.0), rightForeArmOmega), vec3(0.0, 0.0, -1.0), rightForeArmTheta);\n    \n    rightWrist = rightElbow+straightRightWrist;\n    \n    ///////////////////////////////////////////////////////////////\n    //Fingers//////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftFingers = downY/PI/E;\n\n    float leftFingersOmega = leftForeArmOmega+stance[FINGERS].x;\n    float leftFingersTheta = leftForeArmTheta+stance[FINGERS].y;\n    \n    straightLeftFingers = rotatePoint(rotatePoint(straightLeftFingers, vec3(1.0, 0.0, 0.0), leftFingersOmega), vec3(0.0, 0.0, 1.0), leftFingersTheta);\n    \n    leftFinger = leftWrist+straightLeftFingers;\n        \n    vec3 straightRightFingers = downY/PI/E;\n    \n    float rightFingersOmega = rightForeArmOmega+stance[FINGERS].z;\n    float rightFingersTheta = rightForeArmTheta+stance[FINGERS].w;\n    \n    straightRightFingers = rotatePoint(rotatePoint(straightRightFingers, vec3(1.0, 0.0, 0.0), rightFingersOmega), vec3(0.0, 0.0, -1.0), rightFingersTheta);\n    \n    rightFinger = rightWrist+straightRightFingers;\n    \n    \n    ///////////////////////////////////////////////////////////////\n    //Hips/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    leftHip = uSpine+vec3(circle(hipRot), 0.0).xzy/E/GR;\n    rightHip = uSpine-vec3(circle(hipRot), 0.0).xzy/E/GR;\n    ///////////////////////////////////////////////////////////////\n    //Knees////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftKnee = downY/GR;\n\n    float leftKneeOmega = stance[KNEES].x;\n    float leftKneeTheta = stance[KNEES].y;\n    \n    hangingLeftKnee = rotatePoint(rotatePoint(hangingLeftKnee, vec3(1.0, 0.0, 0.0), leftKneeOmega), vec3(0.0, 0.0, 1.0), leftKneeTheta);\n    \n    leftKnee = leftHip+hangingLeftKnee;\n        \n    vec3 hangingRightKnee = downY/GR;\n    \n    float rightKneeOmega = stance[KNEES].z;\n    float rightKneeTheta = stance[KNEES].w;\n    \n    hangingRightKnee = rotatePoint(rotatePoint(hangingRightKnee, vec3(1.0, 0.0, 0.0), rightKneeOmega), vec3(0.0, 0.0, -1.0), rightKneeTheta);\n    \n    rightKnee = rightHip+hangingRightKnee;\n    \n    ///////////////////////////////////////////////////////////////\n    //Ankles///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 straightLeftAnkle = downY/GR;\n\n    float leftAnkleOmega = leftKneeOmega+stance[ANKLES].x;\n    float leftAnkleTheta = leftKneeTheta+stance[ANKLES].y;\n    \n    straightLeftAnkle = rotatePoint(rotatePoint(straightLeftAnkle, vec3(1.0, 0.0, 0.0), leftAnkleOmega), vec3(0.0, 0.0, 1.0), leftAnkleTheta);\n    \n    leftAnkle = leftKnee+straightLeftAnkle;\n        \n    vec3 straightRightAnkle = downY/GR;\n    \n    float rightAnkleOmega = rightKneeOmega+stance[ANKLES].z;\n    float rightAnkleTheta = rightKneeTheta+stance[ANKLES].w;\n    \n    straightRightAnkle = rotatePoint(rotatePoint(straightRightAnkle, vec3(1.0, 0.0, 0.0), rightAnkleOmega), vec3(0.0, 0.0, -1.0), rightAnkleTheta);\n    \n    rightAnkle = rightKnee+straightRightAnkle;\n    \n    ///////////////////////////////////////////////////////////////\n    //Lean/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = rotatePoint(bSpine, vec3(1.0, 0.0, 0.0), lean);\n    head = rotatePoint(head, vec3(1.0, 0.0, 0.0), lean);\n    \n    leftShoulder = rotatePoint(leftShoulder, vec3(1.0, 0.0, 0.0), lean);\n    rightShoulder = rotatePoint(rightShoulder, vec3(1.0, 0.0, 0.0), lean);\n    leftElbow = rotatePoint(leftElbow, vec3(1.0, 0.0, 0.0), lean);\n    rightElbow = rotatePoint(rightElbow, vec3(1.0, 0.0, 0.0), lean);\n    leftWrist = rotatePoint(leftWrist, vec3(1.0, 0.0, 0.0), lean);\n    rightWrist = rotatePoint(rightWrist, vec3(1.0, 0.0, 0.0), lean);\n    leftFinger = rotatePoint(leftFinger, vec3(1.0, 0.0, 0.0), lean);\n    rightFinger = rotatePoint(rightFinger, vec3(1.0, 0.0, 0.0), lean);\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulder Rotation////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n\n    leftShoulder = rotatePoint(leftShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightShoulder = rotatePoint(rightShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftElbow = rotatePoint(leftElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightElbow = rotatePoint(rightElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftWrist = rotatePoint(leftWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightWrist = rotatePoint(rightWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftFinger = rotatePoint(leftFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightFinger = rotatePoint(rightFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    \n    ///////////////////////////////////////////////////////////////\n    //Hip Rotation/////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    //MIN calc\n \tfloat lowestY = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(bSpine.y, uSpine.y),\n                                                                            leftShoulder.y),\n                                                                        rightShoulder.y),\n                                                                    leftElbow.y),\n                                                                rightElbow.y),\n                                                            leftWrist.y),\n                                                        rightWrist.y),\n                                                    leftFinger.y), \n                                                rightFinger.y), \n                                            leftHip.y), \n                                        rightHip.y), \n                                    leftKnee.y), \n                                leftAnkle.y),\n                            rightKnee.y),\n                        rightAnkle.y);\n    minY = min(lowestY, minY);\n}\n\nfloat dfScene(vec3 rp) {\n    \n    float msd = 99.0;\n    \n    //hip\n    msd = min(msd, sdSphere(rp, leftHip, 0.06));\n    msd = min(msd, sdSphere(rp, rightHip, 0.06));\n    msd = min(msd, sdCapsule(rp, leftHip, rightHip, 0.02));\n    //left thigh\n    msd = min(msd, sdSphere(rp, leftKnee, 0.05));\n    msd = min(msd, sdCapsule(rp, leftHip, leftKnee, 0.02));\n    //left shin\n    msd = min(msd, sdSphere(rp, leftAnkle, 0.04));\n    msd = min(msd, sdCapsule(rp, leftKnee, leftAnkle, 0.015));\n    //right thigh\n    msd = min(msd, sdSphere(rp, rightKnee, 0.05));\n    msd = min(msd, sdCapsule(rp, rightHip, rightKnee, 0.02));\n    //right shin\n    msd = min(msd, sdSphere(rp, rightAnkle, 0.04));\n    msd = min(msd, sdCapsule(rp, rightKnee, rightAnkle, 0.015));\n    //spine\n    msd = min(msd, sdSphere(rp, bSpine, 0.04));\n    msd = min(msd, sdSphere(rp, uSpine, 0.04));\n    msd = min(msd, sdCapsule(rp, bSpine, uSpine, 0.02));\n    //shoulder\n    msd = min(msd, sdSphere(rp, leftShoulder, 0.05));\n    msd = min(msd, sdSphere(rp, rightShoulder, 0.05));\n    msd = min(msd, sdCapsule(rp, leftShoulder, rightShoulder, 0.02));\n    //left upper arm\n    msd = min(msd, sdSphere(rp, leftElbow, 0.04));\n    msd = min(msd, sdCapsule(rp, leftShoulder, leftElbow, 0.02));\n    //left lower arm\n    msd = min(msd, sdSphere(rp, leftWrist, 0.03));\n    msd = min(msd, sdCapsule(rp, leftElbow, leftWrist, 0.015));\n    //left finger\n    msd = min(msd, sdSphere(rp, leftFinger, 0.015));\n    msd = min(msd, sdCapsule(rp, leftWrist, leftFinger, 0.01));\n    //right upper arm \n    msd = min(msd, sdSphere(rp, rightElbow, 0.04));\n    msd = min(msd, sdCapsule(rp, rightShoulder, rightElbow, 0.02));\n    //right lower arm\n    msd = min(msd, sdSphere(rp, rightWrist, 0.03));\n    msd = min(msd, sdCapsule(rp, rightElbow, rightWrist, 0.015));\n    //right finger\n    msd = min(msd, sdSphere(rp, rightFinger, 0.015));\n    msd = min(msd, sdCapsule(rp, rightWrist, rightFinger, 0.01));\n    //head\n    msd = min(msd, sdSphere(rp, head, 0.15));\n    \n    return msd;\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 32; i++) {\n        rp = ro + rd * d;\n        float ns = dfScene(rp);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = vec3(1.0, 0.0, 0.0); //surface colour\n        vec3 n = surfaceNormal(rp);\n        float ao = calcAO(rp, n);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\nconst int numWeights = 512;\n\nvec3 weights[numWeights];\n\nfloat lowAverage()\n{\n    const int iters = numWeights;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.25)).r;\n        \n        product *= sound;\n        sum += sound;\n        \n        weights[i].r = sound;\n    }\n    for(int i = 0; i < iters; i++)\n        weights[i].gb = vec2(sum/float(iters), pow(product, 1.0/float(iters)));\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nvoid dance1()\n{\n    float height = max(lowAverage(), last_height)-1.0/60.0;\n    float beat = clip(height);\n\n    last_height = height;\n    \n\tfloat twist = time;\n    \n    stance[KNEES].xz = vec2(saw(beat*2.0));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    vec2 twistCircle = circle(twist*GR);\n    \n    stance[ELBOWS].x = twistCircle.x*beat;\n    stance[ELBOWS].y = twistCircle.x/PI*beat;\n    stance[ELBOWS].z = twistCircle.y*beat;\n    stance[ELBOWS].w = twistCircle.y/PI*beat;\n    \n    stance[WRISTS].x = (stance[ELBOWS].x*.5+.5)*beat;\n    stance[WRISTS].z = (stance[ELBOWS].z*.5+.5)*beat;\n    \n    shoulderRot = sin(PI+twist*PI*3.0)/PI/GR*beat;\n    hipRot = sin(twist*PI*3.0)/PI/GR*beat;\n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    dance1();\n    \n    load_stance();\n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, minY+1.25, -3.5);\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [{"id": "4sSGzc", "previewfilepath": "https://soundcloud.com/little_rea/you-oughta-know-alanis", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/little_rea/you-oughta-know-alanis", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1023, 1023, 1042, 1042, 1094], [1096, 1096, 1139, 1139, 1173], [1175, 1175, 1226, 1226, 1356], [2854, 2854, 2874, 2874, 11678], [11680, 11680, 11704, 11704, 13697], [13699, 13699, 13727, 13727, 14029], [14031, 14036, 14070, 14070, 14363], [14365, 14378, 14413, 14413, 15166], [15224, 15224, 15244, 15244, 15739], [15741, 15741, 15756, 15756, 16489], [16492, 16492, 16547, 16547, 17060]], "test": "timedout"}
{"id": "XtyXzw", "name": "Warp Vortex", "author": "cacheflowe", "description": "A simple radial vortex, with new learnings about smoothstep() and a simple vignette", "tags": ["displacement", "radial"], "likes": 11, "viewed": 966, "published": "Public API", "date": "1483462391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.;\t\t\t\t\t\t\t\t\t// adjust time\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    float rads = atan(uv.x, uv.y);                   \t\t\t\t// get radians to center\n\tfloat dist = length(uv);\t\t\t\t\t\t\t\t\t\t// store distance to center\n    float spinAmp = 4.;\t\t\t\t\t\t\t\t\t\t\t\t// set spin amplitude\n    float spinFreq = 2. + sin(time) * 0.5;\t\t\t\t\t\t\t// set spin frequency\n    rads += sin(time + dist * spinFreq) * spinAmp;\t\t\t\t\t// wave based on distance + time\n    float radialStripes = 10.;\t\t\t\t\t\t\t\t\t\t// break the circle up\n    float col = 0.5 + 0.5 * sin(rads * radialStripes);\t\t\t\t// oscillate color around the circle\n\tcol = smoothstep(0.5,0.6, col);\t\t\t\t\t\t\t\t\t// remap color w/smoothstep to remove blurriness\n    col -= dist / 2.;\t\t\t\t\t\t\t\t\t\t\t\t// vignette - reduce color w/distance\n    fragColor = vec4(vec3(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 116, 116, 974]], "test": "valid"}
