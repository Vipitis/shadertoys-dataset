{"id": "4l33WS", "name": "Blackwatch Modern Tartan", "author": "flowb", "description": "//for Scottish Tartan Pattern challenge http://thebookofshaders.com/09/", "tags": ["procedural", "patterns", "tiling"], "likes": 5, "viewed": 551, "published": "Public API", "date": "1471098045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\"BLACKWATCH MODERN\" TARTAN PATTERN by florian mosleh (flowb)\n//reference: http://www.scotclans.com/scottish-clans/tartan-pattern-book/b/\n//for Scottish Tartan Pattern challenge http://thebookofshaders.com/09/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926536\n\n//colors\n\nvec3 tGreen = vec3(4./255.,88./255.,56./255.);\nvec3 tPurpl = vec3(44./255.,44./255.,129./255.);\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st) * smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    //uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvec2 tile(vec2 _st, float scale){\n\treturn fract(_st*scale);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mat2 spinny = rotate2d(-PI+sin(iTime/20.));\n\tfloat scale=1.+sin(iTime/10.)/30.;\n    vec2 st = (fragCoord.xy/iResolution.xy);\n    st.x *= iResolution.x/iResolution.y;\n\n    vec3 colorV = vec3(0.);\n    vec3 colorH = vec3(0.);\n    vec3 color = vec3(0.);\n    \n    vec2 stD = st;\n    st = st-0.5;\n    st = st * spinny;\n    st = tile(st+0.5,scale);\n\t\n    //green\n    vec2 stG = fract(st*2.+vec2(.5));\n    \n    colorV = tGreen*(box(stG-vec2(.092,0.),vec2(1./6.,2.),0.)+box(stG+vec2(.092,0.),vec2(1./6.,2.),0.));\n    colorH = tGreen*(box(stG-vec2(0.,.092),vec2(2.,1./6.),0.)+box(stG+vec2(0.,.092),vec2(2.,1./6.),0.));\n    \n    //purpl\n    vec2 stP = fract(st*1.);\n    \n    colorV += tPurpl * ( box(stP-vec2(.25,0.),vec2(1./10.,2.),0.) + \n    \t\t\t\t\tbox(stP-vec2(.3125,0.),vec2(1./128.,2.),0.) +\n    \t\t\t\t\tbox(stP-vec2(.329,0.),vec2(1./128.,2.),0.) +\n    \t\t\t\t\tbox(stP-vec2(.1875,0.),vec2(1./128.,2.),0.) +\n    \t\t\t\t\tbox(stP-vec2(.171,0.),vec2(1./128.,2.),0.) +\n\n    \t\t\t\t\tbox(stP+vec2(.2975,0.),vec2(1./16.,2.),0.) + \n    \t\t\t\t\tbox(stP+vec2(.2025,0.),vec2(1./16.,2.),0.) +\n    \t\t\t\t\tbox(stP+vec2(.25,0.),vec2(1./64.,2.),0.) );\t\n\n    colorH += tPurpl * ( box(stP+vec2(.0,.25),vec2(2.,1./10.),0.) +\n    \t\t\t\t\tbox(stP+vec2(0.,.3125),vec2(2.,1./128.),0.) +\n    \t\t\t\t\tbox(stP+vec2(0.,.329),vec2(2.,1./128.),0.) +\n    \t\t\t\t\tbox(stP+vec2(0.,.1875),vec2(2.,1./128.),0.) +\n    \t\t\t\t\tbox(stP+vec2(0.,.171),vec2(2.,1./128.),0.) +\n\n    \t\t\t\t\tbox(stP-vec2(0.,.2975),vec2(2.,1./16.),0.) + \n    \t\t\t\t\tbox(stP-vec2(0.,.2025),vec2(2.,1./16.),0.) +\n    \t\t\t\t\tbox(stP-vec2(0.,.25),vec2(2.,1./64.),0.) );\n    \n    //diags\n    stD = stD-0.5;\n    stD = stD * rotate2d(-PI/4.) * spinny;\n    stD = tile(stD+0.5,96.);\n    float diags = box(stD,vec2(2.,.75),0.5);\n    \n    color = mix(colorV,colorH,diags);\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l33WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 390, 442, 442, 680], [682, 682, 715, 715, 743], [745, 745, 773, 773, 859], [861, 861, 918, 918, 2714]], "test": "valid"}
{"id": "4l3GWS", "name": "Wobbly Truchet Tiles", "author": "AmazingThew", "description": "Simple Truchet tiles with some noise-based animation applied to the lines\n\nUses Wombat's noise implementation: https://github.com/BrianSharpe/Wombat", "tags": ["2d", "truchet"], "likes": 15, "viewed": 407, "published": "Public", "date": "1471061510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nconst int samples = 4;\nconst float angle = 1.;\nconst mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\nconst vec4 navy = vec4(0.08, 0.15, 0.22, 1.00);\nconst vec4 egg  = vec4(1.00, 0.96, 0.91, 1.00);\n\nconst float speed = 2.;\nconst float noiseScale = 67.;\nconst float shift = -8.;\n\nvec2 aux;\n\nfloat SimplexPerlin3D( vec3 P );\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec4 samplePixel(vec2 uv) {\n    vec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n    float tileWidth = 50.0 / iResolution.x;\n    \n    uv *= aspect;\n    uv *= rot;\n    \n    float noiseZ = iTime * speed;\n    float noise = SimplexPerlin3D(vec3(uv*iResolution.x/40., noiseZ)) * 0.5 + 0.5;\n    \n    float thickness = uv.x+0.4;\n    thickness = thickness*0.3 - noise * 0.07 * (1.0-uv.x+0.4);\n    \n    vec2 tileCoord = fract(uv / tileWidth);\n    vec2 tileId = floor(uv / tileWidth);\n    \n    vec2 dlCorner = vec2(0.0, 0.0);\n    vec2 drCorner = vec2(1.0, 0.0);\n    vec2 ulCorner = vec2(0.0, 1.0);\n    vec2 urCorner = vec2(1.0, 1.0);\n    float dlArc = mix(1.0, 0.0, step(thickness, abs(length(tileCoord-dlCorner)-0.5)));\n    float drArc = mix(1.0, 0.0, step(thickness, abs(length(tileCoord-drCorner)-0.5)));\n    float ulArc = mix(1.0, 0.0, step(thickness, abs(length(tileCoord-ulCorner)-0.5)));\n    float urArc = mix(1.0, 0.0, step(thickness, abs(length(tileCoord-urCorner)-0.5)));\n    \n    float typeA = max(dlArc, urArc);\n    float typeB = max(drArc, ulArc);\n    float typeC = mix(1.0, 0.0, min(step(thickness, abs(tileCoord.x-0.5)), step(thickness, abs(tileCoord.y-0.5))));\n    \n    float selector = rand(tileId+vec2(12.));\n    float val = mix(mix(typeA, typeB, step(1.0/3.0, selector)), typeC, step(2.0/3.0, selector));\n    //val = mix(typeA, typeB, step(0.5, selector)); //Uncomment for Smith-style tiles\n    \n    return mix(navy, egg, 1.0-val);\n}\n\nvec4 superSamplePixel(vec2 pos) {\n    vec2 off = 1.0 / float(samples) / iResolution.xy;\n    vec4 sum = vec4(0.0);\n    for (int x=0; x<samples; x++) {\n        for (int y=0; y<samples; y++) {\n            sum += samplePixel(pos + vec2(off.x*float(x), off.y*float(y)));\n        }\n    }\n    return sum / float(samples * samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    aux = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = superSamplePixel(uv);\n}\n\n\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I'm not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This is a modified version of Stefan Gustavson's and Ian McEwan's work at http://github.com/ashima/webgl-noise\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - space scaled can have an approx feature size of 1.0\n//  - filter kernel changed to fix discontinuities at tetrahedron boundaries\n//\n\n//\n//  Simplex Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat SimplexPerlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHADRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tevaluate gradients\n    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    kernel_weights = max(0.5 - kernel_weights, 0.0);\n    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\n\n    //\tsum with the kernel and return\n    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3GWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 387, 387, 459], [462, 462, 489, 489, 1911], [1913, 1913, 1946, 1946, 2239], [2241, 2241, 2298, 2298, 2422], [3388, 3458, 3491, 3602, 6553]], "test": "error"}
{"id": "4lc3Ds", "name": "Plain Cosmos", "author": "alexpolt", "description": "Just a rotating plain with animated circles on it.", "tags": ["circles", "animation", "plain"], "likes": 0, "viewed": 532, "published": "Public API", "date": "1472304501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5,0.5);\n    float ar = iResolution.x / iResolution.y;\n    float t = iTime/20.0;\n    \n    vec3 pos = vec3(0,0,-1);\n    vec3 ray = normalize( vec3( uv.x * ar, uv.y, 0.75 ) );\n    vec3 plain = normalize( vec3( sin(t), cos(t), cos(2.0*t) ) );\n    \n    float pp = dot( plain, pos );\n    float pr = dot( plain, ray);\n    float s = sign( pp ) * sign( pr );\n    \n    vec3 v = pos + abs( pp ) / abs( pr ) * ray;\n    \n    float r = 1.0 - abs( 2.0 * smoothstep(-0.5, 0.5, fract( 1.3+length(v)+2.3*t ) - 0.5 ) - 1.0 );\n    float g = 1.0 - abs( 2.0 * smoothstep(-0.5, 0.5, fract( 0.7+length(v)+1.7*t ) - 0.5 ) - 1.0 );\n    float b = 1.0 - abs( 2.0 * smoothstep(-0.5, 0.5, fract( 0.0+length(v)+2.0*t ) - 0.5 ) - 1.0 );\n    float k = 1.0 - smoothstep( 0.0, 12.0, length(v) );\n    vec3 rgb = vec3( s < 0.0 ? r : 0.0, s < 0.0 ? g : 0.0, s < 0.0 ? b : 0.0 );\n    \n    float back = plain.z * dot( plain.xy, ray.xy ) > 0.0 ? 1.0 : 0.0;\n    plain = dot( plain.xy, ray.xy ) < 0.0 ? -plain : plain;\n    float angle1 = acos( dot( pos, plain ) );\n    float angle2 = acos( dot( -pos, ray ) );\n    float angle3 = 3.1416 - angle1 - angle2;\n    angle3 = clamp( 0.005, 3.1416, angle3 );\n    \n    vec3 ray2beam = pos + ray * sin(angle1) / sin( angle3 );\n    vec3 beam = dot( ray2beam, plain ) * plain;\n    \n    float d0 = smoothstep( .0, .1, length( beam - ray2beam ) );\n\tfloat m1 = back > 0.0 ? 1.0 : pow(d0,.25);\n    float m2 = back > 0.0 ? .5 * ( 1.0 - smoothstep( .0, 4.0, length( beam ) )  ) : 1.0;\n    \n\tfragColor = vec4( rgb * k * m1 + pow( 1.0-d0, 4.0 ) * m2, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lc3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1651]], "test": "valid"}
{"id": "4lcGWf", "name": "Infinite Julia Fractal Zoom Loop", "author": "roywig", "description": "It's a fractal tunnel, by way of a Julia-type set and some conformal maps.\n\n Best viewed in full screen", "tags": ["fractal", "zoom", "mobius"], "likes": 4, "viewed": 220, "published": "Public", "date": "1472008088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AUDIO\n\nconst float PI = 3.14159265359;\nconst vec2 CA = vec2(-0.200,-0.380);\nconst vec2 CB = vec2(-0.610,0.635);\nvec2 CC = vec2(-0.440,0.170);\nconst vec2 CD = vec2(0.170,-0.10); \nconst float C=1.5; \nconst float C2=23.7; \nconst vec3 Color = vec3(0.450,0.513,1.000);\nconst float Speed = 2.;\n#ifdef AUDIO\nfloat iAudio = 0.;\n#else\nconst float iAudio = .15;\n#endif\n\n// Complex functions\nvec2 cis(in float a){ return vec2(cos(a), sin(a));}\nvec2 cMul(in vec2 a, in vec2 b) { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y * b.x);}\nvec2 cDiv(in vec2 a, in vec2 b) { return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / (b.x*b.x+b.y*b.y); }\nvec2 cLog(in vec2 a){ return vec2(log(length(a)),atan(a.y,a.x)); }\nvoid fill(inout float[9] k){for( int i=0;i<8;i++) { k[i] = 0.;} }\n// Elliptic J function calculation ported from d3\n// https://github.com/d3/d3-geo-projection/blob/master/src/elliptic.js\nvec4 ellipticJ(float u, float m){\n    float ai, b=sqrt(1.-m), phi, t, twon=1.;\n    float a[9],c[9];\n    fill(a); fill(c);\n\ta[0] = 1.; c[0] = sqrt(m);\n    int i=0;\n    for (int j=1;j<8;j++){\n        if ((c[j-1] / a[j-1]) > 0.1) {\n            i++;\n            ai = a[j-1];\n            c[j] = (ai - b) * .5;\n            a[j] = (ai + b) * .5;\n            b = sqrt(ai * b);\n            twon *= 2.;\n        }\n    }\n    for (int j=8;j>0;j--){\n        if (j == i) phi = twon * a[j] * u;\n        if (j <= i){\n            t = c[j] * sin(b = phi) / a[j];\n            phi = (asin(t) + phi) / 2.;\n        }\n    }\n    return vec4(sin(phi), t = cos(phi), t / cos(phi - b), phi);\n}\n// Jacobi's cn tiles the plane with a sphere \nvec2 cn(vec2 z, float m) {\n    vec4 a = ellipticJ(z.x, m), b = ellipticJ(z.y, 1. - m);\n    return vec2(a[1] * b[1] , -a[0] * a[2] * b[0] * b[2] )/ (b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0]);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 domain(vec2 z){\n    return vec3(hsv2rgb(vec3(atan(z.y,z.x)/PI*8.+1.224,1.,1.)));\n}\n// A Julia fractal, but with a Mobius transformation instead of a translation\nvec3 M(vec2 z,vec2 c){\n    vec3 mean;\n    float ci;\n    int k=0;\n\tvec3 color;\n    for ( int i=0; i<50;i++){\n        z = cMul(z,z);\n        z = cDiv(cMul(CA,z)+CB+cis(iTime)*iAudio,cMul(z,CC)+CD);          \n        if (i < 3) continue;\n\t \tmean += length(z);\n        float amount = pow(7./float(i),2.608);\n        color = (1.-amount)*color+amount*length(z)*domain(z);\n        k++;\n    }\n\tmean /= float(k-3);\n    // Hacky color time!\n\tci =  log2(C2*log2(length(mean/C)));\n\tci = max(0.,ci);\n    vec3 color2 = .5+.5*cos(ci + Color)+.3;\n\tcolor = color2*(color);\n    \n    return color;\n}\nvec3 color(vec2 z){\n    z = cLog(z) * 1.179;\n    z.x -= mod(iTime/float(Speed),1.)*3.7;\n    z *= mat2(1,-1,1,1);\n    z = cn(z,0.5);\n    return M(z,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef AUDIO\n    iAudio = texture(iChannel0, vec2(0.1, 0.)).r;\n    iAudio = pow(iAudio,4.);\n\t#endif\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\tfragColor = vec4(color(uv),1.0);\n}", "image_inputs": [{"id": "Mdj3zh", "previewfilepath": "https://soundcloud.com/phibes/major-lazer-light-it-up-phibes-remix-free-download?in=phibesbigboots/sets/phibes-dnb-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/phibes/major-lazer-light-it-up-phibes-remix-free-download?in=phibesbigboots/sets/phibes-dnb-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 389, 410, 410, 440], [441, 441, 474, 474, 529], [530, 530, 563, 563, 636], [637, 637, 658, 658, 703], [704, 704, 732, 732, 769], [770, 891, 924, 924, 1556], [1557, 1603, 1629, 1629, 1798], [1800, 1800, 1822, 1822, 1991], [1992, 1992, 2012, 2012, 2079], [2080, 2158, 2180, 2180, 2738], [2739, 2739, 2758, 2758, 2891], [2893, 2893, 2950, 2950, 3155]], "test": "error"}
{"id": "4ld3W4", "name": "Minimal Raymarch", "author": "Kastor", "description": "This is a minimal version of iqs premitives", "tags": ["raymarching"], "likes": 3, "viewed": 197, "published": "Public", "date": "1470228448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 twist( vec3 p )\n{\n    float x = sin(cos(iTime * 0.5) * 0.2 + cos(iTime * 1.5) * 0.2);\n    float val = x * 3.2 *p.y+ cos(iTime + x) * 2.0;\n    float  c = cos(val);\n    float  s = sin(val);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nvec2 map( in vec3 pos )\n{\n\tvec2 res = \n         vec2( 0.5*box( twist(pos),vec3(0.5, 0.5, 10.7)), 46.7);\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n     \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.1, 0.1, 0.1);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        // material        \n\t\tcol = vec3(0.3, 1.0, 0.3);\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        //vec3 normal = calcNormal(pos);\n        float intensity = 0.0;\n        float ambient = 0.2;\n        float diffuse = clamp( dot( nor, -rd ), 0.0, 1.0 );\n        float spec = pow(clamp( dot( ref, -rd ), 0.0, 1.0 ),8.1);\n        intensity += ambient;\n        intensity += 0.7 * spec;\n        intensity += 0.7 * diffuse;\n        col *= intensity;\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n    }\n  \treturn vec3( clamp(col,0.0,1.0) );  \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 zaxis = normalize(ta-ro);\n\tvec3 up = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 xaxis = normalize( cross(zaxis, up) );\n\tvec3 yaxis = normalize( cross(xaxis, zaxis) );\n    return mat3( xaxis, yaxis, zaxis );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    vec2 mo = vec2(0,0);\n\t//mo = vec2(0.0, 0.2);\n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 origin = vec3( -4.5, 0.0, 6.0 );\n\tvec3 lookat = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( origin, lookat, 0.0 );\n    \n    // ray direction\n\tvec3 dir = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( origin, dir );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ld3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 116], [118, 118, 140, 140, 372], [373, 373, 398, 398, 495], [497, 497, 529, 529, 750], [752, 752, 792, 792, 1113], [1116, 1116, 1155, 1155, 1917], [1919, 1919, 1971, 1971, 2178], [2180, 2180, 2237, 2237, 2750]], "test": "valid"}
{"id": "4ldGRf", "name": "Volumetric cloud", "author": "Duke", "description": "My attempt to combine techniques from [url=https://www.shadertoy.com/view/ll2SWd]Above the clouds[/url] and [url=https://www.guerrilla-games.com/read/the-real-time-volumetric-cloudscapes-of-horizon-zero-dawn]Real-Time Volumetric Cloudscapes[/url]", "tags": ["clouds", "volumetric", "scattering", "twisted"], "likes": 89, "viewed": 5223, "published": "Public API", "date": "1470612311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Volumetric cloud\" by Duke\n// https://www.shadertoy.com/view/4ldGRf\n//-------------------------------------------------------------------------------------\n// Based on \"Above the clouds\" (https://www.shadertoy.com/view/ll2SWd)\n// \"Volumetric explosion\" (https://www.shadertoy.com/view/lsySzd)\n// and other previous shaders.\n// Also was useful\n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and IQ's \"Clouds\" (https://www.shadertoy.com/view/XslGRr) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n// Comment this string to see another type of clouds\n#define TWISTED\n// Comment this string to make cloud less dense\n#define DENSE\n\n#define DITHERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n    return noise(p*.06125)*.75+ noise(p*.125)*.325 + noise(p*.4)*.2;\n}\n\n// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Sphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 2.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = -mod(iTime * 0.2,-2.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricCloud(vec3 p)\n{\n    float final = Sphere(p,4.);\n    #ifdef TWISTED\n    float tnoise = noise(p*0.5);\n    //final += tnoise * 1.75;\n    final += SpiralNoiseC(p.zxy*0.3132*tnoise+333.)*3.25;\n    #else\n    final += SpiralNoiseC(p*0.35+333.)*3.0 + fbm(p*50.)*1.25;\n    #endif\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tfloat VolCloud = VolumetricCloud(p/0.5)*0.5; // scale\n\treturn VolCloud;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 26.;\n\tfloat delta = b*b - c;\n\tif(delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\nfloat HGPhase( float cosAngle, float g)\n{\n\tfloat g2 = g * g;\n\treturn (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * cosAngle, 1.5);\n}\n\nfloat BeerLaw(float DenSample, float DenCoef)\n{\n   return exp( -DenSample * DenCoef);\n}\n         \nfloat PowderEff(float DenSample, float cosAngle, float DenCoef, float PowderCoef)\n{\n   float Powder = 1.0 - exp(-DenSample * DenCoef * 2.0);\n   Powder = clamp(Powder * PowderCoef, 0.0, 1.0);\n   return mix(1.0, Powder, smoothstep(0.5, -0.5, cosAngle));\n}\n\n// Utility function that maps a value from one range to another.\nfloat Remap(float original_value, float original_min, float original_max, float new_min, float new_max)\n{\n\treturn new_min + (((original_value - original_min) / (original_max - original_min)) * (new_max - new_min));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n    \n   \t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -8.+key*1.6);\n    \n    R(rd.yz, -pi*3.93);\n    R(ro.yz, -pi*3.93);\n    R(rd.xz, iMouse.x*0.008*pi);\n    R(ro.xz, iMouse.x*0.008*pi);\n   \n    // ld, td: local, total density \n    // w: weighting factor\n    float ld=0., td=0., w;\n\n    // t: length of the ray\n    // d: distance function\n    float d=1., t=0.;\n   \n    // Distance threshold\n    const float h = .225;\n    \n    vec3 sundir = normalize( vec3(-1.0,0.75,1.0) );\n   \n    // background sky     \n    vec3 colSky = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n    float sun = clamp(dot(sundir,rd), 0.0, 1.0);\n    colSky += 0.25 * vec3(1.0,.6,0.1) * pow(sun, 8.0) + 2.0 * vec3(1.0,.6,0.1) * pow(sun, 3000.0);\n    colSky = clamp(colSky, 0.0, 1.1);\n    \n    vec4 sum = vec4(0.0);\n   \n    // Cloud color\n    const vec3 CloudBaseColor = vec3(0.52, 0.67, 0.82);\n    const vec3 CloudTopColor = vec3(1.0);\n   \n    #ifdef DITHERING\n    vec2 posd = ( fragCoord.xy / iResolution.xy );\n    vec2 seed = posd + fract(iTime);\n    t = (1. + 0.2*rand(seed*vec2(100.)));\n    #endif \n    \n    float d_remaped = 0.0;\n\n    float min_dist = 0.0, max_dist = 0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist * step(t, min_dist);    \n    \n    // rm loop\n    for (int i=0; i<64; i++)\n    {\n        vec3 pos = ro + t*rd;\n       \n        // Loop break conditions.\n        if(td>0.9875 || d<0.0006*t || t>12. || t>max_dist || sum.a > 0.99) break;\n       \n        // evaluate distance function\n        d = map(pos);\n      \n        d_remaped = Remap(max(d,-2.), -2., h, h, 1.0);\n\n        // check whether we are close enough\n        if (d<h) \n        {\n            // compute local density and weighting factor \n            ld = h - (1.0 - d_remaped);\n          \n            w = (1. - td) * ld;   \n     \n            // accumulate density\n            #ifdef DENSE\n            td += w + 1./200.;\n            #else\n            td += w * 1./200.;\n            #endif\n\t\t\t\n            const float dShiftStep = 0.2; \n            float dShift = map(pos + dShiftStep * sundir);\n            float fld = clamp((ld - (h - max(dShift, 0.0))) / (dShiftStep * 2.), 0.0, 1.0);\n         \n            vec3 lin = mix(CloudTopColor, CloudBaseColor, -fld) * .85;\n         \n            // this part based on \"Real-Time Volumetric Cloudscapes\" by Andrew Schneider\n            const float FwdSctG = 0.2;\n            const float BckwdSctG = -0.02;\n            const float HGCoef = .1;\n            const float DenCoef = .75;\n            const float PowderCoef = 1.3;\n            \n            float cosAngle = dot(rd, sundir);\n            float FwdSctHG = HGPhase(cosAngle, FwdSctG);\n            float BckwdSctHG = HGPhase(cosAngle, BckwdSctG);\n            float TotalHGPhase = (HGCoef * FwdSctHG) + ((1. - HGCoef) * BckwdSctHG);\n\t\t\t\n            #ifdef DENSE\n            vec4 col = vec4(lin * TotalHGPhase * BeerLaw(fld*ld, DenCoef) * PowderEff(exp(-d), cosAngle, DenCoef, PowderCoef) + colSky * 0.05, d_remaped);\n            #else\n            vec4 col = vec4(lin * TotalHGPhase * BeerLaw(fld*ld, DenCoef) * PowderEff(exp(-d), cosAngle, DenCoef, PowderCoef) + colSky * 0.05, exp(-d_remaped));\n            #endif\n            \n            // front to back blending\n            #ifdef DENSE\n            col.a *= 0.185;\n            #else\n            col.a *= 0.175;\n            #endif\n            col.rgb *= col.a;\n            sum += col*(1.0-sum.a);\n        }\n      \n        td += 1./150.; // 1./80.;\n       \n        // enforce minimum stepsize\n        d = max(d, 0.1);\n      \n        #ifdef DITHERING\n        // add in noise to reduce banding and create fuzz\n        posd.y*=120.;\n        posd.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(posd.y,-posd.x+0.5*sin(4.*iTime+posd.y*4.0))).r);\n        #endif \n     \n        // step forward\n        t += max(d * 0.19, 0.02);\n    }\n \n    sum = clamp( sum, 0.0, 1.0 );\n    \n    }\n        \n    sum.xyz = colSky * (1.0-sum.w) + sum.xyz;\n    \n    // small color adjustment\n    sum.xyz *= 1. / exp( ld * 0.05 ) * .85;\n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*clamp(sum.xyz,0.0,1.0));\n   \n    fragColor = vec4(sum.xyz,1.0);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldGRf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[989, 1003, 1029, 1029, 1238], [1240, 1240, 1261, 1261, 1332], [1334, 1406, 1427, 1427, 1501], [1503, 1503, 1536, 1536, 1562], [1564, 2224, 2252, 2252, 2819], [2821, 2821, 2852, 2852, 3127], [3129, 3129, 3149, 3149, 3224], [3226, 3226, 3302, 3302, 3518], [3520, 3520, 3561, 3561, 3644], [3646, 3646, 3693, 3693, 3733], [3744, 3744, 3827, 3827, 3997], [3999, 4064, 4169, 4169, 4280], [4282, 4282, 4339, 4339, 8916]], "test": "error"}
{"id": "4ldGWj", "name": "Hello Shadertoy!", "author": "elChris", "description": "Just a little experiment with the awesome Shadertoy! Really trippy!\n\nBe careful! This shader may produce dizziness and headaches.", "tags": ["2d"], "likes": 3, "viewed": 207, "published": "Public", "date": "1471829138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 backgroundColor = vec3(0.0, 0.0, 0.0);\nfloat rotRadius = 40.0;\nfloat speed = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 100.0;\n    vec2 screenCenter = (iResolution.xy / 2.0);\n    vec2 circleCenter = screenCenter + vec2(sin(iTime * speed) * rotRadius, cos(iTime * speed) * rotRadius);\n    vec3 result = backgroundColor;\n   \t\n    vec2 dir = fragCoord - circleCenter;\n    float len = length(dir);\n    if(len < radius){\n        result = vec3(sin(len));\n    }\n    else if(length(fragCoord - screenCenter) < (radius + rotRadius)){\n       \tresult = vec3(sin(fragCoord.y + iTime * -40.0));\n    }\n    else {\n        result += vec3(sin(fragCoord.x / 1.0 + iTime * - 20.0) + sin(fragCoord.y / 1.0));\n    }\n    \n\tfragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 145, 145, 777]], "test": "valid"}
{"id": "4ldGzf", "name": "heart test code", "author": "oceanou", "description": "heart http://blog.csdn.net/candycat1992/article/details/44040273", "tags": ["heart"], "likes": 1, "viewed": 149, "published": "Public", "date": "1470659424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    p.y -= 0.25;\n\n    // background color\n    vec3 bcol = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\n    // animate\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\n\n    // shape\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n    // color\n    float s = 1.0-0.5*clamp(r/d,0.0,1.0);\n    s = 0.75 + 0.75*p.x;\n    s *= 1.0-0.25*r;\n    s = 0.5 + 0.6*s;\n    s *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n    vec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\n    vec3 col = mix( bcol, hcol, smoothstep( -0.01, 0.01, d-r) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 921]], "test": "valid"}
{"id": "4lt3R2", "name": "Voro Nope", "author": "XMunkki", "description": "The shader code for the \"Voro Nope\" 4k-intro first released at the Assembly 2016.\n\nSee it with the music (done separately using 4klang):\nhttps://www.youtube.com/watch?v=06AsiIwcock\n", "tags": ["raymarching", "voronoi", "4kintro"], "likes": 2, "viewed": 123, "published": "Public", "date": "1470322037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Voro Nope\" 4k intro, released at Assembly 2016\n// Created by Jere \"XMunkki\" Sanisalo\n//\n// Parts from the internet, Inigo Quilez and others..\n//\n\nvec2 p;\nfloat time;\n////////////////\n\n\n\n\nint fx;\nfloat fx_part;\n\n//#define pi 3.14159265\n//#define pi2 (pi * 2.0)\n\nfloat smoothlerp(float v1, float v2, float t)\n{\n\treturn mix(v1, v2, t*t*(3.0-2.0*t));\n}\n\nfloat Randf_from_2(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 Rand3(vec3 p)\n{\n\treturn vec3(\n\t\tRandf_from_2(p.yz),\n\t\tRandf_from_2(p.xz),\n\t\tRandf_from_2(p.xy));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nint imod(int ai, int bi)\n{\n    return int(mod(float(ai), float(bi))+0.001);\n}\n\nbool Is_Inside(vec3 p)\n{\n    // Pick the effect\n    int f = imod(fx, 4);\n    \n    if (fx < (16 * 2)) f = 4; // Start ball\n    \n    // 0\n    if (f-- == 0)\n    { // Cross and ball\n\t\tp = abs(p);\n        return ((length(p) < 4.0) ||\n            (max(p.x, p.y) < 1.0) ||\n            (max(p.x, p.z) < 1.0) ||\n            (max(p.z, p.y) < 1.0));\n    }\n\n    // 1\n    if (f-- == 0)\n    { // Torus\n\t\tvec2 q = vec2(length(p.xz)-5.0,p.y);\n\t\treturn (length(q) < 2.0);\n    }\n    \n    // 2\n    if (f-- == 0)\n    { // Box\n        return sdBox(p, vec3(5,5,5)) < 0.0;\n    }\n    \n    // 3\n    if (f-- == 0)\n    { // Corner boxes\n        float d = sdBox(p, vec3(6,6,6));\n        float sz = 2.0;\n        p = abs(p);\n        d = max(d, -(p.x - sz));\n        d = max(d, -(p.y - sz));\n        d = max(d, -(p.z - sz));\n        \n        return d < 0.0;\n    }\n    \n    // 4\n    if (f-- == 0)\n    { // Ball\n        return length(p) < 4.0;\n    }\n    \n    return false;\n}\n\nvec3 CalcOffset(ivec3 ipos)\n{\n    vec3 pos = vec3(ipos);\n    vec3 p = abs(Rand3(pos));\n    vec3 ang = vec3(time * 1.23, time * 0.84, time * 1.11) + p.zxy * 234.456;\n    return clamp(p + cos(ang), vec3(0.2,0.2,0.2), vec3(0.8,0.8,0.8));\n}\n\nfloat DF(vec3 wpos, vec3 frac_pos_tweak)\n{ // Voronoi based distance function\n\tivec3 pos = ivec3(floor(wpos));\n\tvec3 posf = fract(wpos) + frac_pos_tweak;\n\n    \n    \n//\tbool is_inside = Is_Inside(pos);\nbool is_inside = false;\n\t\n\tfloat dist_inside = 10.0;\n\tfloat dist_outside = 10.0;\n\tfor (int z = -1; z <= 1; ++z)\n\t{\n\t\tfor (int y = -1; y <= 1; ++y)\n\t\t{\n\t\t\tfor (int x = -1; x <= 1; ++x)\n\t\t\t{\n\t\t\t\tivec3 iofs = ivec3(x, y, z);\n\t\t\t\tivec3 ipos = pos + iofs;\n\t\t\t\t\n\t\t\t\t// Same material?\n\t\t\t\t//if (is_inside == Is_Inside(ipos))\n\t\t\t\t//\tcontinue;\n\t\t\t\t\t\n\t\t\t\t// Apply distance\n\t\t\t\t//vec3 local_ofs = abs(Rand3(vec3(ipos)));\n\t\t\t\t//vec3 local_ofs2 = abs(Rand3(vec3(ipos+ivec3(4,4,4))));\n\t\t\t\t//vec3 local_ofs = vec3(0.5, 0.5, 0.5);\n\t\t\t\t\n// Lerp between fixed and tweaked\n//local_ofs = mix(local_ofs, vec3(0.5, 0.5, 0.5), 1.0 - abs(cos(time * 2.0)));\n//local_ofs = mix(local_ofs, local_ofs2, (1.0 + cos(time * 3.0))*0.5);\n\t\t\t\t\n                vec3 local_ofs = CalcOffset(ipos);\n                \n\t\t\t\tvec3 fofs = vec3(iofs) - posf + local_ofs;\n\t\t\t\tfloat d = dot(fofs, fofs);\n\t\t\t\t\n\t\t\t\t//res = min(res, d);\n\t\t\t\tif (Is_Inside(vec3(ipos)))\n\t\t\t\t\tdist_inside = min(dist_inside, d);\n\t\t\t\telse\n\t\t\t\t\tdist_outside = min(dist_outside, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tdist_inside = sqrt(dist_inside);\n\tdist_outside = sqrt(dist_outside);\n\t\n\tfloat d = dist_inside - dist_outside;\n\treturn d;\n}\n\nvec3 DFNormal(vec3 p)\n{\n\tfloat d = DF(p, vec3(0,0,0));\n\tfloat eps = 0.001;\n\treturn normalize(vec3(\n\t\tDF(p, vec3(eps, 0, 0)) - d,\n\t\tDF(p, vec3(0, eps, 0)) - d,\n\t\tDF(p, vec3(0, 0, eps)) - d\n\t\t));\n}\n\nvec2 Raytrace(vec3 ray_pos, vec3 ray_dir)\n{\n\tvec2 dist_glow = vec2(0, 0);\n\n    for (int i = 0; i < 40; ++i)\n\t{\n\t\tfloat d = DF(ray_pos + ray_dir * dist_glow.x, vec3(0,0,0));\n\t\tif (abs(d) < 0.001)\n\t\t\tbreak;\n        \n        // Glow\n        if (d > 0.0)\n            dist_glow.y += max(1.0 - d * 1.0, 0.0) * 0.2;\n            \n        // Moving\n\t\tdist_glow.x += d * 0.4;\n\t}\n\n\treturn dist_glow;\n}\n\nfloat AO(vec3 pos, vec3 normal)\n{\n    float t = 0.0;\n    float ret = 0.0;\n    for (int i = 0; i < 10; ++i)\n    {\n        t += 0.1;\n        float d = DF(pos + normal * t, vec3(0,0,0));\n        ret += clamp((t - d) * 0.2, 0.0, 1.0);\n    }\n    //ret *= 0.0;\n    return 1.0 - ret;\n}\n\nvec3 MakeColor(int idx, float adj)\n{\n    float i = adj + float(idx)*1523.0;\n    vec3 c = abs(cos(vec3(i,i*0.374,i*0.584)));\n    if (length(c) < 0.7)\n        return vec3(1,1,1)-c;\n    return c;\n}\n\nfloat Specular(vec3 ray_dir, vec3 normal, vec3 light_dir)\n{\n    vec3 hv = normalize(normalize(light_dir) - ray_dir);\n    return pow(abs(dot(normal, hv)), 15.0) * 2.0;\n}\n\nvec4 intro()\n{\n    // Pick the effect\n    fx_part = time / 0.477;\n    fx = int(fx_part);\n    fx_part = fract(fx_part);\n\n    // Base drum pause\n    if (fx >= 61 && fx < 64)\n    {\n        fx = 60;\n        fx_part = 1.0;\n    }\n    \n    // Calculate the camera\n\tfloat cam_ang = time * 0.25;\n\tvec3 cam_pos;\n\tvec3 cam_target = vec3(0, 0, 0);\n\tfloat cam_dist = 10.0;\n    \n    cam_dist += fract(float(fx)*1234.56789) * 5.0; // Random direction\n    \n    if (fx < 32)\n    {\n        cam_dist = 18.0 + time * 4.5 - float(fx) * 2.5;\n    }\n    else\n    {\n        cam_ang += float(fx) * 11.0;\n    }\n    if (fx >= (16 * 8))\n    {\n        float amt = fx_part * 3.0;\n        cam_dist += (imod(fx, 2) == 0) ? amt : -amt;\n    }\n    \n\tcam_pos = normalize(vec3(sin(cam_ang), sin(1.0 + cam_ang * 1.0) * 1.0, cos(cam_ang))) * cam_dist;\n\n    if (fx >= (16*2))\n    {\n        if (imod(fx,2)==0)\n            cam_pos.x *= -1.0;\n        if (imod(fx,3)==0)\n            cam_pos.y *= -1.0;\n        if (imod(fx,5)==0)\n            cam_pos.z *= -1.0;\n    }\n    \n    // Create the camera vectors\n\tvec3 cam_z = normalize(cam_target - cam_pos);\n\tvec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n\tvec3 cam_y = normalize(cross(cam_x, cam_z));\n\tvec3 ray_dir = normalize(\n\t\tcam_x * p.x/* * (16.0/9.0)*/ + \n\t\tcam_y * p.y +\n\t\tcam_z); // * 1.0    <-- fov\n\n\t// Calculate the pixel color\n\tvec3 color;\n\tvec2 dist_glow = Raytrace(cam_pos, ray_dir);\n\n\tif (dist_glow.x < 20.0)\n\t{\n\t\tvec3 hit_pos = cam_pos + ray_dir * dist_glow.x;\n\t\tvec3 normal = DFNormal(hit_pos);\n\t\t\n\t\tfloat light = abs(dot(normal, normalize(vec3(1,1,1))));\n\t\t\n        // Specular lighting\n        light += Specular(ray_dir, normal, vec3(-1,1,1));\n        light += Specular(ray_dir, normal, vec3(1,-1,1));\n        light += Specular(ray_dir, normal, vec3(1,1,-1));\n        \n        int col_idx = (fx < 32) ? -1 : fx;\n                \n        //color = Rand3(floor(hit_pos*0.21)) * 2.0;\n        color = MakeColor(col_idx+2,length(hit_pos)*0.1);\n        \n        color *= light;\n        \n        // Pulse\n        //c *= 2.0 - pow(0.2+abs(fx_part * 10.0 - length(hit_pos)), 1.0);\n        \n        color *= AO(hit_pos, normal);\n        \n        // Disable glow for hits\n        dist_glow.y = 0.0;\n        \n        // Blackness at the end\n        if (fx >= (16*6) && fx < (16*7))\n            color *= 0.0;\n\t}\n\telse\n\t{\n\t\t//color = vec4(0,0,0.5,1);\n        \n        // Bg rotation\n        float a = time * 0.5;\n        vec2 asc = vec2(sin(a), cos(a));\n        bool is_rot = (fx < (16 * 9));\n        vec2 pr = vec2(dot(p,asc.yx), dot(p,asc * vec2(1.0,is_rot?-1.0:1.0)));\n        \n        // Circles\n        float c = length(pr) * 20.0;\n        \n        int bg = imod(fx, 4);\n        // L-shapes\n        if (--bg == 0)\n\t        c = min(abs(pr.x), abs(pr.y)) * -30.0;\n        \n        // X-shapes\n        if (--bg == 0)\n\t        c = min(abs(dot(pr, vec2(1,1))), abs(dot(pr, vec2(-1,1)))) * 20.0;\n        \n        // Boxes\n        if (--bg == 0)\n            c = max(abs(pr.x), abs(pr.y)) * 30.0;\n\n        // THRESHOLD: black / area\n        c = max(0.00001, cos(c - time*5.0));\n        c = pow(c,0.1);\n\n        \n        //color = vec4(c*0.86,c*0.92,c*0.82,1);\n        color = c*MakeColor(fx,length(pr));\n\n        // Start: Bg pulse\n        if (fx < (16 * 6))\n        {\n\t        c = pow(length(pr)/1000.0,0.1)*0.4;\n            color=vec3(c, c, c);\n        }\n    }\n   \n    // Glow\n    if ((fx >= (16*6) && fx < (16 * 7)) ||\n        (fx >= (16*10)))\n    {\n\t    //color += vec3(0.98, 0.89, 0.92) * dist_glow.y;\n\t    color += MakeColor(fx+2,0.0) * dist_glow.y;\n    }\n    \n    // Color grading\n    float gr = 0.485;\n    //color = pow(color, vec4(gr,gr,gr,1));\n    \n    // Vignette\n    color *= 1.0 - pow(length(p) * 0.4, 0.7);\n\n    // Flashing\n    if (fx < (16 * 10))\n    {\n\t    //color *= pow(min(fx_part * 0.5, 1.0), 0.5);\n    \t//color *= min(fx_part * 1.0, 1.0);\n   \t \tcolor *= smoothstep(0.0, 0.7, fx_part);\n    }\n    \n    // End fade\n    color *= 1.0 - smoothstep(85.0, 97.0, time);\n    \n\treturn vec4(color, 1.0);\n}\n\n\n\n\n\n/////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0-1.0;\n    \n    p = uv;\n    time = iTime;\n    fragColor = intro();\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lt3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 265, 312, 312, 352], [354, 354, 383, 383, 455], [457, 457, 477, 477, 560], [562, 562, 593, 593, 689], [691, 691, 717, 717, 768], [770, 770, 794, 817, 1711], [1713, 1713, 1742, 1742, 1949], [1951, 1951, 1993, 2028, 3295], [3297, 3297, 3320, 3320, 3492], [3494, 3494, 3537, 3537, 3884], [3886, 3886, 3919, 3919, 4164], [4166, 4166, 4202, 4202, 4360], [4362, 4362, 4421, 4421, 4530], [4532, 4532, 4546, 4569, 8551], [8557, 8592, 8649, 8649, 8774]], "test": "valid"}
{"id": "4lt3W2", "name": "Not quite home remix", "author": "xwize", "description": "Sci fi remix of the not quite home shader. Would advise only to run on PC with proper GPU, doesn't work on my nexus 4 as the landscape texture gets quantised (if you think you might know the cause, any help would be appreciated).", "tags": ["procedural", "noise", "planet", "landscape"], "likes": 14, "viewed": 459, "published": "Public", "date": "1471814076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat octaves6(vec3 q)\n{\n    float f = 0.0;\n    const int n = 6;\n    float ti = 1.0;\n    for(int i = 0; i < n; ++i)\n    {\n        f += noise(q * ti ) / ti;\n        ti *= 2.0;\n    }\n    return f;\n}\n\n\nmat4 lookAtInv(vec3 eyePos, vec3 targetPos, vec3 upVector)\n{\n    vec3 forward = normalize(targetPos - eyePos);\n    vec3 right = normalize(cross(forward,upVector));\n    vec3 newUp = normalize(cross(right,forward));\n    \n    highp mat4 r;\n    r[0] = vec4(right,0.0);\n    r[1] = vec4(newUp,0.0);\n    r[2] = vec4(-forward,0.0);\n    r[3] = vec4(eyePos,1.0);\n    return r;\n}\n\nfloat starFunc(vec3 p)\n{\n\tfloat a = 0.0;\n\tfloat fp = 0.75;\n\tconst int n = 17;\n\tfloat pa = 0.0;\n\t\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tp=abs(p)/dot(p,p)-fp;\n\t\ta+=abs(length(p)-pa);\n\t\tpa=length(p);\n\t}\n\t\n\ta /= float(n);\n\treturn a*a*a*0.625;\n}\n\nvec3 galaxy(vec3 start, vec3 dir)\n{\n    vec3 p = start+dir*100.0;\n    p += vec3(0.0,150.0,0.0);\n   \n    vec3 c = vec3(starFunc(p)) * vec3(1.2,1.0,2.0);\n    p += vec3(10.1,15.2,10.4);\n\tc += vec3(starFunc(p)) * vec3(1.2,1.2,3.0);\n    p += vec3(10.1,15.2,10.5);\n\tc += vec3(starFunc(p)) * vec3(1.2,1.2,1.4);\n    \n\treturn c*0.03;\n}\n\nfloat snowFunc(vec3 p)\n{\n\tfloat a = 0.0;\n\tfloat fp = 0.75;\n\tconst int n = 32;\n\tfloat pa = 0.0;\n\t\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tp=abs(p)/dot(p,p)-fp;\n\t\ta+=abs(length(p)-pa);\n\t\tpa=length(p);\n\t}\n\t\n\ta /= float(n);\n    a *= 0.625;\n\treturn max(max(a,0.5)-0.5,0.0);\n}\n\nvec3 snowfall(vec3 start, vec3 dir)\n{\n    vec3 p = start+dir*10.0;\n \tp += vec3(80.0,150.0,10.0);\n    \n    //float n = 0.5*noise(0.4*vec3(iTime));\n    p.x += iTime*13.0;//(iTime + n);\n    p.y += iTime*6.0;\n    vec3 c = vec3(snowFunc(p));\n    \n    p += vec3(10.1,15.2,10.4);\n\tc += vec3(snowFunc(p));\n   \n\tc *= 0.1;\n    \n\n\treturn min(c,0.3);\n}\n\nhighp float terrain(highp vec2 p)\n{\n    /*vec3 q = 0.5*vec3(p.x,0.2,p.y);\n    \n    float f = 0.0;\n    f += noise(q);\n    f += noise(q*2.0)*0.65;\n    f += noise(4.0*q)*0.35;\n    //f += noise(8.0*q)*0.05;\n    \n    //f += noise(16.0*q)*0.02;\n \t//f += noise(32.0*q)*0.01;\n    //f += noise(64.0*q)*0.005;\n    //f += noise(128.0*q)*0.0025;\n    \n    f *= f;\n    f *= f;\n    \n    float l = dot(p,p);\n    f *= (0.6 + 0.025*l);*/\n    \n    highp float f = 0.0;\n    \n    // Coarse\n    highp float l = dot(p,p);\n    //vec3 s = texture(iChannel1,p.xy*0.02).rgb;\n   // f += (s.x+s.y+s.z)*0.5;\n    f += texture(iChannel1,p.xy*0.020,2.0).r;\n    f += texture(iChannel1,p.xy*0.02,1.0).r;\n    //f = sin(p.x)*sin(p.y);\n    f *= f;\n    f *= (0.6 + 0.025*l*exp(-max(l-120.0,0.0)*0.01));\n    //f *= 1.0 - 0.4*cos(p.x/2.0);\n    \n    // Detail\n    f += 0.2*texture(iChannel1,p.xy*0.2,0.0).g;\n    \n    \n    return f;\n}\n\nvec3 terrainNormal(vec2 p)\n{\n    float eps = 1.0/1024.0;\n    \n\thighp vec2 dx = vec2(eps,0.0);\n    highp vec2 dy = vec2(0.0,eps);\n    \n    highp vec2 px = p + dx;\n    highp vec2 py = p + dy;\n    \n    highp float h = terrain(p.xy);\n    highp vec3 t = vec3(px.x,terrain(px),px.y) - vec3(p.x,h,p.y);\n    highp vec3 b = vec3(py.x,terrain(py),py.y) - vec3(p.x,h,p.y);\n    \n    t = normalize(t);\n    b = normalize(b);\n    \n    return normalize(cross(b,t));        \t\t\n}\n\nfloat terrainShadow(vec3 p, vec3 dir)\n{\n    vec3 s = p;\n    const int n = 32;\n    float di = 0.4;\n    float dii = 0.002;\n    float light = 1.0;\n    for(int i = 0; i < n; ++i)\n    {\n        s += dir * di;\n        float h = terrain(s.xz);\n        float depth = max(h - s.y,0.0);\n        light -= 0.005*exp(depth*2.0);\n        di += dii;\n    }\n    \n    return max(light,0.0);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat cloudForm(vec3 q)\n{\n    q.x += sin(q.y*2.0);\n    q.z += cos(q.x*2.0)*0.3;\n   \n    \n    float f = -0.15 +\n       noise(q) +\n       noise(q*2.0) * 0.5 + \n       noise(q*4.0) * 0.25 +\n       noise(q*8.0) * 0.125 +\n       noise(q*16.0)* 0.05 + \n       noise(q*32.0)* 0.025 +\n       noise(q*64.0)* 0.0125;\n           \n    f = min(pow(abs(f),10.0)*0.5,0.5);\n    return f;\n}\n\n\nvec3 planet(vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5;\n\tvec3 ro = vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.4*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\tfloat h = 0.0;\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n    \n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n        float lightIntensity = 4.0;\n        float sunNDL = max(0.0,0.05+0.95*(nor.z));\n        \n        \n\t\t{\n            vec3 oceanBlue = vec3(0.0,0.031,0.11);\n            \n            vec3 q = pos;\n            \n            // Ocean\n            col = oceanBlue;\n            col = col * (0.5 + 0.5*noise(q*4.0));\n\t\t\tcol = col * (0.9 + 0.2*noise(q*8.0));\n            col = col * (0.9 + 0.2*noise(q*16.0));\n            col = col * (0.9 + 0.1*noise(q*32.0));\n            col = col * (0.9 + 0.1*noise(q*64.0));\n            \n            // Land\n            q = m * q * 2.01;\n            \n            float hm = octaves6(q+vec3(137.0)) / 1.5;\n            hm *= hm;\n            \n            f = hm;\n            float landBlend = min(4.0*max(f-0.3,0.0),1.0);\n            \n            float nG = exp(-abs(f-0.4)*20.0);//max(f - 0.4,0.0);\n            float nD = exp(-abs(f-0.6)*20.0);//3.0*max(f - 0.75,0.0);\n            float snowLevel = 0.8+ noise(q*64.0)*0.1;\n            float nS = exp(-abs(f-snowLevel)*20.0);\n            \n            vec3 snow = vec3(0.85,0.85,0.85)/1.85;\n            vec3 desert = vec3(1.5,1.3,1.0)/13.0;\n            vec3 grass = vec3(1.0,1.3,0.5)/12.0;\n            \n\t\t\tfloat normn = nG + nD + nS;\n            \n            float grassD = 1.0 + \n                (noise(q*128.0) + noise(q*64.0) + noise(q*32.0))*0.5;\n            \n            float snowD = 1.0 + (noise(q*vec3(5.0,1.0,1.0)*3.0)\n                + noise(q*16.0)*0.5 + noise(q*64.0)*0.5)*0.25;\n            \n            float desertD = 1.0 + noise(q*vec3(1.0,7.0,1.0)*3.0)\n                + noise(q*32.0)*0.5 + noise(q*64.0)*0.5;\n            \n            vec3 land = (desertD*desert*nD + grassD*grass*nG + snowD*snow*nS)/normn;\n            col = mix(col,land,landBlend);\n            \n            float shore = clamp(1.42*pow(1.0-abs(landBlend-0.4),1.0)-1.2,0.0,1.0);\n            col = mix(col, col + vec3(0.0,0.1,0.05),shore);\n        \n            \n            // Cloud shadows\n            q = m * q * 2.01 + iTime*0.03;\n            vec3 off = vec3(0.1);\n\t\t\tf = cloudForm(q+off);\n            f = 0.2 + 0.8*pow(1.0 - f*0.75,2.0);\n            col = col * f;\n            \n            // Clouds  \n\t\t\tf = cloudForm(q);\n            vec3 cloudCol =\n                vec3(0.2)+\n                0.7*noise(q*2.0) +\n                0.4*noise(q*6.0) +\n                0.2*noise(q*16.0) +\n                0.05*noise(q*32.0) + \n                0.04*noise(q*64.0);\n            cloudCol = (cloudCol + f*0.05)*0.55;\n            float opacityGain = 1.4;\n            float brightnessGain = 0.7;\n            col = mix(col,cloudCol*brightnessGain,min(f*opacityGain,1.0));\n            \n\t\t}\n\t\t\n        // Depth\n        float depth = tmin * 2.7 / 2.0;\n        \n        // Surface Diffuse Lighting\n\t\tcol *= (0.005 + sunNDL * lightIntensity);\n        \n        // Surface Specular\n        vec3 ref = reflect(nor,-vec3(0.0,0.0,-1.0));\n        float sunRDE = max(dot(ref,rd),0.0);\n        float spec = 0.125*pow(sunRDE,512.0);\n        col += spec*mix(col,vec3(1.0),0.05)*sunNDL;\n        \n        // Inner Atmosphere\n        float atm = -max(-1.0,1.1 - depth);\n        vec3 baseAtmCol = vec3(0.0,0.041,0.11)*1.5;\n        col = mix(col,baseAtmCol*sunNDL*lightIntensity,pow(atm,2.0));\n        \n        // Atmosphere glow\n        float glow = 0.0;\n        const int steps = 8;\n        const float di = (128.0/50.0)/float(steps);\n        for(int i = 0; i < steps; ++i)\n        {\n            vec3 px = ro + rd * float(i)*di;\n            vec3 tosc = sc - px;\n            float d = length(tosc);\n            float x = abs(d - 1.0);\n            float n = 0.01+max((-tosc/d).z,0.0);\n            glow += 5.5 * exp(-x*16.0) * n * di;\n        }\n        vec3 glowCol = glow * baseAtmCol;\n        \n\t\t// Background\n        float sd = 2.0 + sin(iTime*0.1)*0.1;\n        vec3 bckg = galaxy(ro,rd*sd) + glowCol;\n        float isBckg = 1.0-exp( -0.00001*tmin*tmin );\n\t\tcol = mix( col, vec3(bckg), isBckg );\n\t}\n\t\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = 1.4;//iResolution.y / iResolution.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float cz = 0.0;\n    \n    vec3 co = vec3(0.0,2.7,cz);\n    vec3 ct = vec3(0.0,30.0,cz-50.0);\n    vec3 cu = vec3(0.0,1.0,0.0);\n    \n\tmat4 cm = lookAtInv(co,ct,cu);\n    \n\tvec3 ro = vec3((uv.x-0.5)*aspect,uv.y-0.5,0.0);\n\tvec3 rd = vec3(aspect*(uv.x-0.5),uv.y-0.5,-0.5);\n\trd = normalize(rd);\n    \n    ro = ( cm * vec4(ro,1.0) ).xyz;\n    rd = ( cm * vec4(rd,0.0) ).xyz;\n    \n    vec3 nor = vec3(0.0);\n    vec3 rad = vec3(0.0);\n    \n    vec3 orange = vec3(1.0,0.4,0.0) * 0.6;\n    vec3 purple = vec3(0.4,0.1,1.0);\n    \n    vec3 atmosTop = purple;\n    vec3 atmosBot = vec3(1.0,1.0,0.7);\n    vec3 atmos = mix(atmosTop,atmosBot,-rd.y*0.5+0.5);\n    \n    rad = mix(planet(fragCoord),atmos,0.7);\n\n    const int n = 64;\n    float di = 0.16;\n    float dii = 0.002;\n    float hit = 0.0;\n    float lh = 0.0;\n    float ly = 0.0;\n    vec3 p = ro;\n    \n    for(int i = 0; i < n; ++i) {\n\n        float h = terrain(p.xz);\n\n        if(p.y < h) {\n            float t = (lh-ly)/(p.y-ly-h+lh);\n            p -= rd * di * (1.0 - t);\n            nor = terrainNormal(p.xz);\n            hit = 1.0;\n            break;\n        }\n\n        lh = h;\n        ly = p.y;\n        p += rd * di;\n        di += dii;\n    }\n    \n    if(hit > 0.0) {\n        nor.y += noise(p*32.0)*0.25;\n        nor = normalize(nor);\n\n        vec3 top = normalize(vec3(0.0,0.6,-1.0));\n        vec3 tob = normalize(-top);\n        vec3 toa = normalize(vec3(0.0,1.0,0.0));\n        vec3 tos = normalize(vec3(-1.0,0.5,0.0));\n\n        vec3 sp = vec3(p.x,p.y+0.01,p.z);\n        float shad = terrainShadow(sp,top);\n\n        vec3 dlp = max(0.0,dot(nor,top)) * shad * vec3(1.0,1.0,1.0) * 1.5;\n        vec3 dla = max(0.0,dot(nor,toa)) * 0.3 * atmos;\n        vec3 dls = max(0.0,dot(nor,tos)) * vec3(0.25);\n        vec3 dlb = max(0.0,dot(nor,tob)) * vec3(0.1);\n\n        vec3 rock = vec3(0.5,0.4,0.3);\n        vec3 frost = vec3(1.0);\n\n        float fra = clamp(pow(nor.y+noise(p)*0.6,8.0),0.0,1.0);\n        vec3 diffuse = mix(rock,frost,fra);\n\n        rad = (dlp + dlb + dls + dla) * diffuse;\n\n        float fg = 1.0 - exp(-0.07*length(p - ro));\n        rad = mix(rad,atmos,fg);\n    }\n    \n    rad += snowfall(rd+vec3(0.0,iTime,0.0),ro);\n    \n    float vgn = 1.0 - 0.5*length(vec2((uv.x-0.5)*aspect,uv.y-0.5));\n    rad *= vgn * 1.15;\n    rad *= rad * 3.0;\n    rad = sqrt(rad);\n\tfragColor = vec4(rad,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lt3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 60], [61, 61, 87, 87, 456], [458, 458, 482, 482, 654], [657, 657, 717, 717, 1025], [1027, 1027, 1051, 1051, 1262], [1264, 1264, 1299, 1299, 1590], [1592, 1592, 1616, 1616, 1855], [1857, 1857, 1894, 1894, 2197], [3092, 3092, 3120, 3120, 3553], [3555, 3555, 3594, 3594, 3929], [4057, 4057, 4082, 4082, 4430], [4433, 4433, 4463, 4463, 9362], [9364, 9364, 9421, 9421, 11853]], "test": "error"}
{"id": "4ltGDB", "name": "Prismaflower", "author": "ivansafrin", "description": "Shader a day shader 5.", "tags": ["shaderaday"], "likes": 7, "viewed": 489, "published": "Public API", "date": "1471371661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 mid = uv-vec2(0.5*aspect, 0.5);\n    fragColor = vec4(\n        (1.0-((length(mid)-0.4-abs(sin(atan(mid.x, mid.y)*2.0+(1.0*sin(iTime))))*-0.4) * 70.0)) * (length(mid)-0.2) * 10.0,\n        (1.0-((length(mid)-0.4-abs(sin(atan(mid.x, mid.y)*2.0+(2.0*sin(iTime))))*-0.4) * 70.0)) * (length(mid)-0.2) * 10.0,\n        (1.0-((length(mid)-0.4-abs(sin(atan(mid.x, mid.y)*2.0+(3.0*sin(iTime))))*-0.4) * 70.0)) * (length(mid)-0.2) * 10.0,\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 597]], "test": "valid"}
{"id": "4ltGDf", "name": "fixing hexagonal tiling", "author": "ollj", "description": "trying to fix, merge and optimize hex-tiling-code of multiple sources, i find them rather inaccurate and therefore incompatible.\n\nthis illustrates how inaccurate even iq is when it comes to hexagons, not caring how deformed it is.", "tags": ["hexagon", "hex"], "likes": 9, "viewed": 1004, "published": "Public API", "date": "1472143212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//hex tiling merger with various issues:\n//press pause when zoomed in to notice them:\n//or take a screenshot and rotate it by 90 or 60 degree and overlay it transparent.\n//the circles are not round.\n//the circle centers are not bilateral triangles.\n//yet this is the commonly used hex-tiling code.\n\n//this is the result of ollj, trying to fix the errors of iq hex-tiling code (its .w value is bad)\n//by inserting a (scaled) commonly used (optimitzed) hex-tiling code to get a better .w value\n//and both are to inaccurate that i had to twiddle values to make them overlap a bit.\n\n//firstly, both used hex-tiling-function sources lack symetry so much they are not even trying!\n//the hex centers are not forming equilateral triangles. not even close! only bilateral!\n//for the commonly used hex function!\n//and iq's hex function seems to not care ro return a precise hexagon.\n\n//secondly this needs some tweaking of all the used constants\n//to better approximate y=sin(PI/3) and y=cos(pi/3) and their inverses and x=1-y and whatever ratios of them are used.\n//Wherever these values appear, they seem to noticably lack precision when you look at this up close:\n//.5773503;\n//1.53\n//1.73\n//and these 2 twiddle factors, masking inaccuracies.\n//1.969\n//1.15\n\n//thirdly, i needed to twiddle a subroutine and the initial scaling, \n//causing the circles to not be circular or the hexagon not to be hexagonal. its pretty pathethic.\n\n//quaterly, the HexID.xy code of IQ seems to come with some rounding errors\n//on very smooth gradients. \n//possibly just an illusion of having a visible ceiling\n//for values being shown with color ranges.\n\n//you can see that functions are inaccurate in their x/y scaling of hex-centers\n//as the blue hex borders are only from IQs hex tiling code, and they are not hexagonal!\n//seeing that centers only form bilateral triangles and not equilateral triangles\n//... because both hex functions that i merged use poorly rounded x/y scaling values.\n//\n//you can also see that iq code is VERY inaccirate in the diagonals angle of a hex tile, \n//or is this an effect of (trying to hide) the above?\n\n//may use below function to check on precision:\n//return circle-circle-intersection.x; .x>.y -> 2 radii; .z= distance of circle centers.\n//float cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//circle-circle-intersection.y=sqrt((circle-circle-intersection.x*circle-circle-intersection.x)-(.x*.x));\n\n//return f[x] of a SeeSaw curve with [w]avelength and [a]mplitude; returns range [0..amp]\nfloat seeSaw(float x,float w,float a){return mod(x,w)*a;}\n//set [a]mplitude = 1/[w]avelength\nfloat seeSaw2(float x,float w){return seeSaw(x,w,1./w);}\n///return sin(t), shifted to range [0...1]\nfloat sinP(float t){return(sin(t)+1.)*.5;}\n\n//return mat2 rotation; r=2*PI -> full rotation\nmat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n\n//return distance to center of hex Tile. //taken from a most commonly used hextile function.\nfloat hexC(vec2 i){const float w=1.53,q=w*.5;//i.x*=iResolution.x/iResolution.y;\n vec2 u=i;u*=mat2(1.,-1./w,0.,1./q);\n vec3 g=vec3(u,1.-u.xy);u=floor(g).xy*mat2(1.,.5,0.,q)-i;\n return min(min(length(u),length(vec2(1,0)+u)),min(length(vec2(.5,q)+u),length(vec2(1.5,q)+u)));}\n\n//Created by inigo quilez - iq/2014 , .w replaced by ollj 2016.\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//return hex vec4(cellId.xy,DistanceToBorder.z,DistnaceToCenter.w)\nvec4 hex(vec2 p){float z=p.x*.5773503;\n vec2 q=vec2(2.*z,p.y+z),i=floor(q),f=fract(q),m=step(f.xy,f.yx);\n float v=mod(i.x+i.y,3.),//WTF???\n a=step(1.0,v),b=step(2.0,v);// distance to borders\t\n float e=dot(m,1.-f.yx+a*(f.x+f.y-1.)+b*(f.yx-2.*f));\nreturn vec4(i+a-b*m,e,hexC(p/vec2(1.73,1.969)));}\n//1.969 is a bit fiddly, rounded and likely not very accurate.\n//i assume it should be 2.0 if 1.53 and 1.73 are more precise.\n\n\n//distance to a single hexagon.\n//float hexSingle(vec2 p){p.y+=1.-.5773503;p=vec2(1)-abs(p);return min(p.x,(p*rot2(3.14/3.)).x);}\n\nvoid mainImage(out vec4 o,in vec2 i){\n vec2 p=i/iResolution.xy; \n p.y*=1.15*iResolution.y/iResolution.x; //its already sad that this needs the *1.15 twiddle factor to make circles roughly circullar.\n float t=sin(iTime*.2)*.5+.52;\n p-=iMouse.xy/iResolution.xy-vec2(.5,.0);//mouse movement\n p*=32.*t;\n vec4 h=hex(p);\n h.xy/=16.;h.xy-=0.5;//ID-color-shift\n h.w=seeSaw2(h.w-iTime*.1,.1);\n h.y+=seeSaw2(h.z-.01,.1);\n o=vec4(h.wxy,1.0);\n //float d=hexSingle(p);d=SeeSaw2(d,.03);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2421, 2511, 2549, 2549, 2568], [2569, 2604, 2635, 2635, 2660], [2661, 2704, 2724, 2724, 2746], [2748, 2796, 2815, 2815, 2862], [2864, 2957, 2976, 2976, 3230], [3232, 3449, 3466, 3466, 3744], [3873, 4004, 4041, 4041, 4478]], "test": "valid"}
{"id": "4ltGDl", "name": "Clouds Remix - Superluminous", "author": "CaliCoastReplay", "description": "Another case of me remixing the work of far better people than myself; but picking these apart helps me learn the basics of raymarching.  We are all indebted to IQ.  Optimized for fullscreen speed.\n\nOriginal at :  https://www.shadertoy.com/view/Mt3GWs", "tags": ["raymarching", "raymarch", "clouds", "iq", "shiny", "luminous", "huwb"], "likes": 9, "viewed": 361, "published": "Public", "date": "1472440071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CaliCoastReplay:  This shader is a remix of :  https://www.shadertoy.com/view/Mt3GWs , mixing\n//the work of iq, nimitz, and huwb\n\n//CaliCoastReplay - Licensing on this shader may be unclear;  most is the MIT License, but these two \n//functions were taken from an online tutorial and may be of questionable license.  (However,\n//seeing as how they were freely shared with the online community, I'd say feel free to remix freely\n//as long as the attribution comments remain.)\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts red-green-blue color to hue-saturation-value color\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts hue-saturation-value color to red-green-blue color\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\n//\n// For diagram shader showing how samples are taken:\n//\n// https://www.shadertoy.com/view/ll3GWs\n//\n// We are in the process of writing up this technique. The following github repos\n// is the home of this research.\n//\n// https://github.com/huwb/volsample\n//\n// \n//\n// Additional credits - this scene is mostly mash up of these two amazing shaders:\n//\n// Clouds by iq: https://www.shadertoy.com/view/XslGRr\n// Cloud Ten by nimitz: https://www.shadertoy.com/view/XtS3DD\n// \n\n\n\n#define SAMPLE_COUNT 16\n#define PERIOD 4.0\n\n// mouse toggle\nbool STRUCTURED = true;\n\n// cam moving in a straight line\nfloat zoom = 11.3; // 1.5;\n\nvec3 sundir = normalize(vec3(-1.0,0.0,-1.));\n\n// LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0) * p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.1 + .5 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;\n\n    vec3 q = p;\n    float f = 0.0;\n    \n    \n    f  = 0.6000*noise( q ); q = q*2.12;\n    f += 0.3500*noise( q ); q = q*1.744;\n    f += 0.2050*noise( q ); q = q*1.81;\n    f += 0.0925*noise( q );// q = q*2.005;\n    f += 0.01215*noise( q ); \n   \n    d += 3.55 * f;\n\n    d = clamp( d, 0.0, 1.0 );\n    \n    vec4 res = vec4( d );\n    \n    vec3 col = 1.15 * vec3(1.0,0.95,0.8);\n    col += vec3(1.,0.,0.) * exp2(res.x*10.-10.);\n    res.xyz = mix( col, vec3(0.7,0.7,0.7), res.x );\n    \n    return res;\n}\n\n\n// to share with unity hlsl\n#define float2 vec2\n#define float3 vec3\n#define fmod mod\nfloat mysign( float x ) { return x < 0. ? -1. : 1. ; }\nfloat2 mysign( float2 x ) { return float2( x.x < 0. ? -1. : 1., x.y < 0. ? -1. : 1. ) ; }\n\n// compute ray march start offset and ray march step delta and blend weight for the current ray\nvoid SetupSampling( out float2 t, out float2 dt, out float2 wt, in float3 ro, in float3 rd )\n{\n    if( !STRUCTURED )\n    {\n        dt = float2(PERIOD,PERIOD);\n        t = dt;\n        wt = float2(0.5,0.5);\n        return;\n    }\n    \n    // structured sampling pattern line normals\n    float3 n0 = (abs( rd.x ) > abs( rd.z )) ? float3(1., 0., 0.) : float3(0., 0., 1.); // non diagonal\n    float3 n1 = float3(mysign( rd.x * rd.z ), 0., 1.); // diagonal\n\n    // normal lengths (used later)\n    float2 ln = float2(length( n0 ), length( n1 ));\n    n0 /= ln.x;\n    n1 /= ln.y;\n\n    // some useful DPs\n    float2 ndotro = float2(dot( ro, n0 ), dot( ro, n1 ));\n    float2 ndotrd = float2(dot( rd, n0 ), dot( rd, n1 ));\n\n    // step size\n    float2 period = ln * PERIOD;\n    dt = period / abs( ndotrd );\n\n    // dist to line through origin\n    float2 dist = abs( ndotro / ndotrd );\n\n    // raymarch start offset - skips leftover bit to get from ro to first strata lines\n    t = -mysign( ndotrd ) * fmod( ndotro, period ) / abs( ndotrd );\n    if( ndotrd.x > 0. ) t.x += dt.x;\n    if( ndotrd.y > 0. ) t.y += dt.y;\n\n    // sample weights\n    float minperiod = PERIOD;\n    float maxperiod = sqrt( 2. )*PERIOD;\n    wt = smoothstep( maxperiod, minperiod, dt/ln );\n    wt /= (wt.x + wt.y);\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec4 sum = vec4(0, 0, 0, 0);\n    \n    // setup sampling - compute intersection of ray with 2 sets of planes\n    float2 t, dt, wt;\n\tSetupSampling( t, dt, wt, ro, rd );\n    \n    // fade samples at far extent\n    float f = .45; // magic number - TODO justify this\n    float endFade = f*float(SAMPLE_COUNT)*PERIOD;\n    float startFade = .99*endFade;\n    \n    for(int i=0; i<SAMPLE_COUNT; i++)\n    {\n        if( sum.a > 0.99 ) continue;\n\n        // data for next sample\n        vec4 data = t.x < t.y ? vec4( t.x, wt.x, dt.x, 0. ) : vec4( t.y, wt.y, 0., dt.y );\n        // somewhat similar to: https://www.shadertoy.com/view/4dX3zl\n        //vec4 data = mix( vec4( t.x, wt.x, dt.x, 0. ), vec4( t.y, wt.y, 0., dt.y ), float(t.x > t.y) );\n        vec3 pos = ro + data.x * rd;\n        pos *= 1.1;\n        float w = data.y;\n        t += data.zw;\n        \n        // fade samples at far extent\n        w *= smoothstep( endFade, startFade, data.x );\n        \n        vec4 col = map( pos );\n        \n        // iqs goodness\n        float dif = clamp((col.w - map(pos+0.6*sundir).w)/0.6, 0.0, 1.0 );\n        vec3 lin = vec3(0.54, 0.55, 0.60)*1.79 + 0.35*vec3(0.85, 0.57, 0.3)*dif;\n        col.xyz *= lin;\n        \n        col.xyz *= col.xyz;\n        \n        col.a *= col.a;\n        col.rgb *= col.a;\n\n        // integrate\n        sum += col * (1.2 - sum.a) * w * 0.66;\n    }\n\n    sum.xyz /= (0.001+sum.w);\n     vec3 hsv = rgb2hsv(sum.xyz);\n    hsv.x -= 0.06;\n    hsv.y -= 0.02;\n    hsv.z *=  1.2;\n    hsv.z += 0.063;\n    sum.xyz = hsv2rgb(hsv);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec3 sky( vec3 rd )\n{\n    vec3 col = vec3(0.);\n    \n    float hort = 1. - clamp(abs(rd.y), 0., 1.);\n    col += 1.25*vec3(.69,.5,.1)*exp2(hort*6.7-8.0);\n    col += .13*vec3(.5,.9,1.)*exp2(hort*2.-3.2);\n    col += 0.64*vec3(.2,.23,0.96);\n    \n     vec3 hsv = rgb2hsv(col);\n    hsv.x -= 0.1;\n    hsv.z *= hsv.z * 1.76;\n    hsv.z *=  sqrt( hsv.z )  ;\n    col = hsv2rgb(hsv);\n    \n    col.y *= col.y*1.5;\n    col /= 1.2;\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 3.0 );\n    col += .14*vec3(1.0,0.4,0.2)*pow( sun, 1.4 );\n    col += .3*vec3(.2,.9,.9)*exp2(sun*650.-650.);\n    col += .1*vec3(1.,1.,0.1)*exp2(sun*100.-100.);\n    col += .3*vec3(0.3,.7,0.)*exp2(sun*50.-50.);\n    col += .4*vec3(1.,0.5,0.15)*exp2(sun*10.-10.); \n    \n    float ax = atan(rd.y,length(rd.xz))/1.;\n    float ay = atan(rd.z,rd.x)/2.;\n    float st = texture( iChannel0, vec2(ax,ay) ).x;\n    float st2 = texture( iChannel0, 1.05*vec2(ax,ay) ).x;\n    st *= st2;\n    st = smoothstep(0.5,.98,st);\n    col = mix(col,col+1.8*st,clamp(1.-1.1*length(col),0.,1.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // click mouse to use naive raymarching\n    if( iMouse.z > 0. )\n        STRUCTURED = false;\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n   \n\tvec3 lookDir = vec3(cos(.33*iTime),0.0,sin(.70*iTime));\n\tvec3 camVel = vec3(-3.,0.,0.);\n    \n    // camera\n    vec3 ro = vec3(1.5,2.7 + sin(iTime)/2.5,1.) + iTime*camVel;\n    vec3 ta = ro + lookDir; //vec3(ro.x, ro.y, ro.z-1.);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    float fov = 1.;\n    vec3 rd = normalize( fov*p.x*uu + fov*1.2*p.y*vv + 1.5*ww );\n    \n    // divide by forward component to get fixed z layout instead of fixed dist layout\n    //vec3 rd_layout = rd/mix(dot(rd,ww),1.0,samplesCurvature);\n    vec4 clouds = raymarch( ro, rd );\n    \n    vec3 col = clouds.xyz;\n        \n    // sky if visible\n    if( clouds.w <= 0.97 )\n\t    col = mix( sky(rd), col, clouds.w );\n    \n//\tcol = clamp(col, 0., 1.);\n  //  col = smoothstep(0.,1.,col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n       \n    vec3 hsv = rgb2hsv(col);\n  //  hsv.x += 0.072;\n    hsv.y -= hsv.z/9.5;\n    hsv.y*=1.2;\n    hsv.z*=1.2;\n    col = hsv2rgb(hsv);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltGDl.jpg", "access": "shaders20k", "license": "mit", "functions": [[477, 710, 732, 732, 1063], [1065, 1298, 1320, 1320, 1489], [2163, 2191, 2217, 2217, 2445], [2448, 2448, 2471, 2471, 3022], [3025, 3110, 3135, 3135, 3164], [3165, 3165, 3192, 3192, 3254], [3256, 3352, 3446, 3446, 4626], [4628, 4628, 4669, 4669, 6243], [6245, 6245, 6266, 6266, 7296], [7298, 7298, 7355, 7399, 8701]], "test": "error"}
{"id": "4ltGRs", "name": "Plane Deformations (original)", "author": "platosha", "description": "Originally made in 2012 by me in glsl.heroku.com. Now exists in several copies on the internets.\n\nThe widely known version has an issue: during the planes into a tunnel transition, one of the planes is flipped. This is a fixed, more symmetric version.", "tags": ["procedural"], "likes": 4, "viewed": 684, "published": "Public API", "date": "1470924984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plane Deformations\n// by Anton Platonov <platosha@gmail.com>\n// twitter.com/platosha\n\n// Inspired by iqs articles and code. See:\n// http://www.iquilezles.org/www/articles/deform/deform.htm\n// http://www.iquilezles.org/apps/shadertoy/index2.html\n\nconst float TAU = 6.2832;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float time = iTime;\n\n\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\tvec2 p = -1.0 + 2.0 * position;\n\tp *= vec2( iResolution.x/iResolution.y, 1.0 );\n\t\n\tfloat alpha = -time * 0.13;\n\tfloat sinA = sin(alpha), cosA = cos(alpha);\n\tp = vec2(cosA*p.x+sinA*p.y, -sinA*p.x+cosA*p.y);\n\t\n\tvec2 q = p;\n\tvec2 dir = vec2( sin(time*0.19), cos(time*0.27) ) * 0.333;\n\tq = p + dir/pow(0.5, 1.0-dot(p-dir,p-dir));\n\t\n\tq = mix(q, p, sin(time*0.78));\n\t\n\tfloat zr = 1.0/length(q);\n\tfloat zp = 1.0/abs(q.y);\n\tfloat mc = sin(time*0.16)*.5 + .5;\n\tmc = smoothstep(0.0, 1.0, mc);\n\tmc = smoothstep(0.0, 1.0, mc);\n\tmc = smoothstep(0.0, 1.0, mc);\n\tmc = smoothstep(0.0, 1.0, mc);\n\tfloat z = mix(zr, zp, mc);\n\tfloat ur = 5.0*atan(q.x*sign(q.y), abs(q.y))/TAU + cos(0.2*z*TAU+time*1.37) * 1.2 * sin( time * 0.21 );\n\tfloat up = q.x*sign(q.y)*z;\n\tfloat u = mix(ur, up, mc);\n\tvec2 uv = vec2(u, (1.0+mc*2.0)*z);\n\t\n\tfloat mv = sin(time * 0.55);\n\t\n\tfloat color = 0.0;\n\tcolor = cos(uv.x*TAU) * cos(uv.y*TAU + time*7.7);\n\tcolor = pow(abs(cos(color*TAU)), 3.0);\n\t\n\tfloat color2 = 0.0;\n\tcolor2 = cos(uv.x*TAU*2.0);\n\tcolor2 -= 0.25;\n\t\t\n\tfloat shadow = 1.0/(z*z);\n\tvec3 rc = vec3(0.9, 1.0, 0.8)*color +\n\t\t  vec3(0.3, 0.7, 0.6)*color2;\n\trc *= shadow;\n\t\n\tfragColor = vec4( rc, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 279, 336, 336, 1588]], "test": "valid"}
{"id": "4t33DS", "name": "iso cells", "author": "tomaes", "description": "v1.2 now.", "tags": ["2d", "noise", "pink", "style", "argh"], "likes": 1, "viewed": 172, "published": "Public", "date": "1471091561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// v1.2\nfloat iso(float _x, float _y, float _z)\n{\n    return 1.3/(_x*_x + _y*_y + _z*_z) > 5. ? 1. : .0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    float t = iTime + .4;\n    \n    uv.y += sin(t*1.5+uv.x*.1+uv.y*3.);\n    uv.x /= (sin(t*2.5-uv.y*uv.y*2.1))*.8;\n    \n    float col = sin( length(uv)*.01 /uv.x*(.2/cos(length(uv)*20.) * 10./cos(t+uv.x*4.+uv.y*4.)));\n    \n    for(float z = 1.5; z > -.1; z -= .06)\n    {\n        col += iso(uv.x, uv.y, z) * z;       \n        col -= iso(.5-uv.x+sin(t)*.2, uv.y, z)*.1;\n    }\n    \n    if (uv.x < -.75 || uv.x > .75)\n        col = .85;\n    \n    vec4 colf = vec4(col*.9,col*.2,length(.12*uv/col),1.);\n\n    fragColor = .4*length(uv)*vec4(length(colf)) + colf*.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t33DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 49, 49, 106], [108, 108, 165, 165, 788]], "test": "valid"}
{"id": "4t33WN", "name": "Classic Mandelbrot Set", "author": "takkasila", "description": "Trying Mandelbrot set", "tags": ["fractal", "mandelbrot"], "likes": 2, "viewed": 106, "published": "Public", "date": "1471356689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoom = pow( 0.5, 13.0*tz );\n\n    vec2 pos = fragCoord.xy/iResolution.xy;\n    pos = (pos*2.-1.)*zoom;\n    pos.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec2 z = vec2(0.0);\n    vec2 c = vec2(-0.05,.6805) + pos;\n    for(int i =0; i< 250; i++)\n    {\n        z = vec2(\n                z.x*z.x-z.y*z.y+c.x\n                , 2.*z.x*z.y+c.y\n            );\n        if (length(z) > 4.) break;\n        col = vec3(step(0.5, mod(float(i),2.)));\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t33WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 605]], "test": "valid"}
{"id": "4t3GDs", "name": "WTF", "author": "polyrhythm", "description": "wtf", "tags": ["wtf"], "likes": 2, "viewed": 214, "published": "Public", "date": "1472272627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 pos, float radius) {\n    vec3 q = fract(pos) * 2.0 - 1.0;\n\treturn length(q) - radius;   \n}\n\nconst int ITER = 32;\nconst float GAIN = 0.6;\nfloat trace(vec3 origin, vec3 ray, float freq) {\n    float t = 0.0;\n    for (int i = 0; i < ITER; ++i) {\n     \tvec3 p = origin + (ray - vec3(\n            sin(iTime) * 0.1,\n            cos(iTime) * 0.1,\n            0.0\n        )) * t;\n        float d = map(p, freq * GAIN);\n        t += d * 0.5;\n    }\n    \n    return t;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 0.0, iTime / 5.0);\n    float t = trace(origin, ray, freqs[3]);\n    float fog = 1.0 / (1.0 + pow(t, 2.0) * max(\n        \t\t\t\t\t\t\t\t\t0.05,\n                                            abs(sin(iTime) * 0.2 + 0.1)));\n    vec3 fc = vec3(fog, fog, fog * 1.5);\n    fragColor = vec4(fc, 1.0);\n}", "image_inputs": [{"id": "Md2GR1", "previewfilepath": "https://soundcloud.com/ziggy2210/hotline-miami-soundtrack", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/ziggy2210/hotline-miami-soundtrack", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3GDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 105], [152, 152, 200, 200, 473], [492, 492, 549, 549, 1248]], "test": "error"}
{"id": "4t3Gzs", "name": "Basic rotating circle", "author": "plafone", "description": "Spinning circle usefull for loading screen or similar", "tags": ["2d", "circle", "rotate", "ui"], "likes": 2, "viewed": 125, "published": "Public", "date": "1470783257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n    return vec4(color, 1.0 - t);\n}\n\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Parameters\n    vec3 backCol = rgb(133.0, 224.0, 224.0);\n    vec3 backCirCol = rgb(0.0, 75.0, 102.0);\n    vec3 rotCirCol = rgb(204.0, 255.0, 0.0);\n    \n\tfloat radiusRotM = 0.04;\n    float radiusBackM = 0.2;\n\n   \tvec2 uv = fragCoord.xy;\n\tfloat radiusRot = radiusRotM * iResolution.y;\n    float radiusBack = radiusBackM * iResolution.y;\n    \n    //Play around with this magic numbers to achieve a different rotation\n    float c=cos(iTime * 5.0 + cos(iTime * 5.0)*.5) * 90.0;\n    float s=sin(iTime * 5.0 + cos(iTime * 5.0)*.5) * 90.0;\n    vec2 center = iResolution.xy * 0.5;\n    vec2 centerRot = center + vec2(s, c); //clockwise\n    \n    // Background\n\tvec4 back = vec4(backCol, 0.0);\n\t\n\t// Circles\n\tvec4 rotCircle = circle(uv, centerRot, radiusRot, rotCirCol);\n    vec4 backCircle = circle(uv, center, radiusBack, backCirCol);\n\t\n    vec4 circleColor = mix(back, backCircle, backCircle.a);\n\tfragColor = mix(circleColor, rotCircle, rotCircle.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3Gzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 156], [158, 158, 195, 195, 244], [246, 246, 303, 321, 1253]], "test": "valid"}
{"id": "4tc3D2", "name": "mario in wonderland", "author": "tomaes", "description": "v1.1: smaller mario, tidy hill, platforms for mini marios, who also jump now. deactivated dissolve fx.", "tags": ["2d", "simple", "mario", "nintendo", "8bit"], "likes": 2, "viewed": 243, "published": "Public", "date": "1471538285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// mario in wonderland (v1.1) by tomaes 20160818+19\nbool brect(vec2 _uv, float _x,  float _y, \n                     float _bw, float _bh,\n                     float _lstart, float _lend,\n                     float _line)\n{\n    return ((_uv.x                > _x+_bw*_lstart && _uv.x           < _x+_bw*_lend) &&\n            (_uv.y+_bh*(_line+1.) > _y             && _uv.y+_bh*_line < _y));\n}        \n\n\nvec4 mario(vec2 _uv, float _x, float _y, float _w, float _h)\n{\n    float bw = _w / 12.;\n    float bh = _h / 16.;\n    \n    vec4 col    = vec4(.0);\n    vec4 pal_r  = vec4( 1.,  .1,  .1,  1.);\n    vec4 pal_g  = vec4(  .5, .5,  .1,  1.);\n    vec4 pal_br = vec4( 1.,  .75, .2,  1.);\n    \n    // line 1,2 (hat)\n    if (brect(_uv,_x,_y, bw, bh, 3., 8.,1.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 2.,11.,2.)) col = vec4(pal_r);\n\n    // line 3.. (face)\n    if (brect(_uv,_x,_y, bw, bh, 2., 5.,3.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 5., 7.,3.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 7., 8.,3.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 8., 9.,3.)) col = vec4(pal_br);\n    \n    // line 4.. (face)\n    if (brect(_uv,_x,_y, bw, bh, 1., 2.,4.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 2., 3.,4.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 3., 4.,4.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 4., 7.,4.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 7., 8.,4.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 8.,11.,4.)) col = vec4(pal_br);\n\n    // line 5.. (face)\n    if (brect(_uv,_x,_y, bw, bh, 1., 2.,5.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 2., 3.,5.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 3., 5.,5.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 5., 8.,5.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 8., 9.,5.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 9.,12.,5.)) col = vec4(pal_br);\n\n    // line 6.. (face)\n    if (brect(_uv,_x,_y, bw, bh, 1., 3.,6.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 3., 7.,6.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 7.,11.,6.)) col = vec4(pal_g);\n    \n    // line 7.. (face)\n    if (brect(_uv,_x,_y, bw, bh, 3.,10.,7.)) col = vec4(pal_br);\n    \n    // line 8.. (body)\n    if (brect(_uv,_x,_y, bw, bh, 2.,4.,8.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 4.,5.,8.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 5.,8.,8.)) col = vec4(pal_g);\n    \n    // line 9.. (body)\n    if (brect(_uv,_x,_y, bw, bh, 1., 4.,9.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 4., 5.,9.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 5., 7.,9.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 7., 8.,9.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 8.,11.,9.)) col = vec4(pal_g);\n\n    // line 10.. (body)\n    if (brect(_uv,_x,_y, bw, bh, 0., 4.,10.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 4., 8.,10.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 8.,12.,10.)) col = vec4(pal_g);\n    \n    // line 11.. (body)\n    if (brect(_uv,_x,_y, bw, bh, 0., 2.,11.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 2., 3.,11.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 3., 4.,11.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 4., 5.,11.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 5., 7.,11.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 7., 8.,11.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 8., 9.,11.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 9.,10.,11.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh,10.,12.,11.)) col = vec4(pal_br);\n    \n    // line 12.. (body)\n    if (brect(_uv,_x,_y, bw, bh, 0., 3.,12.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 3., 9.,12.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 9.,12.,12.)) col = vec4(pal_br);\n\n    // line 13.. (body)\n    if (brect(_uv,_x,_y, bw, bh, 0., 2.,13.)) col = vec4(pal_br);\n    if (brect(_uv,_x,_y, bw, bh, 2.,10.,13.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh,10.,12.,13.)) col = vec4(pal_br);\n    \n    // line 14.. (legs)\n    if (brect(_uv,_x,_y, bw, bh, 2., 5.,14.)) col = vec4(pal_r);\n    if (brect(_uv,_x,_y, bw, bh, 7.,10.,14.)) col = vec4(pal_r);\n\n    // line 15.. (feet)\n    if (brect(_uv,_x,_y, bw, bh, 1., 4.,15.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 8.,11.,15.)) col = vec4(pal_g);\n\n    // line 16.. (feet)\n    if (brect(_uv,_x,_y, bw, bh, 0., 4.,16.)) col = vec4(pal_g);\n    if (brect(_uv,_x,_y, bw, bh, 8.,12.,16.)) col = vec4(pal_g);\n\n    return col+_uv.y*.01;\n}\n\nfloat yoff(float _x, float _t)\n{\n    return sin( 3.14159 * _x + _t*2.) + sin(_x*15. + _t*2.)*.06;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float t = mod(iTime+1.5, 100.);\n    \n    float j = 1.6-.8+sin(t)*.25;\n    \n    vec4 c = vec4(.0);\n    \n    // background\n    vec4 b = vec4(.4-uv.y*.1,\n                  .2+ sin(.5+uv.x*20.+t)/sqrt( sin(t*2.+uv.x*100.)+cos(uv.y*100.)), \n                  .89-uv.y*.22 - mod(uv.x-uv.y,.05)*2., \n                  1.);\n    \n    // render main mario\n    vec4 m  = mario(uv,.392 ,j,      .15, abs(.45+sin(t*5.+uv.x*5.)*.1 )) * .2;\n         m += mario(uv,.400 ,j+.008, .15, abs(.45+sin(t*5.+uv.x*5.)*.1 ));\n    \n    // mini marios on hill\n    for(float fx = .0; fx < 1.1; fx += .1)\n    {\n       m += (mario( uv, fx, .2+yoff(uv.x,t)+abs(sin(t+fx*10.)*.1), .04,.15)) * .6;\n    }\n\n    // mario cut-out/dissolve\n    if (length(m) > .2) // 1.5+sin(t*5.+uv.x*5.)\n    \tc = m;\n    else\n        c = b;\n    \n    // calc jump for board\n    j = j - .54 - abs(.65+sin(t*5.+(uv.x)*5.)*.2 );\n    \n\t// board\n    if (uv.x  > .35 && uv.x < .58 && \n        uv.y  > .57+j && uv.y < .65+j)\n        c = vec4(1.,.8,.7, 1.)- mod(uv.x,.1)*2.;\n\n    // hill platforms\n    if (uv.y > (yoff(uv.x,t)+.01) && uv.y < (yoff(uv.x,t)+.05) && mod(uv.x,.1) < .05 )\n    {\n        c = vec4(.9,.6,.2, 1.);\n    }\n    \n    // hill\n    if (uv.y < yoff(uv.x,t) && \n        mod(uv.x*.01+uv.y+yoff(uv.x,t),.1) < .09)\n    {\n        c = vec4(.7, .3+uv.y, .1, 1.);\n    }\n        \n    // columns: left\n    if (uv.x < .07)\n        c *= (.1-uv.x)*10.;\n\n    // columns: right\n    if (uv.x > .93)\n        c *= 1.-(1.-uv.x)*10.;\n        \n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tc3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 222, 222, 391], [402, 402, 464, 464, 4601], [4603, 4603, 4635, 4635, 4702], [4705, 4705, 4762, 4762, 6318]], "test": "valid"}
{"id": "4tc3R2", "name": "waves plotter", "author": "miloszmaki", "description": "a simple 2D function plotter for testing wave functions", "tags": ["2d", "waves", "plot"], "likes": 4, "viewed": 612, "published": "Public API", "date": "1470171459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592;\n\nconst vec2 range = vec2(60, 10);\nconst float lineThickness = 3.;\nconst float gridThickness = 1.;\n\nconst float speed = 2. * PI / 5.;\n\nvec3 plot(float fy, vec2 uv, vec3 color)\n{\n    return color * step(abs(fy - uv.y) * iResolution.y, lineThickness * range.y);\n}\n\nfloat f1(float x)\n{\n    x -= iTime * speed;\n    return sin(x);\n}\n\nfloat f2(float x)\n{\n    return sin(x * 1.2);\n}\n\nfloat rand(float x) { return fract(sin(4798.103853 * x)); }\n\n\nfloat noise(float x)\n{\n    float i = floor(x);\n    float f = fract(x);\t\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix(rand(i), rand(i+1.), u);\n}\n\nvec3 plotFunctions(vec2 uv)\n{\n    vec3 c = vec3(0,0,0);\n    \n    c += plot(f1(uv.x), uv, vec3(0,0.5,0.8));\n    c += plot(f2(uv.x), uv, vec3(0.7,0.5,0));\n    c += plot(f1(uv.x) + f2(uv.x), uv, vec3(0,1,0));\n    c += plot(f1(uv.x) * f2(uv.x), uv, vec3(0.5,0,0.8));\n    \n    float y=0.;\n    for (float i=0.; i<6.; i++)\n    {\n        float offset = iTime * speed / (i+1.);\n        offset *= fract(i * 0.5)*4. - 1.;\n        float freq = 0.5*i+1.;\n        float amp = 1. / (i+1.);\n        y += sin((uv.x + offset)*freq) * amp;\n    }\n    c += plot(y * 0.4 + 3., uv, vec3(1,1,1));\n    \n    c += plot(0.5 * noise(2.*uv.x + iTime * speed) - 3., uv, vec3(1,1,1));\n        \n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    \n    // grid\n    fragColor.r = step(abs(uv.x) * iResolution.x, gridThickness) +\n        step(abs(uv.y) * iResolution.y, gridThickness);\n    \n    // plotFunctions\n    fragColor.rgb += plotFunctions(uv * range);\n    fragColor.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tc3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 203, 203, 287], [289, 289, 308, 308, 353], [355, 355, 374, 374, 401], [403, 403, 424, 424, 462], [465, 465, 487, 487, 606], [608, 608, 637, 637, 1282], [1284, 1284, 1341, 1341, 1636]], "test": "valid"}
{"id": "4tc3Rf", "name": "Worley Hyperdisc - Plasma", "author": "CaliCoastReplay", "description": "Another nice mix of the Yeis Worley noise shader at https://www.shadertoy.com/view/Xl33Wn and the hyperbolic disc from : https://www.shadertoy.com/view/XllSWf", "tags": ["worley", "disc", "mattdamon", "hyperbolic", "yeis"], "likes": 23, "viewed": 1809, "published": "Public", "date": "1470437299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Adapted from:  https://www.shadertoy.com/view/Xl33Wn\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat length2(vec2 p){\n    return dot(p,p);\n}\nfloat noise(vec2 p )\n{\n    return fract(sin(fract(sin(p.x)*(41.13311))+ p.y)*31.0011);\n}\n\nfloat worley(vec2 p) {\n float d = 1e30;\n for (int xo = -1; xo <= 1; ++xo) {\n  for (int yo = -1; yo <= 1; ++yo) {\n   vec2 tp = floor(p) + vec2(xo, yo);\n   d = min(d, length2(p - tp - noise(tp)));\n  }\n }\n  return 3.0*exp(-4.0*abs((2.5*d)-1.0));\n}\n\nfloat fworley(vec2 p)\n{\n    return sqrt(sqrt(sqrt(worley(p * 5.0 + 0.15 * iTime) * \n                          sqrt(worley(p*50.0+ 0.18+ -0.1*iTime)) *\n                         sqrt(sqrt(worley(p*-10.0+0.3*iTime))))));\n}\n\n\n\n//hyperbolic disc/radial distortion adapted from https://www.shadertoy.com/view/XllSWf\nvoid HyperbolicDisc(inout vec2 fragCoord) {\n    fragCoord -= iResolution.xy * 0.5;\n    fragCoord /= iResolution.x;\n    float r = length(fragCoord);\n    vec2 d = fragCoord / r *.8 ;\n    fragCoord = d / atanh(r * (2.5 )) / 2.0;\n    fragCoord *= iResolution.x;\n    fragCoord += iResolution.xy *0.5;\n    fragCoord *= 0.4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    HyperbolicDisc(fragCoord);\n vec2 uv = fragCoord.xy / iResolution.xy;\n    float wolo = fworley(uv*iResolution.xy / 1500.0);\n \twolo *= exp(-length2(abs(0.7*uv-1.0)));\n    fragColor = vec4(wolo * vec3(1.0, 0.1*wolo, pow(wolo, 0.90-wolo)), 1.0);\n    vec3 hsv = rgb2hsv(fragColor.xyz);\n    hsv.z *= hsv.z * 20.8;\n    fragColor.xyz = hsv2rgb(hsv);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tc3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 77, 77, 408], [410, 410, 432, 432, 601], [603, 603, 625, 625, 648], [649, 649, 671, 671, 737], [739, 739, 761, 761, 983], [985, 985, 1008, 1008, 1204], [1208, 1295, 1338, 1338, 1614], [1616, 1616, 1673, 1673, 2026]], "test": "valid"}
{"id": "4tc3WB", "name": "Shaderdough", "author": "tdhooper", "description": "Offsetting the centre of the icosahedron-twist operation gives some fun results.", "tags": ["sdf", "twist", "pastel", "playdough"], "likes": 132, "viewed": 4863, "published": "Public API", "date": "1471136306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --------------------------------------------------------\n// OPTIONS\n// --------------------------------------------------------\n\n// Disable to see more colour variety\n#define SEAMLESS_LOOP\n//#define COLOUR_CYCLE\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n\nfloat t;\n\n#define saturate(x) clamp(x, 0., 1.)\n\n\n// --------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n// --------------------------------------------------------\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n// --------------------------------------------------------\n// http://math.stackexchange.com/a/897677\n// --------------------------------------------------------\n\nmat3 orientMatrix(vec3 A, vec3 B) {\n    mat3 Fi = mat3(\n        A,\n        (B - dot(A, B) * A) / length(B - dot(A, B) * A),\n        cross(B, A)\n    );\n    mat3 G = mat3(\n        dot(A, B),              -length(cross(A, B)),   0,\n        length(cross(A, B)),    dot(A, B),              0,\n        0,                      0,                      1\n    );\n    return Fi * G * inverse(Fi);\n}\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector3b normalize(vec3(-1, -1, -1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector4b normalize(vec3(-1, -1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector5b normalize(vec3(1, -1, -1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n#define GDFVector6b normalize(vec3(-1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector7b normalize(vec3(0, 1, -PHI-1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector8b normalize(vec3(0, -1, -PHI-1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector9b normalize(vec3(PHI+1., 0, -1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector10b normalize(vec3(-PHI-1., 0, -1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector11b normalize(vec3(1, -PHI-1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n#define GDFVector12b normalize(vec3(-1, -PHI-1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector13b normalize(vec3(0, PHI, -1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector14b normalize(vec3(0, -PHI, -1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector15b normalize(vec3(1, 0, -PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector16b normalize(vec3(-1, 0, -PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector17b normalize(vec3(PHI, -1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n#define GDFVector18b normalize(vec3(-PHI, -1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat around an axis\nvoid pModPolar(inout vec3 p, vec3 axis, float repetitions, float offset) {\n    vec3 z = vec3(0,0,1);\n\tmat3 m = orientMatrix(axis, z);\n    p *= inverse(m);\n    pR(p.xy, offset);\n    pModPolar(p.xy, repetitions);\n    pR(p.xy, -offset);\n    p *= m;\n}\n\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nint Type=5;\nvec3 nc;\nvec3 pbc;\nvec3 pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\nfloat indexSgn(float s) {\n\treturn s / 2. + 0.5;\n}\n\nbool boolSgn(float s) {\n\treturn bool(s / 2. + 0.5);\n}\n\nfloat pModIcosahedronIndexed(inout vec3 p, int subdivisions) {\n\tfloat x = indexSgn(sgn(p.x));\n\tfloat y = indexSgn(sgn(p.y));\n\tfloat z = indexSgn(sgn(p.z));\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n\n\tfloat xai = sgn(p.x);\n\tfloat yai = sgn(p.y);\n    p.xy = abs(p.xy);\n\tfloat sideBB = pReflect(p, nc, 0.);\n\n\tfloat ybi = sgn(p.y);\n\tfloat xbi = sgn(p.x);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    float idx = 0.;\n\n    float faceGroupAi = indexSgn(ybi * yai * -1.);\n    float faceGroupBi = indexSgn(yai);\n    float faceGroupCi = clamp((xai - ybi -1.), 0., 1.);\n    float faceGroupDi = clamp(1. - faceGroupAi - faceGroupBi - faceGroupCi, 0., 1.);\n\n    idx += faceGroupAi * (x + (2. * y) + (4. * z));\n    idx += faceGroupBi * (8. + y + (2. * z));\n    # ifndef SEAMLESS_LOOP\n    \tidx += faceGroupCi * (12. + x + (2. * z));\n    # endif\n    idx += faceGroupDi * (12. + x + (2. * y));\n\n\treturn idx;\n}\n\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// tdhooper\n// https://www.shadertoy.com/view/Mtc3RX\n// --------------------------------------------------------\n\nvec3 vMin(vec3 p, vec3 a, vec3 b, vec3 c) {\n    float la = length(p - a);\n    float lb = length(p - b);\n    float lc = length(p - c);\n    if (la < lb) {\n        if (la < lc) {\n            return a;\n        } else {\n            return c;\n        }\n    } else {\n        if (lb < lc) {\n            return b;\n        } else {\n            return c;\n        }\n    }\n}\n\n// Nearest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    if (p.z > 0.) {\n        if (p.x > 0.) {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13, GDFVector15, GDFVector17);\n            } else {\n                return vMin(p, GDFVector14, GDFVector15, GDFVector17b);\n            }\n        } else {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13, GDFVector16, GDFVector18);\n            } else {\n                return vMin(p, GDFVector14, GDFVector16, GDFVector18b);\n            }\n        }\n    } else {\n        if (p.x > 0.) {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13b, GDFVector15b, GDFVector17);\n            } else {\n                return vMin(p, GDFVector14b, GDFVector15b, GDFVector17b);\n            }\n        } else {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13b, GDFVector16b, GDFVector18);\n            } else {\n                return vMin(p, GDFVector14b, GDFVector16b, GDFVector18b);\n            }\n        }\n    }\n}\n\n// Nearest vertex and distance.\n// Distance is roughly to the boundry between the nearest and next\n// nearest icosahedron vertices, ensuring there is always a smooth\n// join at the edges, and normalised from 0 to 1\nvec4 icosahedronAxisDistance(vec3 p) {\n    vec3 iv = icosahedronVertex(p);\n    vec3 originalIv = iv;\n\n    vec3 pn = normalize(p);\n    pModIcosahedron(pn);\n    pModIcosahedron(iv);\n\n    float boundryDist = dot(pn, vec3(1, 0, 0));\n    float boundryMax = dot(iv, vec3(1, 0, 0));\n    boundryDist /= boundryMax;\n\n    float roundDist = length(iv - pn);\n    float roundMax = length(iv - vec3(0, 0, 1.));\n    roundDist /= roundMax;\n    roundDist = -roundDist + 1.;\n\n    float blend = 1. - boundryDist;\n\tblend = pow(blend, 6.);\n    \n    float dist = mix(roundDist, boundryDist, blend);\n\n    return vec4(originalIv, dist);\n}\n\n// Twists p around the nearest icosahedron vertex\nvoid pTwistIcosahedron(inout vec3 p, float amount) {\n    vec4 a = icosahedronAxisDistance(p);\n    vec3 axis = a.xyz;\n    float dist = a.a;\n    mat3 m = rotationMatrix(axis, dist * amount);\n    p *= m;\n}\n\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n     \nModel fInflatedIcosahedron(vec3 p, vec3 axis) {\n    float d = 1000.;\n    \n    # ifdef SEAMLESS_LOOP\n    \t// Radially repeat along the rotation axis, so the\n    \t// colours repeat more frequently and we can use\n    \t// less frames for a seamless loop\n    \tpModPolar(p, axis, 3., PI/2.);\n\t# endif\n    \n    // Slightly inflated icosahedron\n    float idx = pModIcosahedronIndexed(p, 0);\n    d = min(d, dot(p, pca) - .9);\n    d = mix(d, length(p) - .9, .5);\n\n    // Colour each icosahedron face differently\n    # ifdef SEAMLESS_LOOP\n    \tif (idx == 3.) {\n    \t\tidx = 2.;\n    \t}\n    \tidx /= 10.;\n   \t# else\n    \tidx /= 20.;\n    # endif\n    # ifdef COLOUR_CYCLE\n    \tidx = mod(idx + t*1.75, 1.);\n    # endif\n    vec3 colour = spectrum(idx);\n    \n    d *= .6;\n\treturn Model(d, colour, 1.);\n}\n\nvoid pTwistIcosahedron(inout vec3 p, vec3 center, float amount) {\n    p += center;\n    pTwistIcosahedron(p, 5.5);\n    p -= center;\n}\n\nModel model(vec3 p) {\n    float rate = PI/6.;\n    vec3 axis = pca;\n\n    vec3 twistCenter = vec3(0);\n    twistCenter.x = cos(t * rate * -3.) * .3;\n\ttwistCenter.y = sin(t * rate * -3.) * .3;\n\n\tmat3 m = rotationMatrix(\n        reflect(axis, vec3(0,1,0)),\n        t * -rate\n   \t);\n    p *= m;\n    twistCenter *= m;\n\n    pTwistIcosahedron(p, twistCenter, 5.5);\n\n\treturn fInflatedIcosahedron(p, axis);\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 30.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//--------------------------------\n// Modelling\n//--------------------------------\nModel map( vec3 p ){\n    return model(p);\n}\n\n// LIGHTING\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).dist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvec3 doLighting(vec3 col, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n\n    // lighitng        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, 0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    //float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    //float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n    \n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    //dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    //lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    //lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n\n    return col;\n}\n\nstruct Hit {\n    float len;\n    vec3 colour;\n    float id;\n};\n\nHit calcIntersection( in vec3 ro, in vec3 rd ){\n\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    vec3 colour;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n        if( abs(h) < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        Model m = map( ro+rd*t );\n        h = m.dist;\n        t += h;\n        id = m.id;\n        colour = m.colour;\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return Hit( res , colour , id );\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n\n    float x = mouse.x;\n    float y = mouse.y;\n    \n    x = .65;\n    y = .44;\n    \n    float dist = 3.3;\n    float height = 0.;\n    camPos = vec3(0,0,-dist);\n    vec3 axisY = vec3(0,1,0);\n    vec3 axisX = vec3(1,0,0);\n    mat3 m = rotationMatrix(axisY, -x * PI * 2.);\n    axisX *= m;\n    camPos *= m;\n    m = rotationMatrix(axisX, -(y -.5) * PI*2.);\n    camPos *= m;\n    camPos.y += height;\n    camTar = -camPos + vec3(.0001);\n    camTar.y += height;\n    camRoll = 0.;\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nvec2 ffragCoord;\n\nvec3 render( Hit hit , vec3 ro , vec3 rd ){\n\n    vec3 pos = ro + rd * hit.len;\n\n    vec3 color = vec3(.04,.045,.05);\n    color = vec3(.35, .5, .65);\n    vec3 colorB = vec3(.8, .8, .9);\n    \n    vec2 pp = (-iResolution.xy + 2.0*ffragCoord.xy)/iResolution.y;\n    \n    color = mix(colorB, color, length(pp)/1.5);\n\n\n    if (hit.id == 1.){\n        vec3 norm = calcNormal( pos );\n        vec3 ref = reflect(rd, norm);\n        color = doLighting(hit.colour, pos, norm, ref, rd);\n    }\n\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initIcosahedron();\n    t = iTime - .25;\n    //t = mod(t, 4.);\n    \n    ffragCoord = fragCoord;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n\n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    Hit hit = calcIntersection( camPos , rd  );\n\n\n    vec3 color = render( hit , camPos , rd );\n\tcolor = linearToScreen(color);\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tc3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 513, 558, 558, 1024], [1027, 1190, 1225, 1225, 1577], [3729, 3752, 3790, 3790, 3934], [3936, 3936, 3973, 3973, 4186], [4188, 4188, 4208, 4208, 4246], [4248, 4248, 4268, 4268, 4293], [4295, 4369, 4425, 4425, 4470], [4472, 4508, 4536, 4536, 4617], [4619, 4703, 4747, 4747, 4850], [4852, 4924, 4973, 4973, 5010], [5012, 5250, 5282, 5282, 5327], [5329, 5357, 5419, 5419, 5543], [5545, 5658, 5708, 5708, 6098], [6100, 6125, 6199, 6199, 6372], [6375, 6589, 6613, 6646, 7064], [7066, 7066, 7102, 7102, 7239], [7241, 7241, 7266, 7266, 7290], [7292, 7292, 7315, 7315, 7345], [7347, 7347, 7409, 7409, 8243], [8246, 8414, 8482, 8482, 8525], [8527, 8527, 8551, 8551, 8649], [8652, 8826, 8869, 8869, 9187], [9189, 9219, 9251, 9251, 10226], [10228, 10443, 10481, 10481, 11057], [11059, 11109, 11161, 11161, 11311], [11314, 11514, 11561, 11561, 12297], [12299, 12299, 12364, 12364, 12431], [12433, 12433, 12454, 12454, 12830], [13094, 13188, 13217, 13217, 13253], [13255, 13338, 13358, 13358, 13381], [13383, 13396, 13470, 13470, 13743], [13746, 13746, 13788, 13788, 14093], [14121, 14121, 14154, 14154, 14188], [14190, 14190, 14227, 14227, 14271], [14273, 14273, 14339, 14364, 15273], [15338, 15338, 15385, 15385, 15885], [15888, 15919, 15983, 15983, 16161], [16163, 16163, 16261, 16261, 16732], [16734, 16847, 16878, 16878, 17136], [17156, 17156, 17199, 17199, 17652], [17655, 17655, 17712, 17712, 18476]], "test": "error"}
{"id": "4tc3Wf", "name": "Raytraced Volumetrics", "author": "jackdavenport", "description": "My attempt to create a solution for volumetric light. Based on attic: https://www.shadertoy.com/view/Mdl3Rr", "tags": ["noise", "raytracer", "fbm", "shadow", "lighting", "perlin", "volumetric", "raytraced", "smoke"], "likes": 15, "viewed": 1256, "published": "Public API", "date": "1471941280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VOLUME_SAMPLES 64\n\nstruct Hit { vec3 p; vec3 n; int id; };\n\nHit intersectSphere(vec3 ori, vec3 dir, vec3 p, float r) {\n    \n    float a = dot(dir,dir), b = 2. * dot(dir,ori-p), c = dot(ori-p,ori-p)-(r*r);\n    float d = (b*b)-4.*a*c;\n    float l = (-b-sqrt(d))/(2.*a);\n    \n    vec3 pos = ori+dir*l;\n    return Hit(pos,normalize(pos-p),(d >= 0. && l >= 0.) ? 0 : -1);\n    \n}\nHit intersect(vec3 ori, vec3 dir) {\n\treturn intersectSphere(ori,dir,vec3(0.),1.);   \n}\n\nvec3 getLightVector(vec3 p) {\n\treturn vec3(10.*cos(iTime),0.,3.)-p;\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n\t\t\t  -0.80,  0.36, -0.48,\n\t\t\t  -0.60, -0.48,  0.64 );\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\nfloat fbm (vec3 p)\n{\n\tfloat f;\n\tf  = 0.5000*noise( p ); p = m*p*2.02;\n\tf += 0.2500*noise( p ); p = m*p*2.03;\n\tf += 0.1250*noise( p ); //p = m*p*2.01;\n\t//f += 0.0625*noise( p );\n\treturn f;\n}\n\nvec3 calcScatter(vec3 ori, vec3 dir, Hit hit, vec2 fc) {\n    vec3 sum = vec3(0.);\n    float maxDst = min(5., distance(ori,hit.p));\n    float weight = 1. / float(VOLUME_SAMPLES);\n    float stepAm = maxDst * weight;\n    vec3 p = ori;\n    \n    p += dir*(noise(vec3(2.*fc,iTime))*.075);\n    for(int i = 0; i < VOLUME_SAMPLES; i++) {\n        vec3 lv = getLightVector(p);\n        vec3 ld = normalize(lv);\n        Hit sh = intersect(p, ld);\n        if(sh.id < 0) {\n       \t\tsum += fbm(p+vec3(iTime,0.,iTime*.2));\n        }\n        p += dir * stepAm;\n    }\n    \n    return sum * weight * .5;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(sin(iTime),0.,-4.+cos(iTime));\n    vec3 dir = vec3(uv, 1.);\n    dir = normalize(dir);\n    \n    vec3 col = vec3(0.);\n    Hit  hit = intersect(ori, dir);\n    if(hit.id == 0) {\n    \tvec3 lv = getLightVector(hit.p);\n        vec3 ld = normalize(lv);\n        vec3  r = normalize(reflect(dir, hit.n));\n        vec2 uv = asin(hit.n.xy) / 3.14159 + .5;\n        \n        vec3 tx = texture(iChannel0, uv).xyz;\n        float d = max(dot(ld,hit.n),0.);\n        float s = pow(max(dot(ld,r),0.),20.+40.*tx.z);\n        col = tx*(.15+d)+s;\n    }\n    \n    col += calcScatter(ori,dir,hit,fragCoord);\n    \n    vec3 lv = getLightVector(ori);\n    vec3 ld = normalize(lv);\n    float s = 1.;\n    if(intersect(ori,ld).id > -1) {\n    \ts = 0.;\n    }\n    col += pow(max(dot(dir,ld), 0.), 90.)*s;\n    \n\tfragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tc3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 126, 126, 381], [382, 382, 417, 417, 468], [470, 470, 499, 499, 539], [630, 630, 652, 652, 688], [689, 689, 714, 714, 1047], [1048, 1048, 1068, 1068, 1237], [1239, 1239, 1295, 1295, 1824], [1830, 1830, 1887, 1887, 2776]], "test": "error"}
{"id": "4tc3Wj", "name": "Cell Limb Cassinoid Cassini Oval", "author": "ollj", "description": "\"Cassini(an) Ovals\" are metaball-like elongated 0'S, like ellipses, but 2 distances are multiplied instead of added.\nFaster than metaballs and good for cell/limb-shapes.", "tags": ["cell", "ellipse", "oval", "limb", "cassinoid", "cassini"], "likes": 3, "viewed": 553, "published": "Public API", "date": "1471468292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//chatting in https://www.shadertoy.com/live\n\n//\"Cassini(an) Ovals\" are metaball-like elongated 0'S\n//they are like ellipses, but 2 distances are multiplied instead of added.\nfloat dCassinoid(vec2 p, vec2 a, vec2 b){\n return length(p-a)*length(p-b);}\n\nfloat ssf(float a,float d){return smoothstep(-a,a,d);}\n\nfloat waveTri(float x,float d){\n ;d=fract(d*x);//sawtooth (not c0 continuous)\n ;d=abs(d-.5);//to C0 continuous triangle\n ;return d;   \n  //return min(mod(x,d),mod(-x,d))\n     \n     ;}\n\nfloat WavSaw(float x,float w){\n return abs((x)/w);}//waveSaw saw-function\n\nvoid mainImage(out vec4 r,in vec2 c){\n vec2 res=iResolution.xy;\n vec2 p=c/min(res.x,res.y);\n float dx=res.x/res.y;\n vec2 mr=iMouse.xy/res.xy;//relative mouse position on the screen\n mr.x*=res.x/res.y;\n r.rgb = vec3(p,sin(iTime));\n \n vec2 a=vec2(.2);\n vec2 b=mr;\n float d=dCassinoid(p,a,b);\n float lq=length(a-b);lq*=lq;\n float dist=lq*(.4+sin(iTime*2.)*.07);\n float eps=0.01;\n float e=1.;\n if(d<dist+eps)e=-.125;\n if(d<dist+eps && d>dist-eps)e*=4.;//optional line\n d=waveTri(d*30.,.6);\n d=1.-ssf(.25,d*e);\n r.rgb=vec3(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tc3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 175, 216, 216, 250], [252, 252, 279, 279, 306], [308, 308, 339, 339, 491], [493, 493, 523, 523, 544], [544, 568, 605, 605, 1091]], "test": "valid"}
{"id": "4tcGDj", "name": "Sphere Tracing 105", "author": "fab", "description": "To go along with the corresponding blog post which can be found here: http://fabricecastel.github.io/blog/2016-08-17/main.html", "tags": ["raymarching", "tutorial", "domainrepetition"], "likes": 8, "viewed": 3280, "published": "Public API", "date": "1471479228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.01;\nconst float EPSILON = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    vec3 q = vec3(mod(p.x, 3.0) - 1.5, p.yz);\n\tfloat s = 1.0;\n    vec3 d = abs(q) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 40; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0, 50.0*cos(iTime));\n            result = computeLambert(hit, computeSurfaceNormal(hit), light);\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(10.0*sin(iTime), 2.0, 10.0*cos(iTime));\n\tvec3 cameraDirection = normalize(vec3(-1.0*sin(iTime), -0.2, -1.0*cos(iTime)));\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n  \n    // generate the ray for this pixel\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    const float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 pixelColour = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 307, 346, 346, 515], [518, 610, 644, 644, 861], [864, 864, 908, 908, 951], [953, 953, 995, 995, 1457], [1459, 1459, 1516, 1516, 2368]], "test": "valid"}
{"id": "4td3Dj", "name": "recursive reflections epsilon 1", "author": "ollj", "description": "making epsilon variable, and using maxDist and maxSteps as training pool, allows for longer distances.\nThe extra performance on close surfaces is used to recursive reflections with shadows in reflections.\n\ngoto\nhttps://www.shadertoy.com/view/4lscW2", "tags": ["reflection", "shadow", "horizon", "dynamiceps"], "likes": 9, "viewed": 1215, "published": "Public API", "date": "1471698331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//do do:\n//replace this initially dumb and lazy quadratic dynamicEps \n//  with the much better [mod_dynamiceps]\n\n//maybe replace the FishEyeCam with an orthogonal cam. fisheyecam is more an intentional stress-test than good looks.\n//maybe do some seeded scattering on calculating a reflection.\n//maybe add any texturing to this bland method-demo.\n//could need more parameters to the shadow function to make it look better close up than afar\n\n\n//not sure why, but shadertoy makes the color depth in reflections within reflections look a lot lower than other boilerplates.\n//this is likely a precision issue, unlikely a conversion error.\n//precision highp float;\n//nope that didnt do it!\n\n//line 55 \"epsmod1\"... sets performance the most \n//the MAX_ limit range definitions only set upper bounds.\n//that are reached exponentially, so their size barely matters.\n//\n//MAX_SHADOW_REFLECTIONS sets how many reflections will have shadows calculated for them\n#define MAX_SHADOW_REFLECTIONS 2.0\n//with 2.0, a reflection in a reflection has shadows in it. usually enough.\n//\n///MAX_DIST can easily be 1000000. but may crash in higher resolutions\n#define MAX_DIST          100000.\n//MAX_STEPS can easily be 1000000. but may crash in higher resolutions\n#define MAX_STEPS         100000.\n//MAX_HARD can be 200 to 2000, depending on hardware, but may crash in higher resolutions\n#define MAX_HARD  500\n//this is the absolute upper limit of steps per ray, including all its reflections.\n//the hardlimit is only reached in extreme cases, \n//like when the camera POSITION is already close to a surface!\n//\n//by ollj\n//goal is to allow for high render distance and high detail close to the camera\n//goal is to allow for hall of mirror reflections for as long as there are steps left, scatterable non-fake reflections.\n//goal is to see the shadow in the reflection of a revflection of a reflection...\n//goal is to have any fragment converge in the same linear time\n//closer surfaces simply get more detail/reflections.\n//\n//RECURSIVE REFLECTION;\n//if a ray hits a reflective wall, \n//it keeps raymarching a bounched ray.\n//the loop sums up a total color as sum of all reflected rays.\n//a reflected ray makes up a smaller fraction of the total color.\n//if that fraction is too small, it does not reflect.\n//in the end the last reflected fraction of a color is added, that is \"sky\" or \"ground\" color if we run out of steps.\n//\n//LONG RENDER DISTANCE;\n//Achieved by defining MAX_DIST and MAX_STEPS as non-static float pools\n//that diminish with each raymarchng step,\n//many small steps drain them differently than doing many large steps!\n//if any pool drains below 0, the raymarching ends before MAX_HARD loops are cycled.\n//\n//additionaly, epsilon increases each raymarching step (see \"epsmod1\" definition)\n//\n//all this causes raymarching to converge more linearily\n//for many very different fragments of very different scenes\n//while it also \"warps space\" towards the ray, the more steps have been taken.\n//surfaces close to the camera have low epsilon, high precision, lots of reflections.\n//surfaces far from the camera have less precision, less reflections\n//surfaces/hallways coplanar to a ray no longer have the problem of \"running out oof steps\".\n\n#define epsmod1 eps=mad(nextDistance,.0001,eps*1.005);\n//#define epsmod1 eps=nextDistance*.0001+eps*1.005;\n//epsilon increases exponentially, set by step distances.\n//above functions ballances performance/quality the most\n//as it sets a converging cubic-function for many different cases.\n//It makes raymarching more convergent by increasing epsilon and\n//different scenes have different ideal settings for it.\n//like the differences of indoor to outdoor scenes.\n//in general smaller constants cause beter quality and lower fps.\n//\n#define epsmod2 maxSteps -=eps*nextDistance;\n//maxSteps dains slower on short step distances.\n//this makes maxDist the limit for many short steps.\n#define epsmod3 maxDist  -=eps/nextDistance;\n//maxdist drains slower on long step distances.\n//this makes maxSteps the limit for many large steps.\n//\n//maxDist drains accumulative-inversed in comparison to maxSteps's accumulative drain.\n//but sooner or later these 2 converge towards each other!\n//i am sure this can be improved a lot. but benchmarking this on different scenes takes time.\n//and i lack the theoretical undertanding to model many cases to an optimum.\n\n#define PI acos(-1.)  \n#define PIB asin(1.)\n\n#define skyColor       vec3(.1,.5,1.)\n#define shadowColor    vec3(.1,.1,.5)\n#define groundColor    vec3(.6,1.,.7)\n#define buildingsColor vec3(.8,.7,.2)\n#define redColor       vec3(1.,.1,.8)\n//these colors visually make sense for contrast, even for red-green blindness.:\n//shadows are blue\n//ground is greener\n//floating objects are red\n//near ground objects are yellow\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\n\n//these defines are not too practiical:\n#define fovyCoefficient 1.\n#define shadowHardness 3.\n#define time iTime\n\n//i lost my latest cleaned up iprved version of this, \n//leaving us with this older messier version.\n\n//the ugliest thing here is that,\n//if a reflected ray runs out of steps/distance, it aborts\n//meaning it is the last reflection\n//but without dithering this looks a bit ugly\n//\n//in other versions i added fake dithering by modifying RayDirection by +=0.001\n//for each step.\n//this warps space a bit (speudo randomly), which is still fine, we call this \"gravity\" , ya know?\n\n//the main trick here is that some cases are better for (nearby) reflections \n//while others are better for ling distance surfaces.\n//and all combinations can be made almost linearily convergent.\n//the problem here is that it only starts to look good \n//with at least 500 itterations of raymarchoing\n//too much for the average 2014 hardware in useful resolutions/framerates\n\nfloat CubeDistance2 (in vec3 point, in vec3 size){return length(max(abs(point)-size,0.));}\nfloat sdHexPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*.866025+q.y*.5,q.y)-h.x);}\nvec3 DistanceRepetition(in vec3 point, in vec3 repetition ){\n    vec3 q = mod(point, repetition)-.5*repetition;return q;}\nfloat CubeRepetition(in vec3 point, in vec3 repetition ){\n  point.x+=sin(point.y*.11+time*5.);\n  point.z+=cos(point.y*.11);\n  vec3 q = mod(point,repetition)\n  -0.5*repetition;q.y = point.y;\n  return sdHexPrism(q.zxy,vec2(10.,50));\n  return CubeDistance2 ( q, vec3 (10., 50.+sin(time)*15.,10.));}\nfloat PlaneDistance(in vec3 point,in vec3 normal,in float pDistance){return dot(point-(normal * pDistance), normal);}\nfloat modA(float x){return mod(time*.1+x+55.,230.)-55.;}\nfloat fSphere       (vec3 p,float r){return length(p)-r;}\nfloat SphereDistance(vec3 point, vec3 center, float radius){\n  point.z = modA(point.z);point.x = modA(point.x);\n  return fSphere(point-center,radius);}\nfloat RedDistance(in vec3 position){return SphereDistance(position,vec3(0.,66.,0.),30.);}\nfloat BuildingsDistance(in vec3 position){\n  return min(CubeRepetition(position                                ,vec3(80.,0., 90.)),\n\t         CubeRepetition(position+vec3(350.,sin(time)*30.,0.) ,vec3(90.,0.,100.)));}\nfloat GroundDistance(in vec3 position){return PlaneDistance(position,vec3(0.,1.,0.),0.);}\n//merging distance functions above to distanceField function below:\nfloat df(in vec3 position, out int mtl){\n    float radial=length(vec2(position.x,position.z));\n\tfloat radialSine=sin(radial*.05-time*2.)*5.;\n    float gndDistance=position.y-radialSine+6.;\n    float bldDistance=BuildingsDistance(position);\n    float redDistance=RedDistance      (position);\n                       float closest=gndDistance;mtl=   GROUND_MTL;\n    if (bldDistance<closest){closest=bldDistance;mtl=BUILDINGS_MTL;}\n    if (redDistance<closest){closest=redDistance;mtl=      RED_MTL;}\n    return closest;}\n//end of sdf geometry;\n\n//iqs famous softshadow, set to low quality\nfloat SoftShadow( in vec3 landPoint, in vec3 lightVector, float mint, float maxt, float iterations ){\n    float penumbraFactor=1.0;vec3 sphereNormal;float t=mint;\n    for(int s=0;s<20;++s){if(t > maxt) break;\n        float nextDist = min(\n            BuildingsDistance(landPoint + lightVector * t )\n            , RedDistance(landPoint + lightVector * t ));\n        if( nextDist < 0.001 ){return 0.0;}\n        penumbraFactor = min( penumbraFactor, iterations * nextDist / t );\n        t += nextDist;}return penumbraFactor;}\n\n//distance fog is no longer needed, is a relict here.\nvoid applyFog( in float distance, inout vec3 rgb ){\n    //float fogAmount = (1.0 - clamp(distance*0.0015,0.0,1.0) );\n    //float fogAmount = exp( -distance* 0.006 );\n    //vec3 fogColor = vec3(0.9,0.95,1);\n    //if(fogAmount<.6)rgb= vec3(1.,1.,0.);\n    //else rgb=clamp(rgb,0.,1.);\n    //rgb=mix(skyColor,rgb,fogAmount);\n}\n//for mad()-awareness.\nfloat mad (float b,float c,float d){return b*c+d;}\n\nvec3 MaterialColor(int mtl){\n    if(mtl==      SKY_MTL) return skyColor;\n    if(mtl==BUILDINGS_MTL) return buildingsColor;\n    if(mtl==   GROUND_MTL) return groundColor;\n    if(mtl==      RED_MTL) return redColor;\n    return vec3(1.0,1.0,1.0);}\nfloat AmbientOcclusion (vec3 p,vec3 n,float d,float s){float r=1.;int t;\n  for(int i=0;i<5;++i){if(--s<0.)break;r-=(s*d-(df(p+n*s*d,t)))/pow(2.,s);}return r;}\n \n//my reflection code only allows for coarse normal calculations with this function e=0.1 !\n//that means, smaller e will look bad, or not reflect at all. \n//i was tweaking this only to notice that e=0.1 is pretty much the best working value for the scenes scaling.\nvec3 ComputeNormal(vec3 pos, int material,float eps){int d;float e=.1;\n  return vec3(df(vec3(pos.x+e,pos.y  ,pos.z  ),d)-df(vec3(pos.x-e,pos.y  ,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y+e,pos.z  ),d)-df(vec3(pos.x  ,pos.y-e,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y  ,pos.z+e),d)-df(vec3(pos.x  ,pos.y  ,pos.z-e),d));}\n\n//main raymarching loop with maxDistance and MaxSteps and epsilon changed a bit.\n//if (hits a surface) reflect!\n//returns color of fragment.\nvec3 RayMarch(in vec3 position, in vec3 direction, out int mtl){\n  vec3 hitColor;\n  vec3 r;\n  float sg=1.;\n  float nextDistance= 1.;\n  float shadowReflections=MAX_SHADOW_REFLECTIONS;\n  float maxDist =MAX_DIST;\n  float maxSteps=MAX_STEPS;\n  int hardLimit =MAX_HARD;\n  float eps     =.01;\n  for(int ever=3;ever!=0;++ever){//the ride (n)ever ends! unless [hardlimit<0] triggers a return. this lets me drain hardlimit in the loop-\n    nextDistance=df(position,mtl);\n\tposition+=direction*nextDistance;\n    if(nextDistance<eps){//if we hit a surface.\n      vec3 n=ComputeNormal(position,mtl,eps);n=normalize(n);\n      vec3 col=MaterialColor(mtl);\n\t  position+=n;\n      if(shadowReflections>0.0){//if we stil calculate shadows (for this reflection)\n\t\tvec3 lightpos = vec3(250.0*sin(time*.005), 400.0 + 40.0 *cos(time*.002), 250.0*cos(time*.005));\n        lightpos=lightpos-position;vec3 lightVector=normalize(lightpos);float lightdist=length(lightpos);\n\t\tfloat shadow = SoftShadow(position, lightVector, 0.3, lightdist,shadowHardness);\n        if(mtl==BUILDINGS_MTL){col=mix(shadowColor,col,clamp(position.y/7.0,0.0,1.0));}\n\t\tfloat attenuation=clamp(dot(n,lightVector),0.0,1.0);\n\t\tshadow=min(shadow,attenuation);col=mix(shadowColor,col,shadow);\n        float AO=AmbientOcclusion(position,n, 1.0, 7.0);col=mix(shadowColor,col,AO);shadowReflections-=1.0;}\n      float refl=.45;//surface reflectiveness\n      if (mtl==GROUND_MTL)refl=.3;//ground has other reflectiveness\n      r=mix(col,r,1.-sg);//mix the color of the current ray (reflection) with the accumulated total color to be returned.\n      sg=sg*refl;if(sg<.01)return r;\n      direction=direction-(n*1.5*(dot(direction,n)));//direction gets reflected at surface normal. \n        //*1.5 factor means we WILL likely overstp within reflections, accumulatively for each reflection.\n        //this is a reasonable fps booster for less quality in reflections.\n    }hardLimit--;\n    epsmod1 \n    epsmod2 \n    epsmod3 \t\n    if(maxSteps<0.||maxDist<0.||hardLimit<0){\n\t  if (direction.y<0.)return mix(groundColor,r,1.-sg);\n                         return mix(skyColor   ,r,1.-sg);}}return vec3(3,3,3);}\n\nvoid FishEyeCamera( vec2 screenPos, float ratio, float fovy, out vec3 position, out vec3 direction ){\n    screenPos *= vec2(ratio,fovy);\n\tfloat height=cos(time/5.);\n    \n\tdirection=normalize(cross(vec3(screenPos,3.0),vec3(0,1,0)));\n    direction=vec3( sin(screenPos.y+PIB)*sin(screenPos.x)\n                  ,-cos(screenPos.y+PIB)-height*.5-.4+sin(time/20.)*0.2-0.1\n                  ,-sin(screenPos.y+PIB)*cos(screenPos.x));\n\tposition=vec3(sin(time/ 6.)*100.+20.+iMouse.x\n\t              ,height       *205.+206.+iMouse.y\n\t              ,sin(time/14.)*135.+cos(time/13.)*135.)+1.0;\n\tdirection=normalize(direction);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){float ratio=iResolution.x/iResolution.y;\n vec2 uv = fragCoord.xy/iResolution.xy*vec2(.5);\n vec3 d=vec3(1.,0.,0.);vec4 CamRotation;vec3 p;\n FishEyeCamera(uv,ratio,fovyCoefficient,p,d);\n int m;\n vec3 col=RayMarch(p,d,m);\n //vec3 col=vec3(0);\n fragColor=vec4(col,1.0);\n //if(m==SKY_MTL&&d.y<0.){m = GROUND_MTL;fragColor=vec4(1.,0.,0.,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4td3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5467, 5842, 5892, 5892, 5932], [5933, 5933, 5965, 5965, 6032], [6033, 6033, 6093, 6093, 6154], [6155, 6155, 6212, 6212, 6450], [6451, 6451, 6520, 6520, 6568], [6569, 6569, 6589, 6589, 6625], [6626, 6626, 6663, 6663, 6683], [6684, 6684, 6744, 6744, 6835], [6836, 6836, 6872, 6872, 6925], [6926, 6926, 6968, 6968, 7142], [7143, 7143, 7182, 7182, 7232], [7233, 7301, 7341, 7341, 7818], [7843, 7887, 7988, 7988, 8409], [8411, 8465, 8516, 8785, 8787], [8788, 8811, 8847, 8847, 8861], [8863, 8863, 8891, 8891, 9107], [9108, 9108, 9163, 9163, 9266], [9269, 9533, 9586, 9586, 9864], [9866, 10007, 10071, 10071, 12150], [12152, 12152, 12253, 12253, 12768], [12769, 12769, 12823, 12823, 13160]], "test": "valid"}
{"id": "4td3RB", "name": "Simplest Lit Raymarcher", "author": "Incin", "description": "Lol, I'm bored. (Also the lighting is 100% faked)", "tags": ["raymarcher", "lit"], "likes": 0, "viewed": 117, "published": "Public", "date": "1470007425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int STEPS = 256;\n//const vec3 LIGHT_POS = vec3(2,4,7);\n\nbool sphere(vec3 p) {\n    return length(vec3(0,0,6) - p) < 2.;\n}\n\nbool lit(vec3 p) {\n    return length(vec3(sin(iTime)*2.,4,7) - p) < 0.5;\n}\n\nvec3 spherec() {\n    return vec3(0.2,0.5,0.6);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 cp = vec3(uv.x + (-iMouse.x/iResolution.x), (uv.y/aspect) + ((-iMouse.y/iResolution.y) * 0.8) + 0.1, 1);\n    vec3 LIGHT_POS = vec3(sin(iTime)*2.,4,7);\n    vec3 dir = vec3(cp.xyz)*0.05;\n    \n    vec3 I = vec3(0.);\n    int c = 0;\n    for (int i=0; i < STEPS; ++i) {\n        c++;\n\t\tcp += dir;\n        if (sphere(cp)) {\n            I += ((5. / distance(cp, LIGHT_POS)) * spherec());\n            break;\n        }\n        if (lit(cp)) {\n         \tI = vec3(1.);\n            break;\n        }\n    }\n    \n\tfragColor = vec4(I.xyz, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4td3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 62, 83, 83, 126], [128, 128, 146, 146, 202], [204, 204, 220, 220, 252], [254, 254, 311, 311, 942]], "test": "valid"}
{"id": "4td3Rl", "name": "Sticks and donuts", "author": "_pwd_", "description": "Quick finger exercise", "tags": ["raymarching", "distancefield"], "likes": 8, "viewed": 239, "published": "Public", "date": "1470900980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat fld(vec3 h)  {\n\treturn length(vec2(length( sin(h.xz) * cos(h.xz) ) -.15,\n                       length( sin(h.zx) * sin(h.yx) ) - .02)) - .14;\n}\n\nfloat df(vec3 p)  {\n    float t=iTime * .05;\n    float s=sin(t), c = cos(t);\n\n    p -= vec3(s*s, c, -4);\n    p.xy *= rot(t*1.2) ;\n    p.xz *= rot(t*2.63);\n\n    return fld(p);\n}\n\nvoid mainImage( out vec4 O,  vec2 U ) {\n    vec3 rd   = normalize( vec3(U/iResolution.xy, 1 ) ),\n         ro   = vec3(10,2,0);   \n    float off = 0., c, d;\n   \n    for( float i = 0.; i < 1. ; i +=.02 )\n         off += d = df(ro+rd*off),\n         c = abs(d)<1e-4 ? c : i*.9;\n\n    O = c*vec4(c,1,c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4td3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 71, 71, 201], [203, 203, 222, 222, 379], [381, 381, 420, 420, 682]], "test": "valid"}
{"id": "4td3WS", "name": "Checkered Wall", "author": "jackdavenport", "description": "A checkerboarded wall, with a small deformed sphere in the middle.", "tags": ["displacement", "lighting", "wall", "ball", "checker", "trig"], "likes": 8, "viewed": 657, "published": "Public API", "date": "1471312754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 256\n#define MAX_DISTANCE 256.\n\n#define EPSILON .001\n#define SHADOW_BIAS .01\n#define PI 3.1415926535897932384626433832795028841971\n\n#define LIGHT_COL vec3(1.,1.,1.)\n#define LIGHT_AMB .15\n#define LIGHT_DIR normalize(vec3(45.,30.,-45.))\n\n#define POINT_COL vec3(1.,1.,0.)\n\n// Distance functions and smooth minimum by the incredible iq\n// Source: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// Source: http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rot2D(vec2 p, float angle) {\n    angle = radians(angle);\n    float s = sin(angle), c = cos(angle);\n    return mat2(c,s,-s,c) * p;\n}\n\nfloat dstScene(vec3 p) {\n    \n    float disp = sin(p.x*10.+iTime*3.)*.1;\n    disp += cos(p.y*5.-iTime*5.)*.1;    \n    \n    float dst = length(p) - 1. + disp;\n    dst = smin(dst, sdPlane(p, vec4(0.,0.,-1.,1.)), 1.);\n    \n    return dst;\n    \n}\n\nfloat raymarch(vec3 ori, vec3 dir) {\n \n    float t = 0.;\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n    \tvec3  p = ori + dir * t;\n        float d = dstScene(p);\n        if(d < EPSILON || t > MAX_DISTANCE) {\n            break;\n        }\n        t += d * .75;\n    }\n    return t;\n    \n}\n\nvec3 calcNormal(vec3 p) {\n\tvec2 e = vec2(EPSILON,0.);\n    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),\n                  dstScene(p+e.yxy)-dstScene(p-e.yxy),\n                  dstScene(p+e.yyx)-dstScene(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 getPointLightVector(vec3 p) {\n\t\n    float a = iTime * 2.5;\n    vec3 lp = vec3(cos(a),sin(a),.015)*4.5;\n    \n    return lp - p;\n   \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float hardness )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = dstScene( ro + rd*t );\n        res = min( res, hardness*h/t );\n        t += clamp( h, 0.06, 0.30 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n// Shadows by the incredible iq\n// Source: https://www.shadertoy.com/view/Xds3zN\nvec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sp) {\n \n    vec3 d = vec3(0.);\n    vec3 s = vec3(0.);\n    \n    for(int i = 0; i < 2; i++) {\n\n        vec3 lv = i == 0 ? LIGHT_DIR : getPointLightVector(p);\n        vec3 ld = normalize(lv);\n        \n        float diff = max(dot(ld,n),0.);\n    \tfloat spec = 0.;\n    \n    \tdiff *= softshadow(p, ld, SHADOW_BIAS, MAX_DISTANCE, 128.);\n    \tif(i == 1)\n            diff *= 1.-smoothstep(2.,10.,length(lv));\n            \n    \tif(diff > 0. && sp > 0.)\n        \tspec = pow(max(dot(ld,r),0.), sp);\n    \n        vec3 lc = i == 0 ? LIGHT_COL : POINT_COL;\n    \td += (col*lc*(LIGHT_AMB+diff));\n        s += (lc*spec);\n        \n    }\n    \n    return (col*d)+s;\n    \n}\n\nvec3 shadeObjects(vec3 p, vec3 n, vec3 r) {\n    \n    vec3 col = vec3(0.);\n    vec2  uv = mod(asin(n.xy) / PI + .5, 1.);\n        \n    if(p.z > .9)\n    \tuv = mod(p.xy / 3.5, 1.);\n        \n    col = vec3(1.,0.,0.);\n    float sp = 3.;\n    vec2 ch = mod(uv * 5., 1.);\n    if((ch.x > .5 || ch.y > .5) && !(ch.x > .5 && ch.y > .5)) {\n    \tcol *= .5;\n    \tsp = 60.;\n    }\n     \n    col = calcLighting(col, p, n, r, sp);\n    \n    return col;\n    \n}\n\nvec3 shade(vec3 ori, vec3 dir) {\n \n    float  t = raymarch(ori, dir);\n    vec3 col = vec3(0.);\n    \n    if(t < MAX_DISTANCE) {\n\n        vec3  p = ori + dir * t;\n        vec3  n = calcNormal(p);\n        vec3  r = normalize(reflect(dir, n));\n        col = shadeObjects(p,n,r);\n        \n        vec3  rc = vec3(0.);\n        float rt = raymarch(p+r*SHADOW_BIAS,r);\n        if(rt < MAX_DISTANCE) {\n            vec3 rp = p + r * rt;\n            vec3 rn = calcNormal(rp);\n            vec3 rr = normalize(reflect(r,rn));\n            rc = shadeObjects(rp,rn,rr);\n        }\n        \n        float f = 1. - pow(max(-dot(dir, n), 0.), .25);\n        col = mix(col, rc, f);\n        \n    }\n    \n    vec3 lv = getPointLightVector(ori);\n    vec3 ld = normalize(lv);\n    float f = pow(max(dot(dir,ld), 0.), 30.);\n    f   *= softshadow(ori, ld, 0., length(lv), 64.);\n    col += POINT_COL * f;\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,-4.);\n    vec3 dir = vec3(uv, 1.);\n    \n    vec2 m = ((iMouse.xy - iResolution.xy * .5) / iResolution.y) * -vec2(2.,-2.);\n    if(iMouse.xy == vec2(0.)) m = vec2(0.);\n    ori.xy += m;\n    \n    vec3 f = normalize(-ori);\n    vec3 u = normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 v = normalize(cross(u,f));\n    dir = mat3(u,v,f) * dir;\n    \n\tfragColor = vec4(shade(ori,normalize(dir)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4td3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 500, 533, 533, 564], [565, 565, 606, 606, 699], [701, 701, 734, 734, 837], [839, 839, 863, 863, 1081], [1083, 1083, 1119, 1119, 1370], [1372, 1372, 1397, 1397, 1618], [1620, 1620, 1654, 1654, 1757], [1759, 1759, 1852, 1852, 2121], [2123, 2204, 2267, 2267, 2913], [2915, 2915, 2958, 2958, 3354], [3356, 3356, 3388, 3388, 4257], [4259, 4259, 4316, 4316, 4797]], "test": "valid"}
{"id": "4td3zj", "name": "Raymarched Hexagonal Truchet", "author": "Shane", "description": "Raymarched hexagonal Truchet tile, based off of Fabrice and Mattz's examples.", "tags": ["raymarch", "map", "hexagon", "truchet", "edge", "environment"], "likes": 84, "viewed": 1961, "published": "Public API", "date": "1471014579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tRaymarched Hexagonal Truchet\n\t----------------------------\n\n\tRaymarching a hexagonal Truchet pattern. The Truchet pattern itself is pretty easy to produce.\n\tThis particular production method is based off of one of Fabrice Neyret's finely tuned examples, \n\twhich in turn was based on something Mattz did a while back. Both examples are below.\n\n\tTechnically, there isn't a lot to it. The hardest part was producing the Truchet pattern in a \n\treasonably quick way, but most of that was already done for me. Therefore, since I had nothing new \n\tto add, I prettied it up a bit... and by that I mean, I made it really shiny. Probably too shiny. \n\tIt kind of hurts my eyes. :)\n\n\tThe weird, abstract, dragon disco style wasn't intentional. I'm briefly passing through parts of \n\tAsia next week, so that may have mildy influenced my style choices. Hopefully, it meets \n\t834144373's approval. :)\n\t\n\n\tBased on:\n\n\thexagonal truchet ( 352 ) - FabriceNeyret2\n\thttps://www.shadertoy.com/view/Xdt3D8\n\n\t... which, in turn, was based on:\n\thexagonal tiling - mattz\n\thttps://www.shadertoy.com/view/4d2GzV\n\n*/\n\n\n// Using a 2D Hexagonal Truchet pattern as the source of the height map. This is based on Fabrice's \n// example which in turn was based on one by Mattz. I tailored it to suit my needs - and hopefully, \n// sped it up a bit, but it wouldn't shock me if I'd slowed it down instead. :)\n//\n// The process is pretty simple: Break space up into hexagons and color them according to the distance \n// from the center, then randomly flip some about the X-axis. The pattern you're left with isn't that \n// visually appealing. However, once you wrap or fold the values over, you get some nice symmetrical \n// patterns.\n// \n// Just to complicate things slightly, I'm performing the final value folding steps outside of this\n// function in order to color things in sections... It's not that important.\nfloat heightMap(in vec2 p) { \n    \n    p *= 3.;\n    \n\t// Hexagonal coordinates.\n    vec2 h = vec2(p.x + p.y*.57735, p.y*1.1547);\n    \n    // Closest hexagon center.\n    vec2 f = fract(h); h -= f;\n    float c = fract((h.x + h.y)/3.);\n    h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f); \n\n    p -= vec2(h.x - h.y*.5, h.y*.8660254);\n    \n    // Rotate (flip, in this case) random hexagons. Otherwise, you'd have a bunch of circles only.\n    // Note that \"h\" is unique to each hexagon, so we can use it as the random ID.\n    c = fract(cos(dot(h, vec2(41, 289)))*43758.5453); // Reusing \"c.\"\n    p -= p*step(c, .5)*2.; // Equivalent to: if (c<.5) p *= -1.;\n    \n    // Minimum squared distance to neighbors. Taking the square root after comparing, for speed.\n    // Three partitions need to be checked due to the flipping process.\n    p -= vec2(-1, 0);\n    c = dot(p, p); // Reusing \"c\" again.\n    p -= vec2(1.5, .8660254);\n    c = min(c, dot(p, p));\n    p -= vec2(0, -1.73205);\n    c = min(c, dot(p, p));\n    \n    return sqrt(c);\n    \n    // Wrapping the values - or folding the values over (abs(c-.5)*2., cos(c*6.283*1.), etc) - to produce \n    // the nicely lined-up, wavy patterns. I\"m perfoming this step in the \"map\" function. It has to do \n    // with coloring and so forth.\n    //c = sqrt(c);\n    //c = cos(c*6.283*1.) + cos(c*6.283*2.);\n    //return (clamp(c*.6+.5, 0., 1.));\n\n}\n\n// Raymarching an XY-plane - raised a little by the hexagonal Truchet heightmap. Pretty standard.\nfloat map(vec3 p){\n    \n    \n    float c = heightMap(p.xy); // Height map.\n    // Wrapping, or folding the height map values over, to produce the nicely lined-up, wavy patterns.\n    c = cos(c*6.283*1.) + cos(c*6.283*2.);\n    c = (clamp(c*.6+.5, 0., 1.));\n\n    \n    // Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).\n    // Adding some height to the plane from the heightmap. Not much else to it.\n    return 1. - p.z - c*.025;\n\n    \n}\n\n// The normal function with some edge detection and curvature rolled into it. Sometimes, it's possible to \n// get away with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    vec2 e = vec2(.01, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .6, 0., 1.);\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.0025, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n/*\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float c = heightMap((p.xy + p.z*.025)*6.);\n    c = cos(c*6.283*3.);\n    //c = sqrt(clamp(c+.5, 0., 1.));\n    c = (c*.5 + .5);\n    \n    return c;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n*/\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 envMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as other combinations. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n)*.75 + .25; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    //return sin( p*6.2831853 + iTime )*.35 + .65; \n    \n}\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o); \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n    return max(d.y/1.2 - d.x*1., 0.)/1.2;\n    //return d.y - d.x; // return 1.-d.x; // etc.\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit directional ray - Coyote's observation.\n    vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n\n    \n    // Rotate the XY-plane back and forth. Note that sine and cosine are kind of rolled into one.\n    vec2 a = sin(vec2(1.570796, 0) + sin(iTime/4.)*.3); // Fabrice's observation.\n    rd.xy = mat2(a, -a.y, a.x)*rd.xy;\n    \n    \n    // Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(iTime, cos(iTime/4.), 0.);\n    \n    \n    // Light position, hovering around behind the camera.\n    vec3 lp = ro + vec3(cos(iTime/2.)*.5, sin(iTime/2.)*.5, -.5);\n    \n    // Standard raymarching segment. Because of the straight forward setup, not many iterations are necessary.\n    float d, t=0.;\n    for(int j=0;j<32;j++){\n      \n        d = map(ro + rd*t); // distance to the function.\n        t += d*.7; // Total distance from the camera to the surface.\n        \n        // The plane \"is\" the far plane, so no far=plane break is needed.\n        if(d<0.001) break; \n    \n    }\n    \n    // Edge and curve value. Passed into, and set, during the normal calculation.\n    float edge, crv;\n   \n    // Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp, edge, crv);\n    vec3 ld = lp - sp;\n    \n    \n    \n    // Coloring and texturing the surface.\n    //\n    // Height map.\n    float c = heightMap(sp.xy); \n    \n    // Folding, or wrapping, the values above to produce the snake-like pattern that lines up with the randomly\n    // flipped hex cells produced by the height map.\n    vec3 fold = cos(vec3(1, 2, 4)*c*6.283);\n    \n    // Using the height map value, then wrapping it, to produce a finer grain Truchet pattern for the overlay.\n    float c2 = heightMap((sp.xy + sp.z*.025)*6.);\n    c2 = cos(c2*6.283*3.);\n    c2 = (clamp(c2+.5, 0., 1.)); \n\n    \n    // Function based bump mapping. I prefer none in this example, but it's there if you want it.   \n    //if(temp.x>0. || temp.y>0.) sn = dbF(sp, sn, .001);\n    \n    // Surface color value.\n    vec3 oC = vec3(1);\n\n\tif(fold.x>0.) oC = vec3(1, .05, .1)*c2; // Reddish pink with finer grained Truchet overlay.\n    \n    if(fold.x<0.05 && (fold.y)<0.) oC = vec3(1, .7, .45)*(c2*.25 + .75); // Lighter lined borders.\n    else if(fold.x<0.) oC = vec3(1, .8, .4)*c2; // Gold, with overlay.\n        \n    //oC *= n3D(sp*128.)*.35 + .65; // Extra fine grained noisy texturing.\n\n     \n    // Sending some greenish particle pulses through the snake-like patterns. With all the shininess going \n    // on, this effect is a little on the subtle side.\n    float p1 = 1.0 - smoothstep(0., .1, fold.x*.5+.5); // Restrict to the snake-like path.\n    // Other path.\n\t//float p2 = 1.0 - smoothstep(0., .1, cos(heightMap(sp.xy + 1. + iTime/4.)*6.283)*.5+.5);\n\tfloat p2 = 1.0 - smoothstep(0., .1, Voronoi(sp.xy*4. + vec2(iTime, cos(iTime/4.))));\n    p1 = (p2 + .25)*p1; // Overlap the paths.\n    oC += oC.yxz*p1*p1; // Gives a kind of electron effect. Works better with just Voronoi, but it'll do.\n    \n   \n    \n    \n    float lDist = max(length(ld), 0.001); // Light distance.\n    float atten = 1./(1. + lDist*.125); // Light attenuation.\n    \n    ld /= lDist; // Normalizing the light direction vector.\n    \n    float diff = max(dot(ld, sn), 0.); // Diffuse.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); // Specular.\n    float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 3.); // Fresnel, for some mild glow.\n    \n    // Shading. Note, there are no actual shadows. The camera is front on, so the following\n    // two functions are enough to give a shadowy appearance.\n    crv = crv*.9 + .1; // Curvature value, to darken the crevices.\n    float ao = calculateAO(sp, sn); // Ambient occlusion, for self shadowing.\n\n \n    \n    // Combining the terms above to light the texel.\n    vec3 col = oC*(diff + .5) + vec3(1., .7, .4)*spec*2. + vec3(.4, .7, 1)*fre;\n    \n    col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.; // Fake environment mapping.\n \n    \n    // Edges.\n    col *= 1. - edge*.85; // Darker edges.   \n    \n    // Applying the shades.\n    col *= (atten*crv*ao);\n\n\n    // Rough gamma correction, then present to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4td3zj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1096, 1884, 1912, 1912, 3281], [3283, 3381, 3399, 3399, 3842], [3844, 4053, 4112, 4112, 5884], [5888, 6040, 6081, 6081, 6322], [7068, 7136, 7154, 7154, 7500], [7502, 7757, 7787, 7787, 8401], [8403, 8425, 8446, 8533, 8749], [8751, 8953, 8978, 8978, 9674], [9676, 9676, 9732, 9794, 13968]], "test": "valid"}
{"id": "4tdGRf", "name": "Under the stars", "author": "ivansafrin", "description": "#shaderaday #3\n\nUsing noise from:\nhttps://www.shadertoy.com/view/4sfGzS", "tags": ["fire", "stars", "shaderaday"], "likes": 5, "viewed": 802, "published": "Public API", "date": "1470610935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tfloat fireVal = (distance(uv.x, 0.5 + (sin((uv.y - iTime*0.5)*10.0)*0.05)*uv.y) > sin(uv.y) * 0.3) ? 0.0 : sin(0.6-uv.y);\n    fireVal = max(fireVal, 0.0);\n    float landVal = (uv.y < (0.12+sin(uv.x*4.0)*0.08)+(noise(vec3(uv.x*1000.0, 0.0, 0.0))*0.05)*noise(vec3(uv.x * 10.0, 0.0, 0.0))) ? 0.0 : 1.0;\n    vec2 uvN = uv * 100.0;\n    float starRot = iTime * 0.02;\n\tvec2 rotVec = vec2(uvN.x*cos(starRot) - uvN.y * sin(starRot), uvN.x*sin(starRot) + uvN.y * cos(starRot));\n    float starVal = ((noise(vec3(rotVec.x, rotVec.y, 0.0)) < 0.03) ? 1.0 : 0.0) * landVal * sin(uv.y);\n    fragColor = \n        vec4(sin(1.0-uv.y)*0.3*landVal, 0.1*landVal, 0.2*landVal, 1.0) +\n        vec4(starVal, starVal, starVal, 1.0) + \n        vec4((1.0-sin(uv.y))*fireVal*((1.0-uv.y)*3.0), sin(uv.y)* fireVal * ((1.0-uv.y)*3.0), fireVal * 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 59], [60, 60, 86, 86, 453], [455, 455, 512, 512, 1380]], "test": "valid"}
{"id": "4tdGRl", "name": "4: Grid Effect", "author": "andgokevin", "description": "Expanding and strobing grid.", "tags": ["learning"], "likes": 1, "viewed": 92, "published": "Public", "date": "1470894567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Multiply scalar within trig. functions to compress or expand the wave.\n */\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  vec4 bgColor = vec4(0.4, 0.2, 0.2, 1.0);  // Background color.\n  vec4 color = bgColor;  // Default to background color.\n\n  vec2 uv = fragCoord.xy / iResolution.xy;  // Clamp coordinate system to [0, 1].\n    \n  float gridTick = 0.1;  // How much space between grid lines.\n  float gridWidth = 0.1;  // Thickness of grid lines.\n  vec4 gridColor = vec4(0.8, 0.8, 1.0, 1.0);  // Color of grid lines.\n    \n  // Do trippy stuff using the time.\n  // 1. Make the distance between grid ticks vary.\n  // gridTick = gridTick * min(((sin(iTime) + 1.0) / 2.0), 0.002);\n  // 2. Make the width of the grid ticks vary.\n  gridWidth = gridWidth * ((sin(iTime) + 1.0) / 2.0);\n   \n  // Use modulo which divides coordinate by tick. Then compares to the width.  \n  if (mod(uv.x, gridTick) < gridWidth || mod(uv.y, gridTick) < gridWidth) {\n    color = gridColor * abs(sin(0.25 * iTime));\n  }\n\n\n  fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 138, 138, 1033]], "test": "valid"}
{"id": "4tdGWB", "name": "2D: {s,q,n}lerp", "author": "MBR", "description": "normal interp with slerp, qlerp and nlerp", "tags": ["normal", "interpolation"], "likes": 7, "viewed": 1230, "published": "Public", "date": "1471476800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// viz for: http://marc-b-reynolds.github.io/quaternions/2017/04/19/slerp0.html\n\n\n// 2D version\n//  blue = slerp\n//  red  = qlerp\n//  mag  = lerp\n\n// ba^* \nvec2 z_mulc(vec2 a, vec2 b)\n{\n  return vec2(dot(a,b), a.x*b.y-a.y*b.x);\n}\n\n// z^2\nvec2 z_pow2(vec2 z)\n{\n  float x = 2.0*z.x;\n  return vec2(z.x*x-1.0, x*z.y);\n}\n\n// sqrt(z) when |z|=1\nvec2 z_usqrt(vec2 z)\n{\n  float t = 1.0+z.x;\n  float s = inversesqrt(t+t);\n  \n  return vec2(s*t, s*z.y);\n}\n\nvec2 nlerp(vec2 A, vec2 B, float t)\n{\n  return normalize(mix(A, B, t));\n}\n\nvec2 slerp(vec2 A, vec2 B, float t)\n{\n  vec2  z = z_mulc(A,B);\n  float a = acos(z.x);\n  float c = cos(a*t);\n  float s = sqrt(1.0-c*c);\n  s = (z.y >= 0.) ? s : -s;\n    \n  return c*A + s*vec2(-A.y, A.x); \n}\n\nvec2 qlerp(vec2 A, vec2 B, float t)\n{\n  vec2 z = z_mulc(A,B);\n  vec2 h = z_usqrt(z);\n  vec2 m = normalize(vec2(1.0-t+t*h.x, t*h.y));\n  vec2 r = z_pow2(m);  \n    \n  return r.x*A + r.y*vec2(-A.y, A.x);\n}\n\n\n// Viz junk below here\n\n#define W0 0.5545497\n#define W1 0.308517\n#define W3 0.618034\n\n// [-1,1]\nfloat tnoise(in vec2 c)\n{   \n  c = c*fract(c*vec2(W0,W1));\n  float p  = c.x*c.y;\n  float i  = floor(p);\n  float u0 = p-i;\n  float u1 = fract(W3*i);\n  return u0-u1;\n}\n\nfloat circle(vec2 uv, vec3 c)\n{\n  float r = length(c.xy - uv);\n  float d = abs(r - c.z);  \n  return smoothstep(0.015, 0.0, d) + 0.5*smoothstep(0.06, 0.01, r-c.z);\n}\n\nfloat saturate(float x)\n{\n  return clamp(x, 0.0, 1.0);\n}\n\nfloat seg(vec2 p, vec2 a, vec2 b, float r)\n{  \n  b = b-a;\n  a = p-a;\n    \n  float h  = saturate(dot(a,b)/dot(b,b));\n  float d  = length(a - b*h) - r;\n  \n  return smoothstep(0.0095, 0.0, d);\n}\n\n#define RADIUS 0.6\n#define LW     0.004\n#define LL     1.5*RADIUS\n\nconst vec2 x0 = vec2(RADIUS, 0.0);\nconst vec2 y0 = vec2(0.0, RADIUS);\n\nconst vec3 blue  = vec3(0.7, 0.7, 1.9);\nconst vec3 red   = vec3(1.9, 0.7, 0.7);\nconst vec3 green = vec3(0.5, 0.9, 0.5);\nconst vec3 mag   = vec3(0.8, 0.4, 0.8);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float ar = iResolution.x / iResolution.y;\n  vec2  ir = 1.0/iResolution.xy;\n  vec2 uv = 2.0 * (fragCoord.xy*ir) - 1.0;\n  uv.x *= ar;\n  float t = abs(1.0 -(fract(iTime*.25) * 2.0));\n    \n  vec2 A = vec2(1.0, 0.0);\n  vec2 B = (2.0 * iMouse.xy*ir) - 1.0;\n  B.x *= ar;\n  B = normalize(B);\n \n  if (iMouse.w > 0.0) {\n    A = (2.0 * iMouse.zw*ir) - 1.0;\n    A.x *= ar;\n    A = normalize(A);\n  }\n\n  vec2 rl = nlerp(A,B,t);\n  vec2 rs = slerp(A,B,t);\n  vec2 rq = qlerp(A,B,t);\n  \n  vec3 c = vec3(0.0);\n  vec2 o = vec2(0.0);\n  \n  c  += 0.85     *seg(uv, o, LL*A,  LW); // A\n  c  += 0.85     *seg(uv, o, LL*B,  LW); // B\n  c  += 0.85*mag *seg(uv, o, LL*rl, LW); // nlerp(A,B,t)\n  c  += 0.85*blue*seg(uv, o, LL*rs, LW); // slerp(A,B,t)\n  c  += 0.85*red *seg(uv, o, LL*rq, LW); // qlerp(A,B,t)\n    \n  //c += blue*vec3(0.5, 0.5, 0.5) * circle(uv, RADIUS*vec3(rq.x, rq.y, .04));\n    \n  // reference circle and add some SS noise\n  c += vec3(0.5, 0.5, 0.5) * circle(uv, vec3(0, 0, RADIUS));\n  c  = c+(8.0/256.0)*tnoise(fragCoord);\n    \n  fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 156, 185, 185, 229], [231, 238, 259, 259, 315], [317, 339, 361, 361, 444], [446, 446, 483, 483, 519], [521, 521, 558, 558, 725], [727, 727, 764, 764, 928], [1017, 1027, 1052, 1052, 1192], [1194, 1194, 1225, 1225, 1358], [1360, 1360, 1385, 1385, 1416], [1418, 1418, 1462, 1462, 1609], [1910, 1910, 1967, 1967, 3016]], "test": "valid"}
{"id": "4tG3RR", "name": "PBR Test Grid", "author": "geoff", "description": "Grid of the two parameters roughness and metallic.", "tags": ["pbr"], "likes": 3, "viewed": 770, "published": "Public API", "date": "1472583300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\tThe BRDF used in this shader is based on those used by Disney and Epic Games.\n\t\n\tThe input parameters and individual components are modelled after the ones\n\tdescribed in\n\n\t\thttps://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n\tThe various components are then combined based on Disney's PBR shader, found here\n\n\t\thttps://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\t\n\tI'd recommend reading this for a description of what the parameters in this BRDF do\n\n\t\thttp://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\n\t\n*/\nfloat closeObj = 0.0;\nconst float PI = 3.14159;\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec2 flo = vec2(p.y + 0.45, 1.0);\n    float x = 0.0;\n    float y = 0.0;\n    vec2 closeSphere = vec2(10000.0, 10.0);\n    for(float x = 0.0; x <= 1.0; x += 0.1){\n        for(float y = 0.0; y <= 1.0; y += 0.1){\n            vec2 tsphere = vec2(length(p - vec3(-4.55 + x * 10.0, 0.0, -4.55 + y * 10.0)) - 0.45, 2.0);\n            closeSphere = vecMin(closeSphere, tsphere);\n        }\n    }\n    return vecMin(closeSphere, flo);\n}\n\n//Returns the min distance\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 1.0;\n    float d = 0.0;\n    float w = 1.4;\n    float ld = 0.0;\n    float ls = 0.0;\n    float s = 0.0;\n    float cerr = 10000.0;\n    float ct = 0.0;\n    float pixradius = 0.4 / iResolution.x;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 256; i++){\n        ld = d;\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        \n        //Detect intersections missed by over-relaxation\n        if(w > 1.0 && abs(ld) + abs(d) < s){\n            s -= w * s;\n            w = 1.0;\n            t += s;\n            continue;\n        }\n        s = w * d;\n        \n        float err = d / t;\n        \n        if(abs(err) < abs(cerr)){\n            ct = t;\n            cerr = err;\n        }\n        \n        //Intersect when d / t < one pixel\n        if(abs(err) < pixradius){\n            inter = 1;\n            break;\n        }\n        \n        t += s;\n        if(t > 50.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        ct = -1.0;\n    }\n    return ct;\n}\n\n\n//Approximate normal\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0);\nvec3 lightPos = vec3(0.0);\n\n//Square\nfloat sqr(float x){\n  return x * x;\n}\n\n//Diffusion normalisation\nfloat diff(float albedo){\n  return albedo / PI;\n}\n\n//GGX NDF\nfloat specD(float NdotH, float a){\n  float asqr = sqr(a);\n  float NdotHsqr = sqr(NdotH);\n  return asqr / (PI * sqr((NdotHsqr) * (asqr - 1.0) + 1.0));\n}\n\nfloat G1(float NdotX, float k){\n  return NdotX / (NdotX * (1.0 - k) + k);\n}\n\n//Geometric attenuation term\nfloat specG(float NdotV, float NdotL, float k){\n  k /= 2.0;\n  return G1(NdotV, k) * G1(NdotL, k);\n}\n\n//Schlick fresnel approximation used by Unreal Engine\nfloat fresnel(float AdotB){\n  float power = pow(2.0, (-5.55473 * AdotB - 6.98316) * AdotB);\n  return 0.04 + (1.0 - 0.04) * power;\n}\n\n\nvec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 c, float metallic, float roughness, float s, float o){\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n    \n  if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0);\n  \n  float VdotH = dot(V, H);\n  float alpha = roughness * roughness;\n\n  float conductor = 1.0 - metallic;\n\n  vec3 specCol = mix(vec3(1.0), c, metallic);\n  \n  float FresL = fresnel(NdotL);\n  float FresV = fresnel(NdotV);\n  float Fresd90 = 0.5 + 2.0 * sqr(VdotH) * roughness;\n  float Fresd = mix(1.0, Fresd90, FresL) * mix(1.0, Fresd90, FresV); \n  \n  float Ds = specD(NdotH, alpha);\n  float FresH = fresnel(VdotH);\n  vec3 Fress = mix(specCol, vec3(1.0), FresH);\n  float Gs = specG(NdotV, NdotL, roughness);\n\n  return (diff(conductor) * Fresd * max(0.0, NdotL) * o * c + Gs * Fress * Ds * floor(s)) - (0.25 - 0.25 * s) * c;\n}\n\nvec3 colour(vec3 p, float id){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(camPos - p);\n    \n    if(id == 1.0){\n        return vec3(1.0);\n    }\n    if(id == 2.0){\n        float metal = clamp((p.z + 4.55) / 10.0, 0.05, 0.99); \n        float rough = clamp((p.x + 4.55) / 10.0, 0.05, 0.99);\n        return BRDF(l, v, n, vec3(1.0, 0.0, 0.0), metal, rough, 1.0, 1.0);\n    }\n    return vec3(0.0, 1.0, 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 6.0, 0.0);\n    lightPos = vec3(sin(iTime / 2.0) * 10.0, 10.0, cos(iTime/2.0) * 10.0);\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotX(radians(-90.0)) * vec3(uv, 1.1));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(0.0);\n    //If intersected\n    if(d > 0.0){\n        //Colour the point\n        col = colour(c, closeObj);\n        //Apply fog\n    \t//col *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n    col = pow( col, vec3(0.4545) );\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tG3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 673, 692, 692, 833], [835, 835, 854, 854, 995], [997, 997, 1025, 1025, 1085], [1087, 1087, 1107, 1107, 1534], [1536, 1563, 1581, 1581, 1607], [1609, 1609, 1639, 1639, 2637], [2640, 2661, 2681, 2681, 2957], [3012, 3021, 3040, 3040, 3058], [3060, 3086, 3111, 3111, 3135], [3137, 3147, 3181, 3181, 3298], [3300, 3300, 3331, 3331, 3375], [3377, 3406, 3453, 3453, 3505], [3507, 3561, 3588, 3588, 3692], [3695, 3695, 3788, 3788, 4578], [4580, 4580, 4610, 4610, 5023], [5026, 5026, 5082, 5082, 5730]], "test": "valid"}
{"id": "4tt3Df", "name": "Enhanced Sphere-tracer Impl", "author": "geoff", "description": "An implementation of some of the optimisations to the standard sphere tracing algorithm described in 'Enhanced Sphere Tracing' http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nUse the mouse to look around.", "tags": ["spheretracing"], "likes": 11, "viewed": 691, "published": "Public API", "date": "1472233777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AO\n#define SHADOWS\n#define BOUNCES 3\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat closeObj = 0.0;\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\n//Returns a vector (min distance, material)\nvec2 mapMat(vec3 p){\n\tvec2 sphere = vec2(length(p - vec3(sin(iTime), 0.0, cos(iTime))) - 1.0, 2.0);\n    vec2 sphereb = vec2(length(p - vec3(0.0, 0.0, -6.0)) - 1.0, 2.0);\n    vec2 spherec = vec2(length(p - vec3(4.0, 0.0, -3.0)) - 1.0, 3.0);\n    vec2 sphered = vec2(length(p - vec3(-4.0, 0.0, -3.0)) - 1.0, 3.0);\n    vec2 ground = vec2(p.y + 1.0, 1.0);\n    vec2 wall = vec2(-p.z + 5.0, 3.0);\n    return vecMin(sphered, vecMin(spherec, vecMin(sphereb, vecMin(wall, vecMin(sphere, ground)))));\n}\n\n//Returns the min distance\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\n//Sphere tracer implementation - returns distance to closest object and stores material in closeObj\nfloat trace(vec3 ro, vec3 rd){\n    float t = 1.0;\n    float d = 0.0;\n    float w = 1.4;\n    float ld = 0.0;\n    float ls = 0.0;\n    float s = 0.0;\n    float cerr = 10000.0;\n    float ct = 0.0;\n    float pixradius = 1.0 / iResolution.x;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 256; i++){\n        ld = d;\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        \n        //Detect intersections missed by over-relaxation\n        if(w > 1.0 && abs(ld) + abs(d) < s){\n            s -= w * s;\n            w = 1.0;\n            t += s;\n            continue;\n        }\n        s = w * d;\n        \n        float err = d / t;\n        \n        if(abs(err) < abs(cerr)){\n            ct = t;\n            cerr = err;\n        }\n        \n        //Intersect when d / t < one pixel\n        if(abs(err) < pixradius){\n            inter = 1;\n            break;\n        }\n        \n        t += s;\n        if(t > 50.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        ct = -1.0;\n    }\n    return ct;\n}\n\n\n//Approximate normal\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\n//Trace reflections\nfloat traceReflect(inout vec3 ro, inout vec3 rd, const int bounces){\n    float emin = 0.1;\n    float t = 0.0;\n    int inter = 1;\n    for(int i = 0; i < BOUNCES; i++){\n        vec3 n = normal(ro);\n        vec3 rrd = normalize(reflect(rd, n));\n        float e = 2.0 * max(abs(map(ro)), emin);\n        vec3 rro = ro + rrd * e;\n        t = trace(rro, rrd);\n        if(t == -1.0){\n            inter = 0;\n            break;\n        }\n        ro = rro + rrd * t;\n        rd = rrd;\n                if(closeObj != 2.0){\n            break;\n        }\n    }\n    if(inter == 0){\n        t = -1.0;\n    }\n    return t;\n}\n    \n//Globals for use in lighting calculations - updated in main image\nvec3 camPos = vec3(0.0, 0.0, 0.0);\nvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\n//Calculate ambient light\nvec3 amb(vec3 c, float k){\n    return c * k;\n}\n\n//Calculate diffuse light\nvec3 diff(vec3 c, float k, vec3 p){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    return c * k * max(0.0, dot(n, l));\n}\n\n//Calculate specular light\nvec3 spec(vec3 c, float k, vec3 p, float a){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(p - camPos);\n    float facing = dot(l, n) > 0.0 ? 1.0 : 0.0;\n    vec3 r = reflect(l, n);\n    return c * k * facing * pow(max(0.0, dot(r, v)), a);\n}\n\n//Determine if a point is in shadow - 1.0 = not in shadow\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.4;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 64; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\n//Determine a points' occlusion - 1.0 = unoccluded\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 25; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(2.0 * occ, 0.0, 1.0);\n}\n\n//Scoping hack to enable macro enabling of shadows and AO\nfloat s = 1.0;\nfloat ao = 1.0;\n\nvec3 colour(vec3 p, float id){\n    \n    //Compute AO and Shadowing for p\n    //Global definitions of s and ao used if SHADOWS or AO are not defined. \n    \n    #ifdef SHADOWS\n    float s = shadow(p, normalize(camPos - p));\n    #endif\n    \n    #ifdef AO\n    float ao = occlusion(p, normal(p));\n    #endif\n    \n    //Colour points by their material ID\n    if(id == 1.0){\n        //Diffuse colour, specular colour, ambient constant, diffuse constant, specular constant\n        \t//shininess, shadow strength\n    \tvec3 col = vec3(1.0);\n        col = (mod(floor(p.z), 2.0) == 0.0 && mod(floor(p.x), 2.0) != 0.0) \n            \t|| (mod(floor(p.z), 2.0) != 0.0 && mod(floor(p.x), 2.0) == 0.0) ? vec3(1.0, 1.0, 1.0) : vec3(0.0, 0.0, 0.0);\n        vec3 specCol = vec3(1.0);\n        float ka = 0.5;\n        float kd = 0.9;\n        float ks = 0.3;\n        float alpha = 4.0;\n        float ss = 0.4;\n        \n        //Phong reflection model with AO and shadowing\n    \treturn amb(col, ka) * ao + diff(col, kd, p) + floor(s) * spec(specCol, ks, p, alpha) - vec3(ss - ss * s);\n    }else if(id == 2.0){\n        //Diffuse colour, specular colour, ambient constant, diffuse constant, specular constant\n        \t//shininess, shadow strength\n    \tvec3 col = vec3(1.0);\n        vec3 specCol = vec3(1.0);\n        float ka = 0.5;\n        float kd = 0.3;\n        float ks = 0.9;\n        float alpha = 64.0;\n        float ss = 0.4;\n        \n        //Phong reflection model with AO and shadowing\n    \treturn amb(col, ka) * ao + diff(col, kd, p) + floor(s) * spec(specCol, ks, p, alpha) - vec3(ss - ss * s);\n    }else if(id == 3.0){\n        //Diffuse colour, specular colour, ambient constant, diffuse constant, specular constant\n        \t//shininess, shadow strength\n    \tvec3 col = vec3((cos(iTime) + 1.0) / 2.0, 0.0, 1.0);\n        vec3 specCol = vec3(1.0);\n        float ka = 0.5;\n        float kd = 0.9;\n        float ks = 0.3;\n        float alpha = 4.0;\n        float ss = 0.4;\n        \n        //Phong reflection model with AO and shadowing\n    \treturn amb(col, ka) * ao + diff(col, kd, p) + floor(s) * spec(specCol, ks, p, alpha) - vec3(ss - ss * s);\n    }else if(id == 4.0){\n        //Diffuse colour, specular colour, ambient constant, diffuse constant, specular constant\n        \t//shininess, shadow strength\n    \tvec3 col = vec3(1.0, 1.0, 0.0);\n        vec3 specCol = vec3(1.0);\n        float ka = 0.5;\n        float kd = 0.9;\n        float ks = 0.8;\n        float alpha = 64.0;\n        float ss = 0.4;\n        \n        //Phong reflection model with AO and shadowing\n    \treturn amb(col, ka) * ao + diff(col, kd, p) + floor(s) * spec(specCol, ks, p, alpha) - vec3(ss - ss * s);\n    }\n    return vec3(0.0, 1.0, 0.0);\n} \n\n//Camera rotation values\nfloat lastx = 0.0;\nfloat lasty = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 1.0, -3.0);\n    lightPos = vec3(0.0, 2.0, -2.0);\n    lastx += iMouse.x - 0.5;\n    lasty += iMouse.y - 0.5;\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotY(radians(lastx)) * rotX(radians(lasty)) * vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(0.0);\n    //If intersected\n    if(d > 0.0){\n        //Colour the point\n        if(closeObj == 2.0){\n            ro = c;\n            rd = normalize(c - camPos);\n        \td = traceReflect(ro, rd, 1); \n            if(d < 0.0){\n                col = vec3(0.0);\n            }else{\n            \tc = ro;\n            }\n        }\n        if(closeObj > 0.0 && d > 0.0){\n    \t\tcol = colour(c, closeObj);\n        }\n        //Apply fog\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n    col = pow( col, vec3(0.4545) );\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 65, 65, 206], [208, 208, 227, 227, 368], [393, 393, 421, 421, 481], [483, 527, 547, 547, 1018], [1020, 1047, 1065, 1065, 1091], [1093, 1193, 1223, 1223, 2221], [2224, 2245, 2265, 2265, 2541], [2543, 2563, 2631, 2631, 3168], [3314, 3340, 3366, 3366, 3386], [3388, 3414, 3449, 3449, 3553], [3555, 3582, 3626, 3626, 3859], [3861, 3919, 3950, 3950, 4304], [4306, 4357, 4391, 4391, 4640], [4642, 4732, 4762, 4881, 7431], [7434, 7498, 7554, 7554, 8541]], "test": "valid"}
{"id": "4tt3W2", "name": "Sans Battle Scene", "author": "hopskotchrainbow", "description": "Based on Undertale's Sans Battle Scene.", "tags": ["visualizer", "undertale"], "likes": 1, "viewed": 646, "published": "Public API", "date": "1471707134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void blend(inout vec4 result, vec4 color) {\n    result = vec4(mix(result.rgb, color.rgb, color.a), clamp(result.a+color.a, 0.0, 1.0));\n}\nvec2 rotateXY(vec2 coord, float angle) {\n    float rad = radians(angle);\n    return vec2(\n        coord.x*cos(rad)+coord.y*sin(rad),\n        coord.x*sin(rad)-coord.y*cos(rad)\n    );\n}\nvec2 rotateXYPivot(vec2 coord, vec2 pivot, float angle) {\n    vec2 relative = coord-pivot;\n    relative = rotateXY(relative, angle);\n    return relative+pivot;\n}\n\nvoid circle(vec2 coord, vec2 pos, vec4 color, vec2 size, float angle, inout vec4 result) {\n    vec2 hc = coord-pos;\n    hc /= size*0.5;\n    hc = rotateXY(hc, angle);\n    if (length(hc) < 1.0) {\n        blend(result, color);\n    }\n}\nvoid rectangle(vec2 coord, vec4 locs, vec4 color, float angle, inout vec4 result) {\n    coord = rotateXYPivot(coord, vec2((locs.x+locs.z)/2.0, (locs.y+locs.w)/2.0), angle);\n    if (coord.x >= locs.x && coord.y >= locs.y && coord.x <= locs.z && coord.y <= locs.w) {\n        blend(result, color);\n    }\n}\nvoid barWave(vec2 coord, vec4 pos, vec4 color, float angle, inout vec4 result) {\n    pos = vec4(min(pos.z,pos.x),min(pos.w,pos.y),max(pos.z,pos.x),max(pos.w,pos.y));\n    vec2 rel = coord - pos.xy;\n    vec2 scal = vec2(pos.z-pos.x,pos.w-pos.y);\n    rel = rotateXYPivot(rel, scal/2.0, angle);\n    vec2 erl = rel/scal;\n    vec4 waveform = texture(iChannel0, vec2(erl.x, 0.25));\n    float wv = (waveform.r+waveform.g+waveform.b+waveform.a)/4.0;\n    if (rel.x > 0. && rel.x < scal.x && rel.y > 0. && erl.y < wv) {\n        blend(result, vec4(color.r,color.g,color.b,color.a*clamp(wv-erl.y,0.0,1.0)));\n    }\n}\nfloat getAmp(float index) {\n    vec4 amp4 = texture(iChannel0, vec2(mod(index,1.),0.25));\n    return (amp4.r+amp4.g+amp4.b+amp4.a)/4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 hM = texture(iChannel0, vec2(24.,0.25));\n\tfragColor = vec4(0.,0.,0.,1.0);\n    circle(fragCoord, iResolution.xy/2.0, vec4(0.3,0.7,1.,1.), vec2(12.+hM.r*60.,12.+hM.r*60.), 0.0, fragColor);\n    barWave(fragCoord, vec4(0.,0.,iResolution.x, 24.0), vec4(1.,0.7,0.7,1.0), 180.0, fragColor);\n    float ftime = pow(cos(iTime/0.5),2.)*0.2;\n    vec2 hc = fragCoord-iResolution.xy/2.;\n    hc /= iResolution.xy/2.;\n    float hw = hc.y-ftime;\n    float ampf = getAmp(floor((hc.x-iTime*80.5)*160.5)/160.5);\n    ampf = 0.2+ampf*0.75;\n    if (mod(fragCoord.x-iTime*80.5, 32.) <= 16.0 && (hw <= -0.2 || hw >= 0.2)) {\n        blend(fragColor, vec4(1.,1.,1.,1.));\n        if (hw <= -ampf || hw >= ampf) {\n            blend(fragColor, vec4(0.4,0.7,1.,0.7));\n        }\n    }\n}", "image_inputs": [{"id": "lsjGRh", "previewfilepath": "https://soundcloud.com/zevolvez/undertale-ost-megalovania-extended-360p", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/zevolvez/undertale-ost-megalovania-extended-360p", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 136], [137, 137, 177, 177, 320], [321, 321, 378, 378, 482], [484, 484, 574, 574, 715], [716, 716, 799, 799, 1018], [1019, 1019, 1099, 1099, 1621], [1622, 1622, 1649, 1649, 1759], [1761, 1761, 1818, 1818, 2624]], "test": "error"}
{"id": "4tt3Ws", "name": "Sierpinski Gasket Exercise", "author": "docwhite", "description": "Sierpinski Gasket exercise.", "tags": ["spotlight", "sierpinski", "gasket"], "likes": 3, "viewed": 480, "published": "Public API", "date": "1472474995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float Detail = 0.0035;\n\nfloat sdPlane(vec3 p) {\n\treturn p.y + 0.5;\n}\n\nfloat sdSierpinski(vec3 z)\n{\n     const int iterations = 8;\n     const float scale = 2.0;\n     vec3 a1 = vec3(0.0,   1.0,  0.0);\n     vec3 a2 = vec3(0.0,  -0.5,  1.5470);\n     vec3 a3 = vec3(1.0,  -0.5, -0.57735);\n     vec3 a4 = vec3(-1.0, -0.5, -0.57735);\n     vec3 c;\n     float dist, d;\n     int i = 0;\n     for(int n=0; n < iterations; n++) {\n          c = a1; dist = length(z-a1);\n          d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n          d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n          d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n          z = scale * z - c * (scale-1.0);\n          i++;\n     }\n\n     return (length(z)-2.0) * pow(scale, float(-i));\n}\n\nfloat map(vec3 p) {\n    float plane = sdPlane(p);\n    float sierpinski = sdSierpinski(p);   \n    return min(sierpinski, plane);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0.0, Detail);\n    return -normalize(vec3(\n        map(p-e.yxx)-map(p+e.yxx),\n        map(p-e.xyx)-map(p+e.xyx),\n        map(p-e.xxy)-map(p+e.xxy)\n    ));\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float k) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n    \tfloat h = map(ro + rd * t);\n        if (h < 0.001) { return 0.0; }\n        res = min(res, k*h/t);\n       \tt += h;\n    }\n    return res;\n}\n\nfloat spotLight(vec3 p, vec3 n) {\n    vec3 sDir = normalize(vec3(0.0, -1.0, 2.0));\n    vec3 sPos = vec3(0.0, 1.0, -2.0);\n    float co = 40.0;\n    float coDel = 45.0;\n\tvec3 lray = normalize(sPos - p);\n    float fall = clamp((dot(lray, -sDir) - cos(radians(coDel))) / (cos(radians(co)) - cos(radians(coDel))), 0.0, 1.0);\n    float diff = max(0.0, dot(lray, n));\n    float sh = softShadow(p, lray, 0.01, 32.0);\n    return diff * fall * sh;\n}\n\nfloat light(vec3 p, vec3 dir) {\n    vec3 n = normal(p);\n    float spot1 = spotLight(p, n);\n    float ambient1 = 0.2;\n    float total = clamp(spot1 + ambient1, 0.0, 1.0);\n    return total;\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n    float d = 1.0;\n    vec3 p;\n    for (int i = 0; i < 128; ++i) {\n        if (d > Detail && t < 50.0) {\n            p = ro + rd * t;\n            d = map(p);\n            t += d;\n        }\n    }\n    float bg = 0.0;\n    float col;\n    if (d < Detail) {\n    \tcol = light(p-Detail*rd, rd);\n    } else {\n        col = bg;    \n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 cu = normalize( cross(cw,-cp) );\n\tvec3 cv = normalize( cross(cu,-cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n\tvec3 ro = vec3(5.4*sin(iTime * 0.1),1.4, 5.4*cos(iTime * 0.1));\n\tvec3 ta = vec3(0.0);\n    mat3 ca = setCamera(ro, ta);\n    vec3 rd = ca * normalize(vec3(uv.xy, 3.0));\n    \n    float t = trace(ro, rd);\n    fragColor = vec4(t, t, t, 1.0);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 53, 53, 74], [76, 76, 104, 104, 768], [770, 770, 789, 789, 899], [901, 901, 922, 922, 1093], [1095, 1095, 1158, 1158, 1376], [1378, 1378, 1411, 1411, 1816], [1818, 1818, 1849, 1849, 2007], [2009, 2009, 2040, 2040, 2401], [2403, 2403, 2444, 2444, 2627], [2629, 2629, 2686, 2686, 3040]], "test": "valid"}
{"id": "4tt3z2", "name": "Bitwise Operators", "author": "rkevingibson", "description": "Visualizing a handful of bitwise operators. Each pixel is colored according to OP(x, y), where OP is one of bitwise and, or, xor, & nand. ", "tags": ["2d", "visualization", "bitwise"], "likes": 1, "viewed": 164, "published": "Public", "date": "1470341454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tVisualizing bitwise operations.\n\tThis is my first shader here, just trying out some of the viz shown in this article:\n\thttps://medium.com/biffures/part-2-the-beauty-of-bitwise-and-or-cdf1d8d87891\n\tJust because I thought they looked nice. \n\tGonna try using them as a heightfield for a landscape next, to practice some ray tracing\n*/\n\n//Uncomment one of these to visualize.\n\n//#define OP bitwiseAND\n//#define OP bitwiseOR\n#define OP bitwiseNAND\n//#define OP bitwiseXOR\n\nfloat bitwiseAND(in vec2 p)\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += mod(a.x*a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\nfloat bitwiseOR(in vec2 p)\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += mod(a.x,2.0) + mod(a.y,2.0) - mod(a.x*a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\nfloat bitwiseNAND(in vec2 p)\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += 1.0 - mod(a.x*a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\nfloat bitwiseXOR(in vec2 p)\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += mod(a.x+a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\nvec3 hsv_to_rgb(in vec3 hsv)\n{\n    return mix(vec3(1.0),clamp((abs(fract(hsv.x+vec3(3.0, 2.0, 1.0)/3.0)*6.0-3.0)-1.0), 0.0, 1.0),hsv.y)*hsv.z;\n}\n\nvec4 map_color(in float x)\n{\n\t//Map value to color gradient.\n    float t = x; \n    vec3 a =\tvec3(0.5*sin(0.5*iTime + 0.6) + 0.5,0.1,0.1);\n    vec3 b =\tvec3(0.5*sin(0.5*iTime) + 0.5,0.5,0.8);\n    \n    vec3 result = mix(a, b, t);\n    \n    float d = b.x - a.x;\n    float delta = d + ((abs(d) > 180.0) ? ((d < 0.0) ? 360.0 : -360.0) : 0.0);\n    \n    result.x = mod(a.x + (t)*delta + 360.0, 360.0);\n    \n    return vec4(hsv_to_rgb(result),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 point = 128.0*fragCoord/min(iResolution.x, iResolution.y) + 5.0*iTime;\n    float val = OP(point);\n    //float val = bitwiseNAND(point) + bitwiseAND(point);\n    fragColor = map_color(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[447, 472, 501, 501, 703], [705, 705, 733, 733, 965], [967, 967, 997, 997, 1205], [1207, 1207, 1236, 1236, 1438], [1440, 1440, 1470, 1470, 1584], [1586, 1586, 1614, 1646, 2027], [2029, 2029, 2086, 2086, 2286]], "test": "valid"}
{"id": "4ttGRs", "name": "raw pictures of ancient gods", "author": "visy", "description": "raw pictures of ancient gods, as featured in Quadtrip's 4k intro \"Young Person's Guide To The Vimana\"\n\nhttps://www.pouet.net/prod.php?which=67960", "tags": ["dsadsad"], "likes": 1, "viewed": 120, "published": "Public", "date": "1470989260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on gltracy's marching examples\n\n// ray marching\nconst int max_iterations = 8;\nfloat stop_threshold = 0.2;\n float grad_step = 0.00;\nconst float clip_far = 1000.0;\n\nfloat speed = 1.0;\nfloat time = 0.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nfloat repeat(vec3 pos) {\n    pos.x = mod(pos.x, 1.) - 0.5;\n    pos.y = mod(pos.y, 1.) - 0.5;\n    pos.z = mod(pos.z, 1.) - 0.5;\n    return dist_sphere(pos*pos.zyx,pos.z*2.2);\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n\t\n\t// object 0 : sphere\n\tfloat d0 =time*0.1;\n\t\n\t// object 1 : cube\n\tfloat d1 = dist_box( pos, vec3( 2.0 ) );\n\n    float d2 = repeat(pos);\n    \n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn max(d2, min( d1, -d0 ));\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 4.5;\n\t\n\tvec3 final = vec3( -0.7+time*0.003 );\n\t\n    if (final.r > 0.5) final = vec3(0.5);\n    \n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0+cos(time*0.1)*100., 20.0, 20.0-time*0.1 );\n\t\tvec3 light_color = vec3( 1.0, 0.6+time*0.01, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0+cos(time*0.4), 0.7, 0.2 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\t vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\t vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\t vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) * dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth )*time*0.35;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( (150.0-(time*1.1) - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n\nvoid mainImage(out vec4 fa, in vec2 aa)\n{\n    if (iTime*speed > 4.5 && iTime*speed < 5.5) speed=10.0+(4.5-iTime)*1.;\n    else if (iTime*speed > 8.5 && iTime*speed < 8.9) speed=2.1+(8.6-iTime)*1.;\n    else if (iTime*speed > 16.5 && iTime*speed < 17.5) speed=2.0+(16.5-iTime)*1.;\n    else if (iTime*speed > 28.9 && iTime*speed < 29.6) speed=1.9;\n\telse speed = 1.0;\n\n    if (iTime*speed > 94. && iTime*speed < 107.4) { speed = 88.;} \n    \n    time = iTime*speed;\n    \n    if (time > 5.5) time+=1.0;\n    if (time > 28.5 && time < 30.) time+=5020.95;\n        \n        if (time > 95. && speed == 88.) { time+=3232200.-time*1.11; speed = 100.;} \n    \n    if (time >= 107.4 && speed != 100. && time < 119.91) time+=9933.;\n    \n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n    if (uv.x < 0.5) uv.x = 1.0-uv.x;\n    \n    // default ray dir\n\tvec3 dir = ray_dir( 145., iResolution.xy, uv*iResolution.xy );\n\t\n    \n  if (stop_threshold > 1.1)  stop_threshold = 1.4 - time*0.03;\n\n    grad_step = -10.0+time*0.0001;\n    \n\t// default ray origin\n\tvec3 eye = vec3( 100., time*0.5, time*0.05 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( 0.0+cos(time*0.00005)*0. ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 3.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfa = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n    vec4 oc = vec4( shading( pos, n, eye ), 1.0 );\n    for (int i = 0; i < 10; i++) {\n\t    oc+=vec4(shading(pos+vec3(float(i)*9.1,0.+cos(time*1.+float(i)*1.1)*10.9,cos(time*0.1+float(i)*3.)*10.),n*vec3(cos(time*0.1)*1.0,0.0,time*0.01)*8.1,eye),0.0)*0.011;\n\t    oc.rgb += pow( oc.rgb, vec3(0.2525) )*0.08;\n    }\n    \n    oc *= 0.2 + 0.8*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.05-uv.y),0.85);\n    oc = clamp(oc,vec4(0.0),vec4(1.0));\n    vec4 oc2 = vec4( shading( pos+vec3(0.+cos(uv.y+time)*10.,0.,0.), n, eye ), 1.0 )*0.9;\n\tif (oc.r > 0.95 && oc.g > 0.95 && oc.b > 0.95) oc *= oc2*1.2;\n    \n    fa = oc;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 309, 349, 349, 378], [380, 380, 419, 419, 470], [472, 472, 496, 496, 647], [649, 678, 708, 759, 1006], [1008, 1025, 1067, 1093, 2035], [2037, 2066, 2093, 2093, 2412], [2414, 2430, 2499, 2499, 2759], [2761, 2782, 2830, 2830, 3017], [3019, 3051, 3082, 3082, 3238], [3240, 3240, 3263, 3263, 3319], [3322, 3322, 3363, 3363, 5335]], "test": "valid"}
{"id": "4ttGWX", "name": "Sacred Circles", "author": "coil", "description": "Fooling around a bit, first shader", "tags": ["2d"], "likes": 2, "viewed": 150, "published": "Public", "date": "1472158711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LineWidth  1.\n#define rotRadius 0.\n#define rotSpeed 0.5\n#define oscSpeed 1.\n#define pi 3.1415\n#define ringFreq 5.\n#define intensity 0.3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    \n    float t = iTime;\n    \n    fragColor = vec4(0.);\n    \n    //mat4(0,1,-1,0)\n    //vec2 P1 = vec2(0.75,0.5) , P2 = vec2(rotRadius*sin(rotSpeed*t)+0.*sin(oscSpeed*t), rotRadius*cos(oscSpeed*t)+0.2*sin(rotSpeed*t)) + P1, P3 = mat2(0,1,-1,0)*(P1-P2) + (P1+P2)/2.;\n    vec2 P1 = vec2(0.75,0.5) , P2 = vec2(0.1*t, rotRadius*cos(oscSpeed*t)+0.2*sin(rotSpeed*t)) + P1, P3 = mat2(0,1,-1,0)*(P1-P2) + (P1+P2)/2.;\n    \n    float P1r = length(P1 - uv), P2r = length(P2 - uv), P3r = length(P3-uv), PointDist = length(P1-P2);\n    \n    fragColor += vec4(0.05, 0. , 0., 1.0) * abs(0.5*tan( + ringFreq*pi*(1.-abs(PointDist-P1r ))/LineWidth) + 0.1);\n    fragColor += vec4(abs(sin(t)),0.0, 0., 1.0) * abs(0.5*sin(0.5*pi + 2.*ringFreq*pi*(1.-abs(PointDist-P1r ))/LineWidth) + 0.1);\n\n    \n    fragColor += vec4(0.0, 0.05, 0.0, 1.0) * abs(0.5*tan( + ringFreq*pi*(1.-abs(PointDist-P2r ))/LineWidth) + 0.1);\n\tfragColor += vec4(0.1, abs(sin(t)), 0.0, 1.0) * abs(0.5*sin(0.5*pi + 2.*ringFreq*pi*(1.-abs(PointDist-P2r ))/LineWidth) + 0.1);\n       \n    \n    fragColor += vec4(0.0, 0.0, 0.05, 1.0) * abs(0.5*tan( + ringFreq*pi*(1.-abs(PointDist-P3r ))/LineWidth) + 0.1);\n  \tfragColor += vec4(0.0, 0.0, abs(sin(t)), 1.0) * abs(0.5*sin(0.5*pi + 2.*ringFreq*pi*(1.-abs(PointDist-P3r ))/LineWidth) + 0.1);\n   \n\t   \n}\n\n//add si", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 201, 201, 1536]], "test": "valid"}
{"id": "4ttGzB", "name": "015 2d shadow", "author": "kakaxizhhgjh", "description": "2d shadow, inspired by https://www.shadertoy.com/view/4dfXDn\ncannot understand source code,  so use my shadow function instead. effect not good as original, thare are some artificial, so any improve please let me know.", "tags": ["2dshadow"], "likes": 11, "viewed": 507, "published": "Public", "date": "1470052247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float opU(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nfloat opI(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n\treturn max(d1, -d2);\n}\n\nfloat circle(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat ring(vec2 p, float r, float thick) {\n\treturn abs(circle(p, r)) - thick;\n}\n\nfloat pie(vec2 p, float angle) {\n    return dot(vec2(abs(p.x), p.y), vec2(cos(angle), sin(angle)));\n}\n\nfloat arc(vec2 p, float r, float thick, float angle) {\n\treturn opS(ring(p, r, thick), pie(p, angle));\n}\n\nfloat round_box(vec2 p, vec2 d, float r) {\n\tp = abs(p) - d;\n    return min(max(p.x,p.y),0.0) + length(max(p,0.0)) - r;\n}\n\nfloat line_segment(vec2 p, vec2 a, vec2 b, float r) {\n\tvec2 ab = b - a;\n    vec2 ap = p - a;\n    return length(ap - ab * clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0)) - r;\n}\n\n// triangle's sdf comes form iq's https://www.shadertoy.com/view/XsXSz4\n// it use perp dot product to decide whether p inside or outside of triangle\n// more info: http://mathworld.wolfram.com/PerpDotProduct.html\n// vector's perpendicular has two directions below or above\n// choose direction according to triangle's ccw or cw\n// so in this implementation, a, b, c must be given ccw\n\nfloat perp_dot(vec2 a, vec2 b) {\n\treturn dot(vec2(-a.y, a.x), b);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 ab = b - a, bc = c - b, ca = a - c;\n    vec2 ap = p - a, bp = p - b, cp = p - c;\n    vec2 pab = ap - ab * clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0);\n    vec2 pbc = bp - bc * clamp(dot(bc, bp) / dot(bc, bc), 0.0, 1.0);\n    vec2 pca = cp - ca * clamp(dot(ca, cp) / dot(ca, ca), 0.0, 1.0);\n    \n    vec2 d = min(min(\n        vec2(dot(pab, pab), perp_dot(ab, ap)),\n    \tvec2(dot(pbc, pbc), perp_dot(bc, bp))),\n        vec2(dot(pca, pca), perp_dot(ca, cp)));\n    \n    return -sqrt(d.x) * sign(d.y);\n}\n\nmat2 ccw(float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n\treturn mat2(ca, sa, -sa, ca);\n}\n\nfloat map(vec2 p) {\n    float d = circle(p - vec2(-1.3, 0.45), 0.25);\n    d = opU(d, ring(p - vec2(-0.6, 0.45), 0.22, 0.04));\n    d = opU(d, round_box(p - vec2(0.1, 0.45), vec2(0.2), 0.05));\n    d = opU(d, line_segment(p - vec2(0.8, 0.45), vec2(-0.2), vec2(0.2), 0.05));\n    d = opU(d, triangle(p - vec2(1.3, 0.45), vec2(-0.25), vec2(0.25, -0.25), vec2(0.0, 0.25)));\n    \n    d = opU(d, opS(\n        circle(p - vec2(-1.3, -0.45), 0.25),\n        round_box(p - vec2(-1.3, -0.45 + 0.25 * sin(iTime * 3.0)), vec2(0.3, 0.1), 0.0)));\n    \n    d = opU(d, opI(\n        circle(p - vec2(-0.6, -0.45), 0.25),\n    \tround_box(p - vec2(-0.6, -0.45 + 0.25 * sin(iTime * 3.0)), vec2(0.3, 0.1), 0.0)));\n    \n    d = opU(d, opU(\n        circle(p - vec2(0.1, -0.45), 0.25),\n    \tround_box(p - vec2(0.1, -0.45 + 0.25 * sin(iTime * 3.0)), vec2(0.3, 0.1), 0.0)));\n    \n    d = opU(d, triangle((p - vec2(0.8, -0.45)) * ccw(iTime),\n        vec2(-0.2165, -0.125), vec2(0.2165, -0.125), vec2(0.0, 0.25)));\n    \n    d = opU(d, arc(p - vec2(1.3, -0.45), 0.2, 0.03, 0.6));\n    \n    return d;\n}\n\nfloat plot_edge(float d) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, abs(d));\n}\n\nfloat plot_solid(float d) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, max(0.0, d));\n}\n\nvec3 shadow(vec2 ro, vec2 mo) {\n    vec2 rd = normalize(mo - ro);\n    for(int i = 0; i < 48; ++i) {\n        float d = map(ro);\n        float tmax = length(mo - ro);\n        if(d > tmax) return vec3(0.2);\n        if(d < 0.01) return vec3(0.0);\n        ro += d * rd;\n    }\n    return vec3(0.2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mo = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 bg = vec3(0.5) * (1.0 - length(uv) * 0.3);\n    bg *= clamp(min(mod(fragCoord.x, 20.0), mod(fragCoord.y, 20.0)), 0.9, 1.0);\n    bg = mix(bg, vec3(1.0), plot_solid(circle(uv - vec2(mo), 0.06)));\n    bg += shadow(uv, mo);\n    \n    float d = map(uv);\n    bg = mix(bg, vec3(1.0, 0.4, 0.0), plot_solid(d));\n    bg = mix(bg, vec3(0.0), plot_edge(d));\n    \n\tfragColor = vec4(bg, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 54], [56, 56, 87, 87, 110], [112, 112, 143, 143, 167], [169, 169, 200, 200, 225], [227, 227, 269, 269, 306], [308, 308, 340, 340, 409], [411, 411, 465, 465, 514], [516, 516, 558, 558, 636], [638, 638, 691, 691, 809], [811, 1194, 1226, 1226, 1261], [1263, 1263, 1311, 1311, 1814], [1816, 1816, 1835, 1835, 1914], [1916, 1916, 1935, 1935, 2980], [2982, 2982, 3008, 3008, 3064], [3066, 3066, 3093, 3093, 3154], [3156, 3156, 3187, 3187, 3450], [3452, 3452, 3507, 3507, 4029]], "test": "valid"}
{"id": "ll33Ds", "name": "Autumn Diacubes", "author": "Imsure1200q_1UWE130", "description": "These Are The Autumn Diacubes ( Curve-edged Cubes ) Which Emit Light Of Autumn", "tags": ["raymarched", "cubes", "lights", "pattern", "autumn"], "likes": 2, "viewed": 513, "published": "Public API", "date": "1472388253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, vec2 u )\n{\n    float T = iTime;\n    u = (u+u-(o.xy=iResolution.xy))/o.y;\n\to = (1. - length(cos(tan(u+sin(T/vec2(2,3))-T)+T))) /\n        cos(u.y) * vec4(u+vec2(.6,.025), .025, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll33Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 208]], "test": "valid"}
{"id": "ll33WX", "name": " ", "author": "albertelwin", "description": "Was practicing raycasting and got carried away :)", "tags": ["3d", "raycasting", "supersampling", "space"], "likes": 11, "viewed": 268, "published": "Public", "date": "1471995252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SUPERSAMPLING 1\n\n#define TAU 6.28318530717958647692\n#define TO_RAD 0.01745329251\n#define GAMMA 2.2\n\nfloat dither(vec2 xy, float t) {\n    float s = (xy.x * 12.9898) + (xy.y * 78.2330);\n    float r = fract(sin((t * 12.9898) + s) * 43758.5453) + fract(sin((t * 78.2330) + s) * 43758.5453);\n    return (r * 0.00392156886) - 0.00196078443;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float fov = 90.0;\n    float tan_fov = tan(fov * 0.5 * TO_RAD);\n    vec2 image_plane = vec2(tan_fov, tan_fov * (iResolution.y / iResolution.x));\n\n#define MAX_SAMPLE_COUNT 8\n    vec2 sample_offsets[MAX_SAMPLE_COUNT];\n\tsample_offsets[0] = vec2(0.125, 0.875);\n    sample_offsets[1] = vec2(0.625, 0.875);\n    sample_offsets[2] = vec2(0.375, 0.625);\n    sample_offsets[3] = vec2(0.875, 0.625);\n    sample_offsets[4] = vec2(0.125, 0.375);\n    sample_offsets[5] = vec2(0.625, 0.375);\n    sample_offsets[6] = vec2(0.375, 0.125);\n    sample_offsets[7] = vec2(0.875, 0.125);\n    \n#if SUPERSAMPLING\n    #define SAMPLE_COUNT MAX_SAMPLE_COUNT\n#else\n    #define SAMPLE_COUNT 1\n#endif\n\n    vec3 color = vec3(0.0);\n    \n    for(int sample_index = 0; sample_index < SAMPLE_COUNT; sample_index++) {\n        vec2 sample_pos = fragCoord.xy + sample_offsets[sample_index];\n        vec3 image_point = vec3((2.0 * sample_pos / iResolution.xy - 1.0) * image_plane, 1.0);\n       \n        vec3 ro = vec3(0.0);\n        vec3 rd = normalize(image_point);\n\n        vec3 light_pos = vec3(-0.3, 0.0, 0.0); \n\n        vec3 P = vec3(0.0, 0.0, 0.22);\n        float R = 0.1;\n        float R2 = R * R;\n\n        vec3 h = P - ro;\n        float a = dot(rd, h);\n        float b2 = dot(h, h) - a * a;\n        float t = a - sqrt(R2 - b2);\n        if(t > 0.0) {\n            vec3 p = ro + t * rd;\n            vec3 n = normalize(p - P);\n            \n            vec3 l = normalize(light_pos - p);\n            float dot_nl = clamp(dot(n, l), 0.0, 1.0);\n\n            float v = iTime * 0.05;\n            vec2 uv = n.xy + texture(iChannel0, n.xy * 0.7 - vec2(v * 0.4, 0.0)).xy - v;\n            float tex = texture(iChannel1, uv).z * 0.77;\n            \n            color += dot_nl * tex;\n        }\n        else {\n            vec2 seed = fragCoord.xy; \n            vec2 r;\n            r.x = fract(sin((seed.x * 12.9898) + (seed.y * 78.2330)) * 43758.5453);\n            r.y = fract(sin((seed.x * 53.7842) + (seed.y * 47.5134)) * 43758.5453);\n\n            float x = mix(r.x, (sin((iTime * 2.5 + 60.0) * r.y) * 0.5 + 0.5) * ((r.y * r.y) * (r.y * r.y)), 0.04); \n            color += pow(x, 70.0);\n        }\n    }\n    \n    color *= (1.0 / float(SAMPLE_COUNT));\n    color += dither(fragCoord.xy, fract(iTime));\n    color = pow(color, vec3(1.0 / GAMMA));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll33WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 141, 141, 345], [347, 347, 402, 402, 2741]], "test": "error"}
{"id": "ll3GDS", "name": "SDF shape blending", "author": "tiusic", "description": "Playing with blending shapes together in an SDF", "tags": ["sdf"], "likes": 1, "viewed": 342, "published": "Public", "date": "1471215798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\nvec3 intersectionColor = vec3(1, 0, 1);\n\nvec3 colorA = vec3(0, 1, 0);\nvec3 colorB = vec3(0, 0, 1);\n\nvec4 blend(float a, float b, float m) {\n    return vec4(min(min(a, b), a * b - m), (a * colorA + b * colorB) / (a + b));\n}\n\nfloat dSphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat dBox(vec3 p, vec3 c, vec3 dimensions, mat3 rot) {\n\tvec3 d = abs((p - c) * rot) - dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvoid test(inout vec2 distMat, float newDist, int newMat) {\n    if (newDist < distMat.x) {\n        distMat = vec2(newDist, float(newMat));\n    }\n}\n\nfloat shapeSpacing = 3.0 * sin(0.1 * iTime);\nvec2 boxRotor = vec2(cos(iTime), sin(iTime));\nmat3 boxRotation = mat3(1, 0, 0, 0, boxRotor.x, -boxRotor.y, 0, boxRotor.y, boxRotor.x);    \n\nvec4 d(vec3 p) {\n    bool first = true;\n    vec4 mindd;\n    for (float i = 0.0; i <= 1.01; i += 0.1) {\n        vec3 c0 = vec3(30.0 * i, 10, shapeSpacing);\n        vec3 c1 = vec3(30.0 * i, 10, -shapeSpacing);\n        vec4 dd = blend(dSphere(p, c0, 1.0), dBox(p, c1, vec3(1.0, 1.0, 1.0), boxRotation), i);\n        if (first || dd.x < mindd.x) {\n            mindd = dd;\n        }\n        first = false;\n    }\n    return mindd;\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    d(pos+eps.xyy).x - d(pos-eps.xyy).x,\n\t    d(pos+eps.yxy).x - d(pos-eps.yxy).x,\n\t    d(pos+eps.yyx).x - d(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n#define MAX_STEPS 100\n#define MARCH_EPSILON .001\n#define MAX_T 1000.\n\nvoid IntersectScene(vec3 origin, vec3 direction) {\n    float t = 0.;\n    for (int ii = 0; ii < MAX_STEPS; ++ii) {\n        vec3 pos = origin + direction * t;\n        vec4 dd = d(pos);\n        if (dd.x < MARCH_EPSILON) {\n            if (t < MAX_T) {\n\t\t\t\tintersectionNormal = calcNormal(pos);\n            \tintersectionPoint = pos;\n                intersectionT = t;\n                intersectionColor = dd.yzw;\n            }\n            break;\n        }\n        t += dd.x;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\tvec3 origin = vec3(15.0, -15.0, 0.0);\n\tvec3 direction = vec3(uv.x, 1, uv.y);\n\tdirection.xz *= .8;\n\tdirection = normalize(direction);\n\tvec3 color = vec3(0);\n    intersectionT = 1e37;\n    IntersectScene(origin, direction);\n    if (intersectionT < MAX_T) {\n        float lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n        if (lightDot > 0.0) {\n        \tcolor = mix(intersectionColor, vec3(1, 1, 1), 0.3 * lightDot);\n        } else {\n        \tcolor = mix(intersectionColor, vec3(0, 0, 0), -lightDot);\n        }\n    }\n\tfragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3GDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 209, 209, 292], [294, 294, 334, 334, 366], [368, 368, 423, 423, 529], [531, 531, 589, 589, 676], [863, 863, 879, 879, 1288], [1290, 1290, 1320, 1320, 1528], [1600, 1600, 1650, 1650, 2076], [2078, 2078, 2133, 2133, 2844]], "test": "valid"}
{"id": "llc3Ds", "name": "vaulted", "author": "wjbgrafx", "description": "Another domain repetition experiment.", "tags": ["3d", "raymarch", "domain", "repetition"], "likes": 8, "viewed": 569, "published": "Public API", "date": "1472400698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"vaulted\" by wjbgrafx\n\t\n\tbased on\n\t\t\n\tRaymarched Reflections   Uploaded by Shane in 2015-Nov-17\n\thttps://www.shadertoy.com/view/4dt3zn\n\t\n\tPlaying with symmetries - Torus\t   by @paulofalcao\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n\tHG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n\thttp://mercury.sexy/hg_sdf\n\t\n\thttp://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\n\tArray and textureless GLSL 2D/3D/4D simplex noise functions.\n\tIan McEwan, Ashima Arts.\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n#define PI_4\t\t\t\t\t0.78539816339744830961566084581988\n#define PHI \t\t\t\t\t1.618033988749895\n\n#define FAR                     300.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_FOV_FACTOR          1.5\n#define LIGHT_COLOR\t\t\t\tvec3( 1.0 )\n#define LIGHT_ATTEN\t\t\t\t0.02\n\n//------------------------------------------------------------------------------\n// Function declarations\n//----------------------\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID,\n                                                            in vec3 lightPos );\nvec2 rot( vec2 p, float r );\nvec2 rotsim( vec2 p, float s );\n\nfloat pMod1(inout float p, float size); \nfloat pModPolar(inout vec2 p, float repetitions);\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset); \nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\nfloat fSphere(vec3 p, float r);\nfloat fBox(vec3 p, vec3 b);\nfloat fOctahedron(vec3 p, float r, float e);\n \nfloat modPyramid( vec3 p, float h, float baseScale ); \nfloat modOctahedron( vec3 p, float height, float scale );\n\nfloat snoise(vec3 v);\n\n//==============================================================================\n\n// MAP\n// ---\n\nvec2 map( vec3 p )\n{  \n\tfloat centeringDist = 2.75 + 3.0 * abs( sin( iTime * 0.11 ) );\n\tp.x += centeringDist;\n\tp.xy = rot( p.xy, PI_4 );\n\tpReflect( p, normalize( vec3( 1.0, -1.0, 0.0 ) ), centeringDist );\n\tpReflect( p, normalize( vec3( -1.0, -1.0, 0.0 ) ), centeringDist );\n\n\tpMod1( p.z, 11.0 );\n\tvec3 p2 = p,\n\t     p3 = p,\n\t     p4 = p;\n\n\tp.y += 6.0 * abs( sin( iTime * 0.13 ) );\n\t\n\tp2.xz = p3.xz = rot( p2.xz, iTime * 0.31 );\n\t\t\n\tp2.xz = rotsim( p2.xz, 4.0 );\n\tp2.z -= 0.75;\n\t\n\tfloat objID = 1.0;\t      \n\tvec2 obj1 = vec2( fPlane( p, vec3( 0.0, 1.0, 0.0 ), 5.0 ), objID );\n\t\n\tp2.y += 1.0;\n\tobjID = 2.0;\n\tfloat d1 = modOctahedron( p2, 4.0, 0.6 ),\n\t      d2 = modOctahedron( p2.xzy, 4.0, 0.6 ),\n\t      d3 = modOctahedron( p2.zxy, 4.0, 0.6 );\n\t      \n    p2.xz = rot( p2.xz, PI_4 );\n    float d4 = fOctahedron( p2, 2.0, 40.0 ); \n\t      \t\n\tvec2 obj2 = vec2( max( min( d1, min( d2, d3 ) ), -d4 ), objID );\n\t\t\n\tpModPolar( p3.xz, 4.0 );\n\t\n\tobjID = 4.0;\n\td1 = fSphere( p3 - vec3( 5.0, -1.0, 0.0 ), 0.75 );\n\tvec2 obj4 = vec2( d1, objID );\n\t\n\tp2.xz = rot( p2.xz, iTime * -1.71 );\n\n\tobjID = 3.0;\n\td1 = modOctahedron( p2, 2.2, 0.5 );\n\td2 = modOctahedron( p2.xzy, 2.2, 0.5 );\n\td3 = modOctahedron( p2.zxy, 2.2, 0.5 );\n\t\n\tvec2 obj3 = vec2( min( d1, min( d2, d3 ) ), objID );\n\t\n\tp4.xz = rot( p4.xz, iTime * -7.47 );\n\t\n\tobjID = 4.0;\t\n\tvec2 obj5 = vec2( fBox( p4 - vec3( 0.0, -5.1, 0.0 ), \n\t                                       vec3( 3.5, 0.02, 0.125 ) ), objID );\n\t\n\tvec2 closest = obj1;\n\tclosest = closest.s < obj2.s ? closest : obj2;\n\tclosest = closest.s < obj3.s ? closest : obj3;\n\tclosest = closest.s < obj4.s ? closest : obj4;\n\tclosest = closest.s < obj5.s ? closest : obj5;\n\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID, vec3 rayDir )\n{    \n    vec3 clr = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.13 ) ), \n\t\t            abs( sin( iTime * 0.17 ) ),\n\t\t\t        abs( sin( iTime * 0.19 ) ) );\n\t\t\n\t\tvec3 pos = distID.s * rayDir;\n\t\tpos.z += iTime * 2.5; \n\t\t\n\t\tfloat scale = 0.2,\n\t\t      complexity = 20.0,\n\t\t      mixVal = 0.5;\n\t\t\n\t\tvec3 v = pos * scale;\n\n\t\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t\t// Combination Marble( triangular) with Marble( sharp ) - texture 10\n\t\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\t\tt += snoise(v);\t\n\t\tfloat value = t - floor(t);\t\t\t\n\t\t// smooth out the discontinuity\n\t\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\t\tvalue = 0.333 + value*0.667;\n\t\tvec3 color = vec3(value);\t\t    \n\t\t// Marble ( sharp )  :  wjb added variable complexity factor\n\t\tt = (v.x + 2.0*v.y + 3.0*v.z);\n\t\tt +=  snoise(v) * complexity;\n\t\tvalue =  abs(sin(t));\n\t\tcolor /= vec3(sqrt(value)); // modified to divide    \t\t    \n\t\tclr = mix( color, clr, mixVal );        \t\t\t\t\n\t}\n\telse if( objNum == 2.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.03 ) ), \n\t\t            abs( sin( iTime * 0.07 ) ),\n\t\t\t        abs( sin( iTime * 0.05 ) ) );\n\t}\n\telse if( objNum == 3.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.07 ) ), \n\t\t            abs( sin( iTime * 0.05 ) ),\n\t\t\t        abs( sin( iTime * 0.03 ) ) );\n\t}\n\telse if( objNum == 4.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.05 ) ), \n\t\t            abs( sin( iTime * 0.03 ) ),\n\t\t\t        abs( sin( iTime * 0.07 ) ) );\n\t}\n    \n    return clr;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec3 camPos = vec3( 0.4 * sin( iTime * 0.23 ), \n                6.5 + 12.0 * sin( iTime * 0.31 ), \n                                   iTime * 2.5 );\n    vec3 lookAt = camPos + vec3( 0.0, 0.0, camPos.z + 10.0 );\n    vec3 rayDir = getRayDir( camPos, normalize( lookAt - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n    vec3 lightPos = vec3( 0.0, 0.0, \n                       camPos.z + 15.0 + 35.0 * sin( iTime * 0.17 ) );\n\tvec3 sceneColor = vec3( 0.0 );\n\tvec3 skyClr = vec3( abs( sin( iTime * 0.13 ) ), \n\t\t                abs( sin( iTime * 0.17 ) ),\n\t\t\t            abs( sin( iTime * 0.19 ) ) );\n\t   \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( ( camPos.z + FAR ) * 0.35, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID, lightPos );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID, lightPos );\n\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    sceneColor *= fog;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n    \n}\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\n// Standard raymarching routine.\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\n// Second pass, which is the first, and only, reflected bounce. Virtually the \n// same as above, but with fewer iterations and less accuracy.\n\n// The reason for a second, virtually identical equation is that raymarching is \n// usually a pretty expensive exercise, so since the reflected ray doesn't \n// require as much detail, you can relax things a bit - in the hope of speeding \n// things up a little.\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft  \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow \n    // things down. Obviously, the lowest number to give a decent shadow is the \n    // best one to choose. \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n\n        //shade = min( shade, k * h / dist );\n        // Subtle difference. Thanks to IQ for this tidbit.\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n\n        // So many options here, and none are perfect: dist += min( h, 0.2 ),etc\n        dist += min( h, stepDist * 2.0 ); \n        \n        // Early exits from accumulative distance function calls tend to be a \n        // good thing.\n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. \n    // It's a preference thing. Really dark shadows look too brutal to me.\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID,\n                                                             in vec3 lightPos )\n                                                               \n{    \n    // Light direction vector.\n    //vec3 lDir = LIGHT_POS - sp; \n    vec3 lDir = lightPos - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    // wjb added rayDir as argument in order to allow texturing of objects.\n    vec3 objCol = getObjectColor( sp, distID, rayDir );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + LIGHT_COLOR * spec * 2.0 ) * \n                                                                         atten;\n  \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// From Playing with symmetries - Torus\t   by @paulofalcao\t\n// http://glslsandbox.com/e#29755.0\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------\n\n// HG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n// http://mercury.sexy/hg_sdf\n\n// Sign function that doesn't return 0\nfloat sgn(float x) \n{\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) \n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\n\n\t// To obtain separation of the cloned objects, either:\n\t// 1.) translate the original object in the object definition function, or\n\t// 2.) translate p *after* the pModPolar function is called.\n\t//  This version preserves the full object shapes, without shearing, when \n\t// they're offset from the origin - but along the correct axis.\n\t//pModPolar( p.xy, 4.0 );\n\t//p -= vec3( 1.0, 0.0, 0.0 ); // this works\n\t//p -= vec3( 0.0, 1.0, 0.0 ); // this doesn't - causes shearing\n\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) \n{\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\t\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0.0))) + vmax(min(d, vec3(0.0)));\n}\n\n//------------------------------------------------------------------------------\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n// wjb note - This is the code from first version, newer version crashes Nvidia\n// Macro based version for GLSL 1.2 / ES 2.0\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n//------------------------------------------------------------------------------\n\n// Pyramid with base on xz-plane at y=0.0, h = height, s = scaling factor for\n// length of an edge of the square pyramid base, where edge length = s * h, \n// i.e., h = 2.0, s = 0.5, base edge = 1.0; or h = 2.0, s = 2.0, base edge = 4.0\n// s MUST BE >= 0.5\n                        \nfloat modPyramid( vec3 p, float h, float s ) \n{\n\tvec3 q = abs( p );\n\tfloat scale = 1.0 / s;\n\treturn max( -p.y, ( q.x * scale + q.y + q.z * scale - h ) / 3.0 );\n}\n\n//------------------------------------------------------------------------------\n// wjb: Joining two modPyramids to form an octahedron with variable base length.\n// scale MUST BE >= 0.5\n\nfloat modOctahedron( vec3 p, float height, float scale )\n{\n\tfloat d1 = modPyramid( p, height, scale );\n\tp.yz = rot( p.yz, PI );\n\tfloat d2 = modPyramid( p, height, scale );\n\treturn min( d1, d2 );\t\t\n}\n//------------------------------------------------------------------------------\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D and 2D Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ------------------------------------------\n    \n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n\n//------------------------------------------------------------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llc3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2078, 2093, 2113, 2113, 3779], [3877, 3918, 3975, 3975, 5510], [5619, 5648, 5705, 5774, 7978], [8080, 8113, 8154, 8154, 8597], [8883, 9145, 9190, 9190, 9509], [9643, 9848, 9906, 9906, 11152], [11286, 11359, 11388, 11503, 11715], [11819, 11844, 12065, 12135, 13111], [13213, 13256, 13317, 13317, 13604], [13805, 13931, 13957, 13957, 14051], [14053, 14210, 14239, 14239, 14350], [14526, 14565, 14586, 14586, 14611], [14613, 14613, 14633, 14633, 14668], [14670, 14814, 14855, 14855, 14976], [15093, 15565, 15616, 15616, 16006], [16008, 16036, 16099, 16099, 16205], [16207, 16281, 16337, 16337, 16379], [16381, 16381, 16413, 16413, 16438], [16440, 16476, 16504, 16504, 16589], [18648, 18671, 18716, 18716, 18828], [18830, 18830, 18877, 18877, 19039]], "test": "error"}
{"id": "llc3Rs", "name": "fn voronoi texture", "author": "KukaTails", "description": "four different version of Fn function used by voronoi texture", "tags": ["voronoi", "noise"], "likes": 4, "viewed": 176, "published": "Public", "date": "1470857043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return -1.0 + 2.0 * fract(sin(h) * 4358.5453);\n}\n\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\n\nfloat Voronoi(vec2 x)\n{\n    ivec2 p = ivec2(floor(x));\n    vec2  f = fract(x);\n\n    float res = 8.0;\n    for(int j = -1; j <= 1; ++j)\n        for(int i = -1; i <= 1; ++i) {\n        ivec2 b = ivec2(i, j);\n        vec2  r = vec2(b) - f + 0.5 + 0.4 * sin(iTime + 6.2831 * Noise(vec2(p + b)));\n        float d = dot(r, r);\n        res = min(res, d);\n    }\n    return sqrt(res);\n}\n\nvec3 VoronoiFn(vec2 x)\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    \n    float f1 = 18.0;\n    float f2 = 18.0;\n    float f3 = 18.0;\n    for (int j = -1; j <= 1; ++ j) {\n        for (int i = -1; i <= 1; ++ i) {\n            ivec2 b = ivec2(i, j);\n            vec2 r = vec2(b) + 0.5 + 0.4 * sin(iTime + 6.2831 * Hash(vec2(p + b))) - f;;\n            float d = dot(r, r);\n            \n            if (d < f1) {\n                f3 = f2;\n                f2 = f1;\n                f1 = d;\n            } else if (d < f2) {\n                f3 = f2;\n                f2 = d;\n            } else if (d < f3) {\n                f3 = d;\n            }\n        }\n    }\n    return vec3(f1, f2, f3);       \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float val = 0.0;\n\n    vec3 f_vec = VoronoiFn(10.0 * uv);\n\n    if (uv.x < 0.0 && uv.y < 0.0) {\n        val = f_vec.x;\n    }\n    if (uv.x < 0.0 && uv.y > 0.0) {\n        val = f_vec.y;\n    }\n    if (uv.x > 0.0 && uv.y < 0.0) {\n        val = f_vec.z + f_vec.x - f_vec.y;\n    }\n    if (uv.x > 0.0 && uv.y > 0.0) {\n        val = f_vec.y - f_vec.x;\n    }\n    \n    fragColor = vec4(sin(val) * sin(val), sin(val), sin(val + 0.2) + 0.05, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llc3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 114], [117, 117, 138, 138, 429], [432, 432, 455, 455, 807], [809, 809, 833, 833, 1510], [1513, 1513, 1569, 1569, 2080]], "test": "valid"}
{"id": "llc3RX", "name": "windy water", "author": "KukaTails", "description": "use turbulent noise to make windy water", "tags": ["turbulentnoise", "windywater"], "likes": 4, "viewed": 258, "published": "Public", "date": "1470503879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return -1.0 + 2.0 * fract(sin(h) * 4358.5453);\n}\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\nvec2 VecNoise(vec2 point)\n{\n    vec2 res;\n    res.x = Noise(point);\n    res.y = Noise(point + 0.33 + iTime);\n    return res;\n}\n\n\nfloat DistortionNoise(vec2 point, float distortion)\n{\n    vec2 offset = point + vec2(0.5);\n    offset = VecNoise(point);\n    offset *= distortion;\n    point += offset;\n    return Noise(point);\n}\n\n\nfloat DistFbmNoise(vec2 p)\n{\n  const float octaves = 8.0;\n  const float lacunarity = 2.0;\n  const float H = 0.5;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += DistortionNoise(p, 1.0) * pow(lacunarity, -H * i);\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder != 0.0) {\n    value += remainder * Noise(p) * pow(lacunarity, -H * k);\n  }\n  return value;\n}\n\n\nfloat FbmNoise(vec2 p)\n{\n  const float octaves = 4.0;\n  const float lacunarity = 2.0;\n  const float H = 0.8;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += Noise(p) * pow(lacunarity, -H * i);\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder != 0.0) {\n    value += remainder * Noise(p) * pow(lacunarity, -H * k);\n  }\n  return value;\n}\n\nfloat Offset(vec3 pos)\n{\n    const float km = 1.0;\n    float offset = km * FbmNoise(pos.xz);\n    return offset;\n}\n\nfloat DistOffset(vec3 pos)\n{\n    const float km = 0.4;\n    float offset = km * DistFbmNoise(pos.xz);\n    return offset;\n}\n\nfloat Turbulence(vec2 uv)\n{\n    const int octaves = 5;\n    float amplitude = 1.0;\n    uv *= 25.0;\n    float f = 0.0;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    for (int i = 0; i < octaves; ++ i) {\n        f += abs(amplitude * Noise(uv));\n        uv = m * uv;\n        amplitude *= 0.5;\n    }\n    return f;\n}\n\nvec3 CalcNormal(vec3 pos)\n{\n    return normalize(cross(dFdx(pos),\n                           dFdy(pos)));\n}\n\n\nvec3 WindyWave(vec3 pos, vec3 normal)\n{\n    const float km = 1.0;\n    const float txt_scale = 1.0;\n    const float wind_freq = 0.1;\n    const float wind_amp = 10.0;\n    const float min_wind = 0.4;\n    \n    pos = txt_scale * wind_freq * pos;\n    float offset = km * FbmNoise(pos.xz);\n    offset = offset * 3.0 - floor(offset);\n    float turb = Turbulence(pos.xz + 0.01 * iTime);\n    float wind = min_wind + wind_amp * turb;\n    return pos + wind * offset * normal;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 pos = vec3(uv.x, 0.0, uv.y);\n\n    float st_offset = DistOffset(pos + iTime);\n    st_offset = st_offset * 4.0 - floor(st_offset);\n    pos = WindyWave(pos, normal);\n    normal = CalcNormal(pos);\n    const vec3 LIGHT_POS = vec3(1.0, 1.0, -0.4);\n    vec3 light_dir = normalize(LIGHT_POS - pos);\n    vec3 diffuse = clamp(dot(normal, light_dir), 0.0, 1.0) * vec3(0.9, 0.9, 0.6);\n    \n\tfragColor = 0.8 * texture(iChannel0, st + st_offset * 0.005) + 0.5 * vec4(diffuse, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llc3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 114], [116, 116, 137, 137, 428], [430, 430, 457, 457, 556], [559, 559, 612, 612, 753], [756, 756, 784, 784, 1186], [1189, 1189, 1213, 1213, 1600], [1602, 1602, 1626, 1626, 1715], [1717, 1717, 1745, 1745, 1838], [1840, 1840, 1867, 1867, 2147], [2149, 2149, 2176, 2176, 2256], [2259, 2259, 2298, 2298, 2729], [2731, 2731, 2788, 2788, 3397]], "test": "error"}
{"id": "llcGDB", "name": "test reflections", "author": "Slyth", "description": "semi accurate reflections, not really fully working. only coding things that I full understand the math behind this go around in order to actually learn some stuff. lighting isn't accurate but it looks neat", "tags": ["raymarching"], "likes": 0, "viewed": 157, "published": "Public", "date": "1471661550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 40.0;\nconst float EPSILON = 0.001;\nconst vec3 sky = vec3(0.0);//0.2, 0.4, 0.7);\n\nfloat FLOOR_COL = 10.0;\nfloat SPHERE_COL = 46.9;// * sin(iTime);\nfloat BOX_COL = 50.2;\n\nfloat obj_sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat obj_box(vec3 pos, vec3 bounds)\n{\n  return length(max(abs(pos) - bounds, 0.0));\n}\n\nfloat obj_floor(vec3 pos)\n{\n    return pos.y + 2.0;// + sin(pos.x / 2.0) * cos(pos.z / 2.0);   \n}\n\nfloat op_rep(vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c) - 0.5 * c;\n    return obj_sphere(q, 1.0);\n}\n\nvec2 obj_union(vec2 obj0, vec2 obj1)\n{\n    if (obj0.x < obj1.x)\n        return obj0;\n    else\n        return obj1;\n}\n\nvec2 distFunc(vec3 pos)\n{\n    vec3 sphereOff = vec3(2.0, 0.0, 0.0);\n    vec2 f = obj_union(vec2(obj_floor(pos), (mod(pos.x, 2.0) * mod(pos.z, 2.0)) > 0.25 ? 200. : 25.),\n                        obj_union(\n                            vec2(op_rep(pos, vec3(4.0, 0.0, 4.0)), SPHERE_COL),\n                            vec2(obj_box(pos + vec3(0.0, -5.0, 0.0), vec3((cos(iTime) + 1.0) * 2.0, 3.0, sin(iTime) + 1.0)), BOX_COL)));\n    \n    return f;\n}\n\nvec2 rayMarch(inout float totalDist, inout vec3 pos, inout float dist, vec3 rayDir)\n{\n    vec2 fin;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            return fin;\n\n        fin = distFunc(pos);\n        dist = fin.x;\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n    return fin;\n}\n\nvec4 reflections(vec3 pos, vec3 last, vec3 normal, const int maxBounces)\n{\n    float rdist = EPSILON;\n    float rtotalDist = 0.0;\n    vec3 rpos = pos + normal * EPSILON;\n    vec3 rRayDir = reflect(last, normal);    \n    vec3 factor = vec3(1.0);\n    \n    for(int i = 0; i <= 3; i++)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            distFunc(rpos + eps.yxx).x - distFunc(rpos - eps.yxx).x,\n            distFunc(rpos + eps.xyx).x - distFunc(rpos - eps.xyx).x,\n            distFunc(rpos + eps.xxy).x - distFunc(rpos - eps.xxy).x));\n        \n        rdist = EPSILON;\n        rtotalDist = 0.0;\n        rpos = pos + normal * EPSILON;\n        \n        vec2 ret = rayMarch(rtotalDist, rpos, rdist, rRayDir);\n        \n        rRayDir = reflect(rRayDir, normal);\n        \n        vec3 col = vec3(0.7, 0.9, 1.0) + rpos.y * 0.8;\n\n        if(rdist < EPSILON)\n        {\n            col = 0.45 + 0.3 * sin(vec3(0.05, 0.08, 0.10) * (ret.y - 1.0));\n            factor *= col;\n        } else\n            break;\n    }\n    \n    return vec4(factor, 1.0);\n}\n\nfloat shadow(inout float totalDist, inout vec3 pos, inout float dist, vec3 rayDir, float k)\n{    \n    float res = 1.0;\n    vec2 fin;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON)\n            return 0.0;\n\n        fin = distFunc(pos);\n        dist = fin.x;\n        totalDist += dist;\n        pos += dist * rayDir;\n        //res = min(res, k * fin.x / float(i));\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy);\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    vec3 cameraOrigin = vec3(sin(iTime * 0.5) * 10.0, 6.0 + sin(iTime * 0.5) * 5.0, cos(iTime * 0.5) * 10.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, -1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDir);\n\n    vec3 lightPos = -rayDir + vec3(cos(iTime * 0.5) * 16.0, 1.0, sin(iTime * 0.2) * 6.0);\n    \n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    \n    vec2 ret = rayMarch(totalDist, pos, dist, rayDir);\n    vec3 col = vec3(0.7, 0.9, 1.0) + pos.y * 0.8;\n    \n    if (dist < EPSILON)\n    {\n        vec4 ambient = vec4(0.12);\n        float intensity = 0.5;\n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            distFunc(pos + eps.yxx).x - distFunc(pos - eps.yxx).x,\n            distFunc(pos + eps.xyx).x - distFunc(pos - eps.xyx).x,\n            distFunc(pos + eps.xxy).x - distFunc(pos - eps.xxy).x));\n        \n        col = 0.45 + 0.3 * sin(vec3(0.05, 0.08, 0.10) * (ret.y - 1.0));\n        vec4 diffuse = vec4(col, 1.0);//vec4(max(0.0, dot(normal, lightPos)) * intensity);\n        \n        vec3 lightDir = normalize(lightPos - pos);\n        float lightIntensity = dot(normal, lightDir);\n        \n        vec4 reflection = (reflections(pos, rayDir, normal, 3));\n        \n        float sdist = EPSILON;\n        float stotalDist = 0.0;\n        vec3 spos = pos + normal * EPSILON;\n        \n        float shad = shadow(stotalDist, spos, sdist, lightDir, 32.0);\n        \n        vec4 fog = vec4(1.0 - (totalDist / MAX_DIST));\n                \n        fragColor = max(vec4(0.05), (((diffuse * (shad) + reflection * 0.2)) * (lightIntensity)) + ambient) * fog;\n    }\n    else\n    {\n        fragColor = vec4(sky, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 218, 260, 260, 295], [297, 297, 335, 335, 383], [385, 385, 412, 412, 482], [484, 484, 514, 514, 580], [582, 582, 620, 620, 698], [700, 700, 725, 725, 1142], [1144, 1144, 1229, 1229, 1497], [1499, 1499, 1573, 1573, 2579], [2581, 2581, 2674, 2674, 2991], [2993, 2993, 3050, 3050, 5104]], "test": "valid"}
{"id": "llcGWS", "name": "Nearest Neighbour Upsampling ", "author": "geoff", "description": "A retro style shader using simulated nearest neighbour upsampling. The shader is the same as one of my previous shaders, with the addition of the line \nuv = floor(uv * RESOLUTION) / RESOLUTION; Change RESOLUTION to modify the simulated resolution.", "tags": ["retro"], "likes": 6, "viewed": 749, "published": "Public API", "date": "1471192424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AO\n#define SHADOWS\n#define RESOLUTION 150.0\n//#define VIDEO\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat closeObj = 0.0;\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = p;\n    p = vec3(mod(p.x, 5.0) - 2.5, p.y, mod(p.z, 5.0) - 2.5);\n    p -= vec3(0.0, 0.0, 0.0);\n    float qpi = 3.141592 / 4.0;\n    float sub = 10000.0;\n    for(float i = 0.0; i < 8.0; i++){\n        float x = 0.2 * cos(i * qpi);\n        float z = 0.2 * sin(i * qpi);\n        vec3 transp = p - vec3(x, 0.0, z);\n        vec3 a = vec3(x, 1.2, z);\n        vec3 b = vec3(x, -1.2, z);\n        sub = min(sub, capsule(transp, a, b, 0.1));\n    }\n    float ttorus = torus(p - vec3(0.0, -1.5, 0.0), vec2(0.22));\n    float btorus = torus(p - vec3(0.0, 1.5, 0.0), vec2(0.22));\n    float u = min(btorus, ttorus);\n    vec2 column = vec2(min(u, max(-sub, length(p.xz) - 0.35)), 2.0);\n    vec2 flo = vec2(q.y + 1.5, 1.0);\n    vec2 roof = vec2(-q.y + 1.5, 1.0);\n    return vecMin(column, vecMin(flo, roof));\n}\n\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    float d = 0.0;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 1000; i++){\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        if(d < 0.0001){\n            inter = 1;\n            break;\n        }\n        t += d;\n        if(t > 30.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        t = -1.0;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0, 1.0, 0.0);\nvec3 lightPos = vec3(0.0, 1.0, -1.0);\n\nvec3 amb(vec3 c, float k){\n    return c * k;\n}\n\nvec3 diff(vec3 c, float k, vec3 p){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    return c * k * max(0.0, dot(n, l));\n}\n\nvec3 spec(vec3 c, float k, vec3 p, float a){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(p - camPos);\n    float facing = dot(l, n) > 0.0 ? 1.0 : 0.0;\n    vec3 r = reflect(l, n);\n    return c * k * facing * pow(max(0.0, dot(r, v)), a);\n}\n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.4;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 1000; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 25; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(2.0 * occ, 0.0, 1.0);\n}\n\nfloat s = 1.0;\nfloat ao = 1.0;\n\nvec3 colour(vec3 p, float id){\n    \n    #ifdef SHADOWS\n    float s = shadow(p, normalize(lightPos - p));\n    #endif\n    \n    #ifdef AO\n    float ao = occlusion(p, normal(p));\n    #endif\n    \n    if(id == 1.0){\n        vec3 col;\n        vec2 t = mod(floor(p.xz), 2.0);\n        if(t == vec2(0.0) || t == vec2(1.0)){\n            col = vec3(0.2);\n        }else{\n            col = vec3(0.8);\n        }\n        //floor(s) is 1.0 only when the point is completely unshadowed - removes specular highlight from shadowed areas\n        return amb(col, 0.5) * ao + diff(col, 0.9, p) + floor(s) * spec(vec3(1.0), 0.3, p, 4.0) - vec3(0.4 - 0.4 * s);;\n    }else if(id == 2.0){\n    \tvec3 col = vec3(0.929412, 0.882353, 0.788235);\n    \treturn amb(col, 0.5) * ao + diff(col, 0.9, p) + floor(s) * spec(vec3(1.0), 0.3, p, 4.0) - vec3(0.4 - 0.4 * s);\n    }\n    return vec3(0.0, 1.0, 0.0);\n} \n\nfloat lastx = 0.0;\nfloat lasty = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //SIMULATED UPSAMPLING\n    uv = floor(uv * RESOLUTION) / RESOLUTION;\n    \n    vec3 col = vec3(1.0);\n    \n    #ifndef VIDEO\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 0.0, 0.0);\n    lightPos = vec3(0.0, 0.0, 10.0 * sin(iTime/ 2.0));\n    lastx += iMouse.x - 0.5;\n    lasty += iMouse.y - 0.5;\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotY(radians(lastx)) * rotX(radians(lasty)) * vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    \n    //If intersected\n    if(d > 0.0){\n    \tcol = colour(c, closeObj);\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n    #endif\n    \n    #ifdef VIDEO\n    col = texture(iChannel0, uv).xyz;\n    #endif\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 69, 88, 88, 229], [231, 231, 250, 250, 391], [416, 416, 463, 463, 601], [603, 603, 632, 632, 702], [704, 704, 732, 732, 792], [794, 794, 814, 814, 1617], [1619, 1619, 1637, 1637, 1663], [1665, 1665, 1695, 1695, 2078], [2080, 2080, 2100, 2100, 2376], [2452, 2452, 2478, 2478, 2498], [2500, 2500, 2535, 2535, 2639], [2641, 2641, 2685, 2685, 2918], [2920, 2920, 2951, 2951, 3307], [3309, 3309, 3343, 3343, 3592], [3626, 3626, 3656, 3656, 4495], [4537, 4537, 4593, 4593, 5412]], "test": "valid"}
{"id": "lld3DS", "name": "egg Cartesian Oval ellipse", "author": "ollj", "description": "3 different functions for egg shapes;\ndEllipseW()==Cartesian Oval\nlinnEllipseDistortB() is fast and cubic\nSinEgg1() oscillates sinusoidial", "tags": ["eggcartesianovalellipse"], "likes": 4, "viewed": 870, "published": "Public API", "date": "1471400724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//3 egg shaped functions:\n//top   ) sinusoidial egg\n//center) Cartesian-Oval/ellipse egg \n//bottom) distorded-ellipse egg\n\n//egg shapes have many approaches.\n//a lot of more general functions or sums have some egg-shaped ranges.\n//and \"egg shape\" is not too prelcisely defined in mathematic.\n//they only agree that eggs are like distorted ellipses..\n//evolutionary important is that eggs are rotated elipses, deformed to be more conic.\n//this prevents eggs to roll too far away while having a good volume/surface ratio.\n\n//via mathematische-basteleien.de ... \"Ovals_and_Egg_Curves.htm\"\n//by @ollj\n\n//uncomment to make [b.z] oscillate over time:\n//#define oscillate\n\nfloat dCircle(vec2 p,float r){return length(p)-r;}\nfloat dEllipse(vec2 p,vec2 a,vec2 b,float r){\n return length(p-a)+length(p-b)-r;}\n//ellipses are that easy per fragment\n//i dont know why so many others use trig functions like sin and atan for this...\n//for complex number space?\n//to make line thickness constant??\n\n//weighted ellipse -> \"Cartesian Oval\" //.z=weight factor\nfloat dEllipseW(vec2 p,vec3 a,vec3 b,float r){\n return length(p-a.xy)*a.z+length(p-b.xy)*b.z-r;}\n\n//linear ellypse distortions:\n\n//fast cubic function that returns some egg-shapes for some [a]\nfloat linnEllipseDistortB(float x){float a=-.3;\n return sqrt(1.-x*x*(1.+a*x));}\n//y*y((1+a*x)=1-x*x;\n\n//sinisoid egg curve 1\nfloat SinEgg1(float x){float a=6.5;\n return sqrt(abs(sin(x)+.1*sin(x+x)));}\n\nvoid mainImage( out vec4 r, in vec2 i){\n vec2 p=i/min(iResolution.x,iResolution.y);// position on the screen\n p-=vec2(iResolution.x/iResolution.y-.9,.5);\n //above coordinate transform makes circles round, independend trom aspect ratio.\n //and it makes sure that (0.0) is centred near the top left screenspace quadrant)\n p*=1.7;//zoom out\n r.rgb=vec3(p,.5+.5*sin(iTime));//tests if it runs\n#ifdef oscillate\n float s=sin(iTime*.2);\n#else\n float s=0.;\n#endif\n vec3 a=vec3( .5,.0,1.);   //1 of 2 points that define the carthesian oval/ellipse\n vec3 b=vec3(-.5,.0,0.5+s);//2 of 2 points that define the carthesian oval/ellipse\n //float de=dEllipse(p,a.xy,b.xy,.5);//non-weighted\n float de=dEllipseW(p,a,b,.5);\n r.rg=1.-vec2(de);\n float e=.007;//shell thickness\n float size=.4;//black shell shape distance.\n if(de<size+e&&de>size-e)r.xyz=vec3(0.3);\n //egg-shell shape\n de=sin(de*29.);\n if(de<.5&&de>-.5)r.r=1.-r.r;\n //end of code that paints most of the screen space in colors.\n \n //bottom black half-egg shape uses linnEllipseDistortB()\n //a fast cubic function.\n float ledb=linnEllipseDistortB(p.x*2.)*.5;\n float pp=length(p-vec2(p.x,ledb));\n if(pp>1.)r.rgb*=.25;\n    \n //top black half eggs use SinEgg1()\n //sin() has its advantages\n float sie1=-SinEgg1(p.x*5.)*.5;\n float pq=length(p-vec2(p.x,sie1));\n if(pq>1.)r.rgb*=.25;\n    \n //white circle and plus_sign marks coordinate systems (0,0) coodinates and stretching\n if(dCircle(p,.5)<-.1)r.rgb+=vec3(.25);\n if(p.x>-.005&&p.x<.005)r.rgb+=vec3(.25);\n if(p.y>-.005&&p.y<.005)r.rgb+=vec3(.25);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lld3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[598, 666, 696, 696, 716], [717, 717, 762, 762, 798], [984, 1042, 1088, 1088, 1138], [1171, 1235, 1270, 1270, 1314], [1337, 1360, 1383, 1383, 1435], [1437, 1437, 1476, 1476, 2975]], "test": "valid"}
{"id": "lldGW4", "name": "4 Dimensional Kleinian Group", "author": "soma_arc", "description": "More complex kissing schottky groups. It is a 4 dimensional Kleinian group.", "tags": ["3d", "fractal", "schottkygroup"], "likes": 11, "viewed": 196, "published": "Public", "date": "1470802446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\nvec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));\nvec3 rotate(vec3 p, float angle){\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,\n                ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,\n                ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,\n                ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,\n                ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,\n                ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,\n                ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,\n                ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,\n                ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);\n  return m * p;\n}\n\nconst vec3 SPHERE_POS1 = vec3(300, 300, 0);\nconst vec3 SPHERE_POS2 = vec3(300, -300, 0);\nconst vec3 SPHERE_POS3 = vec3(-300, 300, 0);\nconst vec3 SPHERE_POS4 = vec3(-300, -300, 0);\nconst vec3 SPHERE_POS5 = vec3(300. + 300. * sqrt(3.), 0, 0);\nconst vec3 SPHERE_POS6 = vec3(-300. - 300. * sqrt(3.), 0, 0);\nconst vec3 SPHERE_POS7 = vec3(0, 0, 424.26);\nconst vec3 SPHERE_POS8 = vec3(0, 0, -424.26);\nconst float SPHERE_R = 300.;\nconst float SPHERE_R2 = SPHERE_R * SPHERE_R;\n\nvec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){\n  return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;\n}\n\nfloat loopNum = 0.;\nfloat kleinSphereR = 125.;\n//float kleinSphereR = 300.;\n//float kleinSphereR = 400.;\nconst int MAX_KLEIN_ITARATION = 50;\nfloat distKlein(vec3 pos){\n  pos = rotate(pos, radians(iTime * 30.));\n  float scalingFactor= .08;\n  loopNum = 0.;\n  float dr = 1.;\n  bool loopEnd = true;\n  for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n    loopEnd = true;\n    if(distance(pos, SPHERE_POS1) < SPHERE_R){\n      vec3 diff = (pos - SPHERE_POS1);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS2) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS2);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS3) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS3);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS4) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS4);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS5) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS5);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS6) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS6);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS7) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS7);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS7, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS8) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS8);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS8, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }\n    if(loopEnd == true) break;\n  }\n  float f = (length(pos - (SPHERE_POS1 + SPHERE_POS2 + SPHERE_POS5)/3. ) - 50.) / abs(dr) * scalingFactor;\n  float f2 = (length(pos - (SPHERE_POS3 + SPHERE_POS4 + SPHERE_POS6)/3. ) - 50.) / abs(dr) * scalingFactor;\n\n    return min(f2, min(f, (length(pos) - kleinSphereR) / abs(dr) * scalingFactor));\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distFunc(vec3 p){\n  return distKlein(p);\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n  return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                        distFunc(p + d.yxy) - distFunc(p - d.yxy),\n                        distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.1);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  vec3 v = lightPos - p;\n  float dot = dot(n, normalize(v));\n  float r = length(v);\n  return (dot > 0.) ?\n    (lightPower * (dot / (PI_4 * r * r))) * diffuseColor\n    : LIGHTING_FACT * diffuseColor;\n}\n\nconst vec3 lightPos = vec3(400, 0, 500);\nconst vec3 lightPos2 = vec3(-300., -300., -300);\nconst vec3 lightPower = vec3(800000.);\nconst vec3 lightPoweSPHERE_R2 = vec3(10000.);\n\nconst int MAX_MARCHING_LOOP = 800;\nvec2 march(const vec3 origin, const  vec3 ray, const float threshold){\n  vec3 rayPos = origin;\n  float dist;\n  float rayLength = 0.;\n  for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n    dist = distFunc(rayPos);\n    rayLength += dist;\n    rayPos = origin + ray * rayLength ;\n    if(dist < threshold) break;\n  }\n  return vec2(dist, rayLength);\n}\n\nconst vec3 BLACK = vec3(0);\nvec3 calcColor(vec3 eye, vec3 ray){\n  vec3 l = BLACK;\n  float coeff = 1.;\n  vec2 result = march(eye, ray, 0.01);\n  vec3 intersection = eye + ray * result.y;\n  vec3 matColor = vec3(0);\n  vec3 normal = getNormal(intersection);\n  if(result.x < 0.01){\n    matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));\n    l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n    l += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower);\n  }\n  return l;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 eye = vec3(300 , 0., 700 );\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  const vec2 coordOffset = vec2(0.5);\n  vec3 ray = calcRay(eye, target, up, fov,\n                     iResolution.x, iResolution.y,\n                     gl_FragCoord.xy + coordOffset);\n\n  fragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldGW4.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[0, 182, 215, 215, 942], [1413, 1413, 1472, 1472, 1591], [1640, 1734, 1760, 1760, 4103], [4105, 4105, 4257, 4257, 4617], [4668, 4668, 4695, 4695, 4809], [4811, 4811, 4834, 4834, 4859], [4892, 4892, 4921, 4921, 5126], [5196, 5196, 5335, 5335, 5536], [5749, 5749, 5819, 5819, 6091], [6121, 6121, 6156, 6156, 6607], [6653, 6653, 6682, 6682, 6859], [6993, 6993, 7049, 7049, 7296]], "test": "error"}
{"id": "lldGzX", "name": "volumetric light of point light", "author": "KukaTails", "description": "first volumetric light demo", "tags": ["volumetric"], "likes": 2, "viewed": 175, "published": "Public", "date": "1470682640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 sphere = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec3 light_pos = vec3(-2.0, 2.0, -0.2);\n\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n     \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat Turbulence(vec3 p)\n{\n  const float octaves = 4.0;\n  const float lacunarity = 2.0;\n  const float H = 0.5;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += abs(noise(p) * pow(lacunarity, -H * i));\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder != 0.0) {\n    value += abs(remainder * noise(p) * pow(lacunarity, -H * k));\n  }\n  return value;\n}\n\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    // add animation\n    p = p - vec3(1.0, 1.0, 0.0) * iTime * 0.1;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    \n    return f;\n}\n\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat density(vec3 pos, vec3 light_pos, float dot_value)\n{\n    float dist = length(light_pos - pos);\n    float den = 7.0 * fractal_noise(100.0 * pos) - dist * 0.6;\n    den = clamp(den, 0.0, 1.0);\n    \n    return 1.0 * den * exp(-3.2 * dot_value) * exp(-(2.0 * (light_pos.y - pos.y))) ;\n}\n\nvec3 GetColor(vec3 pos, vec3 light_pos, float density, float dot_value)\n{\n    const vec3 light_color = vec3(0.0, 0.0, 1.0);\n    float dis = length(pos - light_pos);\n    float max_dis = length(light_pos) + 6.0;\n    float scale = 1.0 - sin(dis / max_dis);\n    float dot_value_scale = dot_value * 1000.0 - 850.0;\n    float f = scale * density * dot_value_scale;\n    return mix(vec3(sin(iTime), 0.0, cos(iTime)), light_color, f);// * light_color;\n}\n\n\nvec3 GetSkyColor(vec3 pos)\n{\n    return vec3(0.0, 0.4, 0.6);\n}\n\nvec3 raymarching(vec3 ro, vec3 rd)\n{\n    vec4 sum = vec4(0.0);\n    float t = 0.0;\n    vec3 pos = ro + rd * t;\n    bool in_cone = false;\n    for (int i = 0; i < 1000; i++) {\n        if (sum.a > 0.99)\n            break;\n        \n        \n        /* cone light */\n\n        vec3 light_dir = normalize(vec3(-0.8, 1.0, 0.0));\n        vec3 offset = vec3(0.2 * sin(iTime), 0.0, 0.2 * cos(iTime));\n        //light_dir += offset;\n        vec3 eye_dir = normalize(pos - light_pos);\n        float dot_value = dot(-light_dir, eye_dir);\n        \n        vec4 color = vec4(0.0);\n        if (dot_value > 0.90) {\n            if (pos.y < -0.0) {\n                float square_id = mod(floor(4.0 * pos.x) + floor(4.0 * pos.z), 2.0);\n                color = vec4(0.4 + 0.1 * square_id * vec3(1.0), 1.0);\n            } else {\n                in_cone = true;\n                float den = density(pos, light_pos, dot_value);\n                color = vec4(GetColor(pos, light_pos, den, dot_value), den);\n            }\n            color.rgb *= color.a;\n        \tsum = sum + color*(1.0 - sum.a);\n        }\n        t += 0.01;\n        pos = ro + rd * t;\n    }\n    \n    \n    if (sum.a < 0.1) {\n        return vec3(0.0);\n    }\n    \n    \n    vec3 col = clamp(sum.xyz, 0.0, 1.0);\n    return mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    vec3 ro = vec3(0.0, 1.1, -1.5);\n\n    float r = 0.2;\n    float theta = mod(0.1 * iTime, 2.0) * 3.1412925;\n    vec3 offset = vec3(sin(theta), 0.0, cos(theta));\n    ro = vec3(light_pos.x, light_pos.y - 1.0, light_pos.z) + offset;\n    vec3 rd = setCamera(ro, vec3(0.0, 1.0, 0.0), 0.0) * normalize(vec3(p.xy, 2.0));\n    vec3 col = raymarching(ro, rd);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 113, 113, 350], [352, 352, 378, 378, 775], [777, 777, 806, 806, 1119], [1121, 1121, 1171, 1171, 1363], [1365, 1365, 1423, 1423, 1652], [1654, 1654, 1727, 1727, 2098], [2101, 2101, 2129, 2129, 2163], [2165, 2165, 2201, 2201, 3476], [3478, 3478, 3522, 3522, 3699], [3701, 3701, 3758, 3758, 4214]], "test": "error"}
{"id": "llt3Ws", "name": "PerlinLava", "author": "10098", "description": "practicing perlin noise", "tags": ["noise", "perlin"], "likes": 1, "viewed": 179, "published": "Public", "date": "1472546198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 gradient_at(vec3 lattice_point) {\n\tfloat u = (lattice_point.x + lattice_point.z) / 256.0;\n    float v = (lattice_point.y - lattice_point.z) / 256.0;\n    return normalize(vec3(2.0) * (texture(iChannel0, vec2(float(u), float(v))).rgb - vec3(0.5)));\n}\n\nfloat gradient_dot_dir(vec3 lattice_point, vec3 p) {\n\treturn dot(gradient_at(lattice_point), p - lattice_point);\n}\n\nfloat lerp(float a, float b, float t) {\n\treturn (1.0-t) * a + t * b;\n}\n\nfloat fade(float t) {\n\treturn t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n}\n\nvec3 fade(vec3 p) {\n\treturn vec3(fade(p.x), fade(p.y), fade(p.z));\n}\n\nfloat noise(vec3 p) {\n    vec3 p0 = floor(p);\n\tvec3 p1 = p0 + vec3(1.0);\n    vec3 pw = fade(p - p0);\n\n    float x1, x2, y1, y2;\n\n    x1 = lerp(gradient_dot_dir(vec3(p0.x, p0.y, p0.z), p),\n              gradient_dot_dir(vec3(p1.x, p0.y, p0.z), p),\n              pw.x);\n    x2 = lerp(gradient_dot_dir(vec3(p0.x, p1.y, p0.z), p),\n              gradient_dot_dir(vec3(p1.x, p1.y, p0.z), p),\n              pw.x);\n    y1 = lerp(x1, x2, pw.y);\n    x1 = lerp(gradient_dot_dir(vec3(p0.x, p0.y, p1.z), p),\n              gradient_dot_dir(vec3(p1.x, p0.y, p1.z), p),\n              pw.x);\n    x2 = lerp(gradient_dot_dir(vec3(p0.x, p1.y, p1.z), p),\n              gradient_dot_dir(vec3(p1.x, p1.y, p1.z), p),\n              pw.x);\n    y2 = lerp(x1, x2, pw.y);\n              \n\treturn lerp(y1, y2, pw.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 coord = vec3(fragCoord.x, fragCoord.y, iTime * 4.0);\n    float v = noise(coord / 64.0) + 0.25 * noise(coord/32.0) + 0.1*noise(coord/16.0); \n\tv = 0.5 * (v + 1.0);\n    vec3 color;\n    if (v > 0.7) {\n    \tcolor = vec3(v, v/1.3, 0.0); \n    } else if (v > 0.6) {\n        color = vec3(v, v/2.0, 0.0);\n    } else if (v > 0.5) {\n        color = vec3(v, v/4.0, 0.0);\n    } else {\n    \tcolor = vec3(v, 0, 0);\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llt3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 253], [255, 255, 307, 307, 369], [371, 371, 410, 410, 441], [443, 443, 464, 464, 507], [509, 509, 528, 528, 577], [579, 579, 600, 600, 1366], [1368, 1368, 1425, 1425, 1875]], "test": "error"}
{"id": "llt3zj", "name": "Dot Line", "author": "EanJee", "description": "2D composition practice", "tags": ["2d", "minimal", "dot", "point", "composition"], "likes": 8, "viewed": 649, "published": "Public API", "date": "1470376736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\nconst float TWO_PI = PI * 2.0;\nconst float REPEAT = 32.0;\nconst float FREQUENCY = 2.5;\nconst float AMPLITUDE = 0.08;\nconst float RADIUS = 0.45;\nconst float BLUR = 0.1;\n\nvec3 drawCircleFill(vec2 resolution, vec2 st, vec2 center, float radius, float blur)\n{\n    vec2 aspect = resolution / min(resolution.x, resolution.y);\n    return vec3(smoothstep(radius - blur, radius, length((st - center) * aspect)));\n}\n\n// vec2(1, 0): landscape\n// vec2(0, 1): portrait\nvec2 getOrientation(vec2 resolution)\n{\n    float widthLonger = step(resolution.y, resolution.x);\n    return vec2(widthLonger, 1.0 - widthLonger);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // tile on the longer side of screen\n    vec2 repeat = getOrientation(iResolution.xy) * (REPEAT - 1.0) + 1.0;\n    vec2 st = fract(uv * repeat);\n\n    // get slice info\n    vec2 sliceResolution = iResolution.xy / repeat;\n    vec2 sliceOrientation = getOrientation(sliceResolution);\n\n    // oscillate from the center of each slice\n    vec2 sliceIndex = floor(uv * repeat);\n    float phase = max(sliceIndex.x, sliceIndex.y) * TWO_PI / REPEAT;\n    float offsetValue = sin(iTime * FREQUENCY + phase);\n\n    vec2 pos = getOrientation(sliceOrientation) * AMPLITUDE * offsetValue + 0.5;\n    float radius = RADIUS * (offsetValue * 0.5 + 0.5);\n\n    // draw cicles\n    fragColor = vec4(drawCircleFill(sliceResolution, st, pos, radius, BLUR), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llt3zj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 281, 281, 431], [433, 482, 520, 520, 629], [631, 631, 688, 688, 1472]], "test": "valid"}
{"id": "lltGzB", "name": "soft silver spiral stack", "author": "main", "description": "spiral porn for a mate. now with rings! makes silvery colours that go round and round\nput on some relaxing music, fullscreen it, and empty your mind of all else\n\n40 second cycle time on the animation btw\n\n\nfeedback pls? :3", "tags": ["2d", "commented", "relaxing", "slow", "greyscale", "spirals", "hypnoporn", "koru", "silvery"], "likes": 6, "viewed": 1140, "published": "Public API", "date": "1470127757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141592653589793;\n\nfloat spiralpiece (vec2 uv, float rotate) { \n    \n    // take polar coords \n    vec2 polar = vec2(length(uv - vec2(0.0)),\n                      atan(uv.y, uv.x) + rotate*pi);\n    \n    // log spiral is e^(2*pi*theta), thanks wikipedia\n    // this makes a spiral boundrary, abs and subtract from 1 for spiral line pieces\n    // with MAGIC constants for nicer 'colors'. ok nicer greyscale, whatever. \n    return 1.0 - clamp(abs(mod(polar.y, pi*2.0) - (3.0 * log(polar.x))), 0.0, 1.1);\n}\n\n// stack spiralpieces line segments 4 times over.\n// TODO: spirals not perfect, can see boundraries between pieces\n// MAGIC: why 8.1? because it looks better than 8.0 >_< \n// probably 'should be' some multiple of pi or something else stupid like that\nvec4 spiral (vec2 uv, float rotate, vec3 color) {\n\treturn clamp(vec4(spiralpiece(uv*1.000, rotate) \n                    + spiralpiece(uv*8.12, rotate) \n                    + spiralpiece(uv*66.0, rotate)\n                    + spiralpiece(uv*536.0, rotate)),\n                 0.0, 1.0) * vec4(color, 0.0);\n}\n\n// rings... distance to center, take mod to repeat, subtract and abs to make symmetrical. \n// then pow for less blur / thinner pieces, and weirder silvery overlaps. \nfloat ring (vec2 p, float offset) {\n    // MAGIC WITH EXTRA MAGIC ON TOP HOLY SHIT\n    // color   v1    |    ringsize (*will* break it)    v2, 1/2*v1 v3 | color v4\n    return pow(2.42*abs(mod(offset-length(vec2(0.0)-p), 0.75) -0.375) + 0.1, 5.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    /// resolution indepentant coords with 0,0 in the center\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5);\n    float aspect = iResolution.x / iResolution.y; // aspect ratio\n\tuv.y = uv.y / aspect; // same scale for x and y axis -- aspect ratio correction\n    \n    /// animate shit\n    // camera scale/animation\n    uv = uv * vec2(3.0 + 0.5* /*distance*/sin(iTime*0.5/*time*/));\n    // rotation animation\n\tfloat rotate = /*-*/iTime; // uncomment for inwards spiral...\n    // ring animation\n    float ringoffset = iTime * 0.375;\n    \n    /// more objects\n    // soft silvery ring-emphasis, center of screen. does this one actually do anything?\n    vec4 ring1 = clamp(vec4(1.0 - abs(1.4*length(uv - vec2(0.0)) -1.0)), -1.0, 1.0);\n    // same again, edge of screen\n    vec4 ring2 = clamp(vec4(1.0 - abs(0.5*pow(length(uv - vec2(0.0)), 2.0) -1.0)), -1.0, 1.0);\n    // central spot\n    vec4 spot = smoothstep(0.3, 0.6,clamp(vec4(1.0 - 110.0*length(uv - vec2(0.0))), 0.0, 1.0));\n    \n    // combine parts by adding... goes weird-in-a-good-way when they overlap \n    // yeah, this is why I clamp my spirals :P\n    // TODO: should probably be a loop of some kind I guess\n    vec4 sumc = vec4(spiral(uv, rotate*1.00, vec3(0.22))\n                   + spiral(uv, rotate*0.95, vec3(0.22))\n                   + spiral(uv, rotate*0.90, vec3(0.22))\n                   + spiral(uv, rotate*0.85, vec3(0.22))\n                   + spiral(uv, rotate*0.80, vec3(0.22))\n                   + spiral(uv, rotate*0.75, vec3(0.22))\n                   + spiral(uv, rotate*0.70, vec3(0.22))\n                   + spiral(uv, rotate*0.65, vec3(0.22))\n                   + 0.132* ring(uv, 0.05*ringoffset)\n                   + 0.132* ring(uv, 0.10*ringoffset)\n                   + 0.132* ring(uv, 0.15*ringoffset)\n                   + 0.132* ring(uv, 0.20*ringoffset)\n                   + 0.132* ring(uv, 0.25*ringoffset)\n                   + 0.132* ring(uv, 0.30*ringoffset)\n                   + 0.132* ring(uv, 0.35*ringoffset)\n                   + 0.132* ring(uv, 0.40*ringoffset)\n                   + ring1 * 0.08 // might be too dim to have much of an effect :/\n                   + ring2 * 0.15\n                   // MAGIC. FUCKING MAGIC.\n                   + 0.32 * smoothstep(0.05, 0.6, abs(1.0 - length(uv - vec2(0.0)+0.1 *1.0)))\n                   + spot * 0.6\n                   );\n    \n    // 'tone mapping' lol\n    fragColor = pow(sumc, vec4(1.2)) - vec4(0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 80, 112, 520], [522, 773, 822, 822, 1078], [1080, 1246, 1281, 1409, 1494], [1496, 1496, 1553, 1619, 4007]], "test": "valid"}
{"id": "lt33Rf", "name": "Blitter object", "author": "gigatron", "description": "Amiga demo with blitter object, bob  code from glslsandbox", "tags": ["oldschool", "amiga", "object", "blitter"], "likes": 3, "viewed": 150, "published": "Public", "date": "1470519463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// gigatron (Ronan) France .. bob code from glslsandbox !\n \n\nvec3 bob(vec2 p, vec2 t, float r, float i) {\n\tif (length(t-p) < r) {\n\t\treturn vec3(0.1, 0.4, length(p*sqrt(p*p)));\n\t}\n\treturn vec3(0.0);\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv= fragCoord.xy / iResolution.xy*2.-1.;\n    vec3 tx=texture(iChannel0,uv).xyz;\n    \n    uv =1.-uv*abs(sin(iTime))*4.;// t2 screen bounce\n    \n    vec3 tx2=texture(iChannel2,uv).xyz;\n\tvec2 p= fragCoord.xy / iResolution.xy;\n  \tfloat time=iTime*0.4;\n   \tfloat rnd=40.+floor(fract(time*time));// try to genereate random floor number !\n   \n\tfloat a = 1.8;\n\tp.x = p.x*a;\n    \n\tvec3 col = vec3(0.0);\n     \n    tx2.r = rnd+10.+tx2.b+sin(fract(iTime*2.)+uv.x/uv.y)*sin(iTime+tx2.g);\n   \n    \n        float x, y, aa = 5.+time, b = 9.+time*0.8, ite = 20. ;\n    \n        for (float j = 0. ; j < 100. ; j++) {\n                x =  0.8 * sin(aa * (ite / 7. + j / 40.)),\n                y =  0.4 * sin(b * (ite / 7. + j / 40.));\n              \n  \n         col += vec3(bob(p, vec2(0.9+x, 0.5 + y), j/1000., j));            \n  \n              }\n      \n    \n    \n    \n    \n    \n   // (tx2.r>0.5) ? tx2.r=1.0: tx2.b=1.0;// i lowe this ternary conditions :)\n    \n    \n\tfragColor = vec4(vec3(col)/tx2, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4sjGzh", "previewfilepath": "https://soundcloud.com/la_tarte_aux_concombres/whistlingfred-by-mr-urk-of", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/la_tarte_aux_concombres/whistlingfred-by-mr-urk-of", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt33Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 105, 105, 199], [203, 203, 260, 260, 1258]], "test": "error"}
{"id": "lt33Rj", "name": "Mosquito Coil", "author": "Sobaya", "description": "Japanese Mosquito Coil.", "tags": ["3ddistancefield"], "likes": 5, "viewed": 204, "published": "Public", "date": "1470224787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float fov = 0.2;\nconst float eps = 0.001;\nconst float pi = 3.1415926535;\n\nfloat rand(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 114514.1919810))) * 43758.5453);\n}\n\nfloat interpolate(float x, float y, float t) {\n  t = t * t * (3. - 2. * t);\n  return x * (1.-t) + y * t;\n}\n\nfloat irand(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  float rand1 = rand(i);\n  float rand2 = rand(i+vec3(1,0,0));\n  float rand3 = rand(i+vec3(0,0,1));\n  float rand4 = rand(i+vec3(1,0,1));\n  float rand5 = rand(i+vec3(0,1,0));\n  float rand6 = rand(i+vec3(1,1,0));\n  float rand7 = rand(i+vec3(0,1,1));\n  float rand8 = rand(i+vec3(1,1,1));\n  float t1 = interpolate(rand1, rand2, f.x);\n  float t2 = interpolate(rand3, rand4, f.x);\n  float t3 = interpolate(rand5, rand6, f.x);\n  float t4 = interpolate(rand7, rand8, f.x);\n  float s1 = interpolate(t1, t2, f.z);\n  float s2 = interpolate(t3, t4, f.z);\n  return interpolate(s1, s2, f.y);\n}\n\nfloat noise(vec3 p) {\n  float t = 0.;\n  for (int i = 0; i < 8; i++) {\n    float freq = pow(2., float(i));\n    float amp = pow(0.5, float(8-i));\n    t += irand(p / freq) * amp;\n  }\n  return t;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat length8(vec2 p) {\n  float x = 1., y = 1.;\n  for (int i = 0; i < 8; i++) {\n    x *= p.x;\n    y *= p.y;\n  }\n  return pow(x + y, 1.0 / 8.);\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 rotate(vec3 p, vec3 n, float a) {\n  a *= pi / 180.;\n  float c = cos(a);\n  float s = -sin(a);\n   mat3 m = mat3(\n       n.x*n.x*(1.-c)+c, n.x*n.y*(1.-c)+n.z*s, n.x*n.z*(1.-c)-n.y*s,\n       n.y*n.x*(1.-c)-n.z*s, n.y*n.y*(1.-c)+c, n.y*n.z*(1.-c)+n.x*s,\n       n.z*n.x*(1.-c)+n.y*s, n.z*n.y*(1.-c)-n.x*s, n.z*n.z*(1.-c)+c\n       );\n   return m * p;\n}\n\nvec3 scale(vec3 p, vec3 s) {\n  return p / s;\n}\n\nvec3 fireEnd(float t) {\n  float n = floor((20. - t * 0.01) / (2. * pi));\n  float angle = 20. - t * 0.01 - n * 2. * pi;\n  float len = angle * 0.48 + 3. * n + 1.;\n  return vec3(sin(angle) * len, 0, cos(angle) * len);\n}\n\nfloat fire(vec3 p) {\n  p = translate(p, fireEnd(iTime) + vec3(0,5,0));\n  p = scale(p, vec3(2,8,2)*4.);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - 1.;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat body(vec3 p) {\n  p = translate(p, vec3(0.4,3,0));\n  float sub = p.y + 0.0;\n  float len = length(p.xz);\n  float angle = atan(p.x, p.z);\n  if (angle < 0.) angle += 2. * pi;\n  if (angle > 2. * pi) angle -= 2. * pi;\n  float n = floor((len - angle * 0.48+1.) / 3. - 0.2);\n  float t = angle + n * 2. * pi;\n  if (t > 20. - iTime * 0.01) return 1.;\n  vec2 q = vec2(mod(len - angle * 0.48, 3.)-1., p.y);\n  float result = length8(q) - 0.5;\n  result = max(result, sub);\n//  if (abs(result) < eps * 3)\n    result -= noise(p * 300.) * 0.1;\n  return result;\n}\n\nfloat distSaucer(vec3 p) {\n  p = translate(p,vec3(0,-3,0));\n  vec2 q = abs(vec2(length(p.zx), p.y / 20.)) - 0.3;\n  float bar = min(max(q.x,q.y),0.) + length(max(q,0.));\n  q = vec2(length(p.xz) - 10., p.y + 1.0);\n  float torus = length(q) - 0.2;\n  float bottom2 = max(max(-p.y-3.9, p.y + 3.5), length(p-vec3(0,-2,0)) - 10.);\n  p = translate(p, vec3(0,-1,0));\n  p = scale(p, vec3(1,30,1));\n  q = vec2(length(p.xz) - 10., p.y);\n  float result = length8(q) - 0.1;\n  result = min(result, bottom2);\n  result = min(result, torus);\n  result = min(result, bar);\n  return result;\n}\n\nfloat dist(vec3 p) {\n  return min(body(p), distSaucer(p));\n}\n\nint getNearestIndex(vec3 p) {\n  float minDist = body(p);\n  int idx = 0;\n  float d = distSaucer(p);\n  if (d < minDist) {\n    minDist = d;\n    idx = 1;\n  }\n  return idx;\n}\n\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n        dist(p+vec3(eps,0,0)) - dist(p),\n        dist(p+vec3(0,eps,0)) - dist(p),\n        dist(p+vec3(0,0,eps)) - dist(p)\n      ));\n}\n\n\nvec3 rayMarch(vec3 eye, vec3 ray) {\n  vec3 current = eye;\n  for (int i = 0; i < 200; i++) {\n    float d = dist(current);\n    current += ray * d;\n    if (abs(d) < eps) {\n      break;\n    }\n  }\n  return current;\n}\n\nvec3 rayMarchFire(vec3 eye, vec3 ray) {\n  vec3 current = eye;\n  for (int i = 0; i < 100; i++) {\n    float d = fire(current);\n    current += ray * d;\n    if (abs(d) < eps) {\n      break;\n    }\n  }\n  return current;\n}\n\nvec2 cubeMap(vec3 current, vec3 vec) {\n  vec2 result;\n  vec3 tmp;\n  float minT = 1145141919.;\n  float size = 100.;\n  float t;\n\n  //===========x\n  t = (size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n    minT = t;\n  }\n\n  t = (-size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n    minT = t;\n  }\n\n  //===============y\n  t = (size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n    minT = t;\n  }\n\n  t = (-size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n    minT = t;\n  }\n\n  //==============z\n  t = (size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n    minT = t;\n  }\n\n  t = (-size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n    minT = t;\n  }\n  return result  / (2. * size) + 1.;\n}\n\nvec3 getKatoriColor(vec3 p, vec3 vec) {\n  vec3 n = getNormal(p);\n  float diffuse = max(0.,dot(-vec, n));\n  vec3 difColor = vec3(0,0.5,0.3) * 0.8;\n  float len = length((p - fireEnd(iTime)).xz);\n  vec3 gray = vec3(0.7);\n  vec3 red = vec3(0.4,0,0);\n  vec3 black = vec3(0);\n  if (len < 0.7) {\n    difColor = gray;\n  } else if (len < 0.85) {\n    float t = (len - 0.7) / 0.15;\n    difColor = gray * (1.-t) + red * t;\n  } else if (len < 0.95) {\n    difColor = red;\n  } else if (len < 1.1) {\n    float t = (len - 0.95) / 0.15;\n    difColor = red * (1.-t) + black * t;\n  } else if (len < 1.2) {\n    difColor = black;\n  }\n  return difColor * diffuse;\n}\n\nvec3 getSaucerColor(vec3 p, vec3 vec) {\n  float diffuse = max(0.,dot(-vec, getNormal(p)));\n  vec = reflect(vec, getNormal(p));\n  p += vec;\n  int idx = 1;\n  for (int j = 0; j < 3; j++) {\n    p = rayMarch(p, vec);\n    if (abs(dist(p)) > eps) break;\n    if (getNearestIndex(p) == 0) {\n      idx = 0;\n      break;\n    }\n    vec = reflect(vec, getNormal(p));\n  }\n  vec3 reflectColor;\n  if (idx == 0) {\n    reflectColor = getKatoriColor(p, vec);\n  } else if (idx == 1) {\n    reflectColor = texture(iChannel0, cubeMap(p, reflect(vec, getNormal(p)))).rgb;\n  }\n  float refRate = 0.2;\n  return reflectColor * refRate + vec3(1) * (1.-refRate) * diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float a = -0.5;\n    float c = cos(a);\n    float s = sin(a);\n    vec3 n = normalize(vec3(1,0,0));\n    mat3 rot;\n\trot[0][0] = n[0]*n[0]*(1.-c)+c;\n\trot[0][1] = n[0]*n[1]*(1.-c)-n[2]*s;\n\trot[0][2] = n[2]*n[0]*(1.-c)+n[1]*s;\n\trot[1][0] = n[0]*n[1]*(1.-c)+n[2]*s;\n\trot[1][1] = n[1]*n[1]*(1.-c)+c;\n\trot[1][2] = n[1]*n[2]*(1.-c)-n[0]*s;\n\trot[2][0] = n[2]*n[0]*(1.-c)-n[1]*s;\n\trot[2][1] = n[1]*n[2]*(1.-c)+n[0]*s;\n\trot[2][2] = n[2]*n[2]*(1.-c)+c;\n\n  vec3 eye = vec3(0,5,-30);\n  eye = rot * eye;\n  vec3 ray = vec3(uv, sqrt(2.) * tan(fov));\n  const float angle = 1.5;\n  ray = vec3(sin(uv * angle), length(cos(uv * angle)));\n  ray = rot * ray;\n  ray = normalize(ray);\n  vec3 current = rayMarch(eye, ray);\n\n  vec3 lightPos = vec3(1,1,-1) * 10.;\n\n  if (abs(dist(current)) < eps) {\n      int idx = getNearestIndex(current);\n      if (idx == 0) {\n        fragColor.rgb = getKatoriColor(current, normalize(current - eye));\n      } else if (idx == 1) {\n        fragColor.rgb = getSaucerColor(current, normalize(current - eye));\n      }\n  } else {\n    fragColor.rgb = vec3(0);\n  }\n  fragColor.a = 1.;\n  current = rayMarchFire(eye, ray);\n  float t = 0.;\n  vec3 firePos = fireEnd(iTime+5.);\n  for (int i = 0; i < 20; i++) {\n    if (current.y < 2.5) continue;\n    float noiseValue = noise((current-firePos) * 300. - iTime * 100.);\n    noiseValue *= 1. - length((current-firePos).xz) * 3. ;\n    noiseValue = clamp(noiseValue, 0., 1.);\n    noiseValue = pow(noiseValue, 2.);\n    t += noiseValue * 0.2;\n    current += ray * 0.5;\n  }\n  fragColor.rgb += t * vec3(0.8) * 10.;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt33Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 100, 100, 183], [185, 185, 231, 231, 291], [293, 293, 314, 314, 935], [937, 937, 958, 958, 1130], [1132, 1132, 1171, 1171, 1238], [1240, 1240, 1263, 1263, 1384], [1386, 1386, 1418, 1418, 1436], [1438, 1438, 1476, 1476, 1788], [1790, 1790, 1818, 1818, 1836], [1838, 1838, 1861, 1861, 2054], [2056, 2056, 2076, 2076, 2258], [2260, 2260, 2280, 2280, 2811], [2813, 2813, 2839, 2839, 3384], [3386, 3386, 3406, 3406, 3446], [3448, 3448, 3477, 3477, 3617], [3619, 3619, 3643, 3643, 3802], [3805, 3805, 3840, 3840, 4016], [4018, 4018, 4057, 4057, 4233], [4235, 4235, 4273, 4273, 5318], [5320, 5320, 5359, 5359, 5962], [5964, 5964, 6003, 6003, 6608], [6610, 6610, 6667, 6667, 8320]], "test": "error"}
{"id": "lt3GRj", "name": "Prints Numbers", "author": "TimoKinnunen", "description": "Improved version of P_Malin's Smaller Numbers with more accurate numbers display while removing its fudge factor. Also demonstrates font size independent character positioning and tracking the mouse pointer without going offscreen.", "tags": ["utility", "numbers", "font", "digits"], "likes": 13, "viewed": 1698, "published": "Public API", "date": "1470198028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Prints numbers\n\n// Original version: https://www.shadertoy.com/view/4sBSWW\n\n// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Note that the values printed are not always accurate!\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n// Original version\nfloat PrintValue00(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// Improved version\n//\n// Most important change is dropping everything left of the decimal point ASAP \n// when printing the fractional digits. This is done to bring the magnitule down\n// for the following division and modulo.\n//\n// Another change is to replace the logarithm with a power-of-ten value \n// calculation that is needed later anyway.\n// This change is optional, either one works.\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\nfloat GetCurve(float x)\n{\n\treturn ceil(sin( x * 3.14159 * 4.0 )*10.0-0.5)/10.0;\n}\n\nfloat GetCurveDeriv(float x) \n{ \n\treturn 3.14159 * 4.0 * cos( x * 3.14159 * 4.0 ); \n}\n\n// Multiples of 4x5 work best\nvec2 fontSize = vec2(4,5) * vec2(5,3);\n\nvec2 grid(int x, int y) { return fontSize.xx * vec2(1,ceil(fontSize.y/fontSize.x)) * vec2(x,y) + vec2(2); }\n\nvec2 limitTo(vec2 point, int x1, int y1, int x2, int y2, int startX, int startY) {\n    return clamp(point, grid(x1,y1), iResolution.xy - grid(x2,y2)) + grid(startX, startY);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 vColour = vec3(0.0);\n\tvec2 mouse = iMouse.xy;\n\n\tif(mouse.x < 10.0 && mouse.y < 10.0) {\n\t\tmouse =( vec2(sin(iTime), cos(iTime))/2.0+0.5)*iResolution.xy;\n\t}\n\t// Draw Horizontal Line\n\tif(abs(fragCoord.y - iResolution.y * 0.5) < 1.0)\n\t{\n\t\tvColour = vec3(0.25);\n\t}\n\t// Draw Sin Wave\n\t// See the comment from iq or this page\n\t// http://www.iquilezles.org/www/articles/distance/distance.htm\n\tfloat fCurveX = fragCoord.x / iResolution.x;\n\tfloat fSinY = (GetCurve(fCurveX) * 0.25 + 0.5) * iResolution.y;\n\tfloat fSinYdX = (GetCurveDeriv(fCurveX) * 0.25) * iResolution.y / iResolution.x;\n\tfloat fDistanceToCurve = abs(fSinY - fragCoord.y) / sqrt(1.0+fSinYdX*fSinYdX);\n\tfloat fSetPixel = fDistanceToCurve - 1.0; // Add more thickness\n\tvColour = mix(vec3(1.0, 0.0, 0.0), vColour, clamp(fSetPixel, 0.0, 1.0));\t\n\n\t// Draw Sin Value\t\n\tfloat fValue4 = GetCurve(mouse.x / iResolution.x);\n\tfloat fPixelYCoord = (fValue4 * 0.25 + 0.5) * iResolution.y;\n\t\n\t// Plot Point on Sin Wave\n\tfloat fDistToPointA = length( vec2(mouse.x, fPixelYCoord) - fragCoord.xy) - 4.0;\n\tvColour = mix(vColour, vec3(0.0, 1.0, 1.0), (1.0 - clamp(fDistToPointA, 0.0, 1.0)));\n\t\n\t// Plot Mouse Pos\n\tfloat fDistToPointB = length( vec2(mouse.x, mouse.y) - fragCoord.xy) - 4.0;\n\tvColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n\t\n\t// Print Sin Value\n\tvec2 vPixelCoord4 = limitTo(vec2(mouse.x, fPixelYCoord),0,2,8,4,0,0);// + vec2(4.0, 4.0);\n\tfloat fDigits = 2.0;\n\tfloat fDecimalPlaces = 4.0;\n\tfloat fIsDigit4 = PrintValue(fragCoord, vPixelCoord4, fontSize, fValue4, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit4);\n\t\n\t// Print Shader Time\n\tfDigits = 6.0;\n\tvColour = mix( vColour, vec3(0.0, 0.0, 1.0), PrintValue(fragCoord, grid(11,0), fontSize, iTime, fDigits, fDecimalPlaces));\n\n\t// Print Date\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, grid(0,0), fontSize, iDate.x, 4.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, grid(5,0), fontSize, iDate.y + 1.0, 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, grid(8,0), fontSize, iDate.z, 2.0, 0.0));\n\n\t// Draw Time\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, grid(24,0), fontSize, mod(iDate.w / (60.0 * 60.0), 12.0), 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, grid(27,0), fontSize, mod(iDate.w / 60.0, 60.0), 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, grid(30,0), fontSize, mod(iDate.w, 60.0), 2.0, 0.0));\n\t\n\tif(mouse.x >= 0.0)\n\t{\n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = limitTo(mouse.xy, 8,2,8,4,-8,1);\n\t\tfloat fValue2 = mouse.x / iResolution.x;\n\t\tfDigits = 1.0;\n\t\tfDecimalPlaces = 5.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, fontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = limitTo(mouse.xy, 8,2,8,4,0,1);\n\t\tfloat fValue3 = mouse.y / iResolution.y;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, fontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n\t\n\tfragColor = vec4(vColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3GRj.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[905, 1054, 1086, 1086, 1244], [1246, 1266, 1445, 1445, 2428], [2430, 2822, 2933, 2933, 3656], [3657, 3711, 3736, 3736, 3792], [3794, 3794, 3825, 3825, 3879], [3881, 3951, 3976, 3976, 4058], [4060, 4060, 4142, 4142, 4235], [4236, 4236, 4293, 4293, 7532]], "test": "error"}
{"id": "ltc3Rj", "name": "sphere coordinates", "author": "nzNico", "description": "Is there a better way to generate a uv map for a sphere ?", "tags": ["raymrchingspherecoordinates"], "likes": 1, "viewed": 236, "published": "Public", "date": "1470238243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 scene( in vec3 pos )//reception d'une sphere\n{\n    vec3 dim = vec3(1, 1, 1);\n    \n    pos += vec3(0, 0., 0);\n    \n    float resSphere = sdSphere(pos, 1.3);\n    \n   \n    vec2 res = vec2(resSphere, 2.);\n    \n    \n    return res;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\nvec2 getUV(vec3 pos)\n{\n    vec3 nor = calcNormal(pos);\n    float lon = atan(nor.x,nor.z)/3.14;\n    float lat = acos(nor.y)/3.14;\n    vec2 r = vec2(lat, lon);\n    \n    return r;\n}\n\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\n{\n    float dMin = 1.;\n    float dMax = 50.;\n    float precis = 0.002;\n    float traveledDistance = dMin;\n    float color = -1.;\n    \n    for( int i = 0 ; i < 50 ; i++ )\n    {\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\n        \n        if( res.x<precis || traveledDistance>dMax )\n        {\n            break;\n        }\n        \n        traveledDistance += res.x;\n        color = res.y;\n    }\n    \n    if( traveledDistance > dMax )\n    {\n        color = -1.0;\n    }\n    return vec2( traveledDistance, color );\n}\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);//z (dir)\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis)\n    return mat3( cu, cv, cw );\n}\n\n\nfloat makeCheker(vec2 p)\n{\n    vec2 checker = p*10.;\n    vec2 cells = floor(checker);\n    float chekerColor = 0.;\n    if(mod(cells.x+cells.y, 2.)== 0.)\n    {\n        chekerColor = 1.;\n    }\n    else\n    {\n     \tchekerColor = 0.;   \n    }\n    return chekerColor;\n}\n\nvec2 seeCoords(vec2 p)\n{\n    return p.xy;\n}\n\n\nvec2 arrangeCoords(vec2 p)\n{\n    vec2 q = p.xy/iResolution.xy;\n    vec2 r = -1.0+2.0*q;\n\tr.x *= iResolution.x/iResolution.y;\n    return r;\n}\n//->START\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = arrangeCoords(fragCoord);\n     \n    \n    \n    \n    vec3 lookAt = vec3(-0, -0, 0);\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\n    \n    mat3 camera = setCamera(camPos, lookAt, 0.);\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\n    vec2 rayResult = rayMarching(camPos, rayDirection);\n        \n    \n    float rayDistance = rayResult.x;\n    float rayColor = rayResult.y;\n    vec3 hitPos = camPos + rayDirection*rayDistance;\n    vec2 chekerUv;\n    \n    vec3 color;\n    \n    vec3 sphereColor = vec3(0, 0, 0);\n    \n\n    \n    if(rayColor > 1.)\n    {\n        color = vec3(1. , 0.4 ,0.1 );\n     \n        if(rayDistance>1.)\n        {\n        \tchekerUv = getUV(hitPos);\n            sphereColor = vec3(makeCheker(chekerUv));\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\n        }\n        \n    }\n    else\n    {\n        color = vec3(0., 0., 0.);\n    }\n    \n   \n    vec3 pos = camPos + rayDistance * rayDirection;\n    vec3 nor = calcNormal( pos );\n    \n\n\t\n    fragColor = vec4(sphereColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltc3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 39, 39, 65], [67, 67, 118, 118, 300], [303, 303, 335, 335, 622], [624, 624, 646, 646, 802], [804, 804, 860, 860, 1398], [1402, 1402, 1454, 1454, 1700], [1703, 1703, 1729, 1729, 1966], [1968, 1968, 1992, 1992, 2011], [2014, 2014, 2042, 2042, 2154], [2155, 2165, 2222, 2222, 3273]], "test": "valid"}
{"id": "ltc3zl", "name": "float Pack diff", "author": "kuranes", "description": "Click and Drag to change vizualization areas.\n\nClear and simple code demonstrating error by diffing.\n(now keep in mind that output being 8bits, it's hard to visualize error)", "tags": ["simulation", "utility", "pack", "unpack", "diff", "flaot", "halffloat"], "likes": 5, "viewed": 176, "published": "Public", "date": "1470846814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// DIFF * 10 000.0 of various pack/unpack float code\nconst float diffy = 10000.0;\n\n// uncomment to check 0 to 1 from lower left to top right\n// so that error zone spread are clear\n// but don't forget to maximize the \"viewport\" you're checking\n//#define CHECK_ERROR_SPREAD\n// want to test [0, 1] ?\n//#define RANGE_BOUND_ONE_INCLUDED\n\n// MULTI pass instead of \"simulation\" here:  https://www.shadertoy.com/view/4ldGRl\n\n// BLACK == no difference\n// WHITE == huge difference\n//\n// A big decision in to do [0, 1[ or [0, 1]\n// here testing [0, 1[\n//\n//-------------------------------------------------------------------------\n// another error graphing tech: https://www.shadertoy.com/view/XssXR4\n\n//-------------------------------------------------------------------------\n// aras_p\n// http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n// w/o the aras typo 255.0*255.0*255.0 != 160581375 it's 16581375\n\nvec4 EncodeFloatRGBA_aras( const in float v ) {\n  vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n  return enc;\n}\n\nfloat DecodeFloatRGBA_aras(const in vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );\n}\n/// \n\n\n//-------------------------------------------------------------------------\n// the correct one\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/ldj3zG\n// the classic 1-32-bit-float to 4-8-bit-vec4 packing and unpacking functions that \n// have been floating around the internet for 10 years now. Unkown source, but\n// common sense.\n\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\n\nvec4 pack_F1_UB4( const in float value )\n{\n    vec4 res = fract( value*bitShL );\n\tres.yzw -= res.xyz/256.0;\n\treturn res;\n}\n\nfloat unpack_F1_UB4( const in vec4 value )\n{\n    return dot( value, bitShR );\n}\n\n//-------------------------------------------------------------------------\n// half float precision, when you pack 2-16-bit-float to 4-8-bit-vec4 \n\nvec4 encodeHalfFloatRGBA( const in vec2 v ) {\n    const vec2 bias = vec2(1.0 / 256.0, 0.0);\n    vec4 enc;\n    enc.xy = vec2(v.x, fract(v.x * 256.0));\n    enc.xy = enc.xy - (enc.yy * bias);\n\n    enc.zw = vec2(v.y, fract(v.y * 256.0));\n    enc.zw = enc.zw - (enc.ww * bias);\n    return enc;\n}\n\nvec2 decodeHalfFloatRGBA( const in vec4 rgba ) {\n    \n    return vec2(rgba.x + (rgba.y / 256.0), rgba.z + (rgba.w / 256.0));\n}\n\n//-------------------------------------------------------------------------\n\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\n// packing a float in glsl with multiplication and fract\n// wip  as not clear for now what the blog post is saying\n\n// \"fract is the problem\"\nvec4 packFloat_gradientstudios_problem( const in float depth ) {\n\n  const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\n  vec4 res = fract( depth * bit_shift );\n\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\n\n// packing a float in glsl with multiplication and mod\nvec4 packFloat_gradientstudios( float depth ) {\n\n  const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\n  vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 255 ) ) / vec4( 255 );\n\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\nfloat unpackFloat_gradientstudios( vec4 depth ) {\n\n\tvec4 bitSh = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(depth, bitSh);\n}\n\n//-------------------------------------------------------------------------\n// the diff code    \n//-------------------------------------------------------------------------\n\n// pa : packed float to 8 bit vec4\n// unpa: ready rgba 8 bits to be unpacke from an 8nit vec4, to a float\t \n// as said above [0,1[ \nvec4 buffer8bits(const in vec4 pa){\n\n   const float bit8 = 256.0;\n     //const float bit8 = 255.0;// to \"test\" [0,1]\n\n    // simulate that we are writing to a 8 bit color buffer\t\n    vec4 buff = floor( bit8*pa );\n    \n    // simulate that we are reading from a 8 bit color buffer\n    vec4 unpa = buff / bit8;\n    \n    return unpa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 step = 1.0 / iResolution.xy;\n    \n    vec2 mouse = all(lessThanEqual(iMouse.xy, vec2(0.0, 0.0))) ? iResolution.xy*0.5:  iMouse.xy ;\n    \n    float splitX = uv.x - mouse.x * step.x;\n    float splitY = uv.y - mouse.y * step.y;\n\t\n    // between [0,1[\n\tfloat signal = 0.5 + 0.5*sin(uv.x*50.0 + sin(uv.y*50.0) )*sin(uv.y*40.0 + sin(uv.x*40.0+iTime) );\n   \n    // here to check where on 0,1 errors are\n    // but don't forget to maximize the \"viewport\" you're checking\n#ifdef CHECK_ERROR_SPREAD\n\tsignal = cos (uv.x*uv.y*1.57079632679);\n#endif\n    \n    // between [0,1[\n#ifndef RANGE_BOUND_ONE_INCLUDED\n    signal = (signal == 1.0) ? 0.9999999999 : signal ;    \n#endif\n    \n\tfloat diff = 1.0;\n    if (splitX < 0.0 && splitY < 0.0  )\n    {\n        //LOWER LEFT: IQ        \n        float f = unpack_F1_UB4( buffer8bits(pack_F1_UB4( signal )) );\n        \n        diff = abs(signal -f) * diffy; \n\n    }\n    else if (splitX < 0.0 && splitY > 0.0  )\n    {\n        // UPPER LEFT: gradient studios\n        \n        float f = unpackFloat_gradientstudios( buffer8bits(packFloat_gradientstudios( signal )) );                \n        diff = abs(signal -f) * diffy; \n       \n    }\n     else if (splitX > 0.0 && splitY < 0.0  )\n    {\n        // LOWER RIGHT: ARAS_P\n        \n        float f = DecodeFloatRGBA_aras( buffer8bits(EncodeFloatRGBA_aras( signal )) );\n        \n        diff = abs(signal -f) * diffy; \n      \n    }\n    else if (splitX > 0.0 && splitY > 0.0  )\n    {\n        // UPPER RIGHT: HALF FLOAT\n        \n        vec2 f2 = decodeHalfFloatRGBA( buffer8bits(encodeHalfFloatRGBA(vec2( signal ))) );\n        \n        float f = (f2.x + f2.y) * 0.5;\n        //float f = f2.x;\n        \n        diff = abs(signal - f) * diffy; \n       \n    }\n         \n    vec3 diff3 = vec3(diff);\n    float splitBar = (abs(splitX - 0.001) < 0.001) || (abs(splitY - 0.001) < 0.001) ? 0.0: 1.0;\n\tfragColor = vec4(diff3, 1.0)  + vec4(1.0 - splitBar, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltc3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[691, 917, 964, 964, 1117], [1119, 1119, 1168, 1168, 1243], [1251, 1823, 1865, 1865, 1945], [1947, 1947, 1991, 1991, 2026], [2028, 2176, 2221, 2221, 2466], [2468, 2468, 2516, 2516, 2594], [2858, 2884, 2948, 2948, 3196], [3199, 3254, 3301, 3301, 3588], [3590, 3590, 3639, 3639, 3761], [3937, 4069, 4104, 4104, 4401], [4403, 4403, 4460, 4460, 6444]], "test": "error"}
{"id": "ltcGDl", "name": "desert", "author": "wachel", "description": "change log\n2016.8.29:modify curve function", "tags": ["noise", "raytrace"], "likes": 30, "viewed": 629, "published": "Public", "date": "1472364771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//thank for https://www.shadertoy.com/view/MdX3Rr by iq\n\n#define PI 3.14159265359\n\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat terrainH( in vec2 p)\n{\n\n    //small\n\tfloat valS = noise(p * 0.5) + 0.5;//0~1\n    valS = 1.0 - abs(valS - 0.5) * 2.0;\n    valS = pow(valS,2.0);\n\n    //middle\n    float valM = noise(p * 0.26) + 0.5;//0~1\n    valM = 1.0 - abs(valM - 0.5) * 2.0;\n    valM = pow(valM,2.0);\n    \n    //big\n    float valB = smoothstep(0.0,1.0,noise(p * 0.2) + 0.5);//0~1\n\n    float val = valS * 0.01 + valM * 0.19 + valB * 0.8;\n\n    return val * 1.3 - 0.3;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainH( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainH( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(-0.8,0.3,-0.3) );\n    vec3 lightColor = vec3(1.0);\n    vec3 sandColor = vec3(0.9,0.70,0.4);\n    vec3 ambientColor = vec3(0.5);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    float t = interesct(ro,rd,tmin,tmax);\n\n    vec3 col;\n    if(t>tmax){\n        vec3 sky0 = vec3(0.8,0.7,0.5) * 1.2;\n        vec3 sky1 = vec3(0.4,0.6,0.8) * 1.2;\n        col = mix(sky0,sky1,pow(max(rd.y + 0.15,0.0),0.5));\n        col += vec3(pow(max(dot(rd,lightDir),0.0),50.0));\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        \n        float shadow = softShadow(pos + lightDir *0.01,lightDir);\n        \n        vec3 normal = calcNormal( pos, t );\n        normal = normalize(normal + vec3(sin(pos.x * 100.0 + sin(pos.z * 31.0) + sin(pos.y) * 200.0) * 0.02,0,0));\n        vec3 viewDir = -rd;\n\n        float lambertian = max(dot(lightDir,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * noise(pos.xz * 10000.0) * 1.0f;// * pow(texture(iChannel0,pos.xz * 10.0).x,3.0);\n\n        vec3 diff = sandColor * lambertian * lightColor;\n        vec3 spec = (specular1 *0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * sandColor;\n        col = shadow * (diff + spec) + ambient;\n\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    //float yaw = time;//iMouse.x * 0.05;\n    //float pitch = 1.2;//clamp(iMouse.y * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    \n    float yaw;\n    float pitch;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \tyaw = time;\n    \tpitch = 1.2;        \n    }\n    else{\n        yaw = iMouse.x * 0.05;\n    \tpitch = clamp(iMouse.y  * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    }\n    \n    vec2 p0 = fragCoord.xy / iResolution.xy;\n    p0.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = 1.1*vec3(2.5*sin(0.25*yaw),2.5 * cos(pitch),2.5*cos(0.25*yaw));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p0.x*uu + p0.y*vv + 2.5*ww );\n\n    vec3 col = render( vec3(time,1.8,0.0), rd );\n    \n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 84, 105, 105, 226], [228, 228, 254, 254, 652], [654, 654, 682, 695, 1094], [1096, 1096, 1139, 1160, 1415], [1418, 1418, 1491, 1491, 1679], [1682, 1682, 1723, 1723, 1964], [1966, 1966, 2005, 2005, 3474], [3476, 3476, 3533, 3533, 4393]], "test": "valid"}
{"id": "ltcGRl", "name": "Lava Lamp Shader", "author": "vox", "description": "Lava Lamp Shader", "tags": ["lavalampshader"], "likes": 1, "viewed": 611, "published": "Public API", "date": "1470812450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0/GR)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n\n//-----------------AUDIO ALGORITHM-----------------\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\n//-----------------SIMPLEX ALGORITHM-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 numerator = cmul(uv, multa) + offa;\n    vec2 denominator = cmul(uv, multb) + offb;\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = (cdiv(numerator, denominator));\n    \n    for(int i = 0 ; i < 4; i++)\n    {\n        numerator = cmul(uv, multa) + offa+sin(vec2(float(i)-time*GR, -float(i)+time));\n        quotient += (cdiv(numerator, quotient));\n    }\n    \n    \n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    \n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n    seedling = 1.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    \n    float minDist = 0.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        float t = time/PI/GR/E+iteration*PI*2.0;\n        \n\n        multa = cos(vec2(time*.1, time*.2)+iteration*PI*4.0)/PI;\n        offa = cos(vec2(time*.3, time*.4)+iteration*PI*4.0)/PI;\n        multb = cos(vec2(time*.5, time*.6)+iteration*PI*4.0)/PI;\n        offb = cos(vec2(time*.7, time*.8)+iteration*PI*4.0)/PI;\n        \n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv0, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        \n        antispeckle *= stretch;\n\n        stretch = smoothstep(0.0, 1.0/PI/GR, stretch);\n\n        float skip = saw(seedling*PI)*stretch;\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        float l = length(p.xy);\n        \n        minDist = clamp(max(minDist*l, l)*(smoothstep(1.0-1.0/GR, 1.0, stretch)), 0.0, 1.0);\n\n    }\n\n    minDist = sqrt(clamp(1.0-minDist, 0.0, 1.0));\n    \n    fragColor= (vec4(flux(minDist+time+seedling), 1.0)*minDist+vec4(flux(-time/GR), 1.0)*(1.0-minDist))\n        *(1.0-saw(sqrt(minDist)*PI*2.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1113, 1166, 1186, 1186, 1564], [1566, 1621, 1643, 1643, 1840], [1843, 1843, 1868, 1868, 2599], [2601, 2664, 2693, 2693, 2763], [2765, 2765, 2794, 2794, 2878], [2880, 2880, 2948, 2948, 3654], [3656, 3718, 3823, 3823, 4515], [4521, 4521, 4578, 4578, 6277]], "test": "error"}
{"id": "ltdGDj", "name": "Follow the light", "author": "farious", "description": "Experimenting with 2D rectangle drawing.", "tags": ["experimental"], "likes": 5, "viewed": 130, "published": "Public", "date": "1471790418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n#define u_time s_time(1.)\n#define rect_s 0.065\n#define ss smoothstep\nfloat s_time(float f){return sin(iTime * f);}\n\nmat2 rotationMatrix(float angle)\n{ float s = sin(angle);float c = cos(angle); return mat2(c,-s,s,c); }\n\nvec3 rectangle(vec2 pos, vec2 center, float side, float t)\n{\n    vec2 p = abs(center - pos);\n    vec3 col1 = vec3(ss(-side,(p.x + p.y), side));\n    vec3 col2 = vec3(ss(-side, p.x, side) * ss(-side, p.y, side));\n    return clamp(mix(col1, col2, t), 0., 1.0);\n}\n\nvec3 rotatedRect(vec2 pos, vec2 center, float side, float t, float angle)\n{\n    mat2 rot = rotationMatrix(angle);\n    return rectangle(rot * pos, rot * center, side, t);\n}\n \n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    vec2 st = fragCoord.xy/iResolution.xy, p = vec2(0.5);\n    float del = sin(u_time * .5) * 0.25;\n    vec3 c = rotatedRect(st, p + vec2(del), rect_s, u_time, M_PI * u_time);\n    \n    for(float i = 1.; i < 3.; i++)\n    {\n        vec2 rc = p + vec2(del + i * s_time(2.) * 0.1);\n    \tvec3 c1 = rotatedRect(st, rc, rect_s, u_time, M_PI * u_time);\n        c1 *= vec3(4. * i, 2. * i, 3.* i);\n        c+=c1;\n    }\n     \n    fragColor = vec4(c / 2.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 138, 138, 161], [163, 163, 197, 197, 265], [267, 267, 327, 327, 526], [528, 528, 603, 603, 699], [703, 703, 761, 761, 1211]], "test": "valid"}
{"id": "ltdGWB", "name": "cross reference", "author": "tomaes", "description": "looks like normal mapping gone wild, but isn't.", "tags": ["fakebumpmapping"], "likes": 4, "viewed": 113, "published": "Public", "date": "1471424927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 func(vec2 _uv, float _p, float _t)\n{\n    vec2 r = vec2(.0,.0);\n\n    r.x = .2/tan( _p*5.4 + _t*2.6 + _uv.x*2.8 + sin(_t*2.+length(_uv)*4.)*3. ) * .026 / atan(_uv.x,_uv.y) * (mod(_t*2.,2.5));\n    r.y = .7/tan(_t+length(_uv)*5.)/cos( _p*.4 + _t*2.2 + _uv.y*22.6 + cos(_t*2.+length(_uv)*2.)*12. ) * .025 / (atan(_uv.x,_uv.y)+_t*.1) * (mod(_t*2.,.5));\n\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n        \n    float c = -.5;\n    float t = iTime + 1.4;\n\n    uv.x += sin(t+.1/uv.x*.5/uv.y*.15)*.4;\n    uv.y += cos(t+uv.x*4.5+uv.y*.15)*.2;\n\n    for(float f = .0; f < 1.; f += .035)\n    {\n        c += 2.7*mod( distance(func(uv,f,t*.15),func(uv,f,t*.15+1.)),.04-uv.y*.03 );\n        c -=  .8*mod( distance(func(uv,f,t*.15),func(uv,f,t*.15+7.)),.05-uv.x*.06 );\n    }\n    \n    fragColor = vec4(c*.85,c*.8-length(uv)*.05,c*.6-uv.y*.15, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 368], [370, 370, 427, 427, 929]], "test": "valid"}
{"id": "ltdGWX", "name": "HappyPalm", "author": "Dimonz", "description": "My first shader, by tutorial from ther internet but little bit extended", "tags": ["shader"], "likes": 1, "viewed": 80, "published": "Public", "date": "1472161211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = p - vec2 (0.5* (-0.5 *sin (iTime) + 0.5), 0.7);\n    vec4 animFrag = vec4(p,0.3+0.3*sin (iTime),1.0);\n    \n    vec4 col = mix(vec4 (1.0,0.4,0.1, 1.0), vec4 (1.0, 0.8, 0.3, 1.0), sqrt(p.y)); \n    col += animFrag;\n    float wave = sin(iTime);\n    //krona\n   \tfloat r = 0.2 + 0.1 * cos(atan(q.y,q.x)*10.0+20.0*q.x + (8.0 * sin(iTime)));\n  \n    col *= smoothstep(r, r+0.01, length (q));\n    \n    \n    r = 0.015;\n    r += 0.002*cos(120.0*q.y) *sin(iTime);\n    r += exp(-40.0 * p.y);\n    col *= 1.0 - (1.0 - smoothstep(r, r + 0.002, abs (q.x-0.25 *sin(2.0*q.y * wave))))* (1.0 - smoothstep(0.0, 0.1, q.y));\n    fragColor = vec4(col);\n    \n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 747]], "test": "valid"}
{"id": "ltdGzf", "name": "Some Terrain", "author": "dmemes", "description": "I have no idea what I'm doing.", "tags": ["terrain"], "likes": 3, "viewed": 147, "published": "Public", "date": "1470720463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 lightDirection = normalize(vec3(.2, -.2, -.5));\nconst vec3 SUN_COLOR = vec3(1.0, .95, .85);\n\nconst float HASH_SCALE = .1031;\nconst mat2 rotate2D = mat2(1.5623, 1.7531, -1.8131, 1.8623);\nconst vec2 add = vec2(1.0, 0.0);\n\nconst float SEA_LEVEL = 0.0;\n\nconst vec3 WATER_COLOR = vec3(.45, .45, .92);\nconst vec3 SKY_COLOR = vec3(0.75, 0.85, 1.0);\nconst vec3 ROCK_COLOR = vec3(.3, .25, .25);\nconst vec3 GRASS_COLOR = vec3(.32, .44, .21);\nconst vec3 SNOW_COLOR = vec3(.95, .95, .95);\nconst vec3 SAND_COLOR = vec3(.93, .84, .69);\n\n#define PI 3.14159265359\n#define MAX_DISTANCE 800.0\n\nfloat hash12(in vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASH_SCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(in vec2 xz)\n{\n\tvec2 f = fract(xz);\n\txz = floor(xz);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn\tmix(mix(hash12(xz), hash12(xz + add.xy), u.x),\n\tmix(hash12(xz + vec2(0.0, 1.0)), hash12(xz + add.xx), u.x), u.y);\n}\nvec3 noiseD(in vec2 x)\n{\n\tx+=4.2;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(1.5-f)*2.0;;\n    \n    float a = hash12(p);\n    float b = hash12(p + add.xy);\n    float c = hash12(p + add.yx);\n    float d = hash12(p + add.xx);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(f-1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\nfloat terrain(in vec2 p)\n{\n    p *= .004;\n    \n    float a = 3.8;\n    float o = -.1;\n    vec2 d = vec2(0);\n\n    for (int i = 0; i < 8; i++)\n    {\n        \n        vec3 nD = noiseD(p);\n\n        d += nD.yz;\n        float v = nD.x/(1.+dot(d,d));\n            \n        v = pow(1.0-abs(v-.5)*2., 1.5);\n        o += v * a;\n        \n       \tv = noise(p*.1);\n        o-= v*a*.3;\n        \n        a *= -.43;\n        p = rotate2D*p;\n        \n    }\n    return (1.0 - o) * 15.0;\n}\nfloat mapterrain(in vec3 p)\n{\n    return p.y - terrain(p.xz);\n}\n\nfloat cloud(in vec2 p){\n    return terrain(p);\n}\nfloat mapcloud(in vec3 p){\n    float h = noise(p.xz);\n    if (h > 1.0){\n\t\treturn p.y - ((h * 10.0) + 70.0);\n    }else{\n    \treturn 100000.0;\n\t}\n}\n\nfloat map(in vec3 p){\n\treturn mapterrain(p);\n}\n\nbool trace(vec3 o, vec3 r, out float dist)\n{\n    float t = 0.0;\n    float lastH = 0.0;\n    float lastT = 0.0;\n    \n    bool fin = false;\n    for (int i = 0; i < 160; ++i){\n    \tvec3 p = o + r * t;\n        float h = map(p);\n        \n        if (h < .1){\n            fin = true;\n            if (h > map(o + r * (t + h*.5))){\n            \tlastT = t;\n            \tt += h * .5;\n            }\n            break;\n        }\n        \n        lastT = t;\n        t += h * .5;\n        lastH = h;\n        \n        if (t > MAX_DISTANCE) break;\n    }\n    \n    if (fin){ // perform binary subdivision\n        float hT;\n        for (int n = 0; n < 32; n++){\n            if (map(o + r * lastT) < map(o + r * t)){\n                t = (t, lastT) * .5;\n            }else{\n                lastT = (t, lastT) * .5;\n            }\n        }\n        if (map(o + r * lastT) < map(o + r * t)){\n            dist = lastT;\n        }else{\n            dist = t;\n        }\n    }\n    return fin;\n}\nbool traceWater(vec3 o, vec3 r, out float t){\n    t = 0.0;\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float denom = dot(n, r);\n    if (abs(denom) > 0.0001){\n        t = dot(vec3(0.0, SEA_LEVEL, 0.0) - o, n) / denom;\n    }\n    return t > 0.0;\n}\n\nvec3 getNorm(vec3 pos){\n    float p = .1;\n    vec3 v1 = vec3(0.0, terrain(pos.xz), 0.0);\n    vec3 v2 = v1 - vec3(p, terrain(pos.xz + vec2(p, 0.0)), 0.0);\n    vec3 v3 = v1 - vec3(0.0, terrain(pos.xz + vec2(0, -p)), -p);\n    return normalize(cross(v2, v3));\n}\nvec3 getWaterNorm(vec3 pos){\n    vec2 o = pos.xz*1.5 + vec2(cos(iTime*2.0), sin(iTime*2.0));\n    float p = .1;\n    float s = .1;\n    vec3 v1 = vec3(0.0, abs(noise(o)) * s, 0.0);\n    vec3 v2 = v1 - vec3(p, abs(noise(o + vec2(p, 0.0)))*s, 0.0);\n    vec3 v3 = v1 - vec3(0.0, abs(noise(o + vec2(0, -p)))*s, -p);\n    return normalize(cross(v2, v3));\n}\n\nvec3 getSky(in vec3 r, bool sun){\n\tfloat sunAmount = max( dot(r, -lightDirection), 0.0 );\n\tfloat v = pow(1.0-max(r.y,0.0),4.);\n\tvec3  sky = mix(SKY_COLOR, SKY_COLOR * .65, v);\n\tsky = sky + SUN_COLOR * sunAmount * sunAmount * .15;\n\tif (sun) sky = sky + SUN_COLOR * min(pow(sunAmount, 500.0), .6);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nfloat shadow(vec3 pos){\n    /*float t = .1;\n    for (float steps = 0.0; steps < 32.0; steps++){\n        float h = map(pos + -lightDirection * t);\n        \n        if (h < 0.001)\n            return 0.3;\n        t += h;\n    }*/\n    return 1.0;\n}\n\nvec3 getColor(in vec3 pos, in vec3 norm, in vec3 r, in float t){\n    vec3 col = GRASS_COLOR;\n    \n    // snow color\n    if (pos.y > 14.0){\n        col = mix(col, SNOW_COLOR, clamp((pos.y - 14.0) * .2, 0.0, 1.0));\n    } \n\t\n    // beach color\n    if (pos.y < SEA_LEVEL + 2.0){\n        col = mix(col, SAND_COLOR, clamp((1.0 -  (pos.y - SEA_LEVEL)) * .75, 0.0, 1.0));\n    }\n    \n    // rock color\n    if (norm.y < .75)\n        col = mix(col, ROCK_COLOR, clamp((.75 - norm.y) / .3, 0.0, 1.0));\n    \n    // diffuse lighting\n    col *= dot(lightDirection, -norm);\n    \n    // sky\n    col = mix(getSky(r, false), col, exp(-t*.001));\n    \n    return col * shadow(pos);\n}\nvec3 getWaterColor(vec3 pos, vec3 o, vec3 r, vec3 norm, bool reflection){\n    // water reflection\n    vec3 refl = SKY_COLOR;\n\n    vec3 o2 = vec3(pos.x, SEA_LEVEL, pos.z);\n    vec3 r2 = reflect(r, norm);\n    float t2 = 0.0;\n    if (reflection && trace(o2, r2, t2) && distance(o, o2 + r2 * t2) < MAX_DISTANCE){\n        vec3 pos2 = o2 + r2 * t2;\n        vec3 norm2 = getNorm(pos2);\n\n        refl = getColor(pos2, norm2, r2, t2);\n    }else{\n        refl = getSky(reflect(r, norm), false);\n    }\n\t\n    float fresnel = dot(norm, r);\n\t\n    vec3 refr = SAND_COLOR;\n\t\n    vec3 col = mix(mix(refl, refr, fresnel), WATER_COLOR, .2);\n\t\n    // water specular\n    vec3 ref = -normalize(reflect(r, norm));\n    float spec = dot(lightDirection, ref);\n    if (spec > 0.0)\n        col += pow(spec, 40.0);\n    \n    return col * shadow(pos);\n}\n\nvec3 postfx(in vec3 rgb){\n\t// Gamma first...\n\trgb = pow(rgb, vec3(1));\n\t\n\t// Then...\n\t#define CONTRAST 1.0\n\t#define SATURATION 1.5\n\t#define BRIGHTNESS 1.0\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\treturn rgb;\n}\nvec4 doImage(vec2 fragCoord, vec3 o, vec3 r){\n    vec3 col = SKY_COLOR;\n    \n    float t = 0.0;\n    if (trace(o, r, t)){\n    \tvec3 pos = o + r * t;\n\t\tvec3 norm = getNorm(pos);\n        \n        if (pos.y < SEA_LEVEL){\n            traceWater(o, r, t);\n            col = getWaterColor(o + r * t, o, r, getWaterNorm(o+r*t), true);\n            \n        }else{\n        \tcol = getColor(pos, norm, r, t);\n        }\n    }else if (o.y > SEA_LEVEL && r.y < 0.0){ // water in the horizon\n        if (traceWater(o, r, t)){\n            vec3 p = o + r * t;\n        \tcol = getWaterColor(p, o, r, getWaterNorm(p), false);\n        }\n    }else{\n        col = getSky(r, true);\n    }\n    \n\treturn vec4(postfx(col), 1.0);\n}\n\nmat3 xrot(float t){\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\nmat3 yrot(float t){\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\nmat3 zrot(float t){\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * .1;\n    \n    vec3 r = normalize(vec3(uv.xy,-2.0)); r.z += length(uv) * 0.15;\n    r = normalize(r) * yrot(time + PI * 1.2);\n    \n    vec3 o = vec3(0.0, 10.0, 0.0) + (vec3(0.0, 0.0, 1.0) * yrot(time) * 600.0);\n    o.y = max(o.y, terrain(o.xz) + 5.0);\n    \n    fragColor = doImage(fragCoord, o, r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[587, 587, 612, 612, 734], [735, 735, 760, 760, 957], [958, 958, 982, 982, 1308], [1309, 1309, 1335, 1335, 1776], [1777, 1777, 1806, 1806, 1840], [1842, 1842, 1865, 1865, 1890], [1891, 1891, 1917, 1917, 2036], [2038, 2038, 2059, 2059, 2084], [2086, 2086, 2130, 2130, 3048], [3049, 3049, 3094, 3094, 3287], [3289, 3289, 3312, 3312, 3546], [3547, 3547, 3575, 3575, 3893], [3895, 3895, 3928, 3928, 4222], [4224, 4224, 4247, 4449, 4467], [4469, 4469, 4533, 4533, 5130], [5131, 5131, 5204, 5228, 5953], [5955, 5955, 5980, 5999, 6244], [6245, 6245, 6290, 6290, 6946], [6948, 6948, 6967, 6967, 7073], [7074, 7074, 7093, 7093, 7199], [7200, 7200, 7219, 7219, 7328], [7329, 7329, 7386, 7386, 7824]], "test": "error"}
{"id": "ltdGzs", "name": "VR Terrain", "author": "jackdavenport", "description": "A VR terrain shader, made to be used with Google Cardboard on the Shadertoy app.", "tags": ["noise", "terrain", "raymarcher", "height", "vr"], "likes": 4, "viewed": 983, "published": "Public API", "date": "1471051873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON .00001\n#define MAX_DIST 256.\n#define MAX_ITER 512\n\n#define LIGHT_DIR normalize(vec3(45.,30.,-45.))\n#define LIGHT_COL vec3(1.,.8,.2)\n#define LIGHT_AMB vec3(.1,.1,.3)\n\n// Noise by Pixelshaders.com\n// Source: http://pixelshaders.com/examples/noise.html\nfloat random(float p) {\n  return fract(sin(p)*10000.);\n}\nfloat noise(vec2 p) {\n  return random(p.x + p.y*10000.);\n}\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\nfloat smoothNoise(vec2 p) {\n  vec2 inter = smoothstep(0., 1., fract(p));\n  float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  return mix(s, n, inter.y);\n  return noise(nw(p));\n}\nfloat fractalNoise(vec2 p) {\n  float total = 0.0;\n  total += smoothNoise(p);\n  total += smoothNoise(p*2.) / 2.;\n  total += smoothNoise(p*4.) / 4.;\n  total += smoothNoise(p*8.) / 8.;\n  total += smoothNoise(p*16.) / 16.;\n  total /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n  return total;\n}\n//\n\nfloat getHeight(vec3 p) {\n    \n    return smoothNoise(p.xz);\n    \n}\n\nfloat raymarch(vec3 ori, vec3 dir) {\n \n    float t = 0.;\n    for(int i = 0; i < MAX_ITER; i++) {\n   \t\tvec3  p = ori + dir * t;\n        float h = p.y - getHeight(p);\n        if(h < t*EPSILON || t > MAX_DIST)\n            break;\n        t += h * .5;\n    }\n    return t;\n    \n}\n\nvec3 calcNormal(vec3 p, float t) {\n    vec2  e = vec2(t*EPSILON,0.);\n    vec3  n = vec3(getHeight(p-e.xyy)-getHeight(p+e.xyy),\n                   2.*e.x,\n                   getHeight(p-e.yyx)-getHeight(p+e.yyx));\n    return normalize(n);\n}\n\nvec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sp) {\n \n    float d = max(dot(LIGHT_DIR,n),0.);\n    float s = 0.;\n    \n    if(raymarch(p+LIGHT_DIR*.01,LIGHT_DIR) < MAX_DIST)\n        d = 0.;\n    \n    if(d > 0. && sp > 0.)\n        s = pow(max(dot(LIGHT_DIR,r),0.),sp);\n    \n    return col*(LIGHT_AMB+LIGHT_COL*d)+(LIGHT_COL*s);\n    \n}\n\nvec3 getSky(vec3 dir) {\n \n    float y = pow(dir.y,.5);\n    float s = pow(max(dot(LIGHT_DIR,dir),0.),30.);\n    \n    return mix(vec3(.6,.6,.8),vec3(.3,.3,.8),y) + LIGHT_COL*s;\n    \n}\n\nvec3 shadeTerrain(vec3 p, vec3 n, vec3 r) {\n\t  \n    vec3 col;\n    col = texture(iChannel0, p.xz).xyz;\n    col = calcLighting(col, p, n, r, 60.); \n    \n    return col;\n    \n}\n\nvec3 shade(vec3 ori, vec3 dir) {\n \n    float  t = raymarch(ori,dir);\n    vec3 col = getSky(dir);\n    \n    if(t < MAX_DIST) {\n    \tvec3 p = ori+dir*t;\n        vec3 n = calcNormal(p, t);\n        vec3 r = normalize(reflect(dir, n));\n        \n        col = shadeTerrain(p,n,r);\n        \n        vec3  rc = vec3(0.);\n        float rt = raymarch(p+r*.01,r);\n        if(rt < MAX_DIST) {\n       \t\tvec3 rp = p+r*(rt+.01);\n            vec3 rn = calcNormal(rp,rt);\n            vec3 rr = normalize(reflect(r,rn));\n            rc = shadeTerrain(rp,rn,rr);\n        } else {\n        \trc = getSky(r);   \n        }\n        \n        float f = 1.-pow(max(-dot(dir,n),0.),.5);\n        col = mix(col, rc, mix(.2,.8,f));\n        \n    }\n    \n    return col;\n    \n}\n\nvoid transformOri(inout vec3 ori) {\n \n    ori += vec3(cos(iTime*.2)*5.,.5,iTime);\n    if(ori.y < getHeight(ori))\n        ori.y = getHeight(ori)+.2;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,0.);\n    vec3 dir = vec3(uv, 1.);\n    \n    transformOri(ori);\n\tfragColor = vec4(shade(ori,normalize(dir)),1.);\n}\n\nvoid mainVR(out vec4 fc, in vec2 fp, in vec3 ro, in vec3 rd) {\n \n    transformOri(ro);\n\tfc = vec4(shade(ro,normalize(rd)),1.);   \n\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 266, 289, 289, 322], [323, 323, 344, 344, 381], [382, 382, 399, 399, 439], [440, 440, 457, 457, 497], [498, 498, 515, 515, 555], [556, 556, 573, 573, 613], [614, 614, 641, 641, 848], [849, 849, 877, 877, 1133], [1134, 1138, 1163, 1163, 1205], [1207, 1207, 1243, 1243, 1480], [1482, 1482, 1516, 1516, 1721], [1723, 1723, 1786, 1786, 2065], [2067, 2067, 2090, 2090, 2247], [2249, 2249, 2292, 2292, 2422], [2424, 2424, 2456, 2456, 3165], [3167, 3167, 3202, 3202, 3321], [3323, 3323, 3380, 3380, 3586], [3588, 3588, 3650, 3650, 3720]], "test": "error"}
{"id": "ltt3zj", "name": "Tech Ring / HUD", "author": "Yusef28", "description": "Practicing the use of ids in polar coordinates to create cool tech rings. As well as power function to make a light.\nStill working on coloring objects. Here I use Iq's method for procedural palettes using cos.\n", "tags": ["2d", "palette", "ring", "polar", "hud"], "likes": 17, "viewed": 363, "published": "Public", "date": "1470367712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123 );\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nmat2 rot(float a)\n    {\n    float cs = cos(a);\n    float si = sin(a);\n    mat2 mat = mat2(cs, si, -si, cs);\n    return mat;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n\n\tfloat u_time = iTime;//because I was using a glsl editor that names time \"u_time\n    //vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st = st*2.-1.;\n    st.x-=0.75;//not sure why I have to add this now to shift the thing but I do.\n    \n  \t\n    vec4 color;\n    //floor creates an \"id\" because floor(length(st*10)) means 0, 1, 2, 3, 4 ect id's for anything \n    //within the ranges of those numbers. 0 to 1 is on id, 3 tp 4 is one id, etc\n    st*=rot(floor(length(st*10.)));//initial rotation of each ring based on it's id\n    \n    //same thing but this time to rotate the rings in time\n    st*=rot(floor(length(st*10.))+(u_time) );\n  \tfloat a = atan(st.y, st.x)+3.14159;//add pi so it's 0 - 2pi not -pi to pi\n    \n    \n    //get length for whole circle\n    float l = length(st);\n    \n    //I end up multiplying the length by this smoothsteps for some reason\n    l*=smoothstep(0., 0.1, l)*(1.0-smoothstep( 0.8,0.8, l));\n    float i = floor(l*10.);\n    \n    \n    //then for each id, make a cell within that cell that is a bit smaller.\n    //cell has length span and angle span. cell length span is j\n    float j = fract(l*10.);\n    //cell width span is b\n    \n    //here I smoothstep the inner and outer edges of each ring to get like an outline\n    float ls =smoothstep(0.1, 0.14, j)*(1.0-smoothstep( 0.9,0.94, j));\n\n    //here I change the span of each arc based on time in noise so it's more random\n    a-=(noise(i+vec2(u_time))*2.);\n    a = smoothstep(3.1, 3.14, a);\n    \n    //I attemped to smoothstep the arcs edges \n    float b = smoothstep(.2, 0.1, a)*(1.0-smoothstep(3.0, 3.14, a));\n    \n       //here I use iq's procedural palette technique based on b and ls\n    //and modulated by time\n    vec3 cc = (0.5+0.5*sin(vec3(0.1, 0.2, 0.3)-i/2.+b*ls*sin(u_time*2.)));\n    \n    //and I top it off with a pulsating light in the middle.\n        cc+=pow(1.0-l, 4.-sin(u_time*8.))-(l/5.);\n    \n\n    \n \tfragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltt3zj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 24, 24, 164], [166, 248, 270, 270, 676], [677, 677, 700, 700, 802], [803, 803, 860, 860, 2871]], "test": "valid"}
{"id": "lttGzX", "name": "Diffusion Anim", "author": "daeken", "description": "Animated version of my freestyle gfx entry from TRSAC 2015.", "tags": ["trsac"], "likes": 2, "viewed": 170, "published": "Public", "date": "1470675091", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ engine ]\nimport[ noise ]\n\n:globals\n\ttrue =>shadertoy\n\t\t{\n\t\t\t@vec3 uniform =iResolution @float uniform =iTime\n\t\t\tiResolution .xy =>resolution\n\t\t\tiTime =>time\n\t\t}\n\t\t{\n\t\t\t@vec2 uniform =R @float uniform =T\n\t\t\tR =>resolution\n\t\t\tT =>time\n\t\t}\n\tshadertoy cif\n\n\t@vec3 32 array uniform =H\n\tH =>current\n;\n\n: scene ( p:vec3 -> vec2 )\n\t[ [\n\t\tp [ 0 0 -3.5 ] + =>tp\n\t\t[\n\t\t\t{ ( rp )\n\t\t\t\t[\n\t\t\t\t\t[\n\t\t\t\t\t\trp [ .27 6 6 ] box\n\t\t\t\t\t\trp 1.5 ty [ 6 .8 1 ] box\n\t\t\t\t\t\trp -1.5 ty [ 6 .8 1 ] box\n\t\t\t\t\t] .4 unionsmooth\n\t\t\t\t\t{ ( ryp )\n\t\t\t\t\t\tryp 1.9 ty .1 tz [ 6 .9 .5 ] box\n\t\t\t\t\t} rp 25 rotate-x\n\t\t\t\t] union\n\t\t\t} p -60 rotate-z\n\t\t\ttp 3 sphere\n\t\t] subtract\n\t\t[\n\t\t\t{ ( rp )\n\t\t\t\t1 rp .y abs 3.5 - 0 1 clamp time .7 * sin * - =>rampcenter\n\t\t\t\t1 rp .y abs 2.75 - 0 1 clamp - time 1.7 * sin * =>rampside\n\t\t\t\t[\n\t\t\t\t\trp [ .09 4.5 .25 rampcenter * ] box\n\t\t\t\t\trp .18 tx [ .09 3.75 .3 rampside * ] box\n\t\t\t\t\trp -.18 tx [ .09 3.75 .3 rampside * ] box\n\t\t\t\t] union\n\t\t\t} p -2 tz -60 rotate-z\n\t\t\tp [ 0 0 -1 2 ] plane\n\t\t] union\n\t] union 0 ]\n;\n\n:m palette ( t )\n\t[\n\t\t[ 0 ##00A0B0 ]\n\t\t[ .2 ##6A4A3C ]\n\t\t[ .4 ##CC333F ]\n\t\t[ .6 ##EB6841 ]\n\t\t[ .8 ##F7BC05 ]\n\t\t[ 1 ##000 ]\n\t] t envelope\n;\n\n:m stripe-texture ( uvm n )\n\t{ ( p )\n\t\tp .xy -60 deg->rad rotate-2d =rp\n\t\tp .z 10 * sin abs .025 swap step drop 1 =band\n\t\trp .x 6 * 1 - round 5 / 1 mod palette =pcol\n\t\t\t1 pcol - pcol band mix\n\t\t\trp .y 6 + 7 / 0 1 clamp 1 swap - time 2 * cos .5 * .5 + *\n\t\tdesaturate\n\t} uvm filter-texture\n;\n\n:m get-material ( pos id n )\n\t[\n\t\tpos n stripe-texture\n\t\t.6 .75 .2 .5\n\t] material\n;\n\n:m ambient-color ##fff ;\n\n:m lights ( )\n\t##fff .3 [ -.25 -.2 1 ] directional\n\t##fff .12 [ .25 -.2 1 ] directional\n\t##fee .45 [ .5 3 1.25 - -4 ] [ .3 1 -1 ] 60 1.5 spot\n\t##866 .8 [ 5 -1.35 -2.5 ] [ .3 -.55 -.5 ] 60 1.5 spot\n\t##111 1.5 [ -10 0 1 ] directional\n;\n\n: sky ( origin:vec3 dir:vec3 -> vec3 )\n\t##3A464A ##2E525E dir .y .3 + mix\n;\n\n:m focus 1.45 ;\n:m fog 0 ;\n:m fog-factor 7 ;\n:m close 0.01 ;\n:m far 100 ;\n:m max-steps 100 ;\n:m shadow-steps 30 ;\n:m shadow-dist close ;\n:m shadow-hardness 10 ;\n:m filter-textures? true ;\n\n[ 0 -2.5 -4 ] =>origin\n[\n\t0 0 3\n\t0\n] =>target\n\nresolution frag->position =pos\n\npos origin target render\n1.05 desaturate\n1.55 1.95 pos 325 * snoise-2d 2 / .5 + mix enhance-contrast\n.9 .0 brighten\n-.1 .9 vignette\n0 1 clamp ->fragcolor\n*/\n\nvec3 sky(vec3 origin, vec3 dir) {\n\treturn mix(vec3(.22745, .27451, .2902), vec3(.18039, .32157, .36863), dir.y + .3);\n}\nvec4 q_0(vec4 a, vec4 b) {\n\treturn vec4(a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y, a.w * b.y + a.y * b.w + a.z * b.x - a.x * b.z, a.w * b.z + a.z * b.w + a.x * b.y - a.y * b.x, a.w * b.w + a.x * b.x + a.y * b.y - a.z * b.z);\n}\nvec3 qrotate(vec4 a, vec3 b) {\n\treturn q_0(a, q_0(normalize(vec4(b, 0.)), vec4(-a.xyz, a.w))).xyz;\n}\nfloat snoise_12d(vec2 v) {\n\tvec4 C = vec4(.211325, .366025, -.57735, .02439);\n\tvec2 i = floor(dot(v, C.yy) + v);\n\tvec2 x0 = v - i + dot(i, C.xx);\n\tvec2 i1 = (x0.x > x0.y ? vec2(1., 0.) : vec2(0., 1.));\n\tvec4 x12 = x0.xyxy + C.xxzz - vec4(i1, 0., 0.);\n\ti = mod(i, 289.);\n\tvec3 p = mod(((mod(((vec3(0., i1.y, 1.) + i.y) * 34. + 1.) * (vec3(0., i1.y, 1.) + i.y), 289.) + i.x + vec3(0., i1.x, 1.)) * 34. + 1.) * (mod(((vec3(0., i1.y, 1.) + i.y) * 34. + 1.) * (vec3(0., i1.y, 1.) + i.y), 289.) + i.x + vec3(0., i1.x, 1.)), 289.);\n\tvec3 m = pow(max(.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.), vec3(4.));\n\tvec3 x = fract(p * C.w) * 2. - 1.;\n\tvec3 h = abs(x) - .5;\n\tvec3 a0 = x - floor(x + .5);\n\tm *= inversesqrt(a0 * a0 + h * h);\n\treturn dot(m, vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw)) * 130.;\n}\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.));\n}\nvec2 rotate_22d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nfloat smin_3poly(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\nvec2 scene(vec3 p) {\n\tvec3 var_1 = p + vec3(0., 0., -2.);\n\treturn vec2(min(max(-min(smin_3poly(smin_3poly(box(vec3(rotate_22d(p.xy, -1.0472), p.z), vec3(.27, 6., 6.)), box(vec3(rotate_22d(p.xy, -1.0472), p.z) + vec3(0., 1.5, 0.), vec3(6., .8, 1.)), .4), box(vec3(rotate_22d(p.xy, -1.0472), p.z) + vec3(0., -1.5, 0.), vec3(6., .8, 1.)), .4), box(vec3(vec3(rotate_22d(p.xy, -1.0472), p.z).x, rotate_22d(vec3(rotate_22d(p.xy, -1.0472), p.z).yz, .43632)) + vec3(0., 1.9, 0.) + vec3(0., 0., .1), vec3(6., .9, .5))), length(p + vec3(0., 0., -3.5)) - 3.), min(min(min(box(vec3(rotate_22d(var_1.xy, -1.0472), var_1.z), vec3(.09, 4.5, .25 * (1. - clamp(abs(vec3(rotate_22d(var_1.xy, -1.0472), var_1.z).y) - 3.5, 0., 1.) * sin(iTime * .7)))), box(vec3(rotate_22d(var_1.xy, -1.0472), var_1.z) + vec3(.18, 0., 0.), vec3(.09, 3.75, .3 * (1. - clamp(abs(vec3(rotate_22d(var_1.xy, -1.0472), var_1.z).y) - 2.75, 0., 1.)) * sin(iTime * 1.7)))), box(vec3(rotate_22d(var_1.xy, -1.0472), var_1.z) + vec3(-.18, 0., 0.), vec3(.09, 3.75, .3 * (1. - clamp(abs(vec3(rotate_22d(var_1.xy, -1.0472), var_1.z).y) - 2.75, 0., 1.)) * sin(iTime * 1.7)))), dot(p, vec3(0., 0., -1.)) + 2.)), 0.);\n}\nfloat shadow(vec3 ray, vec3 dir) {\n\tfloat dist = .01;\n\tfloat ret = 1.;\n\tfor(int temp_28 = 0; temp_28 < 30; ++temp_28) {\n\t\tvec2 cur = scene(ray + dir * dist);\n\t\tret = min(ret, cur.x / dist * 10.);\n\t\tdist += max(abs(cur.x), .01);\n\t}\n\treturn clamp(ret, 0., 1.);\n}\nfloat calc_4directional(vec3 origin, vec3 pos, vec3 normal, vec3 lightdir, float dif, float spec) {\n\tvec3 ivec = normalize(lightdir);\n\tfloat incidence = max(dot(ivec, normal), 0.);\n\treturn clamp((incidence * dif + pow(max(dot(normalize(ivec + origin), normal), 0.), spec) / 100. * sign(spec) * max(sign(incidence), 0.)) * shadow(pos, lightdir), 0., 1.);\n}\nfloat calc_5point(vec3 origin, vec3 pos, vec3 normal, vec3 lightpos, float dif, float spec) {\n\tvec3 ivec = normalize(lightpos - pos);\n\tfloat incidence = max(dot(ivec, normal), 0.);\n\tfloat shade = shadow(pos, normalize(lightpos - pos));\n\treturn clamp(incidence * dif * shade + pow(max(dot(normalize(ivec + origin), normal), 0.), spec) / length(lightpos - pos) * sign(spec) * max(sign(incidence), 0.) * shade, 0., 1.);\n}\nfloat calc_6spot(vec3 origin, vec3 pos, vec3 normal, vec3 lightpos, vec3 lightdir, float cone_7angle, float cone_8falloff, float dif, float spec) {\n\tvec3 ivec = normalize(lightpos - pos);\n\tfloat incidence = max(dot(ivec, normal), 0.);\n\tfloat shade = shadow(pos, -lightdir);\n\tfloat a = abs(dot(ivec, normalize(lightdir)));\n\tfloat fa = a - cos(cone_7angle);\n\treturn clamp((incidence * dif * shade + pow(max(dot(normalize(ivec + origin), normal), 0.), spec) / length(lightpos - pos) * sign(spec) * max(sign(incidence), 0.) * shade) * clamp(1. - pow(1. - (a - cos(cone_7angle - cone_8falloff)) / (fa + .00001), 3.), 0., 1.) * sign(a - cos(cone_7angle)), 0., 1.);\n}\nvec3 render(vec2 pos, vec3 origin, vec4 target) {\n\tvec3 no;\n\tfloat tilt = target.w * .017453;\n\tvec3 ww = normalize(target.xyz - origin);\n\tvec3 uu = normalize(cross(ww, vec3(sin(tilt), cos(tilt), 0.)));\n\tvec3 dir = normalize(mat3(uu, normalize(cross(uu, ww)), ww) * vec3(pos, 1.45));\n\tfloat t = .1;\n\tvec2 closest = vec2(100.);\n\tvec2 cur;\n\tfor(int temp_41 = 0; temp_41 < 100; ++temp_41) {\n\t\tcur = scene(origin + dir * t);\n\t\tt += cur.x;\n\t\tif(cur.x <= .01) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tvec3 fray = origin + dir * t;\n\tvec3 cursky = sky(origin, dir);\n\tif(cur.x <= .01) {\n\t\tvec3 neps = vec3(max(.01, pow(.0001 * t, 2.)), 0., 0.);\n\t\tvec3 normal = normalize(vec3(scene(fray + neps).x - scene(fray - neps).x, scene(fray + neps.yxy).x - scene(fray - neps.yxy).x, scene(fray + neps.yyx).x - scene(fray - neps.yyx).x));\n\t\tvec3 ddx = dFdx(fray);\n\t\tvec3 ddy = dFdy(fray);\n\t\tint sx = int(clamp(length(ddx) * 4., 0., 9.)) + 1;\n\t\tint sy = int(clamp(length(ddy) * 4., 0., 9.)) + 1;\n\t\tno = vec3(0.);\n\t\tfor(int temp_44 = 0; temp_44 < 10; ++temp_44) {\n\t\t\tfor(int temp_46 = 0; temp_46 < 10; ++temp_46) {\n\t\t\t\tif(temp_44 < sy && temp_46 < sx) {\n\t\t\t\t\tvec2 st = vec2(float(temp_46), float(temp_44)) / vec2(float(sx), float(sy));\n\t\t\t\t\tvec2 rp = rotate_22d((fray + st.x * ddx + st.y * ddy).xy, -1.0472);\n\t\t\t\t\tfloat band = 1.;\n\t\t\t\t\tfloat macro_envelope_t = mod(floor(rp.x * 6. - 1. + .5) / 5., 1.);\n\t\t\t\t\tvec3 pcol = mix(mix(mix(mix(mix(vec3(0., .62745, .6902), vec3(.41569, .2902, .23529), clamp(macro_envelope_t / .2, 0., 1.)), vec3(.8, .2, .24706), clamp((macro_envelope_t - .2) / .2, 0., 1.)), vec3(.92157, .40784, .2549), clamp((macro_envelope_t - .4) / .2, 0., 1.)), vec3(.96863, .73725, .019608), clamp((macro_envelope_t - .6) / .2, 0., 1.)), vec3(0.), clamp((macro_envelope_t - .8) / .2, 0., 1.));\n\t\t\t\t\tvec3 macro_desaturate_col = mix(1. - pcol, pcol, band);\n\t\t\t\t\tvec3 lum = vec3(macro_desaturate_col.r * .299 + macro_desaturate_col.g * .587 + macro_desaturate_col.b * .114);\n\t\t\t\t\tno += mix(lum, macro_desaturate_col, (1. - clamp((rp.y + 6.) / 7., 0., 1.)) * (cos(iTime * 2.) * .5 + .5));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec3 col = no / float(sx * sy);\n\t\tfloat amb = .6;\n\t\tfloat dif = .75;\n\t\tfloat ao_9dif = .2;\n\t\tfloat spec = .5;\n\t\tfloat ao = clamp((1. - (max((.5 - scene(fray + normal * .5).x) / .5, 0.) + max(1. - scene(fray + normal).x, 0.) + max((1.5 - scene(fray + normal * 1.5).x) / 1.5, 0.) + max((2. - scene(fray + normal * 2.).x) / 2., 0.) + max((2.5 - scene(fray + normal * 2.5).x) / 2.5, 0.)) * .1) * (1. - shadow(fray, normal) * .2), 0., 1.);\n\t\tdif *= 1. - ao_9dif * ao;\n\t\tvec3 var_35 = vec3(ao) * amb;\n\t\tvec3 var_36 = vec3(calc_4directional(origin, fray, normal, normalize(-vec3(-.25, -.2, 1.)), dif, spec) * .3);\n\t\tvec3 var_37 = vec3(calc_4directional(origin, fray, normal, normalize(-vec3(.25, -.2, 1.)), dif, spec) * .12);\n\t\tvec3 var_38 = calc_6spot(origin, fray, normal, vec3(.5, 1.75, -4.), normalize(-vec3(.3, 1., -1.)), 1.0472, .02618, dif, spec) * .45 * vec3(1., .93333, .93333);\n\t\tvec3 var_39 = calc_6spot(origin, fray, normal, vec3(5., -1.35, -2.5), normalize(-vec3(.3, -.55, -.5)), 1.0472, .02618, dif, spec) * .8 * vec3(.53333, .4, .4);\n\t\tfloat var_40 = calc_4directional(origin, fray, normal, normalize(-vec3(-10., 0., 1.)), dif, spec) * 1.5 * .066667;\n\t\treturn col * (var_35 + var_36 + var_37 + var_38 + var_39 + var_40);\n\t} else {\n\t\treturn cursky;\n\t}\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tvec3 macro_desaturate_col = render(pos, vec3(0., -2.5, -4.), vec4(0., 0., 3., 0.));\n\tvec3 lum = vec3(macro_desaturate_col.r * .299 + macro_desaturate_col.g * .587 + macro_desaturate_col.b * .114);\n\tfragColor = vec4(clamp((clamp(.9 / length(pos), 0., 1.) * 1.1 + -.1) * clamp((mix(lum, macro_desaturate_col, 1.05) - .5) * mix(1.55, 1.95, snoise_12d(pos * 325.) / 2. + .5) + .5, 0., 1.) * .9, 0., 1.), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 2353, 2386, 2386, 2472], [2473, 2473, 2499, 2499, 2703], [2704, 2704, 2734, 2734, 2804], [2805, 2805, 2831, 2831, 3643], [3644, 3644, 3671, 3671, 3758], [3759, 3759, 3793, 3793, 3891], [3892, 3892, 3937, 3937, 4029], [4030, 4030, 4050, 4050, 5194], [5195, 5195, 5229, 5229, 5455], [5456, 5456, 5555, 5555, 5811], [5812, 5812, 5905, 5905, 6230], [6231, 6231, 6378, 6378, 6891], [6892, 6892, 6941, 6941, 10226], [10227, 10227, 10282, 10282, 10787]], "test": "valid"}
{"id": "ltyGzR", "name": "torus loop", "author": "uber5001", "description": "I got bored in class today.", "tags": ["2d"], "likes": 4, "viewed": 95, "published": "Public", "date": "1472678180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = (atan(tan(iTime/3.0-3.1415/2.0))+1.5708);\n\tfloat n = pow(pow(pow(2.0,t),t), t*0.6);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= iResolution.xy / iResolution.yy;\n    vec3 color = vec3(1.0,1.0,1.0);\n    float i = 0.0;\n    for (int q = 0; q < 129; q++) {\n        if (i < n) {\n        \tvec3 colorTmp = color;\n            vec2 center = vec2(sin(i/n*2.0*3.1415926)/1.0, cos(i/n*2.0*3.1415926)/5.0);\n            vec2 d = center-uv;\n            if (d.x*d.x+d.y*d.y < 0.5) {\n                colorTmp.x += 1.0;\n                if (colorTmp.x > 1.5) {\n                    colorTmp.x = 0.0;\n                    colorTmp.y += 1.0;\n                }\n                if (colorTmp.y > 1.5) {\n                    colorTmp.y = 0.0;\n                    colorTmp.z += 1.0;\n                }\n                if (colorTmp.z > 1.5) {\n                    colorTmp.x = 0.0;\n                    colorTmp.y = 0.0;\n                    colorTmp.z = 0.0;\n                }\n                if (i+1.0 < n) {\n                \tcolor = colorTmp;\n                } else {\n                    float ratio = n-i;\n                    color = colorTmp*(ratio) + color*(1.0-ratio);\n                }\n            } else if (d.x*d.x+d.y*d.y < 0.51) {\n             \tcolor = vec3(0.0,0.0,0.0);\n                i=n;\n            }\n            i+=1.0;\n        }\n    }\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1464]], "test": "valid"}
{"id": "MdSXRd", "name": "StarField02", "author": "xaot88", "description": "The same procedural star field as my StarField01.  But for this one, I do a slow camera spin, instead of a camera crawl.  Just a slight variation in mainImage().", "tags": ["procedural", "sky", "stars", "night", "starry", "starfield"], "likes": 18, "viewed": 760, "published": "Public", "date": "1472452068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define HASHSCALE1 .1031\n\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = hash12( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Sky Background Color\n\tvec3 vColor = vec3( 0.1, 0.2, 0.4 ) * fragCoord.y / iResolution.y;\n\n    // Note: Choose fThreshhold in the range [0.99, 0.9999].\n    // Higher values (i.e., closer to one) yield a sparser starfield.\n    float StarFieldThreshhold = 0.97;\n\n    // Stars with a slow spin.\n    float fSpinRate = 0.001;\n    vec2 vInputPos = ( 2.0 * fragCoord.xy/iResolution.y ) - vec2( 1.0, 1.0 );\n    float fSampleAngle = fSpinRate * float( iFrame ) + atan( vInputPos.y, vInputPos.x );\n    vec2 vSamplePos = ( 0.5 * length( vInputPos ) * vec2( cos( fSampleAngle ), sin( fSampleAngle ) ) + vec2( 0.5, 0.5 ) ) * iResolution.y;\n    float StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n    vColor += vec3( StarVal );\n\t\n\tfragColor = vec4(vColor, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSXRd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[114, 174, 196, 196, 318], [320, 410, 473, 473, 678], [680, 746, 810, 980, 1611], [1613, 1613, 1670, 1695, 2439]], "test": "valid"}
{"id": "Ml33W7", "name": "2D Dist Func (triangle, rect)", "author": "vug", "description": "Distance functions for line, triangle and rectangle.", "tags": ["2d"], "likes": 3, "viewed": 171, "published": "Public", "date": "1470271838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n Inspired by https://www.shadertoy.com/view/ltBGzK \"2D Distance Field Visualization\"\n Here I tried have\n 1) a distance field that can tell inside from outside (e.g. to fill the inside of the shape)\n 2) where the isolines are scaled versions of each other (e.g. no curves at the corners)\n 3) a distance function for triangle\n */\n\n\nfloat rectDist(vec2 p, vec2 dim) {\n    //return length(max(abs(p) - dim, 0.0));\n    //\n    //return abs(p).x - dim.x*0.5;\n    //return abs(p).y - dim.y*0.5;\n    //return max(p.x, p.y);\n    //return max(p.x - dim.x*0.5, p.y - dim.y*0.5);\n    //\n    return max(abs(p).x - dim.x*0.5, abs(p).y - dim.y*0.5);\n}\n\nfloat lineDist(vec2 p, vec2 x, vec2 y) {\n    vec2 v_xy = y - x;\n    vec2 v_xp = p - x;\n    vec2 u_xy = normalize(v_xy);\n    float proj = dot(v_xp, u_xy);\n    vec2 v_xz = u_xy * proj;\n    vec2 v_zp = v_xp - v_xz;\n    //return length(v_zp); // * sign( cross(vec3(v_xz, 0.0), vec3(v_xp, 0.0)).z );\n    return length(v_zp) * sign( cross(vec3(v_xz, 0.0), vec3(v_xp, 0.0)).z ) * -sign(dot(v_xp, u_xy));\n}\n\nfloat triangleDist(vec2 p, vec2 a, vec2 b, vec2 c) {\n    float d_ab = lineDist(p, a, b);\n    float d_bc = lineDist(p, b, c);\n    float d_ca = lineDist(p, c, a);\n    return max(max(d_ab, d_bc), d_ca);\n}\n\nfloat unionOp(in float d1, in float d2 ) { return min(d1,d2); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy - 0.5*iResolution.xy) / iResolution.yy;\n    float t = iTime;\n    \n    float dist1 = rectDist(uv - vec2(0.5, 0.1), vec2(1.0+0.5*sin(t+0.1), 0.3+0.2*cos(t+0.5)));\n    float dist2 = lineDist(uv, vec2(-0.9+sin(t), 0.0), vec2(-0.7, 0.8));\n    float dist3 = triangleDist(uv, vec2(-0.1, -0.1), vec2(1.2+0.5*sin(t+0.7), 0.5+sin(t+1.1)), vec2(0.3, 0.9));\n    float dist = unionOp(unionOp(dist1, dist2), dist3);\n    \n    float thickness = 0.01;\n    float zero = 1.0 - smoothstep(thickness, thickness+0.003, abs(dist));  // shape borders, where distance field is zero.\n    \n    float h = dist;\n    h = tanh(6.0*dist); // emphasize color\n    vec3 color1 = (h > 0.0) ? vec3(h,0.0,0.0) : vec3(0.0,0.0,-h); // red if positive, blue if negative\n    \n    float mod_of_dist = mod(dist, 0.06); // thin lines\n    float zero_of_mod_dist = 1.0 - smoothstep(0.006, .007, abs(mod_of_dist));\n    vec3 color2 = vec3(zero_of_mod_dist);\n     \n\tfragColor = vec4((color1 + color2)*clamp(sin(t*0.7)*2.+0.1, 0.0, 1.0) + zero, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml33W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 333, 367, 576, 638], [640, 640, 680, 680, 1038], [1040, 1040, 1092, 1092, 1241], [1243, 1243, 1285, 1285, 1306], [1308, 1308, 1365, 1365, 2396]], "test": "valid"}
{"id": "Ml33Wj", "name": "cyaneuse", "author": "visy", "description": "circles, noise, holes.", "tags": ["noise", "circles", "holes"], "likes": 3, "viewed": 97, "published": "Public", "date": "1471559021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on gltracy's marching examples\n\n// ray marching\nconst int max_iterations = 1;\nfloat stop_threshold = 0.001;\n float grad_step = 0.01;\nconst float clip_far = 1000.0;\n\nfloat speed = 1.0;\nfloat time = 0.0;\n\n// Optimized port and generalization of \n// http://learningwebgl.com/blog/?p=2858\nfloat stride = 8.0; // Must be a multiple of 4\nbool wiggle = true;\n\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nint mode = 0;\n\nfloat repeat(vec3 pos) {\n    pos.x = mod(pos.x, 1.) - 0.5;\n    pos.y = mod(pos.y, 1.) - 0.5;\n    pos.z = mod(pos.z, 1.) - 0.5;\n\tif (mode == 0) \n    return -dist_sphere(pos,0.5);\n    else \n    return dist_sphere(pos,0.5);\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n\t\n\t// object 0 : sphere\n\tfloat d0 = 0.0;\n\t\n\t// object 1 : cube\n\tfloat d1 = dist_box( pos, vec3( iTime ) );\n\n    float d2 = repeat(pos);\n    \n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn max(d2, min( d1, -d0 ));\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 2.8;\n\t\n\tvec3 final = vec3(0.0);\n\t    \n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( cos(time*0.1)*100., 0.0, -1.0+v.z*0.0001);\n\t\tvec3 light_color = vec3( n.z*0.4,n.z*0.49, n.z*0.5 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( -1.0+n.z*0.8, dot( vl, n ) )*0.6;\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) )*0.8;\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( 100.-abs(cos(time*0.1)*200.), 50.+abs(cos(time*1.)*180.), 10.0 );\n\t\tvec3 light_color = vec3( 0.0, 0.0, 0.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( -1., dot( vl, n ) );\n\t\tfloat specular = max( -10.5+sin(n.z*0.1*(time*time*1.))*25., dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\t vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\t vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\t vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) + dist_field( pos - dx )*pos.x*0.1,\n\t\t\tdist_field( pos + dy ) + dist_field( pos - dy )*pos.y*0.01,\n\t\t\tdist_field( pos + dz ) + dist_field( pos - dz )*pos.z*0.5\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth )*time*0.00035;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( (150.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n\nvoid mainImage(out vec4 fa, in vec2 aa)\n{\n\ttime = iTime*0.1;\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n//    if (uv.x < 0.5) uv.x = 1.0-uv.x;\n    \n    // default ray dir\n\tvec3 dir = ray_dir(iTime*0.0001, iResolution.xy, uv*iResolution.xy );\n    \n\t// default ray origin\n\tvec3 eye = vec3( 0., 0.0,0.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( time,time) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, time, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfa = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tmode = 0;\n\tvec3 n = vec3(0.0);\n    vec4 oc1 = vec4(0.0);\n    vec4 oc2 = vec4(0.0);\n\tmode = 1;\n\tvec3 n2 = vec3(0.0);\n    vec4 oc3 = vec4(0.0);\n    vec4 oc4 = vec4(0.0);\n    \n\tmode = 1;\n\tn = gradient( pos );\n    oc1 = vec4( shading( pos*time*0.001, n*0.61, eye ), 1.0 );\n    oc1 *= 0.2 + 0.8*pow(26.0*uv.x*uv.y*(3.0-uv.x)*(1.05-uv.y),0.55);\n    oc2 = vec4( shading( pos+vec3(0.,0.,0.), n*time*0.4, eye ), 1.0 )*1.2;\n    oc1 = oc1+((oc1+oc2*0.01)*-abs(cos(time*0.3+n.z*90.1)*n.z*0.1));\n\toc1 = clamp(oc1,vec4(0.0),vec4(1.0))*3.4+pos.z*0.00005;\n\n   \tmode = 0;\n\tn2 = gradient( pos );\n    oc3 = vec4( shading( pos, n2*0.8, eye ), 1.0 );\n    oc3 *= 0.2 + 0.8*pow(26.0*uv.x*uv.y*(3.0-uv.x)*(1.05-uv.y),0.55);\n    oc4 = vec4( shading( pos+vec3(0.,0.,0.), n2*time*0.01, eye ), 1.0 )*1.2;\n\n    oc3 = oc3+((oc3+oc4*0.01)*-abs(cos(time*0.3+n2.z*500.1)*n2.z*.1));\n\toc3 = clamp(oc3,vec4(0.0),vec4(1.0))*2.0;\n\n    float v = dot(oc1.rgb+oc3.rgb, oc1.rgb+oc3.rgb)*n2.z*0.1;\n    vec2 p = gl_FragCoord.xy;\n\tif (wiggle) p.x += floor(sin(p.x * 0.08) * 2.0 + sin(p.y * 0.01 + p.x * 0.07));\n\tp = mod(p.xx + vec2(p.y, -p.y), vec2(stride));\n    \n  fa = (oc1+oc3)+0.1*oc3.b*vec4(vec3(\n          float((v > 1.00) || (p.x != 0.0)) *\n\t\t  float((v > 0.70) || (p.y != 0.0)) *\n  \t\t  float((v > 0.35) || (p.x != stride / 2.0)) *\n    \t  float((v > 0.18) || (p.y != stride / 2.0)) *\n          float((v > 0.10) || (p.x != stride / 4.0)) *\n          float((v > 0.02) || (p.y != stride / 4.0))*(3.-pos.z*1.)), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml33Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 462, 502, 502, 531], [533, 533, 572, 572, 623], [640, 640, 664, 664, 862], [864, 893, 923, 974, 1219], [1221, 1238, 1280, 1306, 2269], [2271, 2300, 2327, 2327, 2677], [2679, 2695, 2764, 2764, 3027], [3029, 3050, 3098, 3098, 3274], [3276, 3308, 3339, 3339, 3495], [3497, 3497, 3520, 3520, 3576], [3579, 3579, 3620, 3620, 5663]], "test": "valid"}
{"id": "Ml3GD2", "name": "fun shader", "author": "rsofchrs", "description": "colored shifting gradients", "tags": ["gradient"], "likes": 2, "viewed": 923, "published": "Public API", "date": "1471626384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 baseColorFor(float time) {\n    float i = mod(floor(time / 10.0), 2.0);\n    float progress = mod(time, 10.0);\n    \n    vec3 one = vec3(0.0 / 255.0, 209.0 / 255.0, 193.0 / 255.0);\n    vec3 two = vec3(123.0 / 255.0, 222.0 / 255.0, 90.0 / 255.0);\n\n    \n    if (i == 0.0) {\n        if (progress > 8.0) {\n          return mix(one, two, (progress - 8.0) / 2.0);\n        } else {\n          return one;\n        }\n    }\n    \n    //if (i == 1.0) {\n        if (progress > 8.0) {\n          return mix(two, one, (progress - 8.0) / 2.0);\n        } else {\n          return two;\n        }\n    //}\n}\n\nvec3 adjustSV(vec3 rgb, float s, float v) {\n    vec3 hsv = rgb2hsv(rgb);\n    hsv.y = s;\n    hsv.z = v;\n    return hsv2rgb(hsv);\n}\n\nvec3 colorFor(vec3 base, float uv) {\n    vec3 first = base;\n    \n    vec3 second = adjustSV(base, .5, .9);\n    vec3 third = adjustSV(base, .82, .56);\n    vec3 fourth = adjustSV(base, .2, .96);\n\n    //vec3 first = vec3(0.0 / 255.0, 209.0 / 255.0, 193.0 / 255.0);\n    //vec3 second = vec3(110.0 / 255.0, 230.0 / 255.0, 217.0 / 255.0);\n    //vec3 third = vec3(26.0 / 255.0, 143.0 / 255.0, 124.0 / 255.0);\n    //vec3 fourth = vec3(193.0 / 255.0, 245.0 / 255.0, 240.0 / 255.0);\n    // vec3 babu1 = vec3(0.0 / 255.0, 209.0 / 255.0, 193.0 / 255.0);\n    \n    float x4 = ((uv + 1.0) / 2.0) * 4.0;\n    \n    if (x4 <= 1.0) {\n        return mix(first, second, mod(x4, 1.0));\n    }\n    \n    if (x4 > 1.0 && x4 <= 2.0) {\n        return mix(second, third, mod(x4, 1.0));\n    }\n\n    if (x4 > 2.0 && x4 <= 3.0) {\n        return mix(third, fourth, mod(x4, 1.0));\n    }\n\n    //if (x4 > 3.0 && x4 <= 4.0) {\n        return mix(fourth, first, mod(x4, 1.0));\n    //}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 1.3;\n    float offset = 0.5;\n    \n    vec3 top_left = colorFor(baseColorFor(0.99 * iTime + sin(0.06 * iTime)), sin(speed * 0.06 * iTime + 1.0 + offset));\n    vec3 top_right = colorFor(baseColorFor(0.98 * iTime + sin(0.16 * iTime)), sin(speed * 0.1 * iTime + 2.0 + offset));\n        \n    vec3 bottom_left = colorFor(baseColorFor(0.97 * iTime + sin(0.9 * iTime)), sin(speed * 0.12 * iTime + 5.0 + offset));\n    vec3 bottom_right = colorFor(baseColorFor(0.96 * iTime + sin(0.5 * iTime)), sin(speed * 0.09 * iTime + 6.0 + offset));\n    \n    \n    //vec3 top_left = mix(babu2, kazan3, 0.8 * sin(iTime));\n    //vec3 top_right = mix(kazan1, babu2, 0.9 * sin(iTime));\n        \n    //vec3 bottom_left = mix(kazan2, babu1, 0.7 * sin(iTime));\n    //vec3 bottom_right = mix(babu3, kazan2, 1.2 * sin(iTime));\n    \n\tfloat ymix = fragCoord.y / iResolution.y;\n    vec3 left = mix(top_left, bottom_left, ymix);\n    vec3 right = mix(top_right, bottom_right, ymix);\n    \n    float xmix = fragCoord.x / iResolution.x;\n    \n    fragColor = vec4(mix(left, right, xmix), 1.0);\n    \n\t// fragColor = vec4(uv,0.5+1.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3GD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 353], [355, 355, 377, 377, 540], [542, 542, 573, 573, 1128], [1130, 1130, 1173, 1173, 1259], [1261, 1261, 1297, 1297, 2206], [2208, 2208, 2265, 2265, 3392]], "test": "valid"}
{"id": "Ml3GRX", "name": "Void Sphere", "author": "foil", "description": "Example of pulsating effect based on smoothstep and sin functions.", "tags": ["2d", "pulse", "circle"], "likes": 4, "viewed": 242, "published": "Public", "date": "1470488267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pulseCircle(vec2 p, float r)\n{\n    float l = length(p) - r;\n    return smoothstep(2.5,3.0,2.*sin(3.5/l + 6.*iTime) + 0.2/l);\n}\n\nfloat hash(vec2 co){\n    return sin( 2355.44 * fract(sin(dot(co.xy ,vec2(12.9898,78.233)))  * 43758.5453));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;    \n\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    vec3 color = vec3(hash(uv*iTime*0.2));\n\n    bg = mix(bg, color, pulseCircle(uv - vec2(0.9, 0.5), 0.20));\n\n    fragColor = vec4(bg, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3GRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 132], [134, 134, 154, 154, 243], [245, 245, 302, 302, 531]], "test": "valid"}
{"id": "Ml3GWs", "name": "post: smooth brightness", "author": "hornet", "description": "Using smooth-minimum for brightness adjustment (see https://www.shadertoy.com/view/ltf3W2 )\nControls: LMB + \nmouse x: control white cutoff\nmouse y: control cutoff softness.\n\nRed is area of effect. Can be combined with blacklift / gamma-adjustment.", "tags": ["postfx", "post", "brightness", "soft", "smooth", "levels", "smoothmin", "softmin"], "likes": 27, "viewed": 3390, "published": "Public API", "date": "1472477671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash32n(vec2 n)\n{\n    return fract( sin(dot(n.xy, vec2(12.9898, 78.233)))* vec3(43758.5453, 28001.8384, 50849.4141 ) );\n}\n\nvec3 remap( float a, float b, vec3 v ) {\n    //return (v-a) / (b-a);\n\treturn clamp( (v-vec3(a)) / vec3(b-a), 0.0, 1.0 );\n}\n\nvec3 remap_noclamp( float a, float b, vec3 v )\n{\n\treturn (v-vec3(a,a,a)) / (b-a);\n}\n\nvec3 lin2srgb( vec3 c )\n{\n    return pow( c, vec3(1.0/2.2) );\n}\nvec3 srgb2lin( vec3 c )\n{\n    return pow( c, vec3(2.2) );\n}\n\n\n// ============================================\n\n\n//note: smooth minium, soft-min\n//      https://www.shadertoy.com/view/ltf3W2\nfloat SAbs(float x, float k)\n{\n    return sqrt(x * x + k);\n}\n\nfloat SRamp1(float x, float k)\n{\n    return 0.5 * (x - SAbs(x, k));\n}\n\nfloat SMin1(float a, float b, float k)\n{\n    return a + SRamp1(b - a, k);\n}\n//note: smax = -smin(-a, -b, k )\nvec3 SMin1(vec3 a, vec3 b, float k)\n{\n    return vec3( SMin1( a.r, b.r, k ),\n\t\t\t     SMin1( a.g, b.g, k ),\n\t\t\t     SMin1( a.b, b.b, k ) );\n}\n\nvec3 gamma_softmin( vec3 x, float t )\n{\n    //note: sensible defaults for single-parameter control (t)\n    //note: black-cutoff, white-cutoff, power, soft-clipping\n    vec4 parms = mix( vec4( 0.0, 1.0, 0.0, 0.0 ),\n                      vec4( 0.0, 0.25, 0.25, 1.0 ), t );\n    //float blacklift = mix( 0.0, 0.0, t );\n    \n    vec2 mt = iMouse.xy / iResolution.xy;\n    if ( iMouse.z > 0.5 )\n    {\n        parms = vec4( 0.0, mt.x, 0.0, 5.0 * max(0.0, pow(mt.y,4.0)) );\n        //blacklift = 0.0;\n    }\n\n\tx = max( x, parms.xxx ); //note: clamp below min\n\tx = remap_noclamp( parms.x, parms.y, x );\n\n\t//float pexp = 1.0 / (1.0 - 0.5*parms.z);\n\t//x = pow( x, vec3(pexp, pexp, pexp) );\n\n\t//x = x * (1.0-blacklift) + blacklift;\n\n\tfloat pmin = parms.w;\n\tx = SMin1( x, vec3(1.0, 1.0, 1.0), pmin ); //upper\n\n\treturn x;\n}\n\n\n// ============================================\n\n\nvec3 gamma( vec3 x, float t )\n{\n    vec3 softmin = gamma_softmin( x, t );\n    \n    //note: renormalize (0,0) and (1,1) values\n    //note: should be done in app or vertex-shader\n    float softmin0 = gamma_softmin( vec3(0,0,0), t ).r;\n    float softmin1 = gamma_softmin( vec3(1,1,1), t ).r;\n    \n    return remap( softmin0, softmin1, softmin);\n}\n\nfloat f( float x, float t )\n{\n\treturn gamma( vec3(x), t ).r;\n}\n\nfloat calcCurve( vec2 uv, float t )\n{\n    float threshold = 7.0 / iResolution.y;\n    float fx = f( uv.x, t );\n    float dist = abs( uv.y - fx );\n    return max( 0.0, 15.0 * ( threshold - dist ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0-uv.y;\n    \n    vec3 col = srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n\n    float t = 0.5 + 0.5 * sin( iTime );\n\n    if ( iMouse.z > 0.5 )\n    {\n        t = iMouse.x / iResolution.x;\n    }\n\n    if ( uv.y > 0.9 )\n    \tcol = vec3( fract( uv.x ) );\n\n\n    col = gamma(col, t );\n    \n    if ( uv.y < 0.9 && uv.y > 0.7 )\n    {\n        vec2 guv;\n        guv.x = uv.x;\n        guv.y = 1.0-(uv.y-0.7) / (0.9-0.7);\n\n        vec3 curveits;\n        curveits = vec3( calcCurve( guv, t ) );\n\n        vec3 curvecol = vec3(1,1,1);\n        \n        vec2 mt = iMouse.xy / iResolution.xy;\n        float f0 = f(guv.x, t);\n        float f1 = min( 1.0, 1.0/mt.x * guv.x );\n        float fdiff = f1-f0;\n        if ( iMouse.z > 0.5 )\n        {\n            col.r += step( abs(guv.x-mt.x), 1.0 / iResolution.x );\n\n            //float f0 = f(guv.x, t);\n            //float f1 = min( 1.0, 1.0/mt.x * guv.x );\n            //col.r += step( f0, guv.y) * step( guv.y, f1 );\n           \t//float fdiff = f1-f0;\n           \tcurvecol = mix(vec3(1,1,1), vec3(1,0,0), fdiff * step( 0.01, fdiff ) );\n        }\n        \n        col = mix( vec3(0.025, 0.025, 0.025), curvecol, curveits );\n        \n        //note: grid\n        col += 0.0125 * vec3( step(0.975, 1.0-2.0*abs(fract(10.0*guv.x-0.5)-0.5)) );\n        col += 0.0125 * vec3( step(0.925, 1.0-2.0*abs(fract(4.0*guv.y-0.5)-0.5)) );\n\n        if ( iMouse.z > 0.5 )\n        {\n        \tcol.r += 0.125 * step( 0.01, fdiff ); //note: mouse-extents\n        \t//col.r += step( f0, guv.y) * step( guv.y, f1 ); //note: absolute diff            \n        }\n    }\n\n    //note: show white-clipped area\n    //float lum = sqrt( 0.299*col.r*col.r + 0.587*col.g*col.g + 0.114*col.b*col.b );\n    //if ( iMouse.z > 0.5 && lum > 0.99 )\n    //    col = mix( vec3(0,0,0), col, step(fract(iTime),0.5) );\n    \n    if ( uv.y > 0.9 )\n        col = srgb2lin( col );\n    \n    vec4 outcol = vec4( lin2srgb(col), 1.0 );\n    vec3 trnd = hash32n( uv + fract(iTime) ) + hash32n( uv + 0.1337 + fract(iTime) ) - 0.5;\n    outcol.rgb += trnd / 255.0;\n\tfragColor = outcol;\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3GWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 126], [128, 128, 168, 196, 250], [252, 252, 300, 300, 335], [337, 337, 362, 362, 400], [401, 401, 426, 426, 460], [513, 591, 621, 621, 651], [653, 653, 685, 685, 722], [724, 724, 764, 764, 799], [800, 833, 870, 870, 973], [975, 975, 1014, 1138, 1782], [1785, 1835, 1866, 1866, 2178], [2180, 2180, 2209, 2209, 2242], [2244, 2244, 2281, 2281, 2442], [2444, 2444, 2501, 2501, 4612]], "test": "error"}
{"id": "Ml3Gzs", "name": "Overcast Sky - Variable ", "author": "CaliCoastReplay", "description": "2.5d clouds, using hcf's really nice Perlin noise implementation at :  https://www.shadertoy.com/view/Md3SzB\n\nMouse up/down to change the level of cloud cover.  Mouse left/right to change zoom.", "tags": ["2d", "3d", "noise", "clouds", "zoom", "perlin"], "likes": 3, "viewed": 282, "published": "Public", "date": "1470866360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Adapted from  :  https://www.shadertoy.com/view/Md3SzB\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat hash21(vec2 p)\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return  -1.+2.*fract(sin(h)*43758.5453123);\n}\n\nvec2 hash22(vec2 p)\n{\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283 + iTime/4.0);\n}\n\nfloat perlin_noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = p-pi;\n    \n    vec2 w = pf*pf*(3.-2.*pf);\n    \n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float xm1 = mix(f00,f10,w.x);\n    float xm2 = mix(f01,f11,w.x);\n    \n    float ym = mix(xm1,xm2,w.y); \n    return ym;\n   \n}\n\nfloat noise(vec2 p){\n    p *= 4.;\n\tfloat a = 1., r = 0., s=0.;\n    \n    for (int i=0; i<9; i++) {\n      r += a*perlin_noise(p); s+= a; p *= 2.00; a*=.57;\n    }\n    \n    return r/s;///(.1*3.);\n}\n\n\nvec3 sphereProject(vec2 plane)\n{\n    vec3 r;\n    plane.x -= 0.55;\n    plane.y -= 0.35;\n    float denom = (1.0 + plane.x*plane.x + plane.y*plane.y);\n    r.x = (2.0*plane.x)/denom;    \n    r.y = (2.0*plane.y)/denom;\n    r.z = (1.0 - plane.x*plane.x+plane.y*plane.y)/denom;\n    return r*1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy \n        * 0.6;//+sin(iTime/5.0)/9.0);\n    \n    uv *= vec2(iResolution.x/iResolution.y,1.);\n    vec3 sphere = sphereProject(uv);\n    uv = sphere.xy/2.1;\n    if (iMouse.z > 0.0)        \n    \tuv = 0.6*sphere.xy*iMouse.x/iResolution.x;\n     \n    vec2 uv2 = uv + vec2(0.12253 + iTime/210.0,0.73483-iTime/90.3);\n    vec2 uv3 = uv + vec2(0.34646 - iTime/150.3,0.46436 - iTime/180.4);\n    vec2 uv4 = uv + vec2(0.98398 - iTime/34.5,0.11242 + iTime/100.7);\n    float f = noise(uv)/1.0;\n  //  f+= noise(uv2)/2.2;\n    f+= noise(uv3)/2.45;\n    f+= noise(uv4)/0.7;\n  \n    \n    f = f*0.35+0.55;\n    \n    vec3 lightColor = vec3(0.719,0.719,1.0);\t\n    vec3 color = vec3(lightColor*f);\n    \n    vec3 hsv = rgb2hsv(color);\n    hsv.z += 0.5;\n    \n    float cloudCoverFactor = 0.01; \n    if (iMouse.z > 0.0)\n       cloudCoverFactor = (iMouse.y / iResolution.y) / 2.0 - .261;\n    hsv.z *= hsv.z * hsv.z * sqrt(hsv.z)* 2.01 * (cloudCoverFactor + 0.91);\n    bool deblue = false;\n\tif (hsv.z > 2.75)\n    {\n        hsv.z =4.7 - hsv.z/2.11;\n        hsv.z -= 0.559;\n        deblue = true;\n    }\n    else\n    {\n     //   hsv.y *= 0.9;\n        hsv.z -= 0.041;\n    }\n    //hsv.y += 0.345;\n //   \n    hsv.y *= 2.2;\n    hsv.z -= 0.01;\n    color = hsv2rgb(hsv);\n    \n   \tif (deblue)\n    {\n        color.z = color.y = color.x * .91;\n        color.x -= 0.07;\n       \n    }\n\tfragColor = vec4(color,1.0);\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3Gzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 80, 80, 410], [412, 412, 434, 434, 603], [606, 606, 628, 628, 717], [719, 719, 740, 740, 864], [866, 866, 894, 894, 1353], [1355, 1355, 1375, 1375, 1548], [1551, 1551, 1583, 1583, 1841], [1843, 1843, 1900, 1900, 3313]], "test": "valid"}
{"id": "Mlc3R2", "name": "logo bats", "author": "tomaes", "description": "a different kind of logo animation", "tags": ["logo", "pseudo3d", "design"], "likes": 1, "viewed": 126, "published": "Public", "date": "1470254915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COORDS 39\n#define OFFX .2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    float t = iTime;\n    \n    float c[COORDS];\n    // \"l\"\n    c[0] = .5; c[1] = .6; c[2] = .045;\n    c[3] = .5; c[4] = .5; c[5] = .045;\n    c[6] = .5; c[7] = .4; c[8] = .045;\n    c[9] = .6; c[10]= .4; c[11]= .045;\n\t// \"o\"\n    c[12] = .825; c[13] = .6+sin(t)*.1; c[14]=.15 + sin(t*5.)*.1;\n    // \"g\"\n    c[15] = 1.2; c[16] = .65;c[17] = .045;\n    c[18] = 1.1; c[19] = .6; c[20] = .045;\n    c[21] = 1.1; c[22] = .5; c[23] = .045;\n    c[24] = 1.1; c[25] = .4; c[26] = .045;\n    c[27] = 1.2; c[28] = .4; c[29] = .045;\n    c[30] = 1.3; c[31] = .4; c[32] = .045;\n    c[33] = 1.3; c[34] = .5; c[35] = .045;    \n    // \"o\" (2)\n    c[36] = 1.55; c[37] = .6-sin(t)*.1; c[38]=.15 + cos(t*5.)*.1;\n    \n    float col = .5;\n\n    for( int p = 0; p < COORDS; p += 3)\n    {        \n        if (distance( vec2(c[p]-OFFX,c[p+1]), uv ) < c[p+2])\n            col = .5 + sin( t + float(p) ) * .5;\n        \n        if ((distance( vec2(c[p]-OFFX+.02,c[p+1]), uv ) < c[p+2]) &&\n            (distance( vec2(c[p]-OFFX+.01,c[p+1]), uv)  > c[p+2]*.2))\n            col += .3 + sin( t + float(p) ) * .5;\n                \n        // \"bats\"\n        if (  ((abs(uv.x-c[p]+OFFX-.01)) < sin(uv.y*15.+t*5.)*.05) &&\n              ((abs(uv.x-c[p]+OFFX-.01)) > sin(uv.y*14.+t*5.)*.05)  )\n        \tcol *= .5/col;     \n    }\n    \n    // 3d background\n    if (uv.x > .1 && uv.x < 1.67)\n        col *= mod(col+.0001/sin(uv.x-uv.y),mod(t*.1+cos(uv.x*.5+uv.y*.5),.35))*10.;\n    \n\tfragColor = vec4(col*uv.x*.4, col*.5, col*.4, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlc3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 92, 92, 1625]], "test": "valid"}
{"id": "Mlc3WB", "name": "Shading test", "author": "rimina", "description": "On my way to find nice looking shading.", "tags": ["raymarching", "reflection", "refraction", "shading"], "likes": 2, "viewed": 195, "published": "Public", "date": "1471265192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 80.0\n#define FAR_R 80.0\n#define STEPS 80\n#define GAMMA vec3(2.2)\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n\nfloat fSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n    vec3 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    return c;\n}\n\nfloat sdf(vec3 p){\n    \n    //some performance tests...\n    //pMod2(p.xz, vec2(10.));\n    //pMod3(p, vec3(10.));\n    \n    return min(fSphere(p-vec3(-1.0, 0. ,0.), 0.5),min(fBox(p, vec3(0.025, 1.0, 1.5)), fBox(p-vec3(1.0, 0. , 0.), vec3(0.5))));\n}\n\nvec3 normal( vec3 p ){\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tsdf(p+eps.xyy)-sdf(p-eps.xyy),\n\t\tsdf(p+eps.yxy)-sdf(p-eps.yxy),\n\t\tsdf(p+eps.yyx)-sdf(p-eps.yyx)\n\t));\n}\n\n//Ambien occlusion & shadow coeffience function modified from\n//las's (Mercury) and dechipher's (YUP) methods from pouet raymarching thread\n//PRAMETERS:\n//  p = position,\n//  n = normals (ao) or unit vector of light direction (shadow)\n//  k = constant\n\nfloat ambientOcclusion(vec3 p, vec3 n, float k){\n    float s = sgn(k);\n    float o = s*.5+.5;\n    for(float i = 0.; i < 6.; ++i){\n        o -= (i*k - sdf(p+n*i*k*s))/exp2(i);\n    }\n    return max(min(o, 1.), 0.);\n}\n\nvec3 march(in vec3 ro, in vec3 rd, inout float t){\n\n    vec3 p = ro;\n    for(int i = 0; i < STEPS; ++i){\n        float d = sdf(p);\n        t += d;\n        p += rd*d;\n        \n        if(d < 0.01 || t > FAR){\n            break;\n        }\n        \n    }\n    return p;\n}\n\n\nmat4 marchRF(in vec3 ro, in vec3 rd, in vec3 ro2, in vec3 rd2, inout vec2 t){\n    vec3 n = normal(ro);\n    vec3 n2 = normal(ro2);\n    \n    vec3 rdRefract= refract(rd2, n2, 1.31);\n    \n    vec3 rdReflect = reflect(rd, n);\n    \n    vec3 pRefract = ro2;\n    vec3 pReflect = (ro+(0.01*n));\n    \n    bool refractDone = false;\n    bool reflectDone = false;\n    \n    for(int i = 0; i < STEPS; ++i){\n        float d1 = sdf(pRefract);\n        float d2 = sdf(pReflect);\n        \n        if(!refractDone){\n             t.x += d1;\n             pRefract += rdRefract*d1;\n        }\n        \n        if(!reflectDone){\n        \tt.y += d2;\n        \tpReflect += rdReflect*d2;\n        }\n        \n        if(d1 < 0.0001 || t.x > FAR_R){\n            refractDone = true;\n        }\n        \n        if(d2 < 0.0001 || t.y > FAR_R){\n            reflectDone = true;\n        }\n        \n        if(refractDone && reflectDone){\n            break;\n        }\n        \n    }\n    \n    return mat4(\n        vec4(pRefract, 0.),\n        vec4(pReflect, 0.),\n        vec4(rdRefract, 0.),\n    \tvec4(rdReflect, 0.));\n    \n}\n\nvec3 shade(in vec3 p, in vec3 ld, in vec3 rd){\n    vec3 n = normal(p);\n    \n    float lambertian = max(dot(-ld, n), 0.0);\n    float angle = max(dot(reflect(-ld, n), rd), 0.0);\n    float specular = pow(angle, 80.0);\n    \n    float ao = ambientOcclusion(p, n, 0.5);\n    \n    \n    vec3 c = ao*vec3(0.5)+lambertian*vec3(0.5, 0.5, 0.6)*0.5+specular*vec3(0.6)*0.6;\n    return c;\n}\n\n\n\n\n// Functio to set camera\n// o = camera origin\n// target = camera target (lookAt)\n// cr = right angle\nmat3 setCamera(vec3 o, vec3 target, float cr ){\n\tvec3 cw = normalize(target-o);//z\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);//up\n\tvec3 cu = normalize( cross(cw,cp) );//x\n\tvec3 cv = normalize( cross(cu,cw) );//y\n\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 v = -1.0+2.0*uv;\n    v.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(cos(iTime*0.5)*3.5, 0.0, sin(iTime*0.5)*3.5);\n    vec3 rt = vec3(0., 0., 0.);\n    \n    mat3 cam = setCamera(ro, rt, 0.);\n    vec3 rd = normalize(cam*vec3(v.xy, radians(90.)));\n    \n    float t = 0.01;\n    vec3 p = march(ro, rd, t);\n    \n    vec3 ld = (rt-ro)/distance(rt, ro);\n\tfragColor.rgb = shade(p, ld, rd);\n    fragColor.a = 1.0;\n     \n    if (t < FAR){\n        \n        vec3 col = vec3(1.);\n        vec3 p2 = p;\n        vec3 rd2 = rd;\n        for(int i = 0; i < 8; ++i){\n        \n            vec2 td = vec2(0.);\n            mat4 pr = marchRF(p, rd, p2, rd2, td);\n\n            if(td.x < FAR_R){\n               col = shade(pr[0].xyz, ld, pr[2].xyz);\n               fragColor.rgb = mix(fragColor.rgb, col, 0.25);\n                \n                p2 = pr[0].xyz;\n                rd2 = pr[2].xyz;\n            }\n            if(td.y < FAR_R){\n                col = shade(pr[1].xyz, ld, pr[3].xyz);\n                fragColor.rgb = mix(fragColor.rgb, col, 0.25);\n                \n                p = pr[1].xyz;\n                rd = pr[3].xyz;\n            }\n            else{\n                fragColor.rgb = mix(fragColor.rgb, vec3(1.), 0.042);\n                break;\n            }\n        }\n    }\n    else{\n        fragColor = vec4(1.);\n    }\n    \n    \n    fragColor.rgb = pow(fragColor.rgb, 1.0/GAMMA);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlc3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 98, 98, 123], [125, 125, 146, 146, 181], [184, 184, 215, 215, 241], [243, 243, 271, 271, 353], [355, 355, 392, 392, 483], [485, 485, 522, 522, 623], [625, 625, 643, 737, 871], [873, 873, 895, 895, 1060], [1062, 1315, 1363, 1363, 1529], [1531, 1531, 1581, 1581, 1798], [1801, 1801, 1878, 1878, 2884], [2886, 2886, 2932, 2932, 3260], [3265, 3366, 3413, 3413, 3607], [3609, 3609, 3666, 3666, 5101]], "test": "valid"}
{"id": "MlcGDB", "name": "Draw Line & Line Segment", "author": "gPlatl", "description": "Draw antialiased endless line and line segment with given thickness.\nUse mouse to define 2nd segment point.", "tags": ["2d", "line", "draw", "antialiased", "linesegment"], "likes": 5, "viewed": 1116, "published": "Public", "date": "1471282240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// DrawLineAndSegment.glsl\n//--- draw antialiased endless line and line segment with given thickness ---\n\n// draw line segment from A to B\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\n// draw endless line trough A and B\nfloat line(vec2 P, vec2 A, vec2 B, float r)\n{\n\tvec2 g = B - A;\n    float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\nconst vec3 backColor  = vec3(0.3);\nconst vec3 lineColor1 = vec3(0.35,0.95,0.51);\nconst vec3 lineColor2 = vec3(0.95,0.95,0.10);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mo = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    float thickness = (0.7+0.4*sin(iTime)) * 0.051;\n    vec3 color = backColor;\n\n    // draw endless line\n    float intensity = line(uv, vec2(0.0), mo, thickness*0.5);\n    color = mix(color, lineColor1, intensity);\n\n    // draw line segment\n    intensity = segment(uv, vec2(0.0), mo, thickness);\n    color = mix(color, lineColor2, intensity);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 142, 191, 191, 335], [337, 373, 418, 418, 529], [659, 659, 716, 716, 1232]], "test": "valid"}
{"id": "MlcGRj", "name": "Clothes Pin", "author": "Sobaya", "description": "clothes pin", "tags": ["3ddistancefield"], "likes": 5, "viewed": 157, "published": "Public", "date": "1470223842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nconst float fov = 0.2;\nconst float eps = 0.001;\nconst float pi = 3.1415926535;\n\nfloat rand(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 114514.1919810))) * 43758.5453);\n}\n\nfloat interpolate(float x, float y, float t) {\n  t = t * t * (3. - 2. * t);\n  return x * (1.-t) + y * t;\n}\n\nfloat irand(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  float rand1 = rand(i);\n  float rand2 = rand(i+vec3(1,0,0));\n  float rand3 = rand(i+vec3(0,0,1));\n  float rand4 = rand(i+vec3(1,0,1));\n  float rand5 = rand(i+vec3(0,1,0));\n  float rand6 = rand(i+vec3(1,1,0));\n  float rand7 = rand(i+vec3(0,1,1));\n  float rand8 = rand(i+vec3(1,1,1));\n  float t1 = interpolate(rand1, rand2, f.x);\n  float t2 = interpolate(rand3, rand4, f.x);\n  float t3 = interpolate(rand5, rand6, f.x);\n  float t4 = interpolate(rand7, rand8, f.x);\n  float s1 = interpolate(t1, t2, f.z);\n  float s2 = interpolate(t3, t4, f.z);\n  return interpolate(s1, s2, f.y);\n}\n\nfloat noise(vec3 p) {\n  float t = 0.;\n  for (int i = 0; i < 8; i++) {\n    float freq = pow(2., float(i));\n    float amp = pow(0.5, float(8-i));\n    t += irand(p / freq) * amp;\n  }\n  return t;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 rotate(vec3 p, vec3 n, float a) {\n  a *= pi / 180.;\n  float c = cos(a);\n  float s = -sin(a);\n   mat3 m = mat3(\n       n.x*n.x*(1.-c)+c, n.x*n.y*(1.-c)+n.z*s, n.x*n.z*(1.-c)-n.y*s,\n       n.y*n.x*(1.-c)-n.z*s, n.y*n.y*(1.-c)+c, n.y*n.z*(1.-c)+n.x*s,\n       n.z*n.x*(1.-c)+n.y*s, n.z*n.y*(1.-c)-n.x*s, n.z*n.z*(1.-c)+c\n       );\n   return m * p;\n}\n\nvec3 scale(vec3 p, vec3 s) {\n  return p / s;\n}\n\nfloat poll(vec3 p) {\n  p = scale(p, vec3(1.2, 1.5, 1));\n  p = translate(p, vec3(-0.5,0.3,0));\n  vec2 d = abs(vec2(length(p.xy), p.z)) - 1.;\n  float result = min(max(d.x, d.y), 0.) + length(max(d, 0.));\n  result = max(result, -p.y);\n  return result;\n}\n\nfloat poll2(vec3 p) {\n  p = translate(p, vec3(-4.2,1.5,0));\n  p = rotate(p, vec3(0,0,1), 20.);\n  p = scale(p, vec3(2, 1.5, 15));\n  vec2 d = abs(vec2(length(p.xy), p.z)) - 1.;\n  float result = min(max(d.x, d.y), 0.) + length(max(d, 0.));\n  return result;\n}\n\nfloat body(vec3 p) {\n  float sub3 = p.y + 0.5;\n  const float freq = 0.1;\n  float triWave = (1. - abs(mod(p.x*10.,2.)-1.)) * 0.2;\n  vec3 n = normalize(vec3(-0.3, 1, 0));\n  float sub2 = dot(p - vec3(-4.2, 1.2, 0) - n * triWave, normalize(-n));\n  p = translate(p, vec3(10. / 18. + 0.3, 0,0));\n  float result = length(max(abs(p) - vec3(10,1,1), 0.0));\n  float sub = dot(p - vec3(0,0.5,0), normalize(vec3(0.15,1,0)));\n  result = max(result, sub);\n  result = max(result, -sub2);\n  result = max(result, -sub3);\n  return result;\n}\n\nfloat ringOnly(vec3 p) {\n  float rate = 1. + (sin(iTime /10.) + 1.) * 0.05;\n  p = scale(p, vec3(rate,1,rate));\n  vec2 q = vec2(length(p.xy) - 4., p.z);\n  float result = length(q) - 0.3;\n  return result;\n}\n\nfloat ball(vec3 p) {\n  p = scale(p, vec3(0.5,0.5,10) );\n//  p = translate(p, vec3(0,-7,0));\n  return length(p) - 1.;\n}\n\nfloat side(vec3 p) {\n  float sub3 = length(p - vec3(0,-4,0)) - 1.2;\n  p = scale(p, vec3(0.65, 1,1));\n  p.x = abs(p.x);\n  p = translate(p, vec3(1.2,0,0));\n  p = rotate(p, vec3(0,0,1), 74. + 8. * (sin(iTime * 2.) + 1.));\n  //p = rotate(p, vec3(0,0,1), 76);\n  p = translate(p, vec3(0.5, -1.4, 0));\n  float sub2 = poll2(p);\n  float result = body(p);\n  result = smin(result, poll(p), 4.);\n  result = max(result, abs(p.z) - 1.);\n  result -= 0.5;\n  result = max(result, -sub2);\n  result = max(result, -sub3);\n  return result;\n}\n\nfloat ring(vec3 p) {\n  float sub3 = length(p - vec3(0,-4,0)) - 1.2;\n  float r = ringOnly(p);\n  p = scale(p, vec3(0.65, 1,1));\n  p.x = abs(p.x);\n  p = translate(p, vec3(1.2,0,0));\n  p = rotate(p, vec3(0,0,1), 74. + 8. * (sin(iTime * 2.) + 1.));\n  //p = rotate(p, vec3(0,0,1), 76);\n  p = translate(p, vec3(0.5, -1.4, 0));\n  float sub2 = poll2(p);\n  float result = r;\n  result = max(result, -sub2);\n  result = max(result, -sub3);\n  return result;\n}\n\nfloat dist(vec3 p) {\n  float result = side(p);\n  result = min(result, ring(p));\n  return result;\n}\n\nint getNearestIndex(vec3 p) {\n  float minDist = side(p);\n  int idx = 0;\n  float d = ring(p);\n  if (d < minDist) {\n    minDist = d;\n    idx = 1;\n  }\n  return idx;\n}\n\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n        dist(p+vec3(eps,0,0)) - dist(p),\n        dist(p+vec3(0,eps,0)) - dist(p),\n        dist(p+vec3(0,0,eps)) - dist(p)\n      ));\n}\n\n\nvec3 rayMarch(vec3 eye, vec3 ray) {\n  vec3 current = eye;\n  for (int i = 0; i < 200; i++) {\n    float d = dist(current);\n    current += ray * d;\n    if (abs(d) < eps) {\n      break;\n    }\n  }\n  return current;\n}\n\nvec2 cubeMap(vec3 current, vec3 vec) {\n  vec2 result;\n  vec3 tmp;\n  float minT = 1145141919.;\n  float size = 100.;\n  float t;\n\n  //===========x\n  t = (size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n    minT = t;\n  }\n\n  t = (-size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n    minT = t;\n  }\n\n  //===============y\n  t = (size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n    minT = t;\n  }\n\n  t = (-size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n    minT = t;\n  }\n\n  //==============z\n  t = (size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n    minT = t;\n  }\n\n  t = (-size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n    minT = t;\n  }\n  return result  / (2. * size) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float a = -.5 * iTime;\n    float c = cos(a);\n    float s = sin(a);\n    vec3 n = normalize(vec3(1,1,0));\n    mat3 rot;\n\trot[0][0] = n[0]*n[0]*(1.-c)+c;\n\trot[0][1] = n[0]*n[1]*(1.-c)-n[2]*s;\n\trot[0][2] = n[2]*n[0]*(1.-c)+n[1]*s;\n\trot[1][0] = n[0]*n[1]*(1.-c)+n[2]*s;\n\trot[1][1] = n[1]*n[1]*(1.-c)+c;\n\trot[1][2] = n[1]*n[2]*(1.-c)-n[0]*s;\n\trot[2][0] = n[2]*n[0]*(1.-c)-n[1]*s;\n\trot[2][1] = n[1]*n[2]*(1.-c)+n[0]*s;\n\trot[2][2] = n[2]*n[2]*(1.-c)+c;\n\n\tvec3 eye = vec3(0,0,-15);\n\teye = rot * eye;\n\tvec3 ray = vec3(uv, sqrt(2.) * tan(fov));\n\tconst float angle = 1.5;\n\tray = vec3(sin(uv * angle), length(cos(uv * angle)));\n\tray = rot * ray;\n\tray = normalize(ray);\n\tvec3 current = rayMarch(eye, ray);\n\n\tvec3 lightPos = vec3(1,1,-1) * 10.;\n\n\tif (abs(dist(current)) < eps) {\n    \tvec3 n = getNormal(current);\n    \tvec3 eyeVec = normalize(eye - current);\n   \t\tvec3 lightVec = normalize(lightPos - current);\n    \tvec3 refVec = reflect(-lightVec, n);\n    \tfloat diffuse = max(0.,dot(eyeVec, n));\n    \tfloat spec = max(0.,dot(eyeVec, refVec));\n    \tvec4 reflectColor = texture(iChannel0, cubeMap(current, reflect(-eyeVec, n)));\n      \tint idx = getNearestIndex(current);\n      \tif (idx == 0) {\n        \tfloat refRate = 0.05;\n        \tfragColor = vec4(0.9,0.7,0.7,1) * diffuse;\n        \tfragColor = fragColor * (1.-refRate) + reflectColor * refRate;\n        \tfragColor += pow(spec, 5.) * 0.2;\n      \t} else if (idx == 1) {\n        \tfragColor = reflectColor * 0.2 + vec4(0.5, 0.5 ,0.5, 1) * 0.8;\n        \tfragColor *= diffuse;\n        \tfragColor += pow(spec, 5.);\n      \t} else if (idx == 2) {\n            fragColor = vec4(0,0,0,1) * diffuse;\n      \t} else {\n        \tfragColor = vec4(0,0,1,1);\n      \t}\n\t} else {\n    \tfragColor = vec4(0.25);\n    \tfragColor.a = 1.;\n  \t}\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 124, 124, 207], [209, 209, 255, 255, 315], [317, 317, 338, 338, 959], [961, 961, 982, 982, 1154], [1156, 1156, 1195, 1195, 1262], [1264, 1264, 1296, 1296, 1314], [1316, 1316, 1354, 1354, 1666], [1668, 1668, 1696, 1696, 1714], [1716, 1716, 1736, 1736, 1966], [1968, 1968, 1989, 1989, 2223], [2225, 2225, 2245, 2245, 2747], [2749, 2749, 2773, 2773, 2953], [2955, 2955, 2975, 2975, 3073], [3075, 3075, 3095, 3095, 3595], [3597, 3597, 3617, 3617, 4042], [4044, 4044, 4064, 4064, 4142], [4144, 4144, 4173, 4173, 4307], [4309, 4309, 4333, 4333, 4492], [4495, 4495, 4530, 4530, 4706], [4708, 4708, 4746, 4746, 5791], [5793, 5793, 5850, 5850, 7710]], "test": "error"}
{"id": "MlcGRl", "name": "HV Splits", "author": "benoitM", "description": "Subdivision of space by alternating horizontal and vertical splits recusively", "tags": ["abstract", "recursive", "split", "zone"], "likes": 2, "viewed": 565, "published": "Public API", "date": "1470817199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Benoit Marini - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int iter = 10;\n\n\nfloat partitions (int i, int j)\n{\n    float a=sin(float(i*j)+iTime*float(j)*0.33);\n    return 0.25+(a+1.)*0.25;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 colorForZone (vec2 res)\n{\n    float t = res.x/pow(2., float(iter))+res.y*0.15;\n    return palette(t,vec3(0.5),vec3(0.5),vec3(1.0),vec3(0.,0.33,0.66));\n}\n   \n\n\nvec2 HVdivide (vec2 p)\n{\n    int zone = 0;\n    int a=1;\n    //float cc= cos(iTime*1.);\n    float ss= sin(iTime*0.23);\n    \n    for (int i=0;i<iter;i++)\n\t{\n\t\tfloat seuil = partitions(zone,i);\n        //float cc= cos(iTime*1.+float(zone));\n    \t//float ss= sin(iTime*1.+float(zone));\n\n        float tt=p.x;//cc*p.x+ss*p.y;\n        seuil-=ss*p.y;\n        float s=sign(tt-seuil);\n        s=(s+1.)*0.5;\n        zone+=a*int(s);\n        p.x =s*(p.x-seuil)/(1.-seuil) + (1.-s) *p.x/seuil;\n        a*=2;\n        p=vec2(p.y, 1.-p.x);\n    }\n    \n    return vec2(float(zone),1.-p.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = colorForZone(HVdivide(uv));\n\n    fragColor = vec4(col.xyz,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcGRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 146, 179, 179, 259], [262, 262, 334, 334, 377], [379, 379, 409, 409, 536], [543, 543, 567, 567, 1116], [1120, 1120, 1177, 1177, 1299]], "test": "valid"}
{"id": "MlcGWj", "name": "Abstract Log Lattice 2", "author": "aiekick", "description": "vairation of Abstract Log Lattice", "tags": ["abstract", "2", "lattice", "log"], "likes": 10, "viewed": 622, "published": "Public API", "date": "1471551558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\t// get rotation matrix near z\n\nfloat df(vec3 p)\n{\n    p *= RotZ(p.z*0.1);\n\tp = mod(p, 4.3)-0.5*4.3;\n\tfloat s = 1. - log((abs(p.y)) * 2.) - length(p.xz) ;\n\treturn s;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n\tvec2 uv = (g+g-si)/si.y;\n\n\tfloat time = -iTime;\n\t\n\tvec3 ro = vec3(0,0, time*5.);\n    vec3 cv = ro + vec3(0,0,.1);\n\t\n\tvec3 lp = ro;\n\t\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tconst float iter = 250.;\n\t\n\tfloat s = 1., d = 0.;\n\tfor (float i=0.; i<iter; i++)\n\t{\n\t\tif (0.<0.01*log(d*d/s)) break;\n\t\ts = df(ro+rd*d);\n\t\td += s * 0.1;\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(0,0.5,1);\n\tfloat sss = df(p - n * 0.2)/0.2;\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(200. * sb + 200.);\t\t\t\t\t\t\t\t// bb\n\tfloat sss2 = 1. - SubDensity(p, 4.); \t\t\t\t\t\t\t// one step sub density of df\n\t\n\tvec3 a,b;\n\ta = 1.-(diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.4 + spe;\n    b = col * sss;\n    \n\tfragColor.rgb = mix(a, b, .9-exp(-0.01*d*d));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcGWj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 233, 233, 291], [292, 323, 341, 341, 458], [460, 460, 494, 494, 694], [696, 917, 945, 945, 1270], [1272, 1354, 1411, 1411, 1635], [1637, 1637, 1673, 1673, 1806], [1808, 1808, 1865, 1865, 3240]], "test": "valid"}
{"id": "MlcGzX", "name": "Mutating Mandelball", "author": "zackpudil", "description": "A mandelbox distance used as the radius of a sphere.  A mandelball....", "tags": ["raymarching", "fractal", "reflection"], "likes": 2, "viewed": 238, "published": "Public", "date": "1470509502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float de(vec3 p, inout vec4 o) {\n\tvec4 q = vec4(p, 1);\n\tvec4 c = q;\n\n\to = vec4(10000.0);\n\t\n\tq.xyz *= abs(cos(iTime*0.1));\n\tfor(int i = 0; i < 10; i++) {\n\t\tq.xyz = 2.0*clamp(q.xyz, -1.0, 1.0) - q.xyz;\n\t\tq *= clamp(1.0/dot(q.xyz, q.xyz), 1.0, 1.0/0.5);\n\t\t\n\t\tq = 3.0*q - c;\n\n\t\to = min(o, vec4(abs(q.xzy), length(q.xyz)));\n\t}\n\n\treturn min(length(p) - 1.0 - smoothstep(-2.0, -1.97, -length(p))*(length(q.xyz)/q.w - 0.001), p.y + 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd, inout vec3 pos, inout vec3 ref) {\n\tfloat t = 0.0;\n\tvec4 orb;\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = de(ro + rd*t, orb);\n\t\tif(d < 0.0001*t || t >= 10.0) break;\n\t\tt += d*0.35;\n\t}\n\t\n\tvec3 col = vec3(0.15);\n\tif(t < 10.0) {\n\t\tvec4 tmp;\n\t\tpos = ro + rd*t;\n\t\tvec2 eps = vec2(0.001, 0.0);\n\t\tvec3 nor = normalize(vec3(\n\t\t\tde(pos + eps.xyy, tmp) - de(pos - eps.xyy, tmp),\n\t\t\tde(pos + eps.yxy, tmp) - de(pos - eps.yxy, tmp),\n\t\t\tde(pos + eps.yyx, tmp) - de(pos - eps.yyx, tmp)\n\t\t));\n\t\tref = reflect(rd, nor);\n\t\tvec3 key = normalize(vec3(0.8, 0.7, -0.6));\n\t\t\n\t\tfloat occ = 0.0, w = 1.0, s = 0.006;\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfloat d = de(pos + nor*s, tmp);\n\t\t\tocc += (s - d)*w;\n\t\t\tw *= 0.95;\n\t\t\ts += s/(float(i) + 1.0);\n\t\t}\n\t\tocc = 1.0 - clamp(occ, 0.0, 1.0);\n\t\t\n\t\tfloat sha = 1.0; s = 0.002;\n\t\tfor(int i = 0; i < 50; i++) {\n\t\t\tfloat d = de(pos + key*s, tmp);\n\t\t\ts += d;\n\t\t\tsha = min(sha, 8.0*d/s);\n\t\t\tif(d < 0.0 || t >= 10.0) break;\n\t\t}\n        sha = clamp(sha, 0.0, 1.0);\n\t\t\n\t\tcol = clamp(dot(nor, key), 0.0, 1.0)\n\t\t\t*vec3(1.64, 1.57, 0.99)\n\t\t\t*sha;\n\t\t\n\t\tcol += clamp(0.5 + 0.5*nor.y, 0.0, 1.0)\n\t\t\t*vec3(0.16, 0.20, 0.28)\n\t\t\t*occ;\n\t\t\n\t\tcol += clamp(dot(nor, key*vec3(-1, 0, -1)), 0.0, 1.0)\n\t\t\t*vec3(0.40, 0.28, 0.20)\n\t\t\t*occ;\n\n\t\tvec3 mat; \n\t\t\t\t\t\n\t\tif(pos.y > -0.99) {\n\t\t\tmat = mix(vec3(1.0, 0.3, 0.0), vec3(0.3, 1.0, 0.3), orb.x);\n\t\t\tmat = mix(mat, vec3(0.3, 0.3, 1.0), orb.y);\n\t\t\tmat = mix(mat, vec3(1.1, 0.8, 0.1), orb.z);\n\t\t}\n\t\telse mat = 0.5 + 0.5*vec3(mod(floor(pos.x) + floor(pos.z), 2.0));\n\n\t\tcol *= 0.2*mat;\n\t\tcol += pow(clamp(dot(key, ref), 0.0, 1.0), 8.0)*vec3(1.00, 0.95, 0.5)*mat*occ;\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = 1.75*vec3(cos(iTime*0.4), 0.5, -sin(iTime*0.4));\n\tvec3 ww = normalize(-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.97*ww);\n\n\tvec3 td, tp, rp, re;\n\tvec3 col = render(ro, rd, tp, td);\n\n\tvec3 rcol = render(tp, td, rp, re);\n\n\tcol = mix(col, rcol, 0.2);\n\t\n\tcol = pow(col, vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 431], [433, 433, 496, 496, 2080], [2082, 2082, 2139, 2139, 2639]], "test": "valid"}
{"id": "MldGDl", "name": "PBR Column Room", "author": "geoff", "description": "Same geometry as one of my previous shaders with the addition of the central torus, but this time utilising a physically based BRDF. Mouse X controls how metallic the columns are and Y their roughness. More detail in the shader's comments.", "tags": ["spheretracing", "pbr"], "likes": 6, "viewed": 813, "published": "Public API", "date": "1472519676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\tThe BRDF used in this shader is based on those used by Disney and Epic Games.\n\t\n\tThe input parameters and individual components are modelled after the ones\n\tdescribed in\n\n\t\thttps://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n\tThe various components are then combined based on Disney's PBR shader, found here\n\n\t\thttps://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf\n\t\n\tI'd recommend reading this for a description of what the parameters in this BRDF do\n\n\t\thttp://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\n\t\n*/\n\n//#define COLUMN_COL vec3(1.0, 0.858824, 0.568627)\n#define COLUMN_COL vec3(1.0, 0.0, 0.0)\n\n//#define FLOOR_COL_A vec3(0.8)\n//#define FLOOR_COL_B vec3(0.2)\n#define FLOOR_COL_A vec3(0.0, 0.0, 1.0)\n#define FLOOR_COL_B vec3(1.0, 1.0, 1.0)\n\nfloat closeObj = 0.0;\nconst float PI = 3.14159;\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = p;\n    p = vec3(mod(p.x, 5.0) - 2.5, p.y, mod(p.z, 5.0) - 2.5);\n    float qpi = 3.141592 / 4.0;\n    float sub = 10000.0;\n    for(float i = 0.0; i < 8.0; i++){\n        float x = 0.2 * cos(i * qpi);\n        float z = 0.2 * sin(i * qpi);\n        vec3 transp = p - vec3(x, 0.0, z);\n        vec3 a = vec3(x, 1.2, z);\n        vec3 b = vec3(x, -1.2, z);\n        sub = min(sub, capsule(transp, a, b, 0.1));\n    }\n    float ttorus = torus(p - vec3(0.0, -1.5, 0.0), vec2(0.22));\n    float btorus = torus(p - vec3(0.0, 1.5, 0.0), vec2(0.22));\n    float u = min(btorus, ttorus);\n    vec2 column = vec2(min(u, max(-sub, length(p.xz) - 0.35)), 2.0);\n    vec2 ctorus = vec2(torus(rotX(iTime) * rotY(iTime) * (q - vec3(0.0, 0.0, 5.0)), vec2(1.0, 0.5)), 2.0);\n    vec2 flo = vec2(q.y + 1.5, 1.0);\n    vec2 roof = vec2(-q.y + 1.5, 1.0);\n    return vecMin(ctorus, vecMin(column, vecMin(flo, roof)));\n}\n\n//Returns the min distance\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 1.0;\n    float d = 0.0;\n    float w = 1.4;\n    float ld = 0.0;\n    float ls = 0.0;\n    float s = 0.0;\n    float cerr = 10000.0;\n    float ct = 0.0;\n    float pixradius = 0.4 / iResolution.x;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 256; i++){\n        ld = d;\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        \n        //Detect intersections missed by over-relaxation\n        if(w > 1.0 && abs(ld) + abs(d) < s){\n            s -= w * s;\n            w = 1.0;\n            t += s;\n            continue;\n        }\n        s = w * d;\n        \n        float err = d / t;\n        \n        if(abs(err) < abs(cerr)){\n            ct = t;\n            cerr = err;\n        }\n        \n        //Intersect when d / t < one pixel\n        if(abs(err) < pixradius){\n            inter = 1;\n            break;\n        }\n        \n        t += s;\n        if(t > 50.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        ct = -1.0;\n    }\n    return ct;\n}\n\n\n//Approximate normal\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0);\nvec3 lightPos = vec3(0.0);\n\n//Determine if a point is in shadow - 1.0 = not in shadow\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.01;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 256; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 25; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(2.0 * occ, 0.0, 1.0);\n}\n\n//Square\nfloat sqr(float x){\n  return x * x;\n}\n\n//Diffusion normalisation\nfloat diff(float albedo){\n  return albedo / PI;\n}\n\n//GGX NDF\nfloat specD(float NdotH, float a){\n  float asqr = sqr(a);\n  float NdotHsqr = sqr(NdotH);\n  return asqr / (PI * sqr((NdotHsqr) * (asqr - 1.0) + 1.0));\n}\n\nfloat G1(float NdotX, float k){\n  return NdotX / (NdotX * (1.0 - k) + k);\n}\n\n//Geometric attenuation term\nfloat specG(float NdotV, float NdotL, float k){\n  k /= 2.0;\n  return G1(NdotV, k) * G1(NdotL, k);\n}\n\n//Schlick fresnel approximation used by Unreal Engine\nfloat fresnel(float AdotB){\n  float power = pow(2.0, (-5.55473 * AdotB - 6.98316) * AdotB);\n  return 0.04 + (1.0 - 0.04) * power;\n}\n\n\nvec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 c, float metallic, float roughness, float s, float o){\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n  \n  if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0);\n  \n  float VdotH = dot(V, H);\n  float alpha = roughness * roughness;\n\n  float conductor = 1.0 - metallic;\n\n  vec3 specCol = mix(vec3(1.0), c, metallic);\n  \n  float FresL = fresnel(NdotL);\n  float FresV = fresnel(NdotV);\n  float Fresd90 = 0.5 + 2.0 * sqr(VdotH) * roughness;\n  float Fresd = mix(1.0, Fresd90, FresL) * mix(1.0, Fresd90, FresV); \n  \n  float Ds = specD(NdotH, alpha);\n  float FresH = fresnel(VdotH);\n  vec3 Fress = mix(specCol, vec3(1.0), FresH);\n  float Gs = specG(NdotV, NdotL, roughness);\n\n  return (diff(conductor) * Fresd * max(0.0, NdotL) * o * c + Gs * Fress * Ds * floor(s)) - (0.25 - 0.25 * s) * c;\n}\n\nvec3 colour(vec3 p, float id){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(camPos - p);\n    \n    vec3 amb = 0.25 * vec3(1.0);\n    \n    float s = shadow(p, l);\n    \n    float o = occlusion(p, n);\n    \n    if(id == 1.0){\n        vec3 col;\n        vec2 t = mod(floor(p.xz), 2.0);\n        if(t == vec2(0.0) || t == vec2(1.0)){\n            col = FLOOR_COL_A;\n        }else{\n            col = FLOOR_COL_B;\n        }\n        return BRDF(l, v, n, col, 0.4, 0.2, s, o);\n    }\n    if(id == 2.0){\n        float metal = iMouse.x / iResolution.x;\n        float rough = iMouse.y / iResolution.y;\n        if(rough == 0.0 && metal == 0.0){\n            metal = 0.1;\n            rough = 0.1;\n        }\n        return BRDF(l, v, n, COLUMN_COL, metal, rough, s, o);\n    }\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 0.0, 0.0);\n    lightPos = vec3(sin(iTime) * 3.0, 0.0, 0.0);\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(0.0);\n    //If intersected\n    if(d > 0.0){\n        //Colour the point\n        col = colour(c, closeObj);\n        //Apply fog\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n    col = pow( col, vec3(0.4545) );\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[716, 910, 929, 929, 1070], [1072, 1072, 1091, 1091, 1232], [1234, 1234, 1281, 1281, 1419], [1421, 1421, 1450, 1450, 1520], [1522, 1522, 1550, 1550, 1610], [1612, 1612, 1632, 1632, 2528], [2530, 2557, 2575, 2575, 2601], [2603, 2603, 2633, 2633, 3631], [3634, 3655, 3675, 3675, 3951], [4006, 4064, 4095, 4095, 4451], [4453, 4453, 4487, 4487, 4736], [4738, 4747, 4766, 4766, 4784], [4786, 4812, 4837, 4837, 4861], [4863, 4873, 4907, 4907, 5024], [5026, 5026, 5057, 5057, 5101], [5103, 5132, 5179, 5179, 5231], [5233, 5287, 5314, 5314, 5418], [5421, 5421, 5514, 5514, 6302], [6304, 6304, 6334, 6334, 7130], [7132, 7132, 7188, 7188, 7785]], "test": "valid"}
{"id": "MldGRl", "name": "hanning", "author": "zardoru", "description": "the hanning window on a moving wave.", "tags": ["2d", "sound"], "likes": 2, "viewed": 130, "published": "Public", "date": "1470981326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 tx = (fragCoord.xy / iResolution.xy + vec2(-0.5, -0.5)) * 6.0;\n    vec2 uv = tx * vec2(1, 2);\n    float pi = 3.1416;\n    \n    float dx = tx.x + iTime;\n    float hanning = (0.5 - 0.5 * (1.0 - cos(2.0 * pi * dx))) * 2.0;\n    float fx = hanning * (sin(tx.x) / tx.x * 8.0 / 2.0 + 0.5);\n    vec2 dir = vec2(tx.x, fx);\n    \n    float line = 1.0 - distance(dir, uv);\n    \n\tfragColor = vec4(line);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 455]], "test": "valid"}
{"id": "MldGWj", "name": "Voronoi procedural", "author": "AsGreyWolf", "description": "Voronoi texture procedural generation", "tags": ["procedural", "2d", "voronoi", "texture"], "likes": 5, "viewed": 199, "published": "Public", "date": "1471772326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nconst int max = 1024;\nvec2 randV(int i){\n    vec2 co1 = vec2(float(i)/float(max), 0.0);\n    vec2 co2 = vec2(co1.x, 0.5);\n    return vec2(rand(co1), rand(co2));\n}\nfloat coeff(){\n    float t = iTime/5.0;\n    t -= floor(t);\n    t *= 2.0;\n    if(t<=1.0)\n        return t;\n    return 2.0-t;\n}\nvec2 findNearest(vec2 c, int block){\n\tfloat mindist = -1.0;\n    vec2 nearest;\n    for(int i=0;i<=max;i++){\n        if(i>block) break;\n        vec2 v = randV(i);\n        float dist = distance(v, c);\n        if(mindist < 0.0 || mindist > dist){\n        \tmindist = dist;\n            nearest = v;\n        }\n    }\n    return nearest;\n}\nfloat findBorders(vec2 c, int block){\n\tfloat mindist = -1.0;\n    float mindist2 = -1.0;\n    for(int i=0;i<=max;i++){\n        if(i>block) break;\n        vec2 v = randV(i);\n        float dist = distance(v, c);\n        if(mindist < 0.0 || mindist > dist){\n            mindist2 = mindist;\n        \tmindist = dist;\n        }\n    }\n    return (mindist2-mindist)<0.002?0.0:1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y /= iResolution.x/iResolution.y;\n    float v = sin(iTime*M_PI)>0.0?\n        rand(findNearest(uv,int(coeff()*float(max)))):\n    \tfindBorders(uv,int(coeff()*float(max)));\n\tfragColor = vec4(v,v,v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 67, 67, 139], [162, 162, 180, 180, 301], [302, 302, 316, 316, 427], [428, 428, 464, 464, 758], [759, 759, 796, 796, 1131], [1132, 1132, 1189, 1189, 1440]], "test": "valid"}
{"id": "MljXzz", "name": "Isometric City 2.5D", "author": "knarkowicz", "description": "No raymarching, raytraycing or rasterization was harmed in the making of this Shadertoy", "tags": ["2d", "isometric", "city", "tiles"], "likes": 147, "viewed": 7666, "published": "Public API", "date": "1470073761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\nconst vec3 RGB_WATER\t\t= RGB( 52, 166, 202 );\nconst vec3 RGB_BUILDING \t= RGB( 219, 180, 144 );\nconst vec3 RGB_RIGHT_WALL\t= RGB_BUILDING * 1.1;\nconst vec3 RGB_LEFT_WALL\t= RGB_BUILDING * 0.7;\nconst vec3 RGB_WINDOWS \t\t= RGB( 90, 100, 180 );\nconst vec3 RGB_ROAD \t\t= RGB( 110, 125, 120 ) * 0.7;\nconst vec3 RGB_LANE \t\t= RGB( 255, 255, 255 ) * 0.8;\nconst vec3 RGB_GRASS\t\t= RGB( 129, 164, 66 );\nconst vec3 RGB_TREE_LEAVES\t= RGB( 129, 164, 66 ) * 0.6;\nconst vec3 RGB_TREE_TRUNK\t= RGB( 80, 42, 42 );\nconst float TILE_WATER\t\t= 0.0;\nconst float TILE_GRASS\t\t= 1.0;\nconst float TILE_ISLAND\t\t= 2.0;\nconst float TILE_ROAD_X\t\t= 3.0;\nconst float TILE_ROAD_Y\t\t= 4.0;\nconst float TILE_ROAD_XY\t= 5.0;\nconst float ISO_TILE\t\t= 13.0 * 8.0;\nconst float LARGE_FLOAT\t\t= 1e8;\n\nvoid DrawBuilding( inout vec3 color, inout float zbuffer, vec2 tile, vec2 pixel, vec2 buildingTile, float h )\n{\n    float depth = buildingTile.x + buildingTile.y;\n    if ( depth > zbuffer )\n    {\n        return;\n    }    \n    \n    buildingTile.x += h;\n    buildingTile.y += h;    \n    \n    pixel.y -= ISO_TILE * 0.25;\n    vec2 iso = vec2( ( pixel.x + 2.0 * pixel.y ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y ) / -ISO_TILE );\n    tile = floor( iso );\n    vec2 off = iso - tile;\n    \n\t// roof\n    if ( tile.x == buildingTile.x && tile.y == buildingTile.y && off.x > 0.2 && off.y > 0.2 && off.x < 0.98 && off.y < 0.98 )\n    {\n        zbuffer = depth;\n        color = RGB_BUILDING;\n\n        if ( off.x < 0.28 || off.y < 0.28 || off.x > 1.0 - 0.08 || off.y > 1.0 - 0.08 )\n        {\n            color *= 1.2;\n        }\n    }\n    \n    float px = ( buildingTile.x - buildingTile.y ) * ISO_TILE * 0.5;\n    \n    // right wall\n    if ( pixel.x >= px && pixel.x < px + 0.39 * ISO_TILE && iso.y < buildingTile.y + 0.20 && iso.y > buildingTile.y - h - 0.4 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_RIGHT_WALL;\n        \n\t\tif ( mod( iso.y + 0.2, 0.5 ) < 0.25 )\n\t\t{\n\t\t\tcolor *= RGB_WINDOWS;\n\t\t\tcolor *= mod( pixel.x, 16.0 ) < 8.0 ? 1.0 : 0.8;\n\t\t}\n    }\n    \n    // left wall\n    if ( pixel.x >= px - 0.39 * ISO_TILE && pixel.x < px && iso.x < buildingTile.x + 0.20 && iso.x > buildingTile.x - h - 0.4 )\n    {\n        zbuffer = depth;        \n\t\tcolor = RGB_LEFT_WALL;        \n        \n\t\tif ( mod( iso.x + 0.2, 0.5 ) < 0.25 )\n\t\t{\n\t\t\tcolor *= RGB_WINDOWS;\n\t\t\tcolor *= mod( pixel.x, 16.0 ) < 8.0 ? 1.0 : 0.8;\n\t\t}\n    }\n}\n\nvoid DrawTree( inout vec3 color, inout float zbuffer, vec2 tile, vec2 pixel, vec2 treeTile )\n{        \n    float depth = treeTile.x + treeTile.y;\n    if ( depth > zbuffer )\n    {\n        return;\n    }\n    \n    pixel.y -= ISO_TILE * 0.25;\n    vec2 iso = vec2( ( pixel.x + 2.0 * pixel.y ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y ) / -ISO_TILE );\n    tile = floor( iso );\n    vec2 off = iso - tile;\n    \n    float px = ( treeTile.x - treeTile.y ) * ISO_TILE * 0.5;\n    \n    // top leaves\n    if ( iso.x > treeTile.x + 0.2 && iso.y > treeTile.y + 0.2 && iso.x < treeTile.x + 0.45 && iso.y < treeTile.y + 0.45 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 1.0;\n    }\n    \n\t// left leaves\n    if ( pixel.x >= px - 0.125 * ISO_TILE && pixel.x < px && iso.x > treeTile.x - 0.1 && iso.x < treeTile.x + 0.2 && iso.x > treeTile.x - 0.1 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 0.8;\n    }\n    \n\t// right leaves\n    if ( pixel.x >= px && pixel.x < px + 0.125 * ISO_TILE && iso.y < treeTile.y + 0.2 && iso.y > treeTile.y - 0.1 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 1.2;\n    }    \n    \n    // left trunk\n    if ( pixel.x >= px - 0.039 * ISO_TILE && pixel.x < px && iso.x <= treeTile.x - 0.1 && iso.x > treeTile.x - 0.4 )\n    {\n        zbuffer = depth;        \n\t\tcolor = RGB_TREE_TRUNK * 0.8;\n    }    \n    \n    // right trunk\n    if ( pixel.x >= px && pixel.x < px + 0.039 * ISO_TILE && iso.y <= treeTile.y - 0.1 && iso.y > treeTile.y - 0.4 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_TRUNK * 1.1;\n    }\n}\n\nfloat TileID( vec2 tile )\n{\n    float id = TILE_WATER;\n    vec4 tex = texture( iChannel0, tile / ( iChannelResolution[ 0 ].xy * 4.0 ) );\n    id = tex.y > 0.5 ? TILE_WATER \t: TILE_GRASS;\n    id = tex.y > 0.9 ? TILE_ISLAND \t: id;\n    \n    if ( id == TILE_GRASS && mod( tile.x + 1.0, 4.0 ) == 0.0 )\n    {\n        id = TILE_ROAD_X;\n    }\n    \n    if ( mod( tile.y + 1.0, 4.0 ) == 0.0 )\n    {\n        if ( id == TILE_GRASS ) \n        {\n        \tid = TILE_ROAD_Y;\n    \t}\n        \n        if ( id == TILE_ROAD_X ) \n        {\n        \tid = TILE_ROAD_XY;\n    \t}        \n    }\n    \n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resMult      \t= floor( max( iResolution.x, iResolution.y ) / 800.0 );\n    float resRcp        = 1.0 / max( resMult, 1.0 );\n    //float cameraOffset\t= floor( iTime * 60.0 + 0.5 );\n    float cameraOffset\t= float( iFrame );\n    vec2 pixel \t\t\t= fragCoord * resRcp + cameraOffset - iMouse.xy + vec2( -2000, -2000.0 );\n    \n    vec2 iso\t\t= vec2( ( pixel.x + 2.0 * pixel.y ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y ) / -ISO_TILE );\n    vec2 waterIso\t= vec2( ( pixel.x + 2.0 * pixel.y + 0.15625 * ISO_TILE ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y - 0.15625 * ISO_TILE ) / -ISO_TILE );\n    vec2 isoR\t\t= vec2( ( pixel.x + 2.0 * pixel.y - ISO_TILE * 0.5 ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y + ISO_TILE * 0.5 ) / -ISO_TILE );\n    vec2 tile\t\t= floor( iso );\n    vec2 tileR\t\t= floor( isoR );\n    vec2 waterTile\t= floor( waterIso );\n    vec2 off\t\t= iso - tile;\n    vec2 offR \t\t= isoR - tileR;\n    vec2 waterOff  \t= waterIso - waterTile;\n    \n    vec2 buildingTile0 \t= 2.0 * floor( tile / 2.0 );\n    vec2 buildingTile1 \t= 3.0 * floor( tile / 3.0 );\n    vec2 buildingTile2 \t= 4.0 * floor( tile / 4.0 );\n    vec2 buildingTile3 \t= 5.0 * floor( tile / 5.0 );\n\n    float tileId\t= TileID( tile );\n    float tileLId\t= TileID( vec2( tile.x - 1.0, tile.y ) );\n    float tileRId\t= TileID( vec2( tile.x + 1.0, tile.y ) );\n    float tileTId\t= TileID( vec2( tile.x, tile.y - 1.0 ) );\n    float tileBId\t= TileID( vec2( tile.x, tile.y + 1.0 ) );\n    float tileB0Id\t= TileID( buildingTile0 );\n    float tileB1Id\t= TileID( buildingTile1 );\n    float tileB2Id\t= TileID( buildingTile2 );\n    float tileB3Id\t= TileID( buildingTile3 );\n  \n    // water\n    vec3 waterTexNoise = texture( iChannel0, waterTile /  iChannelResolution[ 0 ].xy + fract( iTime * 0.005 ) ).xyz;    \n    vec3 color = RGB_WATER * mix( 0.8, 1.1, waterTexNoise.z );\n\n    float waterTileId\t= TileID( waterTile );\n    float waterTileLId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y ) );\n    float waterTileRId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y ) );\n    float waterTileTId\t= TileID( vec2( waterTile.x, waterTile.y - 1.0 ) );\n    float waterTileBId\t= TileID( vec2( waterTile.x, waterTile.y + 1.0 ) );\n    float waterTileLTId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y - 1.0 ) );\n    float waterTileLBId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y + 1.0 ) );\n    float waterTileRTId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y - 1.0 ) );\n    float waterTileRBId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y + 1.0 ) );    \n    \n    // water shore shadow\n    if ( waterTileId == TILE_WATER )\n    {\n        if ( ( waterTileLId != TILE_WATER && waterOff.x < 8.0 / 32.0 ) \n            || ( waterTileRId != TILE_WATER && waterOff.x > 24.0 / 32.0 )\n            || ( waterTileTId != TILE_WATER && waterOff.y < 8.0 / 32.0 )\n            || ( waterTileBId != TILE_WATER && waterOff.y > 24.0 / 32.0 )\n            || ( waterTileLTId != TILE_WATER && waterOff.x < 8.0 / 32.0 && waterOff.y < 8.0 / 32.0 )\n            || ( waterTileLBId != TILE_WATER && waterOff.x < 8.0 / 32.0 && waterOff.y > 24.0 / 32.0 )\n            || ( waterTileRTId != TILE_WATER && waterOff.x > 24.0 / 32.0 && waterOff.y < 8.0 / 32.0 )\n            || ( waterTileRBId != TILE_WATER && waterOff.x > 24.0 / 32.0 && waterOff.y > 24.0 / 32.0 )            \n           )\n        {\n            color *= vec3( 0.8 );\n        }\n    }\n    \n    // shores\n    float waterPX = ( waterTile.x - waterTile.y ) * ISO_TILE * 0.5;\n    if ( ( waterTileId != TILE_WATER && pixel.x <= waterPX && waterTileLId == TILE_WATER ) \n        || ( waterTileTId != TILE_WATER && pixel.x > waterPX && waterOff.x < 5.0 / 32.0 ) )\n    {\n\t\tcolor = RGB_GRASS * 0.7;\n\t}\n    if ( ( waterTileId != TILE_WATER && pixel.x > waterPX && waterTileTId == TILE_WATER ) \n        || ( waterTileLId != TILE_WATER && pixel.x <= waterPX && waterOff.x < 5.0 / 32.0 ) )\n    {\n\t\tcolor = RGB_GRASS * 0.9;\n\t}    \n        \n    // grass and road\n    if ( tileId != TILE_WATER )\n    {\n    \tcolor = RGB_GRASS;\n    }\n    \n    float roadWidth = 0.3;\n\tfloat laneWidth = 0.03;\n    if ( ( ( tileId == TILE_ROAD_X || tileId == TILE_ROAD_XY ) && abs( 0.5 - off.x ) < roadWidth ) \n        && ( tileTId != TILE_WATER || tileBId != TILE_WATER ) \n        && ( tileTId != TILE_WATER || off.y >= 0.20 )\n       \t&& ( tileBId != TILE_WATER || off.y <= 0.80 )\n       )\n    {\n\t\tcolor = RGB_ROAD;\n\t\tif ( abs( 0.5 - off.x ) < laneWidth && mod( off.y, 0.5 ) < 0.2 && tileId != TILE_ROAD_XY )\n\t\t{\n\t\t\tcolor = RGB_LANE;\n\t\t}\n    }\n\tif ( ( tileId == TILE_ROAD_Y || tileId == TILE_ROAD_XY ) && abs( 0.5 - off.y ) < roadWidth \n        && ( tileLId != TILE_WATER || tileRId != TILE_WATER )\n        && ( tileLId != TILE_WATER || off.x >= 0.20 ) \n        && ( tileRId != TILE_WATER || off.x <= 0.80 ) )\n    {\n\t\tcolor = RGB_ROAD;\n        if ( abs( 0.5 - off.y ) < laneWidth && mod( off.x, 0.5 ) < 0.2 && tileId != TILE_ROAD_XY )\n        {\n        \tcolor = RGB_LANE;\n\t\t}\n    }\n    \n    if ( tileId == TILE_GRASS && (\n\t\t\t( buildingTile0.x == tile.x && buildingTile0.y == tile.y ) \n        || \t( buildingTile1.x == tile.x && buildingTile1.y == tile.y ) \n        || \t( buildingTile2.x == tile.x && buildingTile2.y == tile.y ) \n        || \t( buildingTile3.x == tile.x && buildingTile3.y == tile.y ) ) )\n    {\n        // building AO\n        vec2 offAO = 7.0 * clamp( ( abs( 0.5 - off ) - 0.35 ), 0.0, 1.0 );\n        color *= clamp( max( offAO.x, offAO.y ), 0.0, 1.0 );\n    }\n    else if ( tileId == TILE_GRASS || tileId == TILE_ISLAND )\n    {\n        // tree AO\n\t\tcolor *= clamp( max( 8.0 * abs( 0.15 - off.x ), 8.0 * abs( 0.15 - off.y ) ), 0.0, 1.0 );        \n    }\n\n    float zbuffer = LARGE_FLOAT;\n    if ( tileB0Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile0, 0.0 );\n    }\n\n    if ( tileB1Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile1, 1.0 );\n    }\n    \n    if ( tileB2Id == TILE_GRASS )    \n    {           \n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile2, 2.0 );\n    }\n    \n    if ( tileB3Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile3, 3.0 );\n    }\n    \n    if ( ( tileId == TILE_GRASS || tileId == TILE_ISLAND ) && zbuffer >= LARGE_FLOAT )\n    {    \n        DrawTree( color, zbuffer, tile, pixel, tile );\n    }\n    \n    fragColor = vec4( sqrt( color ), 1.0 );  \n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[838, 838, 949, 949, 2433], [2435, 2435, 2529, 2529, 3965], [3967, 3967, 3994, 3994, 4555], [4557, 4557, 4614, 4614, 10945]], "test": "error"}
{"id": "MltGzB", "name": "bezier path", "author": "runekill", "description": "Simple implementation of bezier path. Unfortunately i didn't get how i can draw all steps for all curves, so i solve this task by &quot;step&quot; workaround. At least it works.", "tags": ["simple", "tutorial", "bezier", "curve", "path", "heartbeet", "ekg"], "likes": 2, "viewed": 354, "published": "Public", "date": "1470130294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//health bar v 0.2\n//based on works:\n//https://www.shadertoy.com/view/4tlSRr by udart\n//https://www.shadertoy.com/view/lstXDj by akohdr\n#define cirleWidth 0.01\n#define red   vec3(1.00,0.38,0.227)\n#define blue vec3(0.09,0.99,0.55)\n//if health>40 - blue line and some alhorithm for speed, >0 - red line, 0 - straight line.\n#define health 100.\nconst int c = 20; //array size\nconst float size = 10.0;//dotted grid size\n//calculate point based on cubic bezier alhoritm\nvec2 calculateBezierPoint(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float u = 1. - t;\n    float tt = t*t;\n    float uu = u*u;\n    float uuu = uu * u;\n    float ttt = tt * t;\n \n    vec2 p = uuu * p0;    \n    p += 3. * uu * t * p1;   \n    p += 3. * u * tt * p2;    \n    p += ttt * p3;           \n \n    return p;\n}\n//draw line segment\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float l = length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0) );\n    l = smoothstep(cirleWidth,cirleWidth-0.005,l);\n    return l;\n\n}\n//calculate bezier curve\nfloat curve(vec2 uv, vec2 bezierArray[c],float ts)\n{\n    float l=0.;\n    vec2 q0;\n    for (int i=0; i <c; i+=3)\n    {\n        //cordinates of bezier curve control points\n        vec2 p0=bezierArray[i];\n        vec2 p1=bezierArray[i+1];\n        vec2 p2=bezierArray[i+2];\n        vec2 p3=bezierArray[i+3];\n        //first point of bezier curve\n\t\tq0 = calculateBezierPoint(0.,p0,p1,p2,p3);\n\t\t//calculate all points and draw as many of them while j > elapsed time\n        for (float j = 0.; j < 1.01; j+=0.1)\n    \t{\n   \n        \tvec2 q1 = calculateBezierPoint(j,p0,p1,p2,p3);\n        \tl += lineSegment(uv,q0,q1);\n        \tq0 = q1;\n            \n\t\t\t\n    \t}\n        \n    }\n    \n    return l;\n}\n//calculate grid line\nfloat IsGridLine(vec2 fragCoord)\n{\n\tvec2 vGridSquareCoords = fract(fragCoord.xy / vec2(size));\n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vec2(size);\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\treturn fIsGridLine;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.-1.);\n    uv.x+=1.;\n    uv.x *= iResolution.x / iResolution.y;\n    float col = 0.;\n    //creating array of points for bezier lines\n    vec2 bezierArray[c];\n    bezierArray[0] = vec2( -0.0, 0.0);\n    bezierArray[1] = vec2( -0.0+0.1, 0.0);\n    bezierArray[2] = vec2( -0.0+0.2, 0.0);\n    bezierArray[3] = vec2( -0.0+0.3,0.0);\n    bezierArray[4] = vec2( -0.0+0.45, 0.5);\n    bezierArray[5] = vec2( -0.0+0.45, -0.05);\n    bezierArray[6] = vec2( -0.0+0.6, -0.0);\n    bezierArray[7] = vec2( -0.0+0.9, -0.5);\n    bezierArray[8] = vec2( -0.0+0.8, 1.2);\n    bezierArray[9] = vec2( -0.0+0.92, 0.9);\n    bezierArray[10] = vec2( -0.0+1.0, 0.5);\n    bezierArray[11] = vec2( -0.0+1.1, -2.);\n    bezierArray[12] = vec2( -0.0+1.2, 0.0);\n    bezierArray[13] = vec2( -0.0+1.3, 0.00);\n    bezierArray[14] = vec2( -0.0+1.35, 0.15);\n    bezierArray[15] = vec2( -0.0+1.5, 0.0);\n    bezierArray[16] = vec2( -0.0+1.6, 0.0);\n    bezierArray[17] = vec2( -0.0+1.7, 0.0);\n    bezierArray[18] = vec2( -0.0+1.8, 0.0);\n    bezierArray[19] = vec2( -0.0+1.9, 0.0);\n\n\tfloat x,y;\n    vec3 finalcolor;\n    //draw 2 connected bezier curves\n    if (health>40.)\n    {\n        //time calculation for x coordinates and step by step drawing\n    \tfloat ts = mod(iTime,0.04*health)*200./health;\n        //find redraw coordinates\n    \ty = step(ts,uv.x);\n    \tx = smoothstep(uv.x,ts,ts-0.1);\n    \t//draw grid\n    \tcol += min(0.1,IsGridLine(fragCoord));\n        col += min(1.,curve(uv, bezierArray,ts));\n    \tcol += min(1.,curve(vec2(uv.x-1.914,uv.y), bezierArray,ts));\n        //make color out of col value\n    \tfinalcolor = blue*col;\n    } else if (health>0.) \n    {\n        //time calculation for x coordinates and step by step drawing\n    \tfloat ts = mod(iTime,1.6)*5.;\n        //find redraw coordinates\n    \ty = step(ts,uv.x);\n    \tx = smoothstep(uv.x,ts,ts-0.1);\n    \t//draw grid\n    \tcol += min(0.1,IsGridLine(fragCoord));\n        col += min(1.,curve(uv, bezierArray,ts));\n    \tcol += min(1.,curve(vec2(uv.x-1.914,uv.y), bezierArray,ts));\n        //make color out of col value\n    \tfinalcolor = red*col;\n       \n    } else\n    {\n        //time calculation for x coordinates and step by step drawing\n    \tfloat ts = mod(iTime,20.)/5.;\n        //find redraw coordinates\n    \ty = step(ts,uv.x);\n    \tx = smoothstep(uv.x,ts,ts-0.1);\n    \t//draw grid\n    \tcol += min(0.1,IsGridLine(fragCoord));\n\t\tcol += lineSegment(uv, vec2(0.), vec2(3.6,0.)); \n        //make color out of col value\n    \tfinalcolor = red*col;\n        \n    }\n    \n\n\n    //redraw function\n    finalcolor-=vec3(y);\n    finalcolor /=vec3(x);\n    \n\n    \n\tfragColor = vec4(finalcolor, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 464, 536, 536, 784], [785, 805, 848, 848, 1022], [1023, 1048, 1100, 1100, 1734], [1735, 1757, 1791, 1791, 2055], [2056, 2056, 2113, 2113, 4771]], "test": "valid"}
{"id": "Mt33Ds", "name": "print improved!", "author": "FMS_Cat", "description": "wip", "tags": ["utility", "tool", "print"], "likes": 6, "viewed": 289, "published": "Public", "date": "1472385205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool print( in vec2 _coord, float _in ) {\n  vec2 coord = _coord;\n\n  // vertical restriction\n  if ( coord.y <= 0.0 || 5.0 <= coord.y ) { return false; }\n  \n  // dot\n  if ( 0.0 < coord.x && coord.x < 2.0 ) {\n    return coord.x < 1.0 && coord.y < 1.0;\n  }\n\n  // padded by dot\n  if ( 2.0 < coord.x ) { coord.x -= 2.0; }\n  \n  // determine digit\n  float ci = floor( coord.x / 5.0 ) + 1.0;\n\n  // too low / too high\n  if ( 4.0 < ci ) { return false; }\n  if ( ci < -4.0 ) { return false; }\n\n  // x of char\n  float cfx = floor( mod( coord.x, 5.0 ) );\n\n  // width is 4\n  if ( 4.0 == cfx ) { return false; }\n\n  // y of char\n  float cfy = floor( coord.y );\n\n  // bit of char\n  float cf = cfx + 4.0 * cfy;\n\n  // determine char  \n  float num = 0.0;\n  if ( 0.0 < ci ) {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( ci < float( i ) ) { break; }\n      \n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n *= 10.0;\n    }\n  } else {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( -ci < float( i ) ) { break; }\n      \n      if ( ci != 0.0 && n < 1.0 ) {\n        // minus\n        return float( i ) == -ci && _in < 0.0 && cfy == 2.0 && 0.0 < cfx;\n      }\n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n /= 10.0;\n    }\n  }\n\n  bool a;\n  a = 1.0 == mod( floor( (\n    num == 0.0 ? 432534.0 :\n    num == 1.0 ? 410692.0 :\n    num == 2.0 ? 493087.0 :\n    num == 3.0 ? 493191.0 :\n    num == 4.0 ? 630408.0 :\n    num == 5.0 ? 989063.0 :\n    num == 6.0 ? 399254.0 :\n    num == 7.0 ? 1016898.0 :\n    num == 8.0 ? 431766.0 :\n    433798.0\n  ) / pow( 2.0, cf ) ), 2.0 );\n  \n  return a ? true : false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if ( print( ( fragCoord - vec2( 100.0, 100.0 ) )  / 1.0, 20.0*sin( iTime ) ) ) {\n        fragColor = vec4( 1.0, 1.0, 1.0, 1.0 );\n    } else {\n        fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt33Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 1643], [1645, 1645, 1702, 1702, 1904]], "test": "valid"}
{"id": "Mt33Wj", "name": "Not quite home", "author": "xwize", "description": "Earth like", "tags": ["procedural", "noise", "planet"], "likes": 22, "viewed": 613, "published": "Public", "date": "1471616552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Fast 3D (value) noise by using two cubic-smooth bilinear interpolations in a LUT, \n// which is much faster than its hash based (purely procedural) counterpart.\n//\n// Note that instead of fetching from a grey scale texture twice at an offset of (37,17)\n// pixels, the green channel of the texture is a copy of the red channel offset that amount\n// (thx Dave Hoskins for the suggestion to try this)\n\n#define USE_PROCEDURAL\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\nfloat starFunc(vec3 p)\n{\n\tfloat a = 0.0;\n\tfloat fp = 0.75;\n\tconst int n = 17;\n\tfloat pa = 0.0;\n\t\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tp=abs(p)/dot(p,p)-fp;\n\t\ta+=abs(length(p)-pa);\n\t\tpa=length(p);\n\t}\n\t\n\ta /= float(n);\n\treturn a*a*a*0.625;\n}\n\nvec3 galaxy(vec3 start, vec3 dir)\n{\n    vec3 p = start+dir*100.0;\n    p += vec3(0.0,150.0,0.0);\n   \n    vec3 c = vec3(starFunc(p)) * vec3(1.2,1.0,2.0);\n    p += vec3(10.1,15.2,10.4);\n\tc += vec3(starFunc(p)) * vec3(1.2,1.2,3.0);\n    p += vec3(10.1,15.2,10.5);\n\tc += vec3(starFunc(p)) * vec3(1.2,1.2,1.4);\n    \n\treturn c*0.03;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat cloudForm(vec3 q)\n{\n    q.x += sin(q.y*2.0);\n    q.z += cos(q.x*2.0)*0.3;\n   \n    \n    float f = -0.15 +\n       noise(q) +\n       noise(q*2.0) * 0.5 + \n       noise(q*4.0) * 0.25 +\n       noise(q*8.0) * 0.125 +\n       noise(q*16.0)* 0.05 + \n       noise(q*32.0)* 0.025 +\n       noise(q*64.0)* 0.0125;\n           \n    f = min(pow(abs(f),10.0)*0.5,0.5);\n    return f;\n}\n\nfloat octaves6(vec3 q)\n{\n    float f = 0.0;\n    const int n = 6;\n    for(int i = 0; i < n; ++i)\n    {\n        float ti = pow(2.0,float(i));\n        f += noise(q * ti ) / ti;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5+0.02*iTime;\n\tvec3 ro = vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.7*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\tfloat h = 0.0;\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n    \n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n        float lightIntensity = 4.0;\n        float sunNDL = max(0.0,0.05+0.95*(nor.z));\n        \n        \n\t\t{\n            vec3 oceanBlue = vec3(0.0,0.031,0.11);\n            \n            vec3 q = pos;\n            \n            // Ocean\n            col = oceanBlue;\n            col = col * (0.5 + 0.5*noise(q*4.0));\n\t\t\tcol = col * (0.9 + 0.2*noise(q*8.0));\n            col = col * (0.9 + 0.2*noise(q*16.0));\n            col = col * (0.9 + 0.1*noise(q*32.0));\n            col = col * (0.9 + 0.1*noise(q*64.0));\n            \n            // Land\n            q = m * q * 2.01;\n            \n            float hm = octaves6(q+vec3(137.0)) / 1.5;\n            hm *= hm;\n            \n            f = hm;\n            float landBlend = min(4.0*max(f-0.3,0.0),1.0);\n            \n            float nG = exp(-abs(f-0.4)*20.0);//max(f - 0.4,0.0);\n            float nD = exp(-abs(f-0.6)*20.0);//3.0*max(f - 0.75,0.0);\n            float snowLevel = 0.8+ noise(q*64.0)*0.1;\n            float nS = exp(-abs(f-snowLevel)*20.0);\n            \n            vec3 snow = vec3(0.85,0.85,0.85)/1.85;\n            vec3 desert = vec3(1.5,1.3,1.0)/13.0;\n            vec3 grass = vec3(1.0,1.3,0.5)/12.0;\n            \n\t\t\tfloat normn = nG + nD + nS;\n            \n            float grassD = 1.0 + \n                (noise(q*128.0) + noise(q*64.0) + noise(q*32.0))*0.5;\n            \n            float snowD = 1.0 + (noise(q*vec3(5.0,1.0,1.0)*3.0)\n                + noise(q*16.0)*0.5 + noise(q*64.0)*0.5)*0.25;\n            \n            float desertD = 1.0 + noise(q*vec3(1.0,7.0,1.0)*3.0)\n                + noise(q*32.0)*0.5 + noise(q*64.0)*0.5;\n            \n            vec3 land = (desertD*desert*nD + grassD*grass*nG + snowD*snow*nS)/normn;\n            col = mix(col,land,landBlend);\n            \n            float shore = clamp(1.42*pow(1.0-abs(landBlend-0.4),1.0)-1.2,0.0,1.0);\n            col = mix(col, col + vec3(0.0,0.1,0.05),shore);\n        \n            \n            // Cloud shadows\n            q = m * q * 2.01 + iTime*0.03;\n            vec3 off = vec3(0.1);\n\t\t\tf = cloudForm(q+off);\n            f = 0.2 + 0.8*pow(1.0 - f*0.75,2.0);\n            col = col * f;\n            \n            // Clouds  \n\t\t\tf = cloudForm(q);\n            vec3 cloudCol =\n                vec3(0.2)+\n                0.7*noise(q*2.0) +\n                0.4*noise(q*6.0) +\n                0.2*noise(q*16.0) +\n                0.05*noise(q*32.0) + \n                0.04*noise(q*64.0);\n            cloudCol = (cloudCol + f*0.05)*0.55;\n            float opacityGain = 1.4;\n            float brightnessGain = 0.7;\n            col = mix(col,cloudCol*brightnessGain,min(f*opacityGain,1.0));\n            \n\t\t}\n\t\t\n        // Depth\n        float depth = tmin * 2.7 / 2.0;\n        \n        // Surface Diffuse Lighting\n\t\tcol *= (0.005 + sunNDL * lightIntensity);\n        \n        // Surface Specular\n        vec3 ref = reflect(nor,-vec3(0.0,0.0,-1.0));\n        float sunRDE = max(dot(ref,rd),0.0);\n        float spec = 0.125*pow(sunRDE,512.0);\n        col += spec*mix(col,vec3(1.0),0.05)*sunNDL;\n        \n        // Inner Atmosphere\n        float atm = -max(-1.0,1.1 - depth);\n        vec3 baseAtmCol = vec3(0.0,0.041,0.11)*1.5;\n        col = mix(col,baseAtmCol*sunNDL*lightIntensity,pow(atm,2.0));\n        \n        // Atmosphere glow\n        float glow = 0.0;\n        const int steps = 8;\n        const float di = (128.0/50.0)/float(steps);\n        for(int i = 0; i < steps; ++i)\n        {\n            vec3 px = ro + rd * float(i)*di;\n            vec3 tosc = sc - px;\n            float d = length(tosc);\n            float x = abs(d - 1.0);\n            float n = 0.01+max((-tosc/d).z,0.0);\n            glow += 5.5 * exp(-x*16.0) * n * di;\n        }\n        vec3 glowCol = glow * baseAtmCol;\n        \n\t\t// Background\n        vec3 bckg = galaxy(ro,rd) + glowCol;\n        float isBckg = 1.0-exp( -0.00001*tmin*tmin );\n\t\tcol = mix( col, vec3(bckg), isBckg );\n\t}\n\t\n\tcol = sqrt( col);\n\t\n\t//col *= smoothstep( 0.006, 0.008, abs(p.x) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt33Wj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1575, 2066, 2090, 2090, 2301], [2303, 2303, 2338, 2338, 2629], [2757, 2757, 2782, 2782, 3130], [3132, 3132, 3156, 3156, 3327], [3329, 3329, 3386, 3386, 8334]], "test": "valid"}
{"id": "Mt33Ws", "name": "RayParabolaIntersect", "author": "albertelwin", "description": "Practicing ray-parabola intersection testing", "tags": ["3d", "raycasting", "intersection", "parabola"], "likes": 7, "viewed": 207, "published": "Public", "date": "1472380698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SUPERSAMPLING 1\n\n#define TAU 6.28318530717958647692\n#define TO_RAD 0.01745329251\n#define GAMMA 2.2\n#define MAX_DIST 1000.0\n\nfloat dither(vec2 xy, float t) {\n    float s = (xy.x * 12.9898) + (xy.y * 78.2330);\n    float r = fract(sin((t * 12.9898) + s) * 43758.5453) + fract(sin((t * 78.2330) + s) * 43758.5453);\n    return (r * 0.00392156886) - 0.00196078443;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float fov = 90.0;\n    float tan_fov = tan(fov * 0.5 * TO_RAD);\n    vec2 image_plane = vec2(tan_fov, tan_fov * (iResolution.y / iResolution.x));\n\n#define MAX_SAMPLE_COUNT 8\n    vec2 sample_offsets[MAX_SAMPLE_COUNT];\n\tsample_offsets[0] = vec2(0.125, 0.875);\n    sample_offsets[1] = vec2(0.625, 0.875);\n    sample_offsets[2] = vec2(0.375, 0.625);\n    sample_offsets[3] = vec2(0.875, 0.625);\n    sample_offsets[4] = vec2(0.125, 0.375);\n    sample_offsets[5] = vec2(0.625, 0.375);\n    sample_offsets[6] = vec2(0.375, 0.125);\n    sample_offsets[7] = vec2(0.875, 0.125);\n    \n#if SUPERSAMPLING\n    #define SAMPLE_COUNT MAX_SAMPLE_COUNT\n#else\n    #define SAMPLE_COUNT 1\n#endif\n\n    vec3 color = vec3(0.0);\n\n    for(int sample_index = 0; sample_index < SAMPLE_COUNT; sample_index++) {\n        vec2 sample_pos = fragCoord.xy + sample_offsets[sample_index];\n        vec3 image_point = vec3((2.0 * sample_pos / iResolution.xy - 1.0) * image_plane, 1.0);\n\n        vec3 ro = vec3(0.0, 0.0, 2.12);\n        vec3 rd = normalize(image_point - ro);\n        \n        ro.y += 0.5;\n        \n        float t = MAX_DIST;\n        \n        //NOTE: Intersect y = x + z\n        float a = (rd.x * rd.x) + (rd.z * rd.z);\n        float b = (2.0 * rd.x * ro.x) + (2.0 * rd.z * ro.z) - rd.y;\n        float c = (ro.x * ro.x) + (ro.z * ro.z) - ro.y;\n        float d = (b * b) - (4.0 * a * c);\n        if(d > 0.0) {\n            t = (-b - sqrt(d)) / (2.0 * a);\n        }\n        \n        //NOTE: Intersect y = 0\n        float u = -ro.y / rd.y;\n        if(u > 0.0 && u < t) {\n            t = u;\n        }   \n\n        if(t < MAX_DIST) {\n            vec3 p = ro + t * rd;\n            \n            vec3 v = normalize(p);\n            float l = v.r * 0.2126 + v.g * 0.7152 + v.b * 0.0722;\n            color += clamp(1.0 - (l + t * 0.1), 0.0, 1.0);\n        }\n    }\n\n    color *= (1.0 / float(SAMPLE_COUNT));\n    color += dither(fragCoord.xy, fract(iTime));\n    color = pow(color, vec3(1.0 / GAMMA));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt33Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 165, 165, 369], [371, 371, 426, 426, 2427]], "test": "valid"}
{"id": "Mt3GDS", "name": "fract pattern - 59 chars", "author": "GregRostami", "description": "It's been a while since I posted a shader. I'm not sure if this has been done before, but here's half a tweet.", "tags": ["fract", "short", "onetweet"], "likes": 2, "viewed": 477, "published": "Public API", "date": "1471215459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o, vec2 u) { o += fract(iTime+u.x*u.y/iResolution.x); }  /*\n\n// 78 chars - Original\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o = vec4( fract( iTime + u.x*u.y / iResolution.x ) );\n    // o = vec4( fract( (u.x*u.y / iResolution.x) ); // Without animation\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3GDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 79]], "test": "valid"}
{"id": "Mt3GW2", "name": "Tunnel Beauty", "author": "aiekick", "description": "Tunnel Beauty", "tags": ["tunnel", "sss", "beauty"], "likes": 36, "viewed": 4905, "published": "Public API", "date": "1471604170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\t// get rotation matrix near z\n\nvec3 path(vec3 p)\n{\n\tp *= RotZ(p.z * 0.1);\n    p += sin(p.zxy * 0.5) * 0.5;\n\tp *= RotZ(p.z * 0.2);\n   \treturn sin(p.zxy * 0.2) * 2.;\n}\nfloat df(vec3 p)\n{\n\tp += path(p);\n\tp *= RotZ(p.z * 0.1);\n\treturn 1.1 - cos(p.z*1.5) * 0.2 - max(abs(p.x),abs(p.y)) + length(p.xy)*0.2;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n\tvec2 uv = (g+g-si)/si.y;\n\n\tfloat time = iTime*1.2;\n\t\n\tvec3 ro = vec3(0,0, time*5.);\n\tro -= path(ro);\n\t\n\tvec3 cv = ro + vec3(0,0,4); // cam view\n\tcv -= path(cv);\n\t\n\tvec3 lp = ro;\t// light pos\n\t\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<30; i++) // 30 iterations yeah :)\n\t{\n\t\tif (log(d/1e6)>0.) break; // due to this special break condition\n\t\td += df(ro+rd*d);\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(0.8,0.5,0.2);\n\tfloat sss = df(p - n*0.001)/0.01;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = blackbody(200. * sb);\t\t\t\t\t\t\t\t\t// blackbody color\n\tfloat sss2 = 0.8 - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\n\tvec3 a = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.35 + spe;\n    vec3 b = col * sss;\n    \n\tfragColor.rgb = mix(a, b, .8-exp(-0.01*d*d));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3GW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 233, 233, 291], [292, 323, 342, 342, 457], [458, 458, 476, 476, 594], [596, 596, 630, 630, 830], [832, 1053, 1081, 1081, 1406], [1408, 1490, 1547, 1547, 1771], [1773, 1773, 1809, 1809, 1942], [1944, 1944, 2001, 2001, 3534]], "test": "valid"}
{"id": "Mt3Gz2", "name": "PSX rendering", "author": "TDM", "description": "Lack of perspective-correct texturing, z-buffer, float data type and bilinear filtering lead to this kind of buggy rendering.", "tags": ["barycentric", "rasterization", "playstation", "psx"], "likes": 70, "viewed": 5386, "published": "Public API", "date": "1470515868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"PSX rendering\" by Alexander Alekseev aka TDM - 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n#define PSX_MODE\n\n#ifdef PSX_MODE\n\t#define INT_VERTICES\n\tvec2 RESOLUTION = vec2(320.0, 240.0);\n#else\n\t#define BILINEAR\n\t#define RESOLUTION iResolution.xy\n#endif\n\n// math\nfloat _cross(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\nvec3 barycentric(vec2 a, vec2 b, vec2 c, vec2 p) {    \n    vec2 ab = b - a, ac = c - a, ap = p - a;\n    vec2 vw = vec2(_cross(ap,ac),_cross(ab,ap)) / _cross(ab,ac);\n    return vec3(1.0-vw.x-vw.y, vw);\n}\nfloat quantization(float a, float b) {\n    return floor(a * b) / b;\n}\nvec2 quantization(vec2 a, float b) {\n    return floor(a * b) / b;\n}\nvec2 quantization(vec2 a, vec2 b) {\n    return floor(a * b) / b;\n}\nvec3 quantization(vec3 a, float b) {\n    return floor(a * b) / b;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise1(vec2 p) {\n    #ifndef BILINEAR\n\t\treturn hash(floor(p));\n    #else    \n        vec2 i = floor(p);\n        vec2 f = fract(p);\n    \tvec2 tx = mix(vec2(hash(i),hash(i+vec2(0.,1.))) ,\n                      vec2(hash(i+vec2(1.,0.)),hash(i+vec2(1.))),f.x);\n        return mix(tx.x,tx.y,f.y);\n    #endif\n}\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n// textures\nvec4 textureGround(vec2 uv) {\n    const vec2 RES = vec2(8.0, 8.0);    \n    float n = noise1(uv * RES);\n    n = n * 0.2 + 0.5;\n    return vec4(n*0.9,n*0.6,n*0.4,1.0);\n}\n\nvec4 textureWall(vec2 uv) {\n    const vec2 RES = vec2(32.0, 16.0);\n    vec2 iuv = floor(uv * RES);    \n    float n = noise1(uv * RES);\n    n = n * 0.5 + 0.25;\n    float nc = n * (smoothstep(1.0,0.4, iuv.x / RES.x) * 0.5 + 0.5);    \n    return vec4(nc * 0.4, nc * 1.0, nc * 0.5, n + uv.x - abs(uv.y-0.5) );\n}\n\nvec4 textureBox(vec2 uv) {\n    const vec2 RES = vec2(8.0, 8.0);\n    vec2 iuv = (floor(uv * RES) + 0.5) / RES;  \n    float n = noise1(uv * RES);\n    n = max(abs(iuv.x - 0.5), abs(iuv.y - 0.5)) * 2.0;\n    n = n * n;\n    n = 0.5 + n * 0.4 + noise1(uv * RES) * 0.1;\n    return vec4(n, n*0.8, n*0.5, 1.0);\n}\n\nvec4 textureSky(vec2 uv) {\n    const vec2 RES = vec2(8.0, 32.0);    \n    float n = noise1(uv * RES);\n    n = n * 0.05 + 0.8;\n    return vec4(0.5,n*1.0,n*1.1,1.0);\n}   \n\n// rasterization\nvoid triangle(vec2 p,\n         vec2 v0, vec2 v1, vec2 v2,\n         vec2 uv0, vec2 uv1, vec2 uv2,\n         in int tex, inout vec3 color) {\n    \n    if(_cross(v2-v0,v1-v0) <= 1e-4) return;\n    \n    vec3 bary = abs(barycentric(v0,v1,v2, p));\n    if(bary.x + bary.y + bary.z <= 1.0001) {\n        vec2 uv = uv0 * bary.x + uv1 * bary.y + uv2 * bary.z; \n        vec4 frag;        \n        if(tex == 0) {\n    \t\tfrag = textureGround(uv);\n        } else if(tex == 1) {\n            frag = textureWall(uv);\n        } else {\n            frag = textureBox(uv);\n        }\n        if(frag.w > 0.5) color = frag.xyz;\n    }\n}\nvoid quad(vec2 p,\n         vec2 v0, vec2 v1, vec2 v2, vec2 v3,\n         vec2 uv0, vec2 uv1, vec2 uv2, vec2 uv3,\n        in int tex,  inout vec3 color) {    \n    triangle(p, v0,v1,v2, uv0,uv1,uv2, tex,color);\n    triangle(p, v2,v3,v0, uv2,uv3,uv0, tex,color);\n}\n\n// geometry transformation engine\nvoid gte(inout vec3 v, mat4 mat) {   \n    \n    // perspective\n    v = (vec4(v,1.0) * mat).xyz;\n    v.xy /= max(v.z, 1.0);\n    \n    v *= 2.0;\n    \n    // quantization to simulate int\n    #ifdef INT_VERTICES    \t\n\t\tconst vec2 QUANT = vec2(320.0, 240.0) * 0.25;\n        v.xy = quantization(v.xy, QUANT);\n    #endif    \n}\n\n// renderer\nvoid gpu(vec2 p,\n         vec2 v0, vec2 v1, vec2 v2, vec2 v3,\n         vec2 uv0, vec2 uv1, vec2 uv2, vec2 uv3,\n         in int tex, inout vec3 color) {\n    \n    quad(p,\n         v0,v1,v2,v3,\n         uv0,uv1,uv2,uv3,\n         tex,color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    uv = quantization(uv, RESOLUTION * 0.5);\n        \n    const float WIDTH = 1.3;\n    const float HEIGHT = 6.0;\n    const float DEPTH = 4.0;  \n    const float LOD = 4.0;\n    \n    float time = iTime * 2.;    \n    \n    vec3 posv = vec3(-WIDTH*3.0,-2.0, -time+5.0);\n    vec3 rotv = vec3(sin(time)*0.05 + 0.1,\n             sin(time*0.9)*0.05,\n             sin(time*0.7)*0.05);\n    \n    // int-like position\n    #ifdef INT_VERTICES    \t\n        posv = quantization(posv, 64.0);\n        rotv = quantization(rotv, 256.0);    \t\n    #endif\n    \n    mat4 cam = getPosMatrix(posv);    \n    mat4 rot = getRotMatrix(rotv); \n    cam = cam * rot;\n        \n    vec3 c = textureSky(uv + vec2(rotv.y,-rotv.x) * 3.0).xyz;\n\n    vec3 vert[8];\n\n    // ground\n    float z_offset = -floor((posv.z + DEPTH * 1.5) / DEPTH) * DEPTH * 0.5;\n    float poly_depth = DEPTH;\n    \n    for(int dip = 0; dip < 32; dip++) {\n        \n        // kinda LOD\n        z_offset += step(mod(float(dip),4.0), 0.5) * poly_depth * 0.5;\n        #ifdef PSX_MODE\n        if(dip > 11) poly_depth = DEPTH * LOD; \n        #endif\n        \n        vert[0] = vec3(-WIDTH,0.0, poly_depth); \n        vert[1] = vec3(-WIDTH,0.0, 0.0);   \n        vert[2] = vec3( WIDTH,0.0, 0.0);\n        vert[3] = vec3( WIDTH,0.0, poly_depth);\n   \n        vec3 posv = vec3(mod(float(dip),4.0) * WIDTH,\n                         0.0,\n                         z_offset);        \n\n        mat4 pos = getPosMatrix(posv * 2.0);\n        mat4 mat = pos * cam;\n\n        for(int i = 0; i < 4; i++) gte(vert[i], mat);             \n        \n        gpu(uv,\n            vert[3].xy,vert[2].xy,vert[1].xy,vert[0].xy,\n            vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n            0, c);\n    }\n    \n    // walls\n    z_offset = -floor((posv.z + DEPTH ) / DEPTH) * DEPTH * 0.5;\n    poly_depth = DEPTH;\n    \n    for(int dip = 0; dip < 8; dip++) {\n        \n        // kinda LOD\n        z_offset += poly_depth * 0.5;\n        #ifdef PSX_MODE\n        if(dip > 2) poly_depth = DEPTH * LOD;     \n        #endif\n        \n        vert[0] = vec3(0.0,HEIGHT, poly_depth); \n        vert[1] = vec3(0.0,HEIGHT, 0.0);   \n        vert[2] = vec3(0.0,0.0, 0.0);\n        vert[3] = vec3(0.0,0.0, poly_depth);\n   \n        vec3 posv = vec3(WIDTH * 3.5,\n                         0.0,\n                         z_offset);\n        //posv.z -= z_offset;\n\n        mat4 posm = getPosMatrix(posv * 2.0);\n        mat4 mat = posm * cam;\n\n        for(int i = 0; i < 4; i++) gte(vert[i], mat);             \n        \n        gpu(uv,\n            vert[0].xy,vert[1].xy,vert[2].xy,vert[3].xy,\n            vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n            1, c);\n        \n        \n        vert[0] = vec3(0.0,HEIGHT, poly_depth); \n        vert[1] = vec3(0.0,HEIGHT, 0.0);   \n        vert[2] = vec3( 0.0,0.0, 0.0);\n        vert[3] = vec3( 0.0,0.0, poly_depth);\n        \n        posv = vec3(-WIDTH * 0.5,\n                         0.0,\n                         z_offset);\n\n        posm = getPosMatrix(posv * 2.0);\n        mat = posm * cam;\n\n        for(int i = 0; i < 4; i++) gte(vert[i], mat);  \n        \n        gpu(uv,\n            vert[3].xy,vert[2].xy,vert[1].xy,vert[0].xy,\n            vec2(1.0,0.0), vec2(1.0), vec2(0.0,1.0),vec2(0.0),\n            1, c);\n    }\n    \n    // box\n    vert[0] = vec3(-1.0,-1.0, 1.0);\n    vert[1] = vec3(-1.0, 1.0, 1.0);    \n    vert[2] = vec3( 1.0, 1.0, 1.0);    \n    vert[3] = vec3( 1.0,-1.0, 1.0);\n    vert[4] = vec3(-1.0,-1.0,-1.0);\n    vert[5] = vec3(-1.0, 1.0,-1.0);    \n    vert[6] = vec3( 1.0, 1.0,-1.0);    \n    vert[7] = vec3( 1.0,-1.0,-1.0);\n\n    vec3 box_posv = vec3(-posv.x,\n                     2.0,\n                     -posv.z + 15.0);\n\n    rotv = vec3(time * 0.5, time * 0.6, time * 0.7);    \n    mat4 posm = getRotMatrix(rotv) * getPosMatrix(box_posv);\n    mat4 mat = posm * cam;\n\n    for(int i = 0; i < 8; i++) {\n        vert[i].y *= 0.65;\n        gte(vert[i], mat);\n    }\n\n    gpu(uv,\n        vert[3].xy,vert[2].xy,vert[1].xy,vert[0].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    gpu(uv,\n        vert[4].xy,vert[5].xy,vert[6].xy,vert[7].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    \n    gpu(uv,\n        vert[7].xy,vert[6].xy,vert[2].xy,vert[3].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    gpu(uv,\n        vert[0].xy,vert[1].xy,vert[5].xy,vert[4].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    \n    gpu(uv,\n        vert[2].xy,vert[6].xy,vert[5].xy,vert[1].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);    \n    gpu(uv,\n        vert[0].xy,vert[4].xy,vert[7].xy,vert[3].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    \n    // fragment\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3Gz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[306, 314, 344, 344, 380], [381, 381, 431, 431, 583], [584, 584, 622, 622, 653], [654, 654, 690, 690, 721], [722, 722, 757, 757, 788], [789, 789, 825, 825, 856], [857, 857, 879, 879, 959], [960, 960, 982, 982, 1270], [1271, 1271, 1298, 1298, 1609], [1610, 1610, 1637, 1637, 1819], [1821, 1833, 1862, 1862, 2000], [2002, 2002, 2029, 2029, 2309], [2311, 2311, 2337, 2337, 2613], [2615, 2615, 2641, 2641, 2779], [2784, 2801, 2938, 2938, 3408], [3409, 3409, 3561, 3561, 3669], [3671, 3705, 3739, 3766, 4022], [4024, 4036, 4187, 4187, 4275], [4277, 4277, 4334, 4334, 9248]], "test": "error"}
{"id": "Mtc3D2", "name": "gatorball", "author": "wjbgrafx", "description": "Another experiment in object creation using domain operations, based on Shane's \"Raymarched Reflections\".", "tags": ["3d", "raymarch", "domainoperations"], "likes": 12, "viewed": 582, "published": "Public API", "date": "1471631457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"gatorball\" by wjbgrafx\n\t\n\tBased on \"Raymarched Reflections\"   Uploaded by Shane in 2015-Nov-17\n\thttps://www.shadertoy.com/view/4dt3zn\n\t\n \t\"Gardner Cos Clouds\"  Uploaded by fab on 2014-Dec-24\n\thttps://www.shadertoy.com/view/lll3z4\n\n\tHG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n\thttp://mercury.sexy/hg_sdf\n\t\n\t\"Raymarching Primitives\" - Created by inigo quilez - iq/2013\n\thttps://www.shadertoy.com/view/Xds3zN\n\n\t\"Playing with symmetries - Torus\"\t   by @paulofalcao\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n\n#define FAR                     250.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_DIST\t\t\t\t65.0 \n#define CAM_POS                 vec3( 0.0, 45.0, -CAM_DIST )\n#define CAM_FOV_FACTOR          2.0\n#define LOOK_AT                 vec3( 0.0, 0.0, 0.0 )\n#define LIGHT_POS               vec3( 0.0, 50.0, -50.0 )\n#define LIGHT_ATTEN\t\t\t\t0.0005\n\n//------------------------------------------------------------------------------\n// Function declarations\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID );\nvec3 skyColor( vec2 pix );\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\nfloat fSphere(vec3 p, float r);\nfloat fCapsule(vec3 p, float r, float c); \n\n// Repeat around the origin by a fixed angle.\nfloat pModPolar(inout vec2 p, float repetitions);\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the \n// space; translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist);\n\nfloat sdEllipsoid( in vec3 p, in vec3 r );\n\nvec2 rot( vec2 p, float r );\nvec2 rotsim( vec2 p, float s );\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map( vec3 p )\n{  \n\tvec3 p2 = p;\n\t  \n\t// Rotations\n\tp.yz = rot( p.yz, iTime * 0.43 );\n\tp.xz = rot( p.xz, iTime * 0.37 );\n\tp.xy = rot( p.xy, iTime * 0.59 );\n\t\n\t// Domain operations\n\tpModPolar( p.yz, 6.0 );\n\tpModPolar( p.xz, 6.0 );\n\t\n\tpMirrorOctant( p.xy, vec2( 6.0 ) );\n\tpMirrorOctant( p.xz, vec2( 6.0 ) );\n\n\tp.xy = rotsim( p.xy, 12.0 + 11.0 * sin( iTime * 0.11 ) );\n\tp.y -= 5.0 + 4.0 * sin( iTime * 0.31 );\n\t\n\tp.yz = rotsim( p.yz, 12.0 + 11.0 * sin( iTime * 0.17 ) );\n\tp.z -= 5.0 + 4.0 * sin( iTime * 0.43 );\n\t\n\t// Objects\t\n\tp.yz = rot( p.yz, iTime * -0.73 );\n\tp.xz = rot( p.xz, iTime * -0.87 );\n\tp.xy = rot( p.xy, iTime * -0.79 );\n\t\n\tfloat objID = 1.0,\n\t      d1 = sdEllipsoid( p, vec3( 3.1 + sin( iTime * 0.51 ),\n\t                                 3.1 + sin( iTime * 0.53 ), \n\t\t\t\t\t\t\t         3.1 + sin( iTime * 0.59 ) ) ),\n\t      d2 = fCapsule( p, 1.5, 2.75 );\n\t      \n\tvec2 obj1 = vec2( max( d1, -d2 ), objID );\n\t\n\tobjID = 2.0;\n\tvec2 obj2 = vec2( fSphere( p, 1.5 ), objID );\n\t\n\tobjID = 3.0;\n\tvec2 obj3 = vec2( fPlane( p2, vec3( 0.0, 1.0, 0.0 ), 30.0 ), objID );\n\t\n\t//---------------------------------------------------\n\t\n\tvec2 closest = obj1;\n\tclosest = closest.s < obj2.s ? closest : obj2;\n\tclosest = closest.s < obj3.s ? closest : obj3;\n\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID )\n{    \n    vec3 clr = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tclr = vec3( abs( sin( iTime * 0.13 ) ), \n\t\t            abs( sin( iTime * 0.19 ) ),\n\t\t\t        abs( sin( iTime * 0.17 ) ) );\n\t}\n\telse if ( objNum == 2.0 )\n\t{\n\t\tclr = vec3( abs( sin( iTime * 0.23 ) ), \n\t\t            abs( sin( iTime * 0.17 ) ),\n\t\t\t        abs( sin( iTime * 0.31 ) ) );\n\t}\n\telse if ( objNum == 3.0 )\t\n\t{\n\t\tclr = vec3( abs( sin( iTime * 0.17 ) ), \n\t\t            abs( sin( iTime * 0.23 ) ),\n\t\t\t        abs( sin( iTime * 0.29 ) ) );\n\t}\n\t    \n    return clr;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// For Gardner Cos Clouds skyColor()\n\tvec2 st = fragCoord.xy;\n\tst.x *= 0.5;\n\tst.x += sin( iTime * 0.1 ) * 0.5;\n\tst.y *= 0.75;\n\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec3 rayDir = getRayDir( CAM_POS, normalize( LOOK_AT - CAM_POS ), uv );   \n    vec3 rayOrig = CAM_POS;   \n    vec3 lightPos = LIGHT_POS;\n\tvec3 sceneColor = vec3( 0.0 );\n\tvec3 skyClr = skyColor( st );\n\t   \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( FAR * 0.9, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID ) * 0.85;\n\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    //sceneColor *= fog;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n    \n}\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\n// Standard raymarching routine.\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\n// Second pass, which is the first, and only, reflected bounce. Virtually the \n// same as above, but with fewer iterations and less accuracy.\n\n// The reason for a second, virtually identical equation is that raymarching is \n// usually a pretty expensive exercise, so since the reflected ray doesn't \n// require as much detail, you can relax things a bit - in the hope of speeding \n// things up a little.\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft  \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow \n    // things down. Obviously, the lowest number to give a decent shadow is the \n    // best one to choose. \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n\n        //shade = min( shade, k * h / dist );\n        // Subtle difference. Thanks to IQ for this tidbit.\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n\n        // So many options here, and none are perfect: dist += min( h, 0.2 ),etc\n        dist += min( h, stepDist * 2.0 ); \n        \n        // Early exits from accumulative distance function calls tend to be a \n        // good thing.\n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. \n    // It's a preference thing. Really dark shadows look too brutal to me.\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID )\n                                                               \n{    \n    // Light direction vector.\n    vec3 lDir = LIGHT_POS - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    vec3 objCol = getObjectColor( sp, distID );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + vec3( 1.0, 0.6, 0.2 ) *\n                                                          spec * 2.0 ) * atten;\n   \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\n// SKY COLOR\n// ---------\n// https://www.shadertoy.com/view/lll3z4\n// Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n/*\n * Gardner Cos Clouds\n *\n * Translated/adapted from the RenderMan implementation in\n * Texturing & Modeling; a Procedural Approach (3rd ed, p. 50)\n */\n \nvec3 skyColor( vec2 pix )\n{\n\tconst int nTerms = 10;\n\t\n\tfloat zoom = 1.0,\n          cloudDensity = 0.0,\n          amplitude = 0.45,\n          xphase = 0.9 * iTime,\n          yphase = 0.7,\n          xfreq = 2.0 * PI * 0.023,\n          yfreq = 2.0 * PI * 0.021,\n    \n          offset = 0.5,\n          xoffset = 37.0,\n          yoffzet = 523.0,\n    \n          x = pix.x,\n          y = pix.y,\n\t      scale = 1.0 / iResolution.x * 60.0 * 1.0 / zoom;\n\n    x = x * scale + offset + iTime * 1.5;\n    y = y * scale + offset - iTime / 2.3;\n    \n    for ( int i = 0; i < nTerms; i++ )\n    {\n        float fx = amplitude * ( offset + cos( xfreq * ( x + xphase ) ) );\n        float fy = amplitude * ( offset + cos( yfreq * ( y + yphase ) ) );\n        cloudDensity += fx * fy;\n        xphase = PI * 0.5 * 0.9 * cos( yfreq * y );\n        yphase = PI * 0.5 * 1.1 * cos( xfreq * x );\n        amplitude *= 0.602;\n        xfreq *= 1.9 + float( i ) * .01;\n        yfreq *= 2.2 - float( i ) * 0.08;\n    }\n\n    return mix( vec3(0.4, 0.6, 0.9 ), vec3( 1.0 ), cloudDensity );   \n}\n\n// end skyColor()\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n// Excerpts from HG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n// http://mercury.sexy/hg_sdf \n// Brought to you by MERCURY http://mercury.sexy\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n\n#define PHI (1.618033988749895)\n     // PHI (sqrt(5)*0.5 + 0.5)\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, \n\t                                                        step(c, abs(p.y)));\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x \n\t// direction (cell index would be e.g. -5 and 5 in the two halves of the \n\t// cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> \n// from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the \n// space; translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\n// From Playing with symmetries - Torus\t   by @paulofalcao\t\n// http://glslsandbox.com/e#29755.0\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtc3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2187, 2202, 2222, 2222, 3466], [3564, 3605, 3649, 3649, 4208], [4317, 4346, 4403, 4441, 6379], [6481, 6514, 6555, 6555, 6998], [7284, 7546, 7591, 7591, 7910], [8044, 8249, 8307, 8307, 9553], [9687, 9760, 9789, 9904, 10115], [10219, 10244, 10386, 10421, 11309], [11411, 11454, 11515, 11515, 11802], [11987, 12264, 12291, 12291, 13319], [13764, 13792, 13824, 13824, 13849], [13851, 13925, 13981, 13981, 14023], [14025, 14078, 14120, 14120, 14272], [14274, 14387, 14437, 14437, 14833], [14835, 14931, 14974, 14974, 15025], [15027, 15151, 15197, 15197, 15306], [15471, 15585, 15628, 15628, 15688], [15950, 16076, 16102, 16102, 16196], [16198, 16355, 16384, 16384, 16495]], "test": "error"}
{"id": "Mtc3Rs", "name": "fractal voronoi texture", "author": "KukaTails", "description": "fractal sum of voronoi noise function", "tags": ["woronoi", "faractal"], "likes": 2, "viewed": 165, "published": "Public", "date": "1470856499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return -1.0 + 2.0 * fract(sin(h) * 4358.5453);\n}\n\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\n\n\nfloat Voronoi(vec2 x)\n{\n    ivec2 p = ivec2(floor(x));\n    vec2  f = fract(x);\n\n    float res = 8.0;\n    for(int j = -1; j <= 1; ++j)\n        for(int i = -1; i <= 1; ++i) {       ivec2 b = ivec2(i, j);\n        vec2  r = vec2(b) - f + 0.5 + 0.4 * sin(iTime + 6.2831 * Noise(vec2(p + b)));\n        float d = dot(r, r);\n        res = min(res, d);\n    }\n    return sqrt(res);\n}\n\nvec3 VoronoiFn(vec2 x)\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    \n    float f1 = 18.0;\n    float f2 = 18.0;\n    float f3 = 18.0;\n    for (int j = -1; j <= 1; ++ j) {\n        for (int i = -1; i <= 1; ++ i) {\n            ivec2 b = ivec2(i, j);\n            vec2 r = vec2(b) + 0.5 + 0.4 * sin(iTime * 1.0 + 6.2831 * Noise(vec2(p + b))) - f;;\n            float d = dot(r, r);\n            \n            if (d < f1) {\n                f3 = f2;\n                f2 = f1;\n                f1 = d;\n            } else if (d < f2) {\n                f3 = f2;\n                f2 = d;\n            } else if (d < f3) {\n                f3 = d;\n            }\n        }\n    }\n    return vec3(f1, f2, f3);       \n}\n\n\nfloat FbmNoise(vec2 p)\n{\n  const float octaves = 4.0;\n  const float lacunarity = 2.0;\n  const float H = 2.0;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    vec3 val = VoronoiFn(p);\n    value += (val.y - val.x) * pow(lacunarity, -H * i);\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder != 0.0) {\n    value += remainder * Noise(p) * pow(lacunarity, -H * k);\n  }\n  return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float val = 0.0;\n\n    vec3 f_vec = VoronoiFn(10.0 * uv);\n\n    if (uv.x < 0.0 && uv.y < 0.0) {\n        val = f_vec.x;\n    }\n    if (uv.x < 0.0 && uv.y > 0.0) {\n        val = f_vec.y;\n    }\n    if (uv.x > 0.0 && uv.y < 0.0) {\n        val = f_vec.z + f_vec.x - f_vec.y;\n    }\n    if (uv.x > 0.0 && uv.y > 0.0) {\n        val = f_vec.y - f_vec.x;\n    }\n    val = FbmNoise(5.0 * uv);\n    \n    fragColor = vec4(sin(val * 0.1), sin(val), sin(val + 0.1), 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtc3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 114], [117, 117, 138, 138, 429], [433, 433, 456, 456, 806], [808, 808, 832, 832, 1516], [1519, 1519, 1543, 1543, 1966], [1969, 1969, 2025, 2025, 2554]], "test": "valid"}
{"id": "Mtc3RX", "name": "Icosahedron twist", "author": "tdhooper", "description": "Twisting around each vertex of an icosahedron, a sort of smooth spidroball.", "tags": ["sdf", "icosahedron", "twist", "spidroball"], "likes": 118, "viewed": 3116, "published": "Public API", "date": "1470503706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --------------------------------------------------------\n// OPTIONS\n// --------------------------------------------------------\n\n//#define DEBUG\n\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n\nfloat t;\n\n#define saturate(x) clamp(x, 0., 1.)\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector13b normalize(vec3(0, PHI, -1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector14b normalize(vec3(0, -PHI, -1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector15b normalize(vec3(1, 0, -PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector16b normalize(vec3(-1, 0, -PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector17b normalize(vec3(PHI, -1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n#define GDFVector18b normalize(vec3(-PHI, -1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// --------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n// --------------------------------------------------------\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nint Type=5;\nvec3 nc;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\nvec3 vMin(vec3 p, vec3 a, vec3 b, vec3 c) {\n    float la = length(p - a);\n    float lb = length(p - b);\n    float lc = length(p - c);\n    if (la < lb) {\n        if (la < lc) {\n            return a;\n        } else {\n            return c;\n        }\n    } else {\n        if (lb < lc) {\n            return b;\n        } else {\n            return c;\n        }\n    }\n}\n\n// Nearest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    if (p.z > 0.) {\n        if (p.x > 0.) {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13, GDFVector15, GDFVector17);\n            } else {\n                return vMin(p, GDFVector14, GDFVector15, GDFVector17b);\n            }\n        } else {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13, GDFVector16, GDFVector18);\n            } else {\n                return vMin(p, GDFVector14, GDFVector16, GDFVector18b);\n            }\n        }\n    } else {\n        if (p.x > 0.) {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13b, GDFVector15b, GDFVector17);\n            } else {\n                return vMin(p, GDFVector14b, GDFVector15b, GDFVector17b);\n            }\n        } else {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13b, GDFVector16b, GDFVector18);\n            } else {\n                return vMin(p, GDFVector14b, GDFVector16b, GDFVector18b);\n            }\n        }\n    }\n}\n\n// Nearest vertex and distance.\n// Distance is roughly to the boundry between the nearest and next\n// nearest icosahedron vertices, ensuring there is always a smooth\n// join at the edges, and normalised from 0 to 1\nvec4 icosahedronAxisDistance(vec3 p) {\n    vec3 iv = icosahedronVertex(p);\n    vec3 originalIv = iv;\n\n    vec3 pn = normalize(p);\n    pModIcosahedron(pn);\n    pModIcosahedron(iv);\n\n    float boundryDist = dot(pn, vec3(1, 0, 0));\n    float boundryMax = dot(iv, vec3(1, 0, 0));\n    boundryDist /= boundryMax;\n\n    float roundDist = length(iv - pn);\n    float roundMax = length(iv - vec3(0, 0, 1.));\n    roundDist /= roundMax;\n    roundDist = -roundDist + 1.;\n\n    float blend = 1. - boundryDist;\n\tblend = pow(blend, 6.);\n    \n    float dist = mix(roundDist, boundryDist, blend);\n\n    return vec4(originalIv, dist);\n}\n\n// Twists p around the nearest icosahedron vertex\nvoid pTwistIcosahedron(inout vec3 p, float amount) {\n    vec4 a = icosahedronAxisDistance(p);\n    vec3 axis = a.xyz;\n    float dist = a.a;\n    mat3 m = rotationMatrix(axis, dist * amount);\n    p *= m;\n}\n\nfloat model(vec3 p) {\n    # ifndef DEBUG\n    \tfloat wobble = sin(PI/2. * t);\n    \tfloat wobbleX2 = sin(PI/2. * t*2.);\n    \tpR(p.xy, wobbleX2 * .05);\n    \tpR(p.xz, wobbleX2 * .05);\n    \tfloat a = -wobble * 3.;\n        pTwistIcosahedron(p, a);\n    # endif\n    return fIcosahedron(p, 1.);\n}\n\n// Spectrum from 0 - 1\n// Brightens for values over 1\n// Darkens for values below 0\nvec3 debugSpectrum(float n) {\n    vec3 c = spectrum(n);\n    c *= 1. + min(sign(n), .0) * .3;\n    c *= 1. + max(sign(n - 1.), 0.);\n    return c;\n}\n\nvec3 material(vec3 p, vec3 norm, vec3 ref) {\n    # ifdef DEBUG\n        vec4 a = icosahedronAxisDistance(p);\n        float dist = a.a;\n        return debugSpectrum(dist);\n    # else\n        return norm * 0.5 + 0.5;\n    # endif\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 30.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n\n//--------------------------------\n// Modelling\n//--------------------------------\nvec2 map( vec3 p ){\n    vec2 res = vec2(model(p), 1.);\n    return res;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return vec2( res , id );\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n\n    float x = mouse.x;\n    float y = mouse.y;\n    \n    x += .68;\n    y += .44;\n    \n    float dist = 3.3;\n    float height = 0.;\n    camPos = vec3(0,0,-dist);\n    vec3 axisY = vec3(0,1,0);\n    vec3 axisX = vec3(1,0,0);\n    mat3 m = rotationMatrix(axisY, -x * PI * 2.);\n    axisX *= m;\n    camPos *= m;\n    m = rotationMatrix(axisX, -(y -.5) * PI*2.);\n    camPos *= m;\n    camPos.y += height;\n    camTar = -camPos + vec3(.0001);\n    camTar.y += height;\n    camRoll = 0.;\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n\n    vec3 color = vec3(.04,.045,.05);\n    color = vec3(.7, .8, .8);\n    vec3 pos = ro + rd * res.x;\n\n    if (res.y == 1.){\n        vec3 norm = calcNormal( pos );\n        vec3 ref = reflect(rd, norm);\n        color = material(pos, norm, ref);\n    }\n\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initIcosahedron();\n    t = iTime - .25;\n    t = mod(t, 4.);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n\n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    vec2 res = calcIntersection( camPos , rd  );\n\n\n    vec3 color = render( res , camPos , rd );\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtc3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2003, 2026, 2064, 2064, 2208], [2210, 2210, 2247, 2247, 2460], [2462, 2462, 2482, 2482, 2520], [2522, 2596, 2652, 2652, 2697], [2699, 2937, 2969, 2969, 3014], [3016, 3044, 3106, 3106, 3230], [3232, 3422, 3467, 3467, 3933], [3935, 4129, 4153, 4186, 4351], [4353, 4353, 4389, 4389, 4526], [4528, 4696, 4764, 4764, 4807], [4809, 4809, 4833, 4833, 4931], [4933, 5062, 5105, 5105, 5423], [5425, 5455, 5487, 5487, 6462], [6464, 6679, 6717, 6717, 7293], [7295, 7345, 7397, 7397, 7547], [7549, 7549, 7570, 7570, 7836], [7838, 7922, 7951, 7951, 8067], [8069, 8069, 8113, 8113, 8296], [8560, 8654, 8683, 8683, 8719], [8722, 8805, 8824, 8824, 8877], [8879, 8879, 8927, 8927, 9365], [9368, 9399, 9463, 9463, 9641], [9643, 9643, 9741, 9741, 10214], [10216, 10329, 10360, 10360, 10600], [10604, 10604, 10648, 10648, 10915], [10918, 10918, 10975, 10975, 11669]], "test": "valid"}
{"id": "MtcGDl", "name": "dynaflo", "author": "wjbgrafx", "description": "Another domain repetition experiment.", "tags": ["3d", "raymarch", "domain", "repetition"], "likes": 5, "viewed": 471, "published": "Public API", "date": "1472313120", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"dynaflo\" by wjbgrafx\n\t\n\tbased on :\n\t\t\n\tRaymarched Reflections   Uploaded by Shane in 2015-Nov-17\n\thttps://www.shadertoy.com/view/4dt3zn\n\t\n\tPlaying with symmetries - Torus\t   by @paulofalcao\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n\tHG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n\thttp://mercury.sexy/hg_sdf\n\t\n\tArray and textureless GLSL 2D/3D/4D simplex noise functions.\n    Ian McEwan, Ashima Arts.\n\t\n\tpyramid function from \"pyramids\"    Uploaded by avix in 2014-Jan-16\n\thttps://www.shadertoy.com/view/lsBGzG\n*/\n//==============================================================================\n#define PI                      3.1415926535897932384626433832795\n\n#define FAR                     275.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_FOV_FACTOR          1.5\n#define LIGHT_COLOR\t\t\t\tvec3( 1.0 )\n#define LIGHT_ATTEN\t\t\t\t0.0075\n\n//------------------------------------------------------------------------------\n// Function declarations\n//----------------------\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID,\n                                                            in vec3 lightPos );\nvec2 rot( vec2 p, float r );\nvec2 rotsim( vec2 p, float s );\n\nfloat pMod1(inout float p, float size); \nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset); \nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\nfloat fSphere(vec3 p, float r);\n \nfloat pyramid( vec3 p, float h);  \nfloat modPyramid( vec3 p, float h, float baseScale ); \nfloat cutoutPyramid( vec3 p, float height );\nfloat modCutoutPyramid( vec3 p, float height, float scaleVal );\n\nfloat snoise(vec3 v);\n\n//==============================================================================\n// MAP\n// ---\n\nvec2 map( vec3 p )\n{  \n\tfloat dist = 3.0;\n\tpReflect( p, normalize( vec3( 1.0, -1.0, 0.0 ) ), dist );\n\tpReflect( p, normalize( vec3( -1.0, -1.0, 0.0 ) ), dist );\n\t\n\tpMod1( p.z, 10.0 );\n\tvec3 p2 = p;\n\t\n\t// Rotation for obj2\n\tp2.xz = rot( p2.xz, iTime * 0.31 );\n\n\tp2.xz = rotsim( p2.xz, 2.5 );\n\tp2.z -= 3.5;\n\t\n\tfloat objID = 1.0;\t      \n\tvec2 obj1 = vec2( fPlane( p, vec3( 0.0, 1.0, 0.0 ), 5.0 ), objID );\n\t\n\tobjID = 2.0;\n\tvec2 obj2 = vec2( modCutoutPyramid( p2 - vec3( 0.0, -3.0, 0.0 ), \n\t                                                      3.0, 1.25 ), objID );\n\t// Rotation for obj3\n\tp2.xz = rot( p2.xz, iTime * -0.53 );\n\t\n\tobjID = 3.0;\n\tvec2 obj3 = vec2( modPyramid( p2 - vec3( 0.0, -2.85, 0.0 ), 1.75, 1.1 ), \n\t                                                                   objID );\n\tobjID = 4.0;\n\tvec2 obj4 = vec2( fSphere( p2 - vec3( 0.0, 0.7, 0.0 ), 0.7 ), objID );\n\t\n\tvec2 closest = obj1;\n\tclosest = closest.s < obj2.s ? closest : obj2;\n\tclosest = closest.s < obj3.s ? closest : obj3;\n\tclosest = closest.s < obj4.s ? closest : obj4;\n\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID, vec3 rayDir )\n{    \n    vec3 clr = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tclr = vec3( abs( 0.1 + 0.9 * sin( iTime * 0.03 ) ), \n\t\t            abs( 0.1 + 0.9 * sin( iTime * 0.05 ) ),\n\t\t\t        abs( 0.1 + 0.9 * sin( iTime * 0.07 ) ) );\n\n\t\t// wjb modified Perlin Noise 3D : texture 21\n\t\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t\t// on white background\n\t\tvec3 pos = distID.s * rayDir;\n\t\tpos.z += iTime * 3.0; //move texture at same speed as camera moves\n\t\t\n\t\tfloat scale = 0.5,\n\t\t      complexity = 5.0,\n\t\t      mixVal = 0.5;\n\t\t\n\t\tvec3 v = pos * scale;\n\t\tfloat value = \n\t\t            exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) );\n\t    value = 0.75 + value * 0.25;\n\t    // original modified to negate white bkgd, make clr more dominant \n\t    // ( 1.0 - value )\n\t    vec3 color = vec3( 1.0 - value );    \t\t    \n\t    clr = mix( color, clr, mixVal );        \t\t\t\t\t\n\t}\n\telse if( objNum == 2.0 )\n    {\n\t\tclr = vec3( abs( 0.2 + 0.8 * sin( iTime * 0.11 ) ), \n\t\t            abs( 0.1 + 0.9 * sin( iTime * 0.07 ) ),\n\t\t\t        abs( 0.3 + 0.7 * sin( iTime * 0.05 ) ) );\n\t}\n\telse if( objNum == 3.0 )\n    {\n\t\tclr = vec3( abs( 0.3 + 0.7 * sin( iTime * 0.07 ) ), \n\t\t            abs( 0.1 + 0.9 * sin( iTime * 0.17 ) ),\n\t\t\t        abs( 0.2 + 0.8 * sin( iTime * 0.13 ) ) );\n\t}\n\telse if( objNum == 4.0 )\n    {\n\t\tclr = vec3( abs( 0.1 + 0.9 * sin( iTime * 0.13 ) ), \n\t\t            abs( 0.1 + 0.9 * sin( iTime * 0.17 ) ),\n\t\t\t        abs( 0.1 + 0.9 * sin( iTime * 0.11 ) ) );\n\t}\n\t    \n    return clr;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec3 camPos = vec3( 2.5 * sin( iTime * 0.43 ), \n                  4.0 + 2.5 * sin( iTime * 0.51 ), \n                                   iTime * 3.0 );\n    vec3 lookAt = camPos + vec3( 0.0, 0.0, camPos.z + 10.0 );\n    vec3 rayDir = getRayDir( camPos, normalize( lookAt - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n\n    vec3 lightPos = vec3( 0.0, 0.0, \n         camPos.z - 120.0 + \n                         mod( iTime * pow( iTime, 0.6 ), 310.0 ) ); \n\n\tvec3 sceneColor = vec3( 0.0 );\n\tvec3 skyClr = vec3( 0.1 + 0.9 * abs( sin( iTime * 0.03 ) ), \n\t\t                0.1 + 0.9 * abs( sin( iTime * 0.05 ) ),\n\t\t\t            0.1 + 0.9 * abs( sin( iTime * 0.07 ) ) );\n\t   \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( ( camPos.z + FAR ) * 0.25, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID, lightPos );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID, lightPos ) \n\t                                                                     * 0.9;\n\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    sceneColor *= fog;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);    \n}\n\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\n// Standard raymarching routine.\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\n// Second pass, which is the first, and only, reflected bounce. Virtually the \n// same as above, but with fewer iterations and less accuracy.\n\n// The reason for a second, virtually identical equation is that raymarching is \n// usually a pretty expensive exercise, so since the reflected ray doesn't \n// require as much detail, you can relax things a bit - in the hope of speeding \n// things up a little.\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow \n    // things down. Obviously, the lowest number to give a decent shadow is the \n    // best one to choose. \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n\n        //shade = min( shade, k * h / dist );\n        // Subtle difference. Thanks to IQ for this tidbit.\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n\n        // So many options here, and none are perfect: dist += min( h, 0.2 ),etc\n        dist += min( h, stepDist * 2.0 ); \n        \n        // Early exits from accumulative distance function calls tend to be a \n        // good thing.\n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit.\n    // It's a preference thing. Really dark shadows look too brutal to me.\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID,\n                                                             in vec3 lightPos )\n{    \n    // Light direction vector.\n    //vec3 lDir = LIGHT_POS - sp; \n    vec3 lDir = lightPos - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    // wjb added rayDir as argument in order to allow texturing of objects.\n    vec3 objCol = getObjectColor( sp, distID, rayDir );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + LIGHT_COLOR * spec * 2.0 ) * \n                                                                         atten;\n  \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// From Playing with symmetries - Torus\t   by @paulofalcao\t\n// http://glslsandbox.com/e#29755.0\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------\n// HG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n// http://mercury.sexy/hg_sdf\n\n// Sign function that doesn't return 0\nfloat sgn(float x) \n{\n\treturn (x<0.)?-1.:1.;\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) \n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) \n{\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\t\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n//------------------------------------------------------------------------------\n\n// From \"pyramids\"    Uploaded by avix in 2014-Jan-16\n// https://www.shadertoy.com/view/lsBGzG\n// Pyramid with base on xz-plane at y=0.0, h = height, width, and depth\nfloat pyramid( vec3 p, float h) \n{\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\n}\n\n//------------------------------------------------------------------------------\n\n// Modified from pyramid(), above.\n// Pyramid with base on xz-plane at y=0.0, h = height, s = scaling factor for\n// length of an edge of the square pyramid base, where edge length = s * h, \n// i.e., h = 2.0, s = 0.5, base edge = 1.0; or h = 2.0, s = 2.0, base edge = 4.0\n// s MUST BE >= 0.5\n                        \nfloat modPyramid( vec3 p, float h, float s ) \n{\n\tvec3 q = abs( p );\n\tfloat scale = 1.0 / s;\n\treturn max( -p.y, ( q.x * scale + q.y + q.z * scale - h ) / 3.0 );\n}\n\n//------------------------------------------------------------------------------\n// wjb : This should replace cutoutPyramid, as it allows adjustment of size of\n// cutout.\nfloat modCutoutPyramid( vec3 p, float height, float scaleVal )\n{\n\tvec3 p2 = p;\n\tp2.xz = rot( p2.xz, PI * 0.25 );\n\t\n\tfloat d1 = pyramid( p2, height ),\n\t      d2 = modPyramid( p - vec3( 0.0, 0.1, 0.0 ),  \n\t                                       height * ( scaleVal / 1.5 ), 1.35 );\n\treturn max( d1, -d2 );\n}\n//------------------------------------------------------------------------------\n// wjb : works for pyramid height of 0.5 and greater.\nfloat cutoutPyramid( vec3 p, float height )\n{\n\tfloat scaleVal = 1.3;\n\tif ( height < 1.0 )\t{\tscaleVal = 1.1;\t}\n\t\t\n\tvec3 p2 = p;\n\tp2.xz = rot( p2.xz, PI * 0.25 );\n\t\n\tfloat d1 = pyramid( p2, height ),\n\t      d2 = modPyramid( p - vec3( 0.0, 0.1, 0.0 ),  \n\t                                       height * ( scaleVal / 1.5 ), 1.35 );\n\treturn max( d1, -d2 );\n}\n//------------------------------------------------------------------------------\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D and 2D Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ---------------------------------\n    \n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), \n                                                                  dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), \n                                                             dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n//------------------------------------------------------------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1919, 2015, 2035, 2035, 3079], [3177, 3218, 3275, 3275, 4805], [4914, 4943, 5000, 5069, 7415], [7518, 7551, 7592, 7592, 8035], [8321, 8583, 8628, 8628, 8947], [9081, 9285, 9343, 9343, 10588], [10722, 10795, 10824, 10939, 11151], [11255, 11280, 11437, 11507, 12483], [12585, 12628, 12689, 12689, 12976], [13177, 13303, 13329, 13329, 13423], [13425, 13582, 13611, 13611, 13722], [13897, 13936, 13957, 13957, 13982], [13984, 14128, 14169, 14169, 14290], [14292, 14320, 14383, 14383, 14489], [14491, 14565, 14621, 14621, 14663], [14665, 14665, 14697, 14697, 14722], [14805, 14972, 15006, 15006, 15065], [15149, 15465, 15512, 15512, 15626], [15628, 15799, 15863, 15863, 16104], [16105, 16240, 16285, 16285, 16593], [16932, 17363, 17384, 17384, 17441], [17451, 17451, 17472, 17472, 17529], [17539, 17539, 17561, 17561, 17609], [17619, 17619, 17651, 17651, 17711], [17721, 17721, 17749, 17749, 20454]], "test": "error"}
{"id": "MtcGRj", "name": "timed exclusive", "author": "tomaes", "description": "watch while you can. =)\n\n(and yes, it's an early version of 'fleur du mal')", "tags": ["hassciencegonetoofar"], "likes": 7, "viewed": 375, "published": "Public", "date": "1470216938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 r(vec2 _uv, float _t)\n{\n     \n    vec4 f = vec4( mod(sin(_t+(_uv.x/_uv.y)*length(_uv))+atan(_uv.x,_uv.y),fract(_t-length(_uv)))*(10.+sin(_t-length(_uv))*17.)/length(_uv-tan(_t*2.+_uv.x*10./_uv.y))*4.,\n                  (abs(sin(_t*.5)*.1)) /sqrt(length(_uv)),\n                   sqrt(length(_uv))*.75 - .05/fract(mod(_uv.x,.16)*2. + mod(_uv.y,.16)*2.),\n                   1.);\n    \n    f *= vec4(length(f)*.1-length(_uv));\n    \n    return f;\n}\n\n\nvoid mainImage( out vec4 ff, in vec2 fc )\n{\n    float t = iTime + 2.65;\n    vec2 uv = (fc.xy-iResolution.xy*.5) / iResolution.y+sin(t)*.4;\n\n    uv.x += sin(t*2.5)*.2;\n    uv.y += cos(t*2.5)*.2;\n            \n    ff = r(uv,t) / r(uv,t+.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 448], [451, 451, 494, 494, 690]], "test": "valid"}
{"id": "MtcGWj", "name": "017 mini ray marching", "author": "kakaxizhhgjh", "description": "A minimum ray marching shader, works on firefox. What suprise me is that it failed at chrome and opera, report error message: X4579 NaN and infinity literals not allowed.. \nyou can test on your browser.", "tags": ["raymarching", "bug"], "likes": 1, "viewed": 158, "published": "Public", "date": "1471543671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSI = 1e-3;\nconst float TMAX = 1e3;\n\nfloat sphere(vec3 p) {\n    return length(p) - 1.0;\n}\n\nmat3 getCamera(vec3 eye, vec3 target) {\n\tvec3 z = normalize(eye - target);\n    vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    return mat3(x, cross(z, x), z);\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n    for(int i = 0; i < 48; ++i) {\n    \tfloat d = sphere(ro + t * rd);\n        if(abs(d) < EPSI) return t;\n        if(t > TMAX) return TMAX;\n        t += d;\n    }\n    return TMAX;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(3.0 * sin(iTime), 0.0, 3.0 * cos(iTime));\n    vec3 rd = getCamera(ro, vec3(0.0)) * normalize(vec3(uv, -1.0));\n    \n    vec3 color = vec3(1.0);\n    float t = trace(ro, rd);\n    if(t < TMAX) color = vec3(1.0, 0.0, 0.0) * max(dot(normalize(vec3(1.0)), normalize(ro + t * rd)), 0.0); \n    fragColor = vec4(pow(color, vec3(0.45)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 72, 72, 102], [104, 104, 143, 143, 271], [273, 273, 304, 304, 501], [503, 503, 558, 558, 977]], "test": "valid"}
{"id": "Mtd3RS", "name": "Blood Tunnel", "author": "aiekick", "description": "Blood Tunnel", "tags": ["tunnel", "blood"], "likes": 8, "viewed": 706, "published": "Public API", "date": "1470063422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nvec2 path(float t){\treturn vec2(cos(t*0.2), sin(t*0.2)) * 2.;}\n\nvec2 df(vec3 p)\n{\n\tp.xy -= path(p.z);\n\tfloat hex = (max(abs(p.x) + p.y, -p.y) + max(abs(p.x) - p.y, p.y));\n\tfloat tex = texture(iChannel0, (abs(p.xz) + abs(p.yz))*0.28).r * atan(p.x,p.y)/3.14159 * 1.;\n\tp*=3.;\n\tfloat maze = cos(3.14 * (p.x + p.y * sign(sin(1e3 * length(floor(p.xy))))));\n\treturn vec2(0.8 * hex - maze * 0.12 + tex - 4.8 , 2.);\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n = vec3(0);\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.076);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(40.*sb+0.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.08);\t// normal at surface point\n    \n    // derived from bumpmap func from shane\n    const vec2 e = vec2(0.1, 0);\n    mat3 m = mat3( tex3D(iChannel0, e.xyy, n), tex3D(iChannel0, e.yxy, n), tex3D(iChannel0, e.yyx, n));\n   \tvec3 g = vec3(1,0,0) * m * 20.;\n    g -= n * dot(n, g);\n    n =  normalize( n + g );\n    \n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.1242; \t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 7.8); \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb * li + spe, \n        (diff + fre + bb * sb * 0.608 + sss * 0.352) * amb * li + spe * 0.612 \t\n    );\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = -iTime*3.;\n\n    vec2 si = iResolution.xy;\n    vec2 g = fragCoord;\n    \n    vec2 uv = (g+g-si)/si.y;\n    \n    vec3 col = vec3(0.);\n    \n\tvec3 ro = vec3(path(t),t);\n  \tvec3 cv = vec3(path(t),t+.1);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 20.,s = 1.,d = 0.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (s<.025*log(d*d/s/500.)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s * 0.3;\n    }\n    \n    if (iMouse.z > 0.)\n        if (iMouse.x < si.x * 0.5)\n\t\t\td = min(d,d*d*d/md); // weird but cool also\n       \telse\n    \t\td = min(d*.6,d*d*d/md); // another flame version\n    \n    fragColor.rgb = mix(\n        shade(ro, rd, d, ro, 1.2).yzw, \n        vec3(.2,0,0), \n        1.-exp(-0.01*d*d)\n    );\n    \n    fragColor.a = 1.;\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtd3RS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 233, 233, 276], [278, 278, 295, 295, 622], [624, 624, 661, 661, 873], [875, 1096, 1124, 1124, 1449], [1451, 1533, 1590, 1590, 1824], [1826, 1826, 1862, 1862, 1997], [1999, 2175, 2226, 2226, 2397], [2399, 2399, 2457, 2457, 3575], [3577, 3577, 3623, 3623, 3793], [3795, 3795, 3852, 3852, 4634]], "test": "error"}
{"id": "MtdGzf", "name": "Plasma tree", "author": "sillsm", "description": "Plasma tree", "tags": ["raymarching", "tree"], "likes": 1, "viewed": 167, "published": "Public", "date": "1470720813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Max Sills 2016, licensed under the MIT license.\n// Plasma tree\n#define PI 3.14159265\n#define MIRROR\n//#define DEBUG\nstruct Datum\n{\n  vec3 location;\n  float distance;\n  float material;\n};\n\nmat4 Ry (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, 0, -s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Rz (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Disp (vec3 displacement)\n{\nreturn  mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(displacement, 1)\n); \n}\n\n// Derived from http://www.bidouille.org/prog/plasma\nfloat plasma2 (vec2 uv)\n{\n    uv *= 2.;\n    float v = sin((uv.x+iTime));\n    v += sin((uv.y+iTime)/2.0);\n    v += sin((uv.x+uv.y+iTime)/2.0);\n    vec2 c = uv/2.0 * vec2(sin(iTime/3.0), cos(iTime/2.0));\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+iTime);\n    v = v/2.0;\n    return v;\n}\n\nvec2 opU( float d1, float d2, float m1, float m2 )\n{\n    return (d1<d2) ? vec2(d1, m1) : vec2(d2, m2);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p )\n{ \n\treturn p.y;\n}\n\n// Rounded box with a plasma displacement.\nfloat pudBox( vec3 p, vec3 b )\n{\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  float dist = max(length(max(abs(p)-b,0.0)) - 1., -1.*(length(p)));\n  return dist - plasma2(5.*p.xy)/6.;\n}\n\n\nmat4 branch(float a_y, float a_z, float height, float b_len) \n{\n    mat4 dd = Disp(vec3(b_len*sin(a_z),-height + b_len*cos(a_z),0));\n    return Rz(a_z) * dd * Ry(a_y);\n}\n\nfloat tree(vec3 p)\n{\n  vec4 hom = vec4(p, 1); //homogenous coordinates.\n\n  float b1_a = 2.0;\n  float phi = iTime; // How much you want to rotate branch\n    \n  // First branch\n  float replication = clamp((iTime + 2.)/2., 3., 7.);\n  mat4 b1_f = branch(PI/replication - PI, b1_a, 3., 9.);\n    \n  // Second branch\n  float r2 = clamp((iTime+12.)/2., 3., 5.);;\n  float b2_a = 1.1;\n  float b2_size = clamp(iTime+1.,1.,5.);\n  float c = clamp(iTime+2.,1.,5.);\n  mat4 b2_f = branch(PI/r2 - PI, b2_a, -6., b2_size);   \n    \n  // Reflection symmetry around trunk for first branch.\n  hom = Ry(-phi) * hom;\n  float theta = atan(hom.z, hom.x);//(goes from -pi to pi)\n  float t = theta;\n  t = mod(t, 2.*PI);\n  #ifdef MIRROR\n  t = mod(t, 2.*PI/replication);\n  #endif\n  float r = length(hom.xz);\n  vec3 new_p = vec3(r*cos(t), hom.y, r*sin(t));\n    \n  // Debug Code\n  #ifdef DEBUG\n  if ((t > 2.*PI/replication - .1 && t < 2.*PI/replication + .1) ||\n      t < .1 && t > -.1) return 15.;\n  #endif   \n    \n  // Reflection symmetry around first branch for second branch.\n  hom = Ry(-phi)* b1_f * vec4(new_p, 1);\n  theta = atan(hom.z, hom.x);//(goes from -pi to pi)\n  t = theta;\n  t = mod(t, 2.*PI);\n  #ifdef MIRROR\n  t = mod(t, 2.*PI/r2);\n  #endif\n  r = length(hom.xz);\n  vec3 new_p2 = vec3(r*cos(t), hom.y, r*sin(t));\n     \n  // Apply branch coordinate system to symmetry coordinates.  \n  vec4 b1_p = b1_f * vec4(new_p,1);\n  vec4 b2_p = b2_f * vec4(new_p2,1);\n  vec4 b3_p = Disp(vec3(0.,b2_size-2.,0)) * b2_p;\n  \n  // Place a trunk, two branches, and abox.\n  float trunk = sdCappedCylinder(p, vec2(3., 6));\n  float b1 = sdCappedCylinder(b1_p.xyz, vec2(.5, 6));\n  float b2 = sdCappedCylinder(b2_p.xyz, vec2(.25, b2_size));\n  float b3 = pudBox(b3_p.xyz,vec3(.5,.5,.5));\n    \n  return min(b3,min(b2, min(b1, trunk)));    \n}\n\n// Returns distance_to_shape, material index\nvec2 scene(vec3 ray)  \n{\n    float planeMat = .4;\n    float boxMat   = .1;\n    return opU(tree(ray), sdPlane(ray), boxMat, planeMat);\n}\n\nDatum trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    const float hitThreshold = 0.001;\n    vec3 p = vec3(0);\n    float t = 0.0;\n    float m = 0.0;\n    for (int i = 0; i < 100; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* ray);\n        vec2 data = scene(p);\n        float dist = data.x;\n        m  = data.y;\n        t += dist;// * .9;\n        \n        if ( dist < hitThreshold ){\n            break;\n        }\n    }\n    return Datum(p, t, m);\t\t\t\t\t\t\n}\n\n// iq normal\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\n// Stolen from nmz\nfloat f(in vec2 p)\n{\n    return sin(p.x+sin(p.y+iTime*0.1)) * sin(p.y*p.x*0.1+iTime*0.2);\n}\n\n// Stolen from nmz\nvec2 field(in vec2 p)\n{\n\tvec2 ep = vec2(.05,0.);\n    vec2 rz= vec2(0);\n\tfor( int i=0; i<7; i++ )\n\t{\n\t\tfloat t0 = f(p);\n\t\tfloat t1 = f(p + ep.xy);\n\t\tfloat t2 = f(p + ep.yx);\n        vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\n\t\tvec2 t = vec2(-g.y,g.x);\n        \n        p += .9*t + g*0.3;\n        rz= t;\n\t}\n    \n    return rz;\n}\n\n\n// Stolen from ming's tutorial.\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.1;\n\t//float vis = shadow( pos, toLight, 0.01, toLightLen );\n\tfloat vis = 1.;//shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tcomb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\n// Given distance to shape, material index, world coord, and pixel, color.\nvec4 color (float t, float m, vec3 p, vec2 uv)\n{\n    float v = plasma2(5.*p.xy);\n    t = clamp(t, -5., 5.);\n    vec3 col = 5.*(1./t)*vec3(1, sin(3.14*v), cos(3.14*v));\n    col *= .8; // Gamma correction.\n\n    if (length(p) > 100.) {\n        float v2 = plasma2(uv*20.);\n        col = .5*vec3(sin(v2), sin(v2 + iTime), sin(v2+7.)); \n        return vec4(col,0);\n    }\n    if (abs(m -.4) < .001) {\n        vec2 fld = field(p.xz*.10);\n        col = sin(vec3(-.3,0.1,0.5)+fld.x-fld.y)*0.65+0.35;\n    }\n    vec3 nrm = calcNormal(p);\n    vec4 light1 = vec4(20., 20., -10.0, 40.0 );\n    vec3 cc  = shade(p,nrm,light1);\n    //return vec4(cc,0);\n\n    return cc.x*vec4(col, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float f = 3.; // f-stop.\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    // Rotate the viewer position (near clipping plane center).\n    vec3 position = vec3(0,0,-40.);\n    position += vec3(20.*cos(iTime/5.), 30., -60.*abs(sin(iTime/5.)));\n    position += vec3(iMouse.x/10.,0,iMouse.y/10.);\n    \n    #ifdef DEBUG\n    position = vec3(0,40,1);\n    #endif\n    \n    mat4 mat = LookAtRH(position, vec3(0,0,0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(mat*(pixel - vec4(0,0,-f,1))).xyz;\n    \n    Datum d     = trace(ray, pt);\n    fragColor   = color(d.distance, d.material, d.location, uv); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdGzf.jpg", "access": "shaders20k", "license": "mit", "functions": [[113, 201, 224, 224, 405], [407, 407, 430, 430, 611], [613, 613, 644, 644, 772], [774, 827, 852, 852, 1106], [1108, 1108, 1160, 1160, 1212], [1214, 1214, 1256, 1256, 1355], [1357, 1357, 1382, 1382, 1398], [1400, 1443, 1475, 1523, 1631], [1634, 1634, 1697, 1697, 1803], [1805, 1805, 1825, 1825, 3603], [3605, 3650, 3674, 3674, 3785], [3787, 3787, 3831, 3831, 4231], [4233, 4246, 4278, 4278, 4511], [4513, 4583, 4632, 4632, 5010], [5012, 5031, 5051, 5051, 5122], [5124, 5143, 5166, 5166, 5465], [5468, 5500, 5546, 5546, 6016], [6018, 6093, 6141, 6141, 6760], [6762, 6762, 6819, 6819, 7591]], "test": "valid"}
{"id": "Mtt3Ds", "name": "1st Raymarch Shader", "author": "teessider", "description": "My 1st attempt at Raymarching some spheres.", "tags": ["procedural", "3d", "raymarch", "sphere"], "likes": 1, "viewed": 93, "published": "Public", "date": "1472640894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Originally ased on tutorial by dila:\n// https://www.youtube.com/watch?v=yxNnRSefK94\n\nconst int MAX_STEPS = 32;\nconst float STEP_SIZE = 0.75;\n\n// Distance Functions are based on the primitives from iq\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Signed Sphere Distance Function\nfloat sphere(vec3 pos, float radius)\n{\n    //return length(pos) - radius;\n    return sqrt(dot(pos, pos)) - radius;\n}\n\n// Evaluate distance function(s) in here.\n// Setting up for a full scene later.\nfloat scene(vec3 pos)\n{\n    float s1 = sphere(pos + vec3(0.0, 0.0, -2.0), sin(iTime));\n    float s2 = sphere(pos + vec3(sin(1.0 - iTime), sin(iTime), -1.5), 0.5);\n    \n    float s1s2 = min(s1, s2);\n    float s3 = sphere(pos + vec3(-sin(1.0 - iTime), -sin(iTime), -1.5), 0.5);\n    return min(s1s2, s3);\n}\n\n/*\n* Raymarching loop\n* origin \t= Ray origin (rayOrigin)\n* ray \t\t= Normalized Ray (rayDirection)\n*/\nfloat raymarch(vec3 origin, vec3 ray)\n{\n    // t = intersection plane/clipping plane/total distance\n    float t = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = scene(origin + ray * t);\n        t += dist * STEP_SIZE;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Remap UVs from (0 to 1) to (-1 to 1)\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    // Aspect Ratio correction\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n    // The rayDirection.z value controls the Field Of View (FOV). 1.0 = 90 degrees FOV.\n    \n    float r = raymarch(rayOrigin, rayDirection);\n    // From geoff - Simple Diffuse lighting (with light pointing from right)\n    vec3 point = rayOrigin + rayDirection * r;\n    vec3 normal = normalize(point - vec3(100.0, 0.0, 0.0));\n    vec3 light = normalize(rayOrigin - point);\n    float NdotL = max(dot(normal, light), 0.0);\n    \n    vec3 color = vec3(1.0, 1.0, 0.0) * NdotL;\n    vec3 bgColor = mix(vec3(0.5, 0.0, 0.125), vec3(0.125, 0.375, 0.125), (fragCoord.xy / iResolution.xy).y);\n\n    vec3 finalColor = mix(bgColor, color, 1.0 / r);\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtt3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 313, 351, 386, 429], [431, 511, 534, 534, 814], [816, 916, 955, 1015, 1189], [1191, 1191, 1248, 1289, 2199]], "test": "valid"}
{"id": "Mtt3zl", "name": "meteor shower", "author": "cabbibo", "description": "trying to see if I can use smoothmin to make a pretty looking explosion", "tags": ["noise", "raytrace", "smoothmin"], "likes": 13, "viewed": 809, "published": "Public API", "date": "1471015478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2;   \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    vec2 m = mix( b, a, h ); \n    return vec2( m.x - k*h*(1.0-h) , m.y );\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n               \t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    \n    float cycleVal =.7;// mod( iTime , 6. )/6.;\n    float astPos = .8 - cycleVal;\n    vec2 planet = vec2( sdSphere( pos - vec3( -.5 , -.3 , -0.4 ) , .8 ) , 1. ); \n    vec2 asteroid = vec2( sdSphere( pos - vec3( .3 , .2 , 0.1 ) * astPos * 6. , .3 ) , 2. );\n\n    \n   \tvec2 resFlat = opU( planet, asteroid );\n    vec2 resSmooth = smin( planet, asteroid , cycleVal * .3 );\n    float blendDif = resSmooth.x - resFlat.x;\n    \n    vec2 res = resFlat;\n    \n    res.x += cycleVal * 5. * (noise( (pos + cycleVal) * 10. ) + .6 * noise( (pos - cycleVal) * 30. ) + .3 * noise( (pos + cycleVal) * 60. )) * blendDif;\n    res.y = resSmooth.y;\n    \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nvec3 astroidCol( vec3 pos , vec3 norm ){\n    \n float light = dot( norm , normalize(vec3( -1 , -1,.3)));\n    \n   vec3 col = texture( iChannel0 , pos.xy ).xyz;\n   vec3 col2 = texture( iChannel1 , pos.xy * 2. ).xyz;\n    \n   vec3 lCol =.4* max(0. , light ) * vec3( 2. , .5 , .5 );\n   return 1.4 * ( .3 * length(col2) * length( col2 ) + (lCol)); //+ vec3( .6 , .2 , .2 ))); \n    \n}\n\nvec3 planetCol( vec3 pos , vec3 norm ){\n \n   float light = dot( norm , normalize(vec3( 1 , 1,0)));\n    \n   vec3 col = texture( iChannel0 , pos.xy + vec2( iTime * .01 , 0.)).xyz;\n   //vec3 col2 = texture( iChannel1 , pos.xy * .3 ).xyz;\n    \n   vec3 lCol = light * vec3( 1. , .5 , .2 );\n   return 2. * (col * col + (lCol + vec3( .2 , .2 , .2 ))) ;\n    \n    \n}\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0. );\n    \n  vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n      \n    vec3 lightDir = normalize( lightPos - pos );\n    \n    float match = max( 0. , dot( lightDir , norm ));\n      \n    float splodVal = max(0.,.5 - abs(1.5 -res.y)); \n      \n      \n    vec3 pCol = planetCol( pos , norm );\n      \n    vec3 aCol = astroidCol( pos , norm );\n      \n    vec3 impactCol = vec3( 1. , 0. , 0.) * match * .5 + 2.*vec3( .6 , .4 , 0. ) * splodVal * match;\n      \n    color = mix( pCol , aCol , max( res.y-1. , 0.) );\n    color = mix( color, impactCol , max(splodVal * splodVal * 10. ,0.));\n      \n\t//color = aCol;\n        \n        \n  }\n   \n  return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3( sin( iTime) * .5, 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtt3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 291, 355, 355, 533], [535, 629, 658, 658, 694], [696, 696, 727, 727, 823], [825, 825, 860, 860, 884], [887, 887, 925, 925, 1055], [1057, 1057, 1080, 1080, 1119], [1121, 1121, 1144, 1213, 1584], [1589, 1673, 1694, 1694, 2361], [2365, 2365, 2413, 2413, 2880], [2884, 2997, 3028, 3028, 3254], [3258, 3258, 3298, 3298, 3634], [3636, 3636, 3675, 3675, 3993], [3996, 3996, 4040, 4040, 4818], [4822, 4822, 4879, 4879, 5380]], "test": "error"}
{"id": "MttGD2", "name": "a cauliflower", "author": "saharan", "description": "looks delicious!", "tags": ["3d", "fractal"], "likes": 18, "viewed": 291, "published": "Public", "date": "1471848710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 dist(vec3 z) {\n    float r;\n    float time = iTime;\n    float ang = 2.0 * 3.14159265358979 / (24.0 + sin(time * 0.7 + z.y * 0.4) * 16.0);\n    float s = sin(ang);\n    float c = cos(ang);\n    float ang2 = 2.0 * 3.14159265358979 / (22.0 + cos(time * 0.9 + z.z * 0.7) * 16.0);\n    float s2 = sin(ang2);\n    float c2 = cos(ang2);\n    float distAcc = 0.0;\n    float offsetX = sin(time * 0.2) * 0.5;\n    for (int n = 0; n < 12; n++) {\n        if(z.x+z.y<0.0) z.xy = -z.yx;\n        if(z.x+z.z<0.0) z.xz = -z.zx;\n        if(z.y+z.z<0.0) z.zy = -z.yz;\n\n        distAcc += length(z) * pow(2.0, -float(n + 1));\n\n        if (length(z) > 8.0) {\n            return vec2((length(z) - 1.0) * pow(2.0, -float(n + 1)), distAcc);\n        }\n\n        z = vec3(\n            z.x * c - z.z * s,\n            z.y,\n            z.x * s + z.z * c\n        );\n\n        z = z * 2.0 - vec3(1, 1, 1);\n        z.xyz = z.xzy;\n\n        z = vec3(\n            z.x * c2 - z.y * s2,\n            z.x * s2 + z.y * c2,\n            z.z\n        );\n        z.x += offsetX;\n    }\n    return vec2((length(z) - 1.0) * pow(2.0, -12.0), distAcc);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.00001;\n    float base = dist(p).x;\n    return normalize(vec3(\n        dist(p + vec3(eps, 0.0, 0.0)).x - base,\n        dist(p + vec3(0.0, eps, 0.0)).x - base,\n        dist(p + vec3(0.0, 0.0, eps)).x - base\n    ));\n}\n\nvec3 colorGen(vec3 base, vec3 amplitude, vec3 frequency, vec3 shift, float t) {\n    return base + amplitude * cos(6.283185 * (frequency * t + shift));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenPos = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    float screenZ = 0.6;\n    vec3 rayDir = normalize(vec3(screenPos, screenZ));\n    vec3 rayPos = vec3(0, 0, -2);\n\n    float time = iTime;\n    float ang = time * 0.08 + iMouse.x / iResolution.x * 10.0;\n    float s = sin(ang);\n    float c = cos(ang);\n    rayDir = vec3(\n        rayDir.x * c - rayDir.z * s,\n        rayDir.y,\n        rayDir.x * s + rayDir.z * c\n    );\n    rayPos = vec3(\n        rayPos.x * c - rayPos.z * s,\n        rayPos.y,\n        rayPos.x * s + rayPos.z * c\n    );\n\n    if (dist(rayPos).x < 0.0) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        return;\n    }\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float totalDist = 0.0;\n    float hit = 0.0;\n    float minDist = 1000000.0;\n\n    for (int i = 0; i < 64; i++) {\n        float d = dist(rayPos).x;\n        minDist = min(d, minDist);\n        rayPos += rayDir * d;\n        totalDist += d;\n        if (d < 0.01) {\n            color = vec3(1.0, 1.0, 1.0) / (1.0 + totalDist * 0.0);\n            hit = 1.0;\n            break;\n        }\n    }\n    if (hit > 0.5) {\n        vec3 normal = estimateNormal(rayPos);\n        vec3 lightDir = normalize(vec3(1.0, -1.0, 2.0));\n        lightDir = vec3(\n            lightDir.x * c - lightDir.z * s,\n            lightDir.y,\n            lightDir.x * s + lightDir.z * c\n        );\n        float ambient = 0.2;\n        float diffuse = 0.8;\n        float brightness = max(-dot(lightDir, normal), 0.0) * diffuse + ambient;\n        float r = dist(rayPos).y;\n        color = colorGen(vec3(0.6, 0.4, 0.6), vec3(0.6, 0.6, 0.4), vec3(1.5, 0.9, 0.2), vec3(0.7, 0.3, 0.25), 1.0 - r) * brightness;\n    } else {\n        color = colorGen(vec3(0.5), vec3(0.5), vec3(0.7, 0.2, 0.5), vec3(0.4, 0.3, 0.4), minDist * 2.0);\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 1100], [1102, 1102, 1131, 1131, 1364], [1366, 1366, 1445, 1445, 1518], [1520, 1520, 1575, 1575, 3418]], "test": "valid"}
{"id": "MttGRj", "name": "Sine flowers", "author": "ivansafrin", "description": "#shaderaday #1", "tags": ["2d", "sketch", "flowers"], "likes": 9, "viewed": 1049, "published": "Public API", "date": "1470339189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float checkDist = 0.025 + abs(sin(((iTime*floor(uv.x*10.0))+atan(mod(uv.x, 0.1)-0.05, mod(uv.y, 0.1)-0.05)*floor(uv.y * 10.0)))) * 0.025;\n    float val = (distance(mod(vec2(uv.x, uv.y), 0.1), vec2(0.05, 0.05)) < checkDist) ? 1.0 : 0.0;\n    fragColor = vec4(0.2, 0.3, 0.4, 1.0) * (1.0-val) + vec4(1.0, 0.9*uv.y, 0.4, 1.0) * val;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 432]], "test": "valid"}
{"id": "MttGRS", "name": "Hanger", "author": "Sobaya", "description": "A wooden hanger.", "tags": ["3d", "distancefunction", "wood"], "likes": 1, "viewed": 167, "published": "Public", "date": "1470049346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float fov = 0.2;\nconst float eps = 0.001;\nconst float pi = 3.1415926535;\n\nfloat rand(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 114514.1919810))) * 43758.5453);\n}\n\nfloat interpolate(float x, float y, float t) {\n  t = t * t * (3. - 2. * t);\n  return x * (1.-t) + y * t;\n}\n\nfloat irand(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  float rand1 = rand(i);\n  float rand2 = rand(i+vec3(1,0,0));\n  float rand3 = rand(i+vec3(0,0,1));\n  float rand4 = rand(i+vec3(1,0,1));\n  float rand5 = rand(i+vec3(0,1,0));\n  float rand6 = rand(i+vec3(1,1,0));\n  float rand7 = rand(i+vec3(0,1,1));\n  float rand8 = rand(i+vec3(1,1,1));\n  float t1 = interpolate(rand1, rand2, f.x);\n  float t2 = interpolate(rand3, rand4, f.x);\n  float t3 = interpolate(rand5, rand6, f.x);\n  float t4 = interpolate(rand7, rand8, f.x);\n  float s1 = interpolate(t1, t2, f.z);\n  float s2 = interpolate(t3, t4, f.z);\n  return interpolate(s1, s2, f.y);\n}\n\nfloat noise(vec3 p) {\n  float t = 0.;\n  for (int i = 0; i < 8; i++) {\n    float freq = pow(2., float(i));\n    float amp = pow(0.5, float(8-i));\n    t += irand(p / freq) * amp;\n  }\n  return t;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 rotate(vec3 p, vec3 n, float a) {\n  a *= pi / 180.;\n  float c = cos(a);\n  float s = -sin(a);\n   mat3 m = mat3(\n       n.x*n.x*(1.-c)+c, n.x*n.y*(1.-c)+n.z*s, n.x*n.z*(1.-c)-n.y*s,\n       n.y*n.x*(1.-c)-n.z*s, n.y*n.y*(1.-c)+c, n.y*n.z*(1.-c)+n.x*s,\n       n.z*n.x*(1.-c)+n.y*s, n.z*n.y*(1.-c)-n.x*s, n.z*n.z*(1.-c)+c\n       );\n   return m * p;\n}\n\nvec3 scale(vec3 p, vec3 s) {\n  return p / s;\n}\n\nfloat distHook(vec3 p) {\n  p = rotate(p, vec3(0,1,0), iTime * 300.);\n  p = scale(p, vec3(0.8, 1,1));\n  p = translate(p, vec3(0,1,0));\n  float sub = length(translate(p, vec3(-0.7,-0.7,0))) - 0.8;\n  vec2 q = vec2(length(p.xy) - 1., p.z);\n  return max(length(q) - 0.1, -sub);\n}\n\nfloat distPoll(vec3 p) {\n  p = translate(p, vec3(0,-1,0));\n  p = scale(p, vec3(1,5,1));\n  vec2 d = abs(vec2(length(p.xz), p.y)) - 0.15;\n  return min(max(d.x, d.y), 0.) + length(max(d,0.));\n}\n\nfloat distMetalBall(vec3 p) {\n  p = rotate(p, vec3(0,1,0), iTime * 300.);\n  p = translate(p, vec3(-0.80,0.9,0));\n  return length(p) - 0.2;\n}\n\nfloat distMetalUnder(vec3 p) {\n  p.x = abs(p.x);\n  p = translate(p, vec3(4,-5,0));\n  p = scale(p, vec3(1,10,1));\n  vec2 d = abs(vec2(length(p.xz), p.y)) - 0.05;\n  return min(max(d.x, d.y), 0.) + length(max(d,0.));\n}\n\nfloat distMetal(vec3 p) {\n  float result = smin(distHook(p), distPoll(p), 17.);\n  result = smin(result, distMetalBall(p), 17.);\n  result = min(result, distMetalUnder(p));\n  return result;\n}\n\nfloat distWood1(vec3 p) {\n  p = scale(p, vec3(0.1+abs(p.y) * 0.5,1,1));\n  p = translate(p, vec3(0,-1.5,0));\n  return length(max(abs(p) - vec3(1.0,0.6,0.2), 0.));\n}\n\nfloat distWood2(vec3 p) {\n  p.x = abs(p.x);\n  p = translate(p, vec3(0,-1.5,0));\n  p = rotate(p, vec3(0,0,1) , -35.);\n  p = scale(p, vec3(1, p.x * p.x * 0.07 +2., p.x * p.x * p.x * 0.03 +1.));\n  vec3 s = vec3(0);\n  vec3 e = vec3(5, 0, 0);\n  vec3 ps = p - s;\n  vec3 es = e - s;\n  float h = clamp(dot(ps, es) / dot(es, es), 0., 1.);\n  float d = length(ps - es * h) - 0.2;\n  float sub = p.y;\n  return max(d, -sub);\n}\n\nfloat distWood(vec3 p) {\n  return smin(distWood1(p), distWood2(p), 17.);\n}\n\n\nfloat distUnder(vec3 p) {\n  p = translate(p, vec3(0,-5.5,0));\n  p = scale(p, vec3(20,1,1));\n  vec2 d = abs(vec2(length(p.yz), p.x)) - 0.2;\n  return min(max(d.x, d.y), 0.) + length(max(d,0.));\n}\n\nfloat dist(vec3 p) {\n  p = translate(p, vec3(0,3,0));\n  float result = min(distMetal(p), distWood(p));\n  result = min(result, distUnder(p));\n  return result;\n  //return result-0.2-0.04*(sin(iTime/3.+p.x*p.x*0.3)+sin(20.*iTime/3.+p.y*p.y*0.2)+sin((iTime/3.+p.z*p.z*0.3)));\n}\n\nint getNearestIndex(vec3 p) {\n  p = translate(p, vec3(0,3,0));\n  float dist = distMetal(p);\n  int idx = 0;\n  float d = distWood(p);\n  if (d < dist) {\n    dist = d;\n    idx = 1;\n  }\n  d = distUnder(p);\n  if (d < dist) {\n    dist = d;\n    idx = 2;\n  }\n  return idx;\n}\n\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n        dist(p+vec3(eps,0,0)) - dist(p),\n        dist(p+vec3(0,eps,0)) - dist(p),\n        dist(p+vec3(0,0,eps)) - dist(p)\n      ));\n}\n\n\nvec3 rayMarch(vec3 eye, vec3 ray) {\n  vec3 current = eye;\n  for (int i = 0; i < 200; i++) {\n    float d = dist(current);\n    current += ray * d;\n    if (abs(d) < eps) {\n      break;\n    }\n  }\n  return current;\n}\n\nvec2 cubeMap(vec3 current, vec3 vec) {\n  vec2 result;\n  vec3 tmp;\n  float minT = 1145141919.;\n  float size = 100.;\n  float t;\n\n  //===========x\n  t = (size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n  }\n\n  t = -t;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n  }\n\n  //===============y\n  t = (size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n  }\n\n  t = -t;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n  }\n\n  //==============z\n  t = (size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n  }\n\n  t = -t;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n  }\n  return result  / (2. * size) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float angle = -.5 * iTime;\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 n = normalize(vec3(0,1,0));\n    mat3 rot;\n\trot[0][0] = n[0]*n[0]*(1.-c)+c;\n\trot[0][1] = n[0]*n[1]*(1.-c)-n[2]*s;\n\trot[0][2] = n[2]*n[0]*(1.-c)+n[1]*s;\n\trot[1][0] = n[0]*n[1]*(1.-c)+n[2]*s;\n\trot[1][1] = n[1]*n[1]*(1.-c)+c;\n\trot[1][2] = n[1]*n[2]*(1.-c)-n[0]*s;\n\trot[2][0] = n[2]*n[0]*(1.-c)-n[1]*s;\n\trot[2][1] = n[1]*n[2]*(1.-c)+n[0]*s;\n\trot[2][2] = n[2]*n[2]*(1.-c)+c;\n\n  \tvec3 eye = vec3(0,0,-5);\n \teye = rot * eye;\n \tvec3 ray = vec3(uv, sqrt(2.) * tan(fov));\n \tray = rot * ray;\n\tray = normalize(ray);\n \tvec3 current = rayMarch(eye, ray);\n\n \tvec3 lightPos = vec3(1,1,-1) * 10.;\n\n\t if (abs(dist(current)) < eps) {\n \t \tvec3 n = getNormal(current);\n    \tvec3 eyeVec = normalize(eye - current);\n    \tvec3 lightVec = normalize(lightPos - current);\n    \tvec3 refVec = reflect(-lightVec, n);\n    \tfloat diffuse = max(0.,dot(eyeVec, n));\n    \tfloat spec = max(0.,dot(eyeVec, refVec));\n     \tint idx = getNearestIndex(current);\n     \tif (idx == 0) {\n        \tvec4 reflectColor = texture(iChannel0, cubeMap(current, refVec));\n        \tfragColor = reflectColor * 0.2 + vec4(0.5,0.5,0.5,1) * 0.8;\n        \tfragColor *= diffuse;\n        \tfragColor += pow(spec, 5.);\n     \t} else if (idx == 1) {\n        \tvec3 dir = vec3(0.01,0.2,0.5);\n        \tfloat t = noise(current * noise(current * 100.) * 3000. * dir);\n        \tvec4 lightColor = vec4(213,136,76,255) / 255.;\n        \tvec4 darkColor = vec4(vec3(lightColor.rgb / 4.), 1);\n        \tfragColor = mix(lightColor, darkColor, t) * diffuse;\n        \tfragColor += lightColor * pow(spec, 30.) * (1.-t);\n      \t} else if (idx == 2) {\n        \tfragColor = vec4(0,0,0,1) * diffuse;\n      \t}\n\t} else {\n    \tfragColor = vec4(0.25);\n    \tfragColor.a = 1.;\n \t}\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 100, 100, 183], [185, 185, 231, 231, 291], [293, 293, 314, 314, 935], [937, 937, 958, 958, 1130], [1132, 1132, 1171, 1171, 1238], [1240, 1240, 1272, 1272, 1290], [1292, 1292, 1330, 1330, 1642], [1644, 1644, 1672, 1672, 1690], [1692, 1692, 1716, 1716, 1966], [1968, 1968, 1992, 1992, 2158], [2160, 2160, 2189, 2189, 2300], [2302, 2302, 2332, 2332, 2517], [2519, 2519, 2544, 2544, 2708], [2710, 2710, 2735, 2735, 2873], [2875, 2875, 2900, 2900, 3287], [3289, 3289, 3313, 3313, 3363], [3366, 3366, 3391, 3391, 3559], [3561, 3561, 3581, 3581, 3834], [3836, 3836, 3865, 3865, 4101], [4103, 4103, 4127, 4127, 4286], [4289, 4289, 4324, 4324, 4500], [4502, 4502, 4540, 4540, 5426], [5428, 5428, 5485, 5485, 7371]], "test": "error"}
{"id": "MttGWs", "name": "Escher Gradient Field", "author": "gltracy", "description": "sample code of escher effects, reference shaders : https://www.shadertoy.com/view/Mdf3zM, and https://www.shadertoy.com/view/Ml33R7", "tags": ["escher"], "likes": 15, "viewed": 473, "published": "Public", "date": "1472532250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// writtern by @ephtracy\n#define PI (3.14159265)\n\nvec2 escher( vec2 p, float es ) {\n\tp = vec2( log( length( p ) ), atan( p.y, p.x ) ) - iTime * 0.1;\n    \n\tfloat r = es / ( 2.0 * PI );\n\n\tp += p.yx * vec2( r, -r );\n\n\tp.x = mod( p.x, es ) - 0.25 * es;\n\n    p = exp( p.x * 0.465 ) * vec2( cos( p.y ), sin( p.y ) ); // <-- remove 0.465\n    \n   \tp *= exp( ceil( log( max( abs( p.x ), abs( p.y ) ) ) ) ); // <-- droste\n    \n\treturn p;\n}\n\nvec2 uvMap( vec2 v ) {\n    return escher( ( v - iResolution.xy * 0.5 ) / ( iResolution.y * 0.65 ), 1.0 );\n}\n\nfloat draw( float d, vec2 g, float size, float sharp )\t{\n    return smoothstep( size * sharp, size, d / length( g ) );\n}\n\n///////////////////////////////////////////////////\nfloat map( vec2 v ) {\n    v = uvMap( v );\n    return ( v.x * v.x - v.y * v.y );\n}\n\nvec2 gradient( vec2 v ) {\n    const float s = 1.0;\n    float dx = ( map( v + vec2( s, 0.0 ) ) - map( v - vec2( s, 0.0 ) ) );\n    float dy = ( map( v + vec2( 0.0, s ) ) - map( v - vec2( 0.0, s ) ) ); \n    return vec2( dx, dy ) / ( s + s );\n}\n\nfloat map_grad( vec2 v ) {\n   \tv = uvMap( v );\n    return ( log(abs(v.x) + 0.00001) + log(abs(v.y) + 0.00001) );\n}\n\nvec2 gradient_grad( vec2 v ) {\n    const float s = 0.1;\n    float dx = ( map_grad( v + vec2( s, 0.0 ) ) - map_grad( v - vec2( s, 0.0 ) ) );\n    float dy = ( map_grad( v + vec2( 0.0, s ) ) - map_grad( v - vec2( 0.0, s ) ) ); \n    return vec2( dx, dy ) / ( s + s );\n}\n\n///////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = fragCoord.xy;\n    \n    vec3 final = vec3( 0.0 );\n  \n    \n    // gradient field\n    {\n        float d = map_grad( u );\n        vec2 g = gradient_grad( u );\n        \n        vec3 color = vec3( 1.0, 0.6, 0.3 ) * (max(1.0 - abs(d), 0.0)+0.3) * 0.4;\n      \t\n        final = mix( final, color, draw( abs(mod( d, 0.1) - 0.05), g, 1.0, 0.5 ) );\n    }\n    \n    // level set\n    {\n        float d = map( u );\n    \tvec2 g = gradient( u );\n        \n        vec3 color = vec3( 1.0, 0.6, 0.3 ) * (max(1.0 - abs(d), 0.0)+0.3);\n    \t\n        final = mix( final, color, 1.0 - draw( abs(mod(d, 0.2) - 0.1), g, 1.8, 0.5 ) );\n    }\n     \n\tfragColor = vec4( 1.0 - final, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 83, 83, 429], [431, 431, 453, 453, 538], [540, 540, 596, 596, 660], [662, 714, 735, 735, 795], [797, 797, 822, 822, 1037], [1039, 1039, 1065, 1065, 1153], [1155, 1155, 1185, 1185, 1420], [1422, 1474, 1531, 1531, 2200]], "test": "valid"}
{"id": "MttGWX", "name": "Rejmarschning", "author": "DanielPettersso", "description": "Playing with ray marching signed distance fields. Stealing a lot of stuff from iq..", "tags": ["raymarching"], "likes": 2, "viewed": 142, "published": "Public", "date": "1472503857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float RAY_PRECISION = 0.002;\nconst float MAX_RAY_LENGTH = 10.;\nconst int MAX_MARCHING_STEPS = 50;\nconst float AMBIENCE = 0.01;\n\nfloat sdPlane(vec3 p) {\n\treturn p.y+texture(iChannel0, p.xz*.5).x*-.04;\n}\n\nfloat sdSphere(in vec3 pos, in float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdRoundBox( vec3 pos, vec3 size, float rounding) {\n    vec2 tp = vec2(pos.x+pos.z,pos.y+pos.z);\n    pos += texture(iChannel1, tp*.3).xyz*.02;\n\treturn length(max(abs(pos) - size, 0.0)) - rounding;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(-d2, d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opBlend(vec2 a, vec2 b) {\n    float k = 0.3;\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    float xx = mix( b.x, a.x, h ) - k*h*(1.0-h);\n    float yy = (a.x<b.x) ? a.y : b.y;\n    return vec2(xx, yy);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 queryDistanceFields(in vec3 pos) {\n    \n    vec3 repPos = opRep(pos, vec3(4., 0., 4.));\n    \n    vec2 thingy = vec2(\n        opSub(\n            sdRoundBox(repPos, vec3(1.), .1), \n            sdSphere(repPos, 1.4)\n        ), \n        1.\n    );\n    vec2 plane = vec2(sdPlane(pos+vec3(0., .4, 0.)), 2.);    \n    vec2 pillars = opBlend(thingy, plane);\n    \n    vec3 ballPos = vec3(cos(iTime*2.)*2.1, 0., sin(iTime*2.)*2.1);\n    vec3 ballRepPos = opRep(pos+vec3(4.,0.,0.), vec3(8., 0., 8.));\n    vec2 ball = vec2(sdSphere(ballRepPos - ballPos, .5), 3.);\n    \n    return opU(ball, pillars);\n    \n    \n}\n\nvec2 rayMarch(in vec3 rayOrigin, in vec3 rayDirection) {\n    \n    float rayLength = 0.;\n    float material = -1.;\n    \n    for (int i=0; i<MAX_MARCHING_STEPS; i++) {\n        \n        vec2 res = queryDistanceFields(rayOrigin+rayDirection*rayLength);\n        rayLength += res.x;\n\t    material = res.y;\n        \n        if (res.x < RAY_PRECISION || rayLength > MAX_RAY_LENGTH) break; \n       \n    }\n\n    if (rayLength > MAX_RAY_LENGTH) material=-1.0;\n    return vec2( rayLength, material );\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    queryDistanceFields(pos+eps.xyy).x - queryDistanceFields(pos-eps.xyy).x,\n\t    queryDistanceFields(pos+eps.yxy).x - queryDistanceFields(pos-eps.yxy).x,\n\t    queryDistanceFields(pos+eps.yyx).x - queryDistanceFields(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat softshadow(in vec3 shadowPoint, in vec3 directionToLight, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<64; i++) {\n\t\tfloat h = queryDistanceFields(shadowPoint + directionToLight * t).x;\n        res = min( res, 3.0*h/t );\n        t += clamp( h, 0.01, 0.05);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 getBaseColor(in float material, in vec3 hitPosition, in vec3 reflectDirection) {\n    if (material == 1.) {\n        vec2 tp = vec2(hitPosition.x+hitPosition.z,hitPosition.y+hitPosition.z);\n    \treturn texture(iChannel1, tp*.3).xyz;\n    } else if (material == 2.) {\n        return texture(iChannel0, hitPosition.xz*.5).xyz;\n    } else if (material == 3.) {\n        return reflectDirection; \n    }\n    return vec3(1.);\n}\n\nvec3 getColor(in vec2 marchResult, in vec3 rayOrigin, in vec3 rayDirection) { \n    \n    float material = marchResult.y;\n    float rayLength = marchResult.x;\n    \n    if (material < 0.) {\n    \treturn vec3(0.);    \n    } else { \n        \n        vec3 lightDirection = normalize( vec3(cos(iTime*.3), 2., sin(iTime*.3)+3.) );\n        vec3 hitPosition = rayOrigin + rayLength * rayDirection;\n        vec3 normal = calcNormal(hitPosition);\n        vec3 ref = reflect(rayDirection, normal);\n        \n        vec3 baseColor = getBaseColor(material, hitPosition, ref);\n        float ambience = AMBIENCE + AMBIENCE * normal.y;\n        float diffuse = clamp(dot(normal, lightDirection), 0.0, 1.0);\n        \n        float shadowAmount = softshadow(hitPosition, lightDirection, 0.01, 5.);  \n        \n        diffuse *= shadowAmount;\n        diffuse += ambience;\n        diffuse *= pow((MAX_RAY_LENGTH-rayLength)/MAX_RAY_LENGTH,2.);\n        \n        return baseColor * diffuse + vec3(1.) * pow(diffuse, 10.);    \n    }\n}\n\nvec3 render(in vec3 rayOrigin, in vec3 rayDirection) { \n    vec2 res = rayMarch(rayOrigin, rayDirection);\n    return getColor(res, rayOrigin, rayDirection);\n}\n\nmat3 cameraMatrix(in vec3 ro, in vec3 ta, float cr) {\n    \n    // this math is beyond me =(\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // pixel coordinates ranging from -1 to 1\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    // mouse input\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    float spinAngle = iTime * .06 + 6.0 * mo.x;\n    \n    // camera\t\n    \n\tvec3 rayOrigin = vec3(\n        -0.5 + 3.5 * cos(spinAngle), \n        2.5 + 2.0 * mo.y, \n        0.5 + 3.5 * sin(spinAngle)\n    );\n    \n\tvec3 target = vec3(0.);    \n    float fieldOfView = 2.; // lower value = more fow\n    \n    mat3 cm = cameraMatrix(rayOrigin, target, 0.);\n    vec3 rayDirection = cm * normalize(vec3(p.xy,fieldOfView));\n    \n    // render\t\n    \n    vec3 col = render(rayOrigin, rayDirection);\n    \n    // gamma correction\n    \n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n    \n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 157, 157, 207], [209, 209, 255, 255, 290], [292, 292, 348, 348, 495], [497, 497, 530, 530, 557], [559, 559, 587, 587, 620], [622, 622, 652, 652, 839], [841, 841, 871, 871, 900], [902, 902, 941, 941, 1503], [1505, 1505, 1561, 1561, 1994], [1996, 1996, 2026, 2026, 2340], [2342, 2342, 2437, 2437, 2730], [2732, 2732, 2817, 2817, 3154], [3156, 3156, 3233, 3233, 4162], [4164, 4164, 4218, 4218, 4322], [4324, 4324, 4377, 4415, 4597], [4599, 4599, 4654, 4701, 5468]], "test": "error"}
{"id": "XdKGWd", "name": "First SDF", "author": "Cubeleo", "description": "I'm finally trying to warp into the world of SDF.", "tags": ["sdf"], "likes": 6, "viewed": 184, "published": "Public", "date": "1470846257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DEPTH 10\n\n#define MAT_BACKGROUND    0\n#define MAT_GREY_DIFFUSE  1\n#define MAT_CHROME        3\n#define MAT_WAVY_MIRROR   4\n\nint intersectionMaterial;\nfloat intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\n\n\nfloat dSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat dBox(vec3 p, vec3 dimensions)\n{\n\tvec3 d = abs(p) - dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dRoundedBox(vec3 p, vec3 dimensions, float radius)\n{\n    return dBox(p, dimensions) - radius;\n}\n\n\nvec2 test(vec2 distMat, float newDist, int newMat)\n{\n    if (newDist < distMat.x)\n    {\n        distMat = vec2(newDist, float(newMat));\n    }\n    \n    return distMat;\n}\n\nvec3 quatMult(vec4 q, vec3 v)\n{\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{\n    angle *= .5;\n    float s = sin(angle), c = cos(angle);\n    \n    return vec4(normalize(axis) * s, c);\n}\n\nvec2 d(vec3 p)\n{\n    vec3 transformed;\n    vec2 result;\n    \n    result = vec2(dSphere(p - vec3(0, 10, 0), 1.), MAT_GREY_DIFFUSE);\n    result = test(result, dSphere(p - vec3(1. + .5 * sin(3.*iTime), 8. + .5 * sin(5.*iTime), -.75), .3), MAT_GREY_DIFFUSE);\n    result = test(result, dSphere(p - vec3(-1, 10.2, 2.), .7), MAT_CHROME);\n    transformed = quatMult(quatAxisAngle(vec3(0, 0, 1), 2. * iTime), p - vec3(3, 10.2, .4));\n    result = test(result, dBox(transformed, vec3(.7)), MAT_GREY_DIFFUSE);\n    transformed = quatMult(quatAxisAngle(vec3(.5), iTime), p - vec3(-3, 10.2, .4));\n    result = test(result, dRoundedBox(transformed, vec3(.7, .6, .4), 0.4), MAT_GREY_DIFFUSE);\n\tresult = test(result, dBox(p - vec3(0, 0, -3.2), vec3(15, 15, 2)), MAT_WAVY_MIRROR);\n\t\n\treturn result;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    d(pos+eps.xyy).x - d(pos-eps.xyy).x,\n\t    d(pos+eps.yxy).x - d(pos-eps.yxy).x,\n\t    d(pos+eps.yyx).x - d(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n#define MAX_STEPS 100\n#define MARCH_EPSILON .001\n#define MAX_T 100.\n\nvoid IntersectScene(vec3 origin, vec3 direction)\n{\n    intersectionT = 0.;\n    \n    int ii;\n    for (ii = 0; ii < MAX_STEPS && intersectionT < MAX_T; ++ii)\n    {\n        vec3 pos = origin + direction * intersectionT;\n        \n        vec2 distMat = d(pos);\n        \n        if (distMat.x < MARCH_EPSILON)\n        {\n            if (intersectionT < MAX_T)\n            {\n\t            intersectionMaterial = int(distMat.y);\n\t\t\t\tintersectionNormal = calcNormal(pos);\n            \tintersectionPoint = pos;\n            }\n            \n            break;\n        }\n        \n        intersectionT += distMat.x;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\t\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\t\n    vec2 mouseUV = iMouse.z <= 0. ? vec2(0) : ((iMouse.xy / iResolution.xy) - 0.5);\n\tvec3 origin = vec3(-4. * mouseUV.x, 0, -4. * mouseUV.y);\n\t\n\tvec3 direction = vec3(uv.x, 1.25, uv.y);\n\tdirection = normalize(direction);\n\t\n\tvec3 color = vec3(0);\n\t\n\tbool tracing = true;\n\tfor (int i = 0; i < MAX_DEPTH; ++i)\n\t{\n\t\tintersectionMaterial = MAT_BACKGROUND;\n\t\n\t\tIntersectScene(origin, direction);\n\t\t\n\t\tif (intersectionMaterial == MAT_BACKGROUND)\n\t\t{\n\t\t\tfloat backdrop = clamp(dot(direction, vec3(0, .7, .7)), 0., 1.);\n\t\t\tcolor = backdrop * vec3(.6, .6, .9);\n\t\t\t\n\t\t\ttracing = false;\n\t\t}\n\t\telse if (intersectionMaterial == MAT_GREY_DIFFUSE)\n\t\t{\n\t\t\tcolor += .02;\n\t\t\t\n\t\t\tfloat lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n\t\t\t\n\t\t\tif (lightDot > 0.)\n\t\t\t{\n\t\t\t\tcolor += .8 * lightDot;\n\t\t\t}\n\t\t\n\t\t\ttracing = false;\n\t\t}\n\t\telse if (intersectionMaterial == MAT_CHROME)\n\t\t{\n\t\t\torigin = intersectionPoint + intersectionNormal * .001;\n\t\t\tdirection = reflect(direction, intersectionNormal);\n\t\t}\n\t\telse if (intersectionMaterial == MAT_WAVY_MIRROR)\n\t\t{\n\t\t\torigin = intersectionPoint + intersectionNormal * .001;\n\t\t\tdirection = reflect(direction, normalize(intersectionNormal + .01 * sin(10.*intersectionPoint + 2.*iTime)));\n\t\t}\n\t\t\n\t\tif (!tracing) break;\n\t}\n\n\tfragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 233, 270, 270, 303], [305, 305, 342, 342, 436], [438, 438, 496, 496, 539], [542, 542, 594, 594, 710], [712, 712, 743, 743, 804], [806, 806, 850, 850, 957], [959, 959, 975, 975, 1740], [1742, 1742, 1774, 1774, 1982], [2053, 2053, 2103, 2103, 2661], [2663, 2663, 2720, 2720, 4151]], "test": "valid"}
{"id": "Xl33Ds", "name": "Space spheres", "author": "Shadron", "description": "This shader has been created with Shadron and used as a demo in its trailer.\nhttps://www.arteryengine.com/shadron/", "tags": ["3d", "raytracing", "raymarching", "raycasting", "sphere", "shadron"], "likes": 9, "viewed": 359, "published": "Public", "date": "1472501028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Author: Viktor Chlumsk\n// Created with SHADRON\n// www.shadron.info\n\n// LIBRARY FILES\n\n// #include <math_constants>\n#define PI 3.1415926535897932384626433832795\n\n// #include <affine_transform>\nvec3 rotateY(vec3 p, float a) {\n\treturn vec3(\n\t\tcos(a)*p.x+sin(a)*p.z,\n\t\tp.y,\n\t\t-sin(a)*p.x+cos(a)*p.z\n\t);\n}\n\n// #include <perlin>\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nfloat perlin_mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 perlin_mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 perlin_mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 perlin_mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat perlin_permute(float x) {\n     return perlin_mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 perlin_permute(vec3 x) {\n  return perlin_mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 perlin_permute(vec4 x) {\n     return perlin_mod289(((x*34.0)+1.0)*x);\n}\n\nfloat perlin_taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 perlin_taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 perlin_grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\nfloat perlinNoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = perlin_mod289(i); \n  vec4 p = perlin_permute( perlin_permute( perlin_permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = perlin_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat perlinNoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(0.309016994374947451)) ); // (sqrt(5) - 1)/4\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = perlin_mod289(i); \n  float j0 = perlin_permute( perlin_permute( perlin_permute( perlin_permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = perlin_permute( perlin_permute( perlin_permute( perlin_permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = perlin_grad4(j0,   ip);\n  vec4 p1 = perlin_grad4(j1.x, ip);\n  vec4 p2 = perlin_grad4(j1.y, ip);\n  vec4 p3 = perlin_grad4(j1.z, ip);\n  vec4 p4 = perlin_grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = perlin_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= perlin_taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n// #include <worley>\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n// Modulo 289 without a division (only multiplications)\nvec3 worley_mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 worley_mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Modulo 7 without a division\nvec3 worley_mod7(vec3 x) {\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 worley_permute(vec3 x) {\n  return worley_mod289((34.0 * x + 1.0) * x);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// 3x3x3 search region for good F2 everywhere, but a lot\n// slower than the 2x2x2 version.\n// The code below is a bit scary even to its author,\n// but it has at least half decent performance on a\n// modern GPU. In any case, it beats any software\n// implementation of Worley noise hands down.\nvec2 worleyNoise(vec3 P) {\n\tfloat K = 0.142857142857; // 1/7\n\tfloat Ko = 0.428571428571; // 1/2-K/2\n\tfloat K2 = 0.020408163265306; // 1/(7*7)\n\tfloat Kz = 0.166666666667; // 1/6\n\tfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\tfloat jitter = 1.0; // smaller jitter gives more regular pattern\n\n\tvec3 Pi = worley_mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = worley_permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = worley_permute(p + Pi.y - 1.0);\n\tvec3 p2 = worley_permute(p + Pi.y);\n\tvec3 p3 = worley_permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = worley_permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = worley_permute(p1 + Pi.z);\n\tvec3 p13 = worley_permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = worley_permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = worley_permute(p2 + Pi.z);\n\tvec3 p23 = worley_permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = worley_permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = worley_permute(p3 + Pi.z);\n\tvec3 p33 = worley_permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = worley_mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = worley_mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = worley_mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = worley_mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = worley_mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = worley_mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = worley_mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = worley_mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = worley_mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n}\n\n// Main script\n\nconst float startDistance = 3.325;\nconst float hRot = -3.0;\nconst float vRot = 0.0;\nconst float refractEta = 0.875;\nconst int RAYSTEPS = 128;\nconst int REFLECTIONS = 4;\nconst float EPSILON = 0.001;\n\n\n#define SHTIME iTime\n#define TIME (2.5*(2.0*SHTIME+0.9*sin(1.5+2.0*SHTIME)))\n\nstruct Sphere {\n\tvec3 center;\n\tfloat r;\n\tvec3 color1, color2;\n};\n\nfloat sphereSDF(vec3 p, Sphere s) {\n\treturn distance(p, s.center)-s.r;\n}\n\nvec3 sphereNormal(vec3 p, Sphere s) {\n\treturn normalize(p-s.center);\n}\n\nfloat planeSDF(vec3 p) {\n\treturn p.y;\n}\n\nvec3 planeNormal(vec3 p) {\n\treturn vec3(0.0, 1.0, 0.0);\n}\n\nfloat fbm(vec4 p) {\n\tfloat total = 0.0;\n\tfloat s = 1.0;\n\ttotal += 0.5*perlinNoise(s*p);\n\ttotal += 0.25*perlinNoise(2.0*s*p);\n\ttotal += 0.125*perlinNoise(4.0*s*p);\n\ttotal += 0.0625*perlinNoise(8.0*s*p);\n\treturn total;\n}\n\nfloat wnt(vec3 p) {\n    vec2 w = worleyNoise(p);\n    return w.y/w.x-1.5;\n}\n\nfloat fworley(vec3 p) {\n    float total = 0.0;\n    float s = 4.0;\n    total += 0.5*wnt(s*p);\n    total += 0.25*wnt(2.0*s*p);\n    total += 0.125*wnt(4.0*s*p);\n    total += 0.0625*wnt(8.0*s*p);\n    //total += worleyNoise(16.0*s*p).x;\n    return total;\n}\n\nfloat marble(vec3 p) {\n    //vec4 p4 = vec4(p, 0.015625*SHTIME);\n    vec4 p4 = vec4(p.xz, (-1.0+p.y)*vec2(sin(0.5*SHTIME), cos(0.5*SHTIME)));\n\tp4 += fbm(p4);\n\tp4 += fbm(p4);\n\treturn 0.5*(fbm(p4)+1.0);\n\t//return 0.5*(fbm(p)+1.0);\n}\n\nvec4 shader(vec2 pos) {\n    float rhrot = hRot+0.1*TIME;\n\tvec3 start = rotateY(vec3(0.0, 0.7, -startDistance), rhrot);\n\tvec3 direction = rotateY(normalize(vec3((2.0*pos-1.0)*vec2(1.0, iResolution.y/iResolution.x), 1.0)), rhrot);\n\tvec3 lightDirection = normalize(vec3(2.0, -1.0, 3.0));\n\tvec3 color = vec3(0.0);\n\n\tSphere sphere0, sphere1, sphere2, sphere3;\n\tsphere0.center = vec3(0.0, 1.0, 0.0); sphere0.r = 1.0; sphere0.color1 = vec3(1.0, 0.0, 0.125); sphere0.color2 = vec3(1.0, 1.0, 0.125);\n\tsphere1.center = vec3(-1.0, 0.75, -1.5); sphere1.r = 0.75; sphere1.color1 = vec3(0.125, 0.125, 0.125); sphere1.color2 = vec3(0.25, 0.125, 0.0);\n\tsphere2.center = vec3(+1.0, 0.5, -1.0); sphere2.r = 0.5; sphere2.color1 = vec3(0.0, 0.125, 0.25); sphere2.color2 = vec3(0.0625, 0.185, 0.25);\n    sphere3.center = vec3(0.0, -64.0, 0.0); sphere3.r = 64.0; sphere3.color1 = vec3(1.0); sphere3.color2 = vec3(1.0);\n\n\tint ignore = 0;\n\tvec3 p = start;\n\n    float atten = 1.0;\n\tfor (int h = 0; h < REFLECTIONS; ++h) {\n\t\tvec3 normal;\n\t\tvec3 difColor1 = vec3(1.0);\n        vec3 difColor2 = vec3(1.0);\n\t\tfloat ripple = 0.0;\n\t\tbool hit = false;\n\t\tbool seeThrough = false;\n        float natten = atten;\n        float emissive = 0.0;\n\t\tfor (int i = 0; i < RAYSTEPS; ++i) {\n            if (length(p) >= 256.0)\n                break;\n\n\t\t\tfloat distance = 99999999.9;\n\n\t\t\tif (ignore != 1) {\n\t\t\t\t//distance = planeSDF(p);\n                distance = sphereSDF(p, sphere3);\n\t\t\t\tif (distance < EPSILON) {\n\t\t\t\t\thit = true;\n\t\t\t\t\t//normal = planeNormal(p);\n                    normal = sphereNormal(p, sphere3);\n\t\t\t\t\tripple = 0.0625;\n\t\t\t\t\tignore = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ignore != 2) {\n\t\t\t\tdistance = min(distance, sphereSDF(p, sphere0));\n\t\t\t\tif (distance < EPSILON) {\n\t\t\t\t\thit = true;\n\t\t\t\t\tnormal = sphereNormal(p, sphere0);\n\t\t\t\t\tdifColor1 = sphere0.color1;\n                    difColor2 = sphere0.color2;\n                    natten *= 0.25;\n                    emissive = 1.0;\n\t\t\t\t\tignore = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ignore != 3) {\n\t\t\t\tdistance = min(distance, sphereSDF(p, sphere1));\n\t\t\t\tif (distance < EPSILON) {\n\t\t\t\t\thit = true;\n\t\t\t\t\tnormal = sphereNormal(p, sphere1);\n\t\t\t\t\tdifColor1 = sphere1.color1;\n                    difColor2 = sphere1.color2;\n\t\t\t\t\tignore = 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ignore != 4) {\n\t\t\t\tdistance = min(distance, sphereSDF(p, sphere2));\n\t\t\t\tif (distance < EPSILON) {\n\t\t\t\t\thit = true;\n\t\t\t\t\tseeThrough = true;\n\t\t\t\t\tnormal = sphereNormal(p, sphere2);\n\t\t\t\t\tdifColor1 = sphere2.color1;\n                    difColor2 = sphere2.color2;\n\t\t\t\t\tignore = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp += distance*direction;\n\n\t\t}\n\n\t\tif (hit) {\n\t\t\t// SHADOW\n\t\t\tvec3 sp = p;\n\t\t\tfloat shadow = 1.0;\n\t\t\tfloat highlight = 0.0;\n\t\t\tfor (int i = 0; i < RAYSTEPS; ++i) {\n\n\t\t\t\tfloat sdistance = 99999999.9;\n\n\t\t\t\tif (ignore != 1) sdistance = sphereSDF(sp, sphere3); //planeSDF(sp);\n\t\t\t\tif (ignore != 2) sdistance = min(sdistance, sphereSDF(sp, sphere0));\n\t\t\t\tif (ignore != 3) sdistance = min(sdistance, sphereSDF(sp, sphere1));\n\t\t\t\tfloat prevSdist = sdistance;\n\t\t\t\tif (ignore != 4) sdistance = min(sdistance, sphereSDF(sp, sphere2));\n\t\t\t\tif (sdistance < 0.03125) {\n\t\t\t\t\tfloat shadeDist = distance(p, sp);\n\t\t\t\t\tshadow = 1.0-1.0/(1.0+shadeDist);\n\t\t\t\t\tif (prevSdist != sdistance) {\n\t\t\t\t\t\t// refract light instead of block\n\t\t\t\t\t\tvec3 nd = refract(-lightDirection, sphereNormal(sp, sphere2), refractEta);\n\t\t\t\t\t\thighlight = pow(max(0.0, dot(nd, -lightDirection)), 4096.0)*(1.0-shadow);\n\t\t\t\t\t\tshadow = 1.0-0.5*(1.0-shadow);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsp -= sdistance*lightDirection;\n\n\t\t\t}\n\n            float marblePattern = marble(p);\n\t\t\tfloat diffuse = 0.03125+max(0.0, dot(lightDirection, -normal));\n\t\t\tif (seeThrough)\n\t\t\t\tdirection = normalize(refract(direction, normal, refractEta)+ripple*perlinNoise(8.0*p));\n\t\t\telse\n\t\t\t\tdirection = normalize(reflect(direction, normal)+ripple*perlinNoise(8.0*p));\n            vec3 emit = 4.0*emissive*difColor1*max(0.0, marblePattern-0.5);\n\t\t\t//float specular = pow(max(0.0, dot(lightDirection, -direction)), 16.0);\n\t\t\tcolor += (emit+highlight+shadow*(mix(difColor1, difColor2, marblePattern)*diffuse)/(1.0+0.5*distance(start, p)))*atten;\n\t\t\t//return vec4(0.5*(normal+1.0), 1.0);\n\t\t} else {\n\t\t\tcolor += 0.5*vec3(0.1, 0.0, 0.1)*atten*fworley(normalize(p-start)-0.125*lightDirection*cos(SHTIME));\n\t\t\tfloat sun = 0.0;\n\t\t\tsun += 0.9375*pow(max(0.0, dot(direction, -lightDirection)), 16.0+sin(16.0*SHTIME));\n\t\t\tcolor += sun*vec3(1.5, 0.8, 0.4)*atten;\n\t\t\tbreak;\n\t\t}\n\n        atten = natten;\n\t}\n\n\treturn vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = shader(fragCoord/iResolution.xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl33Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 198, 229, 229, 306], [308, 779, 809, 809, 858], [860, 860, 888, 888, 937], [939, 939, 967, 967, 1016], [1018, 1018, 1046, 1046, 1095], [1097, 1097, 1128, 1128, 1175], [1177, 1177, 1206, 1206, 1250], [1252, 1252, 1281, 1281, 1328], [1330, 1330, 1367, 1367, 1419], [1421, 1421, 1456, 1456, 1508], [1510, 1510, 1549, 1549, 1812], [1814, 1814, 1843, 1843, 4024], [4026, 4026, 4055, 4055, 6682], [6684, 7017, 7045, 7045, 7094], [7096, 7096, 7124, 7124, 7173], [7175, 7206, 7232, 7232, 7277], [7279, 7326, 7355, 7355, 7403], [7405, 7747, 7773, 7773, 12435], [12437, 12797, 12832, 12832, 12869], [12871, 12871, 12908, 12908, 12941], [12943, 12943, 12967, 12967, 12982], [12984, 12984, 13010, 13010, 13041], [13043, 13043, 13062, 13062, 13261], [13263, 13263, 13282, 13282, 13337], [13339, 13339, 13362, 13362, 13590], [13592, 13592, 13614, 13656, 13822], [13824, 13824, 13847, 13847, 18353], [18355, 18355, 18410, 18410, 18462]], "test": "valid"}
{"id": "Xl33W2", "name": "practice for rotating round rect", "author": "jcyuan", "description": "for practice.", "tags": ["basicpracticeroundrectanglerotate"], "likes": 4, "viewed": 421, "published": "Public", "date": "1471518822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FILL_COLOR vec3(.8, .8, .3)\n#define BG_COLOR vec3(.1, .5, .3)\n\n// from IQ: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat udRoundBox(in vec2 distFromCenter, in vec2 halfSize, in float cornerRadius)\n{\n    float t = length(max(abs(distFromCenter) - (halfSize - cornerRadius), 0.)) - cornerRadius;\n    return smoothstep(-1., 1., t);\n}\n\nmat2 rotZ(float angle)\n{\n\tfloat ca = cos(angle);\n    float sa = sin(angle);\n\treturn mat2(ca, sa, -sa, ca);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 xy = fragCoord - iResolution.xy * .5;\n    float p = udRoundBox(rotZ(iTime) * xy, vec2(40., 60.), 8.);\n    vec3 col = mix(FILL_COLOR, BG_COLOR, p);\n\tfragColor = vec4(pow(col, vec3(.454545)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl33W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 159, 242, 242, 374], [376, 376, 400, 400, 484], [486, 486, 541, 541, 747]], "test": "valid"}
{"id": "Xl3GDB", "name": "SDF mixed spheres", "author": "tiusic", "description": "Trying to understand how the mix function affects an SDF.\nCopied a bunch of code from https://www.shadertoy.com/view/XdKGWd", "tags": ["sdf"], "likes": 0, "viewed": 75, "published": "Public", "date": "1471154911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\n\nfloat dBlendedSpheres(vec3 p, vec3 c0, float r0, vec3 c1, float r1, float b) {\n    return mix(length(p - c0) - r0, length(p - c1) - r1, b);\n}\n\nvoid test(inout vec2 distMat, float newDist, int newMat) {\n    if (newDist < distMat.x) {\n        distMat = vec2(newDist, float(newMat));\n    }\n}\n\nfloat d(vec3 p) {\n    bool first = true;\n    float mindd;\n    float tt = 3.0 * sin(0.1 * iTime);\n    for (float i = 0.0; i <= 1.01; i += 0.05) {\n        float dd = dBlendedSpheres(p, vec3(20.0 * i, 10, tt), 1.0, vec3(20.0 * i, 10, -tt), 1.0, i);\n        if (first || dd < mindd) {\n            mindd = dd;\n        }\n        first = false;\n    }\n    return mindd;\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    d(pos+eps.xyy) - d(pos-eps.xyy),\n\t    d(pos+eps.yxy) - d(pos-eps.yxy),\n\t    d(pos+eps.yyx) - d(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n#define MAX_STEPS 100\n#define MARCH_EPSILON .001\n#define MAX_T 1000.\n\nvoid IntersectScene(vec3 origin, vec3 direction) {\n    float t = 0.;\n    for (int ii = 0; ii < MAX_STEPS; ++ii) {\n        vec3 pos = origin + direction * t;\n        float dd = d(pos);\n        if (dd < MARCH_EPSILON) {\n            if (t < MAX_T) {\n\t\t\t\tintersectionNormal = calcNormal(pos);\n            \tintersectionPoint = pos;\n                intersectionT = t;\n            }\n            break;\n        }\n        t += dd;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\tvec3 origin = vec3(10.0, -7.0, 0.0);\n\tvec3 direction = vec3(uv.x, 1, uv.y);\n\tdirection.xz *= .8;\n\tdirection = normalize(direction);\n\tvec3 color = vec3(0);\n    intersectionT = 1e37;\n    IntersectScene(origin, direction);\n    if (intersectionT < MAX_T) {\n        float lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n        if (lightDot > 0.0) {\n        \tcolor = mix(vec3(0, 0, 1), vec3(0, 1, 0), lightDot);\n        } else {\n        \tcolor = mix(vec3(0, 0, 1), vec3(1, 0, 0), -lightDot);\n        }\n    }\n\tfragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3GDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 149, 149, 212], [214, 214, 272, 272, 359], [361, 361, 378, 378, 724], [726, 726, 756, 756, 952], [1024, 1024, 1074, 1074, 1453], [1455, 1455, 1510, 1510, 2206]], "test": "valid"}
{"id": "Xl3Gzj", "name": "flow by Perlin noise", "author": "FabriceNeyret2", "description": "divergence-free flow from Perlin noise.\n( NB: time evolution is not physically correct: better change slowly )\nNote that you can combine flow fields; e.g. a coarse river flow + flownoise with translation.", "tags": ["noise", "perlin", "fluid", "flow", "curlnoise", "incompressible", "stream", "divergencefree"], "likes": 45, "viewed": 2915, "published": "Public API", "date": "1470147005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// see also https://www.shadertoy.com/view/ldtSzn\n\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n//     (extended to 3D)\nvec3 hash( vec3 p )\n{\n\tp *= mat3( 127.1,311.7,-53.7,\n\t\t\t   269.5,183.3, 77.1,\n\t\t\t  -301.7, 27.3,215.3 );\n\n\treturn 2.*fract(sin(p)*43758.5453123) -1.;\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n      // u = f*f*f* ( 10. + f * ( -15. + 6.* f ) ); // smoother. from http://staffwww.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/paper445.pdf\n \n    return 2.*mix(\n              mix( mix( dot( hash( i + vec3(0,0,0) ), f - vec3(0,0,0) ), \n                        dot( hash( i + vec3(1,0,0) ), f - vec3(1,0,0) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,0) ), f - vec3(0,1,0) ), \n                        dot( hash( i + vec3(1,1,0) ), f - vec3(1,1,0) ), u.x), u.y),\n              mix( mix( dot( hash( i + vec3(0,0,1) ), f - vec3(0,0,1) ), \n                        dot( hash( i + vec3(1,0,1) ), f - vec3(1,0,1) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,1) ), f - vec3(0,1,1) ), \n                        dot( hash( i + vec3(1,1,1) ), f - vec3(1,1,1) ), u.x), u.y), u.z);\n}\n\nfloat Mnoise(vec3 U ) {\n    return noise(U);                      // base turbulence\n  //return -1. + 2.* (1.-abs(noise(U)));  // flame like\n  //return -1. + 2.* (abs(noise(U)));     // cloud like\n}\n\nfloat turb( vec2 U, float t )\n{ \tfloat f = 0., q=1., s=0.;\n\t\n    float m = 2.; \n // mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for (int i=0; i<2; i++) {\n      U -= t*vec2(.6,.2);\n      f += q*Mnoise( vec3(U,t) ); \n      s += q; \n      q /= 2.; U *= m; t *= 1.71;  // because of diff, we may rather use q/=4.;\n    }\n    return f/s; \n}\n// -----------------------------------------------\n\n#define L(a,b) O+= .3/R.y/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a )\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R.y;\n\tfloat S = 3.,                              // scaling of noise\n        eps = 1e-3, t=.4*iTime;\n    //U -= t*vec2(.3,.1);                      // translation (or do it per band)\n    \n    float n = turb(S*U,t);                     // pure noise = stream\n \n                                               // flow = rot(stream) \n // vec2  V = vec2( turb(S*U+vec2(0,-eps),t) - turb(S*U+vec2(0,eps),t),\n //                 turb(S*U+vec2(eps,0),t)  - turb(S*U+vec2(-eps,0),t) ) / eps;\n    vec2 V = vec2( -dFdy(n), dFdx(n) )* R.y*.7;// using hardware derivatives\n    //V += vec2(3,0);                          // linearly combine other base flows\n    V /= R.y;\n    \n\tO = clamp(vec4(n,0,-n,0),0.,1.);           // draw stream value (note that curl = lapl(stream) so they are very similar)\n    \n    S = R.y/10.;\n    vec2 p = floor(U*S+.5)/S, v;           // draw velocity vectors\n    L ( p-V*2., p+V*2.);               \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3Gzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 161, 182, 182, 312], [314, 314, 337, 337, 1211], [1213, 1213, 1236, 1236, 1411], [1413, 1413, 1444, 1444, 1747], [1748, 1889, 1930, 1930, 2885]], "test": "valid"}
{"id": "Xlc3D2", "name": "Circle & Polygon Lens Flare ", "author": "Yusef28", "description": "Inspired by Mu6ks and Nimitz's awesome lens flares and pics online I tried and came out with this. Feedback welcome.\nInteresting is the function for making polygons which can make any regular polygon. I left a link in a comment above that function.", "tags": ["sun", "lens", "lighting", "light", "flare", "lensflare"], "likes": 96, "viewed": 4198, "published": "Public", "date": "1471571936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rnd(vec2 p)\n{\n    float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));\n return f;   \n}\n\nfloat rnd(float w)\n{\n    float f = fract(sin(w)*1000.);\n return f;   \n}\n\nfloat regShape(vec2 p, int N)\n{\n float f;\n    \n    \nfloat a=atan(p.x,p.y)+.2;\nfloat b=6.28319/float(N);\nf=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));\n    \n    \n    return f;\n}\nvec3 circle(vec2 p, float size, float decay, vec3 color,vec3 color2, float dist, vec2 mouse)\n{\n \t \n    \n    //l is used for making rings.I get the length and pass it through a sinwave\n    //but I also use a pow function. pow function + sin function , from 0 and up, = a pulse, at least\n    //if you return the max of that and 0.0.\n    \n    float l = length(p + mouse*(dist*4.))+size/2.;\n    \n    //l2 is used in the rings as well...somehow...\n    float l2 = length(p + mouse*(dist*4.))+size/3.;\n    \n    ///these are circles, big, rings, and  tiny respectively\n    float c = max(00.01-pow(length(p + mouse*dist), size*1.4), 0.0)*50.;\n    float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*30.), 0.0)*3.;\n    float c2 =  max(0.04/pow(length(p-mouse*dist/2. + 0.09)*1., 1.), 0.0)/20.;\n    float s = max(00.01-pow(regShape(p*5. + mouse*dist*5. + 0.9, 6) , 1.), 0.0)*5.;\n    \n   \tcolor = 0.5+0.5*sin(color);\n    color = cos(vec3(0.44, .24, .2)*8. + dist*4.)*0.5+.5;\n \tvec3 f = c*color ;\n    f += c1*color;\n    \n    f += c2*color;  \n    f +=  s*color;\n    return f-0.01;\n}\n\nfloat sun(vec2 p, vec2 mouse)\n{\n float f;\n    \n    vec2 sunp = p+mouse;\n    float sun = 1.0-length(sunp)*8.;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    //uv=uv*2.-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 mm = iMouse.xy/iResolution.xy - 0.5;\n    mm.x *= iResolution.x/iResolution.y;\n    \n    if(iMouse.z<1.0)\n    {\n     mm = vec2(sin(iTime/6.)/1., cos(iTime/8.)/2. )/2.;   \n        \n    }\n    vec3 circColor = vec3(0.9, 0.2, 0.1);\n    vec3 circColor2 = vec3(0.3, 0.1, 0.9);\n    \n    //now to make the sky not black\n    vec3 color = mix(vec3(0.3, 0.2, 0.02)/0.9, vec3(0.2, 0.5, 0.8), uv.y)*3.-0.52*sin(iTime);\n    \n    //this calls the function which adds three circle types every time through the loop based on parameters I\n    //got by trying things out. rnd i*2000. and rnd i*20 are just to help randomize things more\n    for(float i=0.;i<10.;i++){\n        color += circle(uv, pow(rnd(i*2000.)*1.8, 2.)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, mm);\n    }\n    //get angle and length of the sun (uv - mouse)\n        float a = atan(uv.y-mm.y, uv.x-mm.x);\n    \tfloat l = max(1.0-length(uv-mm)-0.84, 0.0);\n    \n    float bright = 0.1;//+0.1/abs(sin(iTime/3.))/3.;//add brightness based on how the sun moves so that it is brightest\n    //when it is lined up with the center\n    \n    //add the sun with the frill things\n    color += max(0.1/pow(length(uv-mm)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n    color += max(0.1/pow(length(uv-mm)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    color += (max(bright/pow(length(uv-mm)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;\n       // * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));\n    \t\n    //multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that\n    //there is a sharper roll of of the light decay from the sun. \n        color*= exp(1.0-length(uv-mm))/5.;\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "Xsj3z1", "previewfilepath": "https://soundcloud.com/zongo-1/09-hitori-bocchi-1b?in=zongo-1/sets/serial-experiments-lain-bootleg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/zongo-1/09-hitori-bocchi-1b?in=zongo-1/sets/serial-experiments-lain-bootleg", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlc3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 103], [105, 105, 125, 125, 176], [178, 178, 209, 209, 366], [367, 367, 461, 697, 1429], [1431, 1431, 1462, 1462, 1555], [1557, 1557, 1614, 1614, 3577]], "test": "valid"}
{"id": "Xlc3Rf", "name": "Worley Hyperdisc - Ocean Planet", "author": "CaliCoastReplay", "description": "3rd mix of the Worley noise shader at https://www.shadertoy.com/view/Xl33Wn , the hyperbolic disc from : https://www.shadertoy.com/view/XllSWf , and starfield from https://www.shadertoy.com/view/4scXWB .  Try it at high-res!", "tags": ["ocean", "planet", "worley", "stars", "disc", "mattdamon", "hyperbolic", "yeis"], "likes": 65, "viewed": 11497, "published": "Public", "date": "1470438705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Adapted from:  https://www.shadertoy.com/view/Xl33Wn\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat length2(vec2 p){\n    return dot(p,p);\n}\nfloat noise(vec2 p )\n{\n    return fract(sin(fract(sin(p.x)*(41.13311))+ p.y)*31.0011);\n}\n\nfloat worley(vec2 p) {\n float d = 1e30;\n for (int xo = -1; xo <= 1; ++xo) {\n  for (int yo = -1; yo <= 1; ++yo) {\n   vec2 tp = floor(p) + vec2(xo, yo);\n   d = min(d, length2(p - tp - noise(tp)));\n  }\n }\n  return 3.0*exp(-4.4*abs((2.5*d)-1.0));\n}\n\nfloat fworley(vec2 p)\n{\n    return sqrt(sqrt(sqrt(worley(p * 11.0 + 0.15 * iTime) * \n                          sqrt(worley(p*50.0+ 0.18+ -0.12*iTime)) *\n                         sqrt(sqrt(worley(p*-10.0+0.3*iTime))))));\n}\n\n\n//hyperbolic disc/radial distortion adapted from https://www.shadertoy.com/view/XllSWf\nvec2 HyperbolicDisc(vec2 fragCoord) {    \n    fragCoord -= iResolution.xy * 0.29;\n    fragCoord /= iResolution.x;\n    float r = length(fragCoord);\n    vec2 d = fragCoord / r *1.5 ;\n    fragCoord = d / atanh(r * (2.5 )) / 2.0;\n    fragCoord *= iResolution.x;\n    fragCoord += iResolution.xy *0.212;\n    fragCoord += 1.59+ sin(iTime/10.0);\n    return fragCoord;\n}\n\nfloat flare( vec2 U )                            // rotating hexagon \n{\tvec2 A = sin(vec2(0, 1.57) + iDate.w);\n    U = abs( U * mat2(A, -A.y, A.x) ) * mat2(2,0,1,1.7); \n    return .2/max(U.x,U.y);                      // glowing-spiky approx of step(max,.2)\n  //return .2*pow(max(U.x,U.y), -2.);\n \n}\n\n#define r(x)     fract(1e4*sin((x)*541.17))      // rand, signed rand   in 1, 2, 3D.\n#define sr2(x)   ( r(vec2(x,x+.1)) *2.-1. )\n#define sr3(x)   ( r(vec4(x,x+.1,x+.2,0)) *2.-1. )\n\nvec4 stars( vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U =  (U+U - R) / R.y;\n\tO -= O+.3;\n    for (float i=0.; i<99.; i++)\n        O += flare (U - sr2(i)*R/R.y )           // rotating flare at random location\n              * r(i+.2)                          // random scale\n              * (1.+sin(iDate.w+r(i+.3)*6.))*.1  // time pulse\n            //* (1.+.1*sr3(i+.4));               // random color - uncorrelated\n              * (1.+.1*sr3(i));                  // random color - correlated\n    return O;\n}\n\nvec4 fake_planet( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 fragCoord2;\n    fragCoord2.x += sin(iTime/3.5)*12.0;\n    fragCoord2.y += cos(iTime/3.5)*12.0;\n    fragCoord2 = HyperbolicDisc(fragCoord);\n    vec2 uv = fragCoord2.xy / iResolution.xy;\n    float wolo = fworley(uv*iResolution.xy / 1919.0) + fworley((uv*iResolution.xy + sin(iTime*2.0)) / 3200.0)\n         + fworley((uv*iResolution.xy - sin(iTime*2.0)) / 4800.0);\n \twolo *= .85*exp(-length2(abs(0.5*uv-0.9)));\n    fragColor = vec4(wolo * vec3(0.1*wolo*wolo, 0.3*wolo, 1.2*pow(wolo, 0.90-wolo)), 1.0);\n    vec3 hsv = rgb2hsv(fragColor.xyz);\n    hsv.z *= sqrt(hsv.z) * 1.1+ cos(iTime/13.0)*0.4;\n    hsv.x += hsv.z/200.0 * sin(iTime/2.0)*2.0;\n    hsv.y -= hsv.z/102.0;\n    fragColor.xyz = hsv2rgb(hsv);\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 starColor = stars(fragColor, fragCoord);\n    vec4 planetColor = fake_planet(fragCoord);\n    float distanceToCenter = 0.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float xDist = uv.x - 0.35;\n    float yDist = uv.y - 0.35;\n    distanceToCenter += sqrt(xDist*xDist/.29 + yDist*yDist);\n    if (distanceToCenter > 0.60)\n    \tfragColor =starColor/2.0;\n    else        \n    {\n        float falloff =  1.0-distanceToCenter;\n    \tfragColor = planetColor * falloff *falloff * falloff * 1.90;\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlc3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 77, 77, 408], [410, 410, 432, 432, 601], [603, 603, 625, 625, 648], [649, 649, 671, 671, 737], [739, 739, 761, 761, 983], [985, 985, 1008, 1008, 1206], [1209, 1296, 1333, 1333, 1657], [1659, 1659, 1730, 1730, 1958], [2141, 2141, 2171, 2171, 2659], [2661, 2661, 2697, 2697, 3447], [3450, 3450, 3507, 3507, 4015]], "test": "valid"}
{"id": "Xlc3Rs", "name": "Mandelbrotation", "author": "stduhpf", "description": "Basically the mandelbrot set, but with a different rotation of z at each iteration.", "tags": ["fractal"], "likes": 1, "viewed": 140, "published": "Public", "date": "1470778595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define JULIA_MODE\n#define r(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nconst float it=256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*fragCoord.xy /iResolution.y-vec2(iResolution.x/iResolution.y,1.);\n    float a=0.;\n    vec2 z = vec2(0.);\n    #ifdef JULIA_MODE\n    z=uv;\n    uv=2.*iMouse.xy /iResolution.y-vec2(iResolution.x/iResolution.y,1.);\n    if(iMouse.xy==vec2(0.))\n        uv=vec2(.5)*r(iTime);\n    #endif\n    for(float i = 0.;i<it;i++)\n    {\n        a=i;\n        z=z*mat2(z*vec2(1,-1),z.yx)+uv;\n        z*=r(iTime/(i+1.));\n        if(length(z)>2.)\n            break;\n    }\n// a=length(z);\n\tfragColor = vec4(z,pow(a/it,.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlc3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 147, 147, 665]], "test": "valid"}
{"id": "Xlc3W2", "name": "Japanese Lamp", "author": "phi16", "description": "lamp", "tags": ["raymarch"], "likes": 7, "viewed": 162, "published": "Public", "date": "1471532133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define put(e) res = with(e,res)\n\nstruct C{\n    float d;\n    int t;\n};\n    \nvec3 light = normalize(vec3(-2,0,0));\n    \nfloat box(vec3 s,vec3 p){\n    return length(max(abs(p)-s,0.))-0.01;\n}\n\nfloat sbox(vec3 s,vec3 p){\n    vec3 d = abs(p) - s;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat fbox(vec3 s,vec3 p){\n    float frame,res;\n    frame = box(vec3(s.x,s.y,0.001),p-vec3(0,0,s.z));\n    res = frame;\n    frame = box(vec3(s.x,s.y,0.001),p-vec3(0,0,-s.z));\n    res = min(frame,res);\n    frame = box(vec3(0.001,s.y,s.z),p-vec3(s.x,0,0));\n    res = min(frame,res);\n    frame = box(vec3(0.001,s.y,s.z),p-vec3(-s.x,0,0));\n    res = min(frame,res);\n    return res;\n}\n\nC with(C a, C b){\n\tif(a.d < b.d) return a;\n    else return b;\n}    \n\nC dist(vec3 p){\n    C res;\n    C frame;\n    frame = C(fbox(vec3(1,1.6,1)/4.,p-vec3(0,0.2,0)),0);\n    res = frame;\n    C base;\n    base = C(max(sbox(vec3(1,0.1,1)/4.,p-vec3(0,-0.26,0)),-sbox(vec3(0.8,1.,0.8)/4.,p-vec3(0,-0.26,0))),2);\n    put(base);\n    base = C(box(vec3(1,0.1,1)/4.,p-vec3(0,-0.66,0)),1);\n    put(base);\n    C stick;\n    stick = C(box(vec3(0.09,1,0.09)/4.,p-vec3(-0.225,-0.4,0.225)),1);\n    put(stick);\n    stick = C(box(vec3(0.09,1,0.09)/4.,p-vec3(0.225,-0.4,0.225)),1);\n    put(stick);\n    stick = C(box(vec3(0.09,1,0.09)/4.,p-vec3(-0.225,-0.4,-0.225)),1);\n    put(stick);\n    stick = C(box(vec3(0.09,1,0.09)/4.,p-vec3(0.225,-0.4,-0.225)),1);\n    put(stick);\n    C con = C(box(vec3(0.85,0.2,0.85)/4.,p-vec3(0,-0.61,0)),1);\n    put(con);\n    \n    C table = C(box(vec3(3.,1.,3.)/4.,p-vec3(-0.3,-0.96,0.3)),3);\n    put(table);\n    put(C(-p.x + 0.45,4));\n    put(C(p.z + 0.45,4));\n    return res;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.001,0);\n    return normalize(vec3(\n        dist(p+e.xyy).d - dist(p-e.xyy).d,\n        dist(p+e.yxy).d - dist(p-e.yxy).d,\n        dist(p+e.yyx).d - dist(p-e.yyx).d));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noiseBase( in vec3 x , float e )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z + e;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat noise(vec3 p, float e){\n    float f = 0.0;\n    vec3 q = 8.0*p;\n    f  = 0.5000*noiseBase( q,e ); q = m*q*2.01;\n    f += 0.2500*noiseBase( q,e ); q = m*q*2.02;\n    f += 0.1250*noiseBase( q,e ); q = m*q*2.03;\n    f += 0.0625*noiseBase( q,e ); q = m*q*2.01;\n    return f;\n}\nfloat pattern(vec3 p){\n    return noise(p,0.);\n}\nvec2 Dpat(vec3 p, vec3 n1, vec3 n2){\n    n1 *= 0.001;\n    n2 *= 0.001;\n    return normalize(vec2(\n        pattern(p+n1) - pattern(p-n1),\n        pattern(p+n2) - pattern(p-n2)));\n}\n\nvec3 render(vec3 p,vec3 v,vec3 n,int t){\n    if(t==0){\n        p.y -= 0.2;\n        float dep = pattern(p);\n        vec2 n2 = Dpat(p,vec3(0,1,0),cross(vec3(0,1,0),n));\n        vec3 nr = normalize(vec3(n2.y*(1.-abs(n.x)),n2.x,n2.y*(1.-abs(n.z)))+n*15.);\n        vec3 e = mix(vec3(1),vec3(0.4),abs(nr.y));\n        if(dot(p,nr) > 0.)e *= 0.5 / pow(length(p),0.8);\n        else e *= 1.3 / pow(length(p),0.9);\n        e -= dep * vec3(0,0.7,1.0) * 0.3;\n        e *= vec3(0.9,0.8,0.5);\n        float ef = 1./1.5;\n        e = vec3(pow(e.x,ef),pow(e.y,ef),pow(e.z,ef));\n        return e;\n    }else if(t==3){\n        vec3 col = texture(iChannel1,vec2(p.x,p.z)/2.).xyz;\n        p.y -= 0.2;\n        col *= 0.2 / pow(length(p),2.);\n        return col;\n    }else if(t==4){\n        vec3 col = texture(iChannel1,vec2(p.x+p.z,p.y)/2.).xyz;\n        p.y -= 0.2;\n        col *= 0.3 / pow(length(p),2.);\n        return col;\n    }else{\n        vec3 c = vec3(0);\n        c += max(dot(-v,n),0.0)/20.0;\n        c += pow(max(dot(reflect(v,n),light),0.0),10.0)/5.0;\n        if(t==2){\n            c += 0.2 / pow(length(p),1.5) * n.y * vec3(0.9,0.9,0.5);\n        }\n        return c;\n    }\n}\n\nfloat ao(vec3 p,vec3 n){\n    float e = 0.0;\n    for(int i=1;i<5;i++){\n        e += dist(p+n*float(i)/10.0).d / (float(i)/10.0) * pow(2.,-float(i));\n    }\n    return pow(e+0.5,0.7);\n}\n\nvec3 color(vec3 p, vec3 v){\n    float d = 0.001;\n    int maxIter = 100;\n    C c=C(0.,-1);\n    for(int i=0;i<100;i++){\n        C ci=dist(p+d*v);\n        float rd = ci.d;\n        if(abs(rd) < 0.001){\n            maxIter=i;\n            c=ci;\n            break;\n        }\n        d += rd;\n    }\n    if(c.t==-1)return v*0.5+0.5;\n    vec3 pos = p+d*v;\n    vec3 n = normal(pos);\n    return render(pos,v,n,c.t)*ao(pos,n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy, \n\tuv = (2.*fragCoord.xy - R)/R.y;\n    vec3 p=vec3(0,0,0);\n    vec3 vi = vec3(1,0,0);\n    vec3 v=vec3(4.0,uv.y,uv.x);\n    v=normalize(v);\n    vi=normalize(vi);\n    float rot;\n    rot = 0.4;\n    v.xy *= mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n    vi.xy *= mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n    rot = sin(iTime)/2.+3.1415/4.;\n    v.xz *= mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n    vi.xz *= mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n    p -= vi*3.;\n\tfragColor = vec4(color(p,v),1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlc3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 144, 144, 188], [190, 190, 216, 216, 307], [309, 309, 335, 335, 687], [689, 689, 706, 706, 752], [758, 758, 773, 773, 1671], [1673, 1673, 1693, 1693, 1881], [1883, 1883, 1903, 1903, 1975], [1976, 1976, 1999, 1999, 2035], [2036, 2036, 2076, 2076, 2449], [2575, 2575, 2604, 2604, 2851], [2852, 2852, 2874, 2874, 2900], [2901, 2901, 2937, 2937, 3080], [3082, 3082, 3122, 3122, 4242], [4244, 4244, 4268, 4268, 4426], [4428, 4428, 4455, 4455, 4843], [4845, 4845, 4902, 4902, 5431]], "test": "error"}
{"id": "XlcGD2", "name": "PI using LDP sketch", "author": "Imsure1200q_1UWE130", "description": "PI sketches using LDP (Lengthened Dot Product) <-- Is this to you?\nIt also uses steps.", "tags": ["sketch", "repeated", "ldp"], "likes": 1, "viewed": 425, "published": "Public API", "date": "1471528644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rep( float r )\n{\n    return sin(r) * cos(r) / tan(r) * sqrt(r); //<-- guess this's a polynomial.\n}\n//experiment rep if u want.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float col = fract(sin(dot(rep(length(uv)), tan(length(iTime))) + smoothstep(uv.y, fract(mod(uv.x, uv.x/2.0)), distance(length(uv), uv.y)))/length(uv));\n\tfragColor = vec4(col) / tan(fract(sin(col)));\n    fragColor -= vec4(1.0, uv, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 104], [105, 133, 190, 190, 474]], "test": "error"}
{"id": "XlcGWf", "name": "Circles and Lines", "author": "spacetug", "description": "Drawing lines and circles", "tags": ["2d"], "likes": 4, "viewed": 328, "published": "Public API", "date": "1471932113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circleD(vec2 center, float radius)\n{\n    return length(center) - radius;\n}\n\nfloat lineD(vec2 o, float slope) {\n    return 0.0;\n}\n\nvec4 circle(vec2 center, float radius, float lw, vec3 color) {\n    float d = circleD(center, radius);\n    float a = smoothstep(lw, 0.0, d);\n    return vec4(color.rgb, a);    \n}\n\nvec4 circumference(vec2 center, float radius, float lw, vec3 color) {\n    float d = circleD(center, radius);\n    float a = smoothstep(1.0, 0.0, abs(d)/lw);\n    return vec4(color.rgb,a);    \n}\n\nvec4 waveThing(vec2 uv, float lw, vec3 color) {\n\tfloat a = smoothstep(1.0,0.0,abs(cos((uv.x)*4.0)/4.0 - uv.y)/lw);\n\treturn vec4(color.rgb, a);\n}\n\nvec4 lineThing(float t, float c, vec2 uv, float lw, vec3 color) {\n    float a = smoothstep(1.0,0.0,abs(uv.x*t + c - uv.y) / lw);\n\treturn vec4(color.rgb, a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float radius = 0.5;\n    \n    float linew = 0.008;//iResolution.y * 0.00003;\n    float x = iTime;\n\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= aspect;\n    \n    vec2 center = uv;\n    \n    vec4 acc = vec4(0,0,0,0);\n    vec4 c = circumference(center, radius, linew, vec3(0,1,0));\n    acc = mix(acc, c, c.a);\n    \n    float t = 1.0/sin(x) * 4.0;\n\n    c = lineThing(0.0, 0.7, uv, 0.03 + 0.01 * cos(x * 4.0), vec3(1,0,1));\n    acc = mix(acc, c, c.a);\n    \n   \tc = circle(uv - vec2(1.,.7), 0.1 + 0.09 * abs(sin(x)), .01, vec3(.1,1,1));\n    acc = mix(acc, c, c.a);\n\n   \tc = circle(uv - vec2(-1.,.7), 0.1 + 0.09 * abs(sin(x+1.)), .01, vec3(.1,1,1));\n    acc = mix(acc, c, c.a);\n\n    c = lineThing(t, 0.0, uv, 0.05, vec3(1,1,1));\n    acc = mix(acc, c, c.a);\n    \n    c = lineThing(-t, 0.0,uv, 0.05, vec3(1,1,1));\n    acc = mix(acc, c, c.a);\n\n    c = circle(center, 0.11 + 0.01 * cos(x*4.0), linew, vec3(1,1,0));\n    acc = mix(acc, c, c.a);\n    \n    center = vec2(radius * sin(x), radius * cos(x)) + center;\n    c = circumference(center, 0.05, linew, vec3(1,0,0));\n    acc = mix(acc, c, c.a);\n    \n    center = vec2(0.05 * sin(x * 4.0), 0.05 * cos(x * 4.0)) + center;\n    c = circumference(center, 0.02, linew, vec3(0,0,1));\n    acc = mix(acc, c, c.a);\n\n    c = waveThing(uv - vec2(x, -0.25), linew, vec3(0.5,1.0,.5));\n    acc = mix(acc, c, c.a * 0.5);\n\n    c = lineThing(0.0, 0.02 * sin(x*10.), uv + vec2(0,0.15), linew, vec3(1.,0.2,0.5));\n    acc = mix(acc, c, c.a);\n\n    c = lineThing(0.0, 0.0, uv + vec2(0,0.25), 0.03 + 0.005 * cos(x), vec3(1.,0.2,0.5));\n    acc = mix(acc, c, c.a);\n    \n    c = lineThing(0.0, -0.02 * sin(x*10.), uv + vec2(0,0.35), linew, vec3(1.,0.2,0.5));\n    acc = mix(acc, c, c.a);\n\n    c = waveThing(uv - vec2(-x, -0.25), linew, vec3(0.5,1.0,.5));\n    acc = mix(acc, c, c.a * 0.5);\n\n    c = waveThing(uv + vec2(0, 0.25), linew, vec3(1,0.5,.5));\n    acc = mix(acc, c, c.a);\n    \n    float xx = sin (x*0.2) * aspect;\n    center = vec2(xx, cos((xx)*4.0)/4.0) - (uv + vec2(0, 0.25));\n    c = circumference(center, 0.02, linew, vec3(1,0,1));\n    acc = mix(acc, c, c.a);\n\n    center = vec2(0.05 * sin(x * -4.0), 0.05 * cos(x * -4.0)) + center;\n    c = circumference(center, 0.04, linew, vec3(0,1,1));\n    acc = mix(acc, c, c.a);\n    \n    xx = sin (x*5.) * aspect;\n    c = circle(uv + vec2(xx, .25), 0.1 + 0.025 * sin(x) * aspect, linew, vec3(0.2,0.5,1));\n    acc = mix(acc, c, c.a);\n    \n    fragColor = acc;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 80], [82, 82, 116, 116, 134], [136, 136, 198, 198, 312], [314, 314, 383, 383, 505], [507, 507, 554, 554, 651], [653, 653, 718, 718, 811], [814, 814, 871, 871, 3383]], "test": "valid"}
{"id": "XldGD2", "name": "Smooth Spiral", "author": "revers", "description": "Simple 2D spiral. The spiral formula is taken from [url=https://www.shadertoy.com/view/MddSRB]\"spiraling video\" by FabriceNeyret2.[/url]", "tags": ["2d", "spiral"], "likes": 8, "viewed": 170, "published": "Public", "date": "1471723661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * The spiral formula is taken from \"spiraling video\" by FabriceNeyret2 ( https://www.shadertoy.com/view/MddSRB )\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\n// You can play with this value to get different shapes of spiral:\nconst int Spiral = 1;\n\nconst float Multiplier = 0.607;\nconst float Power = 1.0;\n\n#define PI 3.141592\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec2 p = uv;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tfloat a = (atan(p.y, p.x) * 6.0 / PI) * 0.5 + 0.5;\n\tfloat r = length(p);\n\n\tvec2 q = vec2(a, log(r) * Multiplier);\n\n\tq.y += q.x * float(Spiral) / 6.0;\n\n\tfloat g = fract(q.y);\n\tfloat m = sqrt(g);\n\tfloat n = sqrt(1.0 - g);\n\tfloat f = mix(m, n, m);\n\n\ta = fract(a * 0.5 - iTime * 0.5);\n\ta = smoothstep(0.0, 0.8, a) - smoothstep(0.8, 1.0, a);\n\n    vec3 col = vec3(mix(a, 0.0, max(0.0, f * 2.0 - 0.2)) * Power, f, 1.0);\n    col = col * col;\n    col = pow(col, vec3(0.4545));\n    \n    // vignette by iq\n\tcol *= 0.5 + 0.5 * pow((uv.x + 1.0) * (uv.y + 1.0) * (uv.x - 1.0) * (uv.y - 1.0), 0.2);\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldGD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[369, 538, 595, 595, 1330]], "test": "valid"}
{"id": "XldGDj", "name": "Escher's Square Limit - Birds", "author": "roywig", "description": "Escher's square limit (with a simpler bird motif). Undefine ANIMATE for a still image.", "tags": ["math", "escher", "square", "tile", "limit"], "likes": 13, "viewed": 220, "published": "Public", "date": "1471737177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LIGHT vec3(0.441,0.376,0.995)\n#define MID vec3(0.995,0.468,0.477)\n#define DARK  vec3(0.563,0.995,0.545)\n\n#define ANIMATE\n\nfloat bird(vec2 z){\n    float e = .0001;\n    float color = smoothstep(-1.-e,-1.,-abs(z.y*-2.-3.));\n    color *= smoothstep(-e,0.,-max(z.y-z.x,z.x+z.y))-smoothstep(1.,1.+e,-max(z.y-z.x,z.x+z.y+1.));\n    color = mix(color,1.,smoothstep(-1.-e,-1.,-abs(2.*z.x-1.))*step(0.,-z.y)*(1.-smoothstep(1.,1.+e,-min(z.y-z.x+2.,z.x+z.y+1.))));\n    color *= smoothstep(.1,.15,length(z+vec2(1.,1.5)));\n    return color;\n}\n\nvec3 cycle ( vec3 A, vec3 B, vec3 C ){\n    vec3 value = vec3(0);\n    float time = mod(iTime,4.);\n    value = mix(A,B,clamp(time,0.,1.));\n    value = mix(value,C,clamp(time,1.,2.)-1.);\n    value = mix(value,B,clamp(time,2.,3.)-2.);\n\tvalue = mix(value,A,clamp(time,3.,4.)-3.);\n    return value;\n}\n\nvoid cycleColors ( out vec3 A,  out vec3 B,  out vec3 C){\n    #ifdef ANIMATE\n    A = cycle(LIGHT,MID,DARK);\n    B = cycle(MID,DARK,LIGHT);\n    C = cycle(DARK,LIGHT,MID);\n    #else\n    A = LIGHT; B = MID; C = DARK;\n    #endif\n}\n\nvoid corner_colors(int n,out vec3 c1,out vec3 c2,int t){\n    vec3 light, mid, dark;\n    cycleColors(light,mid,dark);\n    if (t == 0){\n    c1=n == 4? light: n == 3? mid: n == 2? dark: mid;\n    c2=n == 4? dark: n == 3? light: n == 2? mid: dark;\n    } else if ( t == 1 ) {\n    c1= n == 4? dark: n == 3? mid: n == 2? dark: light;\n    c2= n == 4? light: n == 3? dark: n == 2? mid: mid;\n    } else {\n    c1= n == 4? dark: n == 3? mid: n == 2? dark: mid;\n    c2= n == 4? mid: n == 3? dark: n == 2? mid: dark;\n    }\n}\n\nvec3 corner_tile(vec2 z,int t){\n    z = z.yx;\n    z = z*4.-2.;\n\n    vec3 color = vec3(0);\n    vec3 c1=vec3(0.),c2=vec3(0.);\n    for (int n=1;n<=4;n++){\n        corner_colors(n,c1,c2,t);\n        // Stamp two birds\n        color = mix(color,c1 ,bird(z));\n        color = mix(color, c2,\n                bird((z+vec2(0,2))*mat2(-1,1,1,1)));\n        // Rotate the coordinate system\n        z *= mat2(0,1,-1,0);\n    }\n    return vec3(color);\n}\n\nvec3 side_colors(int n,int cycleDir){\n    vec3 light, mid, dark;\n    cycleColors(light,mid,dark);\n    n = n > 2? n-3: n;\n    if (cycleDir == 0)\n        return n == 2? light: n == 1? dark: mid;\n    return n == 2? mid: n == 1? dark: light;\n}\n\nvec3 side_tile(vec2 z, int t,int s){\n    vec3 color;\n    z = z.yx;\n    color = bird(z)*side_colors(t,s);\n    color = mix(color,side_colors(1+t,s),bird(z*mat2(0,-1,1,0)));\n\tcolor = mix(color,side_colors(2+t,s),bird((z+vec2(-2.,-2.))*mat2(-.5,.5,.5,.5)));\n    return color;\n}\n\nvec3 side_tiles(vec2 z,int firstColor,int colorDirection){\n    z = z*mat2(-1,0,0,-1)*4.*vec2(2.,1) + vec2(6.,2);\n    vec3 color = side_tile(z,0+firstColor,colorDirection);\n    vec3 tile2 = side_tile(z*mat2(0,1,-1,0)+vec2(0,4)\n,1+firstColor,colorDirection);\n    color = max(vec3(0.),color - tile2)+tile2;\n\n    // fill in\n    color = mix(color, side_colors(2+firstColor,colorDirection), bird(z*mat2(0,-1,-1,0)-vec2(0,4)));\n    color = mix(color, side_colors(0+firstColor,colorDirection), bird(z*mat2(0,1,1,0)-vec2(0,8)));\n    color = mix(color,side_colors(1+firstColor,colorDirection),bird((z+vec2(-2.,-2.))*mat2(-.5,0,0,.5)+vec2(0.,-2.)));\nz.x = mod(z.x-2.5,4.)+2.5;\n    color = mix(color,side_colors(0+firstColor,colorDirection),bird((z+vec2(-2.,-2.))*mat2(1,1,-1,1)+vec2(2.,6.)));\n    return color;\n}\n\nvec2 scale_f(vec2 x){\n    return exp2(-floor(log2(x)));\n}\n\nvec3 limit(vec2 z) {\n    if (z.y < -.25) {\n        z = mat2(-1,0,0,-1)*z;\n    }\n    z = (z+1.)*.75; \n    vec2 a_z = .75-abs(z-.75);\n    vec2 scale = scale_f(a_z);\n    if (scale.x == scale.y) {\n        if (scale.x == 2.) {// Center square\n              return corner_tile(z*2.-1.,2);\n        } else {// 'Corner' squares\n            return corner_tile(mod(z*scale+vec2(z.x<.75?1:0,0),vec2(2)),z.x<.75? 0:1); \n        }\n    } else if (scale.x < scale.y){\n        // Top and bottom\n        return side_tiles(mod(z*scale.y*vec2(.5,1.),vec2(1.,2)),0,0);\n    } else { //scale.x > scale.y\n        // Left and right\n        if (z.x > 0.75)\n            z *= mat2(-1,0,0,-1);\n        return side_tiles(mod(z*mat2(0,1,-1,0)*scale.x*vec2(.5,1.),vec2(1.,2)),1,1);\n    }\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 z )\n{\n\tz = (z / iResolution.xy)-0.5;\n    z.x *= iResolution.x/iResolution.y;\n\tfragColor = vec4(limit(z*2.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 149, 149, 535], [537, 537, 575, 575, 831], [833, 833, 890, 890, 1059], [1061, 1061, 1117, 1117, 1570], [1572, 1572, 1603, 1603, 2009], [2011, 2011, 2048, 2048, 2250], [2252, 2252, 2288, 2288, 2525], [2527, 2527, 2585, 2585, 3328], [3330, 3330, 3351, 3351, 3387], [3389, 3389, 3409, 3409, 4166], [4169, 4169, 4218, 4218, 4326]], "test": "valid"}
{"id": "Xlt3Wl", "name": "RayTriangleIntersect", "author": "albertelwin", "description": "Practicing ray-triangle intersection :)", "tags": ["3d", "raycasting", "triangle", "intersection"], "likes": 5, "viewed": 214, "published": "Public", "date": "1472522378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SUPERSAMPLING 1\n\n#define TAU 6.28318530717958647692\n#define TO_RAD 0.01745329251\n#define GAMMA 2.2\n#define MAX_DIST 1000.0\n\nfloat dither(vec2 xy, float t) {\n    float s = (xy.x * 12.9898) + (xy.y * 78.2330);\n    float r = fract(sin((t * 12.9898) + s) * 43758.5453) + fract(sin((t * 78.2330) + s) * 43758.5453);\n    return (r * 0.00392156886) - 0.00196078443;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float fov = 90.0;\n    float tan_fov = tan(fov * 0.5 * TO_RAD);\n    vec2 image_plane = vec2(tan_fov, tan_fov * (iResolution.y / iResolution.x));\n\n#define MAX_SAMPLE_COUNT 8\n    vec2 sample_offsets[MAX_SAMPLE_COUNT];\n\tsample_offsets[0] = vec2(0.125, 0.875);\n    sample_offsets[1] = vec2(0.625, 0.875);\n    sample_offsets[2] = vec2(0.375, 0.625);\n    sample_offsets[3] = vec2(0.875, 0.625);\n    sample_offsets[4] = vec2(0.125, 0.375);\n    sample_offsets[5] = vec2(0.625, 0.375);\n    sample_offsets[6] = vec2(0.375, 0.125);\n    sample_offsets[7] = vec2(0.875, 0.125);\n\n#if SUPERSAMPLING\n    #define SAMPLE_COUNT MAX_SAMPLE_COUNT\n#else\n    #define SAMPLE_COUNT 1\n#endif\n\n    float a = iTime * 0.5 + 2.9;\n    float cos_a = cos(a);\n    float sin_a = sin(a);\n\n#if 1\n    //NOTE: Just baking the y-rotation into the vertices :)\n    vec3 A = vec3(-cos_a - sin_a, 1.0, sin_a - cos_a) * 0.8;\n    vec3 B = vec3( sin_a - cos_a,-1.0, sin_a + cos_a) * 0.8;\n    vec3 C = vec3( cos_a + sin_a, 1.0, cos_a - sin_a) * 0.8;\n    vec3 D = vec3( cos_a - sin_a,-1.0,-sin_a - cos_a) * 0.8;\n\n#define VERTEX_COUNT 12\n    vec3 v[VERTEX_COUNT];\n    v[ 0] = A; v[ 1] = B; v[ 2] = C;\n    v[ 3] = C; v[ 4] = B; v[ 5] = D;\n    v[ 6] = D; v[ 7] = A; v[ 8] = C;\n    v[ 9] = A; v[10] = D; v[11] = B;\n#else\n#define VERTEX_COUNT 3\n    vec3 v[VERTEX_COUNT];\n    v[0] = vec3( 0.0,-1.0, 0.0);\n    v[1] = vec3(-0.866 * cos_a, 0.5, 0.866 * sin_a);\n    v[2] = vec3( 0.866 * cos_a, 0.5,-0.866 * sin_a);\n#endif\n\n    vec3 color = vec3(0.0);\n\n    for(int sample_index = 0; sample_index < SAMPLE_COUNT; sample_index++) {\n        vec2 sample_pos = fragCoord.xy + sample_offsets[sample_index];\n        vec3 image_point = vec3((2.0 * sample_pos / iResolution.xy - 1.0) * image_plane, -2.0);\n\n        vec3 ro = vec3(0.0, 0.0, -3.0);\n        vec3 rd = normalize(image_point - ro);\n\n        for(int i = 0; i < VERTEX_COUNT; i += 3) {\n            vec3 v0 = v[i + 0];\n            vec3 v1 = v[i + 1];\n            vec3 v2 = v[i + 2];\n\n            vec3 e0 = v1 - v0;\n            vec3 e1 = v2 - v0;\n\n            vec3 n = cross(e0, e1);\n            float d2 = dot(n, n);\n            vec3 m = n * (1.0 / d2);\n            n = m * sqrt(d2);\n\n          \tfloat dot_nd = dot(n, rd);\n            float t = dot(v0 - ro, n) / dot_nd;\n            vec3 p = ro + t * rd;\n            \n            vec3 b;\n            b.y = dot(cross(p - v2, e1), m);\n            b.z = dot(cross(e0, p - v0), m);\n            b.x = 1.0 - (b.y + b.z);\n\n            if(b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0) {\n                color += b;\n            }\n        }\n    }\n\n    color *= (1.0 / float(SAMPLE_COUNT));\n    color += dither(fragCoord.xy, fract(iTime));\n    color = pow(color, vec3(1.0 / GAMMA));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlt3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 165, 165, 369], [371, 371, 426, 426, 3172]], "test": "valid"}
{"id": "XltGR2", "name": "Shielding", "author": "Maff", "description": "Mushrooms is sexy.", "tags": ["notpoo"], "likes": 9, "viewed": 748, "published": "Public", "date": "1470315196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n//\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n\n    return vec3( md, mr );\n}\n\n\nfloat sphere(float t, float k)\n{\n    float d = 1.0+t*t-t*t*k*k;\n    if (d <= 0.0)\n        return -1.0;\n    float x = (k - sqrt(d))/(1.0 + t*t);\n    return asin(x*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // bg texture\n    vec4 texColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n  \tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    float v = iResolution.x;\n    if (v > iResolution.y)\n        v = iResolution.y;\n\tuv /= v;\n    uv *= 3.0;\n    float len = length(uv);\n    float k = 1.0;\n    float len2;\n\n    len2 = sphere(len*k,sqrt(2.0))/sphere(1.0*k,sqrt(2.0));\n\tuv = uv * len2 * 0.5 / len;\n\tuv = uv + 0.5;\n\t/*if (len2 < 0.0 || uv.x < 0. || uv.y < 0. || uv.x > 1. || uv.y > 1.)\n\t{\n\t\tfragColor = texColor;\n\t\treturn;\n\t}*/\n    \n    vec2 pos = uv;\n    float t = iTime/1.0;\n    float scale1 = 40.0;\n    float scale2 = 20.0;\n    float val = 0.0;\n    \n    val += sin((pos.x*scale1 + t));\n    val += sin((pos.y*scale1 + t)/2.0);\n    val += sin((pos.x*scale2 + pos.y*scale2 + sin(t))/2.0);\n    val += sin((pos.x*scale2 - pos.y*scale2 + t)/2.0);\n    val /= 2.0;\n\n\n    vec3 c = voronoi(64.0*pos );\n\n\t// isolines\n    val += 2.0*sin(t)*c.x*(0.5 + 0.5*sin(64.0*c.x));\n    \n    float glow = 0.020 / (0.015 + distance(len, 1.0));\n    \n    val = (cos(PI*val) + 1.0) * 0.5;\n    vec4 col2 = vec4(0.3, 0.7, 1.0, 1.0);\n    \n    fragColor = step(len, 1.0) * 0.5 * col2 * val + glow * col2 + 0.5 * texColor;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 53, 174, 264], [266, 266, 293, 293, 1328], [1331, 1331, 1363, 1363, 1498], [1501, 1501, 1558, 1576, 2757]], "test": "error"}
{"id": "XsySWc", "name": "Material Design Pattern", "author": "Flyguy", "description": " A material design styled pattern thing with faked shadows.\n", "tags": ["shadow", "light", "pattern", "material"], "likes": 16, "viewed": 789, "published": "Public API", "date": "1471314035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----- Definitions -----\n//#define FAKE_POINT_LIGHT\n\n#define TEXTURE_OVERLAY\n#define TEXTURE_OPACITY 0.16\n#define TEXTURE_BLUR 0.5\n\n#define TILE_SIZE 0.25\n\n//Colors from https://material.google.com/style/color.html\n#define TILE0_BG 0x8BC34A\n#define TILE0_BG_S 0x558B2F\n#define TILE0_CIRC 0xF44336\n\n#define TILE1_BG 0x0D47A1\n#define TILE1_BG_S 0x1E88E5\n#define TILE1_CIRC 0xE65100\n#define TILE1_CIRC_S 0xFF9800\n\n//Alpha mask from distance field.\n#define DFMASK(a) smoothstep(aaSize, 0.0, (a))\n\n//----- Globals -----\nvec2 aspect = vec2(0);\nvec2 uv = vec2(0);\nvec2 mouse = vec2(0);\nfloat aaSize = 0.0;\nvec2 tIdx = vec2(0);\nvec2 tUV = vec2(0);\n\n//----- Utilities -----\n//Hex color code (0xRRGGBB) to vec3.\nvec3 Hex(int hex)\n{\n    return mod(floor(float(hex) / exp2(vec3(16, 8, 0))), 256.0) / 255.0;\n}\n\n//Average of vec3 components.\nfloat Average(vec3 c)\n{\n    return (c.r + c.g + c.b)/3.0;\n}\n\n//----- Shapes -----\nvec4 Background(vec3 col)\n{\n\treturn vec4(col, 1);   \n}\n\nvec4 Circle(vec2 pos, float r, vec3 col)\n{\n    float mask = DFMASK(length(tUV - pos) - r);\n    return vec4(col, mask);\n}\n\nvec4 Line(vec2 start, vec2 end, float r, vec3 col)\n{\n\tvec2 line = end - start;\n\tfloat frac = dot(tUV - start,line) / dot(line,line);\n    float mask = DFMASK(distance(start + line * clamp(frac, 0.0, 1.0), tUV) - r);\n\treturn vec4(col, mask);\n}\n\nvec4 Box(vec2 pos, float r, vec3 col)\n{\n    vec2 p = abs(tUV - pos);\n    float mask = DFMASK(max(p.x,p.y) - r);\n    return vec4(col, mask); \n}\n\n//----- Operations -----\n//Blend a into b using a's alpha.\nvec4 Blend(vec4 a, vec4 b)\n{\n    return mix(b, a, a.w);\n}\n\n//Mask a's alpha with msk's alpha.\nvec4 Mask(vec4 a, vec4 msk, bool inv)\n{\n    return vec4(a.rgb, a.w * (inv ? 1.0-msk.w : msk.w));\n}\n\n//----- Rendering -----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Setup globals\n    aspect = iResolution.xy / iResolution.y;\n\tuv = fragCoord.xy / iResolution.y - aspect/2.0;\n    aaSize = 1.0 / iResolution.y / TILE_SIZE;\n    mouse = (iMouse.xy / iResolution.y) - aspect/2.0;\n    \n    vec2 tileIdx = floor(uv / TILE_SIZE);\n    tUV = fract(uv / TILE_SIZE) - 0.5;\n    \n    vec4 color = vec4(0, 0, 0, 1);\n    \n    vec4 tile = vec4(0);\n    \n    //Shadow direction/size.\n    float ang = 0.3 * iTime;\n    vec2 shadvec = 0.12 * vec2(cos(ang), sin(ang));\n    \n    #ifdef FAKE_POINT_LIGHT\n    shadvec = normalize(vec3(uv - mouse, 2.0)).xy;\n    #endif\n    \n    //Checker board pattern.\n    if(mod(tileIdx.x + tileIdx.y, 2.0) == 1.0)\n    {\n        //Tile 0\n        \n        tile = Background(Hex(TILE0_BG));\n        vec4 shad = Line(vec2(0),shadvec,0.25, Hex(TILE0_BG_S));\n        vec4 circ = Circle(vec2(0), 0.25, Hex(TILE0_CIRC));\n\t\t\n        tile = Blend(shad, tile);\n        tile = Blend(circ, tile);\n    }\n    else\n    {\n        //Tile 1\n        \n        tile = Background(Hex(TILE1_BG));\n        vec4 ligt = Box(shadvec,0.5, Hex(TILE1_BG_S));\n        vec4 shad = Circle(vec2(0), 0.25, Hex(TILE1_CIRC));\n        vec4 circ = Circle(shadvec, 0.25, Hex(TILE1_CIRC_S));\n        circ = Mask(circ, shad, false);\n\t\t\n        tile = Blend(ligt, tile);\n        tile = Blend(shad, tile);\n        tile = Blend(circ, tile);\n    }\n    \n    color = tile;\n    \n    //Subtle overlay texture.\n    #ifdef TEXTURE_OVERLAY\n    vec2 texUV = uv * (iResolution.y / iChannelResolution[0].y);\n    color *= Average(texture(iChannel0, texUV, TEXTURE_BLUR).rgb) * TEXTURE_OPACITY + (1.0 - TEXTURE_OPACITY);\n    #endif\n    \n\tfragColor = color;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsySWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[642, 703, 722, 722, 797], [799, 829, 852, 852, 888], [890, 911, 938, 938, 965], [967, 967, 1009, 1009, 1087], [1089, 1089, 1141, 1141, 1330], [1332, 1332, 1371, 1371, 1474], [1476, 1535, 1563, 1563, 1592], [1594, 1629, 1668, 1668, 1727], [1729, 1753, 1810, 1830, 3457]], "test": "error"}
{"id": "Xt3GzX", "name": "Quotidian", "author": "ivansafrin", "description": "#shaderaday #2", "tags": ["sun", "moon", "shaderaday"], "likes": 5, "viewed": 670, "published": "Public API", "date": "1470416434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359 \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float reflectVal = 0.0;\n    if(uv. y < 0.35) {\n        reflectVal = 0.35-(0.35-uv.y);\n        uv.y = 0.35 + (0.35-uv.y);\n        uv.x += sin(iTime+(uv.y* 130.0)) * 0.01;\n    }\n    vec2 sunC = vec2((0.5 * iResolution.x/iResolution.y) + cos(iTime)*0.5\n                         , 0.5 + sin(iTime)*0.4);\n    vec2 moonC = vec2((0.5 * iResolution.x/iResolution.y) + cos(iTime+PI)*0.5\n                      , 0.5 + sin(iTime+PI)*0.4);  \n\tfragColor = vec4(0.05, 0.1, sunC.y, 1.0) +\n        (vec4(1.0, 0.2, 0.0, 1.0) * ((distance(uv, sunC) < 0.06)  ? 1.0 : 0.0))+\n        (vec4(1.0, 0.2+ (abs(sin(iTime)) * 0.8), 0.0, 1.0) * (1.0-distance(uv, sunC) * abs(sin(iTime-PI)) * 3.0) * 1.5\n        *(0.5 + sin(iTime)*0.5))+\n        (vec4(0.8, 0.6, 0.8, 1.0) * ((distance(uv, moonC) < 0.04)  ? 1.0 : 0.0))\n        + (vec4(1.0, 0.3, 0.0, 1.0) * reflectVal);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3GzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 971]], "test": "valid"}
{"id": "Xtc3D2", "name": "Aliens", "author": "ivansafrin", "description": "#shaderaday shader #7\n", "tags": ["alien", "egg", "aliens", "shaderaday"], "likes": 31, "viewed": 4746, "published": "Public API", "date": "1471540439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float EPSILON = 0.005;\n\nvec2 sphere_map(vec3 n) {\n\treturn vec2((atan(n.z,n.x)/(2.0 * PI)), acos(n.y) / (PI));\n}\n\nvec3 smin( vec3 a, vec3 b, float k ) {\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec3 scene(vec3 position) {\n    position.xz = mod(position.xz, 1.4) - 1.0;\n     \n    vec2 uv = sphere_map(normalize(position));\n    \n    float beat = 0.2+ (sin(iTime*20.0) * 0.05);\n    float height = 0.3 + texture(iChannel0, uv).x * beat * (0.5-distance(uv.y, 0.5));\n    vec3 r = vec3(height-0.1, height, height-0.1);\n    vec3 membraneVal = vec3((length(position/r) - 1.0) * min(min(r.x,r.y),r.z), 1.0, 0.0);\n   \n\tr = vec3(0.25, 0.35, 0.25);\n\tvec3 shellVal = vec3((length(position/r) - 1.0) * min(min(r.x,r.y),r.z), 0.0, 1.0);\n    \n    float mixAmt = texture(iChannel0, uv).x*1.1;\n    mixAmt = max(mixAmt, 0.2) - 0.2;\n    vec3 floorval = vec3(position.y+0.3+texture(iChannel0, position.xz).x*0.02, 0.0, 1.0);\n    vec3 eggVal = mix(shellVal, membraneVal, mixAmt);\n    return smin(floorval, eggVal, 0.2);\n}\n\nvec3 raymarch(vec3 position, vec3 direction) {\n    float total_distance = 0.0;\n    for(int i = 0 ; i < 64 ; ++i) {\n        vec3 result = scene(position + direction * total_distance);\n        if(result.x < EPSILON) {\n            return vec3(total_distance, result.y, result.z);\n        }\n        total_distance += result.x;\n    }\n    return vec3(-1.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv -= vec2(0.5*iResolution.x/iResolution.y, 0.5);\n    uv.y -= 0.3;\n    vec3 direction = normalize(vec3(uv, 2.5));\n    vec3 origin = vec3(0.3, 0.6, iTime*0.5);\n    vec3 result = raymarch(origin, direction);\n    \n    vec4 fogColor = vec4(0.1, 0.3, 0.1, 1.0);\n    \n      if(result.x < 0.0) {\n\t\tfragColor = fogColor;\n    } else{\n        vec3 pos = origin+direction*result.x;\n        const vec2 eps = vec2(0.0, EPSILON);\n        vec3 N = normalize(vec3(\n\t\t\tscene(pos + eps.yxx).x - scene(pos - eps.yxx).x,\n\t\t\tscene(pos + eps.xyx).x - scene(pos - eps.xyx).x,\n\t\t\tscene(pos + eps.xxy).x - scene(pos - eps.xxy).x));  \n          \n          vec3 lightPos = origin+vec3(sin(iTime), 0.0, 5.0);\n          \n \t\tfloat diffuse = dot(N, -normalize(pos-lightPos));\n    \t\n        float dist = length(pos-lightPos) * 0.1;\n        float attenuation = 1.0 / (1.0 + 2.3*dist + 6.0*dist*dist);\n  \n          \n\t\tdiffuse = max(0.0, diffuse) * attenuation; \n        vec2 auv = sphere_map(normalize(pos));\n        \n\t\tfloat beat = max(0.0, sin(iTime));\n        \n\t\tfloat distance = length(origin-pos);\n\t\tfloat fogVal = exp(-distance*distance*0.03);  \n        \n\t\tvec4 pulseColor = vec4(0.0, 0.3, 0.1, 1.0);\n\t\tvec4 membraneColor = vec4(0.756, 0.627 ,0.172, 1.0) ;\n\t\tvec4 finalColor = (pulseColor*diffuse*result.y)+ result.y * texture(iChannel0, auv).x * beat * vec4(1.0, 1.0, 0.0, 1.0) * 2.0 +\n            (membraneColor*diffuse*result.z)+\n            pow(max(0.0,dot(normalize(reflect(pos-lightPos, N)),normalize(-pos))), 40.0)\n            ;\n       fragColor = mix(fogColor, finalColor, fogVal);\n          fragColor.a = 1.0;\n      }\n}", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtc3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 87, 87, 149], [151, 151, 189, 189, 286], [287, 287, 314, 314, 1091], [1093, 1093, 1139, 1139, 1456], [1458, 1458, 1515, 1515, 3161]], "test": "error"}
{"id": "Xtc3Rs", "name": "ring_test", "author": "asneakyfatcat", "description": "rad. \n\nAs globaltime goes on you start to get some very interesting interference patterns. ", "tags": ["test", "ring"], "likes": 5, "viewed": 100, "published": "Public", "date": "1470786670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = vec2( fragCoord - .5*R ) / R.y  *5.;\n    uv.x+=sin(uv.y*t*.5);\n    \n\tfragColor = mix(vec4(sin(dot(uv,uv)-t)),\n                    vec4(-uv.x-uv.y, uv.x, uv.y, 1.),\n                    .2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtc3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 313]], "test": "valid"}
{"id": "Xtc3Ws", "name": "Planet Texture", "author": "jackdavenport", "description": "A distant terrestrial world with a rough and rugged terrain.", "tags": ["texture", "light", "space", "planet", "raymarcher", "stars", "world"], "likes": 11, "viewed": 861, "published": "Public API", "date": "1472263103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 512\n#define MAX_DISTANCE 20000.\n#define SHADOW_BIAS .01\n\n#define EPSILON .001\n#define PI 3.14159265358979323846264338327950288419\n\n#define LIGHT_COL vec3(252.,212.,128.)/255.\n#define LIGHT_AMB vec3(.1)\n#define LIGHT_DIR normalize(vec3(45.,30.,45.))\n\nvec2 rot2D(vec2 p, float angle) {\n\tangle = radians(angle);\n    float s = sin(angle), c = cos(angle);\n    return mat2(c,s,-s,c)*p;\n}\n\n// Noise by iq\n// Source: https://www.shadertoy.com/view/XslGRr\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat dstScene(vec3 p) {\n    vec3  n = normalize(p);\n    vec2 uv = asin(n.xy)/PI+.5;\n    float h = texture(iChannel0,uv).x*.1;\n\treturn length(p)-(6300.+(1250.*h));\n}\n\nfloat raymarch(vec3 ori, vec3 dir) {\n    float t = 0.;\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n    \tfloat scn = dstScene(ori+dir*t);\n        if(scn < EPSILON*t || t > MAX_DISTANCE)\n            break;\n        t += scn * .75;\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n\tvec2 e = vec2(EPSILON*t,0.);\n    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),\n                  dstScene(p+e.yxy)-dstScene(p-e.yxy),\n                  dstScene(p+e.yyx)-dstScene(p-e.yyx));\n    return normalize(n);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = dstScene( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.07, .5 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// Shadows by iq\n// Source: https://www.shadertoy.com/view/Xds3zN\nvec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sh, vec3 ori) {\n\tvec3 ds = vec3(0.);\n    vec3 ss = vec3(0.);\n    float d = max(dot(LIGHT_DIR,n),0.);\n    float s = 0.;\n    d *= softshadow(p,LIGHT_DIR,SHADOW_BIAS,MAX_DISTANCE,64.);\n    if(d > 0. && sh > 0.)\n        s = pow(max(dot(LIGHT_DIR,r),0.),sh);\n    ds += LIGHT_COL * d;\n    ss += LIGHT_COL * s;\n    vec3 plv = ori-p;\n    vec3 pld = normalize(plv);\n    d = max(dot(pld,n),0.);\n    s = 0.;\n    d *= softshadow(p,pld,SHADOW_BIAS,length(plv),64.);\n    if(d > 0. && sh > 0.)\n        s = pow(max(dot(pld,r),0.),sh);\n    float a = 1.-clamp(length(plv)/3500.,0.,1.);\n    ds += vec3(d*a);\n    ss += vec3(s*a);\n    return (col*(LIGHT_AMB+ds))+ss;\n}\n\nvec3 getSky(vec3 dir) {\n\tvec3 c = vec3(noise(dir*256.));\n    if(c.x < .8) {\n    \tc = vec3(0.);\n    }\n    return c;\n}\n\nvec3 shade(vec3 ori, vec3 dir) {\n \n    float  t = raymarch(ori,dir);\n    vec3 col = vec3(0.);\n    \n    if(t < MAX_DISTANCE) {\n    \tvec3 p = ori+dir*t;\n        vec3 n = calcNormal(p,t);\n        vec3 r = normalize(reflect(dir, n));\n        \n        vec2 uv = asin(n.xy)/PI+.5;\n        \n        col = texture(iChannel0,uv).xyz;\n        col = calcLighting(col, p, n, r, 30., ori);\n    } else {\n    \tcol = getSky(dir);\n    }\n    \n    float f = pow(max(dot(LIGHT_DIR,dir),0.),60.);\n  \tif(raymarch(ori,LIGHT_DIR) >= MAX_DISTANCE)\n         col += LIGHT_COL * f;\n    \n    return col;\n    \n}\n\nvec3 getCameraOrigin(float t) {\n\tfloat gt = mod(t, 15.);\n    float  r = 1.-(smoothstep(3.,6.,gt)*(1.-smoothstep(12.,15.,gt)));\n    float  a = radians(35.*(2.+t*.1));\n    return vec3(cos(a),0.,sin(a))*mix(7050.,15000.,r);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = getCameraOrigin(iTime);\n    vec3 dir = vec3(uv,1.);\n    \n    vec3 f = normalize(-ori);\n    vec3 u = normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 v = normalize(cross(u,f));\n    dir = normalize(mat3(u,v,f)*dir);\n    \n\tfragColor = vec4(shade(ori,dir),1.);\n}\n\nvoid mainVR(out vec4 fc, in vec2 fp, in vec3 ro, in vec3 rd) {\n    vec3 ori = ro + getCameraOrigin(iTime);\n    vec3 dir = normalize(rd);\n    fc = vec4(shade(ori,dir),1.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtc3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 306, 306, 404], [406, 470, 496, 496, 714], [716, 716, 740, 740, 881], [883, 883, 919, 919, 1134], [1136, 1136, 1170, 1170, 1393], [1395, 1395, 1481, 1481, 1740], [1742, 1808, 1881, 1881, 2513], [2515, 2515, 2538, 2538, 2631], [2633, 2633, 2665, 2665, 3214], [3216, 3216, 3247, 3247, 3441], [3443, 3443, 3500, 3500, 3837], [3839, 3839, 3901, 3901, 4011]], "test": "error"}
{"id": "Xtc3zX", "name": "distortion noise texture", "author": "KukaTails", "description": "generate textures by distortion noise function", "tags": ["distortionnoise"], "likes": 6, "viewed": 154, "published": "Public", "date": "1470422196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return -1.0 + 2.0 * fract(sin(h) * 4358.5453);\n}\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\n\nvec2 VecNoise(vec2 point)\n{\n    vec2 res;\n    res.x = Noise(point);\n    res.y = Noise(point + vec2(iTime / 3.0));\n    return res;\n}\n\n\nfloat DistortionNoise(vec2 point, float distortion)\n{\n    vec2 offset = point + vec2(0.5);\n    offset = VecNoise(point);\n    offset *= distortion;\n    point += offset;\n    return Noise(point);\n}\n\nvec3 GetColor(float noise_value)\n{\n    vec3 a = vec3(0.0);\n    vec3 b = vec3(1.5);\n    return clamp(vec3(mix(a, b, noise_value)), vec3(0.0), vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float noise_value = DistortionNoise(uv * 30.0, 1.0);\n    \n    fragColor = vec4(GetColor(noise_value), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtc3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 114], [116, 116, 137, 137, 428], [431, 431, 458, 458, 562], [565, 565, 618, 618, 759], [761, 761, 795, 795, 915], [917, 917, 974, 974, 1129]], "test": "valid"}
{"id": "XtcGzs", "name": "80s chrome effect", "author": "nuclear", "description": "A procedural reproduction of the 80s chrome logo effect.\nThis was meant for distance field font rendering, emulated here by a weird animated distance field.", "tags": ["2d", "80s", "chrome", "cyberspace"], "likes": 14, "viewed": 1073, "published": "Public API", "date": "1470799905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float smoothness = 0.015;\nconst float bevel_size = 0.1;\n\nconst float horiz_scale = 10.0;\nconst vec3 mid_color = vec3(0.133, 0.006, 0.612);\nconst vec3 horiz_color = vec3(0.612, 0.006, 1.0);\nconst vec3 fog_color = vec3(0.01, 0.01, 0.01);\n\n\nfloat glyph_dist(in vec2 pt);\nvoid gradcurves(float t, out float over, out float under);\nvec3 backdrop(in vec2 pt);\nfloat fbm4(float p);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 pt = (uv * 2.0 - 1.0) * vec2(aspect, 1.0) * 1.0;\n    \n    float dist = glyph_dist(pt);\n    float dfdu = glyph_dist(pt + vec2(0.01, 0.0)) - dist;\n    float dfdv = glyph_dist(pt + vec2(0.0, 0.01)) - dist;\n    vec2 grad = normalize(vec2(dfdu, -dfdv));\n\n    float val = smoothstep(-smoothness, smoothness, dist);\n    float bevel = smoothstep(bevel_size - smoothness, bevel_size + smoothness, dist);\n    \n    // --- face gradients ---\n\tfloat t = uv.y;\n\n\tfloat c_over, c_under;\n\tfloat tlow = min(2.0 * t, 1.0);\n\tgradcurves(tlow, c_over, c_under);\n\tvec3 color_low = vec3(c_over, c_under, c_over * 0.5);\n\n\tfloat thigh = max(2.0 * t - 1.0, 0.0);\n\tgradcurves(thigh, c_over, c_under);\n\tvec3 color_high = vec3(c_under, c_under, c_over);\n\n\tvec3 face_color = mix(color_low, color_high, step(0.5, t));\n\n    // --- bevel gradients ---\n\tfloat bv_shade = mod(1.0 * dot(grad, normalize(vec2(0.1, 1.0))) * 0.5 + 0.5, 1.0);\n\n\tgradcurves(1.0 - bv_shade, c_over, c_under);\n\tvec3 bv_color = vec3(c_under, c_under, c_over);\n    \n    vec3 color = mix(bv_color, face_color, bevel);\n\tfragColor = vec4(mix(backdrop(pt), color, val), 1.0);\n}\n\n// emulate what you'd get from the distance field glyphmap\nfloat glyph_dist(in vec2 pt)\n{\n    float angle = atan(pt.y, pt.x) - iTime * 0.1;\n    float len = length(pt);\n    float rad = 1.0 - len;\n    \n    float theta = angle + sin(iTime - len * 10.0) * 0.2;\n    \n    return rad - abs(sin(theta * 2.5)) * 0.6;\n}\n\n\n#define HALF_PI 1.570796326794897\n\nvoid gradcurves(float t, out float over, out float under)\n{\n    over = cos(t * HALF_PI);\n    under = cos(t * HALF_PI + HALF_PI) + 1.0;\n}\n\nvec3 sky_grad(float t)\n{\n\treturn mix(horiz_color, mid_color, t - 0.8);\n}\n\nvec3 grid(in vec2 pt)\n{\n    float z = 1.0 + abs(pt.y) * 6.0;\n    float x = pt.x / z;\n    float y = abs(pt.y) / z;\n    float val = max(sin(x * 100.0), sin(y * 900.0));\n    \n    float col_t = smoothstep(2.0, 4.5, z);\n    vec3 col = mix(fog_color, vec3(1.0, 0.2, 1.0), col_t);\n    \n    return step(0.22, -pt.y) * val * smoothstep(0.9, 0.95, val) * col;\n}\n\nvec3 backdrop(in vec2 pt)\n{\n    //return grid(pt);\n    vec3 color = sky_grad(pt.y * 2.0);\n\n    float horiz = pt.y + fbm4(pt.x * 1.8) * 0.1;\n\n    return mix(fog_color, color, smoothstep(0.025, 0.03, horiz)) + grid(pt);\n}\n\nfloat cnoise(vec2 p);\n\nfloat fbm4(float p)\n{\n    float res = 0.0;\n    float freq = 1.0;\n    float scale = 1.0;\n    \n    for(int i=0; i<4; i++) {\n        res += cnoise(vec2(p * freq, 0.0)) * scale;\n        freq *= 2.0;\n        scale *= 0.5;\n    }\n    return res;\n}\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylor_inv_sqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic perlin noise\nfloat cnoise(vec2 p)\n{\n  vec4 pi = floor(p.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 pf = fract(p.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  pi = mod289(pi); // To avoid truncation effects in permutation\n  vec4 ix = pi.xzxz;\n  vec4 iy = pi.yyww;\n  vec4 fx = pf.xzxz;\n  vec4 fy = pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylor_inv_sqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 382, 439, 439, 1652], [1654, 1713, 1743, 1743, 1963], [2001, 2001, 2060, 2060, 2137], [2139, 2139, 2163, 2163, 2211], [2213, 2213, 2236, 2236, 2564], [2566, 2566, 2593, 2616, 2785], [2810, 2810, 2831, 2831, 3050], [3052, 3496, 3517, 3517, 3566], [3568, 3568, 3590, 3590, 3627], [3629, 3629, 3659, 3659, 3711], [3713, 3713, 3732, 3732, 3772], [3774, 3798, 3820, 3820, 4864]], "test": "error"}
{"id": "Xtd3Dj", "name": "Perlin Noise", "author": "AsGreyWolf", "description": "simple perlin noise", "tags": ["procedural", "2d", "noise", "perlinnoise", "perlin"], "likes": 2, "viewed": 177, "published": "Public", "date": "1471691083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat linear(float a, float b, float t){\n    return a + (b - a) * t;\n}\nfloat bilinear(float tl, float tr, float bl, float br, float x, float y){\n\treturn linear(linear(tl, tr, x), linear(bl, br, x), y);\n}\nfloat quintic(float t){\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nfloat biquintic(float tl, float tr, float bl, float br, float x, float y){\n\treturn bilinear(tl, tr, bl, br, quintic(x), quintic(y));\n}\nvec2 gridCell(vec2 x){\n\treturn floor(x);\n}\nvec2 randV(vec2 c){\n    float r = rand(c*0.005);\n    if(r<0.25) return vec2(0,1);\n    if(r<0.5) return vec2(0,-1);\n    if(r<0.75) return vec2(1,0);\n    return vec2(-1,0);\n}\nfloat perlin(vec2 c){\n    vec2 cell = gridCell(c);\n    vec2 dc = c-cell;\n    float tl = dot(dc, randV(cell));\n    float tr = dot(vec2(dc.x-1.0, dc.y), randV(vec2(cell.x+1.0,cell.y)));\n    float bl = dot(vec2(dc.x, dc.y-1.0), randV(vec2(cell.x,cell.y+1.0)));\n    float br = dot(vec2(dc.x-1.0, dc.y-1.0), randV(vec2(cell.x+1.0,cell.y+1.0)));\n    return biquintic(tl, tr, bl, br, dc.x, dc.y);\n}\nfloat perlin5(vec2 c){\n    float amplitude = 1.0;\n    float v = 0.0;\n    float m = 0.0;\n    for(int i=0;i<5;i++){\n        v+=perlin(c)*amplitude;\n        m+=amplitude;\n        amplitude/=2.0;\n        c*=2.0;\n    }\n    return v/m;\n}\nfloat coeff(){\n    float t = iTime/5.0;\n    t -= floor(t);\n    t *= 2.0;\n    if(t<=1.0)\n        return t;\n    return 2.0-t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 0.03+0.1*coeff();\n\tvec2 uv = fragCoord.xy / iResolution.xy / size;\n    uv.x *= iResolution.x/iResolution.y;\n    float v = perlin5(uv)*0.5+0.5;\n    fragColor = vec4(v,v,v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtd3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [93, 93, 133, 133, 163], [164, 164, 237, 237, 296], [297, 297, 320, 320, 376], [377, 377, 451, 451, 511], [512, 512, 534, 534, 554], [555, 555, 574, 574, 727], [728, 728, 749, 749, 1119], [1120, 1120, 1142, 1142, 1351], [1352, 1352, 1366, 1366, 1477], [1478, 1478, 1535, 1535, 1730]], "test": "valid"}
{"id": "Xtd3Dl", "name": "Party Template", "author": "Imsure1200q_1UWE130", "description": "Lights Of Te UV Party", "tags": ["lights"], "likes": 0, "viewed": 436, "published": "Public API", "date": "1472449738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time = iTime;\nmat2 rot(vec2 uv)\n{\n    mat2 sort = mat2(cos(time)+uv.x+uv.y, -sin(time)+uv.x-uv.y, sin(time)+uv.y - uv.x, cos(time) + -uv.y-uv.x);\n    mat2 re_sort = mat2(cos(time)-uv.x+uv.y, -sin(time)-uv.x-uv.y, sin(time)-uv.y - uv.x, cos(time) - -uv.y-uv.x);\n    #define sorted if(sort == re_sort) a += t / n;\n    #define unsorted if(sort != re_sort) a += t * n;\n    #define eql if(t == n) q = t * n;\n    #define uneql if(t != n) q = t / n;\n    #define geql if(t > n) q = t - n;\n    #define leql if(t < n) q = n - t;\n    float t, n, a, q = 0.0;\n    float x = uv.x;\n    float y = uv.y;\n    float sx = fract(x);\n    float sy = fract(y);\n    t += x; n += y; sorted; unsorted;\n    t += sx; n += y; sorted; unsorted;\n    t += x; n += sy; sorted; unsorted;\n    t += sx; n += sy; sorted; unsorted;\n    float b = 0.0;\n    b += sqrt(max(max(x, y),max(sx, sy)));\n    t += b; n += b; eql; uneql; geql; leql;\n    t -= b; n += b; eql; uneql; geql; leql;\n    t += b; n -= b; eql; uneql; geql; leql;\n    t -= b; n -= b; eql; uneql; geql; leql;\n    \n    vec2 i = vec2(q / a);\n    vec2 i2 = fract(i);\n    return mat2(cos(time)+i.x, -sin(time)+i.y, sin(time)+i2.x, cos(time)+i2.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0; //<------------------------\n    uv.x *= iResolution.x / iResolution.y; //<- much better\n    float i = length(uv) + 1.0;\n    vec3 col = vec3(vec2(i) * rot(uv), i);\n    fragColor = vec4(sin(col), 1.0) - vec4(0.1, 0.1, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtd3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 1173], [1174, 1174, 1231, 1231, 1533]], "test": "valid"}
{"id": "Xtd3RB", "name": "Aiekick's Disturbing Maze rmx 1", "author": "CaliCoastReplay", "description": "A remix of https://www.shadertoy.com/view/Xtc3DN by aiekick.  Lots of fun to play with!  I feel like this would make a great shader for a maze game generally.", "tags": ["maze", "disturbing"], "likes": 5, "viewed": 176, "published": "Public", "date": "1470007361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 uv = 4.*(2. * g - iResolution.xy)/iResolution.y;\n\t\n    g /= 45.;\n    \n    float rep = cos(3.14 *( g.y + g.x* sign(cos(tan( 6e3 * length(floor(g))) )) ));\n    \n\tfloat a = atan(uv.x, uv.y) / 3.14159 * 1.5;\n\tfloat r = length(uv) - iTime*0.5 ;\n\ta+=r+rep/2.0;\n\tuv = abs(fract(vec2(a+r,a-r))-0.5);\n\t\n\tfloat x = uv.x*1.248;\n\tfloat y = uv.y*6.;\n\tfloat z = uv.y*1.28;\n\tfloat hex = abs(max(x*y,x) - 1.386);\n\tvec3 col = hex * .3 * vec3(0.15,0.24,0.37)/length(uv);\n\t\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += uv.x;\n    hsv.y += uv.y;\n    col = hsv2rgb(hsv);\n    \n    f.rgb =  col;\n    if (abs(rep) > 0.9)\n        f.rgb = col+.5-vec3(.34,1,1)/25./rep;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtd3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 352], [354, 354, 376, 376, 545], [547, 547, 588, 588, 1238]], "test": "valid"}
{"id": "Xtd3Wl", "name": "Reference Perlin Noise", "author": "nlguillemot", "description": "it's just plain Perlin Noise. I tried to write it based on the descriptions in Ken Perlin's papers. Not sure if 100% correct. Designed to help understand Perlin Noise without considering optimizations. Left click and drag to move around and zoom", "tags": ["noise", "perlin"], "likes": 0, "viewed": 208, "published": "Public", "date": "1472438052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// WebGL doesn't support a % b...\nint imod(int a, int b){ return a - a / b * b; }\nivec3 imod3(ivec3 a, ivec3 b) { return a - a / b * b; }\n\n// pseudo-random numbers for the locations of the integer lattice\n// initialized by init_P()\nint Ptab[512];\n\n// sets the permutation table according to the reference numbers by Ken Perlin\nvoid init_P()\n{\n    // macro just short-hand to set the array values\n    // WebGL's GLSL lacks a good way to initialize arrays...\n    #define SP(index,val) Ptab[index] = val;\n    SP(  0,151)SP(  1,160)SP(  2,137)SP(  3, 91)SP(  4, 90)SP(  5, 15)SP(  6,131)SP(  7, 13)\n    SP(  8,201)SP(  9, 95)SP( 10, 96)SP( 11, 53)SP( 12,194)SP( 13,233)SP( 14,  7)SP( 15,225)\n    SP( 16,140)SP( 17, 36)SP( 18,103)SP( 19, 30)SP( 20, 69)SP( 21,142)SP( 22,  8)SP( 23, 99)\n    SP( 24, 37)SP( 25,240)SP( 26, 21)SP( 27, 10)SP( 28, 23)SP( 29,190)SP( 30,  6)SP( 31,148)\n    SP( 32,247)SP( 33,120)SP( 34,234)SP( 35, 75)SP( 36,  0)SP( 37, 26)SP( 38,197)SP( 39, 62)\n    SP( 40, 94)SP( 41,252)SP( 42,219)SP( 43,203)SP( 44,117)SP( 45, 35)SP( 46, 11)SP( 47, 32)\n    SP( 48, 57)SP( 49,177)SP( 50, 33)SP( 51, 88)SP( 52,237)SP( 53,149)SP( 54, 56)SP( 55, 87)\n    SP( 56,174)SP( 57, 20)SP( 58,125)SP( 59,136)SP( 60,171)SP( 61,168)SP( 62, 68)SP( 63,175)\n    SP( 64, 74)SP( 65,165)SP( 66, 71)SP( 67,134)SP( 68,139)SP( 69, 48)SP( 70, 27)SP( 71,166)\n    SP( 72, 77)SP( 73,146)SP( 74,158)SP( 75,231)SP( 76, 83)SP( 77,111)SP( 78,229)SP( 79,122)\n    SP( 80, 60)SP( 81,211)SP( 82,133)SP( 83,230)SP( 84,220)SP( 85,105)SP( 86, 92)SP( 87, 41)\n    SP( 88, 55)SP( 89, 46)SP( 90,245)SP( 91, 40)SP( 92,244)SP( 93,102)SP( 94,143)SP( 95, 54)\n    SP( 96, 65)SP( 97, 25)SP( 98, 63)SP( 99,161)SP(100,  1)SP(101,216)SP(102, 80)SP(103, 73)\n    SP(104,209)SP(105, 76)SP(106,132)SP(107,187)SP(108,208)SP(109, 89)SP(110, 18)SP(111,169)\n    SP(112,200)SP(113,196)SP(114,135)SP(115,130)SP(116,116)SP(117,188)SP(118,159)SP(119, 86)\n    SP(120,164)SP(121,100)SP(122,109)SP(123,198)SP(124,173)SP(125,186)SP(126,  3)SP(127, 64)\n    SP(128, 52)SP(129,217)SP(130,226)SP(131,250)SP(132,124)SP(133,123)SP(134,  5)SP(135,202)\n    SP(136, 38)SP(137,147)SP(138,118)SP(139,126)SP(140,255)SP(141, 82)SP(142, 85)SP(143,212)\n    SP(144,207)SP(145,206)SP(146, 59)SP(147,227)SP(148, 47)SP(149, 16)SP(150, 58)SP(151, 17)\n    SP(152,182)SP(153,189)SP(154, 28)SP(155, 42)SP(156,223)SP(157,183)SP(158,170)SP(159,213)\n    SP(160,119)SP(161,248)SP(162,152)SP(163,  2)SP(164, 44)SP(165,154)SP(166,163)SP(167, 70)\n    SP(168,221)SP(169,153)SP(170,101)SP(171,155)SP(172,167)SP(173, 43)SP(174,172)SP(175,  9)\n    SP(176,129)SP(177, 22)SP(178, 39)SP(179,253)SP(180, 19)SP(181, 98)SP(182,108)SP(183,110)\n    SP(184, 79)SP(185,113)SP(186,224)SP(187,232)SP(188,178)SP(189,185)SP(190,112)SP(191,104)\n    SP(192,218)SP(193,246)SP(194, 97)SP(195,228)SP(196,251)SP(197, 34)SP(198,242)SP(199,193)\n    SP(200,238)SP(201,210)SP(202,144)SP(203, 12)SP(204,191)SP(205,179)SP(206,162)SP(207,241)\n    SP(208, 81)SP(209, 51)SP(210,145)SP(211,235)SP(212,249)SP(213, 14)SP(214,239)SP(215,107)\n    SP(216, 49)SP(217,192)SP(218,214)SP(219, 31)SP(220,181)SP(221,199)SP(222,106)SP(223,157)\n    SP(224,184)SP(225, 84)SP(226,204)SP(227,176)SP(228,115)SP(229,121)SP(230, 50)SP(231, 45)\n    SP(232,127)SP(233,  4)SP(234,150)SP(235,254)SP(236,138)SP(237,236)SP(238,205)SP(239, 93)\n    SP(240,222)SP(241,114)SP(242, 67)SP(243, 29)SP(244, 24)SP(245, 72)SP(246,243)SP(247,141)\n    SP(248,128)SP(249,195)SP(250, 78)SP(251, 66)SP(252,215)SP(253, 61)SP(254,156)SP(255,180)\n    SP(256,151)SP(257,160)SP(258,137)SP(259, 91)SP(260, 90)SP(261, 15)SP(262,131)SP(263, 13)\n    SP(264,201)SP(265, 95)SP(266, 96)SP(267, 53)SP(268,194)SP(269,233)SP(270,  7)SP(271,225)\n    SP(272,140)SP(273, 36)SP(274,103)SP(275, 30)SP(276, 69)SP(277,142)SP(278,  8)SP(279, 99)\n    SP(280, 37)SP(281,240)SP(282, 21)SP(283, 10)SP(284, 23)SP(285,190)SP(286,  6)SP(287,148)\n    SP(288,247)SP(289,120)SP(290,234)SP(291, 75)SP(292,  0)SP(293, 26)SP(294,197)SP(295, 62)\n    SP(296, 94)SP(297,252)SP(298,219)SP(299,203)SP(300,117)SP(301, 35)SP(302, 11)SP(303, 32)\n    SP(304, 57)SP(305,177)SP(306, 33)SP(307, 88)SP(308,237)SP(309,149)SP(310, 56)SP(311, 87)\n    SP(312,174)SP(313, 20)SP(314,125)SP(315,136)SP(316,171)SP(317,168)SP(318, 68)SP(319,175)\n    SP(320, 74)SP(321,165)SP(322, 71)SP(323,134)SP(324,139)SP(325, 48)SP(326, 27)SP(327,166)\n    SP(328, 77)SP(329,146)SP(330,158)SP(331,231)SP(332, 83)SP(333,111)SP(334,229)SP(335,122)\n    SP(336, 60)SP(337,211)SP(338,133)SP(339,230)SP(340,220)SP(341,105)SP(342, 92)SP(343, 41)\n    SP(344, 55)SP(345, 46)SP(346,245)SP(347, 40)SP(348,244)SP(349,102)SP(350,143)SP(351, 54)\n    SP(352, 65)SP(353, 25)SP(354, 63)SP(355,161)SP(356,  1)SP(357,216)SP(358, 80)SP(359, 73)\n    SP(360,209)SP(361, 76)SP(362,132)SP(363,187)SP(364,208)SP(365, 89)SP(366, 18)SP(367,169)\n    SP(368,200)SP(369,196)SP(370,135)SP(371,130)SP(372,116)SP(373,188)SP(374,159)SP(375, 86)\n    SP(376,164)SP(377,100)SP(378,109)SP(379,198)SP(380,173)SP(381,186)SP(382,  3)SP(383, 64)\n    SP(384, 52)SP(385,217)SP(386,226)SP(387,250)SP(388,124)SP(389,123)SP(390,  5)SP(391,202)\n    SP(392, 38)SP(393,147)SP(394,118)SP(395,126)SP(396,255)SP(397, 82)SP(398, 85)SP(399,212)\n    SP(400,207)SP(401,206)SP(402, 59)SP(403,227)SP(404, 47)SP(405, 16)SP(406, 58)SP(407, 17)\n    SP(408,182)SP(409,189)SP(410, 28)SP(411, 42)SP(412,223)SP(413,183)SP(414,170)SP(415,213)\n    SP(416,119)SP(417,248)SP(418,152)SP(419,  2)SP(420, 44)SP(421,154)SP(422,163)SP(423, 70)\n    SP(424,221)SP(425,153)SP(426,101)SP(427,155)SP(428,167)SP(429, 43)SP(430,172)SP(431,  9)\n    SP(432,129)SP(433, 22)SP(434, 39)SP(435,253)SP(436, 19)SP(437, 98)SP(438,108)SP(439,110)\n    SP(440, 79)SP(441,113)SP(442,224)SP(443,232)SP(444,178)SP(445,185)SP(446,112)SP(447,104)\n    SP(448,218)SP(449,246)SP(450, 97)SP(451,228)SP(452,251)SP(453, 34)SP(454,242)SP(455,193)\n    SP(456,238)SP(457,210)SP(458,144)SP(459, 12)SP(460,191)SP(461,179)SP(462,162)SP(463,241)\n    SP(464, 81)SP(465, 51)SP(466,145)SP(467,235)SP(468,249)SP(469, 14)SP(470,239)SP(471,107)\n    SP(472, 49)SP(473,192)SP(474,214)SP(475, 31)SP(476,181)SP(477,199)SP(478,106)SP(479,157)\n    SP(480,184)SP(481, 84)SP(482,204)SP(483,176)SP(484,115)SP(485,121)SP(486, 50)SP(487, 45)\n    SP(488,127)SP(489,  4)SP(490,150)SP(491,254)SP(492,138)SP(493,236)SP(494,205)SP(495, 93)\n    SP(496,222)SP(497,114)SP(498, 67)SP(499, 29)SP(500, 24)SP(501, 72)SP(502,243)SP(503,141)\n    SP(504,128)SP(505,195)SP(506, 78)SP(507, 66)SP(508,215)SP(509, 61)SP(510,156)SP(511,180)\n    #undef SP\n}\n\n// lookup an entry in the permutation table\n// This function is required because of WebGL weirdness.\n// WebGL's GLSL doesn't allow indexing arrays with non-constant values EXCEPT for array indices\n// ... so I have to redundantly loop until I reach the right index. -_-\nint P(int i)\n{\n    for (int x = 0; x < 512; x++)\n    {\n        if (x == i)\n            return Ptab[x];\n    }\n    return 0;\n}\n\n// lookup table for gradients\nvec3 G(int i)\n{\n    if (i == 0x0) return vec3(+1,+1,+0);\n    if (i == 0x1) return vec3(-1,+1,+0);\n    if (i == 0x2) return vec3(+1,-1,+0);\n    if (i == 0x3) return vec3(-1,-1,+0);\n    if (i == 0x4) return vec3(+1,+0,+1);\n    if (i == 0x5) return vec3(-1,+0,+1);\n    if (i == 0x6) return vec3(+1,+0,-1);\n    if (i == 0x7) return vec3(-1,+0,-1);\n    if (i == 0x8) return vec3(+0,+1,+1);\n    if (i == 0x9) return vec3(+0,-1,+1);\n    if (i == 0xA) return vec3(+0,+1,-1);\n    if (i == 0xB) return vec3(+0,-1,-1);\n    if (i == 0xC) return vec3(+1,+1,+0);\n    if (i == 0xD) return vec3(-1,+1,+0);\n    if (i == 0xE) return vec3(+0,-1,+1);\n    if (i == 0xF) return vec3(+0,-1,-1);\n    return vec3(0,0,0);\n}\n\n// get [a,b,c,d] at point [x,y,z] of the lattice\n// [a,b,c,d] represents a linear equation:\n//  * [a,b,c] is the gradient (the slope of the linear equation)\n//  * d is the value of the linear equation (with slope [a,b,c]) at [x,y,z]\n// lattice_ip is the xyz coordinate of the integer lattice whose linear equation is being evaluated\n// sample_t is the fraction inside the lattice grid where to sample the linear equation\nvec4 H(ivec3 lattice_ip, vec3 sample_t)\n{\n    // the lattice repeats at every 256, so mod it.\n    // this prevents out-of-bounds access to the lattice pseudorandom values.\n    lattice_ip = imod3(lattice_ip, ivec3(256));\n    \n    // compute successive hashes to decorrelate indices\n    int i = P(P(P(lattice_ip.x) + lattice_ip.y) + lattice_ip.z);\n    // mod to prevent out-of-bounds access to gradient table\n    i = imod(i, 16);\n    \n    // grab a random gradient from the gradient table\n    vec3 g = G(i);\n    // compute dot product of gradient and fractional part of point\n    // this is the value of the linear equation with gradient [a,b,c] at this point\n    // (think of it as evaluating good old \"y = mx\", but m is the gradient and x is t)\n    float d = dot(g, sample_t);\n    \n    // combine the results and return them\n    return vec4(g, d);\n}\n\n\nfloat Noise(vec3 p)\n{     \n    // the noise function will be evaluated at the 8 corners of the integer lattice\n    // after evaluating it at the 8 corners, they will be interpolated at the current point.\n    // Here, the coordinates of the minimum and maximum corners of the current lattice grid region are computed\n    ivec3 minp = ivec3(floor(p));\n    ivec3 maxp = ivec3(ceil(p));\n    \n    // t is the fraction of the lattice for the current point\n    // the gradients at the corners of the lattice will be interpolated at this offset.\n    vec3 t = fract(p);\n    \n    // evaluate the lattice at all 8 corners\n    // the paramter \"t\" is inverted when evaluating at the opposite corner,\n    // since this makes the gradient interpolated towards the inside the lattice's cube\n    // this is important, since we're evaluating \"t\" to sample inside the cube.\n    vec4 h000 = H(ivec3(minp.x, minp.y, minp.z), t - vec3(0,0,0));\n    vec4 h001 = H(ivec3(minp.x, minp.y, maxp.z), t - vec3(0,0,1));\n    vec4 h010 = H(ivec3(minp.x, maxp.y, minp.z), t - vec3(0,1,0));\n    vec4 h011 = H(ivec3(minp.x, maxp.y, maxp.z), t - vec3(0,1,1));\n    vec4 h100 = H(ivec3(maxp.x, minp.y, minp.z), t - vec3(1,0,0));\n    vec4 h101 = H(ivec3(maxp.x, minp.y, maxp.z), t - vec3(1,0,1));\n    vec4 h110 = H(ivec3(maxp.x, maxp.y, minp.z), t - vec3(1,1,0));\n    vec4 h111 = H(ivec3(maxp.x, maxp.y, maxp.z), t - vec3(1,1,1));\n        \n    // rather than linear interpolation,\n    // the interpolation method is a degree 5 polynomial:\n    // 6 * t^5 - 15 * t^4 + 10 * t^3\n    // this ensures continuity at the vertices of the lattice.\n    t = 6.0*t*t*t*t*t - 15.0*t*t*t*t + 10.0*t*t*t;\n    \n    // Interpolate the lattice corners in X Y and Z\n    // First interpolate in x (flattening a cube into a square)\n    // then interpolate in y (flattening a square into a line)\n    // then interpolate in z (giving a single point)\n    float x00 = mix(h000.w, h100.w, t.x);\n    float x01 = mix(h001.w, h101.w, t.x);\n    float x10 = mix(h010.w, h110.w, t.x);\n    float x11 = mix(h011.w, h111.w, t.x);\n    float y0 = mix(x00, x10, t.y);\n    float y1 = mix(x01, x11, t.y);\n    float z = mix(y0, y1, t.z);\n    \n    return z;\n}\n\n#define OCTAVES 3\nfloat Fbm (vec3 p) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 1.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * Noise(p * frequency);\n        p *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize the permutation table\n    init_P();\n    \n    // determine sample position from inputs\n    vec3 p = vec3((fragCoord + iMouse.xy * vec2(1,10.0)) / ((iResolution.x-iMouse.x)/20.0), iTime);\n    \n    // compute the noise!\n    float noise = Fbm(p);\n    \n    noise = clamp((noise+1.0) / 2.0, 0.0, 1.0);\n    \n    // darken (for asthetic purposes)\n    // noise *= noise;\n    \n    // gamma correct\n    //noise = pow(noise, 1.0/2.2);\n    \n    // output color\n    fragColor = vec4(vec3(noise), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtd3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 57, 57, 81], [82, 82, 113, 113, 137], [248, 327, 342, 456, 6469], [6471, 6740, 6754, 6754, 6864], [6866, 6896, 6911, 6911, 7593], [7595, 8016, 8057, 8187, 8865], [8868, 8868, 8889, 9183, 11045], [11065, 11065, 11085, 11107, 11368], [11371, 11371, 11426, 11466, 11934]], "test": "valid"}
{"id": "XtdGD2", "name": "isinside() visualization", "author": "ollj", "description": "visualizing and analyzing a subroutine of \n//https://www.shadertoy.com/view/4s3GW2\njust because i wanted to know what exactly it does.\n\nspoiler: its just a special case of \"distance to square\" with bottom left vocorner as parameter.", "tags": ["square", "isinside"], "likes": 0, "viewed": 134, "published": "Public", "date": "1471721745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//just visualizing a subroutine of \n//https://www.shadertoy.com/view/4s3GW2\n\n//isInside returns distance to a square \n//with center offset by offsetXY=.5;\n//and with HalfSizeXY=.5;\nfloat isInside(vec2 p){\n //p.x*=2.;//scaling to rectangle\n float offsetXY=.0;\n vec2 d=abs(p-offsetXY)-.5;\n return-max(d.x,d.y);}\n//offsetXY and HalfSizeXY could easily be the same input parameter.\n\n//scaling for IsInside() may be fster if it takes a mat2 as input.\n\nvoid mainImage( out vec4 r, in vec2 i ){\n\tvec2 p =i.xy/iResolution.xy;\n    p.y*=iResolution.y/iResolution.x;\n    p*=4.;\n\tr = vec4(p,0.5+0.5*sin(iTime),1.0);\n    vec2 m=iMouse.xy/iResolution.xy;\n    m.y*=iResolution.y/iResolution.x;\n    m*=4.;\n    //if(length(p.xy-m.xy)<.5){\n\n    float delta=0.0;//this shows that its a gradient.\n    if (isInside(p-m)>delta)r*=.25;//inside is darker\n    //else r*=2.;//is outside, make brighter \n    //}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 181, 204, 238, 309], [379, 447, 487, 487, 886]], "test": "valid"}
{"id": "XtdGDf", "name": "WAVES", "author": "Imsure1200q_1UWE130", "description": "more like fir", "tags": ["waves"], "likes": 1, "viewed": 457, "published": "Public API", "date": "1472127126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(0.)*2.;\nvec3 b( vec2 p, float s )\n{\n    vec2 x = smoothstep(vec2(s), p/2.0, p/5.0);\n    vec3 q = normalize(vec3(x, 1.0));\n    vec3 i = vec3(x, q.z/q.x);\n    float k = length(sqrt(s));\n    return abs(sin(q-i*k)) - clamp(q.x, q.z, s/k);\n}\nvec2 i( vec2 p, float s, float s2 )\n{\n    float x = smoothstep(float(p), s, s2/s);\n    vec2 q = p / x * distance(s, s2);\n    vec3 pos = b(p, s);\n    float pSep = max(min(pos.x, pos.z), min(pos.y, pos.z));\n    return q + pSep * -(iTime / 2.0) / pos.xy;\n}\nfloat s( float u ) {\n    \n    float sum = 0.;\n    \n    for( float i = 1.; i < u; i++) {\n        \n        sum += 1. / pow(float(2.), float(i));\n        \n    }\n    \n    return sum;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if(uv.y >= 0.3/length(texture(iChannel0, i(uv, 2.0, 3.0)))){\n        fragColor = vec4(cos(uv.y)) + vec4(-0.025, 0.025, 0.6, 0.5) - vec4(0.8);\n        fragColor += texture(iChannel1, vec2(uv.x * 1.01 - (iTime / 60.0), uv.y* 5.0) )  - 0.8 + 0.4;\n    }\n    else fragColor = vec4(sin(uv.y)) + vec4(0.9, 0.5, 0.025, 0.5) - vec4(0.1) + sin(iTime)/32. + 1./32.;\n    \n    fragColor *= sin(min(iTime/2.,pi/2.));\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 51, 51, 252], [253, 253, 290, 290, 506], [507, 507, 527, 527, 692], [693, 693, 750, 750, 1201]], "test": "error"}
{"id": "XtdGzB", "name": "little bubble", "author": "w450468524", "description": "maybe it's like a floating bubble.", "tags": ["2d", "ellipse"], "likes": 4, "viewed": 616, "published": "Public API", "date": "1470108041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float size = 0.2;\nconst float a = 1.5*size;\nconst float b = 1.5*size;\nconst float PI = 3.1415926;\nconst float bold = 0.3;\n\n// copy from https://www.shadertoy.com/view/4sc3z2\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 fColor = vec4(1.0, 0.5,0.5, 1.0);\n    vec4 bColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 volocity = vec2(0.0, 0.1);\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 center = vec2(0.5, 0.5);\n    \n\tvec2 pos = uv.xy - center.xy;\n    float angle = atan(uv.x, uv.y)*1.5;\n\t//angle = (angle + PI)/2.0*PI;\n    pos/= vec2(a, b);\n    fragColor = mix(fColor, bColor, smoothstep(-bold, bold, abs(dot(pos, pos) - 1.0 - perlin_noise(vec3(angle,angle, iTime))*0.5)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 220, 242, 242, 394], [395, 395, 423, 423, 1362], [1364, 1364, 1421, 1421, 1888]], "test": "valid"}
{"id": "Xtt3DB", "name": "016 simple path tracing", "author": "kakaxizhhgjh", "description": "original:\nhttps://www.shadertoy.com/view/4ljGRd\nhttps://www.shadertoy.com/view/llBGz1\n", "tags": ["intersection"], "likes": 5, "viewed": 298, "published": "Public", "date": "1471374429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Light  \t{ vec3 d; vec3 c; };\nstruct Ray \t  \t{ vec3 o; vec3 d; };\nstruct Hit\t\t{ float t; vec3 n; vec3 diff; };\nstruct Sphere \t{ float r; vec3 p; vec3 diff; };\nstruct Plane\t{ float d; vec3 n; vec3 diff; };\n\nconst int \tITER  = 4;\nconst float EPS   = 1e-3;\nconst float TMAX  = 1e3;\nconst Hit \tMISS  = Hit(TMAX, vec3(0), vec3(0));\nconst Light light = Light(normalize(vec3(1)), vec3(1));\n\nHit intersectPlane(Ray r, Plane p) {\n\tfloat k = dot(p.n, r.d);\n    if(k >= 0.0) return MISS;\n    return Hit(-(p.d + dot(p.n, r.o)) / k, p.n, p.diff);\n}\n\nHit intersectSphere(Ray r, Sphere s) {\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if(det < 0.0) return MISS;\n    det = sqrt(det);\n    float t = b - det;\n    if(t < 0.0) t = b + det;\n    if(t < 0.0) return MISS;\n    return Hit(t, (r.o + t * r.d - s.p) / s.r, s.diff);\n}\n\nHit intersect(Ray r) {\n\tSphere spheres[3];\n    spheres[0] = Sphere(2.0, vec3(-4, 3.0 + sin(iTime), 0), vec3(1, 0, 0));\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3, 0), vec3(0, 1, 0));\n    spheres[2] = Sphere(1.0, vec3( 0, 1, 4), \t\t\t\t\t  vec3(0, 0, 1));\n    \n    Hit hit = MISS;\n    Hit tmp = intersectPlane(r, Plane(0.0, vec3(0, 1, 0), vec3(1)));\n    if(tmp.t < hit.t) hit = tmp;\n    for(int i = 0; i < 3; ++i) {\n    \ttmp = intersectSphere(r, spheres[i]);\n        if(tmp.t < hit.t) hit = tmp;\n    }\n    return hit;\n}\n\nvec3 schlick(vec3 n, vec3 v, vec3 f0) {\n\treturn pow(1.0 - dot(n, v), 5.0) * (1.0 - f0) + f0;\n}\n\nvec3 shadow(vec3 p, vec3 n) {\n    if(intersect(Ray(p + EPS * light.d, light.d)).t == TMAX) {\n    \treturn max(dot(n, light.d), 0.0) * light.c;\n    }\n    return vec3(0);\n}\n\nvec3 radiance(Ray r) {\n\tvec3 color = vec3(0);\n    vec3 beta = vec3(1);\n    \n    for(int i = 0; i < ITER; ++i) {\n    \tHit hit = intersect(r);\n        if(hit.t < TMAX) {\n        \tvec3 fresnel = schlick(hit.n, -r.d, vec3(0.01));\n            vec3 pos = r.o + hit.t * r.d;\n            color += beta * (1.0 - fresnel) * hit.diff * shadow(pos, hit.n);\n            beta *= fresnel;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(pos + EPS * d, d);\n        } else {\n        \tcolor += beta * vec3(1);\n            break;\n        }\n    }\n    \n    return color;\n}\n\nmat3 getCamera(vec3 eye, vec3 target) {\n    vec3 z = normalize(eye - target);\n\tvec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    return mat3(x, cross(z, x), z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.y * 5.0;\n    \n    float ox = 0.25 / iResolution.y;\n    float oy = 0.75 / iResolution.y;\n    vec2 msaa[4];\n    msaa[0] = vec2(-ox, -oy);\n    msaa[1] = vec2( ox, -oy);\n    msaa[2] = vec2(-ox,  oy);\n    msaa[3] = vec2( ox,  oy);\n    \n    vec3 color = vec3(0);\n    vec3 ro = vec3(14.0 * sin(mo.x), 2.0 + 2.0 * sin(mo.y), 14.0 * cos(mo.x));\n    mat3 camera = getCamera(ro, vec3(0, 1.5, 0));\n    for(int i = 0; i < 4; ++i) {\n    \tvec3 rd = camera * normalize(vec3(uv, -2) + vec3(msaa[i], 0));\n        color += radiance(Ray(ro, rd));\n    }\n    \n\tfragColor = vec4(pow(color / 4.0, vec3(0.45)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtt3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 426, 426, 541], [543, 543, 581, 581, 871], [873, 873, 895, 895, 1399], [1401, 1401, 1440, 1440, 1495], [1497, 1497, 1526, 1526, 1666], [1668, 1668, 1690, 1690, 2233], [2235, 2235, 2274, 2274, 2402], [2404, 2404, 2459, 2459, 3154]], "test": "error"}
{"id": "Xtt3WB", "name": " Swizzle Glitches in Edge", "author": "TimoKinnunen", "description": "Debugging and visualizing some glitches in latest (2016-08-16) Microsoft Edge 39.14901.1000.0", "tags": ["glitch", "edge", "error", "microsoft", "swizzle"], "likes": 2, "viewed": 641, "published": "Public API", "date": "1471353140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////\n// Swizzle Glitches in Edge\n//\n// It seems that swizzling in a particular way causes \n// another variable's value to change, mirroring the \n// scene. With some jiggling of order of calculations,\n// the boxes in the scene can be made to appear at the\n// wrong and the correct positions \"at the same time\".\n//\n//\n//\n// Uncomment NO_GLITCH for how it should look like.\n//\n//\n// Based on SDF shape blending by tiusic:\n// https://www.shadertoy.com/view/ll3GDS\n\n\n//#define NO_GLITCH\n\n\nfloat intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\nvec3 intersectionColor = vec3(1, 0, 1);\n\nvec3 colorA = vec3(0, 1, 0);\nvec3 colorB = vec3(0, 0, 1);\n\nvec4 blend(float a, float b, float m) {\n    return vec4(min(min(a, b), a * b - m), (a * colorA + b * colorB) / (a + b));\n}\n\nfloat dSphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat dBox(vec3 p, vec3 c, vec3 dimensions, mat3 rot) {\n\tvec3 d = abs((p - c) * rot) - dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvoid test(inout vec2 distMat, float newDist, int newMat) {\n    if (newDist < distMat.x) {\n        distMat = vec2(newDist, float(newMat));\n    }\n}\n\n#ifdef NO_GLITCH\nvec4 sp = vec4(0);\nvec4 sc1 = vec4(0);\n#endif\n\nfloat shapeSpacing;\nvec2 boxRotor;\nmat3 boxRotation;\nmat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\nvec4 dc = vec4(0);\nvec4 d(vec3 p) {\n    bool first = true;\n    vec4 mindd;\n    for (float i = 0.0; i <= 1.01; i += 0.1) {\n        vec3 c0 = vec3(30.0 * i, 10, shapeSpacing);\n        vec3 c1 = vec3(30.0 * i, 10, -shapeSpacing);\n\n#ifdef NO_GLITCH\n        sp.xzy=p;\n        sc1.xzy=c1;\n        dc += sp-sc1;\n#else\n        dc.x += p.x;\n        dc.x -= c1.x;\n        dc.y += (p - c1).z;\n        dc.z += (p - c1).y;\n#endif\n        vec3 pRot21 = (p - c1);\n        vec3 pRot212 = vec3(p.xyz - c1.xyz);\n        vec3 pRot22;\n        if(floor(mod(gl_FragCoord.x, 20.0)/10.0)==0.0){\n#ifdef NO_GLITCH\n            pRot22 = pRot21.xzy;\n            pRot22.yz *= rot2(iTime);\n            pRot22 = pRot22.xzy;\n#else\n            pRot22 = vec3(pRot21.x, (pRot212.zy * (rot2(iTime)))).xzy;\n#endif\n        } else {\n            pRot22 = vec3(dc.x, (pRot212.zy * (rot2(iTime)))).xzy;\n        }\n        dc.rgb += max(vec3(0),floor(sign(pRot22)-1.0));\n        vec3 pRot = pRot22 + c1;\n        vec4 dd = blend(dSphere(p, c0, 1.0), dBox(pRot, c1, vec3(1.0), mat3(1)), i); \n        //vec4 dd = blend(dSphere(p, c0, 1.0), dBox(p, c1, vec3(1.0, 1.0, 1.0), boxRotation), i);// Original rotation\n        if (first || dd.x < mindd.x) {\n            mindd = dd;\n        }\n        first = false;\n        vec3 pRot30 = p;\n        vec3 pRot31 = (p - c1);\n#ifdef NO_GLITCH\n        dc -= sp-sc1;\n#else\n        dc.x -= p.x;\n        dc.z -= vec3(pRot31).y;\n        dc.y -= vec3(pRot31).z;\n        dc.x += c1.x;\n#endif\n        \n    }\n    return mindd;\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    d(pos+eps.xyy).x - d(pos-eps.xyy).x,\n\t    d(pos+eps.yxy).x - d(pos-eps.yxy).x,\n\t    d(pos+eps.yyx).x - d(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n#define MAX_STEPS 100\n#define MARCH_EPSILON .001\n#define MAX_T 1000.\n\nvoid IntersectScene(vec3 origin, vec3 direction) {\n    float t = 0.;\n    for (int ii = 0; ii < MAX_STEPS; ++ii) {\n        vec3 pos = origin + direction * t;\n        vec4 dd = d(pos);\n        if (dd.x < MARCH_EPSILON) {\n            if (t < MAX_T) {\n\t\t\t\tintersectionNormal = calcNormal(pos);\n            \tintersectionPoint = pos;\n                intersectionT = t;\n                intersectionColor = dd.yzw;\n            }\n            break;\n        }\n        t += dd.x;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tshapeSpacing = 3.0 * sin(0.1 * iTime);\n\tboxRotor = vec2(cos(iTime), sin(iTime));\n\tboxRotation = mat3(1, 0, 0, 0, boxRotor.x, -boxRotor.y, 0, boxRotor.y, boxRotor.x);    \n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\tvec3 origin = vec3(15.0, -15.0, 0.0);\n\tvec3 direction = vec3(uv.x, 1, uv.y);\n\tdirection.xz *= .8;\n\tdirection = normalize(direction);\n\tvec3 color = vec3(0);\n    intersectionT = 1e37;\n    IntersectScene(origin, direction);\n    if (intersectionT < MAX_T) {\n        float lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n        if (lightDot > 0.0) {\n        \tcolor = mix(intersectionColor, vec3(1, 1, 1), 0.3 * lightDot);\n        } else {\n        \tcolor = mix(intersectionColor, vec3(0, 0, 0), -lightDot);\n        }\n    }\n    if(floor(mod(gl_FragCoord.y, 2.0))==0.0) {\n        color=mix(color,clamp(dc.rgb*0.5,0.0,1.0),0.5+0.5*sin(iTime*2.0));\n    }\n\tfragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtt3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 707, 746, 746, 829], [831, 831, 871, 871, 903], [905, 905, 960, 960, 1066], [1068, 1068, 1126, 1126, 1213], [1332, 1332, 1351, 1351, 1398], [1418, 1418, 1434, 1434, 2908], [2910, 2910, 2940, 2940, 3148], [3220, 3220, 3270, 3270, 3696], [3698, 3698, 3753, 3753, 4763]], "test": "valid"}
{"id": "Xtt3WS", "name": "stripes", "author": "nshelton", "description": "slow raymarch sphere sketch", "tags": ["3d", "raymarch", "sphere", "stripes", "slow"], "likes": 4, "viewed": 208, "published": "Public", "date": "1471303163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n \n\n\nvec3 sph2cart(float r, float theta, float phi)\n{\n   return  vec3(r * cos(theta) * sin(phi),\n         r * sin(theta) * sin(phi),\t\n         r * cos(phi));\n}\n\n\nfloat sph(float rad, vec3 center, vec3 p)\n{\n    return length(p - center) - rad;   \n}\n\nfloat DE(vec3 p) \n{\n  float theta = 30.0; 2.4;\n  float phi = 100.0; // 2.4;// + iTime;\n\n   float mind = sph(1.0, vec3(0.0), p);\n    \n   for(int i = 0; i < 40; i ++)\n   {\n       theta += 0.1;\n       phi += iTime/20.;\n       \n     mind = min(mind,  sph(0.001 * pow(float(i/2 ), 2.0), sph2cart(1.0, theta, phi), p) );\n   }\n    return mind;\n}\n    \nvec3 grad(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.0);\n    \n \treturn normalize(vec3( DE(p + e.xyy) - DE(p - e.xyy), \n                          DE(p + e.yxy) - DE(p - e.yxy), \n                          DE(p + e.yyx) - DE(p - e.yyx)));\n    \n    \n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uv_n = 2.5 * (uv - 0.5) * vec2(1.0, iResolution.y / iResolution.x) ; \n        \n    vec3 cam = vec3(0.0, 0.0, -2);\n    \n    vec3 ray = normalize(vec3( uv_n, 1.0));\n    float t = 0.0;\n    float d = 0.0;\n    vec3 p = cam;\n    float iter = 0.0;\n    bool hit = false;\n    \n    for ( int i = 0; i < 20; i ++) \n    {\n        p = t * ray + cam;\n\t\n\t\td = DE(p);\n        \n        if ( d < 0.01) {\n        \thit = true;\n            break;\n\n        }\n        \n        t += d;\n        iter++;\n        \n    }\n       \t\tvec3 normal = grad(p );\n\n    float st;\n    \n    vec3 color = vec3(1.0);\n    if (!hit){\n        iter = 0.5;\n        st = 1.0;\n    }\n    else\n    {\n   \t\tst =  fract((p.y + p.x + snoise(p)/3.0 - iTime/10.0 ) * 6. ) < 0.5? 0.0 : 1.0;\n        float thickness = sin(p.x * 10.) / 10.0 + 0.2;\n        \n        \n    \t//st = abs(sin(10. * (p.y + p.x )));\n        \n        //st = snoise(p * 4.0 + iTime);\n         \n\t    float shade = 1.0;// abs(dot(ray, normal));\n        \n        color = vec3(st) * shade;\n\n    }\n    \n\n\tfragColor = vec4(color , 1.0);\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtt3WS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1, 451, 472, 472, 521], [523, 523, 544, 544, 593], [595, 595, 617, 617, 657], [659, 659, 687, 687, 739], [741, 741, 765, 765, 2911], [2916, 2916, 2964, 2964, 3070], [3073, 3073, 3116, 3116, 3158], [3160, 3160, 3179, 3179, 3498], [3504, 3504, 3523, 3523, 3744], [3751, 3751, 3808, 3808, 4924]], "test": "valid"}
{"id": "Xtt3WX", "name": "Barycentric Coordinates v1", "author": "sea", "description": "Very un-optimized method of finding barycentric coordinates of a triangle. Tips are welcome.", "tags": ["barycentriccoordinatestriangle"], "likes": 3, "viewed": 378, "published": "Public", "date": "1472082448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// Rotate point.\nvec2 rotate (vec2 p, float r)\n{\n    r *= PI / 180.0;\n    float x = p.x * cos(r) - p.y * sin(r);\n    float y = p.y * cos(r) + p.x * sin(r);\n    return vec2(x, y);\n}\n\n// Draw point\nbool point (vec2 a, vec2 p)\n{\n    return length(a - p) < 0.01;\n}\n\n// Draw line from a to b.\nbool line (vec2 a, vec2 b, vec2 p)\n{\n    vec2 c = b - a;\n    c = normalize(vec2(c.y, -c.x));\n    return abs(dot(c, a - p)) < 0.002;\n}\n\n// Find intersection between vectors a and b by projecting a onto b.\nvec2 projection (vec2 a, vec2 b)\n{\n    b = normalize(b);\n    return b * (b.x * a.x + b.y * a.y);\n}\n\nbool tri (vec2 a, vec2 b, vec2 c, vec2 p, out vec3 color)\n{\n    vec2 ab = b - a;\n    vec2 cb = b - c;\n    vec2 ca = a - c;\n    vec2 ac = c - a;\n    vec2 ba = a - b;\n    vec2 bc = c - b;\n    \n    // Projection of a onto c -> b\n    vec2 ai = c + projection(ca, cb);\n    \n    // Projection of test point onto ai -> a\n    vec2 pai = a + projection(p - ai, a - ai);\n    \n    float percentA = length(pai - a) / length(ai - a) * sign(dot(p - ai, a - ai));\n    \n    // Projection of b onto c -> b\n    vec2 bi = a + projection(ab, ac);\n    \n    // Projection of test point onto bi -> b\n    vec2 pbi = b + projection(p - bi, b - bi);\n    \n    float percentB = length(pbi - b) / length(bi - b) * sign(dot(p - bi, b - bi));\n    \n    // Projection of b onto c -> b\n    vec2 ci = b + projection(bc, ba);\n    \n    // Projection of test point onto ci -> c\n    vec2 pci = c + projection(p - ci, c - ci);\n    \n    float percentC = length(pci - c) / length(ci - c) * sign(dot(p - ci, c - ci));\n    \n    color = vec3(percentA, percentB, percentC);\n    \n    if (percentA > 0.0 && percentA < 1.0 && percentB > 0.0 && percentB < 1.0 && percentC > 0.0 && percentC < 1.0)\n        return true;\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ws = uv.xy * 2.0 - 1.0;\n    ws.y /= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    vec2 a = vec2(0.0, 0.25);\n    vec2 b = vec2(0.25, -0.25);\n    vec2 c = vec2(-0.25, -0.25);\n    \n    vec3 triUV;\n    if (tri(a, b, c, rotate(ws, iTime * 10.0), triUV))\n        color = triUV;\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtt3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 43, 74, 74, 206], [208, 222, 251, 251, 286], [288, 314, 350, 350, 447], [449, 518, 552, 552, 616], [618, 618, 677, 677, 1810], [1812, 1812, 1869, 1869, 2256]], "test": "valid"}
{"id": "XttGzj", "name": "Museum of random planets", "author": "LukeRissacher", "description": "Partly inspired by \"reactive sphere\" by glk7: https://www.shadertoy.com/view/XlfXzM", "tags": ["procedural", "raymarching", "random", "planets"], "likes": 37, "viewed": 724, "published": "Public", "date": "1470294088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MAX_DEPTH = 3.0;\nconst float START_PLANET = 18.0;\n\nvec2 Rotate(vec2 pos, float angle) {\n\treturn vec2(\n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n    );\n}\n\nfloat Cubic(float a, float b, float t) {\n    float blendFactor = t * t * (3.0 - 2.0 * t);\n    return mix(a, b, blendFactor);\n}\n\nvec3 HueToRgb(float h) {\n    vec3 rgb = 2.0 - abs(6.0 * h - vec3(3, 2, 4));\n    rgb.r = 1.0 - rgb.r;\n    return clamp(rgb, 0.0, 1.0);\n}\n\nvec3 HsvToRgb(vec3 hsv) {\n    vec3 rgb = HueToRgb(hsv.x);\n    return ((rgb - 1.0) * hsv.y + 1.0) * hsv.z;\n}\n\n// Gradient noise functions courtesy Inigo Q\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat Rand(vec2 pos) {\n    return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Rand(float pos) {\n    return Rand(vec2(pos));\n}\n\nfloat SphereDistance(vec3 localPos, float radius) {\n\treturn length(localPos) - radius;\n}\n\nfloat SceneDistance(vec3 pos, out float layer) {\n    if (pos.x < 0.0) {\n        return 1.0;\n    }\n    \n    float planetNumber = floor((pos.x) / 2.0) + START_PLANET;\n    \n    vec3 planetPos = pos;\n    planetPos.x = mod(planetPos.x, 2.0) - 1.0;\n    float rotationSpeed = mix(-1.0, 1.0, fract(planetNumber / 2.3));\n    planetPos.xz = Rotate(planetPos.xz, rotationSpeed * iTime);\n    \n    float terrainDetail = mix(0.1, 5.5, Rand(planetNumber + 0.16));\n    float layerHeight = mix(0.005, 0.05, Rand(planetNumber + 0.55));\n    float layerCount = floor(mix(3.5, 20.5, Rand(planetNumber + 0.36)));\n    float noiseValue = 0.5 * noise((normalize(planetPos) + planetNumber) * terrainDetail) + 0.5;\n    layer = floor(noiseValue * layerCount);\n\t\n\tfloat baseSize = mix(0.2, 0.4, Rand(planetNumber + 0.28));\n    float d1 = SphereDistance(planetPos, baseSize + (layer - 1.0) * layerHeight);\n    float d2 = SphereDistance(planetPos, baseSize + layer * layerHeight);\n    \n    float layerTransition = smoothstep(0.0, 0.3, fract(noiseValue * layerCount) + 0.06);\n    return mix(d1, d2, layerTransition);\n}\n\nfloat SceneDistance(vec3 pos) {\n    float dummy;\n    return SceneDistance(pos, dummy);\n}\n\nfloat RayMarch(vec3 startPos, vec3 dir) {\n\tfloat depth = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 pos = startPos + dir * depth;\n        float dist = SceneDistance(pos);\n        if (dist < 0.0001) {\n        \treturn depth;\n        }\n        depth += 0.6 * dist;\n        if (depth >= MAX_DEPTH) {\n            return MAX_DEPTH;\n        }\n    }\n    return MAX_DEPTH;\n}\n\nvec3 SceneNormal(vec3 pos) {\n\tconst float DX = 0.004;\n\tconst vec3 dx = vec3(DX, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, DX, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, DX);\n    return normalize(vec3(\n        SceneDistance(pos + dx) - SceneDistance(pos - dx),\n        SceneDistance(pos + dy) - SceneDistance(pos - dy),\n        SceneDistance(pos + dz) - SceneDistance(pos - dz)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float FOV = radians(45.0);\n    vec3 eyePos = vec3(0.5 * iTime - 1.0, 0.0, -2.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) * 0.5;\n    vec3 rayDir = normalize(vec3(xy, 1.0 / tan(0.5 * FOV) * 0.5 * iResolution.y));\n    vec3 lightDir = normalize(vec3(0.5, 0.8, -1.0));\n   \n    float depth = RayMarch(eyePos, rayDir);\n    if (depth < MAX_DEPTH) {\n        \n        vec3 pos = eyePos + rayDir * depth;\n        float layer;\n        vec3 normal = SceneNormal(pos);\n        SceneDistance(pos, layer);\n        \n        float planetNumber = floor((pos.x) / 2.0) + START_PLANET;\n        \n        float baseHue = Rand(planetNumber + 1.72);\n        float hueStep = mix(0.02, 0.15, pow(Rand(planetNumber + 0.492), 2.0));\n        \n        float baseSat = pow(Rand(planetNumber + 0.195), 0.2);\n        float satStep = mix(-0.2, 0.2, Rand(planetNumber + 0.777));\n        \n        float baseVal = mix(0.5, 1.0, pow(Rand(planetNumber + 0.888), 0.3));\n        float valStep = mix(0.0, 0.2, Rand(planetNumber + 0.992));\n        \n        vec3 color = HsvToRgb(\n            vec3(fract(baseHue + layer * hueStep), \n\t             clamp(baseSat + layer * satStep, 0.0, 1.0), \n                 0.3 + 0.7 * fract(baseVal + layer * valStep)));\n        float diffuse = 2.0 * clamp(dot(lightDir, normal), 0.0, 1.0);\n    \tfragColor = vec4(diffuse * color, 1.0);\n    }\n    else {\n        float gradient = abs(2.0 * (fragCoord.y / iResolution.y) - 1.0);\n        vec3 skyColor = HsvToRgb(vec3(fract(0.015 * iTime) + 0.5, 1.0, 0.1 * gradient));\n        fragColor = vec4(skyColor, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 99, 99, 219], [221, 221, 261, 261, 347], [349, 349, 373, 373, 484], [486, 486, 511, 511, 593], [595, 640, 661, 661, 830], [831, 831, 857, 857, 1682], [1684, 1684, 1706, 1706, 1780], [1782, 1782, 1805, 1805, 1835], [1837, 1837, 1888, 1888, 1925], [1927, 1927, 1975, 1975, 3013], [3015, 3015, 3046, 3046, 3103], [3105, 3105, 3146, 3146, 3480], [3482, 3482, 3510, 3510, 3865], [3867, 3867, 3924, 3924, 5495]], "test": "valid"}
