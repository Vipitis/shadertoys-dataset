{"id": "3dBBWt", "name": "Doodling w/ ThronoCrigger #2", "author": "Flopine", "description": "This is the second part of a 30 minutes concert for which I made live coded visuals. \nThanks to 0r4 for the invitation and ThronoCrigger for his trust :D I had a lot of fun", "tags": ["2d", "animation", "spaceship", "chiptune"], "likes": 5, "viewed": 88, "published": "Public", "date": "1591046016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853071\n#define triratio vec2(1.,.5)\n\n#define BPM (150./60.)\n#define ft(speed) fract(iTime*speed)\n#define loopease(speed) easeInOutCirc(abs(-1.+2.*ft(speed)))\n#define switchanim(speed) (floor(sin(ft(speed)*TAU))+1.)\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.03,fwidth(val-thre)))\n#define circle(s,puv) AAstep(s, length(puv))\n#define line(s,puv1) AAstep(s, abs(puv1))\n#define triY(s,puv) AAstep(s, max(-uv.y,dot(abs(puv),triratio)))\n#define xor(a,b) ((1.-b)*a + (1.-a)*b)\n\n/////////////////////// Tools ////////////////////\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = atan(p.y,p.x);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat easeInOutCirc (float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - (2. * x) * (2. * x))) / 2.\n        : (sqrt(1. - (-2. * x + 2.) * (-2. * x + 2.)) + 1.) / 2.;\n}\n\n/////////////////////// 2D  //////////////////////\nvec3 spaceship (vec2 uv)\n{\n    uv *= rot(PI/4.);\n    float per = 0.3;\n    vec2 uu = uv;\n    vec2 us = uv;\n    us.x += -.25+loopease(BPM/8.)*.5;\n    float mask = triY(0.2,us);\n\n    vec2 us2 = vec2(abs(us.x)-.2,us.y);\n    mask = xor(mask,triY(0.1,(us2)));\n\n    uv.y -= 1.5*ft(BPM/2.);\n    float udx = abs(uv.x)-1.;\n    float udyid = floor(uv.y/per);\n    float udy = mod(uv.y,per)-per*.5;\n    vec2 ud = vec2(udx,udy);\n    float l = line(0.1,ud.x);\n    ud.x += sin(udyid+ft(1.)*TAU)*.2;\n    mask = xor(mask,xor(circle(0.08,ud),l));\n\n    uv = uu;\n    uv *= rot(sin(loopease(BPM/8.)*.5));\n    mo(uv,vec2(.5));\n    uv.x -= 0.3;\n    moda(uv,5.);\n    mask = xor(mask, line(0.1, uv.y));\n\n    vec3 col = (mask <= 0.) ? vec3(0.4,0.8,.6) : vec3(.01,0.0,0.08);\n    return col;\n}\n\n/////////////////////// Main  ////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    if (switchanim(BPM/8.)<=0.)mo(uv,vec2(.5));\n\n    vec3 col = spaceship(uv);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBBWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[847, 898, 918, 918, 961], [963, 963, 995, 995, 1042], [1044, 1044, 1081, 1081, 1204], [1206, 1206, 1237, 1237, 1377], [1379, 1430, 1456, 1456, 2194], [2196, 2247, 2304, 2304, 2486]], "test": "timeout"}
{"id": "3djBDh", "name": "Packed Spheres SDF", "author": "blackle", "description": "a rhombic dodecahedral honeycomb domain repetition!", "tags": ["sdf", "packedspheres", "spherepacking"], "likes": 32, "viewed": 590, "published": "Public API", "date": "1592585490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//the following functions assume that p is inside the cube of radius 1 centered at the origin\n//closest vertex of the cube to p\nvec3 vertex(vec3 p) {\n    return max(sign(p),vec3(0))*2.-1.;\n}\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(sign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,sign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n//closest edge of the cube to p\nvec3 edge(vec3 p) {\n    vec3 mask = vec3(1)-abs(face(p));\n    vec3 v = vertex(p);\n    vec3 a = v*mask.zxy, b = v*mask.yzx;\n    return distance(p,a)<distance(p,b)?a:b;\n}\n\nfloat hills(vec3 p) {\n    return sin(2.*dot(sin(p.xy/16.), cos(p.xy/4.)))*3.;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\n//rhombic dodecahedron SDF with rounded corners\nfloat rho_dod(vec3 p)\n{\n    float offset = 0.1;\n    float radius = .9;\n    p = sqrt(p*p+offset*offset/2.);\n    p = (p+p.yzx)-radius;\n    return super(max(p,0.))+min(0.,max(p.x,max(p.y,p.z)))-offset;\n}\n\nfloat spheres(vec3 p, out vec3 id, out vec3 loc, float density) {\n    vec3 op = p;\n    id = floor(p)+.5;\n    vec3 d = face(p-id);\n    vec3 m = sign(mod(id,2.)-1.);\n    if (m.x*m.y*m.z<0.) id += d;\n    if (id.z + hills(id) > -5.) { //if this ball is absent, get the distance to its neighbour\n        vec3 e = edge(p-id);\n        id += e;\n    }\n    p -= id;\n    float rad = 0.7;\n    float sph = mix(rho_dod(p), length(p)-.7, smoothstep(-.2,.2,cos(iTime)));\n    loc = p;\n    return max((op.z+3.5+hills(op))/2.,sph);\n}\n\nfloat scene(vec3 p) {\n    vec3 id,loc;\n    float s1 = spheres(p, id, loc, 0.4);\n    return s1;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 skycol(vec3 p) {\n    float dt = dot(p,normalize(vec3(1)));\n    float sun = pow(max(dt,0.),10.);\n    return vec3(sun) + .2+dt*.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 samplepos = erot(vec3(-10,0,0), vec3(0,0,1), iTime*.2);\n    vec3 init = vec3(-20.,0,0);\n    \n    float yrot = 0.6+sin(iTime/5.)*.4;\n    float zrot = iTime/4.;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    for (int i = 0; i < 250 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>50.) break;\n    }\n    float fog = smoothstep(5.,50.,distance(p,init));\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ao = smoothstep(-6.5,-4.8,p.z + hills(p))*smoothstep(-.3,.2,scene(p+n*.2)); //fake \"ao\" based on sphere's depth in the stack\n    float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n    float spec = length(sin(r*vec3(1.,2.,2.5))*0.5+0.5)/sqrt(3.);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n\n    \n    vec3 col = vec3(.1)*diff*ao + pow(spec,10.)*frens*2.*ao;\n    vec3 bg = skycol(cam);\n    fragColor.xyz = (hit ? mix(col,bg,fog) : bg);\n    fragColor.xyz = smoothstep(vec3(-0.1),vec3(1),sqrt(fragColor.xyz))*smoothstep(2.,.5,length(uv));\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djBDh.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 424, 445, 445, 486], [487, 519, 538, 538, 762], [763, 795, 814, 814, 963], [965, 965, 986, 986, 1044], [1046, 1046, 1067, 1067, 1099], [1101, 1149, 1172, 1172, 1349], [1351, 1351, 1416, 1416, 1865], [1867, 1867, 1888, 1888, 1963], [1965, 1965, 1984, 1984, 2100], [2102, 2102, 2123, 2123, 2237], [2239, 2239, 2296, 2296, 3779]], "test": "timeout"}
{"id": "3djfDc", "name": "Starfield_", "author": "kotfind", "description": "Most ideas were taken from here: https://www.youtube.com/watch?v=dhuigO4A7RY&t=272s", "tags": ["star", "space", "stars", "starfield"], "likes": 14, "viewed": 433, "published": "Public API", "date": "1591040230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LAYERS 7.\n\nfloat rand(in vec2 p) {\n    return fract(sin(p.x * 317. + p.y * 137.) * 132.);\n}\n\nfloat star(in vec2 uv, in float rays) {\n\tfloat d = length(uv);\n    float m = .1/d;\n    \n    m += 1./exp(100. * abs(uv.x * uv.y)) * rays;\n    \n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\nvec3 starLayer(in vec2 uv) {\n\tfloat T = iTime * 1.8;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n   \tvec3 col = vec3(0.);\n\n    for (float y = -1.; y <= 1.; ++y) {\n        for (float x = -1.; x <= 1.; ++x) {\n            vec2 offs = vec2(x, y);\n            float r = rand(id + offs);\n            float size = max(0.3, fract(r * 127.));\n            float rays = exp((size - 1.) * 50.) * 2.;\n            float blink = sin(T * r) * 0.5 + 0.5;\n            vec3 c = 2. * normalize(vec3(0.8, 0.4, 0.9)) * fract(vec3(r * 123., r * 987., r * 567.));\n            col += blink * c * size * star(gv - offs - vec2(r, fract(r * 275.)) + .5, rays);\n        }\n    }\n    \n    return col;\n}\n\nmat2 rot(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float t = iTime*.08;\n    uv *= rot(t);\n    for (float i = 0.; i < 1.; i += 1./NUM_LAYERS) {\n        float depth = fract(i + t);\n        float scale = mix(20., 2., depth);\n        float fade = depth * smoothstep(1., .9, depth);\n    \tcol += fade * starLayer(uv * scale + 323. * i);\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 103], [105, 105, 144, 144, 301], [303, 303, 331, 331, 988], [990, 990, 1012, 1012, 1088], [1090, 1090, 1147, 1147, 1570]], "test": "timeout"}
{"id": "3ld3zs", "name": "59751-0-", "author": "jorge2017a1", "description": "Unknown author !!!----59751-0-", "tags": ["597510"], "likes": 3, "viewed": 66, "published": "Public", "date": "1590976328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///Unknown author !!!\n//Scene Start\nfloat hash(vec2 p)  \n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat mapH(in vec3 pos) \n{\n\t    pos.x += sin(iTime+pos.z*2.2);\n    \n    \tfloat h = 0.0;\n    \tvec2 q = pos.xz * 0.1;\n    \tfloat s = 0.03;\n    \n    \tfor (int i = 0; i < 3; i++)\n\t     {\n        \tq += vec2(i)+iTime*0.3;\n        \th += s * noise(q);\n    \t}\n    \n    \n    \treturn pos.y + h * 58.0;\n}\n\n//Floor\nvec2 obj0(in vec3 pos) \n{\n    \treturn vec2(min(mapH(pos), 1.),0.);   \n}\n\n\n//Floor Color (checkerboard)\nvec3 obj0_c(in vec3 p){\n if (fract(p.x*.15)>.5)\n   if (fract(p.z*.15)>.5)\n     return vec3(0.6,0.3,0.7);\n   else\n     return vec3(0.7,0.3,0.3);\n else\n   if (fract(p.z*.15)>.5)\n     return vec3(0.55,0.4,0.5);\n   else\n     \treturn vec3(0.8,0.5,0.8);\n}\n\n//Scene End\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n\n  //Camera animation\n  vec3 vuv=vec3(0,2,sin(iTime*0.1));//Change camere up vector here\n  vec3 prp=vec3(-sin(iTime*0.6)*16.0+iTime,7,cos(iTime*0.4)*16.0+iTime); //Change camera path position here\n  vec3 vrp=vec3(40.+iTime,-45,20.+iTime); //Change camere view here\n\n\n  //Camera setup\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n\n  //Raymarching\n  const vec3 e=vec3(0.1,0,0);\n  const float maxd=80.0; //Max depth\n\n  vec2 s=vec2(0.1,0.0);\n  vec3 c,p,n;\n\n  float f=1.0;\n  for(int i=0;i<86;i++){\n    if (abs(s.x)<.01||f>maxd) break;\n    f+=s.x;\n    p=prp+scp*f;\n    s=obj0(p);\n  }\n  \n  if (f<maxd){\n    if (s.y==0.0)\n      c=obj0_c(p);\n    n=normalize(\n      vec3(s.x-obj0(p-e.xyy).x,\n           s.x-obj0(p-e.yxy).x,\n           s.x-obj0(p-e.yyx).x));\n    float b=dot(n,normalize(prp-p));\n    fragColor=vec4(b*c*(2.0-f*.02),1.0);\n  }\n  else fragColor=vec4(0.4,0.2,0.3,1); //background color\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ld3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 58, 58, 162], [164, 164, 190, 190, 484], [486, 486, 512, 512, 778], [780, 788, 813, 813, 859], [862, 891, 914, 914, 1140], [1155, 1155, 1212, 1212, 2321]], "test": "timeout"}
{"id": "3lfcWj", "name": "Fireball by Darko", "author": "omegasbk", "description": "Super simple fireball. \nNeeds more polish.", "tags": ["fire"], "likes": 10, "viewed": 176, "published": "Public", "date": "1593022296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Darko Supe - omegasbk/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 firePosition = vec2(0., 0.0);\n    vec3 fireBallColor = vec3(0.8, 0.2, 0.1);\n    float ballSize = 0.3;\n    float fireSpeed = 1.5;\n        \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    // Fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n   \tfloat ballDistance = distance(firePosition, vec2(uv.x, uv.y));\n    vec3 fireBall = (max(sin(1. - sin(1. - iTime * 2.)) + 3.8, 1.))\n        * smoothstep(ballSize, 0.0, ballDistance)\n        * fireBallColor * vec3(smoothstep(ballSize, ballSize - 0.02, ballDistance));\n    \n    vec3 col = vec3(fireBall);\n    \n        \n    vec3 flameColor = vec3(0.);\n    \n    float i;\n\tfor(i = 0.; i < .6; i += .1) \n    {\n    \tflameColor += texture(iChannel1, vec2((uv.x - 1.) * .6 + i , iTime * fireSpeed * 0.2 - uv.y + i)).rrr;\n    }\n    flameColor *= vec3(0.6, 0., 0.);\n\n\n   \tflameColor += 0.3 * texture(iChannel1, vec2((uv.x - 1.) * .6, iTime * fireSpeed * 0.2 - uv.y)).rrr;\n    flameColor *= smoothstep(firePosition.y + .6, firePosition.y, uv.y);\n    flameColor += 0.3 * texture(iChannel0, vec2((uv.x - 1.) * 2.6, iTime * fireSpeed * 0.2 - uv.y)).rrr;\n    flameColor *= smoothstep(firePosition.y + .8, firePosition.y, uv.y);\n\n    \n    flameColor += texture(iChannel0, vec2((uv.x - 1.) * 2.6, iTime * fireSpeed / 2. - uv.y)).rrr;\n\n    flameColor.r += 0.3;\n    if (flameColor.r < 0.2) flameColor.r = 0.5;\n    flameColor *= smoothstep(firePosition.x + 0.25, firePosition.x, uv.x);        \n    flameColor *= smoothstep(firePosition.x - 0.25, firePosition.x, uv.x);\n    flameColor *= smoothstep(firePosition.y - 0.15, firePosition.y, uv.y);\n    flameColor *= smoothstep(0.6, 0., distance(uv, firePosition));\n    flameColor *= vec3(1.2, 0., 0.);\n    \n    \n    col += flameColor;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfcWj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[129, 129, 186, 186, 2023]], "test": "error"}
{"id": "3lfcz4", "name": "Minimal raymarching", "author": "TAKUSAKU", "description": "Minimal raymarching", "tags": ["raymarching", "minimal", "bitwise"], "likes": 7, "viewed": 72, "published": "Public", "date": "1591510341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define r iResolution\n\n//Based on https://twitter.com/yosshin4004/status/1251357672504360966\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    vec3 d=vec3(U/r.xy-.5,.5),p=vec3(0,0,t),q;\n    for(int i=0;i<99;i++)\n    {\n        p+=d*(length(sin(p.zxy)-cos(p.xyz))-.5);\n        //p+=d*(length(sin(p.zxx)-cos(p.xyz))-.5);\n        //p+=d*(length(sin(p.zxy)-cos(p.zzx))-.5);\n        //p+=d*(length(sin(p.xxy)-cos(p.xyz))-.5);\n        //p+=d*(length(sin(p.yzz)-cos(p.xyz))-.5);\n        if(i==95)q=p+=d=vec3(.6);\n    }\n    ivec3 u=ivec3(q*5e2);\n    o+=float((u.x^u.y^u.z)&150)/2e3*length(p-q)+(p.z-t)*.03;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 151, 151, 612]], "test": "timeout"}
{"id": "3lfyD8", "name": "Triangle to Teeth To Lotus", "author": "tic_is_mad", "description": "Testing rotation madness", "tags": ["experimental"], "likes": 0, "viewed": 59, "published": "Public", "date": "1591900330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat circle(in vec2 _st, in vec2 center, in float _radius)\n{\n    vec2 dist = _st - center;\n    float borderSize = _radius * 0.01;\n    return 1.0 - smoothstep(_radius - borderSize, _radius + borderSize, 4.0 * dot(dist, dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    //st.x *= iResolution.x / iResolution.y;\n    st *= 3.0;\n    st = fract(st);\n    float angle = PI * iTime * 0.4 * st.x;\n    st -= 0.5;\n    st = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * st;\n    st += 0.5;\n    // uv = uv * 2.0 - 1.0;\n    vec3 color = vec3(0.0);\n    // color = mix(color, vec3(1.0), circle(uv, vec2(0.5), 1.0));\n    //float d = length(abs(uv) - 0.3);\n    //color = vec3((d * 10.0));\n    \n    int N = 3;\n    st = st * 2.0 - 1.0;\n    float r = TWO_PI / float(N);\n    float a = atan(st.x, st.y) + PI;\n    \n    //float f = abs(cos(a*3.0));\n    //color = vec3(1.0 - smoothstep(f, f+0.02, r));\n    \n  \n    float d = cos(floor(.5+a / r) * r-a)*length(st);\n\n    d = 1.0-smoothstep(.4,.41,d);\n    \n    vec3 bloodColor = vec3(1.0, 0.2 + 0.05 * cos(iTime), 0.25 + 0.05 * sin(iTime));\n    color = mix(color, bloodColor, d);\n               \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 116, 116, 283], [285, 285, 342, 392, 1356]], "test": "timeout"}
{"id": "3lfyDl", "name": "Numerical Gradient Comparison", "author": "harry7557558", "description": "Comparing 3d numerical differentiation methods.\n\nSeems like the tetrahedron method doesn't work much better than the naive method ~.~", "tags": ["gradient", "compare", "differen"], "likes": 5, "viewed": 253, "published": "Public", "date": "1593380579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Comparing numerical gradient methods\n\n// I just discovered that sampling gradient on a 2d simplex \n// has an error of 1/h O(h²), so I want to know if that applies to 3d.\n\n// Left to right: reference, naive method, central difference, tetrahedron method\n\n// In the three graphs on the right:\n// Red indicates the difference in the direction of gradient;\n// Blue indicates the difference in the magnitude of gradient;\n// A brighter color represents a higher error.\n\n// In the reference graph: rgb -> xyz\n\n// Mouse control:\n// Left/Right: view rotation\n// Up/Down: numerical differentiation step\n\n// The 4-sample tetrahedron method doesn't seem to be much better\n// than the 3-sample naive method.\n\n// Using Taylor expansion, one gets: [+ 1/h O(h³)]\n\n// Naive method:        (∂F/∂x,∂F/∂y,∂F/∂z) + h/2 (∂²F/∂x²,∂²F/∂y²,∂²F/∂z²)\n// Central difference:  (∂F/∂x,∂F/∂y,∂F/∂z)\n// Tetrahedron method:  (∂F/∂x,∂F/∂y,∂F/∂z) + h (∂²F/∂y∂z,∂²F/∂x∂z,∂²F/∂x∂y)\n\n// You can uncomment the commented lines in fun() and map()\n// to see how these methods applied to a sphere and a hyperboloid.\n\n// However, you may need to change these:\n#define saturation 1.0\n#define raymch_step_sc 0.8\n\n// ======================================================================= end of story\n\n\n\n// the funny shape: F(x,y,z)=(x²+2y²+z²)³-(9x²+y²)z³-0.5\nfloat fun(in vec3 p) {\n    //return dot(p,p)-1.; // sphere\n    //return p.x*p.y+p.x*p.z+p.y*p.z+1.; // hyperboloid\n    float e = p.x*p.x+2.*p.y*p.y+p.z*p.z;\n\treturn e*e*e-(9.*p.x*p.x+p.y*p.y)*p.z*p.z*p.z-.5;\n}\n\n// return value and analytical gradient at once\nvec4 map(in vec3 p) {\n    //return vec4(2.*p,dot(p,p)-1.); // sphere\n    //return vec4(p.y+p.z,p.x+p.z,p.x+p.y,p.x*p.y+p.x*p.z+p.y*p.z+1.); // hyperboloid\n    vec3 p2 = p*p;\n    float e = p2.x+2.*p2.y+p2.z, f = 9.*p2.x+p2.y;\n    return vec4(\n        e*e*vec3(6,12,6)*p - p2.z*vec3(18.*p.x*p.z,2.*p.y*p.z,3.*f),\n        e*e*e - p2.z*p.z*f - .5);\n}\n\n\n\n// numerical differentiation step\nfloat h = 0.1;\n\n// numerical gradient method id\nint method = 0;\n\n// naive method\nvec3 grad_naive(in vec3 p){\n    float v = fun(p);\n    return (1./h)*vec3(\n        fun(p+vec3(h,0,0))-v,\n        fun(p+vec3(0,h,0))-v,\n        fun(p+vec3(0,0,h))-v);\n}\n// central difference\nvec3 grad_central(in vec3 p){\n    return (.5/h)*vec3(\n        fun(p+vec3(h,0,0))-fun(p-vec3(h,0,0)),\n        fun(p+vec3(0,h,0))-fun(p-vec3(0,h,0)),\n        fun(p+vec3(0,0,h))-fun(p-vec3(0,0,h)));\n}\n// tetrahedron method\nvec3 grad_tetrahedron(in vec3 p){\n\tfloat a = fun(p+vec3(h,h,h));\n\tfloat b = fun(p+vec3(h,-h,-h));\n\tfloat c = fun(p+vec3(-h,h,-h));\n\tfloat d = fun(p+vec3(-h,-h,h));\n\treturn (.25/h)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n\n// raymarching\n\nvec3 light = vec3(.3,.1,1);\nvec3 render(vec3 p, vec3 d) {\n\tfloat t = 3., dt;\n\tfor (int i = 0; i < 1024; i++) {\n        vec4 mp = map(p+t*d);\n\t\tdt = abs(mp.w) / length(mp.xyz);\n\t\tt += raymch_step_sc*dt;\n        if (dt<.001) {\n\t\t\tp += t*d;\n            vec3 grad = mp.xyz;\n            float m0 = length(grad);\n    \t\tvec3 n0 = normalize(grad);\n            vec3 col = vec3(.2*clamp(dot(n0,light),0.,1.)+.2);\n            if (method==0) return col+(n0+vec3(.5))*vec3(.4,.2,.4);\n            \n            if (method==1) grad=grad_naive(p);\n            if (method==2) grad=grad_central(p);\n            if (method==3) grad=grad_tetrahedron(p);\n            float m = length(grad);\n            vec3 n = normalize(grad);\n            \n            float ed = 10.*(1.-dot(n0,n));\n            float el = (m-m0)*(m-m0)/sqrt(m0*m0+1.);\n    \t\treturn col+vec3(ed,0,el)*saturation;\n        }\n\t\tif (t>20.) break;\n\t}\n    return vec3(.5*clamp(dot(d,light),0.,1.));\n}\n\n#define AA 2\n#define res iResolution.xy\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec3 col = vec3(0.0);\n    vec2 gd = coord.xy;\n    method = int(4.*gd.x/res.x);\n    gd.x = mod(gd.x,.25*res.x);\n    \n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 uv=(12./res.x)*((gd+vec2(i,j)/float(AA))-vec2(.125,.5)*res.xy);\n        vec3 pos = vec3(0,-10,0.);\n        vec3 dir = vec3(uv.x,0,uv.y)-pos;\n        float a = .3*sin(iTime);\n        mat3 R = mat3(1,0,0,0,cos(a),-sin(a),0,sin(a),cos(a));\n        if (iMouse.z>0.){\n            uv = iMouse.xy/res.xy;\n            a = 6.283*(uv.x-.5);\n            R = mat3(cos(a),-sin(a),0,sin(a),cos(a),0,0,0,1) * R;\n            a = 2.*(uv.y-.5);\n            h = 0.1+0.1*a;\n        }\n        light = R*vec3(.3,.1,1);\n        pos = R*pos, dir = R*dir;\n        col += render(pos,normalize(dir));\n    }\n    \n    color = vec4(col/float(AA*AA),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1338, 1402, 1424, 1516, 1611], [1613, 1661, 1682, 1815, 2007], [2110, 2126, 2153, 2153, 2292], [2293, 2315, 2344, 2344, 2512], [2513, 2535, 2568, 2568, 2747], [2795, 2795, 2824, 2824, 3707], [3749, 3749, 3796, 3796, 4608]], "test": "timeout"}
{"id": "3lfyDr", "name": "Fractals: Multibrot", "author": "4rknova", "description": "A simple Multibrot fractal shader.\nhttps://en.wikipedia.org/wiki/Multibrot_set", "tags": ["fractal", "multibrot"], "likes": 3, "viewed": 337, "published": "Public API", "date": "1592433225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ANIMATE\n//#define SMOOTH_SHADING\n#define KVAL   (4.0)\n\n#define AA\t    2.\n#define ZOOM    1.4\n#define ITER    48 // Max number of iterations\n#define COL_IN  vec3(0)\n#define T       iTime\n\nvec2 DeMoivre(vec2 p, float e)\n{\n    // Convert to polar coords\n    float r = sqrt(dot(p,p));\n    float t = atan(p.y, p.x);\n   \t// Apply DeMoivre theorem\n    r = pow(r, e);\n    t = e * t;\n    // Convert back to cartesian coords\n    return r * vec2(cos(t), sin(t));\n}\n\nvec3 fractal(vec2 p)\n{    \n\tvec2 z = vec2(0);  \n\n\tfor (int i = 0; i < ITER; ++i) {\n        \n        float k = KVAL;\n        \n        #ifdef ANIMATE\n         k = 1. + mod(iTime * 0.5, 10.);\n        #endif // ANIMATE\n            \n\t\tz = DeMoivre(z, k) + p; \n\n        #ifdef SMOOTH_SHADING\n        // Smooth shading code contributed by Shane\n        float rad = 64.;\n\t\tif (dot(z,z) > rad) {\t     \n\t\t\tfloat s = float(i) - log2(log2(dot(z,z))/(log2(rad)))/log2(k);\n\t\t\treturn vec3(vec3(cos(s + .9), cos(s + .3), cos(s + .2)) * .4 + .6);\n\t\t}        \n        #else\n\t\tif (dot(z,z) > 4.) {\n\t\t\tfloat s = .125662 * float(i);\n\t\t\treturn vec3(vec3(cos(s + .9), cos(s + .3), cos(s + .2)) * .4 + .6);\n\t\t}\n        #endif // SMOOTH_SHADING\n\t}\n\n    return COL_IN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 c = (fragCoord.xy / iResolution.xy * 2. - 1.)\n\t\t   * vec2(iResolution.x / iResolution.y, 1)\n\t\t   * ZOOM - vec2(.5,0.);\n\n    vec3 col = vec3(0);\n    \n#ifdef AA\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += fractal(c + ZOOM * vec2(i, j) * (e/AA)) / (4.*AA*AA);\n        }\n    }\n#else\n    col = fractal(c);\n#endif /* AA */\n\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyDr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[316, 316, 348, 379, 582], [584, 584, 606, 606, 1328], [1330, 1330, 1387, 1387, 1888]], "test": "timeout"}
{"id": "3lfyz4", "name": "more Circuit Diagram ( 111 ch )", "author": "FabriceNeyret2", "description": "( I already so them in shadertoy under other names, but can find back ).", "tags": ["2d", "xor", "pattern", "onetweet", "golf", "circuits"], "likes": 5, "viewed": 211, "published": "Public API", "date": "1591508835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 30. * iTime),\n      r = (x+y)^(x-y);\n  O = fract(vec4(r*r*r)/(997.+vec4(0,1,2,1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 160]], "test": "ok"}
{"id": "3lGSDV", "name": "thrax sdf test", "author": "manthrax", "description": "sdf csg", "tags": ["sdf", "csg"], "likes": 1, "viewed": 83, "published": "Public", "date": "1592242772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\n//------------------------------------------------------------------\n\n#define fnU(d1,d2) (d1<d2) ? d1 : d2\n#define fnS(d1,d2) max(d1,-d2)\n#define fnI(d1,d2) max(d1,d2)\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n\treturn max(d1,-d2);\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn max(d1,d2);\n}\nfloat opSDU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSDS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSDI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map2( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n\tres = opU( res, vec2( sdPyramid( 2.5*(pos-vec3(-1.0,0.15,-3.0)), 1.1 )/2.5, 13.56 ) );\n\tres = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdSolidAngle(pos-vec3( 0.0,0.20,-3.0), vec2(3,4)/5.0, 0.4 ), 49.13 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdCappedTorus((pos-vec3( 1.0,0.20, 1.0)).xzy, vec2(0.866025,-0.5), 0.2, 0.05), 8.5) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdRhombus(  (pos-vec3( 1.0,0.40,-3.0)).xzy, 0.15, 0.25, 0.04, 0.08 ), 18.4 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(  pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    res = opU( res, vec2( sdRoundCone( pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n    res = opU( res, vec2( sdRoundCone( pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// Create multiple copies of an object - http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n//thx\nvec3 animpos = vec3( 0.0,0.25,0.0);\n\nvec2 map( in vec3 pos ){\n    \n\n    \tvec3 q = pos*1.5 + vec3(0.5,0.0,0.);\n        vec3 r = opRepLim(q,0.75,vec3(-16.,0., -16.),vec3(16.,1.,16.));\n        //d = sdBox( r, vec2(0.4,0.2) ) -  0.1;    \n    \n    vec2 res = vec2( 1e10, 0.0 );\n    res = opU( res, vec2( sdCylinder(  r-vec3( 0.0,0.25,0.0), vec3(0.0,-0.3,0.0), vec3(-0.0,0.3,0.0), 0.18), 31.2 ));\n    res = opU( res, vec2( sdSphere(    r-vec3( 0.0,0.5, 0.0), 0.25 ), 46.9 ));\n\tres = opS( res, vec2( sdTorus(    r-animpos, vec2(0.20,0.15) ), 25.0 ));\n    \n    \n    \n\treturn res;\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,3.0) );\n    \n    //if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.2 + 0.18*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        //col = vec3(0.2);\n        col = 0.2 + 0.18*sin( m*2.0 + vec3(0.0,0.5,1.0) );\n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 5.0*pos.xz, 5.0*dpdx.xz, 5.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n        lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 7.00*spe*vec3(1.10,0.90,0.70);\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 22.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0., .2, 0. );\n    float orbitRadius = 3.;\n    vec3 ro = ta + vec3( orbitRadius*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, orbitRadius*sin(0.1*time + 6.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n    \n    animpos = vec3(0.,(sin(time)+1.)*.25,0.);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGSDV.jpg", "access": "shaders20k", "license": "mit", "functions": [[1614, 1614, 1639, 1639, 1654], [1656, 1656, 1691, 1691, 1717], [1719, 1719, 1750, 1750, 1841], [1843, 1843, 1902, 1902, 1996], [1998, 1998, 2031, 2031, 2086], [2088, 2088, 2158, 2158, 2298], [2300, 2300, 2336, 2336, 2647], [2649, 2649, 2701, 2701, 2815], [2817, 2817, 2881, 2881, 3159], [3161, 3161, 3185, 3185, 3202], [3203, 3203, 3266, 3330, 3917], [3921, 3921, 3957, 3957, 4307], [4309, 4321, 4357, 4357, 4460], [4462, 4487, 4538, 4538, 4893], [4895, 4907, 4945, 4945, 5114], [5116, 5116, 5141, 5141, 5160], [5161, 5161, 5226, 5226, 5564], [5566, 5636, 5694, 5694, 6254], [6256, 6302, 6350, 6350, 6519], [6521, 6521, 6558, 6558, 7152], [7154, 7154, 7196, 7196, 7796], [7798, 7798, 7827, 7827, 7855], [7857, 7897, 7961, 7961, 8219], [8392, 8392, 8422, 8422, 8455], [8457, 8457, 8487, 8487, 8510], [8512, 8512, 8542, 8542, 8564], [8565, 8565, 8609, 8609, 8708], [8710, 8710, 8754, 8754, 8854], [8856, 8856, 8900, 8900, 8999], [9172, 9172, 9198, 9198, 11389], [11391, 11499, 11567, 11567, 11613], [11658, 11658, 11682, 11682, 12194], [12197, 12265, 12316, 12316, 12521], [12550, 12550, 12590, 12590, 13375], [13378, 13440, 13518, 13541, 13932], [13934, 13998, 14030, 14030, 14561], [14563, 14563, 14605, 14605, 14921], [14923, 14999, 15063, 15084, 15317], [15319, 15319, 15384, 15384, 17381], [17383, 17383, 17435, 17435, 17612]], "test": "timeout"}
{"id": "3llcD8", "name": "Slicing example [Terah]", "author": "Terah", "description": "Example of slicing function", "tags": ["raymarcher", "slice"], "likes": 7, "viewed": 134, "published": "Public", "date": "1591978457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = acos(-1.);\nconst float TAU = 2.*PI;\n\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdBox(vec3 p, vec3 b, float s) {\n    vec3 d = abs(p) - b;\n  \treturn length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - s; \n}\n\n// Slicing function example\nfloat slice(vec3 p, float objectToSlice, float a, float b) {\n    \n    vec3 p1 = p;\n    vec3 p2 = p;\n    \n    p1.xz *= rot(a);\n    p2.xz *= rot(b-PI);\n    \n    float d1 = sdPlane(p1, vec3(0.,0.,1.), 0.0);\n    float d2 = sdPlane(p2, vec3(0.,0.,1.), 0.0);\n    \n    float s = max(d1,d2);\n    \n    return max(objectToSlice,-s);\n}\n\nfloat map(vec3 p) {\n    \n    p.yz *= rot(-.5);\n    p.xz *= rot(PI*.5 + iTime*0.3);\n    \n    float box = sdBox(p, vec3(1), 0.05);\n    \n    // Angles for the slice\n    float a = -1.1 + sin(iTime); \n    float b = .7 + sin(iTime+PI*.5);\n    \n    // Slicing the box with angles a and b\n    float slicedObject = slice(p, box, a, b);\n\n    return slicedObject;\n}\n\nvec3 norm(vec3 p) {\n\tvec2 o=vec2(0.002, 0.0);\n    return normalize(vec3(\n        map(p+o.xyy)-map(p-o.xyy),\n        map(p+o.yxy)-map(p-o.yxy),\n        map(p+o.yyx)-map(p-o.yyx)\n    ));\n}\n\nvec3 march(vec3 s, vec3 r) {\n      \n    float d=0.0;\n    int i=0;\n    vec3 p=s;\n    \n    for (; i<100; ++i) {             \n        d = map(p);   \n        if (abs(d)<0.001) {\n            break;\n        }       \n        p+=d*r;\n    }        \n    \n    vec3 col = vec3(0.1);\n    float li = 1.;\n    \n    vec3 n = norm(p);\n    vec3 l = normalize(vec3(.5,1,-2));\n    float lb = max(0.0,dot(n,l));\n    col += lb * vec3(0.8,0.6,0.8) * li;\n    \n    vec3 h = normalize(l + -r);\n    float sa = max(dot(h, n), 0.0);\n    float sp = pow(sa, 5.0);\n    if (lb>0.0) {\n        col += sp * vec3(0.5,0.5,0.5);\n    }\n\n    float fog = 1.0-float(i)/100.0;\n\tcol = mix(vec3(0.01, 0.05, 0.05), col, fog);\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -5.0);\n    vec3 rd = normalize(vec3(uv, 1));\n\n    \n    vec3 col = march(ro, rd);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 74, 74, 143], [145, 145, 187, 187, 223], [225, 225, 263, 263, 358], [360, 388, 448, 448, 712], [714, 714, 733, 733, 1068], [1070, 1070, 1089, 1089, 1256], [1258, 1258, 1286, 1286, 1963], [1967, 1967, 2024, 2024, 2228]], "test": "error"}
{"id": "3llcDn", "name": "bubble gum", "author": "firanolfind", "description": "2d colourful plasma", "tags": ["metaballs", "plasma", "bubbles"], "likes": 5, "viewed": 308, "published": "Public API", "date": "1591829201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// forked from https://www.shadertoy.com/view/4tl3Rn\n\nfloat roundLookingBlob(vec2 fragCoord, vec2 tPos, float r) {\n    vec2 pos = fragCoord.xy/iResolution.yy - vec2(0.5);\n    pos.x -= ((iResolution.x-iResolution.y)/iResolution.y)/2.0;\n    return pow(max(1.0-length(pos-tPos), 0.0) , r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat v = 0.0 \n        + roundLookingBlob(fragCoord * 0.2,vec2(sin(iTime)* 2.0, cos(iTime)*0.004), 10.0)\n    \t+ roundLookingBlob(fragCoord,vec2(sin(iTime*0.6)*0.2, cos(iTime)*0.3), 7.0)\n    \t+ roundLookingBlob(fragCoord,vec2(cos(iTime*0.8)*0.3, sin(iTime*1.1)*0.04), 5.0)\n    \t+ roundLookingBlob(fragCoord,vec2(cos(iTime*0.2)*0.2, sin(iTime*0.9)*0.05), 8.0)\n    \t+ roundLookingBlob(fragCoord,vec2(cos(iTime*1.2)*0.2, 2.0 *sin(iTime*0.9)*0.05), 8.0)\n        + roundLookingBlob(fragCoord,vec2(cos(iTime*0.3)*0.4, sin(iTime*1.1)*0.4), 5.0)\n    \t+ roundLookingBlob(fragCoord,vec2(sin(iTime*0.6)*0.9, cos(iTime)*0.3), 7.0)\n    \t+ roundLookingBlob(fragCoord,vec2(sin(iTime*0.6)*0.3, cos(iTime)*0.8), 7.0)\n        + roundLookingBlob(fragCoord,vec2(cos(iTime*0.3)*0.9, sin(iTime*0.1)*0.4), 3.0)\n        ;\n    v = clamp((v-0.5)*1000.0, 0.0, 1.0);\n    //v = 1.0;\n    //float color = cos(iTime * fragCoord.x) * 1.0;\n    //v *= color;\n    //float r = 1.0 + fragCoord.y *sin(iTime * 0.5) +  0.0001 * (2.0 * sin(iTime * 1.0)) ;\n    float r = \n        -1.0 * 1.0 *sin(iTime) \n        - 2.0* cos(1.0 * iTime) * fragCoord.x / iResolution.x * fragCoord.y / iResolution.y;\n    float g = 0.0 - 0.5 * cos(2.0 * iTime) *  fragCoord.y / iResolution.y; //1.0* sin(iTime) - r + 0.8;\n    float b = 4.0 + sin(iTime) - g + 0.8;\n\tfragColor = vec4(r * v, v * g, v * b, 0.0);\n}\n\n//* fragCoord.y * fragCoord.x", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 114, 114, 288], [290, 290, 347, 347, 1695]], "test": "timeout"}
{"id": "3llcR8", "name": "recursive Bézier construction", "author": "FabriceNeyret2", "description": "Recusive form of the nice geometric construction of Bezier curve:[url]https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Higher-order_curves[/url] .\n Note the fast convergence.\nUse mouse to control spot of refinement.", "tags": ["bezier", "spline", "tuto"], "likes": 10, "viewed": 333, "published": "Public API", "date": "1591428631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === Recusive form of the nice geometric construction of Bezier curve ===\n// https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Higher-order_curves \n// for real-use, would draw segments and stop subdiv when length or angle < threshold\n\nvec2  P0_ = vec2(-1.6,-.8), T0 = .8*vec2(1.5,2), // Bezier cage: points + tangents\n      P3_ = vec2( 1.4,-.8), T3 = .8*vec2(.2 ,2), \n      P0,P1,P2,P3;                               // recursive Bezier cage ( 4 points )\n#define R  iResolution.xy\n\n// --- line drawing from https://www.shadertoy.com/view/llySRh\n// NB: for perf, would better return dot(,) take the min dist, then draw only the sqrt of this one.\n#define S(v,r) smoothstep( -3., 0., r-abs(v)*R.y )\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h); \n}\n\n// --- recursive construction\n// M:        target point ( e.g., Mouse  or cur pixel )\n// constr:   true: draw construction line   false: only draw the final point.\nvoid Bezier( vec2 U, vec2 M, inout vec4 O , bool constr) {\n    for( int i=0; i< (constr ? 4 : 8 ); i++ ) {\n        vec2 P01 = ( P0+P1 )/2., P12 = ( P1+P2 )/2., P23 = (P2+P3)/2., // NB: pretty integer friendly\n             P02 = (P01+P12)/2., P13 = (P12+P23)/2., \n              Pb = (P02+P13)/2.;                 // mid-point on spline, delimiting the 2 sub-cages\n        if (constr) O.rg += S(line(U,P01,P02),), // draw construction lines ( including sub cages )\n                    O.rg += S(line(U,P02,P12),)*.5, \n                    O.rg += S(line(U,P13,P23),),\n                    O.rg += S(line(U,P12,P13),)*.5,\n                    O.g  += S(line(U,P02,Pb) ,),\n                    O.r  += S(line(U,Pb,P13) ,), // draw point on spline\n                    O    += S(length(Pb-U), 4.);\n        else        O    += S(length(Pb-U),   );\n\n        if ( dot( M-Pb, P13-P02 ) < 0. )\n      //if ( M.x < Pb.x ) \n                        P1=P01, P2=P02, P3=Pb;   // choose closest sub-cages\n            else        P2=P23, P1=P13, P0=Pb;\n    }\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( 2.*u - R ) /R.y,\n         M = length(iMouse.xy) < 20. \n                 ?  vec2 ( cos(iTime), 0 )\n                 : ( 2.*iMouse.xy - R ) /R.y; \n    O = vec4(0);\n    T0 += .2 * cos(iTime+vec2(0,11));            // animate Bezier cage\n    T3 += .2*sin(2.3*iTime+vec2(0,11));\n    \n   \n    P0 = P0_, P3=P3_, P1 = P0+T0, P2 = P3+T3;    // set Bezier cage\n    O.r  += S(line(U,P0,P1),);                   // draw Bezier cage\n    O.rg += S(line(U,P1,P2),);\n    O.g  += S(line(U,P2,P3),);\n    \n    O += S(length(M-U)/8.,);                     // draw mouse spot \n    Bezier(U,M,O, true);                         // recursive draw Bezier around mouse spot\n    \n    P0 = P0_, P3=P3_, P1 = P0+T0, P2 = P3+T3;    // set Bezier cage\n    Bezier(U,U,O, false);                        // recursive draw Bezier curve (here, just points)\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 731, 731, 837]], "test": "timeout"}
{"id": "3llcRH", "name": "Stretcher", "author": "Oggbog", "description": "Simple stretch and rotate", "tags": ["stretch"], "likes": 1, "viewed": 161, "published": "Public API", "date": "1591457345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 p,float r){\n    float d = length(p);\n    \n    // comment/uncomment lines 6 and 7 for variations\n    \n    //d = abs(smoothstep(r,r+0.05,d)-smoothstep(r - 0.1,r - 0.1 + 0.05,d));\n    d = 1.0-abs(smoothstep(r,r+0.05,d));\n    return d;\n}\n\nvec2 rot(float a, vec2 c){\n    \n    vec2 r = c * mat2(sin(a),-sin(a),sin(a),cos(a));\n    \n    return r;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.5,0.1,0.4);\n    \n    uv = uv * 8.0;\n    uv += 0.5;\n    \n    uv = rot(-iTime,uv);\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    \n    \n    float d = circle(gv,0.5-(abs(id.x+id.y)*sin(iTime*3.0)*0.05+0.5)*0.05);\n    \n    col += d;\n\tcol *= vec3(0.6,0.4,0.8);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 251], [253, 253, 279, 279, 363], [366, 366, 423, 423, 824]], "test": "ok"}
{"id": "3llcRl", "name": "2D Fractal", "author": "capslpop", "description": "This is my first project. The controls are not very good (mouse).", "tags": ["fractal", "experimental", "realtime"], "likes": 0, "viewed": 53, "published": "Public", "date": "1592801003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nControlsL:\nUse the mouse to move around\n\nThanks FabriceNeyret2 for the hlep!\n*/\nvec2 C;\nvec2 Z;\nfloat maxIteration = 60.0; //This controls the iterations of the Fractal \nfloat disx = 1.0;\nfloat iterations = 0.0;\nfloat scale = 1.0;\nconst float speed = 15.0; //This is the speed of the zoom in\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    scale = speed/(iTime);\n    C.x = uv.x * scale - ((iMouse.x) / (iResolution.x/2.0) + ((speed/2.0)/iTime)) + 1.0;\n    C.y = uv.y * scale - ((iMouse.y) / (iResolution.y/2.0) + (7.5/iTime)) + 1.0;\n    Z = vec2(0);\n    iterations = 0.0;\n    while ( Z.x < maxIteration && Z.y < maxIteration && iterations < maxIteration)\n    {\n        Z = mat2(Z,-Z.y,Z.x) * Z + C;\n        //Z = mat2(Z,-Z.y,Z.x) * Z * Z.y + C ;\n        iterations++;\n    }\n    \n    // Output to screen\n    fragColor = vec4(iterations / maxIteration, 0.5 / (iterations / maxIteration), C.x * C.y, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 353, 353, 967]], "test": "ok"}
{"id": "3llcRS", "name": "Gear wheel thingy", "author": "tibor0991", "description": "Ehhh, nothing much, looks nice but nothing special here.", "tags": ["smoothstep", "polar", "coordinates", "gear"], "likes": 2, "viewed": 44, "published": "Public", "date": "1592347925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat gear(float teethN, float toothHW, vec2 st, float radius) {\n    vec2 uv = vec2(st.x * teethN, st.y-radius);\n\tfloat x = abs((fract(uv.x)-0.5))*2.;\n    float y = uv.y * sqrt(2.) * teethN;\t\t//might be correct, I don't remember the actual formula for the tooth depth\n\treturn 1. - abs(y - smoothstep(0.5-toothHW, 0.5+toothHW, x)); //returns only the contour\n    //return y - smoothstep(0.5-toothHW, 0.5+toothHW, x);\t//returns the full shape\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 st = vec2((atan(uv.x, uv.y) / 6.2831)+0.5, length(uv));\n    \n    float teethN = 32.;\n    \n    \n    //wobbly effect\n    //float toothHW = texture(iChannel0, uv).x*0.4; //tooth half-width\n    \n    //sharp teeth\n    float toothHW = 0.3;\t//tooth half-width\n    \n    float g1 = gear(teethN, toothHW, st + vec2(iTime*0.1,0.), 0.4);\n    float g2 = gear(teethN, toothHW, st + vec2(iTime*0.1,0.), 0.35);\n    \n    \n\n    float col = smoothstep(0.9, 1., pow(max(g1, g2), 0.2));\n\n    // Output to screen\n    fragColor = vec4(col, col, col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 65, 65, 443], [446, 446, 503, 503, 1108]], "test": "timeout"}
{"id": "3llczS", "name": "Midi raym", "author": "tristanwhitehill", "description": "test", "tags": ["prototype"], "likes": 1, "viewed": 101, "published": "Public", "date": "1592357050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nvec2 hash( vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*sin( (iTime*.04)*130.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s , c);\n    \n}\n\nfloat sine(float rate){\n    return sin(iTime*rate);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + ((max(q.x,max(q.y,q.z)),0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return (length(q)-t.y);\n}\n\nfloat GetDist (vec3 p){\n \n   float n = noise(2.5*(iResolution.xy*.05));\n    //put the shape to march to in a position and the last value of the vec4 is the radius\n\tvec4 shape = vec4(0.,1,2.,0.);\n    vec4 shape2 = vec4(0.,1.,2.,0.);\n    vec4 shape3 = vec4(0.,1.,2.,0.);\n    vec4 shape4= vec4(0.,.3,2.,0.);\n    \n    vec3 bp4 = p-shape4.xyz;\n    bp4.zy *= rot(iTime);\n    bp4.xy *= rot(iTime);\n    vec3 bp = p-shape.xyz;\n    bp.xy *= rot(iTime);\n    vec3 bp2 = p-shape2.xyz;\n    bp2.xy *= rot(-iTime);\n    vec3 bp3 = p-shape3.xyz;\n    bp3.yz *= rot(iTime);\n        \n    //distance to shape from current position, position - shape xyz then - the radius\n    //float sDist =(length(p-(shape.xyz))-shape.w);\n    float bd = sdTorus(bp, vec2(sine(.9)*3.,0.3));\n    bd -= sin(p.x+.2*iTime*.3)*.3*n;\n    float bd2 = sdTorus(bp2, vec2(sine(.6)*2.,0.1));\n    bd2 -= cos(p.y+.2*iTime*.8)*.9+n;\n    float bd3 = sdTorus(bp3, vec2(sine(.8)*2.,0.2));\n    bd3 -= sin(p.x+.2*iTime*.3)*.3-n;\n    \n    float bd4 =sdBox(bp4,vec3(.4,.8,.8));\n    \n    //plane distance is the camera's y value\n    float pDist = 2.;//p.y+2.;\n    //distance till collision is the minimum of shapes distance + camera\n    float d = min(bd2, pDist);\n    d = min(d, bd);\n    d = min(d, bd3);\n    d = min(d,bd4);\n    return d;\n    \n    \n}\n\n\nfloat rayMarch (vec3 rayO, vec3 rayD){\n    float distO = 0.;\n        //keeping track of origin of distance loop in vec3 space//\n        \n        //loop that manages a number of steps we take till our ray intersects with the object//\n    for(int i=0; i<MAX_STEPS; i++){\n            //sum the ray source and object orientation and multiply by the ray direction\n            vec3 p= rayO+distO*rayD;\n            //scene orientation//\n            float distSc = GetDist(p);\n            //update distance of step in corellation to scene orientation//\n            distO += distSc;\n            //check if in contact with minimum size of intersection flag, and also the max number \n            //of steps we want to take in the scene declared above//\n            if(distSc<SURF_DIST || distO>MAX_DIST) break;\n        }\n            return distO;\n        }\n    \nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(1, 2, 6);\n   // lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.,3.);\n    float d = rayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nfloat getLight2(vec3 p) {\n    vec3 lightPos = vec3(1, 1, 0);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif2 = clamp(dot(n, l),.0, 3.);\n    float d = rayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif2 *= .1;\n    \n    return dif2;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized canvas// 0 in middle//\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     float n = noise(2.5*(iResolution.xy*.5));\n\n    vec3 col = vec3(.0,.9,.9);\n    vec3 col2 = vec3(.4,.9,.7);\n    \n    //ray Position//\n    vec3 rayO = vec3(0.,0.,-2.0);\n    \n    //ray Direction//\n    vec3 rayD = normalize(vec3(uv.x,uv.y,1.));\n   \n    float d = rayMarch(rayO,rayD);\n     vec3 p = rayO + rayD *d;\n     d /= 2.;\n    float dif = getLight(p*2.);\n    float dif2 =getLight2(p);\n    col = vec3(dif*col);\n    col2 = vec3(dif2*col2);\n    if (col2==vec3(0.0,0.0,0.0)){\n        col2=vec3(.0,9.,.9);\n    }\n    fragColor = vec4(floor(col2),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llczS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 90, 90, 239], [241, 241, 267, 267, 665], [667, 667, 685, 685, 767], [769, 769, 792, 792, 822], [823, 823, 854, 854, 940], [941, 941, 974, 974, 1041], [1043, 1043, 1066, 1066, 2332], [2335, 2335, 2373, 2373, 3180], [3186, 3186, 3210, 3210, 3398], [3400, 3400, 3424, 3424, 3730], [3732, 3732, 3757, 3757, 4066], [4071, 4071, 4128, 4168, 4780]], "test": "timeout"}
{"id": "3llyRB", "name": "war_on_HugZ", "author": "TRASHTRASH", "description": "Just figuring shizz out.", "tags": ["2d", "grid", "disco", "pattern", "stupid", "vj", "visuals", "original", "coke"], "likes": 4, "viewed": 89, "published": "Public", "date": "1592368953", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TRASHTRASH\n//nightly exercise in failing but looks cool I guess\n\nfloat rect(vec2 p) {\n \tvec2 d = abs(p) - (0.5);\n    float rect = min(max(d.x, d.y), 0.0) + length(max(d, 0.));\n    float r = step(0., rect);\n    return r;\n}\n//iq palette\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n\tuv*=30.;\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    \n   float r = rect(gv);\n    vec3 col2 = palette(gv.x*gv.y+iTime,vec3(0.5),vec3(0.5),vec3(2.,1.,0.),vec3(.5,.2,.25));\n    vec3 col = vec3(1.-r)*(abs(sin(iTime*(id.y*id.x))));\n    col += mix(col2,col2-0.5,gv.y);\n   \n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 87, 87, 223], [224, 237, 308, 308, 351], [353, 353, 410, 410, 813]], "test": "ok"}
{"id": "3llyRM", "name": "Morphing Squid Monster", "author": "jarble", "description": "What is this strange creature?", "tags": ["raymarching", "squid"], "likes": 0, "viewed": 199, "published": "Public API", "date": "1591681838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nvec3 hash33(vec3 p)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    vec2 col = (uv.yx*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\nfloat sceneSDF(vec3 p) { \n    return (length(p)-0.5/sin(p.y));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/5.0), 10.0*sin(iTime/5.0), 10.0*cos(iTime/5.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 204, 254, 636], [881, 881, 905, 905, 945], [947, 1368, 1459, 1459, 1765], [1780, 2034, 2099, 2099, 2231], [2233, 2322, 2351, 2351, 2661], [2663, 3155, 3295, 3295, 3885], [3887, 4257, 4342, 4342, 5100], [5102, 5429, 5478, 5513, 5644], [5646, 5646, 5703, 5703, 6620]], "test": "timeout"}
{"id": "3llyzs", "name": "Disintegrating Holed Cylinder", "author": "Leria", "description": "An easy raw mix of 2 shaders", "tags": ["noise", "cylinder"], "likes": 0, "viewed": 234, "published": "Public API", "date": "1592828230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//from https://www.shadertoy.com/view/lssSRn by FabriceNeyret2\n\n#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\n\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\n\nvec2 sphere1Pos = vec2(0.,0.);\nfloat sphere1Rad = .7;         // sphere radius\n\nfloat planePos = .1;\n\nvec2 sphere2Pos = vec2(1.,0.);\nfloat sphere2Rad = .2;         \n\n// cloud appearance (superseeded by mouse tuning)\n\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\nfloat sharp = 0.9;            // cloud sharpness (0= ultra sharp ).\n\n\n\n#define ANIM 1         // 1/0\n\n#define PI 3.14159\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )  // base rand in [0,1]; \n{\n    return fract(sin(n-765.36334)*43758.5453);\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\n}\n\nfloat noise( in vec3 x ) // base noise in [0,1]; \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#if NOISE==1\n\treturn res;\n#elif NOISE==2\n\treturn abs(2.*res-1.);\n#elif NOISE==3\n\treturn 1.-abs(2.*res-1.);\n#endif\n}\n\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n\n\n// smooth distance to sphere = [-1,1] around radius +- thickness H\n\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\n{\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\n\tfloat d = (1.-length(p))/H;  \n\treturn clamp(d,-1.,1.);\n}\n\t\t\n// smooth distance to plane = [-1,1] around plane +- thickness H\n\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\n{\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\n\tfloat d = -p.x/(H*planeRad);  \n\treturn clamp(d,-1.,1.);\n}\n\t\n// smooth intersect operator\n\nfloat inter(float d0, float d1) {\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\n\td1 = (1.+d1)/2.;\n\treturn 2.*d0*d1 -1.;\n}\n\n// smooth union operator\n\nfloat add(float d0, float d1) {\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\n\td1 = (1.+d1)/2.;\n\treturn 2.*(d0+d1-d0*d1) -1.;\n}\n\n// jitter the distance around 0  and smoothclamp\n\nfloat perturb(vec2 p, float d, float H) {\n#if ANIM\n   float t = iTime;\n#else\n  float t = 0.; \n#endif\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\n\t\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\n}\n\n// convert [-1,1] distances into densities\n\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\n\treturn smoothstep(-sharp,sharp,d);\n}\n\n\n// user-define shape\n\t\nfloat shape(vec2 uv,float n) {\n\t\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\n\tfloat v;\n\n#define globalNoise false\n\t\n\tif (globalNoise || (n==0.)) {\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\n\t}\n\telse {\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\n\t}\n\t\n\treturn v;\n}\n\n// main loop\n\nvec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n\nconst vec3 cam = vec3(0., 0., 10.);\nfloat uniform_step = .5;\nvoid draw_disk(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing\n    vec3 p = cam+dir*antialiasing;\n    float s = 0.;\n  \t\n    \n    for(s; s < 150.; s++)\n    {               \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p, p);\n        float dist_center = length(center-cam);\n        \n        vec2 nu = polar_coord(p-(center));\n\n        //if too far, then big step\n        \n        if(sqrt(dist_dist) < (dist_center-radius))\n        {\n        \tk_step = dist_center-radius;\n        }\n\n        //if in the shape, draw\n        else if( (length(nu) - 5. <= 0.) && (length(nu) - 2.5 >= 0.) && (distance(p.y, center.y) < 2.))\n        {\n        \tc += 0.2*vec3(0.4, 0.4, 0.6);\n        }   \n        \n        //if it will never be in the shape anymore, return;\n        if(length(p) > (dist_center+radius))\n        {\n         \tbreak;   \n        }\n        \n        p += dir*k_step;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    \n   \tif (iMouse.z>0.)\n    {       \t\t\t\t   // mouse tuning\n\t\tvec2 m = iMouse.xy / iResolution.xy;\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \n\t}\n\n\tfloat v = dist2dens( shape(uv,1.) ); \n\tvec3 col = vec3(v);\n    \n    draw_disk(normalize(vec3(uv, -1.)), vec3(0., 0., 0.), vec3(0., 1., 0.), 30., color);\n    \n    fragColor = vec4(min(color, max(vec3(0.), col)), 1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[991, 991, 1039, 1039, 1144], [1146, 1146, 1197, 1197, 1700], [1702, 1702, 1764, 1764, 1947], [2079, 2079, 2135, 2135, 2269], [2339, 2339, 2441, 2441, 2572], [2605, 2605, 2638, 2638, 2747], [2775, 2775, 2806, 2806, 2923], [2975, 2975, 3016, 3016, 3358], [3404, 3404, 3430, 3477, 3515], [3541, 3541, 3571, 3571, 4128], [4144, 4144, 4170, 4170, 4318], [4381, 4381, 4461, 4461, 5443], [5445, 5445, 5502, 5502, 5951]], "test": "timeout"}
{"id": "3llyzX", "name": "Swingy Star", "author": "koo1ant", "description": "Playing around with UV modulation", "tags": ["2d", "star"], "likes": 1, "viewed": 56, "published": "Public", "date": "1592620475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: koo1ant (maxisilva@gmail.com)\n// IG: @pecsimax\n\n#define t iTime\n\n#define PI 3.14159235659\n\nprecision highp float;\n\n// Settings\nconst float swingSpeed = 5.;\nconst float starSize = 0.7;\n\nvec2 resolution;\n\nfloat circle(vec2 uv, vec2 pos, float radius)\n{\n    return 1.-step(radius, length(pos-uv));\n}\n\nfloat fractSDF(vec2 uv, vec2 pos, float radius)\n{\n    float dv = length(pos-uv);\n    return step(0.1, \n        fract(dv*radius*20.)) * 0.2+\n        sin(dv*radius*5.-t*5.)*0.16;\n}\n\nvec2 setupSpace(in vec2 fragCoord, in vec2 resolution)\n{\n    vec2 uv;\n    vec2 coord = fragCoord;\n    coord.x -= (resolution.x - resolution.y) * 0.5; // Aspect ratio fix  \n  \n    uv = coord / resolution.y;\n    \n    // Remap to -1 .. 1\n    uv = vec2(\n        uv.x *2. -1.,\n        uv.y *2. -1.);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    resolution = iResolution.xy;\n    \n    vec2 uv = setupSpace(fragCoord.xy, resolution); // Distorted space\n    vec2 uv2 = setupSpace(fragCoord.xy, resolution); // Less distorted space for the insides    \n    vec2 uvu = setupSpace(fragCoord.xy, resolution);\n    \n    \n    // Get angle before UV modulation to distort shape\n    float a = atan(uv.x, uv.y);\n    float a2 = atan(uvu.x, uvu.y);\n    \n\n    // Modulate space\n    uv.x += sin(t*swingSpeed)*0.1;\n    uv.y += cos(t*swingSpeed)*0.1;\n    \n    \n    vec2 innerSwing = vec2(sin(t*swingSpeed)*0.05, cos(t*swingSpeed)*0.11);\n    uv2 += innerSwing;\n    \n    // Draw star\n    float fn = sin(a*5.-5.)*0.15;\n    float fn2 = sin(a*20.+t*5.)*0.004;\n    float fn3 = sin(a*20.-t*10.)*0.004;\n    \n    float fnOutline = sin(a*20.+t*10.)*0.008;\n    \n    // Body\n    float outer = circle(uv, vec2(0), starSize+fn+fn2+fn3);\n    float inner = circle(uv, vec2(0), starSize*0.80+fn+fn2+fn3);\n    \n    // Insides\n\n    float aouter = circle(uv, vec2(0), starSize+fn+fn2+fn3+fnOutline);\n    float ainner = circle(uv, vec2(0), starSize*0.98+fn+fn2+fnOutline);\n\n    float simleFn = 0.2 + sin(t*0.5)*0.1;\n    float smileA = circle(uv2*5.5, vec2(0.0, -0.5), 0.1 + simleFn);\n    float smileB = circle(uv2*5.5, vec2(0, -0.3), 0.2 + simleFn);\n    \n    float eyePosY = 0.3;\n    float eyeFn = 0.3+sin(t*0.8)*0.05;\n    \n    vec2 eradius = vec2(-0.8, eyePosY);\n    \n    float eyeL = circle(uv2 * 5.5, vec2(-0.8, eyePosY), eyeFn + 0.03) * 0.5;\n    float eyeR = circle(uv2 * 5.5, vec2(0.8, eyePosY), eyeFn) * 0.5;\n\n    float fnc = sin(a*5.+4.5)*0.2;\n    float contour = fractSDF(uv, vec2(0), starSize+fnc+fnOutline);\n\n    // Final shapes\n    vec3 shape = vec3(outer-inner);    \n    vec3 ashape = vec3(outer-ainner);\n    vec3 smile = vec3(smileA*10.5-smileB*12.-contour-inner);\n    \n    \n    vec3 color = vec3(\n        shape * 0.2 +\n        ashape * 0.3 +\n        eyeL*10. +\n\teyeR*10. +\n\tsmile);\n     \n        color.b = 0.0;\n    \n    fragColor = vec4(vec3(color-inner),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 261, 261, 307], [309, 309, 358, 358, 487], [489, 489, 545, 545, 800], [802, 802, 859, 859, 2852]], "test": "timeout"}
{"id": "3lscDf", "name": "Hyperbolic Poincaré transformed", "author": "stb", "description": "A hyperbolic tessellation on the Poincaré disk model, with some extra conformal transformations.", "tags": ["2d", "complex", "conformal", "disk", "transformation", "tessellation", "transform", "poincare"], "likes": 19, "viewed": 289, "published": "Public", "date": "1593305585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tHyperbolic Poincaré transformed\n\t2015-2020 stb\n\n\tJust messing with some old code, and a few complex functions.\n*/\n\n// change these\nconst int N\t\t= 7;\t// number of polygon vertices\nconst int P\t\t= 3;\t// number of polygons meeting at a vertex\nconst int Iters\t= 16;\t// number of iterations\n\n\n#define E \t\t2.71828182\n#define HALFPI\t1.57079633\n#define PI\t\t3.14159265\n#define TWOPI\t6.28318531\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n#define rotate2(p, a) vec2(p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a))\n\n\nvec2 radialRepeat(vec2 p, vec2 o, int n) {\n    return rotate(vec2(o.x, o.y), floor(atan(p.x, p.y)*(float(n)/TWOPI)+.5)/(float(n)/TWOPI));\n}\n\nvec2 cInvert(vec2 p, vec2 o, float r) {\n    return (p-o) * pow(r, 2.) / dot(p-o, p-o) + o;\n}\n\nvec2 cInvertMirror(vec2 p, vec2 o, float r, float flip){\n    return (length(p-o)<r ^^ flip==1. ? cInvert(p, o, r) : p);\n}\n\nvec4 poincareGetStuff(int n_, int p_) {\n    float n = PI / float(n_), p = PI / float(p_);\n\tvec2 r1 = vec2(cos(n), -sin(n));\n    vec2 r2 = vec2(cos(p+n-HALFPI), -sin(p+n-HALFPI));\n    float dist = (r1.x - (r2.x/r2.y) * r1.y);\n    float rad = length(vec2(dist, 0.)-r1);\n    float d2 = dist*dist - rad*rad;\n    float s = (d2<0. ? 1. : sqrt(d2));\n\treturn vec4(vec3(dist, rad, 1.)/s, float(d2<0.));\n}\n\nvec2 poincareCreateUVs(vec2 p, vec4 pI) {\n    return cInvertMirror(p, radialRepeat(p, vec2(0., pI.x), N), pI.y, pI.w);\n}\n\n// Many complex functions are from: https://raw.githubusercontent.com/julesb/glsl-util/master/complexvisual.glsl\n\n#ifndef sinh\n\t#define sinh(a) (pow(E, a)-pow(E, -a)) / 2.\n#endif\n#ifndef cosh\n\t#define cosh(a) (pow(E, a)+pow(E, -a)) / 2.\n#endif\n\n#define c_abs(a) length(a)\n#define c_arg(a) atan(a.y, a.x)\n\n#define c_conj(a) vec2(a.x, -a.y)\n#define c_exp(a) vec2(exp(a.x)*cos(a.y), exp(a.x)*sin(a.y))\n#define c_sqr(a) vec2(a.x*a.x-a.y*a.y, 2.*a.x*a.y)\n#define c_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define c_div(a, b) vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y))\n#define c_sin(a) vec2(sin(a.x)*cosh(a.y), cos(a.x)*sinh(a.y))\n#define c_cos(a) vec2(cos(a.x)*cosh(a.y), -sin(a.x)*sinh(a.y))\n#define c_cartToPolar(a) vec2(length(a), atan(a.y, a.x))\n#define c_polarToCart(a) a.x * vec2(cos(a.y), sin(a.y))\n\nvec2 c_sqrt(vec2 a){\n    float r = sqrt(a.x*a.x+a.y*a.y);\n    float rpart = sqrt(.5*(r+a.x));\n    float ipart = sqrt(.5*(r-a.x));\n    if (a.y < 0.) ipart = -ipart;\n    return vec2(rpart, ipart);\n}\n\nvec2 c_tan(vec2 a){ return c_div(c_sin(a), c_cos(a)); }\n\nvec2 c_log(vec2 a){\n    float rpart = length(a);\n    float ipart = atan(a.y, a.x);\n    if (ipart > PI) ipart -= 2. * PI;\n    return vec2(log(rpart), ipart);\n}\n\nvec2 c_toThe(vec2 a, float b){ return c_exp(b*c_log(a)); }\nvec2 c_toThe(vec2 a, vec2 b){ return c_exp(c_mul(b, c_log(a))); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = 2. * (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\t\n    \n    // some transformations\n    float nArms = 1.+floor(16.*abs(fract(.025*iTime)-.5));\n\tp = rotate2(p, .2*iTime);\n    p /= dot(p, p);\n    p = c_toThe(p, nArms);\n    p.x += 1.;\n    p = c_toThe(p, .5);\n    p.x += .5;\n    p /= dot(p, p);\n    p.x -= 1.;\n    p = rotate2(p, .1*iTime);\n    \n    \n    // get data for the disk model\n    vec4 pI = poincareGetStuff(N, P);\n    \n    // build the disk\n    for(int i=0; i<Iters; i++)\n        p = poincareCreateUVs(p, pI);\n    \n    // uncomment to mirror from disk's margin\n    //p = cInvertMirror(p, vec2(0., 0.), 1., 1.);\n    \n    \n    // this is the pattern for each polygon\n    float f = 1. - dot(p, p) / pow(pI.z, 2.);\n    \n    fragColor = vec4(vec3(f)*vec3(1.7, 1.2, .8), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lscDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[680, 680, 719, 719, 772], [897, 897, 936, 936, 1292], [1294, 1294, 1335, 1335, 1414], [2263, 2263, 2283, 2283, 2459], [2461, 2461, 2480, 2480, 2516], [2518, 2518, 2537, 2537, 2676], [2678, 2678, 2708, 2708, 2736], [2737, 2737, 2766, 2766, 2802], [2804, 2804, 2859, 2859, 3652]], "test": "timeout"}
{"id": "3lscDM", "name": "GDCS - Gen. Spheres", "author": "RedReservoir", "description": "Visualization of \"Generalized Spheres\" with exponent in [2/3, 2].", "tags": ["gdcs"], "likes": 1, "viewed": 52, "published": "Public", "date": "1592229826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAYMARCHING_ITERATIONS 100\n#define EPSILON 0.00001\n#define MIN_DIST 0.00001\n#define MAX_DIST 100.0\n#define SAMPLE_SQUARE 1\n\nstruct material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n        \nstruct light {\n    vec3 position;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nmaterial mat_red = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.2, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_green = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_blue = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_orange = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.5, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_turquoise = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.5), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_purple = material(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\n\nlight[] scene_lights = light[] (\n    light(vec3(0.0, 0.0, 0.0), vec3(0.05, 0.05, 0.05), vec3(0.4, 0.4, 0.4), vec3(0.0, 0.0, 0.0)),\n    light(vec3(10.0, 10.0, 10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(-10.0, -10.0, -10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0))\n);\nint l_num = 3;\n\nvec3 background_color = vec3(0.7, 0.7, 0.9);\n\n//---------------------------------------------------------------------------------\n\nfloat timeValue(float x, float y, float spd, float disp) {\n\treturn ((x + y) + (y - x) * sin(spd * (iTime + disp))) / 2.0;   \n}\n\nfloat mixInverse(float x, float y, float a) {\n\treturn (a - x) / (y - x);    \n}\n\nfloat unitMap(float x) {\n    return (2.0 / (1.0 + exp(-x))) - 1.0;\n}\n\nfloat unitMapInverse(float x) {\n\treturn -log((2.0 / (x + 1.0)) - 1.0);    \n}\n\nfloat unitPow(float x, float p) {\n\treturn unitMap(pow(unitMapInverse(x), p));   \n}\n\nmat4 identityMatrix() {\n\tmat4 id;\n    id[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    id[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    id[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    id[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    return id;\n}\n\nmat4 rotationMatrix(float ax, float ay, float az) {\n\tmat4 rot_x;\n    rot_x[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    rot_x[1] = vec4(0.0, cos(ax), -sin(ax), 0.0);\n    rot_x[2] = vec4(0.0, sin(ax), cos(ax), 0.0);\n    rot_x[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_x = transpose(rot_x);\n\n    mat4 rot_y;\n    rot_y[0] = vec4(cos(ay), 0.0, sin(ay), 0.0);\n    rot_y[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    rot_y[2] = vec4(-sin(ay), 0.0, cos(ay), 0.0);\n    rot_y[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_y = transpose(rot_y);\n\n    mat4 rot_z;\n    rot_z[0] = vec4(cos(az), -sin(az), 0.0, 0.0);\n    rot_z[1] = vec4(sin(az), cos(az), 0.0, 0.0);\n    rot_z[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    rot_z[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_z = transpose(rot_z);\n    \n    return rot_z * rot_y * rot_x;\n}\n\nmat4 scaleMatrix(float sx, float sy, float sz) {\n    mat4 sc;\n    sc[0] = vec4(sx, 0.0, 0.0, 0.0);\n    sc[1] = vec4(0.0, sy, 0.0, 0.0);\n    sc[2] = vec4(0.0, 0.0, sz, 0.0);\n    sc[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    sc = transpose(sc);\n    return sc;\n}\n\nmat4 translationMatrix(float tx, float ty, float tz) {\n    mat4 tr;\n    tr[0] = vec4(1.0, 0.0, 0.0, tx);\n    tr[1] = vec4(0.0, 1.0, 0.0, ty);\n    tr[2] = vec4(0.0, 0.0, 1.0, tz);\n    tr[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    tr = transpose(tr);\n    return tr;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 c, float h, float r) {\n    float inOutRadius = length(p.xy - c.xy) - r;\n    float inOutHeight = abs(p.z - c.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat hexPrismSDF(vec3 p, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat generalSphereSDF(vec3 p, vec3 c, float r, float e) {\n    return length(pow(abs(p - c), vec3(e / 2.0))) - pow(r, e);\n}\n\n//---------------------------------------------------------------------------------\n\nvoid unionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 < d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid intersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 > d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid differenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(-d1 > d2) {\n        d = -d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid smoothUnionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) - k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothIntersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothDifferenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, -d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid sceneSDF(vec3 pos, out float dist, out material obj_mat) {\n\n    //dist = sphereSDF(pos, vec3(0,0,0), 1.0);\n    //dist = cylinderSDF(pos, vec3(0, 0, 0), 2.0, 0.5);\n    //dist = torusSDF(pos, vec2(2, 0.5));\n\t//dist = hexPrismSDF(pos, vec2(1.0, 0.5));\n    dist = generalSphereSDF(pos, vec3(0, 0, 0), 1.0, timeValue(0.66, 2.0, 1.0, 0.0));\n    obj_mat = mat_red;\n    \n}\n\n//---------------------------------------------------------------------------------\n\nvec3 blinnPhong(vec3 pos, vec3 V, vec3 N, material mat, light lt) {\n    //Calculate L and H vectors\n    vec3 L = normalize(vec3(lt.position - pos));\n    vec3 H = normalize(L + V);\n\n    //Ambient\n    vec3 ambient = lt.ambient * mat.ambient;\n\n    //Diffuse\n    vec3 diffuse = lt.diffuse * mat.diffuse * max(dot(L, N), 0.0f);\n\n    //Specular\n    vec3 specular = lt.specular * mat.specular * pow(max(dot(H, N), 0.0f), mat.shininess);\n    \n    //Final color calculation\n    //vec3 color = diffuse + ambient + specular;\n    vec3 color = diffuse + ambient;\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 estimateNormal(vec3 pos) {\n    material placeholder;\n    float nxr, nxl, nyr, nyl, nzr, nzl;\n    sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z), nxr, placeholder);\n    sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z), nxl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z), nyr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z), nyl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON), nzr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON), nzl, placeholder);\n   \n    return normalize(vec3(nxr - nxl, nyr - nyl, nzr - nzl));\n}\n\nvoid castRay(vec3 ray_origin, vec3 ray_direction, float dmin, float dmax, out float scene_dist, out material obj_mat) {    \n    scene_dist = dmin;\n    float step_dist;\n    for(int it = 0; it < MAX_RAYMARCHING_ITERATIONS; it++) {\n        vec3 ray_pos = ray_origin + (ray_direction * scene_dist);\n        sceneSDF(ray_pos, step_dist, obj_mat);\n        scene_dist += step_dist;\n        if(step_dist < EPSILON || scene_dist > dmax) { return; }\n    }\n   \n    scene_dist = dmax + 1.0;\n}\n\nvec3 calculateScreenRayDirection(vec2 fragCoord, vec2 size, float fov) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calculateCameraMatrix(vec3 lookfrom, vec3 lookat, vec3 vup) {\n    vec3 cz = normalize(lookat - lookfrom);\n    vec3 cx = normalize(cross(cz, vup));\n    vec3 cy = cross(cx, cz);\n    return mat3(cx, cy, -cz);\n}\n\n\n//---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Precalculate variables\n    vec2 mouse_UV = iMouse.xy / iResolution.xy;\n    \n    //Camera calculations\n    vec3 cam_lookat = vec3(0, 0, 0);\n    vec3 cam_lookfrom = cam_lookat + vec3(7.5 * cos(iTime),\n                                          1.5,\n                                          7.5 * sin(iTime)\n                                         );\n    vec3 cam_vup = vec3(0, 1, 0);\n    mat3 cam_matrix = calculateCameraMatrix(cam_lookfrom, cam_lookat, cam_vup);\n    \n    //Apply raymarching\n    float scene_dist;\n    material obj_mat;\n    \n    //With Anti-Aliasing\n    vec3 ray_origin = cam_lookfrom;\n    vec3 col = vec3(0);\n    \n    for(int kx = 0; kx < SAMPLE_SQUARE; kx++) {\n        for(int ky = 0; ky < SAMPLE_SQUARE; ky++) {\n    \t\t\n            vec2 kxy = vec2((0.5 + float(kx)) / float(SAMPLE_SQUARE), (0.5 + float(ky)) / float(SAMPLE_SQUARE));            \n            vec2 fragCoordSample = fragCoord + kxy - vec2(0.5);\n            vec3 ray_direction = cam_matrix * calculateScreenRayDirection(fragCoord, iResolution.xy, 45.0);\n        \tcastRay(ray_origin, ray_direction, MIN_DIST, MAX_DIST, scene_dist, obj_mat);\n        \n            vec3 pos = ray_origin + (ray_direction * scene_dist);\n    \t\tvec3 norm = estimateNormal(pos);\n            \n            \n            if(scene_dist < MAX_DIST) {\n                for(int l_index = 0; l_index < l_num; l_index++) {\n                    col += blinnPhong(pos, vec3(cam_lookfrom - pos), norm, obj_mat, scene_lights[l_index]);\n                }\n            } else {\n                col += background_color;\n            }\n            \n        }\n    }\n    \n    //Antialiasing division\n    col /= vec3(pow(float(SAMPLE_SQUARE), 2.0));\n    \n    //Gamma normalization\n    //col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lscDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1428, 1428, 1486, 1486, 1554], [1556, 1556, 1601, 1601, 1634], [1636, 1636, 1660, 1660, 1704], [1706, 1706, 1737, 1737, 1782], [1784, 1784, 1817, 1817, 1866], [1868, 1868, 1891, 1891, 2070], [2072, 2072, 2123, 2123, 2844], [2846, 2846, 2894, 2894, 3097], [3099, 3099, 3153, 3153, 3356], [3443, 3443, 3485, 3485, 3517], [3519, 3519, 3572, 3572, 3862], [3864, 3864, 3896, 3896, 3966], [3968, 3968, 4003, 4003, 4276], [4278, 4278, 4336, 4336, 4401], [4488, 4488, 4586, 4586, 4699], [4701, 4701, 4806, 4806, 4919], [4921, 4921, 5024, 5024, 5139], [5141, 5141, 5263, 5263, 5653], [5655, 5655, 5784, 5784, 6174], [6176, 6176, 6303, 6303, 6694], [6781, 6781, 6844, 7034, 7150], [7237, 7237, 7304, 7336, 7806], [7893, 7893, 7924, 7924, 8471], [8473, 8473, 8592, 8592, 8953], [8955, 8955, 9027, 9027, 9151], [9153, 9153, 9219, 9219, 9365], [9453, 9453, 9508, 9537, 11301]], "test": "error"}
{"id": "3lscRH", "name": "Checker bubble", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1269258938039431169", "tags": ["2tweets"], "likes": 7, "viewed": 66, "published": "Public", "date": "1591451801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tivec2 p=ivec2(700.*C/iResolution.y);\n    int x=p.x,y=p.y,T=int(iTime*250.),\n    n=T+abs((x+y-T)&(x-y+T)^((x+y-T/3)|(x-y+T/3)));\n    O.xyz+=mix(vec3(1),(smoothstep(1200.,0.,vec3(n%1400,n%1900,n%1800))),.8)*.6+\n        .9*fwidth(step(20.,float(n%999)));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lscRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 290]], "test": "ok"}
{"id": "3lscRr", "name": "fractal clock", "author": "sukupaper", "description": "The title speaks for itself 👀\n - Uncomment line 33 for another \"design\"\n\n", "tags": ["2d", "fractal", "clock", "distancefunctions"], "likes": 12, "viewed": 225, "published": "Public", "date": "1591286177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define P 3.14159265359\nmat2 r(float a) { float c = cos(a), s = sin(a); return mat2(c,s,-s,c); }\nfloat sq(vec2 p, vec2 sz, float r) { return length(max(abs(p) - sz,0.)) - r; }\n\nfloat anim1(float x) { float sp = P*12.; x = x*sp; return (x + sin(x - P))/sp; }\n\nvec2 m;\nfloat t;\nfloat aa;\nfloat shape(vec2 p) {\n    float d = 10e+9;\n    vec2 s1 = vec2(0.,(0.34444));\n    float s2 = .3;\n    for(int i = 0; i < 8; i++) {\n        float d1 = min(d,sq(p, s1, .002));\n        float d2 = sq(p*r(P*.25),vec2(.15)*s2, max(.001,aa));\n        d2 = min(d2,sq(p*r(P*.25) + .5*s2,vec2(.075)*s2, max(.001,aa)));\n        d2 = min(d2,sq(p*r(P*.25) - .5*s2,vec2(.075)*s2, max(.001,aa)));\n        float d3 = abs(length(p) - .7155*s2) - .001;\n        \n        d =  min(d1,d2);\n        d =  min(d,d3);\n        \n        p *= r(P*anim1(-t*.125)*.5);\n        p *= r(P*-0.3333);\n        p.y = abs(p.y) - s2*m.y;\n        p.x = abs(p.x) - s2*m.x;\n        p *= r(P);\n        s2 *= 0.5;\n        s1.y *= 0.496;\n    }\n    \n    //d = abs(d - .001) - .0005;\n    float dd = d;\n    d = smoothstep(-aa,aa,d);\n    float color = mix(0.,1.,d);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    t = iTime;\n    m = iTime < .1 ? vec2(1.) : iMouse.xy/iResolution.xy - .1;\n    aa = (1./iResolution.x);\n    \n    vec3 color = vec3(0.);\n    color.r += shape(st + vec2(aa + length(st*.002),0.));\n    color.g += shape(st + vec2(0.,0.));\n    color.b += shape(st + vec2(0.,aa + length(st*.002)));\n    \n    fragColor = vec4(color - pow(length(st)*.9,1.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lscRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 41, 41, 96], [97, 97, 133, 133, 175], [177, 177, 199, 199, 257], [286, 286, 307, 307, 1125], [1127, 1127, 1184, 1184, 1632]], "test": "timeout"}
{"id": "3lscRS", "name": "Day 179", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 17, "viewed": 365, "published": "Public API", "date": "1592351107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define T iTime\n\n// wrighter here \n// -- plant -- //\n// fractal in the middle\n// mist \n// floating object inside walls \n// floating mysterius tentacles\n\n// everything is going to be glowy, transparent\n// except of the floating objects inside of the walls \n\n\n// if i have time\n// transparent\n// polar repetetion, 4 times\n\nvec3 path (float z){\n    z *= 0.5;\n    return vec3(sin(z), cos(z),0);\n}\n\nvec3 glow = vec3(0);\n\n#define pal(a,b,c,d,e) ((a)+(b)*sin((c)*(d) + (e)))\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define kick (floor(T) + pow(fract(T),7.))\n\n\nvec2 map(vec3 p){\n\t\tvec2 d = vec2(10e6);\n        float dTrans = 10e7;\n\n        p.y -= 1.;\n\n    \tp -= sin(p)/1.;\n    \n        //p.z += T; \n        vec4 q = vec4(p,1.);\n        for(int i = 0; i < 4; i++){\n\n            float dpp = dot(q.xyz,q.xyz);\n            q /= dpp;\n\n            q.xyz = abs(q.xyz) - vec3(0.03,0.02,0.4);\n\t\t\t\n            //q.xz *= rot(0.5);\n            q.xy *= rot(0. + sin( (T + kick*pi/2.)*0.6)*0.14 );\n            \n            //q.zx *= rot(-0.2 );\n\n        }\n\n        dTrans = min(dTrans, length(q.xyz)/q.w);\n\n        dTrans = min(dTrans, length(q.xy)/q.w);\n\n        dTrans -= 0.003;\n\n        dTrans *= 0.5; \n        dTrans = abs(dTrans) + 0.004;\n\n\n        //dTrans = min(dTrans, length(p)-0.4);\n\n        glow += 0.7/(0.01 + dTrans*dTrans*2000.)*pal(0.5,0.5,vec3(0.7,0.2,0.1),1.,length(p) + T );\n\t\t\n        d.x = min(d.x, dTrans);\n\n        dTrans = 10e8;\n        dTrans = min(dTrans, length(q.xz)/q.w);\n    \tglow += 8.7/(0.01 + dTrans*dTrans*200.)*pal(0.5,0.5,vec3(0.89,0.2,0.1),1.,length(p) + T )*pow(abs(sin(length(p)*4. + T - kick*4.)),40.);\n\n        dTrans = abs(dTrans*0.5) + 0.004;\n\n        d.x = min(d.x, dTrans);\n\n        q.yz *= rot(.0);\n\n    \tq.x +=.0;\n    \tq.z -=.0;\n    \t\n    \tq.z -= 0.;\n    \tq.xy *= rot(0.3*pi);\n    \tq = abs(q);\n        float db = max(q.z,q.x)/q.w*0.4;\n        db -= 0.04;\n        //glow += 0.7/(0.01 + dTrans*dTrans*200.)*pal(0.5,0.5,vec3(0.89,0.2,0.1),1.,length(p) + T )*pow(abs(sin(p.x*4. + T)),40.);\n\n        d.x = min(d.x,db);\n\t\t\n    \tfloat dbb = abs(length(p)-1.5)+0.003; \n        d.x = min(d.x,dbb);\n    \tglow += exp(-dbb)*0.1;\n\t\t\n    \n    \td.x *= 0.9;\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.04,0.0,0.0);\n    //col = vec3(0.7,0.1,0.5);\n\n    uv *= 1. + dot(uv,uv);\n    \n    vec3 ro = vec3(0,0,0.0);\n    ro.y += sin(T);\n    ro.xz += vec2(cos(T)*0.4 + 1.,sin(T)*0.5-1.2)*9.;\n\n    vec3 lookAt = vec3(0);\n\n    lookAt.z = ro.z + 2.;\n\n    lookAt -= lookAt;\n\n    ro += path(ro.z);\n\n    lookAt += path(lookAt.z);\n\n\n    vec3 dir = normalize(lookAt - ro);\n\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up= normalize(cross(dir, right));\n\n    vec3 rd = normalize(dir + right*uv.x + up*uv.y);\n\n\n    vec3 p = ro; float t = 0.; vec2 d = vec2(10e7);\n    bool didHit = false;\n\n\n\n    //p.z -= T + 4.;\n\n    for(int i = 0; i < 110; i++){\n        d = map(p);\n        if(d.x < 0.001){\n        \tdidHit = true;\n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n\n    col += glow*0.06;\n\n    \n    \n    \n    if(didHit){\n    \tvec2 t = vec2(0.001,0);\n        vec3 n = normalize(map(p).x - vec3(map(p-t.xyy).x,map(p-t.yxy).x,map(p-t.yyx).x));\n        \n        \n        #define AO(j) clamp(map(p + n*j).x/j,0.,1.)\n        \n        col += 2.*AO(0.9)*AO(0.1);\n\n    }\n\n    col = 1. - col;\n    col = smoothstep(0.,1.,col);\n    \n    col *= 1. - dot(uv,uv)*0.1;\n    \n    //col = mix(col,vec3(0.5),smoothstep(0.,1.,t*0.001));\n    //col \n    /*\n    col /= 1. - col*0.2;\n    \n    */\n    //col = smoothstep(0.,1.,col*1.);\n    \n    col = pow(col,vec3(0.454545));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lscRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 342, 342, 393], [608, 608, 625, 625, 2233], [2235, 2235, 2292, 2292, 3789]], "test": "timeout"}
{"id": "3lscWr", "name": "square dance", "author": "darkfox", "description": "parallel movement and rotational movement.", "tags": ["square"], "likes": 3, "viewed": 70, "published": "Public", "date": "1591837311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\n// palette.\nconst vec3 red = vec3(0.95, 0.3, 0.35);\nconst vec3 green = vec3(0.3, 0.9, 0.4);\nconst vec3 blue = vec3(0.2, 0.25, 0.98);\nconst vec3 orange = vec3(0.9, 0.45, 0.1);\n// pattern data.\nconst float SCALE = 6.0;\n// hsb to rgb.\nvec3 getRGB(float r, float g, float b){\n    vec3 c = vec3(r, g, b);\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// backgroundColor.\nvoid setBackgroundColor(in vec2 p, inout vec3 col){\n  col = vec3(max(abs(p.x), abs(p.y))) / 1.4;\n}\n// normal pattern.\nvoid setNormalPattern(in vec2 p, inout vec3 col, float time, vec3 ptnColor){\n  // easing.\n  float x = fract(time * 2.0);\n  time = floor(time * 2.0) * 0.5 + 0.5 * x * x * (3.0 - 2.0 * x);\n  p *= SCALE;\n  p -= time * vec2(1.0, -1.0);\n  vec2 f = fract(p);\n  vec2 i = floor(p);\n  bool validation1 = mod(i.x, 2.0) == 0.0 && mod(i.y, 2.0) == 0.0;\n  bool validation2 = mod(i.x + i.y, 4.0) == 0.0;\n  if(!(validation1 && validation2)){ return; }\n  float value = 1.0 - 2.0 * max(abs(f.x - 0.5), abs(f.y - 0.5));\n  col = mix(ptnColor, vec3(1.0), value);\n}\n// rotational pattern.\nvoid setRotatePattern(in vec2 p, inout vec3 col, float time, vec3 ptnColor){\n  p *= SCALE;\n  vec2 q = 0.5 * vec2(p.x - p.y, p.x + p.y);\n  vec2 f = fract(q);\n  vec2 i = floor(q);\n  if(mod(i.x, 2.0) == 1.0 || mod(i.y, 2.0) == 1.0){ return; }\n  vec2 c = vec2(0.5);\n  // easing.\n  float prg = time / 0.5;\n  prg = prg * prg * (3.0 - 2.0 * prg);\n  // change rotation direction.\n  float sgn = (mod(iTime, 3.0) < 1.5 ? 1.0 : -1.0);\n  float multiple = floor(mod(iTime, 4.0));\n  float deg = 0.25 + (0.5 + 0.5 * multiple) * prg * sgn;\n  vec2 u1 = vec2(cos(pi * deg), sin(pi * deg));\n  vec2 u2 = vec2(cos(pi * (deg - 0.5)), sin(pi * (deg - 0.5)));\n  float value = 1.0 - 2.0 * sqrt(2.0) * max(abs(dot(f - c, u1)), abs(dot(f - c, u2)));\n  if(value < 0.0){ return; }\n  col = mix(ptnColor, vec3(1.0), value);\n}\n// normal pattern.\nvoid normalPattern(in vec2 p, inout vec3 col, float time){\n  setNormalPattern(p, col, time, red);\n  setNormalPattern(p.yx * vec2(-1.0, 1.0), col, time, blue);\n  setNormalPattern(-p, col, time, green);\n  setNormalPattern(p.yx * vec2(1.0, -1.0), col, time, orange);\n}\n// rotational pattern.\nvoid rotatePattern(in vec2 p, inout vec3 col, float time){\n  setRotatePattern(p, col, time, red);\n  setRotatePattern(p.yx * vec2(-1.0, 1.0), col, time, blue);\n  setRotatePattern(-p, col, time, green);\n  setRotatePattern(p.yx * vec2(1.0, -1.0), col, time, orange);\n  return;\n}\n// mainCode.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 col;\n  setBackgroundColor(p, col);\n  float time = mod(iTime, 3.0);\n  float id = floor(time * 2.0);\n  if(id == 0.0){ normalPattern(p, col, time); }\n  if(id == 1.0){ rotatePattern(p, col, mod(time, 0.5)); }\n  if(id == 2.0){ normalPattern(p, col, time - 0.5); }\n  if(id == 3.0){ normalPattern(p, col, time - 0.5); }\n  if(id == 4.0){ rotatePattern(p.yx * vec2(1.0, -1.0), col, mod(time, 0.5)); }\n  if(id == 5.0){ normalPattern(p, col, time - 1.0); }\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lscWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 252, 291, 291, 497], [498, 518, 569, 569, 616], [617, 636, 712, 725, 1180], [1181, 1204, 1280, 1280, 1998], [1999, 2018, 2076, 2076, 2283], [2284, 2307, 2365, 2365, 2582], [2583, 2596, 2650, 2650, 3221]], "test": "timeout"}
{"id": "3lsczn", "name": "Flower Petals", "author": "andraantariksa", "description": "Plotting power of 2", "tags": ["math", "line", "basiclearn"], "likes": 3, "viewed": 56, "published": "Public", "date": "1591280921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    vec3 backgroundColor = vec3(1.0, 0.8, 0.79);\n    \n    vec2 d = vec2(0.5) - st;\n    float r = length(d);\n    \n    float time = abs(mod(iTime, 10.0) - 5.0);\n    \n    float f = cos(atan(d.y, d.x) * time + iTime);\n    \n    backgroundColor += step(0.3 * f, r) * vec3(1.0);\n    \n    fragColor = vec4(backgroundColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 127, 127, 494]], "test": "timeout"}
{"id": "3lsczr", "name": "pixel goose paws", "author": "postviolet", "description": "The result of third week of learning shaders with Book of Shaders.", "tags": ["2d", "bookofshaders", "2dshaders"], "likes": 4, "viewed": 180, "published": "Public API", "date": "1591293571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec2 _st, vec2 _size){\n    _size = vec2(0.940,0.460)-_size*0.532;\n    vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st);\n    uv *= smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = fragCoord.xy/iResolution.xy;\n  vec3 color = vec3(0.0);\n\n  st.x *= 32.0;\n  st.y *= 8.0;\n\n  st.x +=  step(1., mod(st.y,2.0)) * fract(st.x);\n  st.y +=  step(1., mod(st.x,2.0)) * fract(st.y)+(iTime);\n\n  vec2 ipos = floor(st);\n  vec2 fpos = fract(st);\n  color = vec3(step(0.332, random(ipos+iTime/24.)));\n\n  fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 213], [215, 215, 243, 243, 351], [353, 353, 410, 410, 756]], "test": "timeout"}
{"id": "3lSczz", "name": "Parabola Segment - distance 2D", "author": "iq", "description": "The exact distance to a parabola segment given its height and width, which involves solving a cubic. Just an adaptation of [url]https://www.shadertoy.com/view/ws3GD7[/url]", "tags": ["2d", "sdf", "distance", "parabola"], "likes": 15, "viewed": 1140, "published": "Public API", "date": "1593535638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The exact distance to a parabola segment given its height\n// and width, which involves solving a cubic. Just an\n// adaptation of https://www.shadertoy.com/view/ws3GD7\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat sdParabola( in vec2 pos, in float wi, in float he )\n{\n    pos.x = abs(pos.x);\n\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q);\n    }\n    else        // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n    }\n    \n    x = min(x,wi);\n    \n    return length(pos-vec2(x,he-x*x/ik)) * \n           sign(ik*(pos.y-he)+pos.x*pos.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/2.0;\n\tfloat w = 0.7+0.69*sin(iTime*0.61+0.0);\n    float h = 0.4+0.35*sin(iTime*0.53+2.0);\n    \n    // sdf\n    float d = sdParabola( p, w, h );\n    \n    float ra = 0.2*(0.5+0.5*cos(1.4*iTime));\n    d = (cos(0.5*iTime)>0.0) ? abs(d) - ra : d;\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.0,1.1,1.2);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdParabola(m, w, h );\n    d = (cos(0.5*iTime)>0.0) ? abs(d) - ra : d;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // width and height\n    d = length(p-vec2(0.0,h))-0.02;\n    d = min(d, length(p-vec2(w,0.0))-0.02);\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0,0.01,d) );\n    \n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSczz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1403, 1403, 1462, 1462, 2093], [2095, 2095, 2150, 2150, 3276]], "test": "timeout"}
{"id": "3lsyWS", "name": "Kelp forest bubbles", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/tlscRs]\"Rainy jungle\"[/url] shader, but it looks more like a kelp forest.", "tags": ["3d", "raymarching", "bubbles"], "likes": 1, "viewed": 195, "published": "Public API", "date": "1592943845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define r iResolution\nint surface_color;\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 jungle_color(vec3 p)\n{\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    uv += ceil(col+sin((col.x+col.y)));\n    col /= sin(uv.x);\n    col2 = col2+col;\n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\nvec3 animate_rain(vec3 p){\n    p.y -= iTime*200.0;\n    vec3 p1 = p/100.0;\n    p += vec3(sin(p1+p1.yzx))*33.33;\n    return p;\n}\n\nvec3 rain_color(in vec3 uv)\n{\n    //uv /= scale;\n    uv = animate_rain(uv);\n    //uv /= scale;\n    \n    uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(sin(vec2(uv.x, uv.y)));\n        uv.x = uv.y + uv.x;\n        uv.y = uv.x - uv.y;\n    }\n    return vec3((lar * .5), lar*.7, lar)*1.5;\n}\n\n\nfloat rainSDF(vec3 p) {\n    p *= 5.0;\n    p = animate_rain(p);\n\n    float to_return = 3.9 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n    return to_return;\n}\n\n\nfloat jungleSDF(vec3 p) {\n    p /= 40.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  3.9 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat sceneSDF(vec3 p){\n    float jungle = jungleSDF(p);\n    float rain = rainSDF(p);\n\tfloat to_return = min(jungle,rain);\n    if(to_return == jungle){\n    \tsurface_color = 1;\n    }\n    else{\n    \tsurface_color = 2;\n    }\n    return to_return;\n}\n\nvec3 surface_color1(vec3 p){\n    if(surface_color == 1){\n    \treturn jungle_color(p);\n    }\n    else if(surface_color == 2){\n    \treturn rain_color(p);\n    }\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    float scale = .1;\n    vec3 d=vec3(U/r.xy-.5,.5),p=vec3(0,6,t),q;\n    const int iterations = 99;\n    for(int i=0;i<iterations;i++)\n    {\n        p+=d*sceneSDF(p/scale)*scale;\n        if(i==iterations-5)q=p+=d=vec3(.6);\n    }\n    o+=vec4(surface_color1(p*5.0)/5.0,0)*length(p-q)+(p.z-t)/float(iterations/3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 135, 135, 429], [675, 675, 701, 701, 801], [803, 803, 832, 851, 1131], [1134, 1134, 1157, 1157, 1315], [1318, 1318, 1343, 1343, 1468], [1470, 1470, 1493, 1493, 1715], [1717, 1717, 1745, 1745, 1876], [1878, 1878, 1919, 1919, 2231]], "test": "error"}
{"id": "3lsyzf", "name": "test:TexturedRayMarchedObjects", "author": "mehow_one", "description": "Attempt to understand how to texture a ray marched object with an image", "tags": ["raymarch", "metaballs", "normals", "mapping", "uvs"], "likes": 2, "viewed": 131, "published": "Public", "date": "1592659208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 t3(sampler2D tex, vec3 p, vec3 n){\n \treturn  (texture(tex,p.xy*0.25).rgb*n.z*n.z\n            +texture(tex,p.zy*.25).rgb*n.x*n.x\n            +texture(tex,p.xz*.25).rgb*n.y*n.y);\n}\n\nvec3 calculateSurface(vec3 point, vec3 normal) {\n     return t3(iChannel0, point, normal);\n}\n\nvec3 calculateLighting(vec3 point, vec3 normal, float dist) {\n    vec3 lightDirection = vec3(1., 1., 1.);\n    \n\treturn vec3(dot(normal, lightDirection));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\tfloat dist;\n\tfor(int i = 0; i < 32; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tdist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(1.0, depth);\n\tvec3 n = calcNormal(p);\n    \n    vec3 surface = calculateSurface(p, n);\n    vec3 lighting = calculateLighting(p, n, dist);\n    \n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec4 col = vec4(0.);\n    \n    if (dist == -1.) {\n        col = vec4(0.);\n    } else {\n        col = vec4(n * lighting, 1.);\n    }\n    \n    \n    //vec3 col = (0.5 + 0.5 * cos((b + iTime * 1.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    //col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col);\n}\n\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 40, 40, 184], [186, 186, 234, 234, 278], [280, 280, 341, 341, 435], [437, 437, 489, 489, 588], [590, 590, 625, 625, 649], [652, 652, 671, 671, 1007], [1009, 1009, 1039, 1039, 1321], [1323, 1323, 1380, 1380, 2328]], "test": "error"}
{"id": "3lsyzr", "name": "Sdf blob", "author": "stlsnk", "description": "A blob made from the smooth union of two spheres with three lights: blue fixed directional, green moving direction and red moving point. \nBy taking the derivative of the distance field, we can calculate the normals at any point.", "tags": ["3d", "raytracing", "sdf", "light"], "likes": 3, "viewed": 334, "published": "Public API", "date": "1591290424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// position of the green/yellow light\nvec3 gpos;\n\nfloat dot2(in vec3 v) { return dot(v, v); }\n\nfloat sdf_sph(in vec3 p, in float r) {\n  return length(p) - r;\n}\n\n// the main blob made from two sphere\nfloat sdf_min(in vec3 p) {\n    float a = sdf_sph(p - vec3(-0.3, 0.0, 0.0), 0.3);\n    float b = sdf_sph(p - vec3(0.2, 0.0, -0.2), 0.5);\n    float res = exp2( -32.*a ) + exp2( -32.*b );\n    return -log2( res ) / 32.;\n}\n\n// added a new sphere at the position of the purple light\nfloat sdf_uni(in vec3 p) {\n    return min(sdf_min(p), sdf_sph(p - gpos, 0.05));\n}\n\nfloat sdf(in vec3 p) {\n    return sdf_uni(p);\n}\n\n// normal vector, gradient of sdf at p\nvec3 d_sdf(in vec3 p) {\n    return vec3(\n               (sdf(p) - sdf(p - vec3(0.0001, 0., 0.))) / 0.0001, \n               (sdf(p) - sdf(p - vec3(0., 0.0001, 0.))) / 0.0001,\n               (sdf(p) - sdf(p - vec3(0., 0., 0.0001))) / 0.0001\n           );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates to y in (-1, 1), origo in (0, 0), aspect is correct\n    vec2 uv = fragCoord / iResolution.y * 2.0 - vec2(iResolution.x / iResolution.y, 1);\n   \n    \n    // moving light point\n    gpos = vec3(-0.2, sin(iTime*1.414), 0.6);\n    // rotation around the y axis\n    mat3 rot = mat3(cos(iTime), 0., -sin(iTime), \n                            0., 1.,          0., \n                    sin(iTime), 0., cos(iTime));\n   \tvec3 p = rot * vec3(uv, 1.);\n    vec3 dir = rot * vec3(0., 0., -1.);\n    \n    for(int i = 0; i < 16; ++i) {\n        p = p + dir * sdf(p) * 1.0;// * sign(dot(d_sdf(p), -dir));\n    }\n    \n    /* // Debug position\n    if(abs(sdf(p)) < 2.0) {\n   \t    fragColor = vec4(p * 0.5 + 0.5, 1.);\n        return;\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    //*/\n    \n    \n    /* // Debug final sdf value\n    if(sdf(p) > 0.1) {\n        fragColor = vec4(1.0);\n        return;\n    } else {\n        fragColor = vec4(sdf(p) * 10., -sdf(p) * 10., 0., 0.);\n        return;\n    } //*/\n    \n   \n    // normal vector\n    vec3 n = normalize(d_sdf(p));\n    \n    // blue color, from a fix direction\n    vec3 bdir = normalize(vec3(-0.3, 0.4, -0.3));\n   \tfloat bcol = dot(n, bdir);\n    \n    \n    // green color, from a moving direction\n    vec3 gdir = normalize(gpos - p);\n    float gcol = dot(n, normalize(gdir));\n    \n    // red color, from a moving point, with distance\n    vec3 rdir = normalize(gpos - p);\n   \tfloat rcol = pow(max(dot(n, rdir), 0.), 4.);\n    \n    \n    \n    if(sdf(p) > 0.1) { \n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n    else {\n        fragColor = vec4(rcol, gcol, bcol, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 73, 73, 93], [95, 95, 133, 133, 159], [161, 199, 225, 225, 415], [417, 475, 501, 501, 556], [558, 558, 580, 580, 605], [607, 646, 669, 669, 900], [902, 902, 959, 1030, 2617]], "test": "timeout"}
{"id": "3lSyzz", "name": "The colours unseen", "author": "Leria", "description": "A bit of color to feel alright ;-)\nChilling shader, you can rotate it, play with it and enable or not the the high quality with HIGH_DEF", "tags": ["noise", "transparency", "sound", "music", "color", "nebulae", "colours"], "likes": 9, "viewed": 323, "published": "Public API", "date": "1593532862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A bit laggy in high quality : Nvidia 920M (GPU for laptop) 16 fps, sometimes 5 || Low quality 60 fps\n//Free for any use, just let my name appears\n//Song : colour (amen) by Jasmine Thompson\n\n//Exercise : You can upgrade the code to sync the sound with the moving volume, it can slow the GPU performances \n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> IF in HIGH_DEF mode, you can :\n\t//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t1\n\n//Stretch or not the colored volume\n#define STRETCH\t\t\t0\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\n//taken from https://www.shadertoy.com/view/XsX3zB\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1., pow( 1.4, -3. ) );\n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    #if STRETCH\n   \tp *= stretching;\n    #endif\n    f = noise(p+iTime/10.); p = p*2.;\n    \n    vec3 s = 2./pow(stretching,vec3(.333));\n    \n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    #if STRETCH\n   \tp *= stretching;\n    #endif\n    f = noise(p+iTime/10.); p = p*2.;\n    \n    vec3 s = 2./pow(stretching,vec3(.333));\n    \n    #if HIGH_DEF\n    f *=  2.*noise( p ); p = p*2.;\n    f *=  4.*noise( p ); p = p*2.;\n    f *=  8.*noise( p ); p = p*2.;\n    f *= 16.*noise( p );\n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tm = Matter(pos, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), .12, RADIUS, RADIUS/8., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 12), m.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    \n    int s = 0;\n    \n    for(s; s < 140; s++)\n    {       \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(d > 0.)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }        \t\n        \n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            float n = abs(fbm(p/4.));\n;\t\n            //sort of \"iso-value\".1*max(0., abs(sin(20.*fbm(p/4.))  )); //iso valeur\n            //complement = n = max(0., 1.-10.*abs(fbm(p/4.)))\n\n            \n            float mask = smoothstep(0., \n                                    1.*RADIUS,\n                                    (RADIUS-length(center))- 128.*n) ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  );\n            \n            //How colors (rgb) are absorbed at the point p in the current iteration\n            //k is the step size\n            //4*cos(p.) is a property that defines the quantity of color which is absorbed\n            //cos(p.) is to make the non-uniform color varying effect not the animation\n             vec3 rgb_t = vec3(\n                \t\tk * 4.* f(p.x) * dens, \n                      \tk * 4.* f(p.y) * dens,\n              \t      \tk * 4.* f(p.z) * dens);    \n            \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = exp(-t_acc);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [{"id": "Mt23Rc", "previewfilepath": "https://soundcloud.com/jasmine-thompson/colour-amen?in=jasmine-thompson/sets/colour", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jasmine-thompson/colour-amen?in=jasmine-thompson/sets/colour", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[832, 905, 927, 927, 1100], [1754, 1754, 1811, 1811, 1980], [1982, 2056, 2078, 2331, 3248], [3250, 3250, 3276, 3276, 4101], [4212, 4212, 4237, 4250, 4594], [4596, 4596, 4621, 4634, 4966], [4968, 4968, 4987, 4987, 5080], [5082, 5101, 5177, 5177, 5224], [5226, 5226, 5258, 5258, 5278], [5280, 5280, 5314, 5314, 5336], [5438, 5438, 5462, 5462, 5622], [5624, 5624, 5648, 5648, 5733], [5735, 5764, 5792, 5792, 5962], [5964, 5986, 6032, 6032, 6655], [6705, 6705, 6746, 6746, 6782], [6784, 6784, 6921, 6921, 6952], [6954, 6954, 6997, 6997, 7037], [7039, 7039, 7063, 7063, 7129], [7131, 7131, 7171, 7171, 7475], [7477, 7477, 7501, 7501, 7564], [7566, 7566, 7613, 7613, 7665], [7667, 7667, 7750, 7750, 7889], [7892, 7892, 7945, 7945, 8302], [8305, 8305, 8357, 8357, 10985], [10988, 10988, 11045, 11045, 11653]], "test": "timeout"}
{"id": "3lV3WD", "name": "60612-0", "author": "jorge2017a1", "description": "/// Unknown author...-------60612-0", "tags": ["606120"], "likes": 1, "viewed": 70, "published": "Public", "date": "1590976467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// Unknown author...\n\n\n// ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n\t\n\t// object 0 : sphere\n\tfloat d0 = dist_sphere( pos, 2.3 );\n\t\n\t// object 1 : cube\n\tfloat d1 = dist_box( pos, vec3( 2.0 ) );\n\t\t\n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn max( d1, -d0 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 10.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( iTime ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lV3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 268, 308, 308, 337], [339, 339, 378, 378, 429], [431, 460, 490, 541, 764], [766, 783, 825, 851, 1684], [1686, 1715, 1742, 1742, 2076], [2078, 2094, 2163, 2163, 2413], [2415, 2436, 2484, 2484, 2660], [2662, 2694, 2725, 2725, 2881], [2883, 2883, 2940, 2960, 3464]], "test": "timeout"}
{"id": "3lXcDH", "name": "Light study / RayMarching", "author": "photonic", "description": "Raymarching and light study", "tags": ["raymarching", "light", "ambient"], "likes": 3, "viewed": 88, "published": "Public", "date": "1591916493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Takes a point in the space\n\n#define FAR 20.\n\n\nfloat map( in vec3 pos )\n{\n    \n \tfloat d1 = length(pos)-0.25;\n    \n    float d2 = pos.y - ( - 0.25);\n\n    float t = iTime*10.0;\n    vec3 rotation = vec3(sin(t), 0.0, cos(t));\n    pos += rotation / 3.0;\n    float d3 = length(pos)- 0.05;\n    \n    return min(min(d1, d3), d2);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.0001, 0.0);\n \treturn normalize ( vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                           \tmap(pos+e.yxy)-map(pos-e.yxy),\n                           \tmap(pos+e.yyx)-map(pos-e.yyx) ) );   \n}\n\nfloat castRay( in vec3 ro, vec3 rd ) {\n  float t = 0.0;\n    for (int i=0; i<100; i++)\n    {\n    \tvec3 pos = ro + t*rd;\n        float h = map( pos );\n        // h < 0.001 means that we are inside the sphere\n        if(h<0.001 || t>FAR ) break;\n        t += h;\n        if ( t>FAR ) break;\n    }   \n    if (t>FAR) t = -1.0;\n    \n    return t;\n}\n\n//Code provided by @Shane , thanks man!\nfloat soft(vec3 ro, vec3 ld, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable...\n    const int maxIterationsShad = 32; \n    \n    float shade = 1.0;\n    float t = 0.; \n    float end = FAR;//max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n  \n    vec3 rd = ld;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        //shade = min(shade, k*d/t);\n        // Subtle difference. Thanks to IQ for this tidbit. I've tweaked this just a little to \n        // help with shadow overlap... Well, I think it helps, but who knows? \n        shade = min(shade, smoothstep(.25, .75, k*d/t));\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .025, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. \n    return max(shade, 0.); \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    //CAMERA\n    float an = -iMouse.x/iResolution.x * 10.;\n\tvec3 ro = vec3(1.0*sin(an), 0.0, 1.0*cos(an));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );    \n    \n    vec3 col = vec3(0.4,0.7,0.9) - .8*rd.y;\n    //col = mix( col, vec3(0.7, 0.75, 0.85), exp(-10.0*rd.y) );\n\t\n   \n    float t = castRay( ro, rd );\n    if ( t > 0.0 )\n    {\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\t\n        vec3 mate = vec3(0.18);\n        \n        vec3 sunpos = vec3(0.8, 0.4, 0.2);\n        vec3 sun_dir = normalize(vec3(0.8, 0.4,0.2 ) );\n        float sun_dif = clamp( dot(nor, sun_dir), 0.0, 1.0);\n        //float sun_shadow = soft(pos + nor*0.0011, sun_dir, nor, 12.);\n       \tfloat sun_shadow = softshadow(pos, sun_dir, 0.1, 1.0, 2.0); \n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0); \n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0); \n        \n        col = mate*vec3(7.0, 4.5, 3.0)*sun_dif*sun_shadow;   \n        col += mate*vec3(0.5, 0.8, 0.9)*sky_dif;\n        col += mate*vec3(0.7, 0.3, 0.2)*bou_dif* 5.0;\n\n    }\n    \n    col = pow( col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXcDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 74, 74, 324], [326, 326, 358, 358, 574], [576, 576, 614, 614, 917], [919, 959, 1005, 1085, 2402], [2404, 2404, 2481, 2481, 2694], [2696, 2696, 2753, 2753, 4145]], "test": "timeout"}
{"id": "3lXcR2", "name": "menger sponge fixv1", "author": "jorge2017a1", "description": "menger sponge fixv1", "tags": ["mengersponge", "fix", "v1"], "likes": 5, "viewed": 81, "published": "Public", "date": "1592438911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*1.+sin(p.y*1.))*0.3;\n    return (length(p)-1.)*1.5;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.42;\n    float dist2 =map(p);\n    float dist =sdBox(p- vec3(0.0), vec3(-0.5+abs(dist2)));\n    \n    \n    \n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n        \n\t\tscale *= 3.0;\n\t}\n\n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    vec3 ro = vec3(0.5+sin(iTime), 0.25, 1.5+ 2.0*cos(time));\n     //ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXcR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 520, 547, 547, 578], [580, 580, 611, 611, 702], [705, 705, 728, 728, 865], [867, 867, 897, 897, 1034], [1084, 1084, 1153, 1232, 1273], [1275, 1275, 1357, 1357, 1588], [1590, 1590, 1650, 1650, 1791], [1840, 1895, 1918, 1918, 2053], [2055, 2055, 2081, 2081, 2138], [2140, 2140, 2180, 2180, 2214], [2218, 2218, 2254, 2254, 2341], [2344, 2344, 2391, 2391, 2424], [2426, 2426, 2451, 2451, 2466], [2469, 2469, 2488, 2488, 2558], [2561, 2590, 2608, 2608, 2881], [2941, 2941, 2970, 2970, 3158], [3160, 3160, 3201, 3201, 3377], [3379, 3379, 3420, 3420, 3572], [3574, 3574, 3595, 3595, 3725], [3727, 3727, 3754, 3754, 4004], [4061, 4105, 4122, 4122, 4193], [4218, 4310, 4335, 4335, 4598], [4656, 4656, 4713, 4713, 5175]], "test": "timeout"}
{"id": "3lXcRB", "name": "Satellite Round", "author": "winsons", "description": "simulate satellite round master star", "tags": ["practise"], "likes": 3, "viewed": 40, "published": "Public", "date": "1592390063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Camera\n{\n\tvec3 origin;\n    vec3 target;\n    vec3 up;\n    float vfov;\n    float aspect_ratio;\n    float focal_length;\n};\n\nmat4 getViewMatrix(Camera cam)\n{\n    vec3 forward = normalize(cam.target - cam.origin);\n    vec3 right = normalize(cross(forward, cam.up));\n    vec3 up = normalize(cross(right, forward));\n    return mat4(\n        vec4(right, .0),\n        vec4(up, .0),\n        vec4(forward, .0),\n        vec4(cam.origin.x, cam.origin.y, cam.origin.z, 1.0)\n    );\n}\n\nvec3 getRay(vec2 uv, Camera cam)\n{\n    float half_height = cam.focal_length * tan(radians(cam.vfov / 2.0));\n    float half_width = half_height * cam.aspect_ratio;\n    vec3 left_bottom = vec3(-half_width, -half_height, cam.focal_length);\n    vec4 point = vec4(left_bottom + vec3(2.0 * half_width, .0, .0) * uv.x + vec3(.0, 2.0 * half_height, .0) * uv.y, 1.0);\n    point = getViewMatrix(cam) * point;\n    return normalize(point.xyz - cam.origin);\n}\n\nfloat sphereSDF(vec3 point, vec3 center, float radius, vec3 round_dir, vec3 round_radius)\n{\n    return length(point - center - round_radius * round_dir) - radius;\n}\n\nfloat mainStarSDF(vec3 point)\n{\n    return sphereSDF(point, vec3(.0, .0, 1.0), 1.0, vec3(.0), vec3(.0));\n}\n\nfloat roundStarSDF(vec3 point)\n{\n    return sphereSDF(point, vec3(.0, .0, 1.0), .3, vec3(sin(iTime), cos(iTime), cos(iTime)), vec3(1.5, 1.0, 1.5));\n}\n\nint getStarType(vec3 point)\n{\n    if (roundStarSDF(point) < mainStarSDF(point))\n    {\n        return 1;\n    }\n    return 2;\n}\n\nvec3 getMainStarColor(vec3 point)\n{\n    float distance = point.y + .3;\n    float bar_count = 7.0;\n    float bar_height = .3 / bar_count;\n    if ( mod(distance / bar_height, 2.0) < 1.0 )\n    {\n        return vec3(.8, .6, .6);\n    }\n    return vec3(.8, .8, .8);\n}\n\nfloat sceneSDF(vec3 point)\n{\n    return min(mainStarSDF(point), roundStarSDF(point));\n}\n\nvec3 getNormal(vec3 p)\n{\n\treturn normalize(vec3(sceneSDF(vec3(p.x+0.0001,p.y,p.z)) -sceneSDF(vec3(p.x-0.0001,p.y,p.z)),\n                               sceneSDF(vec3(p.x,p.y+0.0001,p.z)) -sceneSDF(vec3(p.x,p.y-0.0001,p.z)),\n                               sceneSDF(vec3(p.x,p.y,p.z+0.0001)) -sceneSDF(vec3(p.x,p.y,p.z-0.0001))                 \n                              ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // render sky\n    //fragColor.xyz = mix(vec3(55.0,87.0,99.0)/225.0,vec3(121.0,249.0,255.0)/225.0,uv.y );\n    fragColor.xyz = mix(vec3(14.0,11.0,23.0)/225.0,vec3(74.0,71.0,73.0)/225.0,uv.y );\n    \n    Camera cam;\n    cam.origin = vec3(.0, .0, -5.0);\n    cam.target = vec3(.0, .0, .0);\n    cam.up = vec3(.0, 1.0, .0);\n    cam.vfov = 45.0;\n    cam.aspect_ratio = iResolution.x / iResolution.y;\n    cam.focal_length = 1.0;\n    \n    vec3 point = cam.origin;\n    vec3 ray = getRay(uv, cam);\n    for (int i = 0; i < 250; ++i)\n    {\n        float distance_to_sphere = sceneSDF(point);\n        if (distance_to_sphere < 0.00001)\n        {\n            vec3 light_pos = vec3(4.0, 5.0, -5.0);\n            \n            vec3 light_color = vec3(1.0, 1.0, 1.0);\n            vec3 ambient_color = vec3(.0, .0, .0);\n            vec3 albedo_color;\n            vec3 specular_color = vec3(.0, .8, .0);\n            float specular_gloss = 100.0;\n            \n            if (getStarType(point) == 1)\n            {\n                albedo_color = vec3(.9, .9, .9);\n            }\n            else\n            {\n                albedo_color = getMainStarColor(point);\n            }\n            \n            vec3 world_normal = getNormal(point);\n            vec3 world_light_dir = normalize(light_pos);\n            vec3 world_view_dir = normalize(cam.origin - point);\n            vec3 specular_h_dir = normalize(world_light_dir + world_view_dir);\n            \n            vec3 ambient = ambient_color;\n            vec3 diffuse = light_color * albedo_color * max(dot(world_normal, world_light_dir), 0.0);\n            vec3 specular = light_color * specular_color * pow(max(dot(world_normal, specular_h_dir), .0), specular_gloss);\n            fragColor = vec4(ambient + diffuse + specular, 1.0);\n            return;\n        }\n        point = point + ray * distance_to_sphere;\n    }\n    \n    // Output to screen\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXcRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 160, 160, 475], [477, 477, 511, 511, 923], [925, 925, 1016, 1016, 1089], [1091, 1091, 1122, 1122, 1197], [1199, 1199, 1231, 1231, 1348], [1350, 1350, 1379, 1379, 1475], [1477, 1477, 1512, 1512, 1738], [1740, 1740, 1768, 1768, 1827], [1829, 1829, 1853, 1853, 2206], [2208, 2208, 2265, 2315, 4245]], "test": "timeout"}
{"id": "3lXcz4", "name": "Jupiter Shpere", "author": "TAKUSAKU", "description": "Jupiter", "tags": ["jupiter", "shpere"], "likes": 1, "viewed": 50, "published": "Public", "date": "1591509064", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define r iResolution\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    vec3 u=vec3(2.*U-r.xy,r.y);\n    u=normalize(vec3(u.xy,sqrt(max(u.z*u.z-dot(u.xy,u.xy)*3.,0.))));\n    for(int i=0;i<6;i++)\n    {\n        float l=length(u);\n        u.x+=sin(u.y+t*.3)*5.;\n        u.y+=cos(u.x+t*.1+l);\n        o=cos(l+vec4(.3,.1,0,0));\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 80, 80, 342]], "test": "timeout"}
{"id": "3lXczf", "name": "Day 182", "author": "jeyko", "description": "ooo", "tags": ["mdtmjvm"], "likes": 7, "viewed": 195, "published": "Public API", "date": "1592605313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\nfloat sdBox(vec3 p, vec3 s){p = abs(p) - s; return max(p.x,max(p.y,p.z));}\n\n#define pmod(p,j) mod(p - 0.5*j,j) - 0.5*j \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv*=3.;\n    \n    uv.xy += vec2(sin(iTime)/6.,cos(iTime)/5.);\n    \n    vec3 col = vec3(0.4,0.6,0.5)/1.;\n\n    \n    vec3 p = vec3(uv,1.);\n    #define pi acos(-1.)\n    \n    p.yx *= rot(0.0*pi );\n    \n    p.yz *= rot(0.25*pi + 0.  - iTime*0.02);\n    \n    p.xz *= rot(0.25*pi + sin(iTime)/20.);\n    \n    \n    p /= dot(p,p);\n    \n    \n    p.x += iTime/20.;\n    /*\n    p.x -=  iTime/10.;\n    p.y +=  iTime/30.;\n    \n    \n    p.z -= iTime/20.;\n    */\n    \n    p = pmod(p,0.45);\n    \n    \n    float d;\n    \n    d = length(p-0.1)-0.1;\n    col = mix(col,vec3(0.1,0.4,0.6)/5.,smoothstep(0.002,0.,abs(d)-0.03));\n   \n    \n    // --\n    d = sdBox(p-0.01,vec3(0.14,0.3,0.1)/1.);\n    col = mix(col,vec3(0.4,0.9,0.7)/0.6,smoothstep(0.001,0.,d-0.01));\n    \n    \n    d = sdBox(p,vec3(0.14,0.3,0.1)/1.);\n    col = mix(col,vec3(1,0.9,0.4),smoothstep(0.001,0.,d));\n    \n    col = mix(col,vec3(0.44,0.71,0.91),smoothstep(0.002,0.,abs(d)-0.01));\n    \n    \n    \n    // --\n    \n    d = sdBox(p-0.01,vec3(0.1,0.1,0.1)/1.);\n    col = mix(col,vec3(0.1,0.4,0.6)/20.,smoothstep(0.002,0.,d));\n    \n    d = sdBox(p,vec3(0.1,0.1,0.1)/1.);\n    col = mix(col,vec3(0.1,0.4,0.6),smoothstep(0.002,0.,d));\n    \n    \n    \n    \n    p.yx *= rot(0.5*pi);\n    d = sdBox(p,vec3(0.02,0.02,0.4)/1.);\n    col = mix(col,vec3(0.9,0.4,0.6),smoothstep(0.002,0.,abs(d)-0.01));\n    \n    p.yx *= rot(-0.5*pi);\n    col /= 1. + col;\n    col = smoothstep(0.,1.,col*1.6);\n    \n    col = pow(col,vec3(0.45454));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 79, 79, 125], [172, 172, 229, 229, 1778]], "test": "ok"}
{"id": "3lXyDN", "name": "Circular conic angle", "author": "supah", "description": "Circular conic", "tags": ["gradient", "angle", "circular", "conic"], "likes": 1, "viewed": 80, "published": "Public", "date": "1592072697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize UV Coordinates\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    // Radial\n    uv = vec2(length(uv), atan(uv.x, uv.y) / 3.14159265 + iTime * .3);\n    \n    // Pattern\n    vec2 pattern = vec2(.3, 2.5); // => Change values to change pattern\n    uv = fract(uv * pattern);\n    \n    // Color\n    vec3 col = vec3(uv.y, uv.x, .5);\n    \n    // Add shadow\n    col *= 1. - vec3(col.r) * .9;\n    \n    // Enjoy\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 89, 527]], "test": "ok"}
{"id": "3lXyWH", "name": "The Factory Must Grow !", "author": "Terah", "description": "The Factory Must Grow !", "tags": ["2d", "infinite", "conveyor", "factory"], "likes": 4, "viewed": 162, "published": "Public", "date": "1592169451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// utils\n\nconst float pi = acos(-1.);\nconst float tau = 2.*pi;\n\nfloat rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 a;\n\n#define chance(seed,pct)        rand(seed) < pct \n#define blink(x,delay,duration) step(mod(x, delay), duration)\n#define stairs(x,t)          \t(floor(x) + smoothstep(t*.5, 1.-t*.5, fract(x)))\n#define linearstep(a, b, x) \tclamp(((x)-(a))/((b)-(a)), 0., 1.)  \n#define aastep(s,x)\t\t\t\tlinearstep((s)-(.5*scale)/iResolution.y, (s)+(.5*scale)/iResolution.y, x)\n#define square(p,r)             ( a = aastep(abs(p),r), a.x*a.y )\n#define disc(p,r)               aastep(length(p), r)\n\nvoid paint(inout vec4 canvas, vec3 color, float mask) {\n\tcanvas = vec4(mix(canvas.xyz, color, mask), min(1.,canvas.w+mask));\n}\nvoid paint(inout vec4 canvas, vec4 shape) {\n\tpaint(canvas, shape.xyz, shape.w);\n}\n\n// shader\n\nfloat scale = 10.;\n\n\nvec4 node(vec2 p, vec2 id) {\n    vec4 canvas = vec4(0);\n        \n    \n    float c = rand(id.x);\n    float visible = step(chance(c*13., .5)?.2:.8, rand(id.x*15.));\n    \n    \n    float type = rand(5.7*id.y);\n    bool r = chance(3.7*id.y, .5);\n    \n    if (type < .3) { // bobine\n        paint(canvas, r?vec3(.7,.3,.1):vec3(.9,.7,.1), disc(p, .35)*visible);\n        paint(canvas, vec3(.2), disc(p, .28)*visible);\n        paint(canvas, vec3(.05), disc(p, .15)*visible);\n    } else if (type < .7) { // cargo\n        paint(canvas, r?vec3(.1,.1,.3):vec3(.1,.1,.15), square(p, vec2(.51, .35))*visible);\n        p.x = mod(p.x+.025, .2);\n        paint(canvas, r?vec3(.2,.2,.4):vec3(.2,.2,.25), square(p, vec2(.06, .30))*visible);\n    } else { // chip\n        paint(canvas, r?vec3(.1,.3,.1):vec3(.25,.15,.1), square(p, vec2(.35, .35))*visible);\n        paint(canvas, vec3(.5), square(abs(p)-vec2(.1,.0), vec2(.03, .35))*visible);\n        paint(canvas, vec3(.1), square(p, vec2(.25, .25))*visible);\n        paint(canvas, vec3(.4), square(abs(p)-vec2(.0,.1), vec2(.15, .02))*visible);\n    }\n            \n    return canvas;\n}\n\nvec4 belt(vec2 p, vec2 id, float way) {\n        \n \tvec4 canvas = vec4(0);\n    \n    for(int i=-1; i<7; ++i) {\n        \n        vec3 col = mix(vec3(.4), vec3(.7), aastep(0., mod(abs(float(i)), 2.)-.5));\n        \n        vec2 c = (p-way*vec2(float(i)*.25, .0));\n        \n        paint(canvas, col, disc(c, .5));\n    }\n    \n    \n    paint(canvas, node(p, id));\n        \n    return canvas;\n}\n\nvec4 border(vec2 p, vec2 id) {\n    \n    vec4 canvas = vec4(0);\n       \n\n    vec3 col = vec3(.1);   \n    float mask = aastep(.4, abs(p.y));\n    \n    paint(canvas, col, mask);\n    \n    return canvas;\n}\n\nvec3 grid(vec2 p) {\n       \n    vec4 canvas = vec4(0);\n    \n    vec2 id = vec2(0., floor(p.y*scale));\n    \n    p.y = fract(p.y*scale)-.5;\n\n    float dx = rand(id.y)*2.-1.;\n        \n    vec4 b = border(p, id);\n    \n    p.x += stairs(dx*iTime*.15, .5);\n    \n    id.x = floor(p.x*scale + id.y*100.);\n    \n    p.x = fract(p.x*scale)-.5;\n    \n     \n    paint(canvas, belt(p, id, sign(dx)));\n    paint(canvas, b);\n    \n    //col.xy = p;\n    \n    return canvas.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n        \n    float t = iTime;\n    \n    scale = 4.+10.*floor(mod(t/4., 3.));\n\n    t = stairs(-t, .25);\n    \n    \n    uv += vec2(0., -t/scale);\n    col = grid(uv);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 170], [655, 655, 710, 710, 781], [782, 782, 825, 825, 863], [897, 897, 925, 925, 2008], [2010, 2010, 2049, 2049, 2396], [2398, 2398, 2428, 2428, 2597], [2599, 2599, 2618, 2618, 3059], [3061, 3061, 3118, 3118, 3401]], "test": "error"}
{"id": "3lXyWs", "name": "SDF Soft Shadows & AO", "author": "Assossa", "description": "AO loosely based on https://www.youtube.com/watch?v=FkVlF5OzLcM", "tags": ["raymarching", "sdf", "shadows", "softshadows", "ao"], "likes": 8, "viewed": 191, "published": "Public", "date": "1593379882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RAYMARCH_STEPS 64\n#define FAR_PLANE 10.\n#define AO_STEPS 12\n#define AO_MAX_DIST 4.\n#define FLOOR_SCALE 4.\n#define CAMERA_SPEED 0.02\n\nvec2 cameraPosition(float t) {\n    return vec2(\n        cos(t * CAMERA_SPEED) * 100.,\n        sin(t * CAMERA_SPEED) * 100.\n    );\n}\n\nmat3 viewMatrix(vec3 eye, vec3 lookAt) {\n    vec3 f = normalize(lookAt - eye);\n    vec3 s = normalize(cross(f, vec3(0,1,0)));\n    vec3 u = cross(s, f);\n    return mat3(s, u, f);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene(vec3 p) {\n    vec2 intPos = floor(p.xz * FLOOR_SCALE);\n    float boxScale = 1. / FLOOR_SCALE;\n    \n    float dist = 2. * FAR_PLANE;\n    for(int x = -1; x <= 1; ++x) {\n        for(int y = -1; y <= 1; ++y) {\n            vec2 adjPos = intPos + vec2(x, y);\n            ivec2 texUV = ivec2(mod(adjPos, 256.));\n            float height = texelFetch(iChannel0, texUV, 0).r * 0.2 + 0.1;\n            vec3 boxPos = vec3((adjPos + 0.5) * boxScale, 0.).xzy;\n            dist = min(dist, box(p - boxPos, vec3(boxScale * 0.5, height, boxScale * 0.5)));\n        }\n    }\n    \n    vec3 objPos = p - vec3(cameraPosition(iTime + 1.), .5).xzy - vec3(0, sin(iTime * 2.) * .1 + 0.05, 0);\n    float obj = max(\n        box(objPos, vec3(1., .1, 1.)),\n        length(objPos) - .8\n    );\n    \n    return min(dist, obj);\n}\n\nvec3 sceneNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(\n    \tscene(p + e.xyy) - scene(p - e.xyy),\n        scene(p + e.yxy) - scene(p - e.yxy),\n        scene(p + e.yyx) - scene(p - e.yyx)\n    ));\n}\n\nfloat raymarch(vec3 p, vec3 d) {\n    float dist = 0.0;\n    for(int i = 0; i < RAYMARCH_STEPS; ++i) {\n        dist += scene(p + d * dist);\n    }\n    return dist;\n}\n\nfloat occlusion(vec3 p) {\n    vec3 nml = sceneNormal(p);\n    float scale = AO_MAX_DIST / pow(2., float(AO_STEPS));\n    \n    float ocl = 0.0;\n    for(int i = 1; i <= AO_STEPS; ++i) {\n        float dist = pow(2., float(i)) * scale;\n        ocl += 1. - (max(0., scene(p + nml * dist)) / dist);\n    }\n    \n    return ocl / float(AO_STEPS);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(cameraPosition(iTime), 1.).xzy;\n    vec3 camFocus = vec3(cameraPosition(iTime + 1.), 0.).xzy;\n    vec3 camDir = viewMatrix(camPos, camFocus) * normalize(vec3(uv, 1));\n    \n    float dist = raymarch(camPos, camDir);\n    float foreground = 1. - smoothstep(FAR_PLANE, FAR_PLANE + 1., dist);\n    \n    float ocl = occlusion(camPos + camDir * dist);\n    \n    fragColor = vec4(1. - ocl) * foreground;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 171, 171, 272], [274, 274, 314, 314, 453], [455, 455, 482, 482, 573], [575, 575, 596, 596, 1381], [1383, 1383, 1409, 1409, 1606], [1608, 1608, 1640, 1640, 1770], [1772, 1772, 1797, 1797, 2109], [2112, 2112, 2167, 2167, 2656]], "test": "error"}
{"id": "3lXyzM", "name": "Worley Bulb", "author": "kesson", "description": "3D Worley Noise and raymarching, learning GLSL.\n\nSources:\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE for the Ray Marching tutorial\nhttps://www.youtube.com/watch?v=4066MndcyCk for the Worley Noise tutorial", "tags": ["procedural", "raymarching", "voronoi", "noise", "worley"], "likes": 7, "viewed": 147, "published": "Public", "date": "1591627909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Raymarching and Worley Noise\n * Made while learning some GLSL techniques\n *\n * Thanks to https://www.youtube.com/watch?v=PGtv-dBi2wE for the Ray Marching tutorial\n * Thanks to https://www.youtube.com/watch?v=4066MndcyCk for the Worley Noise tutorial\n *\n */\n\n#define RAYMARCH_MAX_STEPS \t\t100\n#define RAYMARCH_MAX_DIST \t\t50.0\n#define RAYMARCH_SURFACE_DIST \t0.01\n\n// From https://www.youtube.com/watch?v=l-07BXzNdPw\nvec3 randomVector(vec3 p) {\n\tvec3 a = fract(p.xyz*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    vec3 v = fract(vec3(a.x*a.y, a.y*a.z, a.z*a.x));\n    return v;\n}\n\nvec2 worley(vec3 uv, float t, float factor) {\n    vec3 st = uv * factor;\n    vec2 minDist = vec2(1000.0);\n \tvec3 gv = fract(st)-0.5;\n    vec3 id = floor(st);\n\n    for (float z = -1.0; z <= 1.0; z++) {\n        \n        for (float y = -1.0; y <= 1.0; y++) {\n\n            for (float x = -1.0; x <= 1.0; x++) {\n\n                vec3 offs = vec3(x, y, z);\n\n                vec3 n = randomVector(id + offs);\n                vec3 p = offs + sin(n * t) * .5;\n                p -= gv;\n\n                float d = length(p);\n\n                if (d < minDist.x) {\n                    minDist.y = minDist.x;\n                    minDist.x = d;\n                } else if (d < minDist.y) {\n                    minDist.y = d;\n                }\n\n            }\n        }\n        \n    }\n    \n    return minDist;\n}\n\nfloat getDist(vec3 p, float wr) {\n\tvec4 sphere = vec4(0.0, 1.0, 0.0, 1.0 + wr);\n    \n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    float planeDist = (p.y+0.75) - wr;\n    \n    return min(sphereDist, planeDist);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n    \n    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd * dO;\n        vec2 worleyF = worley(p, iTime, 2.0);\n        float dS = getDist(p, (worleyF.y - worleyF.x)*0.2);\n        dO += dS;\n        if (dO > RAYMARCH_MAX_DIST || dS < RAYMARCH_SURFACE_DIST) break;\n    }\n    \n    vec3 d = ro + rd * dO;\n        \n    return dO;\n}\n\nvec3 getNormal(vec3 p, float wr) {\n\tfloat d = getDist(p, wr);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy, wr),\n        getDist(p - e.yxy, wr),\n        getDist(p - e.yyx, wr));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    float an = iTime*0.1;\n    vec3 lightPos = vec3(sin(an) * 4.0, 4.0, cos(an) * 4.0);\n    vec3 l = normalize(lightPos - p);\n    vec2 worleyF = worley(p, iTime, 2.0);\n    vec3 n = getNormal(p, (worleyF.y-worleyF.x));\n    \n    float dif = dot(n, l);\n    \n    float d = rayMarch(p + RAYMARCH_SURFACE_DIST * 120.0, l);\n    if (d < length(lightPos-p)) dif *= 0.25;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float an = iTime * 0.1;\n    // Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\n    vec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );//vec3(0.0, 1.0, 0.0);\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( uv.x*uu + uv.y*vv + 1.5*ww );//normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float d = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    vec2 worleyF = worley(p, iTime, 2.0);\n    \n    float dif = clamp(getLight(p), 0.0, 1.0);\n    \n    float distort = worleyF.y - worleyF.x;\n    vec3 col = vec3(dif) * distort;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXyzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 419, 446, 446, 594], [596, 596, 641, 641, 1389], [1391, 1391, 1424, 1424, 1618], [1620, 1620, 1654, 1654, 2013], [2015, 2015, 2049, 2049, 2263], [2265, 2265, 2289, 2289, 2673], [2675, 2675, 2732, 2732, 3536]], "test": "timeout"}
{"id": "3s2BWV", "name": "Fly On, Buckaroo", "author": "blackle", "description": "this time more cuter :3\n\nbuckaroo is flying to his boyfriend's house\n\nmusic is: [url]https://soundcloud.com/h4ck4y473m32/rave-3000[/url]\n\noriginal: [url]https://www.shadertoy.com/view/3sSBDV[/url]", "tags": ["ufo", "buckaroo"], "likes": 84, "viewed": 4737, "published": "Public API", "date": "1591015192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//antialising. increasing to 8 looks pretty good, but will be 8x slower\n#define AA_SAMPLES 1\n\nconst int BLM[17] = int[17](\n    0x19B12B,0x1AB56B,0x18B167,0x1AB56B,0x18952B,0x1FFFFF,\n    0x1DAA4F,0x1DAADF,0x1DAA4F,0x1DAAEF,0x1CB64F,0x1FFFFF,\n    0xA2048,0x2B6DA,0x236C9,0xAB6DA,0xAB6CA\n);\n\nfloat box(vec2 p, vec2 d) {\n    vec2 q = abs(p)-d;\n    return length(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat comp(vec3 p, vec3 ax, float ro) {\n  \n  p = erot(p,ax,ro);\n  p = asin(sin(p));\n  return length(p)-1.;\n}\n\nfloat cloudssdf(vec3 p) {\n  p.y += iTime*.2;\n  float d1 = comp(p, normalize(vec3(1,2,5)), 0.5);\n  p.y += iTime*.2;\n  float d3 = comp(p*2., normalize(vec3(3,1,1)), 2.5)/2.;\n  p.y += iTime*.2;\n  float d4 = comp(p*3., normalize(vec3(4,-2,5)), 3.5)/3.;\n  return (d1+d3+d4)/3.;\n}\n\nfloat linedist (vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat body;\nfloat beamm;\nvec3 locl;\nfloat rm;\nfloat scene(vec3 p) {\n  p.z += sin(iTime);\n  p = erot(p, vec3(0,1,0), cos(iTime)*.2);\n  beamm = 0.9*(linedist(p, vec3(0), vec3(0,0,-10))-.3-sin(p.z*3.+iTime*4.)*.05 - sin(iTime)*.2);\n  locl = p;\n  vec3 p2 =p;\n  p2.z = sqrt(p2.z*p2.z+0.02);\n  p2.z+=3.;\n  vec3 p3 =p;\n  p3.z = sqrt(p3.z*p3.z+0.02);\n  p3.z+=8.1;\n  body = length(p2)-3.8;\n  body += smoothstep(0.8,.9,sin(atan(p2.x,p2.y)*10.))*.02;\n  body += smoothstep(0.9,1.,sin(atan(p2.x,p2.y)*45.))*.003;\n  rm=length(p3)-8.525;\n  body = smin(body, rm,.01);\n  float hat = length(p-vec3(0,0,0.8))-0.7;\n  return min(min(body,hat), beamm);\n}\nfloat bpm = 124.;\nfloat eye;\nfloat buckaroo(vec3 p) {\n  float bpmt = iTime/60.*bpm;\n  float t = pow(sin(fract(bpmt)*3.14/2.), 20.);\n  p.z += sin(iTime);\n  p = erot(p, vec3(0,1,0), cos(iTime)*.2);\n  p-=vec3(0,0,0.9);\n  p.z += t*.1;\n  p.x = abs(p.x);\n  float b =  length(p)-0.2;\n  float scl = cos(bpmt*3.1415)*.05+.95;\n  b = smin(b, linedist(p, vec3(0), vec3(.3,0,.3)*scl)-.03, 0.05);\n  b = smin(b, length(p-vec3(.3,0,.3)*scl)-.07, 0.1);\n  b = smin(b, linedist(p, vec3(0), vec3(0,0,-.5))-.15, .1);\n  eye = length(p-vec3(.1,.18,.0))-.03;\n  return min(b, eye);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p)-vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 norm2(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(buckaroo(p)-vec3(buckaroo(k[0]), buckaroo(k[1]), buckaroo(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n  return vec3(r*r,g*g,b*b);\n}\n\nvec3 clouds(inout vec3 p, vec3 cam, vec3 init, int depth) {\n  p = init;\n  for (int i = 0; i < depth; i++) {\n    float dist = min(scene(p),cloudssdf(p));\n    dist = sqrt(dist*dist+0.05);\n    p += dist*cam;\n  }\n  float f1 = length(sin(p)*.5+.5)/sqrt(3.);\n  float f2 = smoothstep(0., 30., distance(p,init));\n  vec3 sun = max(0.,dot(vec3(1./sqrt(3.)), cam))*vec3(1);\n  sun = pow(sun,vec3(9)) + pow(sun,vec3(4))*srgb(0.7,0.5,0.2);\n  return mix(srgb(0.2,0.3,0.7), srgb(0.8,0.3,0.3), f1) + mix(srgb(0.2,0.4,0.7), srgb(0.7,0.7,0.7), f2) + sun;\n}\n\n\nvec3 pixel_color( vec2 uv )\n{\n  //we have the moral obligation to use every platform to speak out against injustice\n  //if you're financially comfortable, donate to bail funds or charities\n  //pick a number that makes you as uncomfortable as the police brutality\n  vec2 uv2 = uv + vec2(cos(iTime)*0.03, sin(iTime)*.1);\n  ivec2 id = ivec2(floor(vec2(55,28)-uv2*100.));\n  float blm = 1.;\n  if (id.x >= 0 && id.x < 21 && id.y >= 0 && id.y < 17) {\n    blm = (BLM[id.y] >> id.x) % 2 == 0 ? 0. : 1.;\n  }\n  float bubble = sqrt(length(pow(uv2-vec2(.44,.2),vec2(2.))))-.14;\n  uv2 = uv2 - vec2(0.38,0.2);\n  uv2 = erot(vec3(uv2,0),vec3(0,0,1),1.3-sin(iTime)*.1).xy;\n  float arrow = box((vec2(2,1)*uv2)*mat2(.71,-.71,.71,.71), vec2(.1))-.01;\n  bubble = min(bubble,arrow/1.7);\n    \n    \n  vec3 cam = normalize(vec3(1,uv));\n  \n  float bpmt = iTime/60.*bpm;\n  float t = mix(floor(bpmt) + pow(sin(fract(bpmt)*3.14/2.), 20.), bpmt, 0.8);\n  vec3 init = vec3(-8.+sin(t)*2.,0,0.1);\n  cam = erot(cam, vec3(0,0,1), t*.2);\n  init = erot(init, vec3(0,0,1), t*.2);\n  vec3 clp;\n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  float glow = 0.;\n  for (int i = 0; i < 180 && !hit; i++) {\n    dist = scene(p);\n    if (!isnan(beamm)) glow += .5/(1.+beamm*100.);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n    if(distance(p,init)>20.)break;\n  }\n  float stmp = smoothstep(-.05,.05,dist-rm);\n  vec3 lllocl = locl;\n  glow = min(glow,1.);\n  bool bdy = (dist == body);\n  vec3 n = norm(p);\n  vec3 obj = hit ? sin(n)*.5+.5 : vec3(0);\n  vec3 clds = clouds(clp, cam, init, 20);\n  if (hit) {\n    vec3 p2 = p+n*.1;\n    float ao = smoothstep(-.1,.1,scene(p2));\n    vec3 r = reflect(cam,n);\n    float tex = smoothstep(.4,.6,texture(iChannel0, lllocl.xy*.5).x);\n    tex=mix(tex,1.,stmp);\n    float fres = 1.-abs(dot(cam,n))*.98*(tex*.25+.5);\n    vec3 rflcld = clouds(p2, r, p2, 15-int(tex*5.));\n    obj = rflcld*fres*ao;\n    if (!bdy) {\n      p2 = p+cam;\n      r = refract(cam,n,1.1);\n      vec3 p5 = p;\n      bool hhit = false;\n      float bb;\n      for (int i = 0; i < 50 && !hhit; i++) {\n        bb = buckaroo(p5);\n        hhit = bb*bb< 1e-6;\n        p5+=bb*r;\n        if(distance(p5,p)>2.)break;\n      }\n      bool ey = eye==bb;\n      if (hhit) {\n        vec3 n5 = norm2(p5);\n        vec3 r5 = reflect(cam,n5);\n        float ss = smoothstep(-.05,.05,buckaroo(p5+.05));\n        float fk = length(sin(n5*vec3(.5,.5,2)+.2)*.5+.5)/sqrt(3.)*.5 + ss*.5;\n        float spec = length(sin(r5*vec3(.5,.5,2)+.2)*.5+.5)/sqrt(3.);\n        obj = fk*mix(ey ? srgb(0.1,0.1,0.1) : srgb(0.3,0.75,0.3), rflcld, 0.3) + obj*.5 + pow(spec, 8.)*(ey?1.:.15);\n      } else {\n      \tobj = obj*.5 + clouds(p2, r, p2, 20)*.9;\n      }\n    }\n  }\n  obj = obj  + srgb(0.2,0.4,0.6)*glow;\n  float fctr = smoothstep(-3.,1., distance(clp,init)-distance(p,init));\n  vec3 coll = mix(clds, obj, fctr) + glow*glow*.9*sqrt(fctr*.5+.5);\n  coll = abs(erot(sqrt(coll), normalize(sin(clp*.3+t)), 0.15));\n\n  blm =  mix(0.,blm,smoothstep(0.,.003,abs(bubble)-.01));\n  return mix(vec3(blm),coll*coll, smoothstep(0.,.003,bubble));\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    for (int i = 0; i < AA_SAMPLES+int(min(0,iFrame)); i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n        fragColor += vec4(pixel_color(uv2), 1.);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Mtj3RV", "previewfilepath": "https://soundcloud.com/h4ck4y473m32/rave-3000", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/h4ck4y473m32/rave-3000", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2BWV.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[483, 483, 510, 510, 588], [590, 590, 628, 628, 690], [692, 692, 731, 731, 800], [802, 802, 827, 827, 1076], [1078, 1078, 1119, 1119, 1206], [1208, 1208, 1247, 1247, 1317], [1365, 1365, 1386, 1386, 1951], [1981, 1981, 2005, 2005, 2510], [2512, 2512, 2531, 2531, 2642], [2644, 2644, 2664, 2664, 2787], [2789, 2789, 2827, 2827, 2857], [2859, 2859, 2918, 2918, 3396], [3399, 3399, 3428, 3661, 6446], [6448, 6448, 6469, 6469, 6528], [6530, 6530, 6587, 6587, 6895]], "test": "error"}
{"id": "3s2fD3", "name": "raymarching mouse head", "author": "deni_de", "description": "fun of Ecstatica / thx Inigo Quilez", "tags": ["raymarching"], "likes": 3, "viewed": 192, "published": "Public API", "date": "1591001239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inst: @deni_dedov\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\nfloat mouse(in vec3 pos)\n{\n    float timer = fract(iTime);\n    vec3 posEarL = vec3(pos.x - 0.27 ,pos.y - 0.35,pos.z / 0.5 - 0.1);\n    vec3 posEarR = vec3(pos.x + 0.27 ,pos.y - 0.35,pos.z / 0.5 - 0.1);\n    vec3 pEyeL = vec3(pos.x - 0.1 ,pos.y - 0.17,pos.z + 0.12);\n    vec3 pEyeR = vec3(pos.x + 0.1 ,pos.y - 0.17,pos.z + 0.12);\n    vec3 posNouse = vec3(pos.x ,pos.y - 0.11,pos.z + 0.27);\n    vec3 posNouseTick = vec3(pos.x ,pos.y - 0.135,pos.z * 0.9 + 0.30);\n    vec3 posMouth = vec3(pos.x /0.5,pos.y / 0.2 +0.25,pos.z+0.25);\n    \n    float head = length(pos) - 0.25;\n    float earR = length(posEarR) - 0.11;\n    float earRBool = length(vec3(pos.x + 0.27 ,pos.y - 0.35,pos.z / 0.5 + 0.1)) - 0.15;\n    float earLBool = length(vec3(pos.x - 0.27 ,pos.y - 0.35,pos.z / 0.5 + 0.1)) - 0.15;\n    float earL = length(posEarL) - 0.11;\n    float nouse = length(posNouse) - 0.05;\n    float eyeR = length(pEyeR) - 0.07;\n    float eyeL = length(pEyeL) - 0.07;\n    float nouseT = length(posNouseTick) - 0.05;\n    float mouth = length(posMouth) - 0.21;\n    \n    float result = head  * earR * earL * nouse;\n    result = min(result,eyeR * eyeL);\n    result = max(result,-earRBool * 0.1);\n    result = max(result,-earLBool * 0.1);\n    result = min (result,nouseT);\n    result = max (result,-mouth * .1);\n    return result;\n}\nfloat map(in vec3 pos)\n{\n    \n    float object = mouse(pos);\n    float plane = pos.y - (-0.25);\n    return min(object,plane);\n}\nvec3 cNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize( vec3(map(pos+e.xyy)-map(pos-e.xyy),map(pos+e.yxy)-map(pos-e.yxy),map(pos+e.yyx)-map(pos-e.yyx)));\n}\nfloat Raycast(in vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i <300; i++)\n    {\n        vec3 pos = ro + t * rd;\n        float h = map(pos);\n        if(h <0.001)break;\n        t += h;\n        if(t > 20.0)break;\n    }\n    if(t>20.0) t=-1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float an = iTime * 0.7;\n    \n    vec3 ro = vec3(1.0 * sin(an),0.3,1.0 * cos(an));\n    vec3 ta = vec3(0.0);\n    \n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n    vec3 v = normalize(cross(u,w));\n    \n    vec3 rd = normalize(p.x * u + p.y *v + 1.5 * w);\n\n    vec3 color = vec3(0.6,0.7,0.9) - 0.5 * rd.y;\n    color = mix(color,vec3(0.9,0.95,1.2),exp(-10.0*rd.y));\n    \n    float a = Raycast(ro,rd);\n    if(a >0.0)\n    {\n        vec3 pos = ro + a*rd;\n        vec3 norm = cNormal(pos);\n        \n        vec3 ctrl = vec3(0.21,0.21,0.21);\n\n        \n        vec3 sunDir = normalize(vec3(1.5,2.0,-1.0));\n        float shadow = step(Raycast(pos+ norm*0.001,sunDir),0.0);\n        float diff = clamp(dot(norm,sunDir),0.0,1.0);\n        float sky = clamp(0.5 + 0.5 * dot(norm,vec3(0.0,1.0,0.0)),0.0,1.0);\n        float bounce = clamp(0.5 + 0.5 * dot(norm,vec3(0.0,-1.0,0.0)),0.0,1.0);\n        \n        color = ctrl * vec3(3.0,1.5,0.25) * diff * shadow;\n        color += ctrl * vec3(0.6,0.7,0.9) * sky;\n        color += ctrl * vec3(1.1,0.5,0.15) * bounce;\n        \n        color *= 2.0;\n    }\n    \n    //exposure\n    color = pow(color,vec3(0.53));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 157, 183, 183, 1462], [1463, 1463, 1487, 1487, 1590], [1591, 1591, 1618, 1618, 1771], [1772, 1772, 1808, 1808, 2040], [2042, 2042, 2099, 2099, 3377]], "test": "timeout"}
{"id": "3s2fWK", "name": "Ray Tracer Lesson 2 - Dir Light", "author": "omegasbk", "description": "Shader made for lesson two of Darko's Gamedev Cookbook series on youtube.\nChannel: https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA", "tags": ["raytracing"], "likes": 0, "viewed": 99, "published": "Public", "date": "1591203911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Darko (omegasbk) \n//\n// Darko's Gamedev Cookbok Youtube serial\n// https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA\n//\n// Lesson 2 - Directional Light\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom; \n} camera;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;     \n} sphere;\n\nstruct Light\n{\n\tvec3 direction;    \n} light;\n\nvoid setupScene()\n{\n    camera.position = vec3(0., 0., 3.5);\n    camera.direction = vec3(0., 0., -1.);\n    camera.zoom = 1.0;\n    \n    sphere.position = vec3(0., 0., 0.);\n    sphere.radius = 0.3;\n    sphere.color = vec3(0.9, 0.2, 0.3);\n    \n    light.direction = normalize(vec3(0., -1., -0.78));\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nbool intersect(vec3 direction, out vec3 surfaceNormal)\n{\n    vec3 L = camera.position - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        float t = t0;\n        if (t1 < t0)\n        {\n            t = t1;\n        }\n        \n        vec3 Phit = camera.position + t * direction;\n        surfaceNormal = normalize(Phit - sphere.position);\n        \n        return true;\n    }  \n     \n    return false;\n}\n\nvec3 rayTrace(vec3 direction)\n{\n    vec3 surfaceNormal;\n    \n    if (intersect(direction, surfaceNormal))\n    {\n        float coeff = -dot(light.direction, surfaceNormal);                          \n        \n        return coeff * sphere.color;\n    }\n    \n    return vec3(0., 0., 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{        \n    setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 direction = normalize(vec3(uv, camera.zoom) - camera.position);\n    \n    sphere.position.y = sin(iTime * 6.) / 3.;\n    \n    \n    light.direction.x = -(iMouse.x / iResolution.x - 0.5);\n    light.direction.y = -(iMouse.y / iResolution.y - 0.5);\n    light.direction = normalize(light.direction);\n    \n    \n    \n    vec3 col = rayTrace(direction);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 388, 407, 407, 685], [687, 687, 763, 763, 1056], [1058, 1058, 1114, 1114, 1649], [1651, 1651, 1682, 1682, 1936], [1938, 1938, 1993, 1993, 2588]], "test": "ok"}
{"id": "3sBfDG", "name": "SmileFaceAnimation", "author": "fangyuan267", "description": "SmileFace", "tags": ["smileface"], "likes": 2, "viewed": 77, "published": "Public", "date": "1590983457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)     //limit value between 0.0 to 1.0\n\nfloat remap01(float a, float b, float t)  //control graph area\n{\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t)\n{\n\treturn sat((t-a)/(b-a)) * (d-c) +c;\n}\n\nvec2 within(vec2 uv, vec4 rect)     //creat a new small uv box for a part of graph\n{\n    return (uv- rect.xy)/(rect.zw - rect.xy);\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float smile)\n{   \n    uv -= 0.5;\n    uv.x *= side; //set reverse mirror effect\n    float d = length(uv);\n    \n    vec4 irisCol = vec4(.3, .5, 1.,1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1,.7, d)*.5);    //circle radius range from 0.1 to 0.7 mix two color\n    col.a = S(.5, .48, d); //length > 0.5 return 0, length < 0.48, return 1, else return smooth value\n    \n    col.rgb *= 1. - S(.45, .5, d)*.5 * sat(-uv.y-uv.x*side);  //eye shadow\n    \n    d = length(uv -m * .4); //pupil move with mouse position\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); //black circle\n    \n    irisCol.rgb *= 1. +S(.3, .05, d);  //linear iris blue color\n    float irisMask = S(.28, .25, d); \n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\n    \n    d = length(uv -m * .5);//iris move with mouse position\n    \n    float pupilSize = mix(.4, .16, smile);        //pupil\n    float pupilMask = S(pupilSize, pupilSize * 0.75, d);\n    pupilMask *= irisMask;\n    col.rgb = mix(col.rgb, vec3(0.), pupilMask); \n    \n    float t = iTime;   //highlight animation\n    vec2 offs = vec2(sin(t + uv.y *25.), sin(t + uv.x * 25.));\n    offs *= .01 * (1. -smile);\n    uv += offs;\n    \n    float highlight = S(.09, .08, length(uv-vec2(-.15, .15)));  //highlight\n    highlight += S(.06, .04, length(uv+vec2(-.08, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile)\n{\n    uv -= 0.5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;              //draw smile mouth curve\n    uv.y -= uv.x*uv.x*3. *smile;\n    uv.x *= mix(2.5, 1., smile);\n    \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    uv.y *= 1.4;  //teeth\n    uv.x -= .14;\n    uv.y -= uv.x*uv.x*10.;\n    uv.y += (abs(uv.x) *.5 +.1) ;\n    float td = length(uv - vec2(0.1, .6));   \n    \n    vec3 toothCol = vec3(1.)*S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));  \n    \n    \n    uv.y /= 1.6;  //tongue\n    uv.x += .18;\n    uv.y += uv.x*uv.x*0.9;    \n    td = length(uv + vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.55, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv)\n{\n    vec4 col = vec4(0.9, 0.65, 0.1, 1.0);\n    \n    float d = length(uv);\n    col.a = S(.5, .49, d);  //head range\n    \n    float edgeShade = remap01(.35, .5, d);  //edge shadow\n    edgeShade *= edgeShade;\n    col.rgb *= 1. - edgeShade* .5;\n    \n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d));  //outline\n    \n    float highlight = S(.42, .39, d)*0.75;  //highlight\n    highlight *= remap(.42, -.1, .75, 0., uv.y);  //half linear circle\n    highlight *= S(.18, .19, length(uv-vec2(.21, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    d = length(uv-vec2(.25,-.2));  //cheek blush\n    float cheek = S(.2, .01, d)*0.4;\n    cheek *= S(.17, .16, d);\n    col.rgb = mix(col.rgb, vec3(1.,.1,.1), cheek);\n        \n    return col;\n}\n\nvec4 Soucil(vec2 uv, float smile)\n{\n    float offs = mix(.8, 0., smile);\n    uv.y += offs;  //up down\n    \n    uv.y += uv.x*.9 -mix(.2,.4, smile);  //change curve form\n    uv.x -= mix(.0, .1, smile); //left right\n    uv -= 0.5;\n    vec4 col = vec4(.5, .28, .2, 1.);\n    \n    uv.y += uv.x*uv.x*4.5 *(1.- offs); //change curve radian\n    \n    float d = length(uv);\n    col.a = S(.5, .45, d);\n    \n    float highlight = S(.3, .05, d)*0.5 * smile;  //move with smile time\n    col.rgb = mix(col.rgb, vec3(0.9), highlight);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 m, float smile)\n{\n    vec4 col = vec4(0.);\n    \n    float side = sign(uv.x);  //return 1 if uv.x > 0, return 0 if = 0, return -1 if < 0\n    uv.x = abs(uv.x); //mirror effect\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, smile);\n    vec4 mouth = Mouth(within(uv, vec4(-.3, -.44, .3, -.14)), smile);\n    vec4 soucil = Soucil(within(uv, vec4(.08, .33, .35, .39)), smile);\n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    col = mix(col, soucil, soucil.a);  //float mix(floatx,float y,float a )  return x(1-a)+ya\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; //move vec(0.0,0.0) to the center of screen\n    uv.x = uv.x/iResolution.y *iResolution.x;  \n\n    vec2 m = iMouse.xy/iResolution.xy;  //get mouse position\n    m -= .5;\n    \n    float smile = cos(iTime) * 0.5 + .5;  //value 0.0 to 1.0\n    \n    //uv -= m;\n    uv -= m *(.25 - dot(uv, uv));  //change face direction with mouse position\n    //uv += mix(.25, -.25, smile) *(.25 - dot(uv, uv));  //change face direction by time\n\n    // Output to screen\n    fragColor = Smiley(uv, m, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 173, 173, 201], [203, 203, 261, 261, 300], [302, 302, 386, 386, 434], [436, 436, 488, 488, 1839], [1841, 1841, 1875, 1875, 2574], [2576, 2576, 2596, 2596, 3350], [3352, 3352, 3387, 3387, 3892], [3894, 3894, 3937, 3937, 4553], [4555, 4555, 4612, 4662, 5203]], "test": "timeout"}
{"id": "3tfcDl", "name": "Sun on the water (2D FBM)", "author": "noobay", "description": "A creative exploration of FBM", "tags": ["2d", "fbm", "water", "abstract"], "likes": 0, "viewed": 85, "published": "Public", "date": "1593370424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// noise and fbm taken from https://www.iquilezles.org/www/articles/fbm/fbm.html, https://www.shadertoy.com/view/Msf3WH\n// simplex, fbm and parabola SDF by - Inigo Quilez\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm( in vec2 x, in float H, in int numOctaves )\n{    \n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*noise(f*x);\n    }\n    return t;\n}\n\nfloat sdParabola( in vec2 pos, in float k )\n{    \n    pos.x = abs(pos.x);\n    \n    float p = (1.0-2.0*k*pos.y)/(6.0*k*k);\n    float q = -abs(pos.x)/(4.0*k*k);\n    \n    float h = q*q + p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        pow(-q+r,1.0/3.0) - pow(abs(-q-r),1.0/3.0)*sign(q+r) :\n        2.0*cos(atan(r,-q)/3.0)*sqrt(-p);\n    \n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\n    float parabola = sdParabola(uv, 1.0) * 0.3;\n \n    float fbmResult = fbm(uv + iTime, 0.5, 5);\n\n    vec3 col = vec3(smoothstep(parabola * vec3(1.0, 0.8, 1.0), fbmResult * vec3(0.1, 0.1, 0.86), vec3(distance(parabola , fbmResult))));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfcDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 193, 193, 308], [310, 310, 336, 336, 815], [817, 817, 872, 872, 1060], [1062, 1062, 1107, 1107, 1472], [1474, 1474, 1531, 1581, 1939]], "test": "timeout"}
{"id": "3tfcDs", "name": "JustAMandelbrot", "author": "Sampas", "description": "Visualizes Mandelbrot set, click to zoom in.", "tags": ["mandelbrot"], "likes": 0, "viewed": 33, "published": "Public", "date": "1593383491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    int N = 50;\n    float w = 3.5;\n    float ratio = iResolution.y / iResolution.x;\n    if (iMouse.z > 0.0)\n    {\n        vec2 imm = iMouse.xy / iResolution.xy;\n        imm.x = -1.8 + imm.x * w;\n        imm.y = -0.5 + imm.y * w * ratio;\n        float zoom = 10.0;\n        uv.x = imm.x - w/zoom/2.0 + uv.x * w/zoom;\n    \tuv.y = imm.y - (w/zoom * ratio)/2.0 + uv.y * w/zoom * ratio;\n        N = 150;\n    }\n    else\n    {\n        uv.x = -1.8 + uv.x * w;\n    \tuv.y = -0.5 + uv.y * w * ratio;\n    }\n    \n    float tmp = uv.y;\n    uv.y = uv.x;\n    uv.x = -tmp;\n\n    vec3 col = vec3(0.0);\n    float z_re = uv.x;\n    float z_im = uv.y;\n    int i = 0;\n    float z_low = 10000000.0;\n    for (; i < N; ++i)\n    {\n        float z_im2 = z_im*z_im;\n        float ab = z_re*z_re + z_im2;\n        z_low = min(z_low, ab);\n        if (ab > 4.0)\n        {\n            col = vec3(0.0);\n            break;\n        }\n        z_im = 2.0*z_re*z_im + uv.y;\n        z_re = z_re*z_re - z_im2 + uv.x;\n    }\n    \n    \n    float c = 0.0;\n    if (i < N)\n    {\n    \tc = float(i) / float(N);\n    }\n    c = mix(c, sqrt(z_low), abs(sin(iTime))*0.1);\n    \n    col = vec3(0.0, c, cos(iTime*2.0)*c);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfcDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1319]], "test": "timeout"}
{"id": "3tfcz4", "name": "Solar_Eclipse", "author": "TAKUSAKU", "description": "Solar Eclipse", "tags": ["sphere", "eclipse", "solar"], "likes": 10, "viewed": 69, "published": "Public", "date": "1591509408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define r iResolution\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o=vec4(0);//Required on Safari\n    vec3 u=vec3(2.*U.xy-r.xy,r.y)/3e2;\n    u=normalize(vec3(u.xy,sqrt(max(u.z*u.z-dot(u.xy,u.xy)*2.,0.))));\n    for(int i=0;i<2;i++)//for(int i=0;i<6;i++)\n    {\n        float l=length(u);\n        u.xz+=sin(u.z+t*.2+l);\n        u.y+=cos(u.x+t*.6);\n        o+=cos(l+vec4(.3,.1,0,0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 80, 80, 405]], "test": "timeout"}
{"id": "3tfczs", "name": "60's psychedelic wallpaper", "author": "Oggbog", "description": "Happy accident :-)", "tags": ["psychedelic"], "likes": 1, "viewed": 208, "published": "Public API", "date": "1592749556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *=9.;\n\n    float d = (cos(uv.x)*sin(uv.y))+iTime*3.;\n    \n    vec3 col = fract(vec3(d,1.-d/2.,d/2.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfczs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 294]], "test": "timeout"}
{"id": "3tfSzS", "name": "heart fishes", "author": "inbisibler", "description": "marching fishes", "tags": ["test"], "likes": 0, "viewed": 29, "published": "Public", "date": "1592400453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hart(vec2 p,vec2 c,float scale,float th){\n    float a=1.0;\n    vec2 pos = p - c;\n    pos = pos/scale;\n    pos = vec2(pos.x*cos(th)-pos.y*sin(th),pos.x*sin(th)+pos.y*cos(th));\n\tfloat val = pos.x*pos.x + (pos.y-sqrt(abs(pos.x)))*(pos.y-sqrt(abs(pos.x))) - a*a;\n    if (length(pos)<0.1){\n    \tval=0.0;\n    }\n\treturn val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 position = fragCoord/iResolution.xy-0.5;\n    // vec2 position = (fragCoord - iResolution.xy *0.5)/ min(iResolution.x,iResolution.y);\n\n    \n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+position.xyx+vec3(0,2,4));\n    float n=10.0;\n    for(float j=0.0;j<n;j++){\n    for(float i=0.0;i<=n;i++){\n//        vec2 center = vec2(sin(iTime+6.28*i/n)+3.5,cos(iTime+6.28*i/n))*0.2;\n        vec2 center = vec2(-iTime*0.1+0.5+fract(i*0.5)*0.1+j/n*1.4,i/n*1.0-0.5);\n        center.x = mod(center.x,1.4)-0.7;\n        col *= smoothstep(-0.3,0.3,abs(hart(position,center,0.03,sin(iTime*8.0)*0.3+1.57)));\n    }}\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 325], [327, 327, 384, 434, 1120]], "test": "timeout"}
{"id": "3tfyD4", "name": "ClassiX_Matrix", "author": "TRASHTRASH", "description": "This pattern is my \"Hello World\" each time I start a new language or framework.", "tags": ["2d", "grid", "random", "textures", "matrix", "beep", "boop", "trashtrashscifi"], "likes": 14, "viewed": 243, "published": "Public", "date": "1592068218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//created by TRASHTRASH aka Joshua deLorimier\n\n#define iter 40.0\n#define scaleSpeed 3.0\n#define satSpeed 4.2\n\n// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n//noise\nfloat N2(vec2 p) {\t\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //create coordinates \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    //iterate to make grid\n    uv*=iter;\n    //give ID's for each square\n\tvec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n    //random values\n    float ran = N2(id);\n    float ran2 = N2(id+64.0);\n    //offset each grid\n    vec2 d = abs(gv) - (abs(sin((iTime*scaleSpeed)*ran)*0.5)-0.05);\n    //draw the square\n    float rect = min(max(d.x, d.y),0.0) + length(max(d, 0.));\n\tfloat r = step(0., rect);\n    //combine square and offset to the color var\n\tvec3 col = vec3(1.-r)*vec3(abs(sin((iTime*satSpeed)*ran2))*.8);\n    //add green color\n    col *= vec3(.3,.8,0.4);\n    //draw to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 174, 192, 192, 336], [340, 340, 397, 423, 1106]], "test": "timeout"}
{"id": "3tfyDN", "name": "line_Munix", "author": "TRASHTRASH", "description": "Another one of my old VJing patterns.", "tags": ["2d", "lines", "design", "techno", "vj"], "likes": 1, "viewed": 77, "published": "Public", "date": "1592233615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//created by TRASHTRASH\n//trying to do one of these a day this is another of my simple QC designs \n//converted to GLSL please let me know more effecient ways!\n\n\n//dave hoskins\nfloat N2(vec2 p) {\t\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.y *= 40.;\n    uv.y = mod((iTime*8.0)+uv.y, 40.0);\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv)-0.5;\n    float of = N2(id);\n    float r1 = N2(id+.983);\n    \n    vec2 d = abs(gv) - vec2(abs(sin(iTime*of))*0.45,0.1);\n    float rt = min(max(d.x,d.y),0.0) + length(max(d, 0.0));\n    float r = smoothstep(-0.1,0.1, rt)*2.;\n    \n    \n\tvec3 c = vec3(1.0-r);\n    c *= vec3(1.,0.,0.)*2.0;\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 176, 194, 194, 338], [340, 340, 396, 467, 934]], "test": "timeout"}
{"id": "3tfyRr", "name": "The simplest 3D TheArtOfCode", "author": "stradiotto", "description": "This example was copied from Youtube - ShaderToy Tutorial - The simplest 3D, from The Art Of Code, to understand how to render a single point in 3D space", "tags": ["crossproduct", "pointtoraylinedistance", "smoothsteptoavoidblurring"], "likes": 4, "viewed": 59, "published": "Public", "date": "1591213687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n1) This is the example from Youtube - ShaderToy Tutorial - The simplest 3D\nhttps://www.youtube.com/watch?v=dKA5ZVALOhs&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5&index=11\n\n2) To make the point fixed in space, in the code, \nuncomment the first definition of vec3 p, \nand comment the second definition of vec3 p\n\n3) To just make the normal circular movement of vec3 p,\ncomment line (2) and uncomment line (3)\n\n4) To remove the blurring effect from the point, uncomment line (4)\n\n*/\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p)\n{\n    return length(cross(p-ro, rd)) / length(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = vec3(uv.x, uv.y, 0.) - ro;\n    \n    \n    //vec3  p = vec3(0., 0., 3.); //(1)\n    vec3  p = vec3(\n        4.* sin(iTime), \n        1.* sin(4. * iTime) + .3 * cos(8.5 * iTime), //(2)\n        //0., //(3)\n        8. + 4.* cos(iTime)\n    );\n    \n\tfloat d = DistLine(ro, rd, p);\n    \n    d = smoothstep(.1, .09, d); //(4)\n    \n    fragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[481, 481, 523, 523, 574], [576, 576, 633, 633, 1134]], "test": "ok"}
{"id": "3tfyW2", "name": "gasoline discs", "author": "surgery_waves", "description": "hold down left mouse button and drag around the screen", "tags": ["mystery"], "likes": 1, "viewed": 67, "published": "Public", "date": "1593061921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = radians(180.);\nfloat twoPi = radians (360.);   \nfloat phasor(float frequency) { \t\n    return fract(frequency * iTime); \n} \n\nfloat oscSin(float phase, float xMult, float yMult) { \n    vec2 uv = gl_FragCoord.xy/ iResolution.xy;  \t\n    float x = uv.x * xMult * twoPi; \t\n    float y = uv.y * yMult * twoPi; \t\n    float phi = phase * twoPi; \t\n    return 0.5 + 0.5 * sin(x + y + phi); \t\n} \n\nfloat oscTri(float phase, float xMult, float yMult) {\n    vec2 uv = gl_FragCoord.xy/ iResolution.xy;  \t\n    float x = uv.x * xMult; \t\n    float y = uv.y * yMult; \t\n    float wave; \t\n    float twoPhase = mod(phase + x + y, 1.) * 2.; \t\n    if (twoPhase <= 1.)   { wave = twoPhase;   } \n       else     { wave = 1. - mod(twoPhase, 1.);    }   \n    return wave; \t\n}\n\nfloat oscSaw(float phase, float xMult, float yMult) {\n    vec2 uv = gl_FragCoord.xy/ iResolution.xy;\n    return fract(phase + xMult * uv.x + yMult * uv.y);\n}\nfloat oscSinRad (float phase, float xyMult, float offset) { \n    float mx = max(iResolution.x,iResolution.y); \t\n    vec2 center = vec2(iResolution.xy / 2. / mx); \t\n    vec2 uv = gl_FragCoord.xy / mx; \t\n    float dist = distance(uv, center + offset); \t\n    float phaseIn = phase * twoPi; \t\n    phaseIn = phaseIn + xyMult * dist * twoPi; \t\n    float ripple = 0.5 * cos(phaseIn) + 0.5; \t\n    return ripple; \t\n}\n\n float oscTriRad (float phase, float xyMult, float offset) { \n    float mx = max(iResolution.x,iResolution.y); \t\n    vec2 center = vec2(iResolution.xy / 2. / mx); \t\n    vec2 uv = gl_FragCoord.xy / mx; \t\n    float dist = distance(uv, center + offset); \t\n    float xy = xyMult * dist;\n    float ripple = oscTri(phase, xy, xy); \t\n    return ripple; \t\n}\n\nfloat oscSawRad (float phase, float xyMult, float offset) { \n    float mx = max(iResolution.x,iResolution.y); \t\n    vec2 center = vec2(iResolution.xy / 2. / mx); \t\n    vec2 uv = gl_FragCoord.xy / mx; \t\n    float dist = distance(uv, center + offset); \t\n    float xy = xyMult * dist;\n    float ripple = oscSaw(phase, xy, xy); \t\n    return ripple; \t\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \t\n    vec2 uv = fragCoord.xy / iResolution.xy; \n    vec2 mousey = iMouse.xy / iResolution.xy;\n    float mult = 0.061213; //speed var \t\n    float rampA = phasor(0.2 * mult); \t\n    float rampB = phasor (0.5 * mult);\n    \n    float mouseParamVarSineX = -pi / 2. + pi * mousey.x;\n    float mouseParamVarSineY = -0.963 + mousey.y * 1.926;\n        \t\t\t\t\t  //0.963; //switch by uncommenting this line and commenting the prior line\n    \n    float mouseParamVarWave3X = 5. * (1. - pow(mousey.x, 0.16375)) + 0.73 ;\n    \t\t\t\t\t\t\t//0.73\n    float mouseParamVarWave3Y = 3. * (1. - pow(mousey.y, 0.16375)) + 3.;\n    \t\t\t\t\t\t\t//6.\n    \n    float sinewave = oscSin(rampB, mouseParamVarSineY, mouseParamVarSineX); //third param control point\n    float sinewaveVar = //sinewave;\n        1.; ///switch between 1 and commented out sinewave\n    float triangle = oscTri(rampA, 3., (1.25 + mousey.y * 7.5) * sinewave); \t\n    float sineB = oscSin(phasor(0.2 * mult + rampA * 0.1),0.2,50. * pow(triangle * sinewave, 3.)); \t\n    float rippler = oscSinRad(phasor(0.138 * sinewaveVar * 5. * mult),1.,1.) ; //44.7 + triangle * 2., sineB * triangle);\n\n    float wave1 = triangle * sinewave;\n    float wave2 = pow(sinewave + rippler * 0.2, triangle);\n    float wave3 = triangle * oscTri(rampB, mouseParamVarWave3X, mouseParamVarWave3Y) * sineB;\n    vec3 wavez = vec3(wave1, wave2, wave3);\n    float red = rippler * (wavez.x - wavez.z) * 1.5;\n    float green = 0.376 * pow(0.4,wavez.y) * pow(wavez.y,rippler);\n    float blue = 0.24 * (rippler - wavez.z)+ 0.13 * pow(wavez.z, 0.2 * wavez.x);\n\tfragColor = vec4(vec3(red,green,blue).zxy, 1.);\n    //switch around the order of the letters in \"zxy\" to experiment\n\n  //fragColor = vec4(vec3(oscSaw(phasor(-0.7), 25., 50. )), 1.0);\n\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 90, 90, 132], [135, 135, 188, 188, 393], [396, 396, 449, 449, 757], [759, 759, 812, 812, 916], [917, 917, 976, 976, 1324], [1327, 1327, 1386, 1386, 1675], [1677, 1677, 1736, 1736, 2025], [2030, 2030, 2085, 2085, 3826]], "test": "timeout"}
{"id": "3tfyWN", "name": "Fractals! - a simple demo", "author": "2BoysAndHats", "description": "A simple fractal renderer capable of drawing Julia sets", "tags": ["fractals"], "likes": 0, "viewed": 46, "published": "Public", "date": "1592072005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_ITER = 100;\nconst float THRESHOLD = 2.0f;\n\n// From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// Abused slightly to create cool colours\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coords from -2 to 2 on either axis\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 4.0f) - vec2(2.0f, 2.0f);\n    \n    // some fancy Julia set animations\n    //vec2 c = vec2(0.285f, sin(iTime) * .01f);\n    //vec2 c = vec2(0.001643721971153f, 0.82246763329887f);\n    //vec2 c = vec2(1.0f - 1.61f, 0.0f);\n    \n    float a = sin(iTime * 6.28f * .0001f);\n    vec2 c = .7885f * vec2(cos(a * 360.0f), sin(a * 360.0f));\n    \n    \n    // Loop over, and apply f(z) = z^2 + c\n    vec2 z = uv;\n       \n    for (int i = 0; i < NUM_ITER; i++) {\n\t\tz = vec2((z.x * z.x) - (z.y * z.y), (z.x * z.y) + (z.x * z.y)) + c;\n        if (length(z) > THRESHOLD) {\n            float col = float(i) / float(NUM_ITER);\n            fragColor = vec4(hsv2rgb(vec3(col, col, col)), 1.0f); // fancy coloring\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 163, 185, 185, 354], [356, 356, 413, 461, 1225]], "test": "timeout"}
{"id": "3tfyzN", "name": "Digital fire", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1269400889250308096", "tags": ["2tweets"], "likes": 6, "viewed": 83, "published": "Public", "date": "1591522128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tivec2 p=ivec2(500.*C/iResolution.y);\n    int x=p.x,y=p.y,T=int(iTime*30.),n,i;\n    for(i=0;i++<9;)\n        T++,\n        n=T+abs(((x+y-T*7)|(x-y+T*5))^((x+y-T*12)&(x-y+T*15))^((x+y-T*5)|(x-y+T*8))),\n        O.xyz+=vec3(1,.2,.1)*fwidth(step(300.,float(n%800)))*exp(-float(p.y)*.008);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 325]], "test": "timeout"}
{"id": "3tlcDS", "name": "cellular water", "author": "miko3k", "description": "based on:\nhttps://www.shadertoy.com/view/MdKXDD\nhttps://www.shadertoy.com/view/ltfGD7\n\nAny hints how to make more like Zelda?\n", "tags": ["voronoi", "water"], "likes": 2, "viewed": 111, "published": "Public", "date": "1592956286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(inout vec2 p, mat2 m, float t) {\n    p.x += sin(t);\n    p.y += cos(t);\n    float res = length(fract(p *= m * .1) - .5);\n    return res;\n}\n\nfloat cell(vec2 p, float t) {\n\n    mat2 m =  mat2(7., -6., 5., 7.);\n    \n   \n    // Very cheap wrappable cellular tiles.\n    return min(min(f(p,m,t), f(p,m,t)), f(p,m,t));\n}\n\nvec3 colouredCell( vec2 p, float t){\n    float a1 = cell(p,t)*2.0;\n\n    vec3 base = vec3(0.1, 0.5, 0.75);\n    vec3 high = vec3(0.7, 0.9, 0.9);\n    \n    return mix(base, high, pow(a1, 5.0));\n    \n}\n\n\nvoid mainImage(out vec4 o, vec2 p){\n    p = p / iResolution.xy*10.;\n    float t = iTime / 3.;\n    \n    o = vec4(colouredCell(p, t), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 145], [147, 147, 176, 176, 320], [322, 322, 358, 358, 518], [521, 521, 556, 556, 665]], "test": "timeout"}
{"id": "3tlcRH", "name": "Ghost Boze", "author": "kaiware007", "description": "Summer is coming...", "tags": ["raytracing", "raymarching"], "likes": 3, "viewed": 45, "published": "Public", "date": "1591454256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define M_HALFPI 1.5707963\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n#define MAT_CS 7.0\n\n#define AA 1\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\nvec2 opI( vec2 d1, vec2 d2 )\n{ \n    //return (d1.x>d2.x) ? d1: vec2(d2.x, d1.y);\n    return (d1.x>d2.x) ? d1: d2;\n}\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\nfloat IsHitSphere(vec3 ro, vec3 rd, vec3 sphereCenter, float radius) {\n    vec3 diff = ro - sphereCenter;\n    float xc2 = dot(diff, diff);\n    float vxc = dot(rd, diff);\n    float sq = radius * radius;\n    return vxc * vxc - xc2 + sq; \n}\n\nfloat GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return min(t1, t2);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.02 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n}\n\nvec2 sdBoze(vec3 p, float sc, float ms)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(10.);\n\n    // background\n    vec2 bg1 = vec2(sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), MAT_BG);\n    vec2 bg2 = vec2(sdPlane(p - vec3(0., 1.5, 0.), vec4(0,-1,0,0)), MAT_BG);\n    \n    result = opU(bg1, bg2);\n    //result = opSU(bg2, result,  0.25);\n    \n    //result.x *= s;\n    //return bg1;\n    return result;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n    float shadow = shadow(pos, L);\n\tvec3 diffuseBRDF = kd * albedo / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\n// Specular Occlusion\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v2.pdf\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n\n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(1.0) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), occlusion, roughness);\n    \n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n///////////////////////////////////////////////////////////////////////\n#define MAX_MARCH 30\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.12, 0., 0.4);\n    //vec3 col = min(vec3(0.12, 0., 0.4) + sinebow(fract(iTime * 1.5)) * vec3(0.1), 1.);\n    vec3 nor = norm(p);\n    vec3 sky = vec3(0.0,0.0,0.0);\n    //vec3 sky = min(sinebow(fract(iTime * 2.5 + 0.5)) * vec3(0.35) + vec3(0.3) + pow(max(1.29 - p.y, 0.), 5.), 1.);\n    //if(p.y >= 0.29) \n    if(depth > 100.)\n    {\n    \tcol = sky;\n    } else {\n        if(mat.y > 0.0){\n            vec2 index = floor(p.xz + 0.5);\n\n            float roughness, metalness;\n            if(mat.y == MAT_BG) {\n                //col = min(sinebow(fract((index.x + index.y) * 0.175 + iTime * 0.5 + 0.5)) * vec3(0.3), 1.);\n                col = mod(index.x + index.y, 2.0) == 0.0 ? vec3(0.5,0.,0.) : vec3(0.);\n                roughness = 0.1;\n                metalness = 0.5;\n            }\n            \n            vec3 result = vec3(0.);\n            result += shade(p, col, metalness, roughness, nor, -ray, normalize(vec3(1.)), vec3(1.0, 0.98, 0.95) * 10.)*1.0;\n            result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n            col = result;\n        }\n        \n        \n        //float fog = min(1.0, (1.0 / float(MAX_MARCH)) * float(mat.x))*5.0;\n    \tvec3  fog2 = vec3(0.01) * pow(depth, 2.);\n    \t//col += vec3(0.01, 0.01, 0.05) * fog;\n    \t//col += fog2 + sky * 0.1;\n        col -= fog2;\n        col = max(col, 0.);\n    }\n    \n    return col;\n}\n\nvec4 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    \n    //float planeDistance = GetIntersectLength(p, ray, vec3(0.,0.3,0.), vec3(0.,1.,0.));\n    //t = planeDistance;\n    \n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x <= 0.000001) {\n        \tbreak;\n        }\n        t += mat.x;\n        count++;\n    }\n    \n    p = p + t * ray;\n    mat.x = float(count);\n    return vec4(materialize(p, ray, t, mat), t);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n        float time = iTime * 0.2 * M_PI2;\n        float y = 0.75;\n        //float x = mod(iTime * 0.5, 10000.);\n        vec3 ro = vec3(cos(time)*4.0, y, sin(time)*4.0);\n        //vec3 ro = vec3(sin(time) * 0.1, y + cos(time * 2.13 + 3.5354) * 0.05, 3.0);\n        //ro += vec3(sin(iTime) * 0.2, cos(iTime * M_PI2 * 0.2) * 0.2, 0.);\n        vec3 ta = vec3(0., y, 0.);\n        //vec3 ro = vec3(sin(time * 2.3) * 0.1, cos(time * 3.23) * 0.1, 1.0);\n        //vec3 ta = vec3(-cos(time * 0.9) * 0.05, sin(time * 0.3) * 0.05 , 0.);\n        //vec3 ta = ro + vec3(cos(rotSpeed)*5.0, 0., sin(rotSpeed)*5.0);\n        mat3 c = camera(ro, ta, 0.);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec4 col = trace(ro, ray);\n\n        vec3 spherePos = vec3(0.,0.2 + sin(iTime * 0.4 * M_PI2) * 0.5,0.);\n        float radius = 1.5;\n        float d = GetIntersectSphere(ro, ray, spherePos, radius);\n        if((d > 0.)&&(d < col.w)){\n            vec3 ro2 = ro + ray * d;\n            float t = hash13(ro2 * 100.) * 0.1;\n            vec3 col2 = vec3(0.);\n            for(int i = 0; i < 30; i++){\n                t += 0.1;\n                vec3 pp = ro2 + ray * t;\n                if((length(pp - spherePos) > radius)||((d + t) >= col.w))\n                    break;\n                vec3 q = pp;\n                q = TwistY(q, sin((q.y + time - spherePos.y) * 15.) * 0.1);\n                vec2 r = sdBoze(q - spherePos - vec3(0.,0.1 ,0.), 4.0, 1.0);\n                if(r.x <= 0.){\n                    col2 += vec3(0.6, 0.7, 0.9) * 0.05;\n                }\n            }\n            col.xyz += col2;\n        }\n\n        col.xyz = reinhard(col.xyz, 2.9, 100.0);\n        col.xyz = pow(col.xyz, vec3(1.0/0.9));\n    \ttot += col.xyz;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlcRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[620, 620, 643, 643, 716], [718, 718, 739, 739, 809], [811, 811, 834, 834, 913], [915, 915, 938, 938, 1041], [1043, 1043, 1065, 1065, 1482], [1484, 1484, 1514, 1514, 1644], [1646, 1745, 1791, 1791, 1847], [1849, 1849, 1899, 1899, 2017], [2019, 2019, 2056, 2056, 2145], [2147, 2147, 2217, 2217, 2351], [2353, 2353, 2417, 2417, 2534], [2536, 2536, 2572, 2572, 2606], [2608, 2608, 2660, 2660, 2767], [2769, 2769, 2802, 2828, 2859], [2861, 2918, 2946, 2946, 2979], [2981, 2981, 3011, 3011, 3063], [3065, 3065, 3105, 3105, 3241], [3243, 3243, 3273, 3323, 3358], [3360, 3411, 3448, 3448, 3470], [3472, 3472, 3515, 3515, 3537], [3539, 3539, 3583, 3583, 3604], [3606, 3606, 3658, 3658, 3757], [3760, 3760, 3805, 3805, 4234], [4236, 4236, 4271, 4271, 4419], [4421, 4421, 4455, 4455, 4631], [4633, 4633, 4664, 4664, 4713], [4715, 4715, 4750, 4750, 4785], [4787, 4787, 4824, 4824, 4859], [4861, 5032, 5117, 5117, 5194], [5196, 5196, 5266, 5266, 5433], [5435, 5435, 5520, 5520, 5844], [6102, 6102, 6145, 6145, 6316], [6342, 6342, 6374, 6374, 6487], [6489, 6489, 6532, 6532, 6757], [6759, 6759, 6804, 6804, 7405], [7407, 7407, 7454, 7454, 7626], [7628, 7628, 7669, 7669, 8892], [9112, 9112, 9130, 9130, 9466], [9468, 9468, 9487, 9487, 9606], [9608, 9608, 9644, 9644, 9974], [9977, 9977, 10021, 10021, 10194], [10196, 10196, 10237, 10237, 10280], [10282, 10282, 10345, 10345, 10456], [10458, 10458, 10531, 10531, 10615], [10617, 10617, 10726, 10726, 11342], [11344, 11470, 11540, 11540, 11823], [11825, 11960, 12008, 12008, 12095], [12097, 12097, 12197, 12197, 13058], [13154, 13154, 13213, 13213, 14601], [14603, 14603, 14633, 14633, 15121], [15123, 15123, 15165, 15165, 15343], [15345, 15345, 15372, 15372, 15431], [15433, 15433, 15487, 15487, 15629]], "test": "timeout"}
{"id": "3tlcRN", "name": "Swiss cheese planet", "author": "jarble", "description": "This planet is full of holes!\nI was trying to make a planet with realistic caves, but it looks more like Swiss cheese.", "tags": ["raymarching", "sdf", "planet"], "likes": 3, "viewed": 259, "published": "Public API", "date": "1591562060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\nvec3 surface_color(vec3 p)\n{\n    return sin(p);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat bump(vec3 p3)\n{\n    //add bumps to the planet's surface\n    float distortion = 5.0;\n    p3 *= distortion;\n    return length(sin(p3))/(distortion*5.0);\n}\n\nfloat sceneSDF1(vec3 p) {\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  5.0 + sin((p.x*2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    return max(length(p)-200.0,-sceneSDF1(p/100.0))+(bump(p/40.0)*40.0+bump(p/20.0)*20.0)+bump(p/10.0)*10.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n      \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(sin(iTime/5.0), 10.0*sin(iTime/5.0), 10.0*cos(iTime/5.0))*80.0;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlcRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 209, 209, 230], [473, 473, 494, 534, 631], [633, 633, 658, 658, 768], [771, 771, 795, 795, 906], [908, 1329, 1420, 1420, 1726], [1741, 1995, 2060, 2060, 2192], [2194, 2283, 2312, 2312, 2622], [2624, 3116, 3256, 3256, 3866], [3868, 4238, 4323, 4323, 4752], [4754, 5081, 5130, 5165, 5296], [5298, 5298, 5355, 5355, 6279]], "test": "timeout"}
{"id": "3tlcWS", "name": "Wandering Love", "author": "Flopine", "description": "An improved version of a live coding session I did during Pedipanol's chiptune set for Famitracker Bites concert. \nGo listen her awesome gigs :D https://soundcloud.com/pedipanol", "tags": ["raymarching", "animation", "isometric", "orthographic", "live"], "likes": 7, "viewed": 144, "published": "Public", "date": "1592945275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define BPM (150./60.)\n#define cucubspeed (BPM/2.)\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define ITER 64.\n#define time(speed) fract(iTime*speed)\n#define bouncy(speed) sqrt(abs(sin(time(speed)*PI)))\n#define animback(speed) easeInOutBack(abs(-1.+2.*time(speed)))\n#define animcirc(speed) easeInOutCirc(time(speed))\n#define switchanim(speed) floor(sin(time(speed)*2.*PI)+1.)\n\n\nfloat easeInOutCirc(float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - pow(2. * x, 2.))) / 2.\n        : (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nfloat easeInOutBack(float x)\n{\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n\n    return x < 0.5\n        ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) / 2.\n        : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(10.4,32.4))*1284.4));}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat od (vec3 p ,float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat g1 = 0.;\nfloat room (vec3 p, float size)\n{\n    p.z += (floor(iTime*cucubspeed)+animcirc(cucubspeed))*1.6;\n    vec3 pp = p;\n    float d = abs(box(p, vec3(size,3.,1e10)))-0.2;\n    float per = 2.;\n    p.z = mod(p.z, per)-per*0.5;\n    p.x = abs(p.x)-size*0.95;\n    d = stmin(d, cyl(p.xzy, 0.3,3.),0.2,3.);\n\n    p = pp;\n    p.x = abs(p.x)-size*0.6;\n    p.y += 1.5;\n    p.z = mod(p.z-per*.5, per)-per*0.5;\n    p.xz *= rot(time(0.5)*TAU);\n    float gem = od(p,0.5);\n    g1 += 0.01/(0.01+gem*gem);\n    d = min(d,gem);\n\n    p = pp;\n    p.x = abs(p.x)-size*0.6;\n    p.y += 2.5;\n    d = stmin(d,box(p,vec3(0.8,0.2,1e10)),0.5,4.);\n\n    p = pp;\n    d = max(p.y-2.,d);\n    return d;\n}\n\nfloat cucube (vec3 p, float speed)\n{\n    float size = 0.8;\n    p.z -= 2.;\n    p.x = abs(p.x)-(.9+animback(BPM/8.));\n    p.y += 2.5-size;\n    p.y -= bouncy(speed);\n    p.yz *= rot(animcirc(speed)*PI/2.);  \n    return box(p,vec3(size));\n}\n\nfloat rom,cub;\nfloat SDF (vec3 p)\n{\n    vec3 pp = p;\n    p.yz *= rot(-atan(1.));\n    p.xz *= rot(PI/4.);\n    vec3 piso = p;\n    \n    float size = 7.;\n    rom = room(p,size);\n    float d = rom;\n\n    p = piso;\n    cub = cucube(p,cucubspeed);\n    d = min(d,cub);\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat mask (vec2 uv)\n{\n    return smoothstep(0.1,\n                      0.2, \n                      sin(abs(length(uv+vec2(0.1,-0.1))-time(BPM/8.+PI/2.))*PI)\n                     );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(uv*10.,-50.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = normalize(vec3(1.,1.,-1.)),\n        col = vec3(0.,0.01,0.02);\n\n    float shad, d = 0.; bool hit = false;\n\n    for (float i=0.; i<ITER;i++)\n    {\n        d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        rd += (1.-mask(uv))*0.005;\n        d *= 0.9 + dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        if (d == rom) col = vec3(1.);\n        if (d == cub) col = vec3(0.4,0.,0.3);\n        vec3 n = getnorm(p);\n        float lighting = dot(n,l)*.5+.5;\n        col *= mix(vec3(0.3,0.0,0.1),vec3(0.7,0.5,0.8),lighting);\n    }\n    col += g1*vec3(0.1,0.6,0.8)*0.1;\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlcWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[695, 695, 725, 725, 851], [853, 853, 883, 883, 1096], [1098, 1098, 1120, 1120, 1170], [1172, 1172, 1192, 1192, 1235], [1237, 1237, 1287, 1287, 1391], [1393, 1393, 1434, 1434, 1527], [1529, 1529, 1556, 1556, 1641], [1643, 1643, 1671, 1671, 1707], [1709, 1709, 1747, 1747, 1786], [1803, 1803, 1836, 1836, 2464], [2466, 2466, 2502, 2502, 2702], [2719, 2719, 2739, 2739, 2979], [2981, 2981, 3004, 3004, 3117], [3119, 3119, 3141, 3141, 3302], [3304, 3304, 3359, 3359, 4313]], "test": "timeout"}
{"id": "3tlcz4", "name": "Xor Roller ", "author": "Chris_M_Thomasson", "description": "Another version of the xor roller, showing less, can show more? ;^)", "tags": ["fractal"], "likes": 6, "viewed": 499, "published": "Public API", "date": "1591557452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Chris M. Thomasson's Stupid Simple Xor Roller. ;^)\n// version: pre-alpha 0.0.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n    vec2 uv = fragCoord.xy / iResolution.xy; \n\n    int x = int(fragCoord.x); \n    int y = int(fragCoord.y); \n\n    int xy_xor = (x + iFrame) ^ (y);\n    float s = .01 + abs(sin(iTime * .01)) * (abs(cos(iTime * sin(iTime * .05) * .001) * .01));\n    \n    float cr = mod(float(xy_xor) * 1.1 * s, 1.0);\n\tfloat cg = mod(float(xy_xor) * abs(sin(iTime * 0.01)) * 1.234 * s, 1.0);\n    float cb = mod(float(xy_xor) * 2.253 * s, 1.0);\n    \n    float dis = .5 + abs(sin(iTime * .5)) * .4;\n    \n    if (cr < dis)\n    {\n     \tcr = 0.;  \n    }\n    \n    fragColor = vec4(cr, cr, cr, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 139, 139, 714]], "test": "timeout"}
{"id": "3tlyRH", "name": "Dots cube", "author": "Roninkoi", "description": "Cube consisting of many dots, inspired by a Kefrens demo", "tags": ["cube", "dots"], "likes": 11, "viewed": 326, "published": "Public API", "date": "1591473955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAXIT 128\n#define EPSILON 0.001\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a)\n{\t\n    vec3 p = (abs(r) - a);\n    \n    return length(max(p, 0.));\n}\n \nfloat pbox(vec3 r, float a)\n{\t\n    vec3 p = (abs(r) - a);\n    \n    float dr = 0.02 / (a);\n    float n = 16.;\n    p = p - (a / n) * clamp(round(p / (a / n)), -n, n);\n    p = (length(p) - vec3(dr));\n    \n    return length(max(p, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n    obj = mat3(1.);\n    \n    float ts = (sin(t) + 1.) * (sin(t) + 1.) * (sin(t) + 1.) / 8.;    \n    float tss = (cos(t) + 1.) * 0.8;\n    \n    obj *= rotY((t + tss) * 2.) * rotX((t + tss) * 2.);\n    r = obj * r;\n    \n    float d = pbox(r, ts * 1.4 + 0.5);\n    \n    return vec2(d, d);\n}\n\nvec3 matCol(vec2 o)\n{\n    return vec3(0.0, 1.0, o.y);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime * 0.5;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 0.5, -4.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(1.0 - uv.y * 0.5 + cos(1.5*uv.x), 0.2 - uv.y, uv.y);\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x * 0.001);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.6 - 0.1 * hash(uv);\n\t\tr += rd * d.x;\n        \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    \n\tcol.rgb *= exp(-sh * 1.0);\n    col.rgb = mix(col.rgb, vec3(0.0, 1.0, 0.7), glow * 0.03);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 181, 181, 283], [286, 286, 306, 306, 410], [413, 413, 433, 433, 535], [549, 549, 580, 580, 608], [611, 611, 640, 640, 714], [717, 717, 754, 754, 782], [784, 784, 816, 816, 918], [920, 920, 940, 940, 1012], [1014, 1014, 1041, 1041, 1107], [1110, 1110, 1139, 1139, 1344], [1346, 1346, 1376, 1376, 1431], [1434, 1434, 1476, 1476, 1516], [1529, 1529, 1547, 1547, 1836], [1838, 1838, 1859, 1859, 1893]], "test": "timeout"}
{"id": "3tlyRr", "name": "[TWITCH] Cheshire Box Parkour", "author": "evvvvil", "description": "Cheshire Box Parkour - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["fractal", "demoscene", "abstract", "glow", "alien", "bounce", "kifs", "trippy", "scifi", "world", "architecture", "network", "twitch", "improv"], "likes": 22, "viewed": 478, "published": "Public API", "date": "1591289779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cheshire Box Parkour - Result of an improvised live code session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"The Cheshire cat is probably on drugs, well, I know I am.\" - Lewis Carroll\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,bb,sbb,boxZ,boxR,g,gg;vec3 np,bp,pp,op,po,no,ld,al;//Global vars. About as boring as living in North-East of France (I should know I grew up there).\nfloat cx(vec3 p,vec3 r){return max(abs(length(p.yz)-r.x)-r.y,abs(p.x)-r.z);} //Hollow Tunbe primitive. My own primitive function, don't laugh, I'm not very good at Math but I'm better than you at skateboarding. (seriously though, wanna challenge me? game of skate? You're on broski)\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //Box Primitive. Someone elese's primitive function (told you I'm not very good at Math but I'm French so I'm good at stealing and showing off)\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//Rotate function. Short and sweet, just like the perfect argument with your partner. It never fucking is though, here we are 5 hours later like two howler monkeys hurling bananas at eachother.\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; //Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n} \t\nvec2 fb( vec3 p, float s) //fb is \"fucking bit\" function that make base geometry for the more complex network / kifs made in mp\n{\n  p.yz*=r2(sin(p.x*.5)*.5);//Rotate everything along x axis\n  p=abs(p)-vec3(4,0,0); //Everything is abs symetry cloned along the x to create mroe geom\n  vec2 h,t=vec2(length(p)-1.8,6); //Big glowy spheres\n  g+=0.1/(0.1+t.x*t.x*20.); //Glow trick from Balkhan, push distance field of geom in vairable and add at the end (see last line)\n  h=vec2(length(abs(p.yz)-vec2(1.5))-.3,6);//4 GREY cylinders on sides\n  h.x=min(h.x,cx(p,vec3(2.2,.3,.2)));//hollow tube / ring around the big glowy spheres\n  h.x=max(h.x,abs(p.y)-1.4); //Cut grey sylinders and tube to reveal the blue ones underneath\n  t=t.x<h.x?t:h;  //Merge glowy sphere and all grey shapes above\n  h=vec2(length(abs(p.yz)-vec2(1.5))-.2,5); //Make 4 blue cylinders\n  h.x=min(h.x,cx(p,vec3(2.2,.3,.2))); //Add blue hollow tube / ring around glowy spheres\n  t=t.x<h.x?t:h;  //Add all blue shapes to rest of geometries\n  h=vec2(length(p.yz-vec2(1.6,2.0))-s*min(.02,.1*sin(-p.x*.2)),3); //RED thin tubes going up the columns the variable \"s\" is to hide / show them depending on kifs we are using\n  gg+=0.1/(0.1+h.x*h.x*(200.-190.*sin(p.x*.7-tt*4.-2.)))*s;//Glow the red fuckers with animated sweep along the y axis.\n  t=t.x<h.x?t:h; //Add red fuckers to rest of scene\n  return t;\n}\nvec2 road(vec3 p){ //Road make the black / glowy road like geometry AND the bouncing cheshire boxes\n  vec2 h,t=vec2(bo(abs(p)-vec3(1.15,2.,0.),vec3(.2,.1,100.)),3); //Dull box making dull road\n  h=vec2(bo(abs(p)-vec3(1.15,2.,0.),vec3(.05,.12,100.)),6); //Everybody loves a fucking glow on the road\n  g+=(.5+0.4*abs(sin(p.z*5.))*sbb)/(0.1+h.x*h.x*(400.-sin(p.z+1.57+boxZ)*399.*sbb)); //Make it glow again, reusing boxz position of boxes to align the glow, no real math fuckery here more of some gut feeling bullshit.\n  t=t.x<h.x?t:h;  //Merge dullbox and glow bit\n  vec3 flyPos=p+vec3(0,-.2-(bb),boxZ); //We make the actual box bouncing position in flyPos, I know lame variable name but hey I'm not the one actually called \"Kevin\", you are.\n  flyPos.xy=abs(flyPos.xy)-vec2(1.15,2.);  //Somehow abs symetry cloning of pos seemed a good idea. I don't know since writting this plenty neurones went down the bottle and I even forgot pet lizard name... Dr something? Dr Dre? no wait. Dr Drizzle, that's it. Anyways what are we talking about here?\n  flyPos.yz*=r2(sin(op.z)+boxR); //Just like throwing a soft dildo at your partner's face, the boxes nicely bend as they rotate in space with \"sin(op.z)\". Also they always land on the right face with mix(3.14,0.,fract(tt*2.))\n  h=vec2(bo(flyPos,min(fract(tt*.2),.1)*10.*vec3(.05,mix(.05,.15,bb),.05)),6);//Draw the actual cheshire boxes with mad position above\n  gg+=0.1/(0.1+h.x*h.x*75.); //Make em glow a bit but this time red for bit of contrast\n  t=t.x<h.x?t:h; //Add cheshire boxes to the rest of road\n  t.x/=.6; t.x*=.8; //Tweak distance field to avoid aritfact. I know not exactly elegant to have 2 calc in a row, but then I had 7 pints in a row last friday and despite wearing a fancy hat, it wasn't elegant either.\n  return t; \n}\nvec2 mp( vec3 p )\n{ \n  op=np=p; //op is original position and it is just here to remember how p was orginally before we start tweaking the fuck outta everything\n  np.z=mod(np.z+tt*2.,75.)-37.5;  //np is the more complex position based on p which we put in loop to make a KIFS (kaleidoscopic iteration funciton system)\n  for(int i=0;i<4;i++){ //Here is our KIFS loop, I used to call it \"pseudo fractal\" because I'm not a nerd but someone self-righteous showed me the virtuous jargon-filled path and now I call them KIFS and I'm ok being a self-righteous prick.\n    np.xz=abs(np.xz)-vec2(6,6); //Push out a bit each loop, sort of a \"reverse fucking\", if you don't think about it too long. Indulge me, it's the lockdown and I have to amuse myself.\n    np.xz*=r2(.7+sin(np.z*.2)*.3); //Yeah rotate bit and add sin(np.z) to break symetry along z.\n  }\n  vec2 h,t=fb(np,0.); t.x*=0.8; //Make first bunch of geometry with kifs above\n  h=vec2(p.y,6); //Make simple \"terrain\" with plane at 0, not eveything has to be fancy marble fucking columns, this isn't some crass nouveau-riche footballer's bachelor pad.\n  t=t.x<h.x?t:h; //merge terrain and 1st kifs\n  bp=np*.5; //Create new position bp based on np but twice bigger, to make bigger round of kifs\n  bp.xz*=r2(.785); //Rotate the fuckers a bit for good luck\n  bp.xz+=vec2(.5,-2.5); //And shift them into place so it';s snug  with the first round of kifs\n  h=fb(bp,0.); h.x/=.6; //Draw 2nd bigger bit of geom with kifs, and it is snug with first one\n  t=t.x<h.x?t:h; //Merge 2nd kifs with rest\n  h=road(bp); //Make da road and the bouncing cheshire boxes because shadertoy need more comedy\n  t=t.x<h.x?t:h; //Merge road and rest\n  bp=np*.5; //yeah yeah we do it again, dumb shit i know but don't care broh\n  bp.xy*=r2(1.57); //Rotate 180 to make it stand up, yeah we making oclumns basically\n  bp.xz-=vec2(1.,1.6); //Shift columns a bit make it snug with rest\n  h=fb(bp,1.); h.x/=.7; //Here we draw column with bp position above\n  t=t.x<h.x?t:h; //Merge columns with rest\n  pp=np; //PP is the position used for BLACK boxes on terrain, it is based on np so it's also a kifs\n  pp.xz=mod(pp.xz,2.)-1.;  //Make loads of em by doing a grid of em\n  h=vec2(bo(pp,vec3(.5,1.+2.*(.5+.5*sin(np.z*.5)),.5)),3); // Draw all those black boxes\n  h.x=max(h.x,-(length(bp.yz)-3.2)); //Remove black boxes that are too close to the blue / grey kifs geometry based on bp\n  h.x=max(h.x,-(length(np.yz)-4.8)); //Remove black boxes that are too close to the blue / grey kifs geometry based on np\n  t=t.x<h.x?t:h; //Merge black boxes with rest of scene\n  t.x*=.7; //Tweak distance field of everything to avoid artifact\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.00001||t.x>40.) break;//Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>40.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.82)+24.5;  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  bb=abs(sin(tt*2.)); //bb is an animation variable used to move boxes\n  boxZ=mix(0.,6.7,fract(tt*.2)); //boxZ is the bouncing box z pos animation variable\n  boxR=mix(3.14,0.,fract(tt*2.)); //boxR is the bouncing box angle rotation animation variable\n  sbb=1.-smoothstep(0.,1.,bb);  //sbb is the reverse of bb but also smoothed / eased animation variable\n  vec3 ro=mix(vec3(1),vec3(-1,1.7,1),ceil(sin(tt*.4)))*vec3(cos(tt*.4+.1)*2.,7.,-10),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)), //camera forward, left and up vector.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(-.1,.5,-.3));//ld=light direction\n  co=fo=vec3(.1)-length(uv)*.1-rd.y*.1;//background is dark with vignette and small gradient along y, like a  horizon\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying to throw a spear at a pig. We wouldnt have survive the ice age with you and your nerdy mates.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many brain cells I lost during my mid 2000s raving haydays.\n    float tnoi=texNoise(np.xz*.5).r;\n    if(z.y==5.) {no+=tnoi*.4;no=normalize(no);al=vec3(.0,.3,1.)*(.5+.5*cos(bp*.5))+tnoi;} //defaulkt material is gradient of blue and green with some noi\n    if(z.y<5.) al=vec3(0); //material system if less than 5 make it black\n    if(z.y>5.) al=vec3(1); //material system if more than 5 make it white\n    float dif=max(0.,dot(no,ld)-tnoi), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);//Sp=specular, stolen from shane\n    co=clamp(mix(sp+mix(vec3(.7),vec3(1),abs(rd))*al*(a(.1)*a(.3)+.2)*(dif+s(1.)),fo,min(fr,.5)),0.,1.);//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich    \n  }\n  co=mix(fo,co+g*.2*vec3(0.1,.2,.7)+gg*.1*mix(vec3(1.,.1,.0),vec3(.7,0.2,.1),.5+.5*sin(np.y*.5)),exp(-.0001*t*t*t)); //Fog soften things, but it won't stop your annoying uncle from thinking \"Bloody fiddling with bloody numbers, ain't gonna get you a job, son. Real graft is what ye need, wee man.\"(last sentence read with Scottish accent if you can)\n  fragColor = vec4(pow(co,vec3(.65)),1); //Add glow at the end. g & gg are red and blue glow global variables containg distance fields see lines 42,50,58\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 460, 484, 484, 536], [537, 743, 767, 767, 808], [809, 953, 970, 970, 1013], [1013, 1207, 1230, 1230, 1539], [1542, 1542, 1671, 1671, 2904], [2905, 2905, 2923, 3004, 4684], [4685, 4685, 4704, 4704, 7337], [7338, 7338, 7419, 7419, 8185], [8275, 8275, 8404, 8404, 11630]], "test": "error"}
{"id": "3tscD8", "name": "dotty metaball", "author": "imprity", "description": "kewl\n(that dot is made with ico sphere points I generated with java do you have any better idea to create these points?)", "tags": ["alsokewl"], "likes": 3, "viewed": 69, "published": "Public", "date": "1592329995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nfloat GRatio = 1.618033988;\n\nint maxStep = 255;\nfloat minDist = 0.0;\nfloat maxDist = 200.0;\nfloat e = 0.0001;\n\nstruct Camera{\n    vec3 pos;\n    vec3 look;\n    vec3 up;\n    vec3 right;\n    float fov;\n};\n\nstruct Sphere{\n    vec3 pos;\n    float r;\n};\n\nvec3 rotateX(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    1., 0., 0.,\n    0., cos(ang), -sin(ang),\n    0., sin(ang), cos(ang));\n  return rmat * p;\n}\nvec3 rotateY(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), 0., sin(ang),\n    0., 1., 0.,\n    -sin(ang), 0., cos(ang));\n  return rmat * p;\n}\nvec3 rotateZ(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), -sin(ang), 0.,\n    sin(ang), cos(ang), 0.,\n    0., 0., 1.);\n  return rmat * p;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nCamera getCamera(vec3 pos, vec3 look, vec3 up, float fov){\n    Camera c;\n    c.pos = pos;\n    c.look = normalize(look - pos);\n    c.right = normalize(cross(up, c.look));\n    c.up = cross(c.look, c.right);\n    c.fov = fov;\n    return c;\n}\n\nvec3 getRay(Camera c, vec2 coord){\n    vec3 ray;\n    \n    vec2 nc = coord/iResolution.xy;\n    nc -= 0.5;\n    nc.x *= iResolution.x/iResolution.y;\n    \n    ray += nc.x * c.right;\n    ray += nc.y * c.up;\n    ray += c.fov * c.look;\n    \n    return normalize(ray);\n}\n\nfloat sphereSdf(Sphere s, vec3 p){\n    p -= s.pos;\n    return length(p) - s.r;\n}\n\n\nfloat sdf(vec3 p){\n    Sphere s = Sphere(vec3(0.0,0.0,0.0), 0.6);\n    Sphere s2 = Sphere(vec3(0.1,0.1 + sin(iTime),0.0), 0.3);\n    Sphere s3 = Sphere(vec3(0.2,0.1 + cos(iTime ) * 1.3,0.0), 0.4);\n    \n    \n    float d;\n    \n    d = sphereSdf(s,p);\n    d = smin(d, sphereSdf(s2,p), 0.3);\n    d = smin(d, sphereSdf(s3,p), 0.3);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    Camera cam = getCamera(rotateY(vec3(1.0,0.7, -1.0),iTime * 0.1), vec3(0.0,0.0,0.0), vec3(0.0,1.0,0.0), 0.3);\n    \n    \n    vec3 ray = getRay(cam, fragCoord);\n    \n    float d1 = 0.0;\n    float d2 = 0.0;\n    \n    float h;\n    \n    vec3 n;\n    \n    for(int i=0; i < maxStep; i++){\n        d1 = sdf(d2*ray + cam.pos);\n        if(d1 < e)\n        \tbreak;\n        d2 += d1;\n        if(d2 > maxDist)\n            break;\n        h++;\n    }\n    \n    d2 = min(d2, maxDist);\n    \n    vec3 p = d2 * ray + cam.pos; \n    \n    n = normalize(vec3(\n        sdf(vec3(p.x + e, p.y, p.z)) - sdf(vec3(p.x - e, p.y, p.z)),\n        sdf(vec3(p.x, p.y + e, p.z)) - sdf(vec3(p.x, p.y - e, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + e)) - sdf(vec3(p.x, p.y, p.z - e))\n    ));\n    \n    float c = dot(n, rotateY(normalize(vec3(5.0,3.0, 5.0)), iTime * 0.3));\n    \n    if(d2 >= maxDist){\n        float spot;\n        \n        vec3 spvec = vec3(0.0,0.0,1.0);\n        \n        float spn = 30.0;\n        \n        for(float i=0.0; i<spn; i++){\n            for(float j=0.0; j<spn; j++){\n                spot = max(spot,dot(ray, spvec));\n                spvec = rotateZ(spvec, PI * 2.0 / spn);\n            }\n            spvec = rotateY(spvec, PI * 1.0 / spn);\n        }\n        if(spot < 0.9999)\n        \tfragColor = vec4(0.949, 0.0941, 0.28235, 1.0);\n        else\n            fragColor = vec4(1.0);\n    }\n    else{\n        float spot;\n        n = rotateX(n, iTime * 0.3);\n        n = rotateY(n, iTime * 0.3);\n        /*spot = max(spot, dot(n ,normalize( vec3(-1,  GRatio,  0) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3( 1,  GRatio,  0) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3(-1, -GRatio,  0) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3( 1, -GRatio,  0) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3( 0, -1,  GRatio) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3( 0,  1,  GRatio) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3( 0, -1, -GRatio) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3( 0,  1, -GRatio) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3( GRatio,  0, -1) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3( GRatio,  0,  1) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3(-GRatio,  0, -1) )));\n\t\tspot = max(spot, dot(n ,normalize( vec3(-GRatio,  0,  1) )));*/\n        // LOL\nspot = max(spot, dot(n ,normalize(vec3(-0.52573, 0.85065, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(0.52573, 0.85065, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(-0.52573, -0.85065, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(0.52573, -0.85065, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, -0.52573, 0.85065))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, 0.52573, 0.85065))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, -0.52573, -0.85065))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, 0.52573, -0.85065))));\nspot = max(spot, dot(n ,normalize(vec3(0.85065, 0.00000, -0.52573))));\nspot = max(spot, dot(n ,normalize(vec3(0.85065, 0.00000, 0.52573))));\nspot = max(spot, dot(n ,normalize(vec3(-0.85065, 0.00000, -0.52573))));\nspot = max(spot, dot(n ,normalize(vec3(-0.85065, 0.00000, 0.52573))));\nspot = max(spot, dot(n ,normalize(vec3(-0.80902, 0.50000, 0.30902))));\nspot = max(spot, dot(n ,normalize(vec3(-0.50000, 0.30902, 0.80902))));\nspot = max(spot, dot(n ,normalize(vec3(-0.30902, 0.80902, 0.50000))));\nspot = max(spot, dot(n ,normalize(vec3(0.30123, 0.80413, 0.51248))));\nspot = max(spot, dot(n ,normalize(vec3(-0.01550, 0.99988, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(-0.00000, 1.00000, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(0.31673, 0.81371, -0.48740))));\nspot = max(spot, dot(n ,normalize(vec3(-0.31673, 0.81371, -0.48740))));\nspot = max(spot, dot(n ,normalize(vec3(-0.30902, 0.80902, -0.50000))));\nspot = max(spot, dot(n ,normalize(vec3(-0.48740, 0.31673, -0.81371))));\nspot = max(spot, dot(n ,normalize(vec3(-0.80413, 0.51248, -0.30123))));\nspot = max(spot, dot(n ,normalize(vec3(-0.80902, 0.50000, -0.30902))));\nspot = max(spot, dot(n ,normalize(vec3(-1.00000, 0.00000, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(0.30902, 0.80902, 0.50000))));\nspot = max(spot, dot(n ,normalize(vec3(0.48740, 0.31673, 0.81371))));\nspot = max(spot, dot(n ,normalize(vec3(0.80413, 0.51248, 0.30123))));\nspot = max(spot, dot(n ,normalize(vec3(-0.51248, -0.30123, 0.80413))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, 0.01550, 0.99988))));\nspot = max(spot, dot(n ,normalize(vec3(-0.81371, -0.48740, -0.31673))));\nspot = max(spot, dot(n ,normalize(vec3(-0.81371, -0.48740, 0.31673))));\nspot = max(spot, dot(n ,normalize(vec3(-0.50000, 0.30902, -0.80902))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, 0.01550, -0.99988))));\nspot = max(spot, dot(n ,normalize(vec3(-0.51248, -0.30123, -0.80413))));\nspot = max(spot, dot(n ,normalize(vec3(0.30902, 0.80902, -0.50000))));\nspot = max(spot, dot(n ,normalize(vec3(0.80413, 0.51248, -0.30123))));\nspot = max(spot, dot(n ,normalize(vec3(0.48740, 0.31673, -0.81371))));\nspot = max(spot, dot(n ,normalize(vec3(0.81371, -0.48740, 0.31673))));\nspot = max(spot, dot(n ,normalize(vec3(0.50000, -0.30902, 0.80902))));\nspot = max(spot, dot(n ,normalize(vec3(0.30123, -0.80413, 0.51248))));\nspot = max(spot, dot(n ,normalize(vec3(0.30902, -0.80902, 0.50000))));\nspot = max(spot, dot(n ,normalize(vec3(-0.30902, -0.80902, 0.50000))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, -1.00000, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(-0.30902, -0.80902, -0.50000))));\nspot = max(spot, dot(n ,normalize(vec3(0.30902, -0.80902, -0.50000))));\nspot = max(spot, dot(n ,normalize(vec3(0.50000, -0.30902, -0.80902))));\nspot = max(spot, dot(n ,normalize(vec3(0.80902, -0.50000, -0.30902))));\nspot = max(spot, dot(n ,normalize(vec3(1.00000, 0.00000, 0.00000))));\nspot = max(spot, dot(n ,normalize(vec3(0.80902, -0.50000, 0.30902))));\nspot = max(spot, dot(n ,normalize(vec3(0.50000, 0.30902, 0.80902))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, 0.00000, 1.00000))));\nspot = max(spot, dot(n ,normalize(vec3(-0.50000, -0.30902, 0.80902))));\nspot = max(spot, dot(n ,normalize(vec3(-0.80902, -0.50000, 0.30902))));\nspot = max(spot, dot(n ,normalize(vec3(-0.80902, -0.50000, -0.30902))));\nspot = max(spot, dot(n ,normalize(vec3(-0.50000, -0.30902, -0.80902))));\nspot = max(spot, dot(n ,normalize(vec3(0.00000, 0.00000, -1.00000))));\nspot = max(spot, dot(n ,normalize(vec3(0.50000, 0.30902, -0.80902))));\nspot = max(spot, dot(n ,normalize(vec3(0.80902, 0.50000, -0.30902))));\nspot = max(spot, dot(n ,normalize(vec3(0.80902, 0.50000, 0.30902))));\n        if(spot < 0.98)\n        \tfragColor = vec4(0.949, 0.0941, 0.28235, 1.0);\n        else\n            fragColor = vec4(1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tscD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 305, 305, 420], [421, 421, 454, 454, 569], [570, 570, 603, 603, 718], [720, 720, 761, 761, 854], [856, 856, 914, 914, 1093], [1095, 1095, 1129, 1129, 1357], [1359, 1359, 1393, 1393, 1439], [1442, 1442, 1460, 1460, 1787], [1789, 1789, 1845, 1845, 8522]], "test": "timeout"}
{"id": "3tscz7", "name": "Uniforms - TBOS 3.0", "author": "stungeye", "description": "Chapter 3 - The Book of Shaders - Uniforms\n\nThe input \"uniforms\":\n\n- iResolution\n- iMouse\n- iTime\n\nCalled uniforms as their values are equal across pixel threads.\n\nTrig functions to ease R & G by position and time. Mouse-click X changes rate of B easing.", "tags": ["simple", "gradient", "tbos"], "likes": 1, "viewed": 238, "published": "Public API", "date": "1591715432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Working Through The Book of Shaders\n// Chapter 03 - Uniforms - https://thebookofshaders.com/03/\n// 3.0 Uniforms\n\n\n// Sinusoidal function shifted and scaled to range betwen 0 and 1.\n// See: https://www.desmos.com/calculator/w9jrdpvsmk\nfloat sinEase(float x) {\n\treturn 0.5 * sin(x) + 0.5;\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n    // Set scale according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    float blueRateScale = iMouse.x / iResolution.x; \n       \n    // Ease back and forth 1 and 100 using time-based sine.\n    float stretchFactor = 99.0 * sinEase(iTime) + 1.0;\n    \n    // Setting red and green pixel value.\n    // Ease back and forth between 0 and 1 based on pixel position and time-based stretch factor.\n    float red   = sinEase(fragCoord.x / stretchFactor);\n    float green = sinEase(fragCoord.y / stretchFactor);\n    \n    // Blue will ease in and out based on time and the x position of the mouse.\n    // Ease speed increases from left to right.\n    float blue = abs(tan(iTime * blueRateScale));\n    \n    // Set the pixel value based on the RGB calculated above.\n    fragColor = vec4(red,green,blue,1);\n}\n\n\n// Stung Eye 2020 - Unlicense - https://unlicense.org\n// This is free and unencumbered software released into the public domain.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tscz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 237, 261, 261, 291], [293, 398, 542, 707, 1432]], "test": "ok"}
{"id": "3tsyDf", "name": "eyelash rendering", "author": "meteotrix", "description": "testing a bunch of eyelash rendering things for FFT diffraction purposes. It's rendered in inverted colours for a compositing trick.", "tags": ["implicit"], "likes": 0, "viewed": 31, "published": "Public", "date": "1593299275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col = vec3 (0.2, 0.2, 0.2); //grey background\n    \n    vec2 uv = fragCoord/iResolution.xy; \n    uv.x = uv.x*1.777 - 0.38; //squarify UVs\n    \n    //if(uv.y <0.5)  uv.y = 1.0-uv.y; //mirror UVs vertically\n    \n    vec2 uv1 = uv.xy;\n    \n    //vertical offset\n    if (uv1.y < 0.5) uv1.y = 1.0 - uv1.y;\n    //float y_offset = sin(iTime)*0.05 - 0.1;\n    //uv1.y += y_offset;\n\n    float distance_to_upperlashes_center = distance(vec2(uv1.x, uv1.y * 2.0 + sin(iTime*2.0)*0.5), vec2(0.5, 1.9));\n\n    //if (distance_to_upperlashes_center < 0.4)\n    {\n        vec2 uv2 = uv1.xy;\n        \n        //curve lashes\n        //uv2.x = (uv2.x-0.5) * (1.0 - uv2.y*3.0) +0.5;        \n\n        float angle_around_center = (/*(iTime*0.5) +*/ 1.0 + acos(dot(normalize(uv2.xy - vec2(0.5, 0.5 + 0.5)), vec2(1, 0))));\n\n        //draw lashes\n        if (abs(fract((angle_around_center - 0.03 ) * 8.0 )) < 0.4 - distance_to_upperlashes_center )\n        {\n            col = vec3(1, 1, 1);\n            //col = vec3(abs(fract((angle_around_center - 0.03 ) * 16.0))*2.0);\n        }\n    }\n    \n    //black background\n    if (distance(uv.xy, vec2(0.5)) > 0.3 + sin(iTime*0.5)*0.01)\t\t\n        col = vec3(0, 0, 0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1286]], "test": "timeout"}
{"id": "3tsyW4", "name": "PowerBrot Zoom", "author": "eiffie", "description": "SuperFractalThingy Math for higher power brots. I was working my way towards a 3d mandelbulb zoom but triplex math isn't an algebra so I'm not sure if you can separate Z and deltaZ.", "tags": ["sft"], "likes": 2, "viewed": 220, "published": "Public API", "date": "1592092713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Power Brot Zoom by eiffie (SuperFractalThingy Math for higher powers, delta not approx)\n//#define PWR 3\n#define PWR 4\n//#define PWR 5\n\n#define rez iResolution.xy\n\nvec2 cpwr(vec2 C, float pwr){\n  float a=atan(C.y,C.x)*pwr;\n  return pow(length(C),pwr)*vec2(cos(a),sin(a));\n}\nvec2 cmul(vec2 A, vec2 B){return vec2(A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x);}\n\nfloat tym,scale,yFlip;\nfloat mndfk(vec2 dZ){\n  dZ*=scale;\n#if(PWR==3)\n  vec2 Z=vec2(-.5448069,.27999981*yFlip);\n#elif(PWR==4)\n  vec2 Z=vec2(-.7194003,.27*yFlip);\n#elif(PWR==5)\n  vec2 Z=vec2(-.755805,.2*yFlip);\n#endif\n  vec2 dC=dZ,C=Z;\n  float iters=32.+tym*8.;\n  float i=0.;\n  for(i=0.;i<iters;i+=1.){\n#if(PWR==3)\n    dZ=3.*cmul(cpwr(Z,2.),dZ)+3.*cmul(Z,cpwr(dZ,2.))+cpwr(dZ,3.)+dC;\n    Z=cpwr(Z,3.)+C;\n#elif(PWR==4)\n    dZ=4.*cmul(cpwr(Z,3.),dZ)+6.*cpwr(cmul(Z,dZ),2.)+4.*cmul(Z,cpwr(dZ,3.))+cpwr(dZ,4.)+dC;\n    Z=cpwr(Z,4.)+C;\n#elif(PWR==5)\n    dZ=5.*cmul(cpwr(Z,4.),dZ)+10.*cmul(cpwr(Z,3.),cpwr(dZ,2.))+10.*cmul(cpwr(Z,2.),cpwr(dZ,3.))+5.*cmul(Z,cpwr(dZ,4.))+cpwr(dZ,5.)+dC;\n    Z=cpwr(Z,5.)+C;\n#endif\n    if(dot(dZ,dZ)>40.)break;\n  }\n  return ((iters-i)+log2(log2(dot(dZ,dZ))/log2(40.00))/log2(float(PWR)))/iters;\n}\nvoid mainImage(out vec4 O,in vec2 U){\n  vec2 uv=(2.0*U-rez)/rez.x;\n  tym=mod(iTime,110.)-55.;\n  yFlip=sign(tym);\n  tym=55.-abs(tym);\n  scale=exp(-tym*.5);\n  float a=mndfk(uv);\n  O=vec4(a,a,a,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 194, 194, 274], [275, 275, 301, 301, 347], [372, 372, 393, 393, 1168], [1169, 1169, 1206, 1206, 1367]], "test": "timeout"}
{"id": "3tsyWf", "name": "Day 190", "author": "jeyko", "description": "potato", "tags": ["mograph", "mdtmjvm"], "likes": 18, "viewed": 280, "published": "Public API", "date": "1593290927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./50.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[11](4.2*speed,4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 1.2*speed, 1.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n// oh no\n#define smease(p,g) ease(p, 1.5, 1.24, 0.76, 1.)\n \n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    t += sumScenes(7.)- 0.;\n    \n    t = mod(t, sumScenes(9.)  );\n    \n    vec2 triW = vec2(0.2,0.2)*0.25;\n    \n    float its = 15.;\n    float scene = 0.;\n    \n    vec2 p = uv;\n\n    vec4 q = vec4(p,1,1);\n\n    float dt = 10e5;\n    float dFirst = 10e5;\n\n    for(float i = 0.; i < its; i++){\n        float tsc = i/its*1.5;\n        float enva = eass((t - tsc)/scenes[0]*1.,3.);\n\n        float envb = eass((t - tsc - scenes[0])/scenes[0]*1.,3.);\n\n        float envc = eass((t - tsc - sumScenes(1.))/scenes[0]*1.,3.);\n        float envd = eass((t - tsc - sumScenes(2.))/scenes[0]*1.,3.);\n\n        float enve = eass((t - tsc - sumScenes(3.))/scenes[0]*1.,3.);\n\n        float envf = eass((t - tsc - sumScenes(4.))/scenes[0]*1.,3.);\n\n        float envg = eass((t - tsc - sumScenes(5.))/scenes[0]*1.,3.);\n\n        float envh = eass((t - tsc - sumScenes(6.))/scenes[0]*1.,3.);\n\n        vec2 b = p;\n\n\n        b *= rot(enve*pi*1. );\n        //b = mix(b,abs(b),1.);\n\n        b -= 0.25 - 0.25*enve - 0.25*envh;\n        b.x += 0.5*enva;\n        b.y += 0.5*envb;\n        b.x -= 0.5*envc;\n        b.y -= 0.5*envd;\n        b *= rot(enva*pi/2. + envb*pi/2. + envc*pi/2.   - envh*pi*0. );\n\n        b *= rot(envf*pi/1. - .5*envh*pi );\n\n\n        float itsifs = 1. + envg*1.  - envh*1.;\n        for(float i = 0.; i < itsifs + 1.; i++){\n            vec2 f = abs(b);\n            //b -= 0.01;\n\n            f *= rot(0.25*pi*envd - 0.25*pi*envg);\n            //f *= rot(0.25*pi*envf);\n            \n            b = mix(b,f,smoothstep(0.,1.,itsifs - i));\n\n        }\n\n        b.xy *= rot(tau*i/its/1.*(envg - envh) );\n\n        //b.y -= 0.3;\n        //b.y += 0.2*enva;\n\n        //b.y += sin((i)/1. - t*pi)*0.1;\n        //b.xy *= rot(i*0.4 + iTime/3.);\n\n        float ld = sdBox(b,triW);\n\n        vec2 g = b;\n        ld = min(ld,sdBox(b,vec2(0.0,0.4)));\n        b = abs(b) - vec2(0,0.2);\n        ld = min(ld,sdBox(b,vec2(0.01,0.01)));\n        b = b - vec2(0,0.2);\n        ld = min(ld,sdBox(b,vec2(0.01,0.01)));\n\n        ld = max(ld,-sdBox(g,vec2(0.005,0.05)));\n\n\n        vec4 q = vec4(b,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n\n\n        q = pmod(abs(q),0.04);\n\n        float dbq = sdBox(q,vec4(0.004 + 0.006*envd - envh*0.006));\n\n        float slider = smoothstep(0.,1.,i/its + envd*0.4 - envh*0.4 )*1.;\n\n        if(i == 0.){\n            dFirst = ld;\n\n            dFirst = mix(dFirst,max(ld,dbq),slider);\n\n        } else {\n            //ld = \n            //slider = 0.1;\n\n        }   \n        float ldb = ld;\n        ld = mix(ld,abs(dbq),slider);\n\n        ld = mix(ld,max(ld,ldb),slider);\n\n        dt = min(dt,abs(ld));\n\n        dt = mix(dt, abs(pmod(dt ,0.04 )) ,slider);\n\n\n    }\n    d = min(d,dt); \n    d = min(d,dFirst);\n\n    d = abs(d);\n\n\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 318, 318, 374], [377, 388, 425, 425, 733], [734, 734, 771, 771, 818], [819, 819, 856, 856, 921], [976, 976, 1028, 1028, 1147], [1327, 1327, 1355, 1355, 1462], [1464, 1464, 1533, 1533, 1689], [1690, 1690, 1720, 1720, 1829], [1891, 1891, 1918, 1918, 4906]], "test": "error"}
{"id": "3tsyWM", "name": "Crappy code", "author": "z0rg", "description": "A small thingy did this noon, don't judge the code, it's mainly been done on my smartphone and I did not take time to clean it.", "tags": ["2d", "design", "vaporwave", "chill", "clean"], "likes": 2, "viewed": 80, "published": "Public API", "date": "1592223150", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,-sina,sina,cosa);}\n\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\n\nfloat _union(float a, float b)\n{\n  return min(a,b);\n}\nvec3 cols[4];\nvoid setup()\n{\n  cols[0] = .8*vec3(106, 48, 128)/255.;\n  cols[1] = vec3(125, 44, 82)/255.;\n  cols[2] = .8*vec3(232, 26, 77)/255.;\n  cols[3] = .9*vec3(227, 187, 54)/255.;\n}\nvec3 rdr(vec2 uv, float sh, float tm)\n{\n  int cnt = 8;\n  float fcnt = float(cnt);\n  int i = 0;\n  vec3 col = vec3(1.);\n\nfloat sharp = 200.;//(uv.y<0. ? 20.*(abs(uv.x)+.1) : 200.)*sh;\n   while(i <cnt)\n   {\n     float fi = 0.;//float(i);\n     float rx = .0;//(fi-(fcnt/2.))/(fcnt/2.);\n     vec2 p = r2d(5.*smoothstep(0.,1.,(.5+.5*sin(.1*float(i)+tm*.1))))*(vec2(sin(iTime)*.1, .1*cos(iTime*.5))+vec2(1.*(abs(.8+.4*sin(iTime*.5))))*uv-vec2(rx,0.));\nfloat shading = 2.*dot(p,vec2(p.x,p.y));\n     col = mix(col, shading*vec3(1.), (1.-sat((lenny(p)-.55-.1*abs(sin(fi*15.+iTime*.1)))*sharp)));\n     ++i;\n   }\n   col *= pow(1.-sat(lenny(uv*.5)),.5);\n\n   setup();\n   float axis = uv.y;\n   if (abs(axis) < .4)\n   {\n     col *= vec3(1.)+cols[int(mod(abs((1.9+uv.y+uv.x+mod(iTime*sh,1.)*.6)*20.),4.))].zyx;\n   }\n  return col;\n}\n\n\n\nvec3 tone(vec3 c,vec2 uv)\n{\n  c *= mix(vec3(1.),vec3(.78,.87,.98), sat(length(uv)-.9));\nc = pow(c, vec3(1./.6));\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv*=5.;\n  vec3 col = rdr(uv,.4,iTime);\n  col = mix(rdr(uv*.5,-.2,iTime*2.),col, 1.-sat((length(uv)-1.2)*200.));\n    vec3 col2 = col;\n    col2.xy = col2.xy * r2d(length(uv));\n    col = mix(col, col2, (1.-length(uv))*.5+sin(2.7));\n    col = pow(col, vec3(1./.8));\n  fragColor = vec4(tone(col,uv), 1.0);\n}\n", "image_inputs": [{"id": "llS3zc", "previewfilepath": "https://soundcloud.com/emil-rottmayer/detached?in=emil-rottmayer/sets/detached-ep-vinyl-edition", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/emil-rottmayer/detached?in=emil-rottmayer/sets/detached-ep-vinyl-edition", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyWM.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[397, 397, 415, 415, 490], [493, 493, 513, 513, 540], [542, 542, 563, 563, 593], [595, 595, 627, 627, 648], [663, 663, 677, 677, 834], [835, 835, 874, 874, 1649], [1653, 1653, 1680, 1680, 1779], [1781, 1781, 1838, 1838, 2234]], "test": "timeout"}
{"id": "3tsyWN", "name": "Im so bored", "author": "JuliaPoo", "description": "ehhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh", "tags": ["colors", "bored"], "likes": 2, "viewed": 75, "published": "Public", "date": "1592114108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) { return fract(sin(n) * 1e4); }\n\nfloat noise(float x, float scale) {\n    x *= scale;\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n    float m = mix(hash(i), hash(i + 1.0), u);\n\treturn m;\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat brush(in vec2 uv)\n{\n    vec2 uv0 = uv;\n    uv *= rot(pow(sin(iTime), 3.) * length(uv) * 3. + iTime);\n    vec2 n = normalize(uv);\n    float c1 = acos(n.x) - .3;\n    float c0 = length(uv);\n    c0 += sin(c1*5.)*.2*c0 * sin(iTime);\n    float f = pow(noise(c0, 70.), 10.);\n    float c3 = acos(normalize(uv0).x) - .3;\n    f *= pow(.4, -c3*c3);\n    float col = smoothstep(0., 1., f);\n    col *= sqrt(1.-.8*length(uv));\n    \n    return pow(col, 4.) + .4*sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(.5, .8, .9);\n    vec3 brush = vec3(brush(uv), brush(uv*.9), brush(uv*1.1));\n    col += brush;\n    col = col*col*col*col*col;\n    fragColor = vec4(col, length(col));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 51], [53, 53, 88, 88, 241], [243, 243, 262, 262, 338], [340, 340, 365, 365, 804], [806, 806, 863, 863, 1137]], "test": "timeout"}
{"id": "3tsyWs", "name": "Stepped sdf blending", "author": "bozhkov", "description": "blending some 2d sdfs", "tags": ["2d", "sdf", "blend", "stepped"], "likes": 13, "viewed": 282, "published": "Public", "date": "1593447443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nconst float lWidth = 0.045;\nconst float lDist = 0.011;\n\n// Distance functions by Inigo Quilez\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleEq( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nmat2 rotate2d(float _angle)\n{\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdShape(vec2 st) \n{\n    st = rotate2d(cos(iTime * 0.9) * PI * 1.5) * st;\n\n    float dCircle = length(st) - 0.24;\n    float dBox = sdBox(st, vec2(0.55)) + 0.2;\n    float dTriangle = sdTriangleEq(st) + 0.34;\n    \n    float progress = fract(iTime * 0.3);\n\n    // Transition speed per unit of time (normalized)\n    float tSpeed = 0.3;\n    float tStatic = (1.0 - tSpeed * 3.0) / 3.0;\n    float shapeDuration = tStatic + tSpeed;\n\n    float d = mix(dCircle, dTriangle, smoothstep(0.0, tSpeed, progress));\n    d = mix(d, dBox, smoothstep(shapeDuration, shapeDuration + tSpeed, progress));\n    d = mix(d, dCircle, smoothstep(shapeDuration * 2.0, shapeDuration * 2.0 + tSpeed, progress));\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    st = rotate2d(PI / 4.0) * st;\n\n    st.x += lWidth / 2.0;\n\n    float lfull = lWidth + lDist;\n\n    // the index of each line\n    float i = floor(st.x / lfull);\n\n    // start x of line\n    float lx = lfull * i;\n    float aa = 0.003;\n    float line = smoothstep(lx, lx + aa, st.x) \n    - smoothstep(lx + lWidth - aa, lx + lWidth, st.x);\n\n    // clip x to the start x of its line\n    st.x = lx;\n\n    aa = 0.001;\n    float d = sdShape(st);\n\n    float core = 1.0 - smoothstep(-aa, 0.0, d);\n    core *= line;\n    float shell1 = 1.0 - smoothstep(-aa, 0.0, d - 0.05);\n    shell1 *= line;\n    float shell2 = 1.0 - smoothstep(-aa, 0.0, d - 0.1);\n    shell2 *= line;\n\n    vec3 baseColor = vec3(0.0, 0.05, 0.03);\n    vec3 color = mix(baseColor, vec3(1.0), line * 0.23 * (1.0 - shell2));\n    color = mix(color, vec3(0.3, 1.0, 0.95), core);\n    color = mix(color, vec3(1.0, 0.5, 0.0), shell1 - core);\n    color = mix(color, vec3(1.0, 0.25, 0.0), shell2 - shell1);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 120, 157, 157, 237], [239, 239, 272, 272, 483], [485, 485, 514, 514, 600], [602, 602, 627, 627, 1303], [1305, 1305, 1362, 1362, 2427]], "test": "ok"}
{"id": "3tXcRs", "name": "Simplex Trabeculae", "author": "izutionix", "description": "Using simplex noise to generate a trabecular structure (faster than voronoi based methods)\nstatic version: [url]https://www.shadertoy.com/view/WtXcRj[/url]\n2d version: [url]https://www.shadertoy.com/view/tlfczS[/url]", "tags": ["simplex", "sponge", "cave", "trabeculum", "network"], "likes": 18, "viewed": 314, "published": "Public API", "date": "1592737634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 256\n#define TMAX 100.\n#define PRECIS .0001\n\n#define r(a) mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n#define shaded 0\n\nvec3 hash33(vec3 c, float r) {\n\tvec3 h = .5*normalize(fract(vec3(8., 1., 64.)*sin( dot(vec3(17., 59.4, 15.), c) )*32768.)-.5);\n    return mix(vec3(.4), h, r); // attenuate randomness (make sure everything on the path of the camera is not random)\n}\n\n/* 3d simplex noise from candycat's \"Noise Lab (3D)\" https://www.shadertoy.com/view/4sc3z2\nbased on the one by nikat: https://www.shadertoy.com/view/XsX3zB */\nvec4 simplex_noise(vec3 p, float r) {\n    \n    const float K1 = .333333333;\n    const float K2 = .166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.), d0 - d0.yzx);\n\tvec3 i1 = e * (1. - e.zxy);\n\tvec3 i2 = 1. - e.zxy * (1. - e);\n    \n    vec3 d1 = d0 - (i1 - 1. * K2);\n    vec3 d2 = d0 - (i2 - 2. * K2);\n    vec3 d3 = d0 - (1. - 3. * K2);\n    \n    vec4 h = max(.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i, r)), dot(d1, hash33(i + i1, r)), dot(d2, hash33(i + i2, r)), dot(d3, hash33(i + 1., r)));\n    \n    return 70.*n;\n}\n\n// see https://www.shadertoy.com/view/ttsyRB\nvec4 variations(vec4 n) {\n    vec4 an = abs(n);\n    vec4 s = vec4(\n        dot( n, vec4(1.) ),\n        dot( an,vec4(1.) ),\n        length(n),\n        max(max(max(an.x, an.y), an.z), an.w) );\n    \n    float t =.27;\n    \n    return vec4(\n\t\t// worms\n\t\tmax(0., 1.25*( s.y*t-abs(s.x) )/t),\n\t\t// cells (trabeculae)\n    \tpow( (1.+t)*( (1.-t)+(s.y-s.w/t)*t), 2.), //step( .7, (1.+t)*( (1.-t)+(s.y-s.w/t)*t) ),\n\t\t.75*s.y,\n    \t.5+.5*s.x);\n}\n\nfloat map(vec3 p) {\n    float c = smoothstep(0., 1., length(p.xy)-.1); // controls the randomness\n    p += vec3(-.65, .35, 44.85);\n    float s = 1.;\n    float n = variations( simplex_noise(p*s*.5, c) ).y;\n    n = .78-n;\n    n /= s*4.;\n    \n    return n;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = .01;\n    for(int i=0; i<STEPS; i++) {\n        float h = map(ro + rd * t);\n        t += h;\n        if(t>TMAX || abs(h)<PRECIS) break;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.4, 0);\n    return normalize(\n        map(p) - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n        ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.); ro.z = iTime*.67;\n    vec3 rd = vec3(uv, .5);\n    \n    vec3 l = normalize( vec3(-3,2,1) );\n    \n    float fc = exp2( .5*dot(rd, l) )*.5;\n    \n\tfloat t = march(ro, rd);\n    vec3 p = ro + rd * t;\n    \n    float dif = 0.;\n#if shaded\n    vec3 n = normal(p);\n    dif = dot(n, l)*.5+.5;\n    dif *= .125;\n#endif\n    \n    float fog = pow(1.-.05/(t*.75+.5), 25.);\n    float v = mix(dif, fc, fog);\n    v *= v;\n    \n    vec3 col = 1.-vec3(.67, .45, .05);\n    col = pow(vec3(v), col*1.5 );\n    \n\t// subtle texture\n    col += .004*(texture(iChannel0, fragCoord*.001*r(.2)+.1).x-.5)\n          +.008*(texture(iChannel0, fragCoord*.002*r(.3)+.1).x-.5)\n          +.015*(texture(iChannel0, fragCoord*.004*r(.5)+.1).x-.5)\n          +.03 *(texture(iChannel0, fragCoord*.008*r(.7)+.1).x-.5);\n    \n    col = smoothstep(0., 1., 2.3*col);\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 160, 160, 377], [379, 538, 575, 575, 1224], [1226, 1271, 1296, 1296, 1702], [1704, 1704, 1723, 1723, 1959], [1961, 1961, 1992, 1992, 2158], [2160, 2160, 2181, 2181, 2332], [2335, 2335, 2392, 2392, 3328]], "test": "error"}
{"id": "3tXcz4", "name": "more Circuit Diagram 2 ( 95 ch )", "author": "FabriceNeyret2", "description": "( I already so them in shadertoy under other names, but can find back ).", "tags": ["2d", "xor", "pattern", "onetweet", "golf", "circuits"], "likes": 4, "viewed": 195, "published": "Public API", "date": "1591509022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3lfyz4\n\nvoid mainImage(out vec4 O, vec2 U) {\n  int r = int(U) ^ int(U.y + 30.*iTime);\n  O = fract(vec4(r*r*r)/(997.+vec4(0,1,2,1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 175]], "test": "ok"}
{"id": "3tXczl", "name": "Boze Factory", "author": "kaiware007", "description": "Emission Test", "tags": ["raymarching", "brdf"], "likes": 2, "viewed": 63, "published": "Public", "date": "1592819518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG1 6.0\n#define MAT_BG2 7.0\n#define MAT_CS 8.0\n\n#define AA 1\n    \nstruct surface {\n\tfloat dist;\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n};\n\n// Surface Data Define\n#define SURF_BLACK(d) \t(surface(d, vec3(0.), vec3(0), 0.3, 0.0, 0))\n#define SURF_FACE(d) \t(surface(d, vec3(1,0.7,0.6), vec3(0), 0.3, 0.8, 0))\n#define SURF_MOUSE(d) \t(surface(d, vec3(1,0,0.1), vec3(0), 0.3, 0.0, 0))\n#define SURF_CHEEP(d) \t(surface(d, vec3(1,0.3,0.4), vec3(0), 0.3, 0.0, 0))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    vec3 index = floor(pos * 10. + 0.5);\n    vec3 col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    return surface(d, col, vec3(0), 0.1, 0.8, 0);\n}\n#define SURF_CS(d) \t\t(surface(d, vec3(0.9), vec3(0,0,0), 0.1, 0.8, 0))\n#define SURF_EMIT(d) \t(surface(d, vec3(0), vec3(0,1,0), 0.9, 0.0, 0))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n    \treturn surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness, d1.count);\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec3 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        return surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness, d2.count);\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float sc)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0 / sc);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.035, 0.01 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float sc)\n{    \n    float x = 0.05;\n    float z = -0.175;\n    float r = 0.0045 * sc;\n    float rb1 = 100. / sc;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, rb1), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -rb1), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float sc)\n{\n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.1) * sc, vec3(0.0175,0.0025,0.1) * sc, 0.001*sc);\n}\n\nsurface sdBoze(vec3 p, float sc, float ms)\n{    \n    //vec2 result = vec2(0.);\n    surface result = surface(0., vec3(0), vec3(0), 0., 0., 0);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp, sc);\n    d = opUnion(d, d2);\n\n    //vec2 head = vec2(d, MAT_FACE);\n\tsurface head = SURF_FACE(d);\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    //vec2 eye = vec2(d4, MAT_BLACK);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    //vec2 mouse = vec2(d6, MAT_BROW);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp, sc);\n    //vec2 cheep = vec2(d7, MAT_CHEEP);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp, sc);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    //head = opPaint(head, eye);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    //result = opPaint(result, cheep);\n    \n    //surface s = surface(result.x, vec3(1), vec3(0), 0.3, 0.1);\n            \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, float sc, float ms)\n{\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sc, 0), 0.06 * sc, 0.5 * sc, 0.25 * sc));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = surface(MAX_DIST, vec3(0), vec3(0), 0., 0., 0);\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float t = iTime * 0.1 * M_PI2;\n\n    p = rotate(p, M_PI, vec3(0,1,0));\n    vec3 q = opRep(p, vec3(0.5, 5., 0.5));\n    \n    result = sdBoze(q, 1., sin(t*3.)*0.5 + 0.5);\n    //result = opSU(sdBoze(p + vec3(cos(t)*-0.05-0.05,0.05,0), 1., cos(t * 3.8)*0.5+0.5), result, 0.01);\n\n    // background\n    //vec2 bg1 = vec2(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)), MAT_BG1);\n    surface bg1 = SURF_BG1(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)), p);\n    \n    vec3 index = floor(p * 2. + 0.5);\n    float rnd = hash13(vec3(index.x,0,index.z));\n    vec3 rnd3 = hash33(vec3(index.x,0,index.z));\n    \n    //vec3 q = opRep(p, vec3(0.5, 5., 0.5));\n    q = TwistY(q, 2.*M_PI2);\n    q = rotate(q, t+rnd*M_PI2, vec3(0,1,0));\n    q += vec3(0.02,0,0.02);\n    float w = 0.025;\n    //vec3 col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    vec3 col = sinebow(rnd + iTime * 3.5) * saturate(noise(rnd3 + vec3(iTime * 10.5,0,0))*2.5-1.);\n    surface bg2 = surface(sdRoundBox(q, vec3(w,5.,w), 0.01), vec3(0), saturate((sin(q.y * 100.-t*2.)*10.0-5.))*col, 0.1, 0.8, 0);\n    \n    result = opU(result, opSU(bg1, bg2, 0.1));\n    \n\treturn result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < 0.0001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction) {\n    float material = 0.0;\n\n    float t = 0.02;\n    \n    vec3 pos;\n    int count = 0;\n    surface hit;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = origin + direction * t;\n        hit = map(pos);\n\n        hit.dist *= 0.5;\n        \n        t += hit.dist;\n        //material = hit.y;\n\n        count++;\n        if (hit.dist <= 0.000001 || hit.dist >= MAX_DIST) {\n        \tbreak;\n        }\n    }\n\n    return surface(t, hit.albedo, hit.emission, hit.roughness, hit.metalness, count);\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    return vec3(0);\n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    //vec3 indirectDiffuse = vec3(0);\n    \n    /*\n    vec3 indirectSpecular = vec3(0);//indirectHit.albedo;\n    vec3 indirectEmission = vec3(0);//indirectHit.emission;\n    \n    vec3 r2 = r;\n    vec3 p = pos;\n    vec3 n2 = normal;\n    \n    for(int i = 0; i < 1; i++)\n    {\n        surface indirectHit = traceRay(p, r2);\n\n        vec3 indirectPosition = p + indirectHit.dist * r2;        \n\t\tfloat reflength = length(indirectPosition - p);\n        \n        if(reflength >= 0.){\n            //vec3 sky = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        \tvec3 sky = 0.8 * SkyColor(r2) * metallic;\n\n        \t// fog\n        \tindirectSpecular += mix(indirectHit.albedo, sky, 1.0 - saturate(exp2(-4.0 * reflength * reflength)));\n            indirectEmission += mix(indirectHit.emission, sky, 1.0 - saturate(exp2(-4.0 * reflength * reflength)));\n            \n        }\n\t\tn2 = norm(indirectPosition);\n        r2 = normalize(reflect(r2, n2));\n        p = indirectPosition;\n    }\n\t*/\n    // indirect contribution\n    //vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n    //vec3 specularColor = f0 * dfg.x + dfg.y;\n\t//vec3 ibl = diffuseColor * indirectDiffuse * 1.0 + indirectSpecular * specularColor;\n    //vec3 ibl = diffuseColor * indirectDiffuse * 1.0 + specularColor;\n    vec3 ibl = diffuseColor * indirectDiffuse;\n    //vec3 ibl = specularColor;\n    \n    color += ibl * indirectIntensity;\n\t//color += surf.emission + metallic * indirectIntensity * indirectEmission;\n    color += surf.emission;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 ro, vec3 p, vec3 ray, surface mat, vec2 uv)\n{\n    vec3 col = vec3(0);\n    vec3 sky = SkyColor(ray);\n    \n    float t = iTime * 1.0 + M_PI * 1.5;\n    float r = 2.0;\n    vec3 lightPos = vec3(0.6, 0.8, -0.0);\n    float dist = mat.dist;\n    if (mat.dist >= MAX_DIST) {\n        col = sky;\n    } else {\n        vec3 result = vec3(0.);\n        vec3 nor = norm(p);\n\t\tvec3 sky = 0.8 * SkyColor(ray) * mat.metalness;\n        \n        col = calcAmb(p, ray, nor, lightPos, vec3(0.98, 0.92, 0.89) * 3.0, mat);\n        col = mix(col, sky, 1.0 - saturate(exp2(8.0 - dist * dist)));\n        float metalness = mat.metalness;\n        vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n        // reflection\n        for(int i = 0; i < 2; i++)\n        {\n            vec3 nor = norm(p);\n            ray = normalize(reflect(ray, nor));\n            surface indirectHit = traceRay(p, ray);\n           \tvec3 indirectPosition = p + indirectHit.dist * ray;\n            float reflength = length(indirectPosition - p);\n            p = indirectPosition;\n            mat = indirectHit;\n\n            result = calcAmb(p, ray, nor, lightPos, lightColor, mat);\n\n            vec3 sky = 0.8 * SkyColor(ray) * mat.metalness;\n\n            dist += indirectHit.dist;\n        \t\n            // Exponential distance fog\n        \tresult = mix(result, sky, 1.0 - saturate(exp2(4.0 - dist * dist)));\n            \n            col += result * metalness;\n            metalness = mat.metalness;\n        }\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray);\n    \n    pos = p + mat.dist * ray;\n    return materialize(p, pos, ray, mat, uv);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float t = iTime * M_PI2 * 0.1;\n        //float t = 0.;\n        float y = sin(t * 2.5) * 0.125+0.25;\n        //float r = 2. + sin(t * 0.5)*0.5;\n        float r = 1.5;\n        float theta = t + RAD90 + RAD90*0.25;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        vec3 ro = vec3(cos(theta) * r, 0.24 + y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0.05, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1138, 1138, 1175, 1175, 1368], [1511, 1511, 1534, 1534, 1607], [1609, 1609, 1630, 1630, 1700], [1702, 1702, 1725, 1725, 1804], [1807, 1807, 1829, 1829, 2246], [2249, 2249, 2310, 2310, 2448], [2451, 2511, 2537, 2537, 3403], [3405, 3593, 3616, 3616, 3719], [3721, 3740, 3762, 3762, 3895], [3897, 3917, 3939, 3939, 4064], [4065, 4164, 4200, 4200, 4228], [4230, 4230, 4276, 4276, 4332], [4334, 4334, 4384, 4384, 4502], [4504, 4504, 4541, 4541, 4630], [4632, 4632, 4702, 4702, 4836], [4838, 4838, 4902, 4902, 5019], [5021, 5021, 5054, 5080, 5111], [5113, 5113, 5138, 5138, 5157], [5158, 5158, 5183, 5183, 5202], [5203, 5203, 5239, 5239, 5267], [5269, 5269, 5328, 5328, 5641], [5643, 5700, 5737, 5778, 5861], [5863, 5863, 5902, 6074, 6232], [6234, 6234, 6283, 6283, 6706], [6708, 6708, 6747, 6793, 6878], [6880, 6880, 6921, 7031, 7194], [7209, 7260, 7297, 7297, 7319], [7321, 7321, 7364, 7364, 7386], [7388, 7388, 7432, 7432, 7453], [7455, 7455, 7507, 7507, 7606], [7609, 7609, 7654, 7654, 8083], [8085, 8085, 8106, 8106, 8174], [8176, 8176, 8216, 8216, 8341], [8344, 8344, 8379, 8379, 8527], [8529, 8529, 8563, 8563, 8739], [8741, 8741, 8772, 8772, 8821], [8823, 8823, 8858, 8858, 8893], [8895, 8895, 8932, 8932, 8967], [8969, 9140, 9225, 9225, 9302], [9304, 9347, 9422, 9422, 9814], [10071, 10071, 10102, 10102, 10256], [10282, 10282, 10314, 10314, 10427], [10429, 10429, 10472, 10472, 10718], [10720, 10720, 10753, 10753, 11365], [11367, 11367, 11402, 11402, 11553], [11555, 11555, 11599, 11633, 12957], [12959, 12959, 13026, 13026, 13148], [13150, 13150, 13196, 13196, 13340], [13342, 13342, 13411, 13411, 13629], [13849, 13849, 13870, 13870, 15153], [15673, 15673, 15722, 15722, 16023], [16025, 16025, 16078, 16078, 16569], [16835, 16903, 16931, 16931, 17058], [17060, 17150, 17213, 17213, 17419], [17421, 17487, 17551, 17721, 18352], [18354, 18354, 18380, 18380, 18802], [18978, 18978, 18999, 18999, 19047], [19049, 19049, 19110, 19195, 19394], [19396, 19396, 19469, 19561, 19761], [19763, 19763, 19805, 19885, 19939], [19941, 19941, 19990, 19990, 20038], [20040, 20040, 20113, 20170, 20385], [20387, 20387, 20407, 20407, 20432], [20619, 20619, 20669, 20753, 21111], [21113, 21113, 21168, 21225, 21485], [21487, 21487, 21583, 21583, 24332], [24536, 24536, 24569, 24625, 24811], [24813, 24813, 24852, 24852, 24895], [24897, 24913, 24986, 24986, 25070], [25072, 25198, 25268, 25268, 25551], [25553, 25553, 25653, 25653, 26446], [26448, 26448, 26515, 26515, 28162], [28164, 28164, 28204, 28204, 28337], [28339, 28339, 28381, 28381, 28559]], "test": "timeout"}
{"id": "3tXyD8", "name": "Primitives Bàsiques", "author": "ferranSanchezUB", "description": "Es pot observar diferents primitives que van canviant cada 10 segons (modificable en una constant).\nLlistat de primitives: Esfera, Pla, Caixa, torus i Cilindre.", "tags": ["raymarching", "primitives"], "likes": 2, "viewed": 34, "published": "Public", "date": "1591897042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float SWAP_TIME = 10.0;\n\n//Color cel\nconst vec3 background = vec3(0.529, 0.808, 0.922);\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sphereSDF(vec3 X, vec3 C, float r) { \n    return length(X - C) - r; \n}\n\nfloat planeSDF(vec3 X, vec3 C, vec3 N) {\n    return dot(X - C, N);\n}\n\nfloat boxSDF(vec3 X, vec3 C, vec3 b) {\n    vec3 q = abs(X - C) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\nfloat torusSDF(vec3 X, vec3 C, float r, float R) {\n    return length(vec2(length(X.xz - C.xz) - r, X.y - C.y)) - R;\n}\n\nfloat cylinderSDF(vec3 X, vec3 C, float r, float e) {\n    vec2 q = abs(vec2(length(X.xz - C.xz), X.y - C.y)) - vec2(r, e);\n    return min(max(q.x,q.y), 0.0) + length(max(q, 0.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    samplePoint = rotateX(iTime / 2.0) * samplePoint;\n    vec3 C = vec3(0.0);\n   \n    \n    switch (int(iTime / SWAP_TIME) % 5){\n        case 0:\n        \treturn sphereSDF(samplePoint, C, 1.2);\n        case 1:\n        \treturn planeSDF(samplePoint, C, vec3(0.0, 1.0, 0.0));\n        case 2:\n        \treturn boxSDF(samplePoint, C, vec3(1.8, 1.8, 1.8));\n        case 3:\n        \treturn torusSDF(samplePoint, C, 1.2, 0.8);\n\t\tcase 4:\n        \treturn cylinderSDF(samplePoint, C, 1.2, 1.8);\n    }\n}\n\nvec3 estimateNormal(vec3 p) { // per la funcio sceneSDF(p)\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*EPSILON ) + \n                      k.yyx*sceneSDF( p + k.yyx*EPSILON ) + \n                      k.yxy*sceneSDF( p + k.yxy*EPSILON ) + \n                      k.xxx*sceneSDF( p + k.xxx*EPSILON ) );\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(background, 1.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 265, 292, 292, 439], [441, 487, 514, 514, 661], [663, 709, 736, 736, 883], [885, 885, 927, 927, 961], [963, 963, 1003, 1003, 1031], [1033, 1033, 1071, 1071, 1166], [1168, 1168, 1218, 1218, 1285], [1287, 1287, 1340, 1340, 1468], [1470, 1710, 1744, 1783, 2272], [2274, 2274, 2303, 2332, 2609], [2611, 3032, 3123, 3123, 3429], [3444, 3698, 3763, 3763, 3895], [3897, 4389, 4529, 4529, 5119], [5121, 5491, 5576, 5576, 6376], [6378, 6705, 6754, 6789, 6920], [6922, 6922, 6979, 6979, 7890]], "test": "error"}
{"id": "3tXyRM", "name": "Trippy Shitty Waves", "author": "sin3point14", "description": "two opposite waves", "tags": ["waves"], "likes": 2, "viewed": 185, "published": "Public API", "date": "1591652575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist = 7.0f * length(fragCoord.xy - iResolution.xy)/length(iResolution.xy);\n    float red = abs(cos(iTime - dist));\n    //float red = 0.0f;\n    dist = 7.0f * length(fragCoord.xy)/length(iResolution.xy);\n    float green = abs(cos(iTime - dist));\n\t//float green = 0.0f;\n    fragColor = vec4(red, green, 0.0f, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 383]], "test": "ok"}
{"id": "3tXyRN", "name": "Minimal raymarching color", "author": "TAKUSAKU", "description": "Minimal raymarching with bit operator coloring", "tags": ["raymarching", "color", "minimal", "bitwise"], "likes": 10, "viewed": 113, "published": "Public", "date": "1591510895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define r iResolution\n\n//Based on https://twitter.com/yosshin4004/status/1251357672504360966\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    vec3 d=vec3(U/r.xy-.5,.5),p=vec3(0,6,t),q;\n    for(int i=0;i<99;i++)\n    {\n        p+=d*(length(sin(p.zxy*.6)-cos(p.xyz))-.5);\n        if(i==94)q=p+=d=vec3(.6);\n    }\n    ivec3 u=ivec3(q*5e2);\n    o+=vec4(u.y&150,u.x&99,u.z&99,0)/1e3*length(p-q)+(p.z-t)*.03;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 151, 151, 416]], "test": "timeout"}
{"id": "3tXyzl", "name": "Color Blend Boze", "author": "kaiware007", "description": "Color Blend Test ", "tags": ["raymarching", "brdf"], "likes": 4, "viewed": 76, "published": "Public", "date": "1592725137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG1 6.0\n#define MAT_BG2 7.0\n#define MAT_CS 8.0\n\n#define AA 1\n    \nstruct surface {\n\tfloat dist;\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n};\n\n// Surface Data Define\n#define SURF_BLACK(d) \t(surface(d, vec3(0.), vec3(0), 0.3, 0.0, 0))\n#define SURF_FACE(d) \t(surface(d, vec3(1,0.7,0.6), vec3(0), 0.3, 0.0, 0))\n#define SURF_MOUSE(d) \t(surface(d, vec3(1,0,0.1), vec3(0), 0.3, 0.0, 0))\n#define SURF_CHEEP(d) \t(surface(d, vec3(1,0.3,0.4), vec3(0), 0.3, 0.0, 0))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    vec3 index = floor(pos * 10. + 0.5);\n    vec3 col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    return surface(d, vec3(1,0.3,0.4), vec3(0), 0.1, 0.0, 0);\n}\n#define SURF_CS(d) \t\t(surface(d, vec3(0.9), vec3(0,0,0), 0.1, 0.8, 0))\n#define SURF_EMIT(d) \t(surface(d, vec3(0), vec3(0,1,0), 0.9, 0.0, 0))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n    \treturn surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness, d1.count);\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec3 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        return surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness, d2.count);\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float sc)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0 / sc);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.035, 0.01 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float sc)\n{    \n    float x = 0.05;\n    float z = -0.175;\n    float r = 0.0045 * sc;\n    float rb1 = 100. / sc;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, rb1), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -rb1), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float sc)\n{\n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.1) * sc, vec3(0.0175,0.0025,0.1) * sc, 0.001*sc);\n}\n\nsurface sdBoze(vec3 p, float sc, float ms)\n{    \n    //vec2 result = vec2(0.);\n    surface result = surface(0., vec3(0), vec3(0), 0., 0., 0);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp, sc);\n    d = opUnion(d, d2);\n\n    //vec2 head = vec2(d, MAT_FACE);\n\tsurface head = SURF_FACE(d);\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    //vec2 eye = vec2(d4, MAT_BLACK);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    //vec2 mouse = vec2(d6, MAT_BROW);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp, sc);\n    //vec2 cheep = vec2(d7, MAT_CHEEP);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp, sc);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    //head = opPaint(head, eye);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    //result = opPaint(result, cheep);\n    \n    //surface s = surface(result.x, vec3(1), vec3(0), 0.3, 0.1);\n            \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, float sc, float ms)\n{\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sc, 0), 0.06 * sc, 0.5 * sc, 0.25 * sc));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = surface(MAX_DIST, vec3(0), vec3(0), 0., 0., 0);\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float t = iTime * 0.2 * M_PI2;\n\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    result = sdBoze(p + vec3(cos(t)*0.05+0.05,0.05,sin(t*2.)*0.05), 1., sin(t*3.)*0.5 + 0.5);\n    result = opSU(sdBoze(p + vec3(cos(t)*-0.05-0.05,0.05,cos(t*2.3)*0.05), 1., cos(t * 3.8)*0.5+0.5), result, 0.01);\n\n    float st = t * 1.0;\n\n    const float num = 16.;\n    float z = sin(t*2.5)*0.025+0.05;\n    for(int i = 0; i < int(num); i++){\n        float r = float(i) * M_PI2 / num + st; \n        vec3 col = sinebow(float(i)/num);\n        float len = sin(r * 1.85 + iTime * 3.) * 0.5 + 0.75;\n    \t//surface l = surface(sdCapsule(p, vec3(cos(r) * 0.2, sin(r) * 0.15, -sin(st)*0.1), vec3(cos(r) * 1.0, sin(r) * 0.75, -sin(st)*0.1), sin(t*2.5)*0.025 + 0.05), col, vec3(0), 0.1, 0.0, 0);\n        surface l = surface(sdCapsule(p, vec3(0,0,z), vec3(cos(r) * len, sin(r) * len, z), cos(r * 1.85 + iTime * 3.)*0.01 + 0.02), col, vec3(0), 0.1, 0.0, 0);\n        //surface sphere = surface(sdSphere(p + vec3(cos(r) * 0.2, sin(r) * 0.15 - 0.05, -sin(st)*0.1), sin(t*2.5)*0.025 + 0.05), col, vec3(0), 0.1, 0.0, 0);\n\t\tresult = opSU(result, l, 0.05);\n    }\n    \n\treturn result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < 0.0001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction) {\n    float material = 0.0;\n\n    float t = 0.02;\n    \n    vec3 pos;\n    int count = 0;\n    surface hit;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = origin + direction * t;\n        hit = map(pos);\n\n        t += hit.dist;\n        //material = hit.y;\n\n        count++;\n        if (hit.dist <= 0.0001 || hit.dist >= MAX_DIST) {\n        \tbreak;\n        }\n    }\n    /*\n    if (t >= MAX_DIST) {\n        t = MAX_DIST;\n        material = 0.0;        \n    }\n*/\n    //return vec3(t, material, count);\n    return surface(t, hit.albedo, hit.emission, hit.roughness, hit.metalness, count);\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    return vec3(0);\n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    surface indirectHit = traceRay(pos, r);\n    vec3 indirectSpecular = indirectHit.albedo;\n    vec3 indirectEmission = indirectHit.emission;\n    \n    //if (indirectHit.y > 0.0) \n    {\n        vec3 indirectPosition = pos + indirectHit.dist * r;        \n\t\tfloat reflength = length(indirectPosition - pos);\n        \n        if(reflength >= 0.){\n            //vec3 sky = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        \tvec3 sky = 0.8 * SkyColor(r) * metallic;\n\n        \t// fog\n        \tindirectSpecular = mix(indirectSpecular, sky, 1.0 - saturate(exp2(-0.1 * reflength * reflength)));\n            indirectEmission = mix(indirectEmission, sky, 1.0 - saturate(exp2(-0.1 * reflength * reflength)));\n        }\n\t\t\n    }\n\t\n    // indirect contribution\n    vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n    vec3 specularColor = f0 * dfg.x + dfg.y;\n\tvec3 ibl = diffuseColor * indirectDiffuse * 1.0 + indirectSpecular * specularColor;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission + indirectEmission;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 ro, vec3 p, vec3 ray, surface mat, vec2 uv)\n{\n    vec3 col = vec3(0);\n    vec3 sky = SkyColor(ray);\n    \n    float t = iTime * M_PI * 0.2 + M_PI * 1.5;\n    float r = 2.0;\n    //vec3 lightPos = vec3(0.6, 0.8, -0.0);\n    vec3 lightPos = vec3(cos(t)*r, 0.8, sin(t)*r);\n    \n    if (mat.dist >= MAX_DIST) {\n        col = sky;\n    } else {\n        //if(mat.y > 0.0)\n        {\n            vec3 nor = norm(p);\n            //float roughness, metalness;\n            //col = materialColor(p, mat, roughness, metalness);\n\n            vec3 result = vec3(0.);\n            //result = calcAmb(p, ray, nor, lightPos, vec3(0.98, 0.92, 0.89) * 3.0, col, roughness, metalness);\n            result = calcAmb(p, ray, nor, lightPos, vec3(0.98, 0.92, 0.89) * 3.0, mat);\n            col = result;\n        }\n    }\n    \n    // Exponential distance fog\n    col = mix(col, 0.8 * sky, 1.0 - saturate(exp2(400.0-mat.dist * mat.dist)));\n\n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray);\n    \n    pos = p + mat.dist * ray;\n    return materialize(p, pos, ray, mat, uv);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif    \n        float t = iTime * M_PI * 0.2;\n        float y = 0.05;\n        float r = 1.0;\n        //vec3 ro = vec3(sin(t) * 0.25, y + cos(t * 2.13 + 3.5354) * 0.25, -r);\n        vec3 ro = vec3(0, y, -r);\n        vec3 ta = vec3(0., y, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1138, 1138, 1175, 1175, 1380], [1523, 1523, 1546, 1546, 1619], [1621, 1621, 1642, 1642, 1712], [1714, 1714, 1737, 1737, 1816], [1819, 1819, 1841, 1841, 2258], [2261, 2261, 2322, 2322, 2460], [2463, 2523, 2549, 2549, 3415], [3417, 3605, 3627, 3627, 3760], [3762, 3861, 3897, 3897, 3925], [3927, 3927, 3973, 3973, 4029], [4031, 4031, 4081, 4081, 4199], [4201, 4201, 4238, 4238, 4327], [4329, 4329, 4399, 4399, 4533], [4535, 4535, 4599, 4599, 4716], [4718, 4718, 4751, 4777, 4808], [4810, 4810, 4835, 4835, 4854], [4855, 4855, 4880, 4880, 4899], [4900, 4900, 4936, 4936, 4964], [4966, 4966, 5025, 5025, 5338], [5340, 5397, 5434, 5475, 5558], [5560, 5560, 5599, 5771, 5929], [5931, 5931, 5980, 5980, 6403], [6405, 6405, 6444, 6490, 6575], [6577, 6577, 6618, 6728, 6891], [6906, 6957, 6994, 6994, 7016], [7018, 7018, 7061, 7061, 7083], [7085, 7085, 7129, 7129, 7150], [7152, 7152, 7204, 7204, 7303], [7306, 7306, 7351, 7351, 7780], [7782, 7782, 7803, 7803, 7871], [7873, 7873, 7913, 7913, 8038], [8041, 8041, 8076, 8076, 8224], [8226, 8226, 8260, 8260, 8436], [8438, 8438, 8469, 8469, 8518], [8520, 8520, 8555, 8555, 8590], [8592, 8592, 8629, 8629, 8664], [8666, 8837, 8922, 8922, 8999], [9001, 9044, 9119, 9119, 9511], [9768, 9768, 9799, 9799, 9953], [9979, 9979, 10011, 10011, 10124], [10126, 10126, 10169, 10169, 10401], [10403, 10403, 10436, 10436, 11048], [11050, 11050, 11085, 11085, 11236], [11238, 11238, 11282, 11316, 12640], [12642, 12642, 12709, 12709, 12831], [12833, 12833, 12879, 12879, 13023], [13025, 13025, 13094, 13094, 13312], [13532, 13532, 13553, 13553, 14807], [15327, 15327, 15376, 15376, 15677], [15679, 15679, 15732, 15732, 16320], [16586, 16654, 16682, 16682, 16809], [16811, 16901, 16964, 16964, 17170], [17172, 17238, 17302, 17472, 18103], [18105, 18105, 18131, 18131, 18553], [18729, 18729, 18750, 18750, 18798], [18800, 18800, 18861, 18946, 19145], [19147, 19147, 19220, 19312, 19512], [19514, 19514, 19556, 19636, 19690], [19692, 19692, 19741, 19741, 19789], [19791, 19791, 19864, 19921, 20136], [20138, 20138, 20158, 20158, 20183], [20370, 20370, 20420, 20504, 20862], [20864, 20864, 20919, 20976, 21236], [21238, 21238, 21334, 21334, 23614], [23818, 23818, 23851, 23907, 24093], [24095, 24095, 24134, 24134, 24177], [24179, 24195, 24268, 24268, 24352], [24354, 24480, 24550, 24550, 24833], [24835, 24835, 24935, 24935, 25728], [25730, 25730, 25797, 25797, 26889], [26891, 26891, 26931, 26931, 27064], [27066, 27066, 27108, 27108, 27286]], "test": "timeout"}
{"id": "ls3yRN", "name": "Refractive Planes", "author": "stb", "description": "Just something I never posted... until now!", "tags": ["2d", "fractal", "refraction", "shading", "parallax", "25d", "planes"], "likes": 7, "viewed": 97, "published": "Public", "date": "1591664092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tRefractive Planes (Fractal Planes)\n\t201x-2020 stb\n\tMessy code is messy.\n\n\tNotes: bumbed the trace level up to 12... sorry for any burning GPUs :/\n\n*/\n\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nvec2 cInv(vec2 p, vec2 o, float r) {\n    return (p-o) * r * r / dot(p-o, p-o) + o;\n}\n\nvec2 cInvMir(vec2 p, vec2 o, float r, float flip){\n    return (length(p-o)<r ^^ flip==1. ? cInv(p, o, r) : p);\n}\n\nfloat map(in vec2 p, float z) {\n    for(int i=0; i<8; i++) {\n        p *= 1.1;\n        p.x = max(0., abs(mod(p.x, 4.)-2.)-.1);\n        p.y = max(0., abs(mod(p.y, 4.)-2.)+.5);\n        p -= vec2(.5, .83);\n        \n        p = rotate(p, radians(45.-3.*z));\n        p.y = abs(p.y+.03)-.03;\n        \n        p = cInvMir(p, vec2(.3, .3), 1.4, 1.);\n    }\n    return length(p);\n}\n\nvec3 getNorm(vec2 p, float z) {\n    vec3 acc = vec3(-1., 0., 1.) / iResolution.y * 2.;\n    return\n        normalize(\n            vec3(\n                map(p+acc.zy, z) - map(p+acc.xy, z),\n            \tmap(p+acc.yz, z) - map(p+acc.yx, z),\n            \tacc.z\n\t\t\t)\n\t\t);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n    vec2 res = iResolution.xy;\n    vec2 p = 2. * (fc-res/2.) / res.y;\n    vec2 m = 8. * (iMouse.xy-res.xy/2.) / res.xy;\n    \n    vec3 pos = vec3(0., 0., .25);\n    vec3 dir = vec3(p.xy, 1.);\n    vec3 hit;\n    \n    float fSky = clamp(pow(1.-.3*abs(p.y), 3.), 0., 1.);\n    float alpha=0.;\n    vec3 col = vec3(0.);\n    \n    vec3 rgbSolid = vec3(1., .8, .5);\n    vec3 rgbClear = vec3(.5, .7, 1.);\n    vec3 rgbSky = fSky * vec3(.4, .5, .8);\n    \n    vec3 lPos = (vec3(1., .25, -1.3));\n    \n    float T = -.3*iTime;\n    \n    pos.z -= fract(T);\n    \n    const int I = 12;\n    for(int i=0; i<=I; i++) {\n        \n        pos.z += dir.z;\n        \n        hit = dir*pos.z;\n        hit.xy += vec2(sin(T), cos(T));\n        \n        if(iMouse.x>0.)\n    \t\thit.xy += m.xy;\n        \n        float pattern = clamp(1.-map(hit.xy, hit.z), 0., 1.);\n        \n        float mask = clamp(smoothstep(.35, .4, pattern), 0., 1.);\n        \n        vec3 norm = getNorm(hit.xy, pos.z);\n        \n        vec3 diffuse = vec3(1.) * clamp(dot(norm, lPos), 0., 1.);\n        diffuse += 2. * vec3(.5, .75, 1.) * clamp(dot(norm, vec3(-1., 0., -.3)), 0., 1.);\n        \n        col = mix(mix(rgbSolid*vec3(pattern*.5+1.*diffuse), rgbSky, (float(i)-fract(T))/float(I)), col, alpha);\n        \n        float fade = i==0 ? (1.-fract(T)) : 1.;\n        \n        // refraction\n        dir = refract(dir, norm*.1*fade, 1./1.03);\n        \n        dir /= dir.z;\n        \n        alpha += mask;\n        alpha = clamp(alpha*fade, 0., 1.);\n        \n        if(alpha>=1.) break;\n    }\n    \n    col = mix(col, rgbSky, max(0., 1.-alpha));\n    \n    fo = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3yRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 263, 263, 311], [427, 427, 458, 458, 798], [800, 800, 831, 831, 1068]], "test": "timeout"}
{"id": "MlVfz3", "name": "Neutron Star", "author": "milolouis", "description": "Dancing kaleidoscope star. NEW AND IMPROVED!", "tags": ["sstar"], "likes": 2, "viewed": 226, "published": "Public API", "date": "1591121553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nfloat circle(vec2 fragCoord, vec2 centreCoord, float radius)\n{\n    return radius / length(fragCoord - centreCoord);\n}\n\nvec3 drawStar(vec2 fragCoord, vec2 centreCoord, float radius)\n{\n    float r = circle(fragCoord, centreCoord, tan(iTime + 1.0) * radius + 100.);\n    float g = circle(fragCoord, centreCoord, tan(iTime + 1.2) * radius + 100.);\n    float b = circle(fragCoord, centreCoord, tan(rand(iTime) + 0.7) * radius + 100.);\n               \n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 centre = iResolution.xy / 2.0;\n    \n    vec3 val = drawStar(fragCoord, centre, 50.0);\n\n    fragColor = vec4(val,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVfz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 146, 146, 194], [196, 196, 258, 258, 313], [315, 315, 378, 378, 666], [668, 668, 725, 725, 857]], "test": "timeout"}
{"id": "tdBcDK", "name": "Get Numb", "author": "trickstival", "description": "Just get numb boi", "tags": ["ripple", "numb"], "likes": 1, "viewed": 51, "published": "Public", "date": "1591130834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float distanceToCenter = distance(uv, vec2(.5));\n    float rippleColor = sin(distanceToCenter * 200. - iTime * 20.);\n    rippleColor = smoothstep(rippleColor, rippleColor - .9, distanceToCenter);\n\n    vec3 col = vec3(rippleColor);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 445]], "test": "ok"}
{"id": "tdjfWc", "name": "Day 165 - Not good rasterizer", "author": "jeyko", "description": "potato", "tags": ["rasterizer", "mdmtjvm"], "likes": 6, "viewed": 271, "published": "Public API", "date": "1591040406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Used Inigo Quilez's rasterizer as a reference - https://www.shadertoy.com/view/4slGzn\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n#define SZ 40 \n\nvec3[SZ*3] vertices;\n\nvec3[SZ] cols;\n\nvec3 r31(float i){\n\treturn texture(iChannel0,vec2(floor(i/256.),mod(i,256.))).xyz;\n}\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float z = 10000.;\n    \n    vec3 col = vec3(0);\n\n    \n    uv *= 3.;\n    \n    // generate vertices and colours\n    for(float i = 0.; i < float(SZ*3+min(iFrame,0)); i++){\n        vec3 vertice;\n        \n        float mult = 4.8;\n        vertice.xy = vec2(cos(i*mult),sin(i*mult))*2.;\n        \n        vertice.xy *= 1.;\n        \n        \n        float kick = floor(iTime+5.) + pow(fract(iTime+5.),8.);\n        vertice.z = cos(mix(i*3.14*2.,i,abs(sin(kick/3.14/200.))))*4.4;\n        \n        vertice.xz *= rot(sin(iTime)/3.);\n        vertice.yx *= rot(cos(iTime)/3.);\n        \n        \n        vertice.z += 5.6 ; // camera offs\n        \n        //vertice.z = 1.;\n        cols[int(i)/3] = 0.5+sin(floor(i)  + uv.x/6. +iTime + sin(uv.y/3.)/1.+ vec3(1.,0.5,0.2))/2.;\n        \n    \tvertices[int(i)] = vertice;\n    }\n    \n    \n    // draw triangles\n    for(int i = 0; i < SZ+min(iFrame,0); i++){\n        vec3 va = vertices[i*3+0];\n        vec3 vb = vertices[i*3+1];\n        vec3 vc = vertices[i*3+2];\n  \t\t\n        vec3 tricol = cols[i];\n        \n        float zoffs = 0.;\n        \n        va.z -= zoffs;\n        vb.z -= zoffs;\n        vc.z -= zoffs;\n        \n        vec2 a = va.xy/va.z;\n        vec2 b = vb.xy/vb.z;\n        vec2 c = vc.xy/vc.z;\n  \t\n        vec3 cr = vec3(\n        \tcross2d(uv-a,b-a),\n            cross2d(uv-b,c-b),\n        \tcross2d(uv-c,a-c)\n        ); \n\n        if ((\n            cr.x>0. &&\n            cr.y>0. &&\n            cr.z>0.\n\t\t\t)\n           ){\n\t\t\tvec3 b = cr.zyx/(cr.z + cr.y + cr.x);\n            \n            float iz = b.x/va.z + b.y/vb.z + b.z/vc.z;\n            \n            vec3 c = 0.5+sin(floor(float(i)) + b.x + uv.x/6. +iTime + sin(uv.y/3.)/1.+ vec3(1.,0.6,0.2))/2.;\n\t\t\t//vec3 c = 0.5+sin(floor(float(i)) + b.x +iTime*0. + b.y*14.+ vec3(1.,0.5,0.2))/2.;\n\n            \n            col += (c)*(1.-length(col)*1.4);\n            \n            z = min(z,iz);\n\n        }\n\n    }\n    \n    col *= 0.9;\n    \n    \n    col = smoothstep(0.,1.,col);\n\tcol = mix(col,vec3(0.3,0.4,0.7)/11.,pow(smoothstep(0.,1.,z*0.7),2.));\n    \n    col *= 1. - dot(uv,uv)*0.06;\n    \n    col = pow(max(col,0.),vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 123, 123, 155], [210, 210, 228, 228, 294], [348, 348, 405, 405, 2626]], "test": "error"}
{"id": "tlByzR", "name": "Head (show primitives)", "author": "teadrinker", "description": "Amazing modelling by tdhooper:   https://www.shadertoy.com/view/wlf3WX\nI just wanted to see the primitives, so I added animation into smin()\n", "tags": ["animation", "head"], "likes": 20, "viewed": 427, "published": "Public API", "date": "1593549808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nBy:   https://www.shadertoy.com/user/tdhooper\nFrom: https://www.shadertoy.com/view/wlf3WX\n\n\nLicense: Creative Commons Attribution-NonCommercial\nhttps://creativecommons.org/licenses/by-nc/4.0/\n\n*/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\nfloat fHalfCapsule(vec3 p, float r) {\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\n}\n\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    k *= 0.5 * sin(iTime) + 0.5;\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nbool isEye = false;\n\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    p.y -= .11;\n\n    vec3 pa = p;\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = pp;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = pp;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n    \n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\n    brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // jaw\n\n    p = pp;\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = pp + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    // return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n\tisEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}\n\nfloat sstep(float t) {\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\n}\n\nfloat map(vec3 p) {\n    \n    float scale = 1.;\n    float s = .2;\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\n    float rx = sin(iTime * .33) * .2;\n\n    if (iMouse.z > 0.) {\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;\n    \trx = (.5 - iMouse.y / iResolution.y) * PI / 2.;\n        scale = 2.;\n    }\n    \n    pR(p.yz, rx);\n    pR(p.xz, ry);\n    \n    p /= scale;\n   \treturn mHead(p) * scale;\n}\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0005,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,3.2);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n    vec3 col = vec3(.1);\n\n    for (int i = 0; i < 150; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        dist = map(rayPosition);\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 5.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        vec3 albedo = isEye ? vec3(2) : vec3(1);\n        vec3 n = calcNormal(rayPosition);\n        vec3 lp = vec3(-.5,.5,.5);\n        float l = max(dot(lp, n), 0.);\n        vec3 ld = normalize(lp - rayPosition);\n        l += .02;\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\n        col = albedo * l;\n        col = pow(col, vec3(1./2.2));\n    }\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByzR.jpg", "access": "shaders20k", "license": "cc-by-4.0 OR cc-by-3.0", "functions": [[227, 227, 259, 259, 304], [306, 306, 333, 333, 363], [403, 403, 423, 423, 451], [453, 453, 473, 473, 511], [513, 513, 533, 533, 571], [573, 573, 593, 593, 621], [623, 623, 651, 651, 738], [740, 740, 764, 764, 826], [828, 828, 858, 858, 945], [948, 948, 985, 985, 1051], [1054, 1098, 1162, 1162, 1440], [1442, 1442, 1482, 1482, 1573], [1575, 1575, 1615, 1615, 1707], [1709, 1709, 1747, 1747, 1891], [1893, 1893, 1932, 1932, 1963], [1965, 1965, 2004, 2004, 2075], [2077, 2077, 2116, 2116, 2187], [2190, 2190, 2219, 2219, 2286], [2288, 2288, 2317, 2317, 2384], [2408, 2408, 2429, 2429, 11609], [11611, 11611, 11633, 11633, 11676], [11678, 11678, 11697, 11697, 12129], [12159, 12159, 12185, 12185, 12444], [12446, 12446, 12503, 12503, 13513]], "test": "timeout"}
{"id": "tlfcR2", "name": "Cradles of Newton", "author": "dr2", "description": "Lots of different 'Newton's Cradles' - mouseable", "tags": ["mechanics", "physics", "pendulum"], "likes": 12, "viewed": 228, "published": "Public API", "date": "1592481787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Cradles of Newton\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 Hashv3v2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltAx, qHit, fSize;\nvec2 gId, cellSz, csP, csS;\nfloat tCur, dstFar, cRad, szFac, pLen, sLen, bRad, pAng, kMin, kMax;\nint idObj;\nbool isOcc;\nconst float kLim = 4.;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid CellConf ()\n{\n  vec3 h;\n  float sAng;\n  h = Hashv3v2 (17.7 * gId + 1.1);\n  isOcc = (length (h) > 0.3);\n  szFac = min (1.2 + 0.7 * h.x, 1.6);\n  pAng = 0.2 * pi * sin (0.4 * 2. * pi * tCur / sqrt (szFac));\n  csP = sin (pAng + vec2 (0.5 * pi, 0.));\n  bRad = 0.3;\n  pLen = 1.2;\n  kMax = 1. + floor (kLim * h.y);\n  kMin = -1. + floor ((kMax + 1.) * h.z);\n  fSize = vec3 (1., pLen + bRad, (2. * kMax + 1.3) * bRad);\n  sAng = atan (fSize.x / (2. * pLen - bRad));\n  sLen = pLen / cos (sAng);\n  csS = sin (sAng + vec2 (0.5 * pi, pi));\n}\n\nfloat MechDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, fRad, sRad, sz;\n  dMin /= szFac;\n  p /= szFac;\n  fRad = 0.08;\n  sRad = 0.05;\n  for (float k = float (VAR_ZERO); k <= kLim; k ++) {\n    q = p;\n    q.y -= fSize.y + bRad - fRad + pLen;\n    if (k == 0.) {\n      if (kMin == 0.) q.yz = Rot2Cs (q.yz, csP);\n    } else {\n      sz = sign (q.z);\n      q.z = abs (q.z) - 2. * k * bRad;\n      if (k > kMin && sz * pAng > 0.) q.yz = Rot2Cs (q.yz, vec2 (csP.x, abs (csP.y)));\n    }\n    q.y -= - 2. * pLen;\n    d = PrSphDf (q, bRad);\n    DMINQ (2);\n    q.x = abs (q.x);\n    q.y -= bRad;\n    q.yx = Rot2Cs (q.yx, csS);\n    q.y -= sLen - bRad;\n    d = PrCylDf (q.zxy, sRad, sLen);\n    DMINQ (3);\n    if (k == kMax) break;\n  }\n  q = vec3 (abs (p.x) - fSize.x, p.y - 2. * fSize.y, p.z);\n  d = PrCapsDf (q, fRad, fSize.z);\n  DMINQ (4);\n  q = vec3 (p.x, p.y - 2. * fSize.y, abs (p.z) - fSize.z).yzx;\n  d = PrCapsDf (q, fRad, fSize.x);\n  DMINQ (5);\n  q = vec3 (abs (p.xz) - fSize.xz, p.y - fSize.y);\n  d = PrCylDf (q, fRad, fSize.y);\n  q.z -= - 0.97 * fSize.y;\n  d = min (d, PrCylDf (q, 3. * fRad, 0.03 * fSize.y));\n  DMINQ (5);\n  return dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, hc, r;\n  dMin = dstFar;\n  r = cRad - length (p.xz);\n  p.xz = Rot2D (p.xz, 2. * pi * cellSz.x * gId.x);\n  p.x += cRad + 3.;\n  p.y -= cellSz.y * gId.y;\n  q = p;\n  d = SmoothMax (r, - PrBoxDf (q, vec3 (4., 0.5 * cellSz.y - 0.5, 7.2)), 0.2);\n  DMINQ (1);\n  if (r < 0.01) {\n    if (isOcc) {\n      p.y -= - (0.5 * cellSz.y - 0.5);\n      dMin = MechDf (p, dMin);\n    }\n  } else dMin = min (dMin, r + 0.02);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float dHit, d;\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + dHit * rd;\n    gId = vec2 ((floor (atan (p.z, - p.x) / (2. * pi * cellSz.x)) + 0.5),\n       floor (p.y / cellSz.y + 0.5));\n    if (gId != gIdP) {\n      gIdP = gId;\n      CellConf ();\n    }\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BaseShd (vec3 p)\n{\n  vec3 q;\n  float d, sz;\n  d = dstFar / szFac;\n  p.xz = Rot2D (p.xz, 2. * pi * cellSz.x * gId.x);\n  p.x += cRad + 3.;\n  p.y -= cellSz.y * (gId.y - 0.5) + 0.5;\n  p /= szFac;\n  for (float k = float (VAR_ZERO); k <= kLim; k ++) {\n    q = p;\n    q.y -= fSize.y + bRad;\n    if (k == 0.) {\n      if (kMin == 0.) q.yz = Rot2Cs (q.yz, csP);\n    } else {\n      sz = sign (q.z);\n      q.z = abs (q.z) - 2. * k * bRad;\n      if (k > kMin && sz * pAng > 0.) q.yz = Rot2Cs (q.yz, vec2 (csP.x, abs (csP.y)));\n    }\n    d = min (d, length (q.xz));\n    if (k == kMax) break;\n  }\n  return smoothstep (1., 1.2, d / bRad);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ld;\n  float dstObj, lw, nDotR;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      nDotR = - dot (vn, rd);\n      if (vn.y < -0.99 && length (ro.xz) > cRad + 1. && nDotR > 0.) {\n        col4 = vec4 (vec3 (0.8, 0.8, 0.6) * (0.2 + 0.8 * nDotR), -1.);\n      } else {\n        col4 = vec4 (0.6, 0.6, 0.7, 0.);\n        if (vn.y > 0.9) col4 *= 0.8 * (isOcc ? 0.6 + 0.4 * BaseShd (ro) : 1.);\n        else if (vn.y < -0.9) col4 *= 1.5;\n        vn = VaryNf (16. * ro, vn, 0.5);\n      }\n    } else if (idObj == 2) {\n      col4 = vec4 (HsvToRgb (vec3 (mod (17.11 * gId.x + 27.33 * gId.y, 1.), 0.8, 1.)), 0.3);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.7, 0.7, 0.4, 0.1) * (0.9 + 0.1 * sin (16. * pi * qHit.y));\n    } else if (idObj == 4) {\n      col4 = mix (vec4 (0.7, 0.7, 0.4, 0.1), vec4 (0.7, 0.3, 0.2, 0.2) * (0.8 +\n         0.2 * sin (32. * pi * qHit.z)), step (0.05, abs (mod (qHit.z + bRad, 2. * bRad) - bRad)));\n    } else if (idObj == 5) {\n      col4 = vec4 (0.7, 0.3, 0.2, 0.2) * (0.8 + 0.2 * sin (32. * pi * qHit.z));\n    }\n    if (col4.a >= 0.) {\n      col = 0.2 * col4.rgb;\n      for (int k = 0; k < 2; k ++) {\n        if (k == 0) {\n          ld = ltAx;\n          lw = 0.1 + 0.9 * smoothstep (0.95, 0.98, - dot (ltAx, rd)); \n        } else {\n          ld = vec3 (0., 1., 0.);\n          lw = 1.; \n        }\n        col += lw * (0.4 * col4.rgb * max (dot (vn, ld), 0.) +\n           0.5 * col4.a * pow (max (dot (ld, reflect (rd, vn)), 0.), 32.));\n      }\n    } else col = col4.rgb;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, tStep, t, fd;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  fd = floor (dateCur.w / 7200.);\n  tCur = mod (tCur, 36000.) + 30. * fd;\n  az = 0.;\n  el = -0.05 * pi;\n  tStep = 5.;\n  t = floor (tCur / tStep) + smoothstep (0.8, 1., mod (tCur / tStep, 1.));\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  zmFac = 4. + 5. * abs (az) / pi;\n  cellSz = vec2 (1./16., 8.);\n  cRad = 40.;\n  az += 2. * pi * cellSz.x * (t + 0.5) * sign (2. * mod (fd, 2.) - 1.);\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., - 0.7 * cRad);\n  ro.y += cellSz.y * (t + 0.2);\n  dstFar = 4. * cRad;\n  ltAx = vuMat * normalize (vec3 (0., 0., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec3 (0., cHashVA2.xy)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfcR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[886, 886, 904, 904, 1418], [1420, 1420, 1455, 1455, 2559], [2561, 2561, 2583, 2583, 3027], [3029, 3029, 3062, 3062, 3479], [3481, 3481, 3502, 3502, 3757], [3759, 3759, 3783, 3783, 4389], [4391, 4391, 4426, 4426, 6052], [6054, 6054, 6110, 6110, 7520], [7522, 7522, 7554, 7554, 7654], [7656, 7656, 7689, 7689, 7716], [7718, 7718, 7760, 7760, 7811], [7813, 7813, 7856, 7856, 7920], [7922, 7922, 7946, 7946, 8063], [8065, 8065, 8110, 8110, 8213], [8215, 8215, 8260, 8260, 8298], [8300, 8300, 8336, 8336, 8542], [8544, 8544, 8574, 8574, 8687], [8689, 8689, 8720, 8720, 8784], [8818, 8818, 8842, 8842, 8954], [8956, 8956, 8980, 8980, 9092], [9094, 9094, 9119, 9119, 9305], [9307, 9307, 9336, 9336, 9548], [9550, 9550, 9589, 9589, 9769]], "test": "error"}
{"id": "tlfcRS", "name": "universe is a machine", "author": "bipinoli", "description": "Learning from the amazing:\nhttps://www.shadertoy.com/user/BigWIngs\n\nFollowing his youtube tutorials: \"The art of code\" (https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg)", "tags": ["learningshaders"], "likes": 1, "viewed": 57, "published": "Public", "date": "1592319876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 polar = vec2(atan(uv.x,uv.y)/6.28,length(uv));\n    \n    float rotationSlowness = .008;\n    uv = vec2(polar.x-iTime*rotationSlowness, polar.y);\n    \n    //float c = fract(sin(uv.x*200. + uv.y*53.)*5279.);\n    //float c = fract(sin(uv.x*123.));\n    float c = fract(fract(sin(uv.y*123.)) + fract(cos(uv.x*123.)));    \n    \n    //c *= fract(sin(uv.y*10.));\n    //c *= fract(sin(uv.x*12.));\n    \n    float r = c;\n\tfloat g = smoothstep(.1, .3, c);\n    float b = smoothstep(.2, .4, c);\n    \n    vec3 col = vec3(r, g, b);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 711]], "test": "ok"}
{"id": "tlfczl", "name": "Fractal flowers", "author": "jarble", "description": "This recursive signed distance function makes a very \"flowery\" fractal shape.", "tags": ["3d", "raymarching", "fractal"], "likes": 0, "viewed": 181, "published": "Public API", "date": "1592768863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/50.0));\n    float color2 = length(cos(p/50.0));\n    return vec3(color1,color2/1.5,color1);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    return length(sin(p/size)*size) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 100.0; i *= 10.0){\n        p /= (vec3(2.0)+sin(p/(400.0)));\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = scale*(10.0+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 350, 378, 378, 524], [768, 768, 797, 797, 843], [845, 845, 869, 869, 1157], [1159, 1580, 1671, 1671, 1983], [1998, 2252, 2317, 2317, 2449], [2451, 2540, 2569, 2569, 2879], [2881, 3373, 3513, 3513, 4123], [4125, 4495, 4580, 4580, 5352], [5354, 5681, 5730, 5765, 5896], [5898, 5898, 5955, 5955, 7120]], "test": "timeout"}
{"id": "tlfczS", "name": "Simplex Noise Worms and Cells", "author": "izutionix", "description": "messing with  [url=https://www.shadertoy.com/view/Msf3WH]iq's simplex noise shader[/url]\nmouse y controls thickness (kind of)\npress spacebar to toggle cell treshold", "tags": ["2d", "voronoi", "noise", "worley", "simplex", "caustics", "cells", "worms", "brain", "trabeculum", "trabeculum", "trabeculum", "scratches", "intestines"], "likes": 14, "viewed": 269, "published": "Public", "date": "1592349529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ss(t, b, g) smoothstep(t-b, t+b, g)\n#define screen(a, b) a+b-a*b\n\nvec2 hash( vec2 p ) // modified from iq's too\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\tp = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return p;\n    //return normalize(p); // more uniform (thanks Fabrice)\n}\n\n// slightly modified version of iq's simplex noise shader: https://www.shadertoy.com/view/Msf3WH\nvec3 snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return 1e2*n; //return full vector\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n\tfloat b = iResolution.y;\n    float t =.25;\n    if(iMouse.xy!=vec2(0))\n    t = iMouse.y/b;\n    b = 4./b;\n    \n    vec3 n = snoise( 6.*(p-iTime/10.+5.) );\n\tvec3 an = abs(n);\n    vec4 s = vec4(\n        dot( n, vec3(1.) ),\n\t\tdot( an,vec3(1.) ),\n        length(n),\n        max(max(an.x, an.y), an.z ) );\n    \n\tfloat x;\n    \n    if(p.x<-.333)\n\t// worms\n\t\tx = 1.25*( s.y*t-abs(s.x) )/t;\n    else if(p.x<.333) {\t\n\t// cells\n    \tx = (1.-t)+(s.y-s.w/t)*t;\n        x *= 1.+t;\n        if(texelFetch( iChannel0, ivec2(32,2),0 ).x>.5) // spacebar pressed\n            x = ss(.6, b, x); // treshold\n        x *= x; // looks nicer\n    }\n\telse\n\t// intestines or brain\n\t\tx = .75*s.y;\n    \n    float border = ss( .002, b/4., abs(abs(p.x)-.333) );\n    x = screen( x*border, (1.-border) );\n\n\tfragColor = vec4(x);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfczS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 121, 121, 307], [309, 406, 432, 432, 917], [919, 919, 976, 976, 1833]], "test": "error"}
{"id": "tlfyDf", "name": "Visual Enhancer", "author": "scry", "description": "yesss\nuncomment line 45 for extra fun (but don't do it if photosensitive)", "tags": ["2d"], "likes": 1, "viewed": 84, "published": "Public", "date": "1593266237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float c = length(uv-0.5);\n    float tt = iTime;\n    float n1 = mod(noise(uv*950.)*100.,1.)*100.;\n    float n2 = noise(uv+n1+tt*0.1);\n    vec3 col = vec3(1.-(n2*1.));\n    col *= 0.99;\n    col += 0.0;\n    vec3 c2 = 1.-col;\n    float fn = noise(uv);\n    float f =(sin((tt*3.14)*9.+sin(tt*.4)*44.)+1.)*0.1;\n    float s =(sin(tt*0.04)+1.);\n    f = f+0.95;\n    s += 1.;\n    col = fract(col*1.02);\n    col *= f*0.18; //fast flicker for dreamachine effect\n    //https://en.wikipedia.org/wiki/Dreamachine\n    col *= s*0.5;\n    col *= 0.95 +sin(c*10.+tt)*0.08;\n    col += (sin(uv.y*6.+tt*0.033)*0.5+0.5)*.04;\n    \n    //col = mix(col,c2,f);\n    //col = mod(col,1.);\n    //gl_FragColor = vec4(col,1.);\n    // Normalized pixel coordinates (from 0 to 1)\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfyDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 144], [146, 146, 172, 172, 689], [691, 691, 748, 748, 1687]], "test": "timeout"}
{"id": "tlfyWM", "name": "1st polar coord", "author": "bipinoli", "description": "Learning shaders following tutorial from \"The Art of Code\" on youtube", "tags": ["learningshaders"], "likes": 1, "viewed": 53, "published": "Public", "date": "1592274702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 polar = vec2(atan(uv.x,uv.y)/6.28,length(uv));\n    \n    // change angle depending on the radius to produce wrapping result\n    polar.x += polar.y;\n\n    float rotationSlowness = .2;\n    \n    uv = vec2(polar.x-iTime*rotationSlowness, polar.y);\n    //uv = vec2(polar.x, polar.y);\n    \n    float dials = 10.;\n    \n   \tfloat x = uv.x*dials;\n    float m = min(fract(x), 1.-fract(x));\n    float c = smoothstep(1., 0., m);\n    \n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfyWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 610]], "test": "ok"}
{"id": "tlfyzn", "name": "HappyAccidents", "author": "photonic", "description": "I'm just playing around with the code to get some happy accidents <3 ", "tags": ["animation", "beartbeat"], "likes": 0, "viewed": 66, "published": "Public", "date": "1591243466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CONTROLS HOW SOFT IS THE EDGE OF THE OBJECT\n#define BLUR 0.01\n\n//CONTROLS THE FREQUENCY OF THE BEAT\n#define BEAT_FREQ 5.0\n\n//THIS CONTROLS DE SIZE OF THE OBJECT\n#define WIDTH .09\n#define HEIGHT 0.01\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    uv.y = uv.y + sin((iDate.w + uv.x)*10.) * .08;\n\n    uv.y /= random(uv);\n    \n    uv *= (-abs(cos(iTime * BEAT_FREQ) / 10.0)) - 1.0;\n    \n\tcol += smoothstep(1.0, 1.0 - BLUR, abs(uv.x) + (1.0 - WIDTH)) * smoothstep(1.0, 1.0 - BLUR, abs(uv.y) + (1.0 - HEIGHT));\n    \n    col.b -= 1.0;\n    col.g -= 1.0;\n  \n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfyzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 226, 226, 333], [335, 335, 392, 442, 879]], "test": "timeout"}
{"id": "tllcRj", "name": "RayMarching Sphere w/ fbm", "author": "wnu", "description": "raymarching a sphere, but continue until you reach a certain value of fractional brownian motion. Drilling into the Sphere", "tags": ["raymarching", "fbm"], "likes": 2, "viewed": 190, "published": "Public", "date": "1592523009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat random3 (in vec3 _st) {\n    return fract(sin(dot(_st,\n                         vec3(12.9898,78.233,123.24647)))*\n      43758.5453123);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat noise3 (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 fr = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random3(i);\n    float b = random3(i + vec3(1.0, 0.0, 0.0));\n    float c = random3(i + vec3(0.0, 1.0, 0.0));\n    float d = random3(i + vec3(1.0, 1.0, 0.0));\n    \n    float e = random3(i + vec3(0.0, 0.0, 1.0));\n    float f = random3(i + vec3(1.0, 0.0, 1.0));\n    float g = random3(i + vec3(0.0, 1.0, 1.0));\n    float h = random3(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = fr * fr * (3.0 - 2.0 * fr);\n    \n    float bf = mix(a,b,u.x);\n    float bb = mix(c,d,u.x);\n    \n    float bot = mix(bf,bb,u.y);\n    \n    float tf = mix(e,f,u.x);\n    float tb = mix(g,h,u.x);\n    \n    float top = mix(tf,tb,u.y); \n\n    return mix(bot,top,u.z);\n}\n\n#define NUM_OCTAVES 2\n\nfloat fbm3 ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    float offset = 0.;\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        //v += a * sin((_st.y + _st.x+ _st.y)*10.)*1.5;\n        offset += a*2.5;\n        v += a * noise3(_st)*2.5;\n        _st = _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v/offset;\n}\n\nfloat fbmN(vec3 _st, int n){\n\tfloat v = 0.;\n    for (int i = 0;i<4;i++){\n        if(i>=n) break;\n        v= fbm3(_st + v*4.);\n    }\n    \n    return v;\n}\n\nfloat map(vec3 pos){\n return length(pos) - 0.25;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 rot = rotationMatrix(vec3(1.,1.,1.),-iTime/2.);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 pos = (rot*vec4(vec3(0.0,0.0,1.0),1.)).xyz;\n    \n    vec3 pd = (rot*vec4(normalize(vec3(uv,-1.5)),1.)).xyz;\n    \n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float l = 0.;\n    float fbm =0.;\n    for(int i = 0; i<255; i++){\n    \tvec3 p = pos + t*pd;       \n        l = map(p);\n        float fbmTest = fbmN(p*10.,1);\n        //float fbmTest = noise3(p*10.);\n        //float fbmTest = random3(p*10.);\n            \n        if((l<0.0002)){\n            if(fbmTest >0.55){\n         \t\tbreak;\n            }else{\n             t+=0.002;   \n            }\n        }else{\n        t += l;\n        }\n        \n    }\n    \n    float plen = 0.;\n    \n    if (l< 0.0002){\n    vec3 p = pos + t*pd;    \n    fbm = fbmN(p*10.,1);\n    //fbm = noise3(p*10.);\n    //fbm = random3(p*10.);\n    plen = length(p)/0.25;\n    fbm *= fbm * (3.0 - 2.0 * fbm)*plen;\n    }\n    float inCircle = smoothstep(0.02,-0.,l);\n    col = hsl2rgb(vec3(fbm*0.05+0.5,0.7,plen))*inCircle;\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllcRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 673], [675, 675, 704, 704, 817], [819, 819, 846, 846, 989], [991, 991, 1019, 1019, 1749], [1774, 1774, 1801, 1801, 2130], [2132, 2132, 2160, 2160, 2284], [2286, 2286, 2306, 2306, 2339], [2341, 2341, 2398, 2398, 3496]], "test": "timeout"}
{"id": "tllcRr", "name": "Checker Warping", "author": "percentcer", "description": "Messing with fragcoords", "tags": ["checkers"], "likes": 3, "viewed": 237, "published": "Public API", "date": "1591311847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.x;\n    \n    vec3 col;\n    for (int i = 0; i < 3; i++) {\n        float time = iTime - .2 * float(i);\n        vec2 uv_ = uv - vec2(sin(time),cos(time))*.2;\n\n        vec2 px = fragCoord - (iResolution.xy/2.);\n        vec3 col_ = 0.5 + 0.5 * cos(/*time + */length(uv_) * 2. + uv_.xyx + vec3(0,2,4) );\n\n        px *= length(uv_);\n        float squareSize = iResolution.y * .1;\n        if (mod(floor(px / squareSize), vec2(2.)) == vec2(0.)\n           || mod(floor(px / squareSize), vec2(2.)) == vec2(1.)) {\n            col_ = 1.-col_;\n        }\n        col[i] = col_[i];\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllcRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 727]], "test": "timeout"}
{"id": "tllcz7", "name": "stuffstuff", "author": "space_sheep", "description": "stuffstuff", "tags": ["stuffstuff"], "likes": 2, "viewed": 53, "published": "Public", "date": "1592427734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.141592654;\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 p = vec2(fragCoord.x, fragCoord.y);\n    vec2 res = vec2(iResolution.x, iResolution.y);\n    vec2 c = vec2(res.x / 2.0, res.y / 2.0);\n    float t = 50.0*cos(iTime/2.0);\n    \n    float dist = sqrt(pow((c.x-p.x),2.0) + pow((c.y-p.y),2.0));\n    \n    vec2 a = vec2(p.x-c.x, c.y-p.y);\n    vec2 b = vec2(1, 0);\n\n    float deg = acos(dot(a,b) / (length(a) * length(b)) );\n    \n    if(a.y>0.0)\n    {\n        deg = 2.0 * pi - deg;\n    }\n    \n    float q = mod(floor(dist/50.0),2.0);\n    \n    if(mod(floor(deg/(2.0*pi)*t),2.0)==q)\n    {\n        fragColor = vec4(0.5,0,0,1);\n    }\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllcz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 707]], "test": "ok"}
{"id": "tllczs", "name": "[TWITCH] Rainbow Maze", "author": "Flopine", "description": "Improved version of a shader started during a twitch stream. You can re-watch all of the previous episode of HBHS (Have a Beer Have a Shader) here: https://www.twitch.tv/flopine", "tags": ["raymarching", "animation", "isometric", "orthographic", "twitch"], "likes": 9, "viewed": 134, "published": "Public", "date": "1592860704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853071\n#define ITER 64.\n\n#define time(speed) fract(iTime*speed)\n#define bouncy(speed) sqrt(abs(sin(time(speed)*PI)))\n#define switchanim(speed) floor(sin(time(speed)*TAU)+1.)\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.5,32.4)))*1245.2);}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = mod(atan(p.y,p.x)-per*.5,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat lustre, g1 = 0.;\nfloat room (vec3 p)\n{\n    vec3 pp = p;\n    float size = 2.;\n    float r = abs(box(p, vec3(1.5,2.,1.5)))-0.08;\n    mo(p.xz, vec2(1.3));\n    r = min(r, max(length(p.xz)-0.2,abs(p.y)-3.));\n\n    p = pp;\n    float d = max(p.y-.5,r);\n    moda(p.xz, 4.);\n    p.x -= 1.5;\n    d = max(d,-box(p+vec3(0.,1.3,0.),vec3(0.1,0.7,.5)));\n\n    p = pp;\n    p.z = abs(p.z)-1.3;\n    lustre = dot(p,normalize(sign(p)))-0.2;\n    g1 += .01/(.01+lustre*lustre);\n    d = min(d, lustre);\n    return d;\n}\n\nfloat ball (vec3 p, float speed)\n{\n    p.y -= -2.+bouncy(speed*10.)*1.5; \n    return length(p)-0.3;\n}\n\nfloat ba; vec2 rid;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1.));\n    p.xz *= rot(PI/4.);\n    vec3 pp = p;\n\n    vec2 ballper = vec2(9.);\n    vec2 ballid = floor((p.xz-ballper*.5)/ballper);\n    float sp = length(ballid)*.2;\n\n    p.xz = mod(p.xz-ballper*.5,ballper)-ballper*.5;\n    float switchanim = sign(sin(time(sp*.5)*TAU));\n    vec2 ballanim = vec2(max(cos(time(sp)*TAU+PI/2.),0.)*3.,\n                         max(sin(time(sp)*TAU),0.)*3.\n                        );\n    p.xz += ballanim * switchanim;\n    ba = ball(p,sp);\n\n    p = pp;\n    vec2 per = vec2(3.);\n    rid = floor((p.xz-per*.5)/per);\n    p.xz = mod(p.xz-per*.5,per)-per*.5;\n\n    return min(ba,room(p));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvec3 pal (float t, vec3 c)\n{return vec3(0.5)+vec3(.5)*cos(TAU*(c*t+vec3(0.,0.36,0.64)));}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    float zoom = (switchanim(0.1) <= 0.) ? 30. : 15.;\n\n    vec3 ro = vec3(uv*zoom,-20.),\n        rd = vec3(0.,-0.05,1.),\n        p = ro,\n        l = normalize(vec3(0.9,1.2,-3.)),\n        col = vec3(0.);\n\n    float d = 0.; bool hit = false;\n\n    for (float i=0.; i<ITER;i++)\n    {\n        d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            break;\n        }\n        d *= 0.95+dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        if (d == ba) col = vec3(0.);\n        else if (d == lustre) col = vec3(0.);\n        else col = vec3(1.);\n            \n        vec3 n = getnorm(p);\n        float lighting = max(dot(n,l),0.);\n        col *= lighting*pal(length(rid),vec3(0.1))*0.3;\n    }\n\n    col += g1*pal(length(rid),vec3(0.1))*0.3;\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllczs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 532, 552, 552, 595], [597, 597, 620, 620, 670], [672, 672, 704, 704, 751], [753, 753, 789, 789, 908], [910, 910, 937, 937, 1022], [1047, 1047, 1068, 1068, 1523], [1525, 1525, 1559, 1559, 1626], [1648, 1648, 1668, 1668, 2300], [2302, 2302, 2325, 2325, 2438], [2440, 2440, 2468, 2468, 2529], [2531, 2531, 2587, 2587, 3566]], "test": "timeout"}
{"id": "tllyDj", "name": "Chocolate package", "author": "gaz", "description": "inspired https://www.shadertoy.com/view/llGXDR", "tags": ["fractal", "mandelbox"], "likes": 17, "viewed": 253, "published": "Public", "date": "1593148811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\n//Fractal Parameters\n#define SCALE -2.8\n#define MR2 0.3\n#define S_VEC  vec4(SCALE,SCALE,SCALE,abs(SCALE))/MR2\n\nfloat map(vec3 p){\n    p.xy *= rot(iTime*0.2);\n    p.yz *= rot(iTime*0.1);\n    vec4 q = vec4(p,1), q0 = q; \n    for (int i=0; i<10; i++) {\n        q.xyz = clamp(q.xyz, -1.0, 1.0) * 2.0 - q.xyz;\n        float r2 = pow(lpNorm(q.xyz,16.0),2.0);\n        q *= S_VEC*clamp(max(MR2/r2, MR2), 0.0, 0.9);\n        q += q0*0.5;\n    }\n    return 0.8*length(q.xyz)/q.w - 0.005;\n}\n\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<50;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,4.5);\n    vec3 rd = normalize(vec3(uv,-2.0));\n    vec3 col = vec3(0);\n\tconst float maxd = 10.0;\n    float t = march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=vec3(0.9,0.3,0.2)+cos(p*0.5)*0.5+0.5;\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(3);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.8;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.1,0.4,0.9)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 20.0);\n    }\n    fragColor.xyz = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 144], [257, 257, 275, 275, 623], [626, 626, 652, 652, 804], [806, 806, 860, 860, 1026], [1028, 1028, 1080, 1080, 1163], [1166, 1166, 1223, 1223, 2163]], "test": "timeout"}
{"id": "tllyRH", "name": "whatever1456", "author": "rubix", "description": "remix of https://www.shadertoy.com/view/wtlyR8\nwhere is the \"remix\" button", "tags": ["xor"], "likes": 5, "viewed": 75, "published": "Public", "date": "1591472392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Circuit Diagram2\" by ntsutae\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\n// ported to shadertoy by chordbug : https://www.shadertoy.com/view/wtlyR8\n// modified by rubix a little to make a joke\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(fragCoord.x);\n  int y = int(fragCoord.y + 30.0 * iTime);\n  int r = (x+y)^(x-y);\n  bool b = abs(r*r*r) % 997 >= 297;\n  fragColor = vec4(vec3(b ? 1.0 : 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 259, 314, 314, 492]], "test": "ok"}
{"id": "tllyWf", "name": "Once upon time... space", "author": "mrange", "description": "License CC0: Once upon time... in space\nWhen I grew up I loved the french kid show \"Once upon time... space\". The show had a big influence on me and 30+ years I wanted to make a homage to it. Song: https://www.youtube.com/watch?v=9IsGy0LvV9M\n\n", "tags": ["raymarching", "scifi"], "likes": 22, "viewed": 313, "published": "Public API", "date": "1593333776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Once upon time... space\n//  When I grew up I loved the french kid show \"Once upon time... space\". \n//  The show had a big influence on me and 30+ years I wanted to make a homage to it. \n//  Song: https://www.youtube.com/watch?v=9IsGy0LvV9M\n\n//  Shader takes a long time to load, sorry!\n//  Code \"borrowed\" from the usual suspects\n\n// ------------------------------==> COMMON <==--------------------------------\n\nstruct Effect {\n  int      major  ;\n  int      minor  ;\n  float    seq    ;\n  bool     fade   ;\n  float    input0 ;\n  float    input1 ;\n};\n\n#define PI         3.141592654\n#define TAU        (2.0*PI)\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\n#define DURATION1  6.85\n#define DURATION   5.13\n#define DURATIONT  172.0\n\n#define FADEIN     1.0\n#define FADEOUT    2.0\n\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n\n#define SABS(x,k)   LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define SCA(a)      vec2(sin(a), cos(a))\n\n// Uncomment to speed up experimentation\n//#define EXPERIMENTING\n\n#define MINOR_NONE          0\n\n#define MAJOR_NOEFFECT      0\n\n#define MAJOR_IMPULSE       1\n#define MINOR_INTRO         0\n#define MINOR_OUTRO         1\n\n#define MAJOR_ORRERY        2\n#define MINOR_SUNRISE       0\n#define MINOR_CLOSEUP       1\n#define MINOR_APPROACH      2\n#define MINOR_ESCAPE        3\n\n#define MAJOR_WATERWORLD    3\n\n#define MAJOR_BARRENMOON    4\n\n#define MAJOR_GALAXY        5\n\n#define MAJOR_SPACESHIP     6\n#define MINOR_FROM_BEHIND   0\n#define MINOR_CYLINDER_SEA  1\n#define MINOR_FROM_FRONT    2\n\n//#define EXPERIMENTING\n\n#ifdef EXPERIMENTING\n#define ENABLE_IMPULSE\n\nconst Effect effects[] = Effect[](\n    Effect(MAJOR_IMPULSE     , MINOR_INTRO          , 0.0, false , 0.0       , 0.0) // This is special in that it's 7 seconds long, all other about ~5.1 long\n  );\n\n#else\n#define ENABLE_NOEFFECT\n#define ENABLE_IMPULSE\n#define ENABLE_ORRERY\n#define ENABLE_BARRENMOON\n#define ENABLE_WATERWORLD\n#define ENABLE_GALAXY\n#define ENABLE_SPACESHIP\n\nconst Effect effects[] = Effect[](\n    Effect(MAJOR_IMPULSE     , MINOR_NONE           , 0.0, false , 0.0       , 0.0) // This is special in that it's 7 seconds long, all other about ~5.1 long\n  , Effect(MAJOR_ORRERY      , MINOR_SUNRISE        , 0.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_SUNRISE        , 1.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_CLOSEUP        , 0.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_CLOSEUP        , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 0.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 1.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_BEHIND    , 2.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 0.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 1.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_CYLINDER_SEA   , 2.0, true  , 0.0       , 200000.0)\n  , Effect(MAJOR_ORRERY      , MINOR_APPROACH       , 0.0, true  , -1.1      , 1.0)\n  , Effect(MAJOR_ORRERY      , MINOR_APPROACH       , 1.0, true  , -1.1      , 1.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 0.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 1.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 2.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_BARRENMOON  , MINOR_NONE           , 3.0, true  , 7.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 0.0, true  , 0.0       , 0.0) // 20\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 2.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_WATERWORLD  , MINOR_NONE           , 3.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 0.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 1.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_ORRERY      , MINOR_ESCAPE         , 2.0, true  , PI/6.0    , 0.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 0.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 1.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_SPACESHIP   , MINOR_FROM_FRONT     , 2.0, true  , PI+0.5    , 550000.0)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 0.0, true  , 0.4       , 0.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 1.0, true  , 0.4       , 0.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 0.0, true  , 2.0       , 2.5)\n  , Effect(MAJOR_GALAXY      , MINOR_NONE           , 1.0, true  , 2.0       , 2.5)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 0.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 1.0, true  , 0.0       , 0.0)\n  , Effect(MAJOR_IMPULSE     , MINOR_OUTRO          , 2.0, true  , 0.0       , 0.0)\n  );\n#endif\n\n// From planet surface\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = skyCol1*skyCol1*skyCol1*3.0;\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.9,0.8);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.8);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  ringColor     = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  planetCol     = sqrt(vec3(0.9, 0.8, 0.7));\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\nconst vec3  mountainColor = sqrt(vec3(0.95, 0.65, 0.45));\n\n// From space\nconst vec3  sunDirection         = normalize(vec3(0.0, 0.5, -10.0));\nconst vec3  sunColor1            = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2            = vec3(1.0, 0.8, 0.9);\nconst vec3  smallSunDirection    = normalize(vec3(-2.0, -3.5, -10.0));\nconst vec3  smallSunColor1       = vec3(1.0, 0.6, 0.6);\nconst vec3  smallSunColor2       = vec3(1.0, 0.3, 0.6);\n\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat parabola(vec2 pos, float k) {\n  pos.x = abs(pos.x);\n\n  float p = (1.0-2.0*k*pos.y)/(6.0*k*k);\n  float q = -abs(pos.x)/(4.0*k*k);\n\n  float h = q*q + p*p*p;\n  float r = sqrt(abs(h));\n\n  float x = (h>0.0) ? pow(-q+r,1.0/3.0) - pow(abs(-q-r),1.0/3.0)*sign(q+r) : 2.0*cos(atan(r,-q)/3.0)*sqrt(-p);\n\n  return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l);\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n// Not an exact distance field\nfloat softBox(vec3 p, float r) {\n  p *= p;\n  p *= p;\n  p *= p;\n  return pow(p.x + p.y + p.z, 1.0/8.0) - r;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat capsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n  return length(p.xy-c.xy)-c.z;\n}\n\n\nfloat l2(vec2 p) {\n  return dot(p, p);\n}\n\nfloat l2(vec3 p) {\n  return dot(p, p);\n}\nfloat spow(float v, float p) {\n  return sign(v)*pow(abs(v), p);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat smoother(float f, float r) {\n  return tanh(f/r)*r;\n}\n\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 cylinderCoord(vec3 p) {\n  return vec2(p.z, atan(p.x, -p.y));\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat roundIntersection(float a, float b, float r) {\n  vec2 u = max(vec2(r + a,r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\nfloat chamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat roundDiff (float a, float b, float r) {  return roundIntersection(a, -b, r);\n}\nfloat pcos(float f) {\n  return 0.5 + 0.5*cos(f);\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec4 cyl) {\n  vec3  oc = ro - cb;\n  float card = dot(cyl.xyz ,rd);\n  float caoc = dot(cyl.xyz, oc);\n  float a = 1.0 - card*card;\n  float b = dot(oc, rd) - caoc*card;\n  float c = dot(oc, oc) - caoc*caoc - cyl.w*cyl.w;\n  float h = b*b - a*c;\n  if (h<0.0) return vec2(-1.0); //no intersection\n  h = sqrt(h);\n  return vec2(-b-h,-b+h)/a;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n\n  if (h<0.0) return vec2(-1.0);\n  h = sqrt(h);\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  return mix(vec2(-1.0), vec2(t1, t2),step(0.0, t2));\n}\n\n\nvec3 raySphereDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n  float ndbuffer = dbuffer/sph.w;\n  vec3  rc = (ro - sph.xyz)/sph.w;\n\n  float b = dot(rd,rc);\n  float c = dot(rc,rc) - 1.0;\n  float h = b*b - c;\n  if (h<0.0) return vec3(-1.0, -1.0, 0.0);\n  h = sqrt(h);\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  if (t2<0.0 || t1>ndbuffer) return vec3(-1.0, -1.0, 0.0);\n  t1 = max(t1, 0.0);\n  t2 = min(t2, ndbuffer);\n\n  float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n  float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n  return vec3(sph.w*t1, sph.w*t2, (i2-i1)*(3.0/4.0));\n}\n\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n\n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif\n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n\n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n\n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nvec4 voronoi(vec2 x) {\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash2(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nconst vec2 sca0 = SCA(0.0);\n\nfloat letteri(vec2 p) {\n  p.y -= 0.25;\n  return box(p, vec2(0.125, 0.75));\n}\n\nfloat letterm(vec2 p) {\n  p.y = -p.y;\n  float l = horseshoe(p - vec2(+0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  float r = horseshoe(p - vec2(-0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  return min(l, r);\n}\n\nfloat letterp(vec2 p) {\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = max(circle(p, 0.5), -circle(p, 0.3));\n  return min(b, c);\n}\n\nfloat letteru(vec2 p) {\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.375, 0.1));\n}\n\nfloat letterl(vec2 p) {\n  return box(p, vec2(0.125, 0.5));\n}\n\nfloat letters(vec2 p) {\n  rot(p, -PI/6.0);\n  rot(p, -PI/2.0);\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1)) - 0.0;\n  rot(p, PI);\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat lettere(vec2 p) {\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat impulse(vec2 p) {\n  p.x += 0.6;\n  const float oi = -3.00;\n  const float om = -1.65;\n  const float op = +0.10;\n  const float ou = +1.25;\n  const float ol = +2.10;\n  const float os = +2.80;\n  const float oe = +3.85;\n  float di = letteri(p - vec2(oi, 0.0));\n  float dm = letterm(p - vec2(om, 0.0));\n  float dp = letterp(p - vec2(op, 0.0));\n  float du = letteru(p - vec2(ou, 0.0));\n  float dl = letterl(p - vec2(ol, 0.0));\n  float ds = letters(p - vec2(os, 0.0));\n  float de = lettere(p - vec2(oe, 0.0));\n  float oo = 0.1;\n  float dx = abs(p.y) - oo;\n  dx = abs(dx) - oo*0.5;\n  float d = 1000000.0;\n  d = min(d, di);\n  d = min(d, dm);\n  d = min(d, dp);\n  d = min(d, du);\n  d = min(d, dl);\n  d = min(d, ds);\n  d = min(d, de);\n  d = max(d, -dx);\n\n  return d;\n}\n\nfloat star(vec2 p, float r, float rf) {\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 gasGiant(vec3 ro, vec3 rd, vec3 sunDir) {\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n\n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n\n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n\n  vec3 final = vec3(0.0);\n\n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n\n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  return final;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n//  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n// ------------------------------==> COMMON <==--------------------------------\n\n// -----------------------------==> NOEFFECT <==-------------------------------\n\n#ifdef ENABLE_NOEFFECT\n\nvec3 noeffect_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  return vec3(0.0, 0.5, 0.0);\n}\n\n#endif\n\n// -----------------------------==> NOEFFECT <==-------------------------------\n\n// -----------------------------==> IMPULSE <==--------------------------------\n\n#ifdef ENABLE_IMPULSE\n\nfloat impulse_planet(vec2 p) {\n  p.y = abs(p.y);\n  float dc1 = circle(p, 2.0);\n  float dc2 = circle(p+vec2(0.0, 0.035), 2.0);\n  float dc = max(dc1, -dc2)+0.0025;\n  return dc;\n}\n\nfloat impulse_moon(vec2 p) {\n  float dc5 = circle(p-vec2(-3.6, 1.45), 0.25);\n  float dc6 = circle(p-vec2(-3.6, 1.45)+0.025*vec2(-1.0, 1.0), 0.25);\n  float dc0 = max(dc5, -dc6);\n  return dc0;\n}\n\n\nfloat impulse_stars(vec2 p, float ltime) {\n  const float count = 27.0;\n  const float radius = 5.0;\n  vec2 pp = toPolar(p);\n  pp.y += ltime*TAU/(count*2.0);\n  float n = mod1(pp.y, TAU/count);\n  p = toRect(pp);\n  p -= vec2(radius, 0.0);\n  float ds = (star(p, 0.35, 0.35));\n  return ds;\n}\n\nfloat impulse_df(vec2 p, float s, float ltime, bool stars) {\n  p /= s;\n\n  float di = impulse(p);\n  di = min(abs(di-0.0275) - 0.0155*pow(s, -0.25), di);\n  float dp = impulse_planet(p);\n  float dm = impulse_moon(p);\n  float ds = impulse_stars(p, ltime);\n  float d = di;\n  d = min(d, dp);\n  d = min(d, dm);\n  if (stars) d = min(d, ds);\n  return d*s;\n}\n\nfloat impulse_fbm(vec2 p) {\n  vec2 op = p;\n  const float aa   = 0.3;\n  const float ff   = 2.03;\n  const float tt   = PI/2.5;\n  const float oo   = 1.93;\n\n  float a = 1.0;\n  float o = 0.4;\n  float s = 0.0;\n  float d = 0.0;\n\n  p*=0.55;\n  for (int i; i < 3;++i) {\n    float nn = a*vnoise(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  return 0.65*(s/d);\n}\n\nfloat impulse_warp(vec2 p, float ltime, out vec2 v, out vec2 w) {\n  rot(p, -1.0);\n  p.x += 0.75;\n\n  vec2 o1 = vec2(1.0)*0.125;\n  vec2 o2 = vec2(-1.0)*0.125;\n  vec2 o3 = vec2(1.0)*0.125;\n  vec2 o4 = vec2(-1.0)*0.125;\n  rot(o1, ltime*sqrt(0.5));\n  rot(o2, ltime*sqrt(0.45));\n  rot(o3, -ltime*sqrt(0.35));\n  rot(o4, -ltime);\n  vec2 vv = vec2(impulse_fbm(p + o1), impulse_fbm(p + o2));\n  vv *= -5.0;\n  vec2 ww = vec2(impulse_fbm(p + vv + o2), impulse_fbm(p + vv + o3));\n  ww *= -5.0;\n  v = vv;\n  w = ww;\n  return impulse_fbm(p + ww + o4);\n}\n\nfloat impulse_height(vec2 p, float ltime) {\n  vec2 v;\n  vec2 w;\n  return impulse_warp(p, ltime, v, w);\n}\n\nvec3 impulse_normal(vec2 p, float ltime) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n\n  vec3 n;\n  n.x = impulse_height(p + e.xy, ltime) - impulse_height(p - e.xy, ltime);\n  n.y = 2.0*e.x;\n  n.z = impulse_height(p + e.yx, ltime) - impulse_height(p - e.yx, ltime);\n\n  return normalize(n);\n}\n\nvec3 impulse_intro(float ltime, vec2 p, vec2 q) {\n  // Hard coded to 7 fadein and fadeout\n  float pixel = 5.0/RESOLUTION.y;\n  float s = 30.0/(10.0 + ltime*(100.0/DURATION1));\n  float d = impulse_df(p, s, ltime, true);\n  vec2 op = p;\n  vec3 col = vec3(0.0);\n  p *= 0.5;\n  p -= 0.2;\n\n  vec2 v;\n  vec2 w;\n\n  float h = impulse_warp(p, ltime, v, w);\n  vec3 n = impulse_normal(p, ltime);\n  vec3 lp1 = vec3(-4.0, -2.0, 3.0);\n  vec3 ld1 = normalize(vec3(p.x, h, p.y) - lp1);\n  float dif1 = max(dot(n, ld1), 0.0);\n\n  float vv = 0.8;\n\n  vec3 col1 = hsv2rgb(vec3(0.95*v.yx, vv));\n  vec3 col2 = hsv2rgb(vec3(-0.65*w, vv));\n\n  col = (col1 + col2)*pow(dif1, 2.25);\n\n  col = mix(col, vec3(1.0), smoothstep(0.0, pixel, -d));\n\n  col = postProcess(col, q);\n\n  float fadeIn  = smoothstep(0.0, 2.0, ltime);\n  float fadeOut = smoothstep(DURATION1 - 4.0, DURATION1, ltime);\n\n  col = col + (1.0 - fadeIn);\n  col = mix(col, vec3(0.0), fadeOut*fadeOut);\n\n  return col;\n}\n\nvec3 impulse_outro(float ltime, vec2 p, vec2 q) {\n  float pixel = 5.0/RESOLUTION.y;\n  float s = 10.0/(10.0 + 0.5*ltime*(3.0/DURATION));\n  s *= 0.2;\n  float d = impulse_df(p, s, ltime, false);\n\n  vec3 col = vec3(0.0);\n  col = mix(col, vec3(1.0), smoothstep(0.0, pixel, -d));\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\nvec3 impulse_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 col = vec3(0.5);\n  switch(minor) {\n  case MINOR_INTRO:\n    col = impulse_intro(ltime, p, q);\n    break;\n  case MINOR_OUTRO:\n    col = impulse_outro(ltime, p, q);\n    break;\n  }\n  return col;\n}\n\n#endif\n\n// -----------------------------==> IMPULSE <==--------------------------------\n\n// ------------------------------==> ORRERY <==--------------------------------\n\n#ifdef ENABLE_ORRERY\n\nconst vec3  orrery_moonColor            = vec3(0.6, 0.5, 0.4);\nconst float orrery_farAway              = 1E6;\nconst vec4  orrery_vgasGiant            = vec4(0.0, 0.0, 0.0, 10);\nconst vec4  orrery_vmoon                = vec4(-19.0, 0.7, 0.0, 0.5);\n\nvec3 orrery_skyColor(vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2*1.0;\n\n  col += pow(smallDiff, 10000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 1000.0)*smallSunColor2*0.25;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.25;\n\n  return col;\n}\n\nvec4 orrery_moon(float input0) {\n  vec3 p = orrery_vmoon.xyz;\n  rot(p.xz, input0);\n  p.y *= pcos(input0);\n  return vec4(p, orrery_vmoon.w);\n}\n\nvec4 orrery_rings(float input0, vec3 ro, vec3 rd, inout float pd) {\n  float rsd = (0.0 - ro.y)/rd.y;\n  vec3 p = ro + rd*rsd;\n\n  vec3 pn = vec3(0.0, 1.0, 0.0);\n  vec3 pr = reflect(rd, pn);\n  vec3 pref = orrery_skyColor(pr);\n  float pfres = pow(1.0-abs(dot(rd, pn)), 10.0);\n  float pl = length(p);\n  float pdf = pl-22.0;\n  pdf = abs(pdf) - 3.2;\n  pdf = abs(pdf) - 2.1;\n  pdf = abs(pdf) - 1.0;\n  vec4 pcol = vec4(1.0);\n  pcol.xyz = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 1.0, 1.0), 0.5 - 0.5*cos(15.0*pl))*sunColor1;\n  pcol.xyz = pow(pcol.xyz, vec3(0.75));\n  pcol.w = psin(20.0*pl)*psin(14.0*pl)*psin(21.0*pl);\n  pcol.w *= 0.5*step(pdf, 0.0);\n  pcol.xyz += pfres*pref;\n\n  vec3 rsn = vec3(0.0, 1.0, 0.0);\n\n  pcol.w = pow(pcol.w, 1.0*pow(abs(dot(rd, rsn)), 0.4));\n\n  vec2 psi1 = raySphere(p, sunDirection, orrery_vgasGiant);\n  pcol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi1.y - psi1.x)/(2.0*orrery_vgasGiant.w)));\n\n  vec4 vm = orrery_moon(input0);\n  vec2 psi2 = raySphere(p, sunDirection, vm);\n  pcol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi2.y - psi2.x)/(2.0*vm.w)));\n\n  pd = mix(pd, rsd, pcol.w > 0.0);\n\n  return pcol;\n}\n\nvec4 orrery_gasGiant(float input0, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec3 srsd = raySphereDensity(ro, rd, orrery_vgasGiant, orrery_farAway);\n  vec2 si = srsd.xy;\n  float sdens = srsd.z;\n  vec3 sp = ro + rd*si.x;\n  vec3 smp = ro + rd*(si.x+si.y)*0.5;\n  float smd = length(smp)/orrery_vgasGiant.w;\n  vec3 sn = normalize(sp - orrery_vgasGiant.xyz);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = orrery_skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 15.0);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  float sf = (si.y - si.x)/(2.0*orrery_vgasGiant.w);\n  vec3 sbeer = exp(-90.0*sdens*vec3(0.30, 0.25, 0.22)*pow(smd, -3.0));\n  float srayl = pow(1.0 - abs(dot(rd, sn)), 5.0);\n\n  float slo = atan(sp.z, sp.x);\n  float slat = PI*sp.y/orrery_vgasGiant.w;\n  vec3 scol = vec3(0.8);\n\n  scol = mix(scol, vec3(0.7, 0.7, 0.8), pow(pcos(20.0*slat), 5.0));\n  scol = mix(scol, vec3(0.75, 0.7, 0.8), pow(pcos(14.0*slat), 20.0));\n  scol = mix(scol, vec3(0.2), pow(pcos(21.0*slat)*pcos(13.0*slat+1.0), 15.0));\n  scol = tanh(scol);\n  scol *= pow(sunColor1, vec3(0.66));\n  scol += vec3(0.0, 0.0, srayl*0.5) ;\n\n  vec4 vm = orrery_moon(input0);\n  vec2 mi = raySphere(sp, sunDirection, vm);\n\n  float msha = (1.0  - smoothstep(0.0, 1.0, (mi.y - mi.x)/(2.0*vm.w)));\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + pow(skyCol, vec3(0.85))*sbeer + scol*pow(sdiff, 0.75);\n    col.xyz *= msha;\n    col.w = 1.0;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec4 orrery_moon(float input0, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec4 vm = orrery_moon(input0);\n\n  vec2 si = raySphere(ro, rd, vm);\n  vec3 sp = ro + rd*si.x;\n  vec3 sn = normalize(sp - vm.xyz);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = orrery_skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 5.0);\n  float sf = (si.y - si.x)/(2.0*vm.w);\n\n  vec2 gi = raySphere(sp, sunDirection, orrery_vgasGiant);\n\n  float gsha = (1.0  - smoothstep(0.0, 1.0, (gi.y - gi.x)/(2.0*orrery_vgasGiant.w)));\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + orrery_moonColor*pow(sdiff, 0.75);\n    col.w = (1.0 - exp(-7.0*sf))*gsha;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec4 orrery_ship(float ltime, float input0, float input1, vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  const vec3 normal = normalize(-vec3(-1.0, -1.0, -1.0));\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n  const vec3 xx = cross(up, normal);\n  const vec3 yy = cross(xx, normal);\n  const float exc = 0.1;\n\n  vec4 vm = orrery_moon(input0);\n\n  vec4 p = vec4(normal, -dot(normal, vm.xyz));\n  float d = rayPlane(ro, rd, p);\n  vec3 pp = ro + rd*d - vm.xyz;\n\n  vec2 p2 = vec2(dot(xx, pp), dot(yy, pp));\n  p2.y *= -1.0;\n  p2 += vec2(0.0, 2.0*vm.w);\n\n  const float posY = 0.15;\n  const float posX = sqrt(posY/exc);\n\n  float dp = parabola(p2, exc);\n  dp = abs(dp)-0.001;\n\n  float trailt = smoothstep(0.0125+p2.y*p2.y*0.01, 0.0, dp);\n\n  float fadeOut = (smoothstep(10.0, posY, p2.y));\n\n  trailt *= fadeOut*(step(posY, p2.y))*step(p2.x, 0.0);\n  trailt *= 1.5-1.0*smoothstep(0.0, 0.75, p2.y);\n\n  vec4 trailCol = vec4(hsv2rgb(vec3(0.99, 0.0, 1.0)-vec3(0.5, -1.0, 0.5)*(1.0-fadeOut)), trailt);\n\n  float sc = circle(p2-vec2(-posX, posY), 0.0);\n\n  vec4 shipCol = vec4(2.0*vec3(1.5, 1.0, 2.0), 1.0)*smoothstep(-7.0, 1.0, sin(ltime*4.0*TAU))*smoothstep(0.125, 0.0, sc);\n\n  vec4 col = mix(trailCol, shipCol, shipCol.w)*input1;\n\n  pd = mix(pd, d, col.w > 0.0);\n\n\n  return col;\n}\n\nvec3 orrery_render(float ltime, float input0, float input1, vec3 ro, vec3 rd) {\n  vec3 skyCol = orrery_skyColor(rd);\n\n  vec4 col = vec4(skyCol, 1.0);\n  float cold = orrery_farAway;\n\n  vec4 ggcol = orrery_gasGiant(input0, ro, rd, skyCol, cold);\n\n  col.xyz = mix(col.xyz, ggcol.xyz, ggcol.w);\n\n  float md = orrery_farAway;\n  vec4 mcol = orrery_moon(input0, ro, rd, skyCol, md);\n\n  col.xyz = mix(col.xyz, mcol.xyz, mcol.w*step(md, cold));\n  cold = mix(cold, md, step(md, cold));\n\n  float rsd = orrery_farAway;\n  vec3 rsp;\n  vec4 rscol = orrery_rings(input0, ro, rd, rsd);\n\n  col.xyz = mix(col.xyz, rscol.xyz, rscol.w*step(rsd, cold));\n  cold = mix(cold, rsd, step(rsd, cold));\n\n  float sd = orrery_farAway;\n  vec4 scol = orrery_ship(ltime, input0, input1, ro, rd, skyCol, sd);\n\n  col.xyz = mix(col.xyz, scol.xyz, scol.w*step(sd, cold));\n  cold = mix(cold, sd, step(sd, cold));\n\n  return col.xyz;\n}\n\nvec3 orrery_fragment(float ltime, float input0, float input1, vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  vec3 col = orrery_render(ltime, input0, input1, ro, rd);\n  return col;\n}\n\nvec3 orrery_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro = vec3(0.0, 0.0, 52.0);\n  vec3 la = vec3(0.0, 0.0,0.0);\n  vec3 up = vec3(-0.0, 1.0, 0.0);\n\n  switch(minor) {\n  case MINOR_SUNRISE:\n    ro.y += ltime*4.0/(2.0*DURATION)+3.0;\n    la = vec3(0.0, 0.0, -orrery_farAway);\n    break;\n  case MINOR_CLOSEUP:\n    ro = vec3(0.0, 0.0, -25.0);\n    rot(ro.yz, 1.0-0.1*ltime/(2.0*DURATION));\n    la = vec3(0.0, 0.0, 0.0);\n    up = vec3(-0.25, 1.0, 0.0);\n    break;\n  case MINOR_APPROACH:\n    ro = (0.75-ltime/(3.0*DURATION)*0.15)*vec3(-25.0, -20.0, -40.0);\n    la = orrery_moon(input0).xyz;\n    break;\n  case MINOR_ESCAPE:\n    ro = vec3(0.0, 5.0, 30.0);\n    la = vec3(0.0, 0.0, -orrery_farAway);\n    ro.x += -6.0*ltime/(3.0*DURATION);\n    ro.y += 12.0*ltime/(3.0*DURATION);\n    ro.z += 60.0*ltime/(3.0*DURATION);\n    up = vec3(-1.0, 1.0, 0.0);\n    break;\n  default:\n    break;\n  }\n\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n  col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o1);\n\n  col = clamp(col, 0.0, 1.0);\n\n  // Adaptive AA? Is that a good idea?\n  vec3 dcolx = dFdx(col);\n  vec3 dcoly = dFdy(col);\n  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly)/(col+0.01);\n//  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly);\n\n  float de = max(dcol.x, max(dcol.y, dcol.z));\n\n  if (de > 0.1) {\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p-o1);\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o2);\n    col += orrery_fragment(ltime, input0, input1, ro, uu, vv, ww, p-o2);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ------------------------------==> ORRERY <==--------------------------------\n\n// ----------------------------==> WATERWORLD <==------------------------------\n\n#ifdef ENABLE_WATERWORLD\n\n#define WATERWORLD_TOLERANCE       0.00001\n#define WATERWORLD_MAX_ITER        55\n#define WATERWORLD_MAX_DISTANCE    31.0\n\nfloat waterworld_heightMod(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += -pp.x*0.2;\n  p = toRect(pp);\n  return pow((psin(1.0*p.x)*psin(1.0*p.y)), max(0.25, pp.x*0.20))*0.8;\n}\n\nfloat waterworld_height(vec2 p, float dd, int mx) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n\n  float hm = waterworld_heightMod(p);\n\n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n\n  int i = 0;\n\n  p *= 2.0;\n\n  for (; i < mx;++i) {\n    float nn = a*(vnoise(p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n\n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat waterworld_loheight(vec2 p, float d) {\n  return waterworld_height(p, d, 3);\n}\n\nfloat waterworld_height(vec2 p, float d) {\n  return waterworld_height(p, d, 5);\n}\n\nfloat waterworld_hiheight(vec2 p, float d) {\n  return waterworld_height(p, d, 6);\n}\n\nvec3 waterworld_normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = (waterworld_hiheight(p - eps.xy, d) - waterworld_hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (waterworld_hiheight(p - eps.yx, d) - waterworld_hiheight(p + eps.yx, d));\n\n  return normalize(n);\n}\n\nfloat waterworld_march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < WATERWORLD_MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = waterworld_height(p.xz, d);\n\n    if (d > WATERWORLD_MAX_DISTANCE) {\n      max_iter = i;\n      return WATERWORLD_MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < WATERWORLD_TOLERANCE) {\n      return d;\n    }\n\n    const float sl = 0.9;\n\n    dt = max(hd*sl, WATERWORLD_TOLERANCE+0.0005*d);\n    lastd = d;\n    d += dt;\n  }\n\n  max_iter = WATERWORLD_MAX_ITER;\n  return WATERWORLD_MAX_DISTANCE;\n}\n\nvec3 waterworld_sunDirection() {\n  return normalize(vec3(-0.5, 0.2, 1.0));\n}\n\nvec3 waterworld_smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 waterworld_skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = waterworld_sunDirection();\n  vec3 smallSunDir = waterworld_smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  float dustTransparency = smoothstep(-0.15, 0.075, rd.y);\n\n  vec3 skyCol = mix(skyCol1, skyCol2, sqrt(dustTransparency));\n  skyCol *= (1.0-dustTransparency);\n\n  vec3 planetCol = gasGiant(ro, rd, sunDir)*dustTransparency;\n\n  vec3 final = planetCol + skyCol + sunCol + smallSunCol;\n\n  return final;\n}\n\nvec3 waterworld_shipColor(vec2 p, float ltime) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*0.05;\n  p = toRect(pp);\n\n  float n = mod1(p.x, 0.15);\n  p.y += 3.0-ltime*0.5+0.05*abs(n*n);\n\n  float td = abs(p.x) - (0.005-p.y*0.002);\n  td = abs(td) - (0.02*pow(-p.y, 0.25));\n  float sd = circle(p, 0.05);\n\n  vec3 trailCol = vec3(0.5)*smoothstep(-5.0, 0.0, p.y)*step(p.y, 0.0)*smoothstep(0.0, 0.025, -td);\n  vec3 shipCol = vec3(0.5+smoothstep(-1.0, 1.0, sin(ltime*15.0*TAU+n)))*smoothstep(0.0, 0.075, -sd);\n\n  vec3 col = trailCol;\n  col += shipCol;\n\n  float sm = step(abs(n), 2.0);\n\n  return col*sm;\n}\n\nvec3 waterworld_getColor(vec3 ro, vec3 rd, float ltime) {\n  int max_iter = 0;\n  vec3 skyCol = waterworld_skyColor(ro, rd);\n  vec3 col = vec3(0);\n\n  const float shipHeight = 1.0;\n  const float seaHeight = 0.0;\n  const float cloudHeight = 0.2;\n  const float upperCloudHeight = 0.5;\n\n  float id = (cloudHeight - ro.y)/rd.y;\n\n  if (id > 0.0) {\n    float d = waterworld_march(ro, rd, id, max_iter);\n    vec3 sunDir = waterworld_sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, 1.0, -1.0);\n    vec3 p = ro + d*rd;\n\n    float loh = waterworld_loheight(p.xz, d);\n    float loh2 = waterworld_loheight(p.xz+sunDir.xz*0.05, d);\n    float hih = waterworld_hiheight(p.xz, d);\n    vec3 normal = waterworld_normal(p.xz, d);\n\n    float ud = (upperCloudHeight - 4.0*loh - ro.y)/rd.y;\n\n    float sd = (seaHeight - ro.y)/rd.y;\n    vec3 sp = ro + sd*rd;\n    float scd = (cloudHeight - sp.y)/sunDir.y;\n    vec3 scp = sp + sunDir*scd;\n\n    float sloh = waterworld_loheight(scp.xz, d);\n    float cshd = exp(-15.0*sloh);\n\n    float amb = 0.3;\n\n    vec3 seaNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 seaRef = reflect(rd, seaNormal);\n    vec3 seaCol = .25*waterworld_skyColor(p, seaRef);\n    seaCol += pow(max(dot(seaNormal, sunDir), 0.0), 2.0);\n    seaCol *= cshd;\n    seaCol += 0.075*pow(vec3(0.1, 1.3, 4.0), vec3(max(dot(seaNormal, seaRef), 0.0)));\n\n    float spe = pow(max(dot(sunDir, reflect(rd, normal)), 0.0), 3.0);\n    float fre = pow(1.0-dot(normal, -rd), 2.0);\n\n    col = seaCol;\n\n    const float level = 0.00;\n    const float level2 = 0.3;\n    // REALLY fake shadows and lighting\n    vec3 scol = sunCol1*(smoothstep(level, level2, hih) - smoothstep(level, level2, loh2));\n    col = mix(vec3(1.0), col, exp(-17.0*(hih-0.25*loh)));\n    col = mix(vec3(0.75), col, exp(-10.0*loh*(max(d-ud, 0.0))));\n    col += scol;\n\n    col += vec3(0.5)*spe*fre;\n\n    float ssd = (shipHeight - ro.y)/rd.y;\n\n    col += waterworld_shipColor((ro + rd*ssd).xz, ltime);\n\n    col = mix(col, skyCol, smoothstep(0.5*WATERWORLD_MAX_DISTANCE, 1.*WATERWORLD_MAX_DISTANCE, d));\n\n  } else {\n    col = skyCol;\n  }\n\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 waterworld_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro  = vec3(0.5, 5.5, -2.0);\n  vec3 la  = ro + vec3(0.0, -1.+0.75*ltime/(4.0*DURATION),  1.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = waterworld_getColor(ro, rd, ltime)  ;\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n//\n\n\n// ----------------------------==> WATERWORLD <==------------------------------\n\n// ----------------------------==> BARRENMOON <==------------------------------\n\n#ifdef ENABLE_BARRENMOON\n\n#define BARRENMOON_TOLERANCE       0.00001\n#define BARRENMOON_MAX_ITER        65\n#define BARRENMOON_MIN_DISTANCE    0.01\n#define BARRENMOON_MAX_DISTANCE    9.0\n\nconst float barrenmoon_near = 0.3;\nconst float barrenmoon_far  = 0.5;\n\nconst vec3 barrenmoon_sunCol1      = pow(sunCol1, vec3(1.0, 4.0, 4.0));\nconst vec3 barrenmoon_sunCol2      = pow(sunCol2, vec3(2));\nconst vec3 barrenmoon_smallSunCol1 = smallSunCol1;\nconst vec3 barrenmoon_smallSunCol2 = smallSunCol2;\n\nvec2 barrenmoon_hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat barrenmoon_circles(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = barrenmoon_hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  const float r = 0.225;\n\n  float d = circle(p, 2.0*r);\n\n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\nfloat barrenmoon_craters(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = barrenmoon_hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  rot(p, TAU*hh.y);\n  const float r = 0.45;\n\n  float d = egg(p, 0.75*r, 0.5*r*abs(hh.y));\n\n  float h = -abs(hh.x)*(smoothstep(0.0, r, -2.0*d)-0.3*smoothstep(0.0, 0.2*r, -d));\n\n  return h*0.275;\n}\n\n\nfloat barrenmoon_height(vec2 p, float dd, int mx) {\n  const float aa   = 0.45;\n  const float ff   = 2.03;\n  const float tt   = 1.2;\n  const float oo   = 3.93;\n\n  float a = 1.0;\n  float o = 0.2;\n  float s = 0.075*sin(p.x+p.y);\n  float d = 0.0;\n\n  int i = 0;\n\n  for (; i < 4;++i) {\n    float nn = a*barrenmoon_craters(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float lod = s/d;\n\n  float rdd = dd/BARRENMOON_MAX_DISTANCE;\n  mx = int(mix(float(4), float(mx), step(rdd, barrenmoon_far)));\n\n  for (; i < mx; ++i) {\n    float nn = a*barrenmoon_circles(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float hid = (s/d);\n\n  float m = smoothstep(barrenmoon_near, barrenmoon_far, rdd);\n  return mix(hid, lod, m*m);\n}\n\nfloat barrenmoon_height(vec2 p, float d) {\n  return barrenmoon_height(p, d, 6);\n}\n\nfloat barrenmoon_hiheight(vec2 p, float d) {\n  return barrenmoon_height(p, d, 8);\n}\n\nvec3 barrenmoon_normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = (barrenmoon_hiheight(p - eps.xy, d) - barrenmoon_hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (barrenmoon_hiheight(p - eps.yx, d) - barrenmoon_hiheight(p + eps.yx, d));\n\n  return normalize(n);\n}\n\nfloat barrenmoon_march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  const float initialStep = 1.0;\n  const float secondaryStep = 0.25;\n  float currentStepDist = initialStep;\n  float lastd = d;\n  float mint = -0.005/rd.y;\n  for (int i = 0; i < BARRENMOON_MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = barrenmoon_height(p.xz, d);\n\n    if (d > BARRENMOON_MAX_DISTANCE) {\n      max_iter = i;\n      return BARRENMOON_MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < BARRENMOON_TOLERANCE) {\n      if (currentStepDist < initialStep) {\n        max_iter = i;\n        return d;\n      }\n\n      d = lastd;\n      currentStepDist = secondaryStep;\n      continue;\n    }\n\n    dt = max(hd, mint)*currentStepDist;\n    lastd = d;\n    d += dt;\n  }\n\n  max_iter = BARRENMOON_MAX_ITER;\n  return BARRENMOON_MAX_DISTANCE;\n}\n\nvec3 barrenmoon_sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 barrenmoon_smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 barrenmoon_rocketDirection(float ltime) {\n  return normalize(vec3(0.0, -0.2+mod(ltime, 90.0)*0.0125, 1.0));\n}\n\nvec3 barrenmoon_skyColor(float ltime, vec3 ro, vec3 rd) {\n  vec3 sunDir = barrenmoon_sunDirection();\n  vec3 smallSunDir = barrenmoon_smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n\n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, vec3(0.0), smoothstep(0.0 , 1.0, 5.0*angle)), skyCol3, smoothstep(0.0, 1.0, -5.0*angle));\n\n  vec3 sunCol = 0.5*barrenmoon_sunCol1*pow(sunDot, 20.0) + 8.0*barrenmoon_sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*barrenmoon_smallSunCol1*pow(smallSunDot, 200.0) + 4.0*barrenmoon_smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dust = pow(barrenmoon_sunCol2*mountainColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n\n  float dustTransparency = smoothstep(-0.075, 0.0, rd.y);\n\n  vec3 rocketDir = barrenmoon_rocketDirection(ltime);\n  float rocketDot = max(dot(rd, rocketDir), 0.0);\n  float rocketDot2 = max(dot(normalize(rd.xz), normalize(rocketDir.xz)), 0.0);\n  vec3 rocketCol = vec3(0.25)*(3.0*smoothstep(-1.0, 1.0, psin(ltime*15.0*TAU))*pow(rocketDot, 70000.0) + smoothstep(-0.25, 0.0, rd.y - rocketDir.y)*step(rd.y, rocketDir.y)*pow(rocketDot2, 1000000.0))*dustTransparency;\n\n  vec3 planetCol = gasGiant(ro, rd, sunDir)*dustTransparency;\n\n  vec3 final = planetCol + skyCol + sunCol + smallSunCol + dust + rocketCol;\n\n  return final;\n}\n\nvec3 barrenmoon_getColor(float ltime, vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = barrenmoon_skyColor(ltime, ro, rd);\n  vec3 col = vec3(0);\n\n  float id = (0.125 - ro.y)/rd.y;\n\n  if (id > 0.0)   {\n    float d = barrenmoon_march(ro, rd, id, max_iter);\n    vec3 sunDir = barrenmoon_sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, .0, -1.0);\n    vec3 p = ro + d*rd;\n\n    vec3 normal = barrenmoon_normal(p.xz, d);\n    vec3 dnx = dFdx(normal);\n    vec3 dny = dFdy(normal);\n    float ff = dot(dnx, dnx) + dot(dny, dny);\n    normal = normalize(normal + vec3(0.0, 5.0*ff, 0.0));\n\n    float amb = 0.2;\n\n    float dif1 = max(0.0, dot(sunDir, normal));\n    vec3 shd1 = barrenmoon_sunCol2*mix(amb, 1.0, pow(dif1, 0.75));\n\n    float dif2 = max(0.0, dot(osunDir, normal));\n    vec3 shd2 = barrenmoon_sunCol1*mix(amb, 1.0, pow(dif2, 0.75));\n\n    vec3 ref = reflect(rd, normal);\n    vec3 rcol = barrenmoon_skyColor(ltime, p, ref);\n\n    col = mountainColor*amb*skyCol3;\n    col += mix(shd1, shd2, -0.5)*mountainColor;\n    float fre = max(dot(normal, -rd), 0.0);\n    fre = pow(1.0 - fre, 5.0);\n    col += rcol*fre*0.5;\n    col += (1.0*p.y);\n    col = tanh(col);\n    col = mix(col, skyCol, smoothstep(0.5*BARRENMOON_MAX_DISTANCE, BARRENMOON_MAX_DISTANCE, d));\n\n  } else {\n    col = skyCol;\n  }\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 barrenmoon_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  ltime = ltime + input0;\n  float off = 0.5*ltime;\n\n  vec3 ro  = vec3(0.5, 1.0-0.25, -2.0 + off);\n  vec3 la  = ro + vec3(0.0, -0.00,  2.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = barrenmoon_getColor(ltime, ro, rd)  ;\n\n//  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ----------------------------==> BARRENMOON <==------------------------------\n\n// ------------------------------==> GALAXY <==--------------------------------\n\n#ifdef ENABLE_GALAXY\n\nconst float galaxy_twirly   = 2.5;\nconst vec3  galaxy_colDust  = vec3(1.0, 0.9, 0.75);\n\nfloat galaxy_noise(float ttime, vec2 p) {\n  float s = 1.0;\n\n  p *= tanh(0.1*length(p));\n  float tm = ttime;\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5)+tm);\n  float d = cos(p.y*sqrt(1.5)+tm);\n\n  return a*b*c*d;\n}\n\nvec2 galaxy_twirl(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*galaxy_twirly + a;\n  p = toRect(pp);\n\n  p *= z;\n\n  return p;\n}\n\nfloat galaxy_galaxy(float ttime, vec2 p, float a, float z) {\n  p = galaxy_twirl(p, a, z);\n\n  return galaxy_noise(ttime, p);\n}\n\nvec3 galaxy_stars(vec2 p) {\n  float l = length(p);\n\n  vec2 pp = toPolar(p);\n  pp.x /= (1.0+length(pp.x))*0.5;\n  p = toRect(pp);\n\n  float sz = 0.0075;\n\n  vec3 s = vec3(10000.0);\n\n  for (int i = 0; i < 3; ++i) {\n    rot(p, 0.5);\n    vec2 ip = p;\n    vec2 n = mod2(ip, vec2(sz));\n    float r = hash(n);\n    vec2 o = -1.0 + 2.0*vec2(r, fract(r*1000.0));\n    s.x = min(s.x, length(ip-0.25*sz*o));\n    s.yz = n*0.1;\n  }\n\n  return s;\n}\n\nfloat galaxy_height(float ttime, vec2 p) {\n  float ang = atan(p.y, p.x);\n  float l = length(p);\n  float sp = mix(1.0, pow(0.75 + 0.25*sin(2.0*(ang + l*galaxy_twirly)), 3.0), tanh(6.0*l));\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  for (int i = 0; i < 11; ++i) {\n    float g = a*galaxy_galaxy(ttime, p, ttime*(0.025*float(i)), f);\n    s += g;\n    a *= sqrt(0.45);\n    f *= sqrt(2.0);\n    d += a;\n  }\n\n  s *= sp;\n\n  return SABS((-0.25+ s/d), 0.5)*exp(-5.5*l*l);\n}\n\nvec3 galaxy_normal(float ttime, vec2 p) {\n  vec2 eps = vec2(0.000125, 0.0);\n\n  vec3 n;\n\n  n.x = galaxy_height(ttime, p - eps.xy) - galaxy_height(ttime, p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = galaxy_height(ttime, p - eps.yx) - galaxy_height(ttime, p + eps.yx);\n\n  return normalize(n);\n}\n\nvec3 galaxy_galaxy(float ttime, vec2 p, vec3 ro, vec3 rd, float d) {\n  rot(p, 0.5*ttime);\n\n  float h = galaxy_height(ttime, p);\n  vec3 s = galaxy_stars(p);\n  float th = tanh(h);\n  vec3 n = galaxy_normal(ttime, p);\n\n  vec3 p3 = vec3(p.x, th, p.y);\n  float lh = 0.5;\n  vec3 lp1 = vec3(-0.0, lh, 0.0);\n  vec3 ld1 = normalize(lp1 - p3);\n  vec3 lp2 = vec3(0.0, lh, 0.0);\n  vec3 ld2 = normalize(lp2 - p3);\n\n  float l = length(p);\n  float tl = tanh(l);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n//  col += vec3(0.5)*pow(diff1, 20.0);\n  col += 0.25*pow(diff2, 4.0);\n  col += pow(vec3(0.5)*h, n.y*1.75*(mix(vec3(0.5, 1.0, 1.5), vec3(0.5, 1.0, 1.5).zyx, 1.25*tl)));\n//  col += 0.9*vec3(1.0, 0.9, 0.75)*exp(-10*l*l);\n\n\n  float sr = hash(s.yz);\n  float si = pow(th*sr, 0.25)*0.001;\n  vec3 scol = sr*5.0*exp(-2.5*l*l)*tanh(pow(si/(s.x), 2.5))*mix(vec3(0.5, 0.75, 1.0), vec3(1.0, 0.75, 0.5), sr*0.6);\n  float sd = length(ro);\n  scol = clamp(scol, 0.0, 1.0);\n  // TODO: Smooth out stars, but it works for the purpose of this shader\n  col += step(sd, 1.5)*scol*smoothstep(0.0, 0.35, 1.0-n.y);\n\n  float ddust = (h - ro.y)/rd.y;\n  if (ddust < d) {\n    float t = d - ddust;\n    col += 0.7*galaxy_colDust*(1.0-exp(-2.0*t));\n  }\n\n  return col;\n}\n\nvec3 galaxy_render(float ttime, vec3 ro, vec3 rd) {\n  float dgalaxy = (0.0 - ro.y)/rd.y;\n\n  vec3 col = vec3(0);\n\n  if (dgalaxy > 0.0) {\n    col = vec3(0.5);\n    vec3 p = ro + dgalaxy*rd;\n\n    col = galaxy_galaxy(ttime, p.xz, ro, rd, dgalaxy);\n  }\n\n  vec2 cgalaxy = raySphere(ro, rd, vec4(vec3(0.0), 0.125));\n\n  float t;\n\n  if (dgalaxy > 0.0 && cgalaxy.x > 0.0) {\n    float t0 = max(dgalaxy - cgalaxy.x, 0.0);\n    float t1 = cgalaxy.y - cgalaxy.x;\n    t = min(t0, t1);\n  } else if (cgalaxy.x < cgalaxy.y){\n    t = cgalaxy.y - cgalaxy.x;\n  }\n\n  col += 1.7*galaxy_colDust*(1.0-exp(-1.0*t));\n\n\n  return col;\n}\n\nvec3 galaxy_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n  vec3 ro = vec3(0.0, 0.7, 2.0)*mix(input0, input1, ltime/(2.0*DURATION));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(-0.5, 1.0, 0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  float ttime = 0.05*ltime;\n  vec3 col = galaxy_render(ttime, ro, rd);\n\n  col = postProcess(col, q);\n\n  return col;\n}\n\n#endif\n\n// ------------------------------==> GALAXY <==--------------------------------\n\n// -----------------------------==> SPACESHIP <==------------------------------\n\n#ifdef ENABLE_SPACESHIP\n\n#define SPACESHIP_TOLERANCE           0.001\n#define SPACESHIP_NORM_OFF            0.001\n#define SPACESHIP_MAX_RAY_LENGTH      100.0\n\n#define SPACESHIP_MAX_RAY_MARCHES     60\n\nconst float spaceship_refractRatio = 0.95;\n\nconst vec3  spaceship_seaCol1      = vec3(0.15, 0.45, 0.55);\nconst vec3  spaceship_seaCol2      = spaceship_seaCol1*spaceship_seaCol1*spaceship_seaCol1*3.0;\n\nconst float spaceship_innerLength  = 4.0;\nconst float spaceship_outerLength  = 6.25;\nconst vec3  spaceship_sunPos       = vec3(0.0, 0.0, spaceship_innerLength);\nconst vec3  spaceship_sunCol1      = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3  spaceship_sunCol2      = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\nconst vec3  spaceship_engineCol1   = vec3(8.0/8.0,6.0/8.0,6.0/8.0);\nconst vec3  spaceship_engineCol2   = vec3(8.0/8.0,5.0/8.0,6.0/8.0);\n\nconst vec3  spaceship_start       = vec3(0.0);\n\nvec3 spaceship_sunColor(vec3 ro, vec3 rd, float input0, float input1) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n  vec3 col = vec3(0.0);\n\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2;\n\n  col += pow(smallDiff, 8000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.5;\n  col += pow(smallDiff, 150.0)*smallSunColor2*0.5;\n\n  return col;\n}\n\nvec3 spaceship_skyColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n  vec3 gcol = gasGiant(ro+vec3(input0*input1/TAU, 0.0, input1), rd, sunDirection);\n\n  return scol+gcol;\n}\n\nvec3 spaceship_refColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n\n  vec3 final = vec3(0.0);\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) final = vec3(2.0)*rd.y;\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  final *= 0.5;\n  final += scol;\n\n  return final;\n}\n\nvec3 spaceship_domeColor(vec3 ro, vec3 rd, float input0, float input1) {\n  rot(rd.xz, input0);\n  vec3 scol = spaceship_sunColor(ro, rd, input0, input1);\n\n  vec3 final = mix(vec3(0.125, 0.25, 0.5), vec3(0.25), 0.5 + 0.5*rd.y)*0.5;\n  final += scol;\n\n  return final;\n}\n\nvec4 spaceship_backplane(vec3 ro, vec3 rd, inout vec3 scol) {\n  float ed = (spaceship_innerLength - ro.z)/rd.z;\n  vec3 ep = ro + rd*ed;\n  vec3 en = vec3(0.0, 0.0, 1.0);\n\n  float lr = 0.5;\n  float er = (lr*lr-dot(ep.xy, ep.xy))/(lr*lr);\n  float eradius = length(ep.xy);\n  float emradius = eradius;\n  float eangle = atan(ep.y, ep.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.1);\n  mod1(emangle, TAU/60.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n\n  float efadeout = 1.0 - smoothstep(0.0, 0.9, eradius);\n\n  scol = vec3(0.0);\n  scol += 8.0*spaceship_sunCol1*pow(clamp(er, 0.0, 1.0), 8.0);\n  scol += spaceship_sunCol1*pow(clamp(er, 0.0, 1.0), 1.0);\n  scol += spaceship_sunCol2*efadeout*efadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += scol;\n  ecol += elinec*smoothstep(0.01, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.015, 0.0, abs(emangle))*efadeout;\n\n  return vec4(ecol, eradius < 1.0);\n}\n\nfloat spaceship_fbm(vec2 p, int mx) {\n  const float aa = 0.45;\n  const float pp = 2.08;\n  const float rr = 1.0;\n\n  float a = 1.0;\n  float s = 0.0;\n  float d = 0.0;\n\n  for (int i = 0; i < mx; ++i) {\n    s += a*vnoise(p);\n    d += abs(a);\n    a *= aa;\n    p *= pp;\n    rot(p, rr);\n  }\n\n  return 1.0*s/d;\n}\n\nvec3 spaceship_normal(vec2 p, int mx) {\n  vec2 eps = -vec2(0.0001, 0.0);\n\n  vec3 nor;\n\n  nor.x = spaceship_fbm(p + eps.xy, mx) - spaceship_fbm(p - eps.xy, mx);\n  nor.y = 2.0*eps.x;\n  nor.z = spaceship_fbm(p + eps.yx, mx) - spaceship_fbm(p - eps.yx, mx);\n\n  return normalize(nor);\n}\n\nvec3 spaceship_islands(vec3 col, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.7;\n  float beachLevel = level + 0.025;\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n\n  sp *= 2.0;\n  float hih = spaceship_fbm(sp, 6);\n  float loh = spaceship_fbm(sp+vec2(0.075-0.075*sp.x/spaceship_innerLength, 0.0), 3);\n  vec3 hn = spaceship_normal(sp, 6);\n\n  vec3 nn = normalize(hn + n);\n\n  const vec3 sandCol = vec3(1.0, 0.95, 0.9);\n\n  float fdiff = pow(max(dot(sunDir, nn), 0.0), 0.5);\n\n  vec4 treePattern = voronoi(sp*40.0);\n  vec3 islandCol  = mix(vec3(0.5, 0.75, 0.0), vec3(0.1, 0.45, 0.0), treePattern.y*fdiff*2.0);\n  islandCol *= 1.0 - treePattern.x * 0.75;\n\n  col = mix(0.0, 1.0, hih < level)*mix(sandCol, col , 1.0 - exp(8.0*vec3(2.0, 1.0, 1.0)*(hih-level)));\n  col = mix(col, sandCol, vec3((beachLevel >  hih) && (hih > level)));\n  col = mix(col, islandCol, vec3(hih > beachLevel));\n  // Really REALLY fake lighting+shadows\n  const float hh = 0.125;\n  vec3 scol = vec3(1.0)*(smoothstep(level, level+hh, hih) - smoothstep(level, level+hh, loh));\n  col = col+scol*0.5;\n\n  return col;\n}\n\nvec3 spaceship_clouds(vec3 col, vec3 ro, vec3 rd, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.5;\n\n  vec3 ref = reflect(rd, n);\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n  float sunL2 = l2(spaceship_sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe1 = 0.5*pow(max(dot(sunDir, ref), 0.0), 10.0);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  sp *= 2.0;\n  sp += 100.0;\n  float hih = max(spaceship_fbm(sp, 6) - level, 0.0);\n  float loh = max(spaceship_fbm(sp, 3) - level, 0.0);;\n\n  // More fake stuff\n  float m = clamp(1.0- exp(-15.0*(hih-0.5*loh)), 0.0, 1.0);\n\n  col = mix(col, vec3(1.25)*spaceship_sunCol1*(sunIll + spe1 + spe2), m*m*m);\n\n  return col;\n}\n\nvec3 spaceship_cloudShadows(vec3 col, vec3 p, float level) {\n  level += 0.5;\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n\n  vec2 ci = rayCylinder(p, sunDir, spaceship_start, vec4(0.0, 0.0, 1.0, 0.8));\n\n  vec3 pp = p + ci.x*sunDir;\n  vec2 pp2 = cylinderCoord(pp);\n\n  pp2 *= 2.0;\n  pp2 += 100.0;\n  float loh = max(spaceship_fbm(pp2, 3) - level, 0.0);\n\n  return col*mix(0.3, 1.0, exp(-3.0\n  *loh));\n}\n\nvec3 spaceship_sea(vec3 ro, vec3 rd, vec3 n, vec3 p, vec2 sp) {\n\n  vec3 ref = reflect(rd, n);\n  ref = normalize(ref + 0.025*psin(mix(110.0, 220.0, psin(2.0*p.z+0.2*p.x))*p.z));\n\n  vec3 sunDir = normalize(spaceship_sunPos - p);\n  float sunL2 = l2(spaceship_sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  vec3 seaCol = vec3(0.0);\n  seaCol += 1.0*spaceship_seaCol2*pow(1.0-max(dot(n, ref), 0.0), 0.45);\n  seaCol += spaceship_seaCol1*0.5*sunIll;\n  seaCol += spaceship_seaCol1*spaceship_sunCol1*sunDiff*sunIll;\n  seaCol += spaceship_sunCol1*spe2;\n\n  return seaCol;\n}\n\nvec3 spaceship_shipInterior(vec3 ro, vec3 rd, float input0, float input1) {\n  ro += rd*0.05;\n\n  float fd = (0.0 - ro.z)/rd.z;\n  vec2 di = raySphere(ro, rd, vec4(spaceship_start, 1.0));\n  vec2 ci = rayCylinder(ro, rd, spaceship_start, vec4(0.0, 0.0, 1.0, 0.8));\n  vec2 gi = rayCylinder(ro, rd, spaceship_start, vec4(0.0, 0.0, 1.0, 0.9));\n\n  vec3 dp = ro + rd*di.y;\n  vec3 dn = -normalize(dp  -spaceship_start);\n  vec3 drefr = refract(dp, dn, 1.0/spaceship_refractRatio);\n  vec3 dcol = 0.9*spaceship_domeColor(dp, drefr, input0, input1);\n\n  vec3 gp = ro + rd*gi.y;\n  vec3 gpy = ro + rd*gi.x;\n  vec3 gn = -normalize(vec3(gp.xy-spaceship_start.xy, 0.0));\n  vec2 gp2 = cylinderCoord(gp);\n\n  vec3 cp = ro + rd*ci.y;\n  vec3 cn = -normalize(vec3(cp.xy-spaceship_start.xy, 0.0));\n\n  vec3 fpcol = vec3(0.0);\n\n  vec3 scol;\n  vec4 bpcol = spaceship_backplane(ro, rd, scol);\n  vec3 bpn = vec3(0.0, 0.0, 1.0);\n  float bpdiff = max(dot(rd, bpn), 0.0);\n\n  vec3 col = vec3(0.0);\n\n  col = mix(col, fpcol, vec3(fd > gi.y));\n  col = mix(col, dcol, vec3(dp.z < 0.0));\n  col = mix(col, bpcol.xyz, bpcol.w);\n\n  if (gp.z > 0.0 && gpy.z < 0.0 && gp.z < spaceship_innerLength) {\n    float level = 0.0;\n    level += 1.0-smoothstep(0.0, 0.1*spaceship_innerLength, gp2.x);\n    level += 1.0-smoothstep(0.0, 0.1*spaceship_innerLength, spaceship_innerLength-gp2.x);\n\n    /*\n    // Too fix discontinuity. Alternative approach, place the camera correctly ;)\n    level += 1.0-smoothstep(-PI, -PI+0.5, gp2.y);\n    level += 1.0-smoothstep(PI, PI-0.5, gp2.y);\n    */\n\n    level *= 0.125;\n    vec3 gcol = spaceship_sea(ro, rd, gn, gp, gp2);\n    gcol = spaceship_islands(gcol, gp, gn, gp2, level);\n    gcol = spaceship_cloudShadows(gcol, gp, level);\n    gcol = spaceship_clouds(gcol, ro, rd, cp, cn, cylinderCoord(cp), level);\n    col = gcol;\n  }\n\n  float id = max(gi.y-max(gi.x, 0.0), 0.0);\n  col = mix(col, spaceship_sunCol1, 1.0-exp(-0.05*id*id));\n  col = mix(col, 0.75*scol + 1.25*spaceship_sunCol1, pow(bpdiff, 35.0));\n\n  return col;\n}\n\nfloat spaceship_theShip(float ltime, vec3 p, out float nx, out float ny, out int m) {\n  const float rep = 5.0;\n  const float tradius = 1.2;\n  const float sstep = TAU*1.125/rep;\n  const float sradius = 0.45*TAU*1.125/rep;\n  rot(p.xy, ltime*TAU/60.0);\n  float dcapsule = capsule(p, spaceship_outerLength, 1.0);\n  dcapsule = pmin(dcapsule, softBox(p, 0.75), 0.25);\n  float dglobe = max(dcapsule, p.z);\n\n  vec3 pc = p;\n  pc.z -= 0.5*sstep;\n  float n = mod1(pc.z, sstep);\n  float dtorus = torus(pc.xzy, vec2(tradius*1.55, 0.025));\n  float nm = modPolar(pc.xy, rep);\n  float dspoke = cylinder(pc, vec3(tradius*1.55, 0.0, 0.025));\n  dtorus = min(dtorus, dspoke);\n  dtorus = max(dtorus, -p.z + sstep*0.5-0.025);\n  dtorus = max(dtorus, p.z-sstep*5.0 + sstep*0.5-0.025);\n  float dbattery = sphere(pc - vec3(tradius, 0.0, 0.0), sradius);\n  float dbox = softBox(pc - vec3(tradius, 0.0, 0.0), sradius*0.9);\n  dbox = roundDiff(dbox, dbattery, 0.125);\n  dbattery = min(dbattery, dbox);\n  dbattery = max(dbattery, -p.z + sstep*0.05);\n  dbattery = max(dbattery, p.z-sstep*5.0);\n  float dengine1 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+1.0)), 0.9);\n  float dengine2 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+2.0)), 0.9);\n  float dengine3 = sphere((p-vec3(0.0, 0.0, spaceship_outerLength+1.0)), 0.25);\n  float dengine = dengine1;\n  dengine = max(dengine, -dengine2);\n  dengine = min(dengine, dengine3);\n  vec3 pe = p;\n  pe -= vec3(0.0, 0.0, spaceship_outerLength+1.8);\n  mod1(pe.x, 0.5);\n  mod1(pe.y, 0.5);\n  float d = dcapsule;\n  d = min(d, dengine);\n  d = chamfer(d, dbattery, 0.035);\n  d = min(d, dtorus);\n\n\n  m = 1;\n\n  if (d == dglobe) m = 3;\n  if (d == dbattery) m = 4;\n  if (d == dtorus) m = 1;\n  if (d == dbox) m = 2;\n  if (d == dengine1) m = 2;\n  if (d == -dengine2) m = 5;\n  if (d == dengine3) m = 5;\n\n  nx = n;\n  ny = nm;\n\n  return d;\n}\n\nfloat spaceship_map(float ltime, vec3 p, out float nx, out float ny, out int m) {\n  return spaceship_theShip(ltime, p, nx, ny, m);\n}\n\n\nfloat spaceship_rayMarch(float ltime, vec3 ro, vec3 rd, out float nx, out float ny, out int mat, out int iter) {\n  float t = 0.0;\n  float d;\n  int i;\n  for (i = 0; i < SPACESHIP_MAX_RAY_MARCHES; i++)\n  {\n    d = spaceship_map(ltime, ro + rd*t, nx, ny, mat);\n    if (d < SPACESHIP_TOLERANCE || t > SPACESHIP_MAX_RAY_LENGTH) break;\n    t += d; // 0.9\n  }\n  iter = i;\n\n  if (abs(d) > 10.0*SPACESHIP_TOLERANCE) return SPACESHIP_MAX_RAY_LENGTH;\n\n  return t;\n}\n\nvec3 spaceship_normal(float ltime, vec3 pos) {\n  vec3  eps = vec3(SPACESHIP_NORM_OFF,0.0,0.0);\n  vec3 nor;\n  float nx;\n  float ny;\n  int mat;\n  nor.x = spaceship_map(ltime, pos+eps.xyy, nx, ny, mat) - spaceship_map(ltime, pos-eps.xyy, nx, ny, mat);\n  nor.y = spaceship_map(ltime, pos+eps.yxy, nx, ny, mat) - spaceship_map(ltime, pos-eps.yxy, nx, ny, mat);\n  nor.z = spaceship_map(ltime, pos+eps.yyx, nx, ny, mat) - spaceship_map(ltime, pos-eps.yyx, nx, ny, mat);\n  return normalize(nor);\n}\n\nvec3 spaceship_innerColor(float ltime, vec3 ro, vec3 rd, vec3 nor, float nx, float ny) {\n  vec2 f = hash2(137.0*vec2(nx, ny)+27.0);\n  vec3 refr = refract(rd, nor, 3.0);\n  float dim = smoothstep(0.6, 0.7, f.x);\n  dim *= mix(0.5, 1.0, psin(2.0*ltime+f.y*TAU));\n  float s1 = mix(0.3, 2.0, dim);\n  float s2 = mix(1.0, 1.25, dim);\n  float m = max(dot(nor, -refr), 0.0);\n  return 1.5*s1*pow(vec3(1.2, 1.1, s2)*m, 1.25*vec3(2.5, 2.5, 5.5));\n}\n\nvec3 engineColor(vec3 ro, vec3 rd, vec3 nor) {\n  float eradius = length(ro.xy);\n  float emradius = eradius;\n  float eangle = atan(ro.y, ro.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.2);\n  mod1(emangle, TAU/20.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n\n  float efadeout = 1.0 - smoothstep(0.0, 0.75, eradius);\n  float ifadeout = smoothstep(0.2, 0.225, eradius);\n\n  vec3 refr = refract(rd, nor, 1.25);\n  float m = max(dot(nor, -refr), 0.0);\n\n\n  vec3 scol = vec3(0.0);\n  scol += 4.0*spaceship_engineCol1*pow(m, 4.0);\n  scol += spaceship_engineCol2*2.0;\n  scol *= 1.0- ifadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += elinec*smoothstep(0.02, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.05, 0.0, abs(emangle))*efadeout;\n  ecol += spaceship_engineCol2*2.0*efadeout*efadeout;\n  ecol *= ifadeout;\n\n  return ecol + scol;\n}\n\nvec3 spaceship_render(float ltime, float input0, float input1, vec3 ro, vec3 rd) {\n  // background color\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  int mat = 0;\n  int iter = 0;\n  float nx;\n  float ny;\n  float t = spaceship_rayMarch(ltime, ro, rd, nx, ny, mat, iter);\n\n//  vec3 icol = 1.0*vec3(1.0, 0.0, 0.9)*smoothstep(0.5, 1.0, float(iter)/MAX_RAY_MARCHES);\n  const  vec3 icol = vec3(0.0);\n\n  vec3 pos = ro + t*rd;\n  vec3 nor = spaceship_normal(ltime, pos);\n\n  float ndif = 1.0;\n  float nref = 0.8;\n\n  vec3 ref  = reflect(rd, nor);\n  vec3 rcol = spaceship_refColor(pos, ref, input0, input1);\n  vec3 refr = refract(rd, nor, spaceship_refractRatio);\n\n  if (t < SPACESHIP_MAX_RAY_LENGTH) {\n    // Ray intersected object\n\n    switch(mat) {\n    case 0:\n      color = mix(vec3(1.0), nor*nor, 0.5);\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 1:\n      color = vec3(0.9) + abs(nor.zxy)*0.1;\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 2:\n      color = vec3(0.25) + abs(nor.zxy)*0.05;\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 3:\n      vec3 sicol = spaceship_shipInterior(pos, refr, input0, input1);\n      color = mix(sicol, rcol, vec3(refr == vec3(0.0)));\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 4:\n      color = spaceship_innerColor(ltime, pos, rd, nor, nx, ny);\n      ndif = 0.75;\n      nref = 0.9;\n      break;\n    case 5:\n      color = engineColor(pos, rd, nor);\n      ndif = 0.5;\n      nref = 0.75;\n      break;\n    default:\n      color = nor*nor;\n      break;\n    }\n\n  }\n  else {\n    // Ray intersected sky\n    return spaceship_skyColor(ro, rd, input0, input1) + icol;\n  }\n\n  vec3 ld0  = vec3(0.0, 1.0, 0.0);\n\n  vec3 lv1  = sunDirection;\n  float ll1 = length(lv1);\n  vec3 ld1  = lv1 / ll1;\n\n  vec3 lv2  = smallSunDirection;\n  float ll2 = length(lv2);\n  vec3 ld2  = lv2 / ll2;\n\n  int rmat = 0;\n  int riter = 0;\n  float st  = spaceship_rayMarch(ltime, pos + ref*10.0*SPACESHIP_TOLERANCE, ref, nx ,ny, rmat, riter);\n  float sha2 = st < SPACESHIP_MAX_RAY_LENGTH ? 0.0 : 1.0;\n\n  float dif0 = pow(max(dot(nor,ld0),0.0), ndif);\n  float dif1 = pow(max(dot(nor,ld1),0.0), ndif);\n  float dif2 = pow(max(dot(nor,ld2),0.0), ndif);\n\n  vec3 col0 = mix(vec3(1.0), dif0*vec3(1.0), 0.8);\n  vec3 col1 = mix(vec3(1.0), dif1*spaceship_sunCol1, 0.8);\n  vec3 col2 = mix(vec3(1.0), dif2*spaceship_sunCol2, 0.8);\n\n  vec3 col = mix(rcol*sha2, color*(col0 + col1 + col2)/2.0, nref);\n\n  return col + icol;\n}\n\nvec3 spaceship_fragment(float ltime, float input0, float input1, vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  return spaceship_render(ltime, input0, input1, ro, rd);\n}\n\n\nvec3 spaceship_effect(int minor, float input0, float input1, float ltime, vec2 p, vec2 q) {\n\n  vec3 ro  =vec3(1.0, 0.0, -3.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  switch(minor) {\n  case MINOR_FROM_BEHIND:\n    ro = 3.0*vec3(0.5-ltime/10., 1.0+ltime/5.0, 15.0-ltime);\n    break;\n  case MINOR_CYLINDER_SEA:\n    ro = vec3(-7.5+ltime, 0.5, -1.5-ltime/10.0);\n    break;\n  case MINOR_FROM_FRONT:\n    ro = -3.0*vec3(-0.5+ltime/10., 1.0-ltime/5.0, 10.0-ltime);\n    break;\n  default:\n    break;\n  }\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n  col += spaceship_fragment(ltime, input0, input1, ro, uu, vv, ww, p+o1);\n\n#ifdef AA\n  // Adaptive AA? Is that a good idea?\n  vec3 dcolx = dFdx(col);\n  vec3 dcoly = dFdy(col);\n  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly)/(col+1.0/256);\n//  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly);\n\n  float de = max(dcol.x, max(dcol.y, dcol.z));\n  if (de > 0.1) {\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p-o1);\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p+o2);\n    col += spaceship_fragment(ltime, ro, uu, vv, ww, p-o2);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n#endif\n\n  return col;\n}\n\n#endif\n\n// -----------------------------==> SPACESHIP <==------------------------------\n\n// -------------------------------==> MAIN <==---------------------------------\n\nvec3 mainImage(vec2 p, vec2 q) {\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float effectNo = 0.0;\n  const float totalTime = float(effects.length())*DURATION + (DURATION1-DURATION);\n  float dtime = mod(max(TIME, 0.0), totalTime)-(DURATION1 - DURATION);\n\n  float timeInEffect = mod(dtime, DURATION);\n  int effectIndex = int(effectNo + mod(dtime/DURATION, float(effects.length())));\n\n  if (dtime < DURATION) {\n    // Special handling for first effect\n    timeInEffect = dtime+DURATION1 - DURATION;\n    effectIndex = 0;\n  }\n\n  Effect effect = effects[effectIndex];\n  Effect nextEffect = effects[int(((effectIndex + 1)%effects.length()))];\n  float ltime = timeInEffect + effect.seq*DURATION;\n\n  vec3 col = vec3(0.5);\n\n\n  switch(effect.major) {\n#ifdef ENABLE_NOEFFECT\n  case MAJOR_NOEFFECT:\n    col = noeffect_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_IMPULSE\n  case MAJOR_IMPULSE:\n    col = impulse_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_ORRERY\n  case MAJOR_ORRERY:\n    col = orrery_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_WATERWORLD\n  case MAJOR_WATERWORLD:\n    col = waterworld_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_BARRENMOON\n  case MAJOR_BARRENMOON:\n    col = barrenmoon_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_GALAXY\n  case MAJOR_GALAXY:\n    col = galaxy_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n#ifdef ENABLE_SPACESHIP\n  case MAJOR_SPACESHIP:\n    col = spaceship_effect(effect.minor, effect.input0, effect.input1, ltime, p, q);\n    break;\n#endif\n  default:\n    col = vec3(0.5, 0.0, 0.0);\n    break;\n  }\n\n  col = clamp(col, 0.0, 1.0);\n\n  float fadeIn  = smoothstep(0.0, FADEIN, timeInEffect);\n  float fadeOut = smoothstep(DURATION - FADEOUT, DURATION, timeInEffect);\n  float tfadeout = smoothstep(DURATIONT - 2.0*DURATION, DURATIONT, TIME);\n\n  if (effect.fade && effect.seq == 0.0) {\n    col = mix(vec3(0.0), col, fadeIn*fadeIn);\n  }\n\n  if (effect.fade && nextEffect.seq == 0.0){\n    col = mix(col, vec3(0.0), fadeOut*fadeOut);\n  }\n\n  col = mix(col, vec3(0.0), tfadeout*tfadeout);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  fragColor = vec4(mainImage(p, q), 1.0);\n}\n\n// -------------------------------==> MAIN <==---------------------------------\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyWf.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[6146, 6146, 6167, 6167, 6208], [6210, 6210, 6232, 6232, 6276], [6278, 6278, 6303, 6303, 6332], [6334, 6334, 6373, 6373, 6498], [6500, 6500, 6536, 6536, 6630], [6632, 6632, 6659, 6659, 6728], [6730, 6730, 6779, 6779, 7181], [7183, 7183, 7205, 7205, 7374], [7376, 7376, 7411, 7411, 7729], [7731, 7731, 7762, 7762, 7788], [7790, 7790, 7821, 7821, 7847], [7849, 7849, 7876, 7876, 7952], [7954, 7954, 8004, 8004, 8221], [8223, 8254, 8286, 8286, 8362], [8364, 8364, 8393, 8393, 8458], [8461, 8461, 8502, 8502, 8557], [8559, 8559, 8591, 8591, 8625], [8628, 8628, 8646, 8646, 8668], [8670, 8670, 8688, 8688, 8710], [8711, 8711, 8741, 8741, 8776], [8778, 8778, 8811, 8811, 8896], [8898, 8898, 8932, 8932, 8956], [8958, 8958, 8997, 8997, 9260], [9262, 9262, 9290, 9290, 9329], [9331, 9331, 9355, 9355, 9425], [9427, 9427, 9447, 9447, 9545], [9547, 9547, 9586, 9586, 9675], [9677, 9677, 9729, 9729, 9817], [9819, 9819, 9861, 9861, 9911], [9913, 9913, 9958, 9958, 9997], [9998, 9998, 10019, 10019, 10048], [10050, 10050, 10071, 10071, 10100], [10102, 10102, 10157, 10157, 10480], [10482, 10482, 10524, 10524, 10571], [10573, 10573, 10617, 10617, 10875], [10878, 10878, 10944, 10944, 11447], [11450, 11450, 11472, 11472, 12025], [12027, 12027, 12049, 12049, 12389], [12420, 12420, 12443, 12443, 12496], [12498, 12498, 12521, 12521, 12699], [12701, 12701, 12724, 12724, 12854], [12856, 12856, 12879, 12879, 12952], [12954, 12954, 12977, 12977, 13014], [13016, 13016, 13039, 13039, 13296], [13298, 13298, 13321, 13321, 13399], [13401, 13401, 13424, 13424, 14161], [14163, 14163, 14202, 14202, 14560], [14562, 14562, 14608, 14608, 16039], [16041, 16041, 16077, 16102, 16352], [64833, 64833, 64865, 64865, 67160], [67162, 67162, 67214, 67214, 67319]], "test": "error"}
{"id": "tllyz4", "name": "fork-XY Oscilloscope Cube", "author": "jorge2017a1", "description": "fork-XY Oscilloscope Cube\n\n///XY Oscilloscope Cube (Loud)\n//Creado por Flyguy en 2016-10-23\n//https://www.shadertoy.com/view/lly3DG", "tags": ["forkxyoscilloscopecube"], "likes": 7, "viewed": 171, "published": "Public", "date": "1591580412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///XY Oscilloscope Cube (Loud)\n//Creado por Flyguy en 2016-10-23\n//https://www.shadertoy.com/view/lly3DG\n\n//Modificado por: jorge2017a1  \n//fecha 07/jun/2020\n\n\n\n//Preview of the shape being drawn. (may fall out of sync with the sound when paused)\n\nfloat tau = atan(1.0)*8.0;\n\nfloat gShapeTime = 0.0;\nmat4 gModel = mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);\n\nvec2 cossin(float x)\n{\n\treturn vec2(cos(x), sin(x));   \n}\n\n//Single point projection\nvec2 Project(vec3 p0)\n{\n    vec3 vanish = vec3(0.0,-2.0,0.0);\n    \n    p0 -= vanish;\n    \n\treturn length(vanish) * p0.xz / p0.y;\n}\n\n//Transformation functions\nmat4 Translate(vec3 v)\n{\n    return mat4(vec4(1,0,0,v.x), vec4(0,1,0,v.y), vec4(0,0,1,v.z), vec4(0,0,0,1));\n}\n\n//Angle-axis rotation\nmat4 Rotate(vec3 u,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    u = normalize(u);\n    \n    vec3 c0 = vec3(c + (u.x*u.x) * (1.0-c), (u.y*u.x) * (1.0-c) + (u.z*s), (u.z*u.x) * (1.0-c) - (u.y*s));    \n    vec3 c1 = vec3((u.x*u.y) * (1.0-c) - (u.z*s), c + (u.y*u.y) * (1.0-c), (u.z*u.y) * (1.0-c) + (u.x*s)); \n    vec3 c2 = vec3((u.x*u.z) * (1.0-c) + (u.y*s), (u.y*u.z) * (1.0-c) - (u.x*s), c + (u.z*u.z) * (1.0-c));\n    \n    return mat4(mat3(c0,c1,c2));\n}\n\nmat4 Scale(vec3 v)\n{\n    return mat4(vec4(v.x,0,0,0), vec4(0,v.y,0,0), vec4(0,0,v.z,0), vec4(0,0,0,1));\n}\n\n//Projected line\nfloat Line3d(vec3 p0,vec3 p1,vec2 uv)\n{\n    p0 = (vec4(p0,1.0) * gModel).xyz;\n    p1 = (vec4(p1,1.0) * gModel).xyz;\n    \n\tp0.xy = Project(p0);\n\tp1.xy = Project(p1);\n    \n\tvec2 dir = normalize(p1.xy - p0.xy);\t\n\tuv = (uv - p0.xy) * mat2(dir.x, dir.y, -dir.y, dir.x);\t\n    \n    float d = distance(uv, clamp(uv, vec2(0.0), vec2(distance(p0.xy, p1.xy), 0.0)));\n    \n\treturn smoothstep(4.0/iResolution.y, 0.0, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y) - (res / 2.0);\n    uv *= 2.0;\n    \n    float time = iTime*0.5+4.0;\n    \n    \n    gModel *= Scale(vec3(0.081525));\n    \n    gModel *= Rotate(vec3(0, 0, 1), time);\n    gModel *= Rotate(vec3(0, 1, 0), time);\n    gModel *= Rotate(vec3(1, 0, 0), time);\n    //gModel *= Translate(vec3(0.4 * cossin(1.0 * time), 0.4 * sin(0.6 * time)));\n    \n    \n    \nvec3 cube[18];\ncube[0] = vec3(2, 2, 0);\ncube[1] = vec3(2, 7, 0);\ncube[2] = vec3(5, 10, 0);\ncube[3] = vec3(8, 7, 0);\ncube[4] = vec3(8, 2, 0);\ncube[5] = vec3(7, 2, 0);\ncube[6] = vec3(6, 2, 0);\ncube[7] = vec3(6, 5, 0);\ncube[8] = vec3(7, 5, 0);\n    \ncube[9] = vec3(2, 2, 10);\ncube[10] = vec3(2, 7, 10);\ncube[11] = vec3(5, 10, 10);\ncube[12] = vec3(8, 7, 10);\ncube[13] = vec3(8, 2, 10);\ncube[14] = vec3(7, 2, 10);\ncube[15] = vec3(6, 2, 10);\ncube[16] = vec3(6, 5, 10);\ncube[17] = vec3(7, 5, 10);\n    \n    \n     for(int j=0;j<18;j++)\n     {\n        cube[j]+= vec3(-15.0,0.0,0.0);\n     } \n         \n    \n    \n    vec3 cout = vec3(0);\n    \n    \n    //z0\n\tcout += Line3d(cube[0],cube[1], uv);\n    cout += Line3d(cube[1],cube[2], uv);\n    cout += Line3d(cube[2],cube[3], uv);\n    cout += Line3d(cube[3],cube[4], uv);\n    cout += Line3d(cube[4],cube[5], uv);\n    cout += Line3d(cube[5],cube[6], uv);\n    cout += Line3d(cube[6],cube[7], uv);\n    cout += Line3d(cube[7],cube[8], uv);\n    cout += Line3d(cube[8],cube[5], uv);\n    cout += Line3d(cube[6],cube[0], uv);\n    \n    \n    // z2\n    cout += Line3d(cube[9],cube[10], uv);\n    cout += Line3d(cube[10],cube[11], uv);\n    cout += Line3d(cube[11],cube[12], uv);\n    cout += Line3d(cube[12],cube[13], uv);\n    cout += Line3d(cube[13],cube[14], uv);\n    cout += Line3d(cube[14],cube[15], uv);\n    cout += Line3d(cube[15],cube[16], uv);\n    cout += Line3d(cube[16],cube[17], uv);\n    cout += Line3d(cube[17],cube[14], uv);\n    cout += Line3d(cube[14],cube[9], uv);\n    \n    \n    //lineas de largo eje z\n    cout += Line3d(cube[0],cube[9], uv);\n    cout += Line3d(cube[1],cube[10], uv);\n    cout += Line3d(cube[2],cube[11], uv);\n    cout += Line3d(cube[3],cube[12], uv);\n    cout += Line3d(cube[4],cube[13], uv);\n   \n\n\n    \n    \n    \nvec3 casa2[24];\ncasa2[0]=vec3( 1, 1, 0) ;  //1\ncasa2[1]=vec3( 1, 4, 0) ;  //2\ncasa2[2]=vec3( 2, 5, 0) ;  //3\ncasa2[3]=vec3( 3, 6, 0) ;  //4\ncasa2[4]=vec3( 4, 7, 0) ;  //5\ncasa2[5]=vec3( 4, 8, 0) ;  //6\ncasa2[6]=vec3( 5, 8, 0) ;  //7\ncasa2[7]=vec3( 5, 7, 0) ;  //8\ncasa2[8]=vec3( 6, 6, 0) ;  //9\ncasa2[9]=vec3( 7, 5, 0) ;  //10\ncasa2[10]=vec3( 8, 4, 0) ;  //11\ncasa2[11]=vec3( 8, 1, 0) ;  //12\n    \ncasa2[12]=vec3( 1, 1, 25) ;  //13\ncasa2[13]=vec3( 1, 4, 25) ;  //14\ncasa2[14]=vec3( 2, 5, 25) ;  //15\ncasa2[15]=vec3( 3, 6, 25) ;  //16\ncasa2[16]=vec3( 4, 7, 25) ;  //17\ncasa2[17]=vec3( 4, 8, 25) ;  //18\ncasa2[18]=vec3( 5, 8, 25) ;  //19\ncasa2[19]=vec3( 5, 7, 25) ;  //20\ncasa2[20]=vec3( 6, 6, 25) ;  //21\ncasa2[21]=vec3( 7, 5, 25) ;  //22\ncasa2[22]=vec3( 8, 4, 25) ;  //23\ncasa2[23]=vec3( 8, 1, 25) ;  //24\n    \n    \n   for(int j=12;j<24;j++)\n     {\n        casa2[j]+= vec3(0.0,0.0,-15.0);\n     } \n    \n    \n    //lado A\n    cout += Line3d(casa2[0],casa2[1], uv);\n    cout += Line3d(casa2[1],casa2[2], uv);\n    cout += Line3d(casa2[2],casa2[3], uv);\n    cout += Line3d(casa2[3],casa2[4], uv);\n    cout += Line3d(casa2[4],casa2[5], uv);\n    cout += Line3d(casa2[5],casa2[6], uv);\n    cout += Line3d(casa2[6],casa2[7], uv);\n    cout += Line3d(casa2[7],casa2[8], uv);\n    cout += Line3d(casa2[8],casa2[9], uv);\n    cout += Line3d(casa2[9],casa2[10], uv);\n    cout += Line3d(casa2[10],casa2[11], uv);\n    cout += Line3d(casa2[11],casa2[0], uv);\n    \n    //lado B\n    cout += Line3d(casa2[12],casa2[13], uv);\n    cout += Line3d(casa2[13],casa2[14], uv);\n    cout += Line3d(casa2[14],casa2[15], uv);\n    cout += Line3d(casa2[15],casa2[16], uv);\n    cout += Line3d(casa2[16],casa2[17], uv);\n    cout += Line3d(casa2[17],casa2[18], uv);\n    cout += Line3d(casa2[18],casa2[19], uv);\n    cout += Line3d(casa2[19],casa2[20], uv);\n    cout += Line3d(casa2[20],casa2[21], uv);\n    cout += Line3d(casa2[21],casa2[22], uv);\n    cout += Line3d(casa2[22],casa2[23], uv);\n    cout += Line3d(casa2[23],casa2[12], uv);\n    \n    \n    //union a y b\n    cout += Line3d(casa2[0],casa2[12], uv);\n    cout += Line3d(casa2[1],casa2[13], uv);\n    cout += Line3d(casa2[2],casa2[14], uv);\n    cout += Line3d(casa2[3],casa2[15], uv);\n    cout += Line3d(casa2[4],casa2[16], uv);\n    cout += Line3d(casa2[5],casa2[17], uv);\n    cout += Line3d(casa2[6],casa2[18], uv);\n    cout += Line3d(casa2[7],casa2[19], uv);\n    cout += Line3d(casa2[8],casa2[20], uv);\n    cout += Line3d(casa2[9],casa2[21], uv);\n    cout += Line3d(casa2[10],casa2[22], uv);\n    cout += Line3d(casa2[11],casa2[23], uv);\n   \n    \n        \n    \n    \nvec3 tria[18];\ntria[0]=vec3( 1, 1,0);  //1\ntria[1]=vec3( 2, 2,0);  //2\ntria[2]=vec3( 3, 3,0);  //3\ntria[3]=vec3( 4, 4,0);  //4\ntria[4]=vec3( 5, 5,0);  //5\ntria[5]=vec3( 6, 4,0);  //6\ntria[6]=vec3( 7, 3,0);  //7\ntria[7]=vec3( 8, 2,0);  //8\ntria[8]=vec3( 9, 1,0);  //9\ntria[9]=vec3( 1, 1,20);  //10\ntria[10]=vec3( 2, 2,20);  //11\ntria[11]=vec3( 3, 3,20);  //12\ntria[12]=vec3( 4, 4,20);  //13\ntria[13]=vec3( 5, 5,20);  //14\ntria[14]=vec3( 6, 4,20);  //15\ntria[15]=vec3( 7, 3,20);  //16\ntria[16]=vec3( 8, 2,20);  //17\ntria[17]=vec3( 9, 1,20);  //18\n\t\n    \n     for(int j=0;j<18;j++)\n     {\n        tria[j]+= vec3(10.0,0.0,0.0);\n     } \n    \n     for(int j=9;j<18;j++)\n     {\n        tria[j]+= vec3(0.0,0.0,-10.0);\n     } \n    \n    \n    //lado A\n    cout += Line3d(tria[0],tria[1], uv);\n    cout += Line3d(tria[1],tria[2], uv);\n    cout += Line3d(tria[2],tria[3], uv);\n    cout += Line3d(tria[3],tria[4], uv);\n    cout += Line3d(tria[4],tria[5], uv);\n    cout += Line3d(tria[5],tria[6], uv);\n    cout += Line3d(tria[6],tria[7], uv);\n    cout += Line3d(tria[7],tria[8], uv);\n    cout += Line3d(tria[8],tria[0], uv);\n    \n    //lado B\n    cout += Line3d(tria[9],tria[10], uv);\n    cout += Line3d(tria[10],tria[11], uv);\n    cout += Line3d(tria[11],tria[12], uv);\n    cout += Line3d(tria[12],tria[13], uv);\n    cout += Line3d(tria[13],tria[14], uv);\n    cout += Line3d(tria[14],tria[15], uv);\n    cout += Line3d(tria[15],tria[16], uv);\n    cout += Line3d(tria[16],tria[17], uv);\n    cout += Line3d(tria[17],tria[9], uv);\n    \n    //union A y B \n    cout += Line3d(tria[0],tria[9], uv);\n    cout += Line3d(tria[1],tria[10], uv);\n    cout += Line3d(tria[2],tria[11], uv);\n    cout += Line3d(tria[3],tria[12], uv);\n    cout += Line3d(tria[4],tria[13], uv);\n    cout += Line3d(tria[5],tria[14], uv);\n    cout += Line3d(tria[6],tria[15], uv);\n    cout += Line3d(tria[7],tria[16], uv);\n    cout += Line3d(tria[8],tria[17], uv);\n    \n    \n    \n\n    cout *= vec3(0.1,0.8,0.1);\n    \n    fragColor = vec4(cout, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 379, 379, 414], [416, 442, 465, 465, 572], [574, 601, 625, 625, 710], [712, 734, 763, 763, 1200], [1202, 1202, 1222, 1222, 1307], [1309, 1326, 1365, 1365, 1735], [1737, 1737, 1794, 1794, 8580]], "test": "timeout"}
{"id": "tllyzX", "name": "Field of divisors", "author": "brianhaak", "description": "Linear counting has a complex underlying structure, and it explains why prime factorization is so damn hard. A beautiful connection of size and entropy. Infinitesimals should have an insane amount of energy (structure). So they can't exist.", "tags": ["numbers", "field", "linear", "primes"], "likes": 2, "viewed": 203, "published": "Public API", "date": "1592717524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    \n    //fragCoord = floor(fragCoord);// - 0.5);\n    \n    //fragCoord.x *= 0.5 / (log(fragCoord.x) - 1.0); // 0.125;\n    //fragCoord.y *= 0.25;// / (log(fragCoord.y) - 1.0);\n   \n   \n    float zoom = 1.0;//8.0;\n    \n    fragCoord = floor(vec2(fragCoord) / zoom);\n    \n    // float vert_pos = (iResolution.y - (iMouse.y - iMouse.w)) / zoom;\n    \n    // float vert_pos = (iResolution.y - abs(iMouse.w)) / zoom;\n    float vert_pos = (abs(iMouse.w)) / zoom;\n    if (iMouse.y > 0.0) {\n        //vert_pos = (iResolution.y - abs(iMouse.y)) / zoom;\n        vert_pos = (abs(iMouse.y)) / zoom;\n    }\n    \n    vert_pos = floor(vert_pos);\n    \n    float y = fragCoord.y;//iResolution.y - fragCoord.y;\n    \n    //fragCoord = floor(vec2(fragCoord.x, y) / zoom);\n    //fragCoord = floor(fragCoord / zoom);\n    //y = fragCoord.y;\n    \n    \n    //float x = floor(0.5 * fragCoord.x) + 2.0;\n    float x = fragCoord.x + 1.0;\n    \n    if (x == y) {\n        //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    \n   \n    const vec4 rate = vec4(240.0,144.0,120.0,60.0);\n    vec4  d = abs(rate-iFrameRate);\n    float refresh = (d.x<d.y && d.x<d.z && d.x<d.w) ? rate.x:\n                               (d.y<d.z && d.y<d.w) ? rate.y:\n                                          (d.z<d.w) ? rate.z:\n                                                      rate.w;\n    \n    // compute how many frames we should have delivered so far\n    float frame = round(iTime*refresh);\n    \n    \n    // float offset = iTime * 60.0;\n    float speed = 111.0;\n    //float speed = 1.0 / 4.0;\n    float offset = floor(speed * frame);// / speed) * speed;//iTime * 500.0;\n    \n    vec4 mix_mouse = vec4(0.0);\n    \n    if (abs(y - vert_pos) < 0.51) {\n        mix_mouse = vec4(0.5, 0.5, 0.0, 0.0);\n    }\n    \n    //y += offset + 1046527.0;// + 1800.0;\n    y += offset;\n    \n    /*\n    if (x >= y) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    if (x > y) {\n        fragColor = vec4(0.0);\n        return;\n    }*/\n    \n    //if (y - offset == floor(iResolution.y / zoom) - 10.0) { //52.0) {\n    //    fragColor = vec4(1.0);\n    //    return;\n    //}\n    \n    \n   \n    \n    //if (x <= 1.0) {\n    //\tfragColor = vec4(0.0);;//vec4(vec3((1.0 / 256.0) * mod(y, 256.)), 1.0);\n    //    return;\n    //}\n    \n    \n   \n    //float line = mod(y / x, repeat); //* step(remainder, 1.0), 256.0);\n    \n    // float linemix = line;//step(remainder, 1.0);//(mod(remainder, 256.) / 512.0);// * (1.0 / 512.0) * mod(remainder, 256.);\n    \n    //fragColor = vec4(vec3(linemix * remainder * step(remainder, 1.0)), 1.0);\n    \n    //fragColor = vec4(vec3(remainder * step(remainder, 1.0) * (repeat - line) / repeat), 1.0);\n    \n    //fragColor = vec4(vec3(remainder * step(remainder, 1.0) * (1.0 - line / repeat)), 1.0);\n    \n    \n    //fragColor = vec4(vec3(remainder * step(remainder, 1.0)), 1.0);\n    // fragColor = vec4(vec3((y / x) * remainder * step(remainder, 1.0)), 1.0);\n    //fragColor = vec4(vec3((y / x) * remainder), 1.0);\n    \n    //float ratio = (y + 0.125) / (x + 0.125);\n    //float integral_ratio = floor(ratio);\n    float remainder = mod(y + 1.0, x + 0.125); //y - x * integral_ratio;\n    \n    vec4 shade = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    if (mod(y, vert_pos) < 1.0 && abs(y / (vert_pos) - x) < 1.0) {\n        shade = vec4(0.2, 2.0, 0.2, 1.0);\n    }\n    \n   \n    //float remainder = floor(mod(y, x));\n    // fragColor = vec4(vec3(step(remainder, 0.5)), 1.0);\n    //fragColor = (vec4(vec3(step(remainder, 1.0)), 1.0) + mix_mouse) * shade;\n    //fragColor = ((vec4(0.0, 0.0, 0.0, 1.0), 1.0) + mix_mouse) * shade;\n    float value = 0.5 * step(remainder, 1.0);\n    fragColor = (vec4(value, value, value, 1.0) + mix_mouse) + shade;\n    \n    \n    /* Semi-working code\n    float repeat = 3.0;\n    float r = 1.0 - mod(y / x + 2.0, repeat);// / repeat);\n    float g = 1.0 - mod(y / x + 1.0, repeat);// / repeat);\n    float b = 1.0 - mod(y / x, repeat);// / repeat);\n    fragColor = vec4(vec3(remainder * step(remainder, 1.0)), 1.0);\n    fragColor *= vec4(r, g, b, 1.0);\n    */\n    \n    \n    //fragColor *= vec4(vec3(remainder), 1.0);\n    \n    /*float odd_x = mod(x, 2.0);\n    \n    fragColor *= vec4(odd_x, 1.0, 1.0, 1.0);\n    \n    float even_x = mod(x + 1.0, 2.0);\n    \n    fragColor *= vec4(1.0, even_x, 1.0, 1.0);*/\n    \n    if (x >= y && mix_mouse.x < 0.01) {\n        fragColor = vec4(0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 326, 4560]], "test": "timeout"}
{"id": "tlscDH", "name": "Minimal raymarching color 2", "author": "TAKUSAKU", "description": "Minimal raymarching with bit operator coloring", "tags": ["raymarching", "color", "minimal", "bitwise"], "likes": 5, "viewed": 53, "published": "Public", "date": "1592050608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 U )\n{\n    vec3 d=vec3(U/iResolution.xy-.5*sin(iTime)-.5,.5),\n        p=vec3(9.5+1.4*sin(iTime),9.-4.*cos(iTime),iTime+.3),q;\n    for(int i=0;++i<99;i==94?q=p+=d=vec3(.6):q)\n        p+=d*(length(sin(p)+cos(p*.5))-.4);\n    ivec3 u=ivec3(q*5e2);\n    o=vec4(u.y&150,u.x&99,u.z&99,0)/1e3*length(p-q)+(p.z-iTime)*.03;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlscDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 349]], "test": "timeout"}
{"id": "tlscR4", "name": "pv", "author": "rljorge", "description": "pv", "tags": ["test"], "likes": 3, "viewed": 35, "published": "Public", "date": "1591580480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rotation = float(0);\nvec3 color1 = vec3(0.007, 0.341, 0.462);\nvec3 color2 = vec3(0.509, 0.737, 0.074);\nvec3 color3 = vec3(0.011, 0.752, 0.831);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= vec2(0.5);\n    uv *= rotate2d(rotation);\n    uv += vec2(0.5);\n\n    float t = rand(vec2 (1, 0)) + (iTime  + 10.) * 0.1;\n\n    uv *= 0.4;\n\n    vec4 final = vec4(0, 0.341, 0.462, 1);\n\n    float lowBound = 0.5;\n    float highBound = 1.;\n\n    float noise1 = smoothstep(lowBound, highBound, (snoise((uv + vec2(-0.5, 0.) + t)) + 1.) / 2.);\n    final = mix(final, vec4(color1, 1.), noise1);\n\n    float noise2 = smoothstep(lowBound, highBound, (snoise((uv - t * 0.2)) + 1.) / 2.);\n    final = mix(final, vec4(color2, .3), noise2);\n\n    float noise3 = smoothstep(lowBound, highBound, (snoise(uv + t + vec2(-0.3, 0.)) + 1.) / 2.);\n    final = mix(final, vec4(color3, 1.), noise3);\n\n    fragColor = final;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlscR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 171, 171, 243], [245, 245, 273, 273, 359], [361, 361, 382, 382, 431], [433, 433, 454, 454, 503], [505, 505, 527, 527, 564], [566, 566, 590, 590, 2096], [2097, 2097, 2154, 2154, 2909]], "test": "timeout"}
{"id": "tlscW4", "name": "1st 3d", "author": "bipinoli", "description": "Following tutorial from \"The Art of code\"", "tags": ["learningshader"], "likes": 1, "viewed": 26, "published": "Public", "date": "1592133891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float point2rayDist(vec3 ro, vec3 rd, vec3 p) {\n \treturn length(cross(p-ro, rd))/length(rd);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // view plane at z = 0\n    // camera at (x,y,z) = (0,0,-2)\n    \n    // ray\n    vec3 ro = vec3(0., 0., -2.);\n    vec3 rd = vec3(uv.x, uv.y, 0.) - ro;\n    \n    float t = iTime;\n    \n    // point in 3d\n    vec3 p = vec3(cos(t), 0., 2. + sin(t));\n    \n    float d = point2rayDist(ro, rd, p);\n    d = smoothstep(.3, .31, d);\n    \n    vec3 col = vec3(d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlscW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 97], [99, 99, 156, 156, 640]], "test": "timeout"}
{"id": "tlsyD8", "name": "Dodecahedralis V", "author": "sl2c", "description": "Another cohomology fractal on the right-angled dodecahedron.  I made several of these and I'm posting them one at a time even though I'm not equally impressed with them.", "tags": ["fractal", "circles", "hyperbolic"], "likes": 9, "viewed": 96, "published": "Public", "date": "1592328902", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nbool flip(inout vec3 z, in vec2 c, in float r, inout int t, in int k) {\n    z.xy -= c;\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        z *= r * r / dot(z,z);\n        t = k - t;\n    }\n    z.xy += c;\n    return res;\n}\n\nbool inside(in vec3 z, in vec2 c, in float r, inout float t) {\n    vec3 p = z - vec3(c,0.0);\n    float res = (dot(p,p)-r*r) / (2.0 * abs(r) * p.z);\n    t = min(t, abs(res));\n    return res < 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.0 / iResolution.y;\n    vec3 z = vec3(z0,ds);\n    \n    vec2[12] c; float[12] r;\n    float r1 = pow(1.5 + 0.5 * sqrt(5.0) - sqrt(1.5 * sqrt(5.0) + 2.5), 0.5);\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1 * sqrt(sqrt(5.0));\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<5; i++) {\n        float theta = tau * 0.2 * float(i);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+6] = r3;\n        c[i+6] = x3 * eit;\n    }\n    float r4 = -1.0 / r1;\n    r[11] = r4; c[11] = vec2(0.0);\n    \n    float period = -4.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    z *= exp(-d);\n    \n    bool fl = false;\n    float yellow = 0.0;\n    int t = 1;\n    int s = 0;\n    bool fl1 = false; bool fl2 = false; bool fl3 = false;\n    for (int i=0; i<7; i++) {\n        fl = fl ^^ flip(z, c[0], r[0], t, 0);\n        fl = fl ^^ flip(z, c[2], r[2], t, 0);\n        fl = fl ^^ flip(z, c[5], r[5], t, 0);\n        fl = fl ^^ flip(z, c[7], r[7], t, 0);\n        fl = fl ^^ flip(z, c[10], r[10], t, 0);\n        fl = fl ^^ flip(z, c[11], r[11], t, 0);\n        \n        fl1 = fl1 ^^ flip(z, c[1], r[1], s, -1);\n        fl2 = fl2 ^^ flip(z, c[3], r[3], s, 1);\n        fl3 = fl3 ^^ flip(z, c[4], r[4], s, 1);\n        fl1 = fl1 ^^ flip(z, c[6], r[6], s, 1);\n        fl2 = fl2 ^^ flip(z, c[8], r[8], s, -1);\n        fl3 = fl3 ^^ flip(z, c[9], r[9], s, -1);\n    }\n    if (fl1) {s=-s;}\n    if (fl2) {s=-s;}\n    if (fl3) {s=-s;}\n    float st = float(s);\n    \n    st = st / (1.0 + abs(st));\n    vec3 col = vec3(0.5 + st * 0.45); col.g *= 0.8; col.b *= 0.6;\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyD8.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[485, 485, 547, 547, 682]], "test": "timeout"}
{"id": "tlsyRn", "name": "Snakeskin", "author": "yacodes", "description": "Snake-like skin shader", "tags": ["snakeskin"], "likes": 1, "viewed": 186, "published": "Public API", "date": "1591296416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x, 0.0, 0.0, _scale.y);\n}\n\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\nfloat polygon(in vec2 st, in int edges, in float size) {\n    vec2 _st = st * 2. - 1.;\n    float a = atan(_st.x,_st.y)+PI;\n    float r = (PI*2.)/float(edges);\n    float d = cos(floor(0.5+a/r)*r-a)*length(_st);\n\treturn 1.0-smoothstep(size,size+0.01,d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy/iResolution.xy;\n    st.y *= iResolution.y/iResolution.x;\n    vec3 color = vec3(0.);\n    vec2 pos = st.xy*vec2(28.,28.);\n    float pattern = pos.x;\n    pos = rotate2d(noise(pos / 20.) + 5.5 + iTime / 4.) * pos + iTime * 3.;\n    pattern = polygon(fract(pos), 3, noise(pos + iTime) + 0.2);\n    color = mix(color, vec3(0.316,0.635,0.286), pattern * noise(pos * 72.));\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 62, 62, 137], [139, 221, 243, 243, 541], [543, 543, 570, 570, 652], [654, 654, 678, 678, 727], [729, 729, 763, 763, 919], [921, 921, 977, 977, 1173], [1175, 1175, 1230, 1230, 1655]], "test": "timeout"}
{"id": "tlsyWB", "name": "Red Noisy volume, Dark inside", "author": "Leria", "description": "Test for future shader", "tags": ["noise", "sphere", "red", "dark", "bolume"], "likes": 2, "viewed": 229, "published": "Public API", "date": "1593000242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct BlackHole\n{\n    vec3 pos; //position\n    vec3 disk_normal;\n    float mass; //blackhole mass\n    float attraction_radius; //attraction radius of the blackhole\n    float inner_radius; //inner radius\n    float accretion_disk_radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nBlackHole bh;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\n//iq noise\n/*\n\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n*/\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nfloat fbm( vec3 p ) { // in [-1,1]\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.;\n    f += 0.2500*noise( p ); p = p*2.;\n    f += 0.1250*noise( p ); p = p*2.;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_black_hole(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tbh = BlackHole(pos, J, mass, radius, inner_rad, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\n//gravity stuff\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 bh_vec = bh.pos - p;\n    float d = dot(bh_vec,bh_vec);\n    vec3 res = normalize(bh_vec) * (GRAV_CONST*bh.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n\nvoid init_black_hole(void)\n{\n \tset_black_hole(vec3(0., 0., 0.), .12, RADIUS, RADIUS/8., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_black_hole();\n    set_camera(vec3(0., 0., 12), bh.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n/*note:\n\n               if(sdf_cylinder(p-bh.pos, vec3(0., 0., -1.), vec3(0., 0., 1.), \n                        RADIUS) < 0.)\n        {\n            vec4 tex = texture(iChannel0, p/16.+0.05*iTime);\n           \n            t_loc = clamp(   smoothstep(-.5,.5,tex.r)\n                            - smoothstep(2.,.5,length(p)-RADIUS/2.+8.*((2.*fbm(p/8.)-1.))) , 0.,1.);\n            t_gen *= t_loc;\n        }  \n\n*/\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    vec3 c_tmp = vec3(0);\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //p = ( vec4(p, 1.)*ROT(vec3(0., 1., 0.), degree) * cam.view).xyz;\n\n    float perturbation = fbm(p);\n  \tfloat dens = perturbation;\n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    \n    int s = 0;\n    \n    for(s; s < 150; s++)\n    {       \n        //p = (vec4(p, 1.)*vec4(ROT(vec3(0., 1., 0.), degree) * cam.view).xyz;\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(bh.pos-cam.pos);\n        vec3 center = p-bh.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5;\n\n        if(d > -.5)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }\n        \n        float anim_coef = 1.5*cos(0.);\n        //center = (vec4( center, 1.) * ROT(vec3(0., 1., 0.), degree) ).xyz*(vec4( center, 1.) * ROT(vec3(1., 0., 0.), degree2) * cam.view ).xyz ;\n\t\t\n        \n        if(length(center)-RADIUS < 0.)\n        {\n            float anim_coef = 1.5*cos(iTime);\n            \n            #if COLOR           \n            float n = ( abs(fbm(p/8.*anim_coef)));\n            float mask = smoothstep(.2, \n                                     2.*RADIUS+anim_coef, \n                                     (RADIUS-length(center))- 128.*n) ;\n            \n            /*\n\t\n\t\t\t//Avec Bnoise()\n\n            float n = ( (fbm(p/8.*anim_coef)));\n            float mask = smoothstep(.2, \n                                     3.*RADIUS+anim_coef, \n                                     (RADIUS-length(p))- 64.*n) ;\n*/\n            \n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  );\n            \n            vec3 rgb_t = vec3(transp(uniform_step, 4.,  dens), \n                      \ttransp(uniform_step, 16.,dens ),\n              \t      \ttransp(uniform_step, 16., dens));  \n            t_acc *= rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+bh.accretion_disk_radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = t_acc;\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    bh.pos = normalize(vec3(-10, 20., bh.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [{"id": "4sfGRr", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1299, 1299, 1356, 1356, 1525], [1528, 1528, 1554, 1554, 2379], [2436, 2436, 2457, 2470, 2641], [2643, 2662, 2738, 2738, 2785], [2787, 2787, 2819, 2819, 2839], [2841, 2841, 2875, 2875, 2897], [2998, 2998, 3022, 3022, 3182], [3184, 3184, 3208, 3208, 3293], [3295, 3324, 3352, 3352, 3522], [3524, 3546, 3592, 3592, 4215], [4265, 4265, 4306, 4306, 4342], [4344, 4344, 4485, 4485, 4548], [4550, 4550, 4593, 4593, 4633], [4635, 4651, 4712, 4712, 4912], [4914, 4914, 4942, 4942, 5012], [5014, 5014, 5054, 5054, 5358], [5360, 5360, 5384, 5384, 5452], [5454, 5454, 5501, 5501, 5553], [5555, 5555, 5638, 5638, 5777], [5780, 5780, 5833, 5833, 6190], [6601, 6601, 6653, 6653, 9522], [9525, 9525, 9582, 9582, 10192]], "test": "timeout"}
{"id": "tlsyz2", "name": "Hall Of Mirrors v0.3", "author": "_pwd_", "description": "Shiny boxes ...lots of", "tags": ["raymarching", "reflection", "refraction", "cubes"], "likes": 14, "viewed": 239, "published": "Public", "date": "1592554997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Hall Of Mirrors\n// -> adding my 50 cents upon mu6k and XT95 origins by\n//\n//\n// mixing  30 torus by XT95 -> https://www.shadertoy.com/view/3dlcWl\n// with    origin by mu6k -> https://www.shadertoy.com/view/XdfGzS\n//\n\n\n#define object_speed_modifier 1.0\n#define render_steps 64\n#define offset1 4.5\n#define offset2 1.8\n#define att 12.\n\n// helpers\nfloat hash1(float s) { return fract(sin(s)*42422.42); }\nmat2 rot(float v) { float a = cos(v), b = sin(v); return mat2(a,b,-b,a); }\nfloat torus(vec3 p, vec2 q) { return length( vec2(length(p.xz)-q.x,p.y) ) - q.y; } \n\n// global + params\nfloat time;\nfloat id;\nvec3 glow;\nvec3 sync;\n\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat rnd(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n//Smooth min by IQ\nfloat smin( float a, float b )\n{\n    float k = 0.5;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// distance function\nfloat map( vec3 p ) {\n    // rotate the world\n\tp.xz *= rot(time* .1);\n\t//p.xy *= rot(time*.2);\n\n    \n    // small point light on the center\n\tfloat d =  length(p);\n\tglow += vec3(1.) / ( .1 + d*200.);\n    \n\tfloat t = iTime*object_speed_modifier+5.0;\n\tp.x += t;\t\n\tp.z += t*.4;\n\n\tfloat s = length(p);\n\n\tp.y  = abs(p.y);\n\tp.y -= 5.0;\n\t\n    d = 0.5-p.y;\n\t\n\tfor (int i=0; i<15; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\t\n\t\tp+=vec3(1.25-fi,0.0,1.75+fi);\n\t\tvec3 pm;\n\t\t\n\t\tfloat rep = 10.0 + sin(fi*2.0+1.0)*4.0 /* sync.g * 0.00005*/;\n\t\t\n\t\tpm.xz = mod(p.xz+vec2(rep*.5),vec2(rep))-vec2(rep*.5);\n\t\t\n\t\tfloat width  = 1.0  + sin(fi) * .8;\n\t\tfloat height = 2.0  + cos(fi) * 1.2 + ( sync.b * 0.3);\n\t\tfloat offset = -0.5 + cos(fi) * 1.8;\n\n\t\tvec3 df = abs(vec3(pm.x,p.y+1.0/width,pm.z))-vec3(width,height,width);\n\t\tfloat box = max(max(df.x,df.y),df.z);\n        \n\n\t\t//box= length(max(df,0.0)) + min(max(df.x,max(df.y,df.z)),0.0) - 0.095;\n        \n        // we accumulate the lighting here\n    \tfloat intensity = 1. / ( 1. + pow(abs(box*att),1.3));\n    \tif(i == 2 && id == 0.) {\n    \t\tglow += vec3(1.,.3,1.) * intensity;\n    \t} else if(i == 5 && id == 4.) {\n      \t\tglow += vec3(0.,0.,.6) * intensity; \n    \t} else if(i == 7 && id == 1.) {\n      \t\tglow += vec3(1.,1.,.1) * intensity;\n    \t} else if(i == 14 && id == 2.) {\n      \t\tglow += vec3(.1,1.,.1) * intensity;\n    \t} else if(i == 17 && id == 5.) {\n      \t\tglow += vec3(0.16,0.0,0.32) * intensity;            \n    \t} else if(i == 20 && id == 3.) {\n      \t\tglow += vec3(.1,1.,1.) * intensity;\n    \t}\n\n\t\td = min(d,box);\n\t}\n\n\treturn d;    \n    \n    \n}\n\n\nvec3 getNormal(vec3 p) {\n\tvec3 eps=vec3(.1,0,0);\n\treturn normalize(vec3(map(p+eps.xyy),map(p+eps.yxy),map(p+eps.yyx)));\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\n\tacc+=map(p+vec3(-0.5,-0.5,-0.5));\n\tacc+=map(p+vec3(-0.5,-0.5,+0.5));\n\tacc+=map(p+vec3(-0.5,+0.5,-0.5));\n\tacc+=map(p+vec3(-0.5,+0.5,+0.5));\n\tacc+=map(p+vec3(+0.5,-0.5,-0.5));\n\tacc+map(p+vec3(+0.5,-0.5,+0.5));\n\tacc+=map(p+vec3(+0.5,+0.5,-0.5));\n\tacc+=map(p+vec3(+0.5,+0.5,+0.5));\n\treturn acc*.05+.5;\n}\n\nfloat ao1(vec3 p, vec3 n, float d) {\n\n\tfloat s = sign(d);\n\tfloat o = s*.5+.5;\n\tfor (float i = 4.0; i > 0.; --i) {\n\t\to -= (i*d - map(p+n*i*d*s)) / exp2(i);\n\t}\n\treturn o;\n\t\n}\n\n//render background\nvec3 background(vec3 p,vec3 d) {\n\treturn vec3(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime + 10.;\n    \n    // uv stuff\n    vec2 uv = fragCoord/iResolution.xy;\n  \tvec2 v = uv*2.-1.;\n  \tv.x /= iResolution.y / iResolution.x;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    \n    \n    float fft = texture(iChannel0, vec2(.4, .25)).r * 2.; \n\tsync = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n\tid = floor(hash1(floor(iTime*2.*hash(floor(time*.2))))*5.);\n    \n    // ray setup\n  \tvec3 ro = vec3(0.,0.,-4.);\n  \tvec3 rd = normalize(vec3(v, 1.));\n\trd.z -= length(rd)*.54; //lens distort\n    rd = normalize(rd);\n\trd = rotate_x(rd,1.5);\n\trd = rotate_y(rd,mouse.x*9.0+offset2);\n    \n    if( mouse.y != 0. )  rd = rotate_x(rd,mouse.y*9.0+offset1);\n    \n    // raymarching by distance field\n  \tvec3 p = ro + rd ;\n  \tglow   = vec3(.0);\n    \n    float dd;\n    vec3 sp = p;\n    \n  \tfor(int i=0; i<render_steps; i++) {\n        dd = map(p);\n    \tp += dd * rd;\n        if (dd<.001) break;\n  \t}\n\n    vec3 n   = getNormal(p);\n    float a  = ao1(p, n, 0.51);\n    float s  = ao1(p, n, -0.435);\n    vec3 cB  = vec3(a);\n\tfloat ao = amb_occ(p);\n    \n\trd=refract(rd,getNormal(p),1./.87);\n\tp+=rd;\n    \n    float ref=0.;\n    vec3 spec = vec3(0.);\n\tfloat intens=.1;\n\tfor (int i=0; i<render_steps; i++)\n\t{\n        dd = map(p);\n    \tp += dd * rd;\n\t\tif (dd>0.0 && ref>.5) {\n            ref=0.;\n\t\t\tif (dot(rd,n)<-.5) rd=normalize(refract(rd,n,1./.97));\n\t\t\tvec3 refl=reflect(rd,n);\n        }\n \t\tif (dd<0.0 && ref<.05) {\n            ref=1.;\n\t\t\tif (dot(rd,n)<-.05) rd=normalize(refract(rd,n,.97));\n\t\t\tvec3 refl=reflect(rd,n);\n        }       \n\t}    \n     \n    float duration = 15.; \n    float parabola = 0.75;\n    float saw = mod(time/duration,1.);\n\tparabola = 0.8-pow(4.*saw*(1.-saw),2.)*0.6;\n\n    // glow + background + vignetting + gamma correction\n  \tvec3 col = glow * s;\n\tcol *= 0.5;\n  \t\n    col += spec * spec;\n\n \tif (dd>0.1) col = background(sp,rd);\n   \n    col *= pow(uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .8)*2.;\n  \tcol = pow(col,vec3(1./2.2));\n    \n    col += 0.25*(0.5-rnd(uv.xy*time))*parabola;\t\n\n\n  \tfragColor = vec4( mix( col, cB, 0.3 ) * ao, 1. );\n}", "image_inputs": [{"id": "4t2Gz3", "previewfilepath": "https://soundcloud.com/northcape/glasshouse", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/northcape/glasshouse", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[418, 429, 451, 451, 484], [485, 485, 504, 504, 559], [560, 560, 589, 589, 642], [710, 710, 731, 731, 810], [812, 812, 832, 832, 899], [902, 902, 938, 938, 1055], [1057, 1057, 1093, 1093, 1211], [1213, 1232, 1264, 1264, 1372], [1375, 1396, 1417, 1441, 2971], [2974, 2974, 2998, 2998, 3095], [3097, 3097, 3120, 3120, 3438], [3440, 3440, 3476, 3476, 3612], [3614, 3634, 3666, 3666, 3686], [3689, 3689, 3746, 3746, 5815]], "test": "error"}
{"id": "tlsyzS", "name": "prime ring", "author": "inbisibler", "description": "line function tutorial", "tags": ["ring"], "likes": 1, "viewed": 57, "published": "Public", "date": "1592404470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float waveRing(float radius, float width, float num, float time, vec2 pos)\n{\n    radius = radius + 1./(radius*10. +20.)*0.3*sin(5.*time)*sin(num*atan(pos.x,pos.y) + time);\n    float t = width / abs(radius - length(pos));\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy *0.5)/ min(iResolution.x,iResolution.y);\n    \n\n    // Time varying pixel color\n\t// float t = 0.01 / abs(0.2-0.2*fract(5.*(length(uv)+0.01*length(uv)*5.*sin(10.*iTime)*sin(10.*atan(uv.x,uv.y)+iTime))));\n    \n    float t = waveRing(0.2,0.01,11.,7.*iTime,uv);\n    \n    t += waveRing(0.4,0.01,13.,-5.*iTime,uv);\n    t += waveRing(0.6,0.01,17.,3.*iTime,uv);\n    t += waveRing(0.8,0.01,19.,-2.*iTime,uv);\n    \n    // Output to screen\n    fragColor = vec4(vec3(t),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 76, 236], [239, 239, 296, 346, 853]], "test": "timeout"}
{"id": "tlXcDr", "name": "Random Number Towers", "author": "Oggbog", "description": "Random number thingy\nBased on my LED clock https://www.shadertoy.com/view/tllyz7", "tags": ["random"], "likes": 8, "viewed": 263, "published": "Public API", "date": "1591826510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//   Segment numbers\n//   ===============\n//\n//\t\t 0\n//\t\t###\n//\t   #   #\n//\t  1#   #2\n//\t   # 3 #\n//\t\t###\n//\t   #   #\n//\t  4#   #5\n//\t   #   #\n//\t\t###\n//\t\t 6\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n\nfloat segment(vec2 uv,int o){\n    \n    \n    float d = o==1 ? abs(uv.x):abs(uv.y);\n   \n    d = smoothstep(0.11,0.101,d);\n    d *= smoothstep(0.49,0.488,abs(uv.x+uv.y));\n    d *= smoothstep(0.49,0.488,abs(uv.x-uv.y));\n    \n    return d;\n}\n\nfloat digit(vec2 uv,int n){\n    float d = 0.0;\n    float b = 0.2; // brightness\n    uv *= 2.4;\n    // segment 0\n    if(n!=1 && n!=4){\n    \td += segment(uv-vec2(0.0,1.0),0);\n    } else {\n        d += segment(uv-vec2(0.0,1.0),0)*b;\n    }\n    // segment 1\n    if (n!=1 && n!=2 && n!=3 && n!=7){\n    \td += segment(uv-vec2(-0.5,0.5),1);\n    } else {\n        d += segment(uv-vec2(-0.5,0.5),1)*b;\n    }\n    // segment 2\n    if (n!=5 && n!=6){ \n    \td += segment(uv-vec2(0.5),1);\n    } else {\n        d += segment(uv-vec2(0.5),1)*b;\n    }\n    // segment 3\n    if (n!=0 && n!=1 && n!=7){\n    \td += segment(uv,0);\n    } else {\n        d += segment(uv,0)*b;\n    }\n    // segment 4\n    if(n==0 || n==2 || n==6 || n==8){\n    \td += segment(uv-vec2(-0.5),1);\n    } else {\n        d += segment(uv-vec2(-0.5),1)*b;\n    }\n    // segment 5\n    if(n!=2){\n    \td += segment(uv-vec2(0.5,-0.5),1);\n    } else {\n        d += segment(uv-vec2(0.5,-0.5),1)*b;\n    }\n    // segment 6\n    if(n!=1 && n!=4 && n!=7){\n    \td += segment(uv-vec2(0.0,-1.0),0);\n    } else {\n        d += segment(uv-vec2(0.0,-1.0),0)*b;\n    }\n    return d;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates and adjust aspect ratio\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 lv = uv;\n    //uv.y -= iTime/2.;\n    uv.x -= sin(iTime/3.);\n    uv *= 2.; \n    vec2 gv = fract(uv * 5.0)-0.5;\n    vec2 id = floor(uv * 5.0);\n    \n    vec2 id2 = floor(lv * 200.0);\n    \n    float rd = mod(iTime*0.2+hash21(id2),10.0);\n    float d = digit(gv,int(mod(hash21(id)*10.+iTime,10.0)));\n    float e = digit(lv,int(rd));\n    \n    d *= abs(sin(uv.x*1.9)*0.8);\n    \n    vec3 col = vec3(d,0.,d/3.0);\n   \tcol = mix(col,vec3(e,e,e),e);\n\t\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 180, 180, 280], [283, 283, 312, 312, 519], [521, 521, 548, 548, 1626], [1632, 1632, 1689, 1749, 2329]], "test": "timeout"}
{"id": "tlXcR4", "name": "Circle parallax", "author": "Oggbog", "description": "Simple circle parallax scroller", "tags": ["parallax"], "likes": 3, "viewed": 254, "published": "Public API", "date": "1591533622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 luv;\n    vec3 col;\n    float p;\n    fragColor = vec4(0.6,0.8,0.9,1.0);\n    \n    for(float l = 10.0; l > 0.0; l -= 1.0){\n \n    \t\n        \n\t\tluv = vec2(fract( (l*uv.x+ iTime) *2.), l*uv.y);\n        \n        p = luv.y > l - 2.06\n            ? smoothstep(.57,.55, distance(luv, vec2(.5,l-2.06)))\n            : 1.;\n\n       \n        \n        if (p>0.0){\n            col = p*vec3(0.0,1.0-l/10.0,0.1);\n            fragColor = vec4(col,1.0);\n        }\n\n    \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 623]], "test": "timeout"}
{"id": "tlXcRX", "name": "TacGround", "author": "EDragon", "description": "I wanted to replicate a background from a video that had the character \"Tac\" appear in it\n\nI still know almost to nothing about color layering in glsl but somehow I came up with the wonkiest math known to man that *somewhat* did what I wanted", "tags": ["wave", "tac", "notitg"], "likes": 2, "viewed": 92, "published": "Public", "date": "1592588105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //video that inspired me to do this\n    //https://youtu.be/KisZ8PpkXGU\n    \n    \n    \n    //vec2 gl_FragCoord = fragCoord.xy;\n    vec2 resolution = iResolution.xy;\n    float t = iTime;\n    \n    \n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\tvec2 uv2 = gl_FragCoord.xy / resolution.xy;\n\tvec2 uv3 = gl_FragCoord.xy / resolution.xy;\n\tvec2 uv4 = gl_FragCoord.xy / resolution.xy;\n\tvec2 uv5 = gl_FragCoord.xy / resolution.xy;\n\tvec2 uv6 = gl_FragCoord.xy / resolution.xy;\n    vec2 uv7 = gl_FragCoord.xy / resolution.xy; \n    vec2 uv8 = gl_FragCoord.xy / resolution.xy;\n\n    //code for mobile shader complier, don't mind it\n\t/*if (pointerCount > 0){\n\t\tt = time/(time*.25);\n\t}else{\n\t\tt = time;\n\t}*/\n\n\tfloat s = ((iMouse.x-resolution.x/2.)*.01);\n\n\tuv.y += .05*sin(uv.x*20.+(t*s)*2.);\n\tuv2.y += .05*sin((uv.x-3.1415*.25)*20.+(t*s)*2.);\n\tuv3.y += .05*asin(sin((1.25*uv.x-3.1415*.25)*20.+(t*s)*1.5));\n\tuv4.y += .05*asin(sin((1.25*uv.x-3.1415*.5)*20.+(t*s)*1.5));\n\tuv5.y += .05*sin((1.5*uv.x)*20.+(t*s)*1.15);\n\tuv6.y += .05*sin((1.5*uv.x-3.1415*.25)*20.+(t*s)*1.15);\n\tuv7.y += 1.*floor(sin(uv7.x*20.+(t*s)*.25)-.9);\n\tuv8.y += 1.*floor(sin(uv7.x*15.+(t*s)*.3)-.85);\n\n\n\n\t//float wb = smoothstep(.0, .005, .1-uv.y);\n\t//float sb = smoothstep(.0, .005, .15-uv3.y);\n\t//float wt = smoothstep(.0, .005, uv2.y-.9);\n\n\tfloat sb = smoothstep(uv3.y-.2, 0., .0005);\n\tfloat sbb = step(.0, uv3.y-.2);\n\tfloat st = smoothstep(uv4.y+.2, 1., .9995);\n\tfloat stt = step(uv4.y+.2, 1.);\n\n    //idk why this is like this but it is for some reason\n\tfloat wt = smoothstep(uv.y+.1, 1., .998);\n\tfloat wtt = step(uv.y+.1, 1.);\n\tfloat wb = smoothstep(uv2.y-.1, .0, .002);\n\tfloat wbb = step(.0, uv2.y-.1);\n\n\tfloat wt2 = smoothstep(uv5.y+.3, 1., .9995);\n\tfloat wtt2 = step(uv5.y+.3, 1.);\n\tfloat wb2 = smoothstep(uv6.y-.3, .0, .0005);\n\tfloat wbb2 = step(.0, uv6.y-.3);\n    \n\tfloat p1 = step(.0, uv7.y);\n\tfloat p2 = step(.0, uv8.y);\n\n\tfloat w1 = wb*wbb*wt*wtt;\n\tfloat w2 = wb2*wbb2*wt2*wtt2;\n\tfloat s1 = sb*sbb*st*stt;\n\n\n\n\tvec4 col = vec4(1.);\n\tvec4 col2 = vec4(1.);\n\tvec4 col3 = vec4(1.);\n\tvec4 col4 = vec4(1.);\n    vec4 col5 = vec4(1.);\n    vec4 col6 = vec4(1.);\n\n\t//float cl = (sb+(sb-wb));\n\n\tcol = vec4(1.-w1);\n\tcol2 = vec4(1.-s1);\n\tcol3 = vec4(1.-w2);\n\tcol4 = vec4(1.-0.);\n    col5 = vec4(1.-p1);\n    col6 = vec4(1.-p2);\n\t//col *= cl;\n\t//col2 *= sb;\n    \n    //colors are getting manipulated by other cols and it messed up  my head\n\n\tcol *= vec4(.0, .2, .5, 1.);\n\tcol2 *= vec4(.1, .35, .35, 1.);\n\tcol3 *= vec4(.5, .4, .15, 1.);\n\tcol4 *= vec4(.45, .25, .0, 1.);\n\tcol5 *= vec4(.8, .2, .0, 1.);\n\tcol6 *= vec4(.8, .2, .0, 1.);\n\n\t//idk what I did but it works god dammit\n\n\n\tcol2 *= col.a-.999;\n\tcol2 *= col.a-2.;\n\tcol5 *= col2-.1;\t//???????????????\n\tcol5 *= col2-1.;\t//WHAT\n\tcol6 *= col5.a-.999;\n\tcol6 *= col5.a-.2;\n\tcol6 *= col3.a-.999;//WHY\n\tcol6 *= col3.a-2.;\t//THIS MAKES NO SENSE TO ME\n\tcol3 *= col2.a-.999;\n\tcol3 *= col2.a-2.;\n\tcol4 *= col3.a-.999;\n\tcol4 *= col3.a-2.;\n\tcol5 *= col3.a-.999;\n\tcol5 *= col3.a-2.;\n\tcol5 *= col4.a-.999;\n\tcol5 *= col4.a-2.;\n\tcol6 *= col5.a-.999;\n\tcol6 *= col5.a-2.;\n\n    fragColor = vec4 (col+col2+col3+col4+col5+col6);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 192, 3174]], "test": "timeout"}
{"id": "tlXcWM", "name": "Hydrangea", "author": "gaz", "description": "// https://twitter.com/gaziya5/status/1272309104376074240", "tags": ["2tweets"], "likes": 11, "viewed": 139, "published": "Public", "date": "1592193596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n    vec3 p=vec3(C,iTime*9.+C.x*.5),\n    a=vec3(-1,1,0);\n    p.y+=iTime*40.;\n\tint n=int(iTime*500.)+abs(int(dot(p,a.yyy))^int(dot(p,a.xyx))^int(dot(p,a.zxy))^int(dot(p,a.zxx)));\n    O.xyz+=(cos(p/80.)*.5+.5)*200./float(n%999);\n}\n\n/*\n#define mainImage(O,C){\\\n    vec3 p=vec3((300.*C.xy/iResolution.y),iTime*9.+C.x*.5),\\\n    a=vec3(-1,1,0);\\\n    p.y+=iTime*40.;\\\n\tint n=int(iTime*500.)+abs(int(dot(p,a.yyy))^int(dot(p,a.xyx))^int(dot(p,a.zxy))^int(dot(p,a.zxx)));\\\n\tO.xyz+=(cos(p/80.)*.5+.5)*200./float(n%999);\\\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 264]], "test": "timeout"}
{"id": "tlXczH", "name": "Rhombus Skyhigh", "author": "darkfox", "description": "colorful rhombus and cloudy background.", "tags": ["fbm", "polygon"], "likes": 3, "viewed": 67, "published": "Public", "date": "1591407017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// constant.\nconst float pi = 3.14159;\n// palette.\nconst vec3 skyblue = vec3(0.1, 0.65, 0.9);\nconst vec3 red = vec3(0.95, 0.3, 0.35);\nconst vec3 green = vec3(0.3, 0.9, 0.4);\nconst vec3 blue = vec3(0.2, 0.25, 0.98);\nconst vec3 orange = vec3(0.98, 0.49, 0.13);\nconst vec3 lightgreen = vec3(0.7, 0.9, 0.1);\nconst vec3 aquagray = vec3(0.38, 0.65, 0.78);\n// pattern data.\nconst float SCALE = 8.0;\nconst float SPEED = 1.0;\n// e1, e2, mat.\nconst vec2 e1 = vec2(0.86601, 0.5);\nconst vec2 e2 = vec2(-0.86601, 0.5);\nconst mat2 getPtn = mat2(0.33333, -0.33333, 0.57735, 0.57735);\nconst mat2 rot120 = mat2(-0.5, 0.86601, -0.86601, -0.5);\n// for noise.\nconst vec2 u_10 = vec2(1.0, 0.0);\nconst vec2 u_01 = vec2(0.0, 1.0);\nconst vec2 u_11 = vec2(1.0, 1.0);\nconst vec2 r_vector = vec2(12.9898, 78.233);\nconst vec3 r_vec_30 = vec3(127.1, 311.7, 251.9);\nconst vec3 r_vec_31 = vec3(269.5, 183.3, 314.3);\nconst vec3 r_vec_32 = vec3(419.2, 371.9, 218.4);\nconst vec3 u_100 = vec3(1.0, 0.0, 0.0);\nconst vec3 u_010 = vec3(0.0, 1.0, 0.0);\nconst vec3 u_001 = vec3(0.0, 0.0, 1.0);\nconst vec3 u_110 = vec3(1.0, 1.0, 0.0);\nconst vec3 u_101 = vec3(1.0, 0.0, 1.0);\nconst vec3 u_011 = vec3(0.0, 1.0, 1.0);\nconst vec3 u_111 = vec3(1.0, 1.0, 1.0);\nconst float r_coeff = 43758.5453123;\nconst int octaves = 6;\n// random.\nfloat random(vec2 st){\n  return fract(sin(dot(st.xy, r_vector)) * r_coeff);\n}\n// 3D random vector.(-1.0～1.0)\nvec3 random3(vec3 st){\n  vec3 v;\n  v.x = sin(dot(st, r_vec_30)) * r_coeff;\n  v.y = sin(dot(st, r_vec_31)) * r_coeff;\n  v.z = sin(dot(st, r_vec_32)) * r_coeff;\n  return -1.0 + 2.0 * fract(v); // -1.0～1.0.\n}\n// simplex noise.\nfloat snoise3(vec3 st){\n  vec3 p = st + (st.x + st.y + st.z) / 3.0;\n  vec3 f = fract(p);\n  vec3 i = floor(p);\n  vec3 g0, g1, g2, g3;\n  vec4 wt;\n  g0 = i;\n  g3 = i + u_111;\n  if(f.x >= f.y && f.x >= f.z){\n    g1 = i + u_100;\n    g2 = i + (f.y >= f.z ? u_110 : u_101);\n    wt = (f.y >= f.z ? vec4(1.0 - f.x, f.x - f.y, f.y - f.z, f.z) : vec4(1.0 - f.x, f.x - f.z, f.z - f.y, f.y));\n  }else if(f.y >= f.x && f.y >= f.z){\n    g1 = i + u_010;\n    g2 = i + (f.x >= f.z ? u_110 : u_011);\n    wt = (f.x >= f.z ? vec4(1.0 - f.y, f.y - f.x, f.x - f.z, f.z) : vec4(1.0 - f.y, f.y - f.z, f.z - f.x, f.x));\n  }else{\n    g1 = i + u_001;\n    g2 = i + (f.x >= f.y ? u_101 : u_011);\n    wt = (f.x >= f.y ? vec4(1.0 - f.z, f.z - f.x, f.x - f.y, f.y) : vec4(1.0 - f.z, f.z - f.y, f.y - f.x, f.x));\n  }\n  float value = 0.0;\n  wt = wt * wt * wt * (wt * (wt * 6.0 - 15.0) + 10.0);\n  value += wt.x * dot(p - g0, random3(g0));\n  value += wt.y * dot(p - g1, random3(g1));\n  value += wt.z * dot(p - g2, random3(g2));\n  value += wt.w * dot(p - g3, random3(g3));\n  return value;\n}\n// fbm.\nfloat fbm(vec3 st){\n  float value = 0.0;\n  float amplitude = 0.5;\n  for(int i = 0; i < octaves; i++){\n    value += amplitude * snoise3(st);\n    st *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n// backgroundColor. (clouds)\nvoid setBackgroundColor(in vec2 p, inout vec3 col){\n  float n = 0.5 + 0.5 * fbm(vec3(p + e1 * iTime * SPEED * 0.3, iTime * SPEED * 0.1));\n  col = skyblue + (vec3(0.9) - skyblue) * smoothstep(0.44, 0.56, n);\n}\n// pattern.\nvoid setPattern(in vec2 p, inout vec3 col, vec3 ptnColor1, vec3 ptnColor2){\n  p.x -= iTime * SPEED;\n  p *= SCALE;\n  vec2 q = getPtn * p;\n  vec2 f = fract(q);\n  vec2 i = floor(q);\n  if(mod((i.x - 1.0) * (i.y - 1.0), 2.0) == 0.0){ return; }\n  float rnd = random(i);\n  if(rnd < 0.4){ return; }\n  // move f to center, normalize.\n  f = 2.0 * (f - vec2(0.5));\n  // stretch factor.\n  float factor = sin(iTime * 6.0 + rnd * 2.0 * pi);\n  // stretch length.\n  float l = rnd * factor * 0.5;\n  // coeff of line equation.\n  vec2 k = vec2(l, abs(2.0 * abs(l) - 1.0)) / (1.0 - abs(l));\n  if(abs(f.x - k.x * f.y) > k.y || abs(f.y - k.x * f.x) > k.y){ return; }\n  float d = max(abs(f.x - k.x * f.y), abs(f.y - k.x * f.x)) / k.y;\n  d = d * d * (3.0 - 2.0 * d);\n  col = (ptnColor1 + (ptnColor2 - ptnColor1) * step(0.7, rnd)) * d;\n  col = mix(col, vec3(1.0), 0.5 * abs(factor));\n}\n// mainCode.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 col;\n  setBackgroundColor(p, col);\n  setPattern(p, col, red, orange);\n  p = rot120 * p;\n  setPattern(p, col, blue, aquagray);\n  p = rot120 * p;\n  setPattern(p, col, green, lightgreen);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1274, 1285, 1307, 1307, 1362], [1363, 1396, 1418, 1418, 1603], [1604, 1622, 1645, 1645, 2674], [2675, 2683, 2702, 2702, 2881], [2882, 2911, 2962, 2962, 3119], [3120, 3132, 3207, 3207, 3992], [3993, 4006, 4060, 4060, 4370]], "test": "timeout"}
{"id": "tlXyR4", "name": "L-tree", "author": "Yasik", "description": "3d l-sys", "tags": ["3dlsys"], "likes": 9, "viewed": 132, "published": "Public", "date": "1591529165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAT_PLANE 7.     \n#define MAT_TREE  5.\n// Uncomment to visualize the bounding volumes.\n//#define DEBUG\n\n//--------------------------------------------------------------------------\nmat4 Ry (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, 0, -s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Rz (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Disp (vec3 displacement)\n{\nreturn  mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(displacement, 1)\n); \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n//--------------------------------------------------------------------------\n\nvec2 opU( float d1, float d2, float m1, float m2 )\n{\n    return (d1<d2) ? vec2(d1, m1) : vec2(d2, m2);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  p -= vec3(0.,h.y, 0);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p )\n{ \n\treturn p.y;\n}\n//--------------------------------------------------------------------------\nfloat c_t(vec3 pt, float x1, float x2, float x3)\n{    \n    mat4 posR = Rz(-(25.7/360.)*2.*PI);\n    mat4 negR = Rz(25.7/360.*2.*PI);\n    mat4 bendP = Ry(25.7/360.*2.*PI);\n    mat4 bendR = Ry(-25.7/360.*2.*PI);\n    \n    const int depth = 7;\n    const int branches = 3; \n    float len = 1.5;\n    float wid = .05;\n    float widf= .9;\n    \n    float trunk = sdCappedCylinder(pt-vec3(0.,0., 0.), vec2(wid,len));\n    float d = trunk;\n    float x = sdSphere((Disp(vec3(0.,-2.5*len,0.))*vec4(pt, 1.)).xyz,1.8*len);\n    if (x > 2.*len/2.) return min(x,d);\n\n    vec3 pt_n = pt;\n      for (int i = 1; i <= depth; ++i)\n      {\n        wid *= widf;\n        float l = len*pow(.5,float(i));\n       \n        mat4 mx1 = Rz(-0.2*sin(iTime+6.2))*posR*bendP*Disp(vec3(0,-2.*l - l/2.,0));\n\n        mat4 wind = Rz(0.2*sin(iTime+6.2));\n        mat4 mx2 = wind*negR*bendP*Disp(vec3(0,-2.*l,0));\n\n        wind = Rz(0.2*sin(iTime+1.));\n        mat4 mx3 = wind*Disp(vec3(0,-4.*l,0)) ;\n        \n        vec3 pt_1 = (mx1 * vec4(pt_n,1)).xyz;\n        vec3 pt_2 = (mx2 * vec4(pt_n,1)).xyz;\n        vec3 pt_3 = (mx3 * vec4(pt_n,1)).xyz;\n          \n        // bounding sphere test\n        float z1 = sdSphere((Disp(vec3(0.,-x1*l,0.))*vec4(pt_1, 1.)).xyz,2.5*l);\n        float z2 = sdSphere((Disp(vec3(0.,-x2*l,0.))*vec4(pt_2, 1.)).xyz,2.5*l);\n        float z3 = sdSphere((Disp(vec3(0.,-x3*l,0.))*vec4(pt_3, 1.)).xyz,2.5*l);\n          \n        // potential cylinders\n        float y1= sdCappedCylinder(pt_1, vec2(wid,l));\n        float y2= sdCappedCylinder(pt_2, vec2(wid,l));\n        float y3= sdCappedCylinder(pt_3, vec2(wid,l));\n\n        // calc closest\n        float mi = min(z1, min(z2,z3));\n          \n        vec3 pt = (z1<z2) ? pt_1 : pt_2;\n        pt_n = (min(z1,z2)<z3) ? pt   : pt_3;\n\n        d = min( d, min(y1,min(y2,y3)) );\n        float epsilon = .5;\n        #ifdef DEBUG\n        epsilon = .0;\n        #endif\n        if (mi < epsilon) {continue;} \n          //break;\n          return min(mi,d);\n     }\n   return d; \n    \n}\n\n// Any system of bounding spheres will capture some pieces\n// and miss others due to confusion at the overlap of two spheres. \n// So we throw a few different\n// systems at the tree and take the best estimate.\nfloat c(vec3 pt)\n{\n    // I culled some bounding volumes for speed leading to small artifacts.\n    float y1 = c_t(pt, 3., 3., 2.);\n    //float y4 = c_t(pt, 2., 3., 3.);\n    //float y = min(y4,y1);\n    return y1;\n}\n\n// Returns distance_to_shape, material index\nvec2 scene(vec3 ray)  \n{\n    vec2 objs = opU(c(ray), sdPlane(ray), MAT_TREE, MAT_PLANE);\n    return objs ;\n}\n\n//iq's softshadow\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.01 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec2 trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    float tmax = 21.0;\n    float tmin = .1;\n    float m = 0.0;\n    for (int i = 0; i < 70; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* ray);\n        vec2 data = scene(p);\n        float dist = data.x;\n        m  = data.y;\n        t += dist;//;*.5;//;// * .9;\n        \n        if ( (t > tmax) || ((t < tmin) && (t > 0.))){\n            break;\n        }\n    }\n    if( t>tmax ) m=-1.0;\n    return vec2(t, m);\t\t\t\t\t\t\n}\n\n// iq normal\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\n// Stolen from ming's tutorial.\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.1;\n\tfloat vis = softshadow( pos, toLight, 0.02, 2.5 );\n\t//float vis = 1.;//shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tcomb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\n// Given distance to shape, material index, world coord, and pixel, color.\nvec4 color (float t, float m, vec3 p)\n{\n\n    vec4 col = vec4(0.0);\n    float f = mod( floor(p.z) + floor(p.x), 2.0);\n    \n    if (abs(p.x) > 10. || abs(p.z) > 10.) {\n        return vec4(0.);\n    }\n    else if (abs(m -MAT_TREE) < .001) {\n         vec4 brown = vec4(.8, .6, .45, 1.);\n         vec4 green = vec4(.125,.49,.22,1.);\n         col = mix(brown,green,p.y/10.);\n         //col = vec4(.8, .6, .45, 1.);\n         //return col;\n    }else if( abs(m -MAT_PLANE) < .001 ){\n         \n         col = vec4( 0.8 + 0.1*f*vec3(1.0), 1.);\n    } \n    vec3 nrm = calcNormal(p);\n    vec4 light1 = vec4(2., 8., 2.,   10.0 );\n    vec4 light2 = vec4(-2., 8., -2., 10.0 );\n    vec3 cc  = shade(p,nrm,light1);\n    vec3 cc1 = shade(p,nrm,light2);\n    \n    return (cc.x+cc1.x)*col;\n}\n\n// returns pixel color\nvec4 render(vec3 ray, vec3 pt)\n{\n    vec2 tm    = trace(ray, pt);\n    float t    = tm.x;\n    float mat  = tm.y;\n    vec3 point = pt + (t* ray);\n    return color(t, mat, point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float f = 3.; // f-stop.\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    vec3 position = vec3(cos(iMouse.x/100. - .8)*10., 3., sin(iMouse.y/100.-.3)*10.);\n    \n    mat4 mat = LookAtRH(position, vec3(0,3,0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(mat*(pixel - vec4(0,0,-f,1))).xyz;\n    \n    fragColor   = render(ray, pt);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 211, 234, 234, 415], [417, 417, 440, 440, 621], [623, 623, 654, 654, 782], [784, 784, 819, 819, 845], [924, 924, 976, 976, 1028], [1030, 1030, 1072, 1072, 1195], [1197, 1197, 1222, 1222, 1238], [1239, 1316, 1366, 1366, 3318], [3320, 3529, 3547, 3623, 3742], [3744, 3789, 3813, 3813, 3897], [3899, 3917, 3991, 3991, 4253], [4255, 4255, 4298, 4298, 4752], [4754, 4767, 4799, 4799, 5032], [5034, 5104, 5153, 5153, 5531], [5533, 5565, 5611, 5611, 6078], [6080, 6155, 6194, 6194, 6921], [6923, 6946, 6978, 6978, 7124], [7126, 7126, 7183, 7183, 7692]], "test": "timeout"}
{"id": "tlXyRH", "name": "Cool velocimeter", "author": "makaronsito", "description": "Gas gas gas", "tags": ["procedural"], "likes": 3, "viewed": 217, "published": "Public API", "date": "1591392360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MAX_VEL = 20.;\nconst float MIN_ANGLE = -36.;\nconst float MAX_ANGLE = 120.;\nconst float GROSOR_AGUJA = .1; //porcentaje\nconst float LARGO_AGUJA = .5; //porcentaje\nconst float LARGO_MARCA = .12; //porcentaje\nconst float GROSOR_MARCA = 1.5; //en grados\nconst float ANG_ESP_MARCA = 12.; //en grados\nconst float GROSOR_CIRC = .02; //porcentaje\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float vel = abs(sin(iTime/20.)) * MAX_VEL;\n    \n\tvec3 col = vec3(-1);\n\tvec2 centerUV = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tfloat velCoef = vel/MAX_VEL;\n\tfloat angle = mix(MIN_ANGLE, MAX_ANGLE, velCoef) + sin(iTime * velCoef * 90.) * velCoef * 3.;\n\tfloat uvDisp = length(centerUV);\n\t\n\t//crea un círculo rojo que delimita la zona en que la aguja gira\n\tif (uvDisp > GROSOR_AGUJA * 1.2 && uvDisp < GROSOR_CIRC + GROSOR_AGUJA * 1.2)\n\t\tcol = vec3(0.1,-1,-1);\n\t\t\n\t//solo renderizamos la parte de la línea que \"se mueve en la dirección adecuada\" creando la ilusión de una aguja\n\tvec2 dir = vec2(cos(radians(angle)), sin(radians(angle)));\n\tfloat dirCos = (centerUV.x*dir.x+centerUV.y*dir.y)/(length(centerUV)*length(dir));\n\tif (length(centerUV) < GROSOR_AGUJA || dirCos > 0.) {\n\t\t//ecuación distancia punto-recta\n\t\tfloat dist = abs(centerUV.y*dir.x - centerUV.x*dir.y) / length(dir);\n\t\tif (dist < GROSOR_AGUJA/2.){\n\t\t\tfloat centerDistCoef = clamp(1.-uvDisp/LARGO_AGUJA,0.,1.);\n\t\t\tfloat lineDistCoef = (GROSOR_AGUJA/2.)/dist-1.;\n\t\t\tcol = vec3(clamp(lineDistCoef * centerDistCoef, 0., 1.),-1.,-1.);\n\t\t}\n\t}\n\t\n\t//ángulo del UV, de 0 a 360\n\tfloat aUV = degrees(atan(centerUV.y/centerUV.x));\n    if (centerUV.x < 0.)\n        aUV += 180.;\n\t\n\t//si nos encontramos en la franja donde debe haber marcas\n\tif (uvDisp > LARGO_AGUJA - LARGO_MARCA && uvDisp < LARGO_AGUJA){\n\t\tif (uvDisp > LARGO_AGUJA-LARGO_MARCA/2. && uvDisp < LARGO_AGUJA + GROSOR_CIRC - LARGO_MARCA/2.)\n\t\t\tcol = vec3(0.1);//asignar color gris al círculo delimitador\n\t\tif (mod(aUV, ANG_ESP_MARCA) < GROSOR_MARCA && aUV < MAX_ANGLE + GROSOR_MARCA && aUV > MIN_ANGLE){ //marcas de velocidad\n\t\t\tif (aUV < 0.)//asignamos el color a cada marca según el ángulo de la línea que siga\n\t\t\t\tcol = vec3(0.3, 0, 1);\n\t\t\telse if (aUV < 90.)\n\t\t\t\tcol = vec3(0, 1, 0.3);\n\t\t\telse\n\t\t\t\tcol = vec3(1, 1, 0.);\n\t\t}\n\t}\n\t\t\n\tfragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 352, 407, 407, 2305]], "test": "timeout"}
{"id": "tlXyRS", "name": "BRDF Boze", "author": "kaiware007", "description": "Reference BRDF code\nhttps://www.shadertoy.com/view/XlKSDR", "tags": ["raymarching", "brdf"], "likes": 1, "viewed": 69, "published": "Public", "date": "1592403988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG1 6.0\n#define MAT_BG2 7.0\n#define MAT_CS 8.0\n\n#define AA 1\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0 / sc);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05, 0.02 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    //return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n    return sdRoundBox(p + vec3(0.03, -0.14,-0.1) * sc, vec3(0.0175,0.0025,0.1) * sc, 0.001);\n}\n\nvec2 sdBoze(vec3 p, float sc, float ms)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    //eye.x = opUnion(d9, d10);\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(0.);\n    p = rotate(p, M_PI, vec3(0,1,0));\n    //p = rotate(p, iTime, vec3(0,1,0));\n    //p = rotate(p, iTime, vec3(1,0,0));\n    result = sdBoze(p, 1.0, 1.0);\n    //result = sdBoze(p, (sin(iTime) * 0.5 + 0.5) * 1.5);\n    \n    // background\n    vec2 bg1 = vec2(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)), MAT_BG1);\n    \n    vec3 q = opRep(p, vec3(0.5));\n    q = TwistY(q, 2.*M_PI2);\n    q = rotate(q, iTime*M_PI, vec3(0,1,0));\n    q += vec3(0.01,0,0.01);\n    float w = 0.025;\n    vec2 bg2 = vec2(sdRoundBox(q, vec3(w,0.5,w), 0.01), MAT_BG2);\n    \n    result = opU(result, opSU(bg1, bg2, 0.2));\n    //result = opU(bg1, result);\n    //result = opSU(bg1, result, sin(iTime)*0.01+0.01);\n    //result = opU(bg2, result);\n    //result = opSU(bg2, result, sin(iTime)*0.1+0.1);\n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).x - map(position - epsilon.xyy).x,\n          map(position + epsilon.yxy).x - map(position - epsilon.yxy).x,\n          map(position + epsilon.yyx).x - map(position - epsilon.yyx).x);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).x;\n        if (h < 0.0001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = 0.0;\n\n    float t = 0.02;\n    \n    vec3 pos;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = origin + direction * t;\n        vec2 hit = map(pos);\n\n        float d = hit.x * 0.5;\n        t += d;\n        material = hit.y;\n\n        if (d <= 0.00001 ) {\n        \tbreak;\n        }\n\n        \n    }\n    if (t >= MAX_DIST) {\n        t = MAX_DIST;\n        material = 0.0;        \n    }\n    return vec2(t, material);\n}\n\nvec3 materialColor(vec3 pos, vec2 mat, out float roughness, out float metalness)\n{\n    vec3 col = vec3(0);\n    \n    //float t = saturate(sin(iTime * 2.5)*0.25+0.25);\n    float m = 0.1;\n    //float r = mix(0.00001, 1., sin(iTime * 5.)*0.5+0.5);\n    float r = 0.1;\n\tif(mat.y == MAT_BLACK) {\n        col = vec3(0.1);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_FACE) {\n        col = vec3(1.0, 0.8, 0.45);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_BROW) {\n        col = vec3(1.0, 0, 0.1);\n        roughness = r;\n        metalness = m*0.1;\n    } else if(mat.y == MAT_CHEEP) {\n        col = vec3(1.0, 0.3, 0.5);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_BG1) {\n        vec3 index = floor(pos * 10.+ 0.5);\n\n        float f = noise(index + iTime * 2.8);\n        col = mix(vec3(1), vec3(0), f);\n        //col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.001;\n        metalness = 0.8;\n    } else if(mat.y == MAT_BG2) {\n        vec3 index = floor(pos * 50.+ 0.5);\n\t\tfloat f = noise(index + iTime * vec3(2.8,-0.8,0.79));\n        col = sinebow(f);\n        //col = vec3(1.0,0,0) + vec3(-1,0,1) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.001;\n        metalness = 0.8;\n    }\n    return col;\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightDir, vec3 lightColor, vec3 baseColor, float roughness, float metallic) {\n    vec3 color = vec3(0);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    vec3 r = normalize(reflect(rayDir, normal));\n\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    \n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n \t\n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec2 indirectHit = traceRay(pos, r);\n    vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n    \n    if (indirectHit.y > 0.0) {\n        vec3 indirectPosition = pos + indirectHit.x * r;        \n\t\tfloat reflength = length(indirectPosition - pos);\n        \n        float roughness, metalness;\n        indirectSpecular = materialColor(indirectPosition, indirectHit, roughness, metalness);\n\n        vec3 sky = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        // fog\n        indirectSpecular = mix(indirectSpecular, 0.8 * sky, 1.0 - saturate(exp2(-0.1 * reflength * reflength)));\n    }\n\t\n    // indirect contribution\n    vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n    vec3 specularColor = f0 * dfg.x + dfg.y;\n    vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\t\n    color += ibl * indirectIntensity;\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.65, 0.85, 1.0);\n    //vec3 sky = vec3(0);\n    vec3 sky = vec3(0.65, 0.85, 1.0) + ray.y * 0.72;\n    //vec3 sky = vec3(1);\n    if (depth >= MAX_DIST) {\n        col = sky;\n    } else {\n        if(mat.y > 0.0)\n        {\n            vec3 nor = norm(p);            \n            float roughness, metalness;\n            col = materialColor(p, mat, roughness, metalness);\n\n            vec3 result = vec3(0.);\n            //result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n            result = calcAmb(p, ray, nor, normalize(vec3(0.6, 0.8, -0.7)), vec3(0.98, 0.92, 0.89) * 3.0, col, roughness, metalness);\n            col = result;\n        }\n    }\n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n    // Exponential distance fog\n    col = mix(col, 0.8 * sky, 1.0 - saturate(exp2(-0.1 * depth * depth)));\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray)\n{\n    vec3 pos;\n    vec2 mat = traceRay(p, ray);\n    \n    p = p + mat.x * ray;\n    return materialize(p, ray, mat.x, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float t = iTime * M_PI * 0.2;\n        float y = sin(t * 2.5) * 0.25;\n        float r = 1. + sin(t * 0.5)*0.5;\n        float theta = t + RAD90 + RAD90*0.25;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        vec3 ro = vec3(cos(theta) * r, 0.24 + y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0.05, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray);\n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[694, 694, 717, 717, 790], [792, 792, 813, 813, 883], [885, 885, 908, 908, 987], [990, 990, 1012, 1012, 1429], [1432, 1531, 1577, 1577, 1633], [1635, 1635, 1685, 1685, 1803], [1805, 1805, 1842, 1842, 1931], [1933, 1933, 2003, 2003, 2137], [2139, 2139, 2203, 2203, 2320], [2322, 2322, 2355, 2381, 2412], [2414, 2471, 2499, 2499, 2532], [2534, 2534, 2564, 2564, 2616], [2618, 2618, 2658, 2658, 2794], [2796, 2847, 2884, 2884, 2906], [2908, 2908, 2951, 2951, 2973], [2975, 2975, 3019, 3019, 3040], [3042, 3042, 3094, 3094, 3193], [3196, 3196, 3241, 3241, 3670], [3673, 3673, 3708, 3708, 3856], [3858, 3858, 3892, 3892, 4068], [4070, 4070, 4101, 4101, 4150], [4152, 4152, 4187, 4187, 4222], [4224, 4224, 4261, 4261, 4296], [4298, 4469, 4554, 4554, 4631], [4633, 4676, 4751, 4751, 5143], [5400, 5400, 5443, 5443, 5614], [5640, 5640, 5672, 5672, 5785], [5787, 5787, 5830, 5830, 6061], [6063, 6063, 6108, 6108, 6709], [6711, 6711, 6758, 6758, 7025], [7027, 7027, 7068, 7068, 8323], [8543, 8543, 8561, 8561, 9374], [9876, 9876, 9925, 9925, 10223], [10226, 10226, 10276, 10276, 10714], [10716, 10716, 10798, 10798, 12087], [12260, 12260, 12281, 12281, 12329], [12331, 12331, 12392, 12477, 12676], [12678, 12678, 12751, 12843, 13043], [13045, 13045, 13087, 13167, 13221], [13223, 13223, 13272, 13272, 13320], [13322, 13322, 13395, 13452, 13667], [13669, 13669, 13689, 13689, 13714], [13901, 13901, 13951, 14035, 14393], [14395, 14395, 14450, 14507, 14767], [14769, 14769, 14900, 14900, 16866], [17070, 17070, 17103, 17159, 17345], [17347, 17347, 17386, 17386, 17429], [17431, 17447, 17520, 17520, 17604], [17606, 17732, 17802, 17802, 18085], [18087, 18087, 18187, 18187, 18977], [18980, 18980, 19039, 19039, 19957], [19959, 19959, 19990, 19990, 20113], [20115, 20115, 20157, 20157, 20335]], "test": "timeout"}
{"id": "tlXyRX", "name": "RainbowCircles_veryUnoptimized", "author": "Mukul", "description": "Just something I felt is interesting which came out of me practicing glsl fragment shaders.", "tags": ["circle", "rainbow", "concentric", "polarform"], "likes": 1, "viewed": 75, "published": "Public", "date": "1592586369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\nconst float twoPI = 2.0*PI;//6.28318\n\nconst float PIbyThree = PI/3.0;\nconst float twoPIbyThree = twoPI/3.0;\nconst float fourPIbyThree = 4.0*PI/3.0;\nconst float fivePIbyThree = 5.0*PI/3.0;\n\nfloat diatance(vec2 p1, vec2 p2){\n    return (\n        sqrt(\n            pow((p2.y - p1.y),2.0) + pow((p2.x - p1.x),2.0)\n    ));\n}\n\n//Translating Points at an angle w.r.t center point using polar form of a straight line in 2D geometry\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 FragCoord = fragCoord.xy;\n    vec2 res = iResolution.xy;\n    float diagonal = distance(vec2(0.0,0.0),res);\n    vec2 center = vec2(res.x/2.0,res.y/2.0);\n\tcenter.x += res.x * 5.4 * sin(iTime/3.0);center.y += res.y * 5.4 * cos(iTime/3.0);\t//--rotating the center\n    float \tdist = distance (FragCoord,center),\n        \tR=0.0,G=0.0,B=0.0,tmp, grad1, grad2;\t\t\t\t\t\t\t\t\t\t\t\n    float angle = atan((FragCoord.y - center.y) , (FragCoord.x - center.x));\n        \n    angle = mod((angle + iTime),twoPI);\t//--small increment to angle to show animation, negate addition to\n    \t\t\t\t\t\t\t\t\t\t\t//  rotate counter Clockwise\n    //**new method using smoothstep, I tried pls point out anything bad.\n    R = (angle <= twoPIbyThree && angle >= 0.0)? 1.0 : 0.0;\n    R += smoothstep(fivePIbyThree, twoPI, angle);\n    tmp = ( smoothstep(twoPIbyThree, PI, angle)); \n    R += (((tmp < 1.0 && tmp > 0.0) && R == 0.0)? 1.0-tmp : 0.0);\n    \n    \n    G = (angle <= fourPIbyThree && angle >= twoPIbyThree)? 1.0 : 0.0;\n    tmp = smoothstep(PIbyThree, twoPIbyThree, angle);\n    G += (((tmp < 1.0 && tmp > 0.0) && G == 0.0)? tmp : 0.0);\n    tmp = (smoothstep(fourPIbyThree, fivePIbyThree, angle) ); \n    G += (((tmp < 1.0 && tmp > 0.0) && G == 0.0)? 1.0-tmp : 0.0);\n    \n    B = (angle <= twoPI && angle >= fourPIbyThree)? 1.0 : 0.0;\n    tmp = smoothstep(PI, fourPIbyThree, angle);\n    B += (((tmp < 1.0 && tmp > 0.0) && B == 0.0)? tmp : 0.0);\n    tmp = (smoothstep(0.0, PIbyThree, angle)); \n    B += (((tmp < 1.0 && tmp > 0.0) && B == 0.0)? 1.0-tmp : 0.0);\n    \n    \n    //**old method - scrapped, tho still works\n    //if(angle >= twoPIbyThree && angle < fourPIbyThree){\n    //    G = 1.0;\n    //}\n    //else if((angle < twoPIbyThree && angle >= PIbyThree)){\n    //    G = (angle - PIbyThree) / (PIbyThree);\n    //}\n    //else if (angle > fourPIbyThree && angle <= fivePIbyThree){\n    //    G = 1.0 - (angle - fourPIbyThree) / (PIbyThree);\n    //}\n    //\n    //if(angle >= fourPIbyThree && angle < twoPI){\n    //    B = 1.0;\n    //}\n    //else if(angle > 0.0 && angle <= PIbyThree){\n    //    B = 1.0 - (angle) / (PIbyThree);\n    //}\n    //else if(angle > PI && angle <= fourPIbyThree){\n    //    B = (angle - PI) / (PIbyThree);\n    //}\n    \n    //R +=  - sin(iTime) * dist/diagonal;\n    //G +=  - sin(iTime + 2.0*PI/3.0) * dist/diagonal;\n    //B +=  - sin(iTime + 4.0*PI/3.0) * dist/diagonal;\n    \n    // My old experiment, I don't even know how I came up with this.\n\ttmp = mod(dist + 1000.0*pow(sin(iTime/5.0)+1.0,2.0),50.0 + 50.0*cos(iTime/5.0));\n    //** I don't know how to use smoothstep to reduce jaggered edges from circles\n    if( tmp <= 10.0 ){\t\n        grad1 = smoothstep(0.0,1.0,(tmp*tmp)/150.0);\n        tmp = 10.0-tmp;\t//reverse gradient for inner edge\n        grad2 = smoothstep(0.0,1.0,(tmp*tmp)/150.0);\n        \n        tmp = (grad1 + grad2);\n        //tmp/2.0 to give lighter, more transparent look\n        R += smoothstep( 0.0,1.0, tmp/2.0);\n        G += smoothstep( 0.0,1.0, tmp/2.0);\n        B += smoothstep( 0.0,1.0, tmp/2.0);\n    }\n    \n    vec3 color;\n    color = vec3(R,G,B);\n\tcolor *= ((sin(iTime))+2.0);\t//dancing color pellets\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 248, 248, 345], [451, 451, 508, 508, 3669]], "test": "timeout"}
{"id": "tlXyWH", "name": "Shaggy Feeder", "author": "dr2", "description": "Hairy critter that eats grass, shoots, roots and leaves...", "tags": ["hair", "fur", "animal"], "likes": 9, "viewed": 286, "published": "Public API", "date": "1591950095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Shaggy Feeder\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Hairy critter that eats grass, shoots, roots and leaves...\n\n// Learned hairstyling from \"furball\" by simesgreen \n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nfloat dstFar, tCur, tRot, rBall, furThk;\nconst float pi = 3.1415927;\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  float b, d;\n  d = dstFar;\n  b = dot (rd, ro);\n  d = b * b + rBall * rBall - dot (ro, ro);\n  return (d > 0.) ? - b - sqrt (d) : dstFar;\n}\n\nvec3 FurPos (vec3 p)\n{\n  float s, t;\n  s = length (p);\n  p /= s;\n  t = 1. + (s - rBall) / furThk;\n  p.xz = Rot2D (p.xz, 0.5 * t * sin (2. * pi * tRot));\n  return vec3 (atan (p.z, p.x), acos (p.y) - 0.3 * t, s);\n}\n\nfloat FurDens (vec3 q)\n{\n  vec2 s;\n  s = Noisev2v2 (96. * q.xy);\n  return smoothstep (0.3, 1., s.x) * smoothstep (1., 1.2, s.y - (q.z - rBall) / furThk);\n}\n\nvec3 FurCol (vec3 ro, vec3 rd, vec3 col)\n{\n  vec4 col4, c4;\n  vec3 p, q, vn;\n  vec2 e;\n  float d;\n  const float nLay = 96.;\n  furThk = 0.2;\n  rBall = 1.;\n  d = BallHit (ro, rd);\n  col4 = vec4 (0.);\n  if (d < dstFar) {\n    p = ro + (d + 0.001) * rd;\n    p.xz = Rot2D (p.xz, 0.5 * sin (2. * pi * tRot + 0.5 * pi));\n    for (float j = 0.; j < nLay; j ++) {\n      q = FurPos (p);\n      c4.a = (j < nLay - 1. || q.z > rBall - furThk) ? FurDens (q) : 1.;\n      if (c4.a > 0.) {\n        e = vec2 (0.01, 0.);\n        vn = normalize (c4.a - vec3 (FurDens (FurPos (p + e.xyy)),\n           FurDens (FurPos (p + e.yxy)), FurDens (FurPos (p + e.xxy))));\n        c4.rgb = mix (vec3 (0.7, 0.4, 0.2), vec3 (0.3, 0.3, 0.5),\n           smoothstep (0.4, 0.6, Fbm2 (16. * q.xy)));\n        c4.rgb = c4.rgb * (0.5 + 0.5 * max (0., dot (vn, sunDir)));\n        c4.rgb *= c4.a * (0.6 + 0.4 * smoothstep (0.3, 0.7, (q.z - (rBall - furThk)) / furThk));\n        col4 += c4 * (1. - col4.a);\n      }\n      p += (2. * furThk / nLay) * rd;\n      if (p.y < 0.02 || col4.a > 0.95 || q.z > rBall) break;\n    }\n  }\n  if (col4.a > 0.95) col = col4.rgb;\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, trCol, vn, gPos;\n  vec2 vf;\n  float dstGrnd, dMove, s, bRad, f, w;\n  dMove = 0.1 * tCur;\n  if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    gPos = ro + vec3 (0., 0., dMove);\n    vf = vec2 (8., 4. * (1. - smoothstep (0.5, 0.9, dstGrnd / dstFar)));\n    col = mix (vec3 (0.4, 0.5, 0.3), vec3 (0., 0.5, 0.1),\n       smoothstep (0.2, 0.8, Fbm2 (8. * gPos.xz)));\n    w = 0.1 * (Noisefv2 (8. * gPos.xz) - 0.5);\n    if (ro.z < 0. && abs (gPos.x) < 0.8 + w) {\n      f = Fbm2 (32. * gPos.xz);\n      trCol = vec3 (0.6, 0.7, 0.1) * (0.5 + 0.5 * f);\n      bRad = 0.1 + 0.15 * Fbm1 (floor ((gPos.z + 1.) / 2.));\n      s = length (vec2 (gPos.x, mod (gPos.z + 1., 2.) - 1.));\n      if (s < bRad) {\n        trCol = mix (vec3 (0.1 + 0.2 * f, 0., 0.), trCol, smoothstep (-0.04, 0., s - bRad));\n        vf = vec2 (8., 8.);\n      } else vf = vec2 (16., 1.);\n      col = mix (trCol, col, smoothstep (0.75, 0.8, abs (gPos.x) - w));\n    }\n    col *= 0.9 + 0.1 * smoothstep (0.8, 0.9, length (ro.xz));\n    col = mix (vec3 (0.2, 0.5, 0.2), col,  1. - smoothstep (0.5, 0.9, dstGrnd / dstFar));\n    if (vf.x > 0.) vn = VaryNf (vf.x * gPos, vn, vf.y);\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.));\n    col = mix (0.8 * col, vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  col = FurCol (ro, rd, col);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.17 * pi;\n  tRot = 0.4 * tCur;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el += 0.08 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n  dstFar = 50.;\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v2 (vec2 p)\n{\n  return vec2 (Noisefv2 (p), Noisefv2 (p + vec2 (17., 23.)));\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyWH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[520, 520, 554, 554, 693], [695, 695, 717, 717, 907], [909, 909, 933, 933, 1064], [1066, 1066, 1108, 1108, 2197], [2199, 2199, 2233, 2233, 2993], [2995, 2995, 3030, 3030, 4455], [4457, 4457, 4513, 4513, 5250], [5252, 5252, 5288, 5288, 5494], [5496, 5496, 5526, 5526, 5639], [5673, 5673, 5697, 5697, 5750], [5752, 5752, 5776, 5776, 5906], [5908, 5908, 5933, 5933, 6079], [6081, 6081, 6106, 6106, 6292], [6294, 6294, 6319, 6319, 6383], [6385, 6385, 6407, 6407, 6561], [6563, 6563, 6584, 6584, 6739], [6741, 6741, 6770, 6770, 6982], [6984, 6984, 7023, 7023, 7203]], "test": "error"}
{"id": "tlXyz7", "name": "Cratered desert planet", "author": "jarble", "description": "This planet has many caves, craters, and sand dunes. It looks fairly realistic up close, but it has many moiré patterns when viewed from a distance.", "tags": ["3d", "planet", "cave", "dunes", "desert", "crater"], "likes": 2, "viewed": 257, "published": "Public API", "date": "1591669271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float planet_size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*100.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat sceneSDF1(vec3 p) {\n    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));\n}\n\nfloat sceneSDF2(vec3 p){\n    p *= 3.0;\n\treturn 0.5 + sceneSDF1(p/2.0+sceneSDF1(p/5.0));\n}\n\nfloat dunes1(vec3 p,float distortion){\n    p *= distortion;\n\treturn sin((p.x/3.0+p.y/5.0+p.z/11.0))/distortion;\n}\nfloat dunes(vec3 p,float distortion){\n\treturn dunes1(p,distortion) + dunes1(p.zxy,distortion);\n}\n\nfloat planet_surface(vec3 p){\n return\tlength(p)-planet_size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = 1.1+dunes(p,10.0)/5.0+max(planet_surface(p),-min(sceneSDF2(p/7.0),min(sceneSDF2(p.xzy/11.0),sceneSDF2(p/13.0))));\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 315, 315, 453], [697, 697, 722, 769, 825], [827, 827, 851, 851, 916], [918, 918, 956, 956, 1031], [1032, 1032, 1069, 1069, 1128], [1130, 1130, 1159, 1159, 1192], [1194, 1194, 1218, 1218, 1456], [1458, 1879, 1970, 1970, 2276], [2291, 2545, 2610, 2610, 2742], [2744, 2833, 2862, 2862, 3172], [3174, 3666, 3806, 3806, 4416], [4418, 4788, 4873, 4873, 5645], [5647, 5974, 6023, 6058, 6189], [6191, 6191, 6248, 6248, 7226]], "test": "timeout"}
{"id": "tly3zG", "name": "pixel line", "author": "dtsmio", "description": "moving pixel line", "tags": ["pixels"], "likes": 6, "viewed": 100, "published": "Public", "date": "1592396474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float time = iTime / 2.;\n    //time = 0.8 + sin(iTime * 1.) * 0.2;\n\n    vec3 col = vec3(0);\n    \n    vec2 st = uv * 6. + vec2(2., 0.);\n    vec2 dt = uv * 8. + vec2(2., 0.);\n\t\n    vec3 c1 = vec3(0.2, 0.8, 0.8);\n    vec3 c2 = vec3(0.8, 0.6, 0.2);\n    vec3 c3 = vec3(0.8, 0.2, 0.8);\n    vec3 c4 = vec3(0.4, 0.7, 0.4);\n    \n    float rws = 12.;\n    float maxlen = 6.;\n    float sbp = 2.;\n    \n    float tx = time * 0.4 + 5.;\n    float prog = smoothstep(0.5, 1., sin(time * 2.) * 0.5 + 0.5);\n    float tprog = max(0., fract(tx * 0.5)- 0.5);\n    float stp = step(0.1, tprog);\n    \n    float f1 = floor(tx * maxlen * rws / sbp) / maxlen / rws * sbp;\n    float f3 = (max(0., fract(tx * 0.5) - 0.5) * 2. + floor(tx * 0.5)) * 2.;\n    prog = max(f1 - f3, step(0., fract(tx * 0.5)- 0.5) * (tx - f3));\n\n    float len = prog * maxlen;\n    \n    float border = len - 1.;\n    float pnum = rws * rws * maxlen;\n    float size = 1./ rws;\n    float spray = smoothstep(0., 0.1, tprog);\n    \n    for (float i = 0.; i < pnum; i++) {// < pnum\n\t        \n    \tvec2 pos = vec2(floor(i / rws)/rws, fract(i/rws));\n        \n        if (pos.x > len) { \n        \tcontinue;\n        }\n        float ab = step(border, pos.x); // after border space\n\n        // set movement discret\n        pos.x -= fract(pos.x * rws)/rws;\n        \n        vec2 npos = pos;\n        // add random movement after border when spray\n        npos.y += ab * (pos.x - border) * 1.2 * (pos.y - 0.5) * sin(i * 3.123) * spray;\n        npos.x += ab * (pos.x - border) * 0.4 * sin(i * 12.1) * spray;\n\t\n        float csize = size;\n        float p = step(npos.x, st.x) * step(npos.y, st.y);\n        p *= max(0., 1. - step(npos.x + csize, st.x) - step(npos.y + csize, st.y));\n        \n        vec3 c; // choose color\n        float rc = fract(sin(floor(i/2.) - mod(floor(i / rws), 2.) * rws / 2.) * 0.5 + 0.5);\n        if (0. <= rc && rc < 0.25) {\n            c = c1;\n        }\n        if (0.25 <= rc && rc < 0.5) {\n            c = c2;\n        }\n        if (0.5 <= rc && rc < 0.75) {\n            c = c3;\n        }\n        if (0.75 <= rc && rc < 1.) {\n            c = c4;\n        }\n\t\t\n        // add opacity\n        c *= smoothstep(len, len - 1./rws, pos.x);\n        \n        col += p * c;\n        \n        if (p > 0.) {\n        \tbreak;\n        }\n    }\n    \n    float block = step(0., st.x) * step(0., uv.y);\n    block *= max(0., 1. - step(maxlen, st.x) - step(1., st.y));\n    \n    col += block/6. ;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2589]], "test": "timeout"}
{"id": "ts2cRy", "name": "glitch pattern", "author": "boysx", "description": "glitch pattern", "tags": ["glitch", "pattern"], "likes": 9, "viewed": 349, "published": "Public API", "date": "1591299554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p)\n{\n    float t = floor(iTime * 20.) / 10.; // glitch FPS\n    //t = exp(t);\n    return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv, float blockiness)\n{   \n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    float n1 = rand(id);\n    float n2 = rand(id+vec2(1,0));\n    float n3 = rand(id+vec2(0,1));\n    float n4 = rand(id+vec2(1,1));\n    \n    vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n\n    return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n}\n\nfloat fbm(vec2 uv, int count, float blockiness, float complexity)\n{\n    float val = 0.0;\n    float amp = 0.5;\n    \n    while(count != 0)\n    {\n    \tval += amp * noise(uv + (rand(ceil(uv * 3.) / 3.) * 2. + (float(floor(iTime * 20.) / 10.)/float(count)) - 1.), blockiness);\n        amp *= 0.5;\n        uv *= complexity;    \n        count--;\n    }\n    \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv;\n    \n    uv *= 5.;\n    //uv.x *= noise((ceil(uv * 5.) / 5.) * 0.3, 3.0); // should i?\n    uv.x *= fbm(uv, 2, 3.0, 1.0);\n    \n    float noiseVal = (smoothstep(0.5, 1.0, fbm(uv, 2, 3.0, 1.5))); // take the noise\n\n    vec3 col = vec3(texture(iChannel0, vec2(uv2.x + noiseVal * 0.05, uv2.y)).r,\n                   texture(iChannel0, vec2(uv2.x - noiseVal * 0.05, uv2.y)).g,\n                   texture(iChannel0, vec2(uv2.x, uv2.y)).b); // adjust amplitude\n    col = vec3(1.0, 0.0, 0.0)*smoothstep(0.2, 0.3, noiseVal);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2cRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 169], [171, 171, 211, 211, 516], [887, 887, 944, 994, 1625]], "test": "error"}
{"id": "tsBfD3", "name": "Cubic Bezier Curve", "author": "yp3y5akh0v", "description": "Cubic Bezier Curve", "tags": ["2d", "bezier", "curve", "cubic"], "likes": 2, "viewed": 108, "published": "Public", "date": "1590962540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 40.\n#define R iResolution.xy\n#define M iMouse.xy\n#define t iTime\n#define T (0.5 + 0.5 * sin(t))\n#define D(p) (((p) - 0.5 * R) / R.y)\n#define inf 1e32\n\nfloat distToV(vec2 p, vec2 o, vec2 v) {\n    vec2 op = p - o;\n    vec2 ep = op - v;\n    float d = length(ep - dot(ep, v) / dot(v, v) * v);\n    if (dot(op, v) < 0.) {\n        d = length(op);\n    }    \n    if (dot(ep, -v) < 0.) {\n        d = length(ep);\n    }\n    return d;\n}\n\nvec2 CubicBezier(vec2 a, vec2 b, vec2 c, vec2 d, float q) {\n    vec2 qab = mix(a, b, q);\n    vec2 qbc = mix(b, c, q);\n    vec2 qcd = mix(c, d, q);\n    vec2 qabc = mix(qab, qbc, q);\n    vec2 qbcd = mix(qbc, qcd, q);\n    return mix(qabc, qbcd, q);\n}\n\nvoid mainImage(out vec4 o, in vec2 p)\n{\n    p = D(p);\n    vec2 m = D(M);    \n    vec2 a = vec2(0., -0.3);\n    vec2 b = vec2(-2. + T, 0.5);\n    vec2 c = vec2(2. - T, 0.5);\n    vec2 d = vec2(0., -0.3);\n    float s = inf;\n    \n    for (float i = 1.; i <= N; i++) {\n        vec2 qb0 = CubicBezier(a, b, c, d, (i - 1.) / N);\n        vec2 qb1 = CubicBezier(a, b, c, d, i / N);\n        float d = distToV(p, qb0, qb1 - qb0);\n        s = min(s, d);\n    }\n    \n    vec2 tab = mix(a, b, T);\n    vec2 tbc = mix(b, c, T);\n    vec2 tcd = mix(c, d, T);\n    vec2 tabc = mix(tab, tbc, T);\n    vec2 tbcd = mix(tbc, tcd, T);\n    vec2 tr = mix(tabc, tbcd, T);\n    \n    o = vec4(0.002 / s + 0.004 / length(p - tr));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 200, 200, 433], [435, 435, 494, 494, 682], [684, 684, 723, 723, 1380]], "test": "timeout"}
{"id": "tsSfDd", "name": "Kelp forest", "author": "jarble", "description": "There are many blades of wavy kelp here.\nClick and drag the mouse to look around.", "tags": ["raymarching", "kelp"], "likes": 1, "viewed": 224, "published": "Public API", "date": "1591122707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\n\nvec3 animate(vec3 p){\n    p *= 10.0;\n\tp += vec3(sin(p.y/10.0+iTime*5.0),cos(p.z/10.0),0.0)*10.0;\n    return p;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p = animate(p);\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = vec2(p.x,p.y)/(300.0);\n    p = (sin(p) + sin(p*4.0))/2.0;\n    return sin(vec3(0.2*p.x,(p.y+p.x+p.z)*2.0,p.z*.2));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    //p *= 5.0;\n    p = animate(p)/10.0;\n    p.x += sin(p.z);\n    p += sin(vec3(p.xzy)/3.0)*3.0;\n    return  (2.1 + (sin(p.x/(2.0+sin(p.z/400.0)))+cos(p.z/(4.0)))*1.1+(p.y*p.y/6.0)/1000.0)/2.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    vec3 eye = vec3(0.0, 1.0, -7.0-iTime)*10.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 268, 268, 359], [361, 361, 389, 389, 591], [594, 834, 858, 874, 1054], [1056, 1477, 1568, 1568, 1932], [1947, 2201, 2266, 2266, 2398], [2400, 2489, 2518, 2518, 2828], [2830, 3322, 3462, 3462, 4052], [4054, 4424, 4509, 4509, 5267], [5269, 5596, 5645, 5680, 5811], [5813, 5813, 5870, 5870, 6931]], "test": "timeout"}
{"id": "ttfcDj", "name": "Flower colors", "author": "TAKUSAKU", "description": "Flower colors", "tags": ["flower", "color"], "likes": 2, "viewed": 42, "published": "Public", "date": "1593071608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n    vec2 p=(2.*FC-iResolution.xy)/iResolution.y;\n    vec3 c=vec3(.5-.9*sin(iTime*.5));\n    for(float i=-5.;i<9.;i++)\n        p*=1.1,\n        c+=sin(iTime*.5)\n        *vec3(.5,.5+.5*cos(iTime),.5+.5*sin(iTime))\n        *(1.-smoothstep(.1,.2,abs(length(p)-.5)))\n        *smoothstep(-1.,.5,sin(floor(cos(iTime/4.)*16.)*atan(p.y,p.x)));\n    o=vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfcDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 395]], "test": "timeout"}
{"id": "ttfcR8", "name": "\"marbling\" by lainga", "author": "foran", "description": "marbling", "tags": ["marbling"], "likes": 0, "viewed": 43, "published": "Public", "date": "1591381575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"marbling\" by lainga. https://shadertoy.com/view/MdySzR\n// 2020-06-05 18:19:12\n\n\n\nvec2 pa(in vec2 uv, in float per){\n    vec2 result = (sin(uv.x*per)) * normalize(vec2(cos((uv.x)*per), .5));\n    return result;\n}\n\nvec2 pb(in vec2 uv, in float per){\n    vec2 result = (cos(uv.y*per)) * normalize(vec2(1., cos((uv.y)*per)));\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*.4;\n    \n\tvec2 uv = -1. + .1*(fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y*.5+.5;\n        \n    vec2 vpert = pa(uv, 20.);\n    uv += vpert * sin(t) *.2;\n    \n    vec2 hpert = pb(uv, 51.);\n     uv += hpert * sin(t) * .08;\n    \n    //vec4 col = texture(iChannel0, uv);\n    //fragColor = col;\n\tfragColor = mix(6.*vec4(sin(uv.y*12.),mod(uv.x*12.,.25), \n    cos(uv.y*13.), 1.), vec4(sin(t*.5)*3.,sin(t*.5),sin(t*1.5)*11.,\n    tan(t*22.15)*1.), .249);\n     //fragColor *= col;\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfcR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 127, 127, 222], [224, 224, 258, 258, 353], [355, 355, 412, 412, 930]], "test": "timeout"}
{"id": "ttfcRB", "name": "OrbitTrap Mandelbrot", "author": "cheasify", "description": "Simple orbit trap with a few trap choices: point, line, circle. I will probably write some more later or multiple simultaneously. On screen is a moving circular trap. You can look at the others by uncommenting sections in orbitMeasure.", "tags": ["fractal", "mandelbrot", "orbittrap", "pretty"], "likes": 2, "viewed": 65, "published": "Public", "date": "1592332916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fast and ez\nvec3 color(float x){\n\tx=sin(x);//so it loops nicely\n    //x=abs(sin(x));//limits colors \n    //bezier, you can rearange the functions for different color combos but this one is best\n    float r=(1.0-x)*(1.0-x);\n    float g=x*x;\n    float b=2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\nfloat orbitMeasure(vec2 point){\n    //point \n\t//return distance(point,vec2(-1,0));\n    \n    //shifted line \n    //vec2 s=vec2(-2,0);//offset\n    //vec2 dir=vec2(cos(iTime),sin(iTime));//direction of line\n    //float d=dot(point-s,dir)/length(dir);\n    //return sqrt(length(point-s)*length(point-s)-d*d);\n    \n    //shifted circle\n    //note the point is just a 0 radius circle \n    vec2 c=2.1*vec2(cos(iTime)-.25,sin(iTime));// this looks cool\n    //vec2 c=vec2(1,0);\n    float r=1.4;\n    return abs(r-length(point-c));\n    \n    //any function that takes in a 2d vector and outputs a scalar, preferably positive scalars \n}\n\n//(x+yi)^2=(x+yi)(x+yi)=x^2+(yi)^2+2xyi since i^2=-1 then =x^2-y^2+2xyi \nvec2 square(vec2 n){\n\treturn vec2(n.x*n.x-n.y*n.y,2.0*n.x*n.y);\n}\n\n//const vec2 center=vec2( -0.743643887037158704752191506114774, 0.131825904205311970493132056385139);\nconst vec2 center= vec2(-1,0);\nconst int maxiter=100;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=1.5*((2.*fragCoord-iResolution.xy)/iResolution.y);\n    //uv/=exp2(iTime);\n    uv+=center;\n    \n    float mini=1e20f;\n    vec2 value=vec2(0);\n    for(int i=0;i<maxiter;i++){\n        value=square(value)+uv;\n    \tmini=min(orbitMeasure(value),mini);   \n    }\n   \tfragColor=vec4(color(length(mini+2.5)*2.5)*.8,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfcRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 14, 34, 34, 294], [296, 296, 327, 673, 918], [920, 993, 1013, 1013, 1058], [1218, 1218, 1275, 1275, 1598]], "test": "timeout"}
{"id": "ttfczf", "name": "very slow line rendering", "author": "meteotrix", "description": "testing something to replace implicit modeling. deadline coming, can't think about how to optimize x) it's precomputed don't worry.", "tags": ["linerendering"], "likes": 0, "viewed": 61, "published": "Public", "date": "1592611699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//from https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\nfloat minimum_distance(vec2 v, vec2 w, vec2 p) {  \n  float l2 = distance(v, w)*distance(v, w);\n  if (l2 == 0.0) return distance(p, v);\n   float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n   vec2 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 1.777;\n    uv.x -= 0.38;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n//#define OLD_VERSION    \n#ifdef OLD_VERSION //cleaned it up a bit but basically this:\n    \n    float distance_to_center = distance(uv.xy, vec2(0.5));\n\tfloat angle_around_center = acos(dot(normalize(uv.xy - vec2(0.5)), vec2(1, 0)));\n\tbool draw = (fract((angle_around_center - 0.02) * 32.0) < 0.25 && distance_to_center > 0.25 && distance_to_center < 0.3);\n\tcol = draw ? vec3(0) : col ;\n    \n#else\n    \n    //create points for lines\n    #define count 36.0  \n    vec2[int(count)] pts_A;\n    vec2[int(count)] pts_B;    \n    for(float p=0.0; p<count; ++p)\n    {\n        float degrees = p * (360.0/count);\n        float rads = (degrees / 180.0) * 3.14159;\n        mat2x2 rotation = mat2x2(cos(rads), -sin(rads), sin(rads), cos(rads));\n        \n        vec2 dir = vec2(1, 0) * rotation;\n        vec2 center = vec2(0.5,0.5);\n        pts_A[int(p)] = center + dir*0.2;\n        pts_B[int(p)] = center + dir*0.5;\n        \n    }\n    \n    \n    //draw lines\n    float line_thickness = 2.0 / iResolution.y;\n    //int samples_per_frag = 1;\n    for(int p=0; p <int(count);++p)\n    {\n        if (minimum_distance(pts_A[p], pts_B[p], uv.xy) < line_thickness) col.rgb = vec3(0.0);\n    }\n    \n#endif\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 103, 151, 151, 368]], "test": "timeout"}
{"id": "ttfyDj", "name": "Day 187", "author": "jeyko", "description": "potato", "tags": ["mograph", "mdtmjvm"], "likes": 25, "viewed": 369, "published": "Public API", "date": "1593065386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./60.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\n#define pmod(p,j) mod(p - 0.5*j,j) - 0.5*j\n\n\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[10](6.2*speed,2.7*speed, 2.6*speed, 4.2*speed, 3.*speed, 6.75*speed, 6.2*speed, 7.2*speed, 6.2*speed, 8.9*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    //t += sumScenes(8.)- 0.;\n    \n    t = mod(t, sumScenes(9.)  );\n    \n    vec2 triW = vec2(0.1,0.173)*1.;\n    \n    float its = 6.;\n    \n    if(t < scenes[0]){\n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n           \n            float enva = smease(t/scenes[0]*1.,2.);\n            \n            float envb = 1.-smease(t/scenes[0]*1.,3.);\n \t\t\t\n            \n                        \n            \n            p *= rot(tau*i/its);\n\t\t\t\n            \n            float antiatten = (1. - enva);\n\n            p.y -= 0.105*antiatten;\n            \n            p.y += 0.9*enva*envb;\n            p.xy *= rot(-pi*enva/1.);\n           \n            vec2 q = p;\n            \n            enva*=envb;\n            \n            float dt = sdTri(p,triW);\n            for(int i = 0; i < 2; i++){\n            \tp = abs(p);\n                p.x -= 0.03*antiatten;\n                p.y -= 0.03*antiatten;\n            \t\n                p.xy *= rot( .5*pi*antiatten);\n\t\t\t\n                p.xy *= rot(-0.5*pi*enva);\n                p.y -= 0.1*enva;\n                p.x += 0.15*enva;\n            \t\n                //p.x += 0.05*enva;\n                \n                p.xy *= rot(0.25*pi*enva);\n                \n            }\n            \t\t\t\t\t\n            \n            //p *= rot(0.5*pi*enva);\n                \n            \n            \n            dt = mix(dt,sdBox(p,triW/5.),1.*antiatten);\n            q = pmod(q,triW/2.);\n            dt = mix(dt,sdBox(q,triW/14.),enva*2.5); \n            \n            //dt = mix(dt, max(abs(pmod(dt ,0.02)) - 0.001,dt),0.);\n            \n            //dt = mix(dt, max(abs(pmod(dt,0.02)) - 0.001,dt),0.);\n            \n            d = min(d,dt); \n            \n            \n        }\n\n    } else if(t <  sumScenes(1.) ) {\n    \tt -=  sumScenes(0.) ;\n        \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(pi*2.*i/its);\n\n            float env = smease(t/scenes[1],2.);\n            p.x -= 0.2*env;\n\t\t\t\n            p *= rot(env*pi/3.);\n            \n\n            d = min(d,sdTri(p,triW)); \n\n        }\n        \n    \n    }else if(t < sumScenes(2.) ) {\n    \tt -= sumScenes(1.); \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(pi*2.*i/its);\n\n            float env = smease(t/scenes[2],2.5);\n            p.x -= 0.2 - 0.2*env;\n\t\t\t\n            p *= rot(pi/3.);\n            \n\n            d = min(d,sdTri(p,triW)); \n\n        }\n        \n    }else if(t < sumScenes(3.)) {\n    \tt -= sumScenes(2.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            \n            \n            p *= rot(pi*2.*i/its);\n\n            \n            float enva = smease(t/scenes[3]*2.,1.);\n\t\t\t\n            float envb = smease(t/scenes[3]*1.,3.);\n\t\t\t\n            p *= rot(envb*pi);\n            p.x += 0.1*enva;\n\n            d = min(d,sdTri(p,triW)); \n\n        }\n        \n    }else if(t < sumScenes(4.)) {\n    \tt -= sumScenes(3.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(pi*2.*i/its);\n\n            \n            float enva = smease(t/scenes[4]*1.,3.);\n\t\t\t\n            float envb = smease(t/scenes[4]*1.5,2.);\n\t\t\t\n            p *= rot(pi + pi*enva);\n            \n            p.x += 0.1 - 0.1*enva;\n            \n            d = min(d,sdTri(p,triW)); \n\n        }\n    \n    }else if(t < sumScenes(5.)) {\n    \tt -= sumScenes(4.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(tau*i/its);\n\n            float enva = smease(t/scenes[5]*0.9,3.);\n            \n            p.xy -= 0.1*enva;\n\t\t\t\n            for(int i = 0; i < 4; i++){\n            \tp = abs(p);\n                p.xy *= rot(-pi*0.25*enva);\n                p.x -= 0.06*enva;\n            }\n            \n            //p *= rot(pi);\n\n            \n            float dt = sdTri(p,triW); \n            dt = mix(dt, max(abs(pmod(dt,0.02)) - 0.001,dt),1.*enva);\n            \n            d = min(d,dt); \n\n        }\n    }else if(t < sumScenes(6.)) {\n    \tt -= sumScenes(5.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(tau*i/its);\n\n            float enva = smease(t/scenes[6]*0.8,3.);\n            \n            p.xy -= 0.1;\n\t\t\t\n            for(int i = 0; i < 4; i++){\n            \tp = abs(p);\n                p.xy *= rot(-pi*0.25 + 0.5*pi*enva);\n                p.x -= 0.06;\n            }\n            \n            float dt = sdTri(p,triW); \n            dt = mix(dt, max(abs(pmod(dt,0.02)) - 0.001,dt),1.);\n            \n            d = min(d,dt); \n\n        }\n    }else if(t < sumScenes(7.)) {\n    \tt -= sumScenes(6.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(tau*i/its);\n\n            float enva = smease(t/scenes[7]*1.,3.);\n            \n            p.xy *= rot(-1.*pi*enva);\n            p.xy -= 0.1;\n            \n            \n            for(int i = 0; i < 4; i++){\n            \tp = abs(p);\n                p.xy *= rot(0.25*pi + -0.25*pi*enva);\n                p.x -= 0.06 - 0.1*enva;\n            \t\n                p.y += 0.02*enva;\n                \n                p.xy *= rot(0.25*pi*enva);\n\t\t\t\n            }\n            \n            float dt = sdTri(p,triW); \n            dt = mix(dt, max(abs(pmod(dt,0.02)) - 0.001,dt),1. - 1.*enva);\n            \n            d = min(d,dt); \n\n        }\n    }else if(t < sumScenes(8.)) {\n    \tt -= sumScenes(7.) ; \n    \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            p *= rot(tau*i/its);\n\n            float enva = smease(t/scenes[8]*1.25,3.);\n            \n            p.xy *= rot(-1.*pi - 1.*pi*enva);\n            p.xy -= 0.1 - 0.1*enva;\n            \n            \n            for(int i = 0; i < 4; i++){\n            \tp = abs(p);\n                p.x -= -0.04 + 0.04*enva;\n            \t\n                p.y += 0.02 - 0.02*enva;\n                \n                p.xy *= rot(0.25*pi + .25*pi*enva);\n\t\t\t\n            }\n            \n            float dt = sdTri(p,triW); \n            \n            d = min(d,dt); \n\n        }\n    }else if(t < sumScenes(9.)) {\n    \tt -= sumScenes(8.) ; \n        \n        for(float i = 0.; i < its; i++){\n\n            vec2 p = uv;\n\n            float enva = smease(t/scenes[9]*1.25,3.);\n            \n            float envb = 1.-smease(t/scenes[9]*1.25,2.);\n            \n            p *= rot(tau*i/its);\n\n            p *= rot(pi);\n\n            \n            //enva*= envb*6.;\n            \n            enva *= 1.5;\n            \n            p.y -= 0.07*enva;\n\n            //p *= rot(pi*enva/1.);\n\n           \n            \n\n            \n            float dt = sdTri(p,triW); \n            \n            for(int i = 0; i < 2; i++){\n            \tp = abs(p);\n                p.x -= 0.03;\n                p.y -= 0.03;\n            \t\n                //p.y += 0.005;\n                \n                p.xy *= rot( .5*pi);\n\t\t\t\n            }             \n            //p \n            dt = mix(dt,sdBox(p,triW/5.),enva/1.5); \n            //dt = mix(dt, max(abs(pmod(dt ,0.02)) - 0.001,dt), 1.-envb);\n            \n            d = min(d,dt); \n            \n        }\n    }\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    \n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 278, 302, 302, 358], [361, 372, 409, 409, 717], [718, 718, 755, 755, 802], [850, 850, 919, 919, 1075], [1076, 1076, 1108, 1108, 1212], [1382, 1382, 1410, 1410, 1517], [1519, 1519, 1546, 1546, 8866]], "test": "error"}
{"id": "ttfyRs", "name": "Infinite bridges", "author": "jarble", "description": "This fractal seems to be a city full of bridges and arches.", "tags": ["3d", "raymarching", "fractal"], "likes": 1, "viewed": 179, "published": "Public API", "date": "1592773987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n   \n\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON\n    \n  ; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0));\n    float color2 = length(cos(p/100.0));\n    return vec3(color1/1.5,color1/2.0,color2/3.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y-p.z/2000.0)-p1.y,sin(p1.z)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 10.0; i *= 2.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = scale*vec3(cos(iTime)/3.0,sin(iTime)/1.8,iTime*speed)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 384, 384, 540], [784, 784, 813, 813, 947], [949, 949, 973, 973, 1218], [1220, 1641, 1732, 1732, 2038], [2053, 2307, 2372, 2372, 2504], [2506, 2595, 2624, 2624, 2934], [2936, 3428, 3568, 3568, 4178], [4180, 4550, 4635, 4635, 5339], [5341, 5668, 5717, 5752, 5883], [5885, 5885, 5942, 5942, 7075]], "test": "timeout"}
{"id": "ttfyWB", "name": "Blender Donut", "author": "dean_the_coder", "description": "My take on the famous 'Blender donut'.\nCould do with finding a method to stop the ends of the sprinkles getting cut off...\nThanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!", "tags": ["3d", "raymarching", "donut", "blender", "cineshader"], "likes": 13, "viewed": 3767, "published": "Public API", "date": "1592936209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n    return (noise(p) + noise((p + 0.2) * 1.98) * 0.5 + noise((p + 0.66) * 4.12) * 0.25) / 1.75;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 sdDonut(vec3 p) {\n    float d1 = sdTorus(p, vec2(4.0, 1.4));\n\treturn vec2(d1, 1.5);\n}\n\nvec2 sdCream(vec3 p) {\n    float f = 0.0;\n    f += sin(p.x * 1.1 + p.z * 1.2) * 1.1;\n    f += sin(p.x * 2.5) * 0.5;\n    f += sin(p.z * 4.0) * 0.25;\n    f /= 4.0;\n    \n    float d2 = abs(p.y + f + 2.0) - 2.3;\n    \n    float d1 = sdDonut(p).x;\n    float d = max(d1, -d2);\n    \n\treturn vec2(d - 0.13, 2.5);\n}\n\nvec2 sdSprinkles(vec3 p) {\n    float dd = sdCream(p - vec3(0.0, 0.05, 0.0)).x;\n    \n    vec3 id = floor(p / 0.3);\n    \n    p.xz *= rot(hash(id.xz) * 3.141);\n    p.xy *= rot(hash(id.xy) * 3.141);\n    p.xz *= rot(hash(id.xz) * 3.141);\n    \n    p.x = mod(p.x, 0.3) - 0.15;\n    p.y = mod(p.y, 0.3) - 0.15;\n    p.z = mod(p.z, 0.3) - 0.15;\n    \n    p.xz *= rot(hash(id.xz) * 3.141);\n    p.xy *= rot(hash(id.xy) * 3.141);\n    p.xz *= rot(hash(id.xz) * 3.141);\n    float d = sdCapsule(p, 0.3, 0.02);\n    \n    d = max(d, dd);\n    \n    return vec2(d, mod(id.x, 6.0) + mod(id.y, 6.0) + mod(id.z, 6.0) + 10.5);\n}\n\nvec2 map(vec3 p) {\n    float bumps = fbm(p * 8.0) * 0.02;\n    vec2 d1 = sdDonut(p) - bumps;\n    vec2 d2 = sdCream(p);\n    vec2 d3 = sdSprinkles(p);\n    vec2 d4 = vec2(p.y + 1.7, 3.5);\n    \n    return min2(d1, min2(d2, min2(d3, d4)));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.7;\n    for (int i = 0; i < 16; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col;\n\n    // Raymarch.\n    vec3 ro = vec3(sin(iTime * 0.3), 4.0 + cos(iTime * 0.6) * 0.5, -9.0);\n    vec3 rd = getRayDir(ro, vec3(0.0, -1.0, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 128.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(10.0, 7.0, -10.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.15, 0.2, 0.25);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float occ = calcOcc(p, n, 4.0);\n        float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n        float mainLight = max(0.0, dot(n, lightToPoint));\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1;\n        vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Donut.\n            mat = vec3(0.5, 0.3, 0.2);\n        } else if (hit == 2) {\n            // Cream.\n            mat = vec3(1.0, 0.43, 0.85);\n        } else if (hit == 3) {\n            // Plane.\n            mat = vec3(0.2);\n        } else if (hit >= 10) {\n            // Sprinkles!\n            vec3 c = vec3(float(hit)) + vec3(1.0, 2.0, 3.0);\n            mat = sin(floor(c * 3.0) / 3.0);\n        }\n\n        col = (mainLight * sha + (spe + backLight) * occ) * lightCol;\n        col += skyLight * occ;\n        col *= mat;\n        col = mix(col, skyCol, fog);\n    } else {\n        // Sky.\n        col = vec3(0.15, 0.2, 0.25);\n    }\n\n    // Output to screen\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyWB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[88, 88, 108, 108, 172], [174, 230, 251, 251, 527], [529, 529, 548, 548, 646], [648, 648, 667, 667, 743], [745, 745, 776, 776, 841], [843, 843, 886, 886, 941], [943, 943, 990, 990, 1195], [1197, 1197, 1224, 1224, 1256], [1258, 1258, 1280, 1280, 1348], [1350, 1350, 1372, 1372, 1655], [1657, 1657, 1683, 1683, 2257], [2259, 2259, 2277, 2277, 2494], [2496, 2496, 2524, 2524, 2715], [2717, 2717, 2775, 2775, 3073], [3075, 3075, 3122, 3122, 3210], [3300, 3300, 3341, 3341, 3482], [3484, 3484, 3541, 3541, 5548]], "test": "timeout"}
{"id": "ttfyz4", "name": "Cloud Boze", "author": "kaiware007", "description": "Cloud Boze", "tags": ["raycasting", "fbm"], "likes": 5, "viewed": 100, "published": "Public", "date": "1591543174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define M_HALFPI 1.5707963\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n#define MAT_CS 7.0\n\n#define AA 1\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(hash13(ip+vec3(0.)),hash13(ip+vec3(1.,0.,0.)),hash13(ip+vec3(0.,1.,0.)),hash13(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(hash13(ip+vec3(0.,0.,1.)),hash13(ip+vec3(1.,0.,1.)),hash13(ip+vec3(0.,1.,1.)),hash13(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\nvec2 opI( vec2 d1, vec2 d2 )\n{ \n    //return (d1.x>d2.x) ? d1: vec2(d2.x, d1.y);\n    return (d1.x>d2.x) ? d1: d2;\n}\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\nfloat IsHitSphere(vec3 ro, vec3 rd, vec3 sphereCenter, float radius) {\n    vec3 diff = ro - sphereCenter;\n    float xc2 = dot(diff, diff);\n    float vxc = dot(rd, diff);\n    float sq = radius * radius;\n    return vxc * vxc - xc2 + sq; \n}\n\nfloat GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return min(t1, t2);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.02 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n}\n\nvec2 sdBoze(vec3 p, float sc, float ms)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat densitycalc(vec3 p){\n    p = rotate(p, 0.45, vec3(0,0,1));\n\tvec2 r = sdBoze(p, 5.0, (sin(iTime * 0.1 * M_PI) * 0.5 + 0.5)*1.5);\n\treturn fbm(p * 10. + iTime * 0.2) - min(r.x, 1.) * 10.;\n}\n\n#define MAX_MARCH 32\n#define MAX_MARCH_L 6\n\nvec3 raycast(vec3 p, vec3 ray, float depth)\n{\n    vec3 result = vec3(0.);\n        \n    //vec3 spherePos = vec3(0.,0.2 + sin(iTime * 4.0) * 0.5,0.);\n    vec3 spherePos = vec3(-0.05,0.2,0.);\n    float time = iTime * 2.2;\n    \n    float radius = 1.5;\n    float d = GetIntersectSphere(p, ray, spherePos, radius);\n    \n    if((d > 0.)&&(d < depth)){\n        float step = 1.0 / float(MAX_MARCH);\n    \tfloat lightStep = 1.0 / float(MAX_MARCH_L);\n\n        vec3 qq = rotate(p, 0.45, vec3(0,0,1));\n\t\tvec2 r = sdBoze(qq, 5.0, 1.0);\n        \n        vec3 ro2 = p + ray * (r.x - step);\n        float t = hash13(ro2 * 100.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 45.;\n        //vec3 sunDir = normalize(vec3(cos(time),1,sin(time)));\n        vec3 sunDir = normalize(vec3(-1,1,-0.25));\n        vec3 col = vec3(0.5);\n        \n        for(int i = 0; i < MAX_MARCH; i++){\n            t += step;\n            vec3 pp = ro2 + ray * t;\n            if((length(pp - spherePos) > radius)||((d + t) >= depth))\n                break;\n            vec3 q = pp - spherePos - vec3(0.,0.1 ,0.);\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 100. * dd * transmittance;\n                \n                float transmittanceLight = 1.0;\n                vec3 lightPos = q;\n                \n                for(int j = 0; j < MAX_MARCH_L; j++){\n                \tfloat densityLight = densitycalc(q + sunDir * float(j) * lightStep);\n                    if(densityLight > 0.0){\n                    \tfloat dl = densityLight * lightStep;\n                        transmittanceLight *= 1.0 - dl * absorption * 0.1;\n                        if(transmittanceLight < 0.01){\n                        \ttransmittanceLight = 0.;\n                            break;\n                        }\n                    }\n                }\n                col += vec3(1.,.7,.5) * (150. * dd * transmittance * transmittanceLight);\n            }\n        }\n        result = col * alpha;\n    }\n    \n    return result;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        float time = iTime * 0.5;\n        float y = 0.5;\n        vec3 ro = vec3(0., y, 5.);\n        vec3 ta = vec3(0., y, 0.);\n        mat3 c = camera(ro, ta, 0.);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = vec3(0.05,0.2,0.7);\n\n        col += raycast(ro, ray, 100.);\n\n        col = reinhard(col.xyz, 2.9, 100.0);\n        col = pow(col.xyz, vec3(1.0/0.9));\n    \n    \ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[620, 620, 643, 643, 716], [718, 718, 739, 739, 809], [811, 811, 834, 834, 937], [939, 939, 961, 961, 1378], [1488, 1488, 1509, 1509, 1650], [1652, 1652, 1682, 1682, 1812], [1814, 1913, 1959, 1959, 2015], [2017, 2017, 2067, 2067, 2185], [2187, 2187, 2224, 2224, 2313], [2315, 2315, 2385, 2385, 2519], [2521, 2521, 2585, 2585, 2702], [2704, 2704, 2740, 2740, 2774], [2776, 2776, 2828, 2828, 2935], [2937, 2937, 2970, 2996, 3027], [3029, 3086, 3114, 3114, 3147], [3149, 3149, 3179, 3179, 3231], [3233, 3233, 3273, 3273, 3409], [3411, 3411, 3441, 3491, 3526], [3528, 3579, 3616, 3616, 3638], [3640, 3640, 3683, 3683, 3705], [3707, 3707, 3751, 3751, 3772], [3774, 3774, 3826, 3826, 3925], [3928, 3928, 3973, 3973, 4402], [4404, 4404, 4439, 4439, 4587], [4589, 4589, 4623, 4623, 4799], [4801, 4801, 4832, 4832, 4881], [4883, 4883, 4918, 4918, 4953], [4955, 4955, 4992, 4992, 5027], [5029, 5200, 5285, 5285, 5362], [5364, 5364, 5434, 5434, 5601], [5603, 5603, 5688, 5688, 6012], [6270, 6270, 6313, 6313, 6484], [6510, 6510, 6542, 6542, 6655], [6657, 6657, 6700, 6700, 6925], [6927, 6927, 6972, 6972, 7573], [7575, 7575, 7622, 7622, 7794], [7796, 7796, 7837, 7837, 9060], [9279, 9279, 9305, 9305, 9471], [9517, 9517, 9562, 9562, 11771], [11773, 11773, 11815, 11815, 11993], [11995, 11995, 12022, 12022, 12081], [12083, 12083, 12137, 12137, 12279]], "test": "timeout"}
{"id": "ttfyzM", "name": "Experiments grid lights", "author": "photonic", "description": "experiments with grid and light", "tags": ["light"], "likes": 0, "viewed": 67, "published": "Public", "date": "1591656417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iMouse.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    uv *= 30.;\n    \n    vec2 gv = fract(uv) - 0.5;\n\tvec2 id = floor(uv);\n    uv *= abs(gv.y);\n\n    gv *= abs(uv.x);\n    gv += sin(iTime * id) - cos(iTime);\n    \n    float d = length(gv);\n    float d2 = length(uv);\n    \n    float m = abs(sin(iTime * 1.0) * .5) / d;\n    \n    col += m;\n\n    col *= vec3(.5, abs(sin(iTime + 200.)), abs(sin(iTime + 50.)));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfyzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 522]], "test": "timeout"}
{"id": "ttjXzd", "name": "Gate", "author": "dreamur", "description": "Based of the image: M E L C O T T I by Archist:\n\nhttps://old.reddit.com/r/ImaginaryMindscapes/comments/9704p1/m_e_l_c_o_t_t_i_by_me/", "tags": ["2d", "portal", "gate", "starscape"], "likes": 7, "viewed": 151, "published": "Public", "date": "1592825084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate (vec2 _st, float _angle) {\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    return _st;\n}\n\nfloat sdCircle(in vec2 _st, in float _radius)\n{\n    return length(_st) - _radius;\n}\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n  \tvec2 d = abs(p) - size - radius;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\n// by IQ\n// http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot(k2,k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\n// 2D Random\nfloat random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }\n\n// https://thebookofshaders.com/edit.php#12/vorono-01.frag\nfloat voroni(in vec2 _st, in float _offset)\n{\n    vec2 i_st = floor(_st);\n    vec2 f_st = fract(_st);\n\n    float m_dist = 150.;  // minimun distance\n    vec2 m_point;        // minimum point\n\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = vec2(random(i_st + neighbor ));\n            point = 0.5 + 0.5*sin(_offset + 6.2831*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n\n            if( dist < m_dist ) {\n                m_dist = dist;\n                m_point = point;\n            }\n        }\n    }\n    \n    return m_dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st       = 4.0 * fragCoord.xy / iResolution.x - vec2(2.0, 1.0);\n    \n    \n    vec3 col1 \t\t= vec3(1.0, 1.0, 0.416);\n    vec3 col2\t\t= vec3(0.0, 0.0, 0.0);\n    vec3 col3\t\t= vec3(0.0, 0.0, 0.65);\n    \n    vec3 color    \t= vec3(0.0);\n\n\n    float ripples;\n    float gateDF;\n    vec3 gradient;\n    \n    \n    \n    //**************\n    if(st.y >= -0.2)\n    {\n        color    \t= mix(col1, col3, st.y * 2.0 + 0.5);\n    \tcolor \t\t= mix(color, col2, st.y * 0.8 + 0.0); \n        \n        // //**************\n        float starsDF\t\t= 1.0 - smoothstep( voroni(-st * 40.0 , 0.0), 0.0, 0.018  );\n        starsDF\t\t\t\t+= 1.0 - smoothstep(voroni(st * vec2(-2.0,2.0) - vec2(iTime * 0.38, 0.0) + st.x * 2.0, 0.0), 0.0, 0.015);\n        color         \t\t= mix(color, vec3(1.0, 1.0, 1.0), starsDF * 0.75);      \n        \n        gateDF  \t\t\t= boxDist(st - vec2(0.0, -0.25), vec2(0.225, 1.1), 0.0) ;\n    \tgradient \t\t\t= mix(col3, col1, st.y + 0.45 - (st.x * 0.3));\n    \tgradient \t\t\t= mix(gradient, vec3(1.0), 0.15);\n    \tcolor         \t\t= mix(color, gradient, clamp(1.0 - sign(gateDF), 0.0, 1.0));\n        color         \t\t= mix(color, vec3(0.678, 0.847, 0.902), 1.0 - smoothstep(0.0, 0.015, abs(gateDF) ) );\n    } \n    else\n    {    \n        \n        vec2 xy = st;\n        //xy.y = ceil(xy.y * 12.0 - sin(iTime - xy.y * 3.0)) ;     \n        \n        //xy.y = ceil(xy.y * 3.0 + 3.0 + sin(iTime - xy.y) );\n        //float timeOffset = ceil(xy.y * 3.0 + 3.0 + sin(iTime - xy.y) );\n        \n        \n        //  color    \t= mix(col1, col3, xy.y * -3.0 - 0.8 + timeOffset );\n    \t//  color \t\t= mix(color, col2, xy.y  - 0.2 + timeOffset );           \n        \n //       float\tdx = 1.0 + iTime /25.0-abs(distance(xy.y, floor(xy.x) ));\n //       float\tdx2 = 1.0 + 0.25 /10.0-abs(distance(xy.y, 0.5));\n //       float\tdy = (1.0-abs(distance(xy.y, mod(0.0 + iTime,1.0))));\n //               dy = (dy > 0.5) ? 2.0 * dy : 2.0 * (1.0 - dy);\n\n//        if(dx2 > 1.0 - 0.25 / 10.0)\t{\n //           float rX2 =  (dy * random( vec2(dy, dx) ) + dx2) / 4.0;\n //           xy.y += 0.5 + rX2 / 12.5;\n//        }\n\n//        xy.y = mod(xy.y, 1.0);\n        \n        color    = mix(col1, col3, xy.y * -3.5 - 0.8);\n    \tcolor \t = mix(color, col2, xy.y  - 0.0 ); \n         \n        gateDF  \t\t\t= boxDist(xy - vec2(0.0, -0.25), vec2(0.225, 1.1), 0.0);\n    \tgradient \t\t\t= mix(col3, col1, xy.y + 0.45 - (xy.x * 0.3));\n    \tgradient \t\t\t= mix(gradient, vec3(1.0), 0.15);\n        color         \t\t= mix(color, gradient, clamp(1.0 - sign(gateDF), 0.0, 1.0));\n        color         \t\t= mix(color, vec3(0.678, 0.847, 0.902), 1.0 - smoothstep(0.0, 0.015, abs(gateDF) ) );        \n    }\n   \n                \n    //*************\n\tif(st.y < -0.2)\n    {                                       \n        // //**************\n        vec2 xy\t\t= 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0, 0.25);\n        xy.x \t\t+= abs(sin(st.y + 0.5) * 8.0) - 1.3;    \n        float road \t= sdTrapezoid(xy - vec2(0.05,0.0), 4.0, 0.2, 0.325);\n        \n        gradient\t= mix(vec3(1.0), vec3(0.0, 0.0, 0.125), st.y * -0.75 + 0.45);\n        gradient\t= mix(vec3(1.0), vec3(0.0, 0.0, 0.235), -road + 1.05);\n        \n        color \t\t= mix(color, gradient, 1.0 - smoothstep(0.0, 0.0175 -st.y / 32.0, road) );\n    }\n    \n    //*************\n    if(st.x < -1.0 || st.x > 1.0)\n    {\n        color = vec3(0.0);\n    }\n    \n   \tfragColor  = vec4( vec3(color) , 1.0); \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 73, 73, 181], [183, 183, 230, 230, 266], [268, 268, 316, 316, 420], [423, 510, 575, 575, 905], [907, 920, 947, 947, 1018], [1020, 1079, 1124, 1124, 1752], [1754, 1754, 1810, 1810, 5189]], "test": "timeout"}
{"id": "ttlcD8", "name": "Dodecahedralis VI", "author": "sl2c", "description": "Similar to the past \"Dodecahedralis\" shaders; this one with a rotating 3d projection of a 6d cohomology class.  Don't like this one as much as some I've made but it looks kind of neat.", "tags": ["fractal", "circles", "hyperbolic"], "likes": 8, "viewed": 93, "published": "Public", "date": "1592436887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\nfloat phi = sqrt(1.25) + 0.5;\n\nbool flip(inout vec3 z, in vec2 c, in float r, inout int t, in int k) {\n    z.xy -= c;\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        z *= r * r / dot(z,z);\n        t = k - t;\n    }\n    z.xy += c;\n    return res;\n}\n\nbool inside(in vec3 z, in vec2 c, in float r, inout float t) {\n    vec3 p = z - vec3(c,0.0);\n    float res = (dot(p,p)-r*r) / (2.0 * abs(r) * p.z);\n    t = min(t, abs(res));\n    return res < 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.5 / iResolution.y;\n    vec3 z = vec3(z0,ds);\n    \n    vec2[12] c; float[12] r;\n    float r1 = pow(1.5 + 0.5 * sqrt(5.0) - sqrt(1.5 * sqrt(5.0) + 2.5), 0.5);\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1 * sqrt(sqrt(5.0));\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<5; i++) {\n        float theta = tau * 0.2 * float(i);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+6] = r3;\n        c[i+6] = x3 * eit;\n    }\n    float r4 = -1.0 / r1;\n    r[11] = r4; c[11] = vec2(0.0);\n    \n    float period = -8.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    z *= exp(-d);\n    \n    bool fl = false;\n    float yellow = 0.0;\n    int[6] sv = int[](0,0,0,0,0,0);\n    bool[6] fls = bool[](false,false,false,false,false,false);\n    for (int i=0; i<7; i++) {\n        fls[5] = fls[5] ^^ flip(z, c[0], r[0], sv[5], 1);\n        for (int j=0; j<5; j++) {\n            fls[j] = fls[j] ^^ flip(z, c[j+1], r[j+1], sv[j], 1);\n            fls[j] = fls[j] ^^ flip(z, c[j+6], r[j+6], sv[j], -1);\n        }\n        fls[5] = fls[5] ^^ flip(z, c[11], r[11], sv[5], -1);\n        \n    }\n    for (int j=0; j<6; j++) {\n        if (fls[j]) {\n            sv[j] = -sv[j];\n        }\n    }\n    //float col = 0.0;\n    vec3 col = vec3(0.0);\n    for (int j=0; j<5; j++) {\n        float theta = tau * (0.2 * float(j) + d / period);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        //col += float(sv[j]*sv[j]);\n        col += float(sv[j]) * vec3(cos(theta),sin(theta),0.5) * 2.0 / sqrt(5.0);\n    }\n    float s5 = float(sv[5]) + 4.0 * d / period;\n    col.g += s5;\n    //col += s5 * s5;\n    col = col / (7.0 + col);\n    col = col.rbg;\n    fragColor = vec4(vec3(col),1.0);\n    /*if (sv[5] > 0) {\n        fragColor.r = 1.0;\n        fragColor.g = 0.0;\n    }\n    if (sv[5] < 0) {\n        fragColor.r = 0.0;\n        fragColor.g = 1.0;\n    }*/\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcD8.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[515, 515, 577, 577, 712]], "test": "error"}
{"id": "ttlcDM", "name": "blending smooth spheres", "author": "cabbibo", "description": "testing smooth min", "tags": ["spheres", "smoothmin"], "likes": 2, "viewed": 238, "published": "Public API", "date": "1592255569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n// power smooth min (k = 8);\n// polynomial smooth min (k = 0.1);\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h),a.y);\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    \n    vec2 res = vec2(10000.,-1.);\n    for( int i = 0; i< 8; i++){\n       res = opU(res, vec2(sdSphere( pos - vec3( -1.2 , float(i) * .15 -.5 , -.4) , .1  ),1.));\n        \n    }\n    \n    float blendTime = .5*abs(sin(iTime));\n    \n    for( int i = 0; i< 8; i++){\n       res = smin(res, vec2(sdSphere( pos - vec3( 0. , float(i) * .15 -.5 , -.4) , .1 ),1.),  blendTime);\n        \n    }\n    \n    \n    vec2 rightRes = vec2(10000.,-1.);\n    for( int i = 0; i< 8; i++){\n    \trightRes = opU(rightRes, vec2(sdSphere( pos - vec3( 1.2 , float(i) * .15 -.5 , -.4) , .1  ),1.));\n    }\n    \n    rightRes = smin( rightRes , rightRes , blendTime );\n\n    \n    res = opU( rightRes , res );\n    \n        \n\n \t//vec2 res = vec2( sdSphere( pos - vec3( .3 , .3 , -0.4 ) , 1.1 ) , 1. ); \n    //res = opU( res , vec2( sdBox( pos- vec3( -.8 , -.4 , 0.2 ), vec3( .4 , .3 , .2 )) , 2. ));\n    \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0. );\n    \n  vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n      \n    vec3 lightDir = normalize( lightPos - pos );\n    \n    float match = max( 0. , dot( lightDir , norm ));\n      \n    // Balloon\n    if( res.y == 1. ){\n            \n    \tcolor = vec3( 1. , 0., 0.) * match + vec3( .3 , .1, .2 );\n        vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n    // Box\n    }else if(res.y == 2. ){\n        \n        color = norm;\n        \n    }\n        \n        \n  }\n   \n  return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 291, 355, 355, 533], [535, 629, 658, 658, 701], [703, 703, 734, 734, 830], [832, 832, 867, 867, 891], [894, 959, 997, 997, 1108], [1110, 1194, 1215, 1215, 2114], [2118, 2118, 2166, 2166, 2633], [2637, 2750, 2781, 2781, 3007], [3012, 3012, 3056, 3056, 3667], [3671, 3671, 3728, 3728, 4215]], "test": "timeout"}
{"id": "ttlcDs", "name": "Sinusoids Wave 2D golf+AA+undist", "author": "FabriceNeyret2", "description": "antialiasing, undistorted dots, golfing 643 chars [url]https://shadertoy.com/view/wtlyDs[/url]\n", "tags": ["2tweets", "trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 4, "viewed": 226, "published": "Public API", "date": "1593505015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// antialiasing, undistorted dots, golfing https://shadertoy.com/view/wtlyDs\n\n\n// 199 chars -2 by Fab -4 by coyote\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 r = iResolution.yy*.1,\n         U = u*5. + u.y* cos( iTime + u.x/r*.56 + 11.*O++.xw );\n    O -= .1*(  min( 35.5*r - U , 5. )\n             + min(5.*length( inverse(mat2(dFdx(U),dFdy(U))) * (U-round(U/r)*r) )\n                   -r*.2 , 5.)  ).y;\n}\n/*\n\n\n// 205 chars  -6 by coyote  -1 by Fab\n\n#define mainImage(O,u)                                                   \\\n    vec2 r = iResolution.yy*.1, U = u/r;                                 \\\n    U = U*5. + U.y* cos( iTime + U.x*.56 + 11.*O.xw );                   \\\n    O -=   min( (35.5-U.y)*r.x*.1, .5 )                                  \\\n         + min(.5*length((U-round(U)) * inverse(transpose(mat2(dFdx(U),dFdy(U))))) \\\n                -r.x*.02, .5) - 1.                                      /*\n\n\n\n\n\n// 212 chars  -9 by Fabrice\n\n#define mainImage(O,u)                                                    \\\n    vec2 R = iResolution.xy*.1, U = u/R.y;                                \\\n    U = U*5. + U.y* cos( iTime + U.x*.56 + 11.*O.xw );                    \\\n    U = max( vec4( (U-35.5)*R/5.,                                         \\\n                    R/25. - length( ( U - round(U) )                      \\\n                                   * inverse(transpose(mat2(dFdx(U),dFdy(U)) )) ) \\\n                 )*.5+.5 , 0. ).yw;                                       \\\n    O += U.x+U.y                                                         /*\n\n\n\n\n\n\n// --- 221 chars -7 by iapafoto -1 by Fab\n\n#define S(v) smoothstep(-1.,1., v).y//\n#define mainImage(O,u)                                          \\\n    vec2 R = iResolution.xy*.1, U = u/R.y;                      \\\n    U = U*5. + U.y* cos( iTime + U.x*.56 + vec2(0,11) );        \\\n    O += S( (U-35.5)*R/5. )                                     \\\n      +  S( R/25. - length( ( U - round(U) )                    \\\n                           * inverse(transpose(mat2(dFdx(U),dFdy(U)) )) ) )  /*\n//          same length:   * inverse(mat2(vec4(dFdx(U),dFdy(U)).xzyw )) ) )  /*\n\n\n\n\n\n// --- 229 chars\n\n#define S(v) smoothstep(-1.,1., v)                               //\n#define mainImage(O,u)                                            \\\n    vec2 R = iResolution.xy, U = u/R.y;                           \\\n    U = U*50. + U.y*10.* cos( iTime + U.x*5.6+vec2(0,11) );       \\\n    O += S( (U.y - 35.5)*R.y/50. )                                \\\n      +  S( R.y/250. - length(  ( U - round(U) )                  \\\n                               * inverse(transpose(mat2(dFdx(U),dFdy(U)))) ) ) /*\n\n\n\n\n\n// --- +21 ch: variant with analytical derivatives:\n\n#define S(v) smoothstep(-1.,1., v)                               //\n#define mainImage(O,u)                                            \\\n    vec2 R = iResolution.xy, V = u/R.y,                           \\\n         C = 10.*cos( iTime + V.x*5.6+vec2(0,11) ),               \\\n    U = V*50. + V.y*C;                                            \\\n    O += S( (U.y - 35.5)*R.y/50. )                                \\\n      +  S( R.y/250. - length(  ( U - round(U) )                  \\\n                               * inverse(mat2( 50.-V.y*5.6*C.y, C.x, V.y*5.6*C.x, 50.+C.y )  / R.y) ) ) /*\n               // is: mat2( 5.+C.y, -C.x, -.56*V.y*C.x, 5.-V.y*.56*C.y )  * R.y/(25.+5.*C.y-.56*V.y*(1.+5.*C.y)))  )\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 152, 152, 407]], "test": "error"}
{"id": "ttlcRN", "name": "2.5D Water Progress", "author": "salvicode", "description": "Forked from https://www.shadertoy.com/view/Mddfzr", "tags": ["2d", "reflection", "simple", "pixel", "water", "progress", "waving", "over"], "likes": 2, "viewed": 87, "published": "Public", "date": "1591591805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 drawWater(vec4 water_color, sampler2D color, float transparency, float height, float angle, float wave_strength, float wave_ratio, vec2 uv);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float WATER_HEIGHT = abs(sin(iTime * 0.5));\n    vec4 WATER_COLOR = vec4(0.5, 0.5, 0.53, 1.0);\n    float WAVE_STRENGTH = 3.0;\n    float WAVE_FREQUENCY = 8.0;\n    float WATER_TRANSPARENCY = 0.4;\n    float WATER_ANGLE = 2.0;\n    \n    fragColor = drawWater(WATER_COLOR, iChannel0, WATER_TRANSPARENCY, WATER_HEIGHT, WATER_ANGLE, WAVE_STRENGTH, WAVE_FREQUENCY, uv);\n}\n\nvec4 drawWater(vec4 water_color, sampler2D color, float transparency, float height, float angle, float wave_strength, float wave_frequency, vec2 uv)\n{\n    angle *= uv.y/height+angle/1.5; //3D effect\n    wave_strength /= 1000.0;\n    float wave = sin(10.0*uv.y+10.0*uv.x+wave_frequency*iTime)*wave_strength;\n    wave += sin(20.0*-uv.y+20.0*uv.x+wave_frequency*1.0*iTime)*wave_strength*0.5;\n    wave += sin(15.0*-uv.y+15.0*-uv.x+wave_frequency*0.6*iTime)*wave_strength*1.3;\n    wave += sin(3.0*-uv.y+3.0*-uv.x+wave_frequency*0.3*iTime)*wave_strength*10.0;\n    \n    if(uv.y - wave <= height)\n        return mix(\n        mix(\n            texture(color, vec2(uv.x, ((1.0 + angle)*(height + wave) - angle*uv.y + wave))),\n            water_color,\n            0.6-(0.3-(0.3*uv.y/height))),\n        texture(color, vec2(uv.x + wave, uv.y - wave)),\n        transparency-(transparency*uv.y/height));\n    else\n        return vec4(0,0,0,0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 202, 202, 615], [617, 617, 767, 767, 1544]], "test": "error"}
{"id": "ttlyDX", "name": "hola mundo", "author": "JacobC", "description": "A simple hello world with circles and lines", "tags": ["2d", "sdf", "helloworld", "char"], "likes": 6, "viewed": 86, "published": "Public", "date": "1593315238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 p, float r)\n{\n    return abs(length(p) - r);\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    \n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    \n    return length(pa - ba * t) - r;\n}\n\nfloat horseshoe(in vec2 p, float t, float r)\n{\n    float b = t * 3.14 * 2.;\n    float a = atan(p.y, p.x) / 3.14 * .5 + .5; \n    return (a < t) ? \n        \t\t\t\tmin(length(p + vec2(r, 0.)), \n                            length(p * mat2(cos(b), sin(b), -sin(b), cos(b)) + vec2(r, .0)))\n        \t\t\t\t:\n    \t\t\t\t\tabs(length(p) - r);\n}\n\nfloat h(in vec2 p, float s)\n{\n    p *= 1. / s;\n    \n    float l1 = line(p, vec2(-.5, 1.), vec2(-.5, -1.), .0);\n    float hs = horseshoe(p + vec2(.0, .5), .5, .5);\n    float l2 = line(p, vec2(.5, -.5), vec2(.5, -1.), .0);\n    \n    return min(l2, min(l1, hs));\n}\n\n\nfloat o(in vec2 p, float s)\n{\n    p *= 1. / s;\n    \n    return circle(p + vec2(.0, .5), .5);\n}\n\nfloat l(in vec2 p, float s)\n{\n    p *= 1. / s;\n    \n    return line(p, vec2(.0, 1.), vec2(.0, -1.), .0);\n}\n\nfloat a(in vec2 p, float s)\n{\n    p *= 1. / s;\n    \n    float c = circle(p + vec2(.0, .5), .5);\n    float l = line(p, vec2(.5, .0), vec2(.5, -1.), 0.);\n    \n    return min(c, l);\n}\n\nfloat m(in vec2 p, float s)\n{\n    p *= 1. / s;\n    \n    float l1 = line(p, vec2(-1., .0), vec2(-1.), .0);\n    float hs = horseshoe(vec2(abs(p.x)-.5, p.y + .5), .5, .5);\n    float l2 = line(p, vec2(.0, -.5), vec2(.0, -1.), .0);\n    float l3 = line(p, vec2(1., -.5), vec2(1., -1.), .0);\n    \n    return min(l3, min(l2, min(l1, hs)));\n}\n\nfloat u(in vec2 p, float s)\n{\n    p *= 1. / s;\n    \n    float l1 = line(p, vec2(-.5, .0), vec2(-.5), .0);\n    float hs = horseshoe(vec2(p.x, -p.y - .5), .5, .5);\n    float l2 = line(p, vec2(.5, .0), vec2(.5, -1.), .0);\n    \n    return min(l2, min(l1, hs));\n}\n\nfloat n(in vec2 p, float s)\n{\n    p *= 1. / s;\n    \n    float l1 = line(p, vec2(-.5, .0), vec2(-.5, -1.), .0);\n    float hs = horseshoe(p + vec2(.0, .5), .5, .5);\n    float l2 = line(p, vec2(.5, -.5), vec2(.5, -1.), .0);\n    \n    return min(l2, min(l1, hs));\n}\n\nfloat d(in vec2 p, float s)\n{\n    p *= 1. / s;\n    \n    float c = circle(p + vec2(.0, .5), .5);\n    float l = line(p, vec2(.5, 1.), vec2(.5, -1.), 0.);\n    \n    return min(c, l);\n}\n\n#define R vec3(1., .0, .0)\n#define Y vec3(1., 1., .0)\n#define G vec3(.0, 1., .0)\n#define C vec3(.0, 1., 1.)\n#define B vec3(.0, .0, 1.)\n#define M vec3(1., .0, 1.)\n#define T iTime \n#define Pi 3.14\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    float s = .1;\n    float ch = h(uv + vec2(.66, .0), s);\n    float co = o(uv + vec2(.52, .0), s);\n    float cl = l(uv + vec2(.43, .0), s);\n    float ca = a(uv + vec2(.34, .0), s);\n    \n    float cm = m(uv - vec2(.0, .0), s);\n    float cu = u(uv - vec2(.19, .0), s);\n    float cn = n(uv - vec2(.33, .0), s);\n    float cd = d(uv - vec2(.47, .0), s);\n    float co2 = o(uv - vec2(.61, .0), s);\n    \n    float c = min(ch, min(co, min(cl, min(ca, min(cm, min(cu, min(cn, min(cd, co2))))))));\n    float sc = smoothstep(.15, .2, c);\n    c = smoothstep(.05, .1, abs(fract(c-iTime)-.5));\n    \n    float a = mod(T*.25, 6.);\n    \n    vec3 CL = (a >= .0 && a < 1.) ? \t\n        \t\tmix(R, Y, a) : \n    \t\t\t(a >= 1. && a < 2.) ?\n                mix(Y, G, a - 1.) :\n    \t\t\t(a >= 2. && a < 3.) ?\n                mix(G, C, a - 2.) : \n    \t\t\t(a >= 3. && a < 4.) ?\n                mix(C, B, a - 3.) :\n    \t\t\t(a >= 4. && a < 5.) ?\n                mix(B, M, a - 4.) :\n    \t\t\tmix(M, R, a- 5.);\n    \n    col += mix(CL, vec3(1.), min(c, sc)) + .5;\n    \n    fragColor = vec4(sqrt(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 67], [69, 69, 123, 123, 269], [271, 271, 317, 317, 596], [598, 598, 627, 627, 858], [861, 861, 890, 890, 955], [957, 957, 986, 986, 1063], [1065, 1065, 1094, 1094, 1245], [1247, 1247, 1276, 1276, 1580], [1582, 1582, 1611, 1611, 1840], [1842, 1842, 1871, 1871, 2102], [2104, 2104, 2133, 2133, 2284], [2482, 2482, 2539, 2539, 3701]], "test": "ok"}
{"id": "ttlyWn", "name": "Mandelbrot  set", "author": "changjiu", "description": "Mandelbrot Set", "tags": ["mandelbrot"], "likes": 2, "viewed": 210, "published": "Public API", "date": "1591848642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 pow2(vec2 n){\n\tfloat x = n.x*n.x-n.y*n.y;\n    float y = 2.0*n.x*n.y;\n\treturn vec2(x,y);\n}\n\nvec2 plus(vec2 n, vec2 m){\n\tfloat x = n.x+m.x;\n    float y = n.y+m.y;\n\treturn vec2(x,y);\n}\n\nvec2 pow2plus(vec2 n, vec2 m){\n\tvec2 p2 = pow2(n);\n    vec2 result = plus(p2,m);\n\treturn result;\n}\n\n\nfloat isInMandelbrot(float x, float y){\n    vec2 z0 = vec2(0.0,0.0);\n    vec2 m = vec2(x,y);\n    vec2 zn = z0;\n    for(int i=0; i<60; i++){\n        zn = pow2plus(zn,m);\n    }\n    \n\treturn length(zn);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    \n\tfloat t = mod(iTime,47.), v=0.;\n    t = min(t, 47.-t);\n    float  scale = 1./(pow(t,t/6.));\n\n    vec2  R = iResolution.xy, U;\n    O -= O;\n\n    for (int k=0; k<9;k++) { \n        U  = ( u+.33*vec2(k%3-1,k/3-1) - .5* R ) / R.y*scale;\n        v  = isInMandelbrot(U.x-0.7652, U.y+0.1);\n        O +=  sin(3.14*v);\n    }\n    O = .5 + .5* O/9.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 94], [96, 96, 122, 122, 186], [188, 188, 218, 218, 286], [289, 289, 328, 328, 490], [492, 492, 530, 530, 875]], "test": "timeout"}
{"id": "ttlyzf", "name": "Complex Function Graph", "author": "amhall", "description": "Graphs a complex function f(z), where output is colored based on angle and distance (capped at 1.0) from the origin, and time.\n\nEdit the function f(z) (line 47) to graph your own equations! I provided some helper functions for complex operations.", "tags": ["2d", "graph", "function", "complex"], "likes": 5, "viewed": 133, "published": "Public", "date": "1592705814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Anthony Hall, June 2020\n\nconst float pi = radians(180.0);\nconst int SUPERSAMPLE = 3; // Decrease to speed things up, increase to reduce aliasing\nconst int samples = SUPERSAMPLE * SUPERSAMPLE;\nconst float increment = 1.0 / float(SUPERSAMPLE);\nconst float offset = increment / 2.0 - 0.5;\n\n// By default, the graph is such that the minimum screen dimension\n// corresponds to [-1.0, 1.0]\n// Change this vector to change the scale of the real and imaginary axes respectively\nconst vec2 SCALE = vec2(4.0, 4.0);\n\n// This is the coordinate of the graph that corresponds to\n// the center of the screen\nconst vec2 CENTER = vec2(0.0, 0.0);\n\n// Scale the speed with which the hue shifts with time\n// At 1.0, it cycles every 6 seconds\nconst float colorShift = 1.0;\n\n// Scale the speed with which the layer effect shifts with time\n// At 1.0, it cycles every 2 seconds\nconst float layerShift = 1.0;\n\n// The intensity of the magnitude-based layer effect\nconst float layerIntensity = 0.5;\n\n// *** These are the complex operations available! ***\n\n// Multiplies two complex numbers, c1 * c2\nvec2 complexMultiply(vec2 c1, vec2 c2);\n\n// Divides two complex numbers, c1 / c2\nvec2 complexDivide(vec2 c1, vec2 c2);\n\n// Divides a float by a complex number, f / c\nvec2 complexDivide(float f, vec2 c);\n\n// Takes the natural logarithm of a complex number, ln(c)\nvec2 complexLog(vec2 c);\n\n// Raises e to a complex power, e^c\nvec2 complexExp(vec2 c);\n\n// Raises a complex number to a complex power, c^exponent\nvec2 complexPow(vec2 c, vec2 exponent);\n\n// Sine of a complex number\nvec2 complexSin(vec2 c);\n\n// Cosine of a complex number\nvec2 complexCos(vec2 c);\n\n// Tangent of a complex number\nvec2 complexTan(vec2 c);\n\n// *** This is the function that we are graphing ***\n// The input and output are both complex numbers\nvec2 f(vec2 z)\n{\n    // sin(cos(tan(z))), offset, rotated, and scaled\n    z /= 1.6; return complexSin(complexCos(complexTan((z.yx / 6.0) + vec2(4.7, 0.0)))); \n    \n    // Here are some of my other favorites:    \n    \n\t// Mandelbrot - Append '*/' to next line to uncomment\n    /* \n    z = z / 3.7 - vec2(0.6, 0.0);\n    vec2 C = z;\n    for (int i = 0; i < 22; i++) \n        z = complexMultiply(z, z) + C;\n    \n    return z;\n    /**/\n    \n    // Julia, travelling around main cardioid\n    // It takes a lot of iterations to get good detail on the spirals\n    // so it is a good idea to reduce the supersampling (see top)\n    // Append '*/' to the next line to uncomment\n    /* \n\tz = z / 3.0;// - vec2(0.6, 0.0);\n    \n    float time = iTime / 32.0;\n    vec2 C = vec2(cos(time), sin(time))/2.0 - vec2(cos(time * 2.0), sin(time * 2.0))/4.; \n    \n    for (int i = 0; i < 100; i++) \n        z = complexMultiply(z, z) + C;\n    \n    return z * 1.3; // Brighten the coloring a bit\n    /**/\n    \n    // cos(sin(sin(z)))\n    // return complexCos(complexSin(complexSin(z)));\n    \n    // e^sin( (z+1)/z ), scaled \n    // z /= 5.0; return complexExp(complexSin(complexDivide(z + 1.0, z)));\n    \n    // 2 sin(time) / (z*(z + <cos(time), sin(time)>)) yields a cool orbit effect\n    // z /= 2.0; return 2.0 * complexDivide(sin(iTime), complexMultiply(z, z + vec2(cos(iTime), sin(iTime)))); \n}\n\n// Interpolates t as a percentage between a and b\n// t is clamped between 0 and 1\nfloat reverseLerp(float t, float a, float b) {\n    float p = (t - a) / (b - a);\n    return clamp(p, 0.0, 1.0);\n}\n\n// Gets a generic color wheel value given an angle\n// Theta is in degrees\nfloat colorWheelValue(float theta) {\n    theta = mod(theta - 60.0 * colorShift * iTime, 360.0);\n    \n    if (theta < 180.0)\n        return reverseLerp(theta, 120.0, 180.0);\n    else\n        return reverseLerp(theta, 360.0, 300.0);\n}\n\n// Converts a complex point to its place on the color wheel\nvec3 getColorFromPoint(vec2 point) {\n    // Uncomment this line to sample a texture instead of coloring normally\n    // return texture(iChannel0, point / 20.0 + iTime / 50.0).xyz;\n    \n    // Make infinity, nan and x = 0 black (so atan doesnt divide by 0)\n    if (isinf(point.x) || isinf(point.y) ||\n        isnan(point.x) || isnan(point.y) ||\n        point.x == 0.0)\n        \n        return vec3(0.0);\n    \n    // Solve for angle to point then convert to degrees\n    float theta = degrees(atan(point.y, point.x)); \n\n    // Each color component is just a colorWheelValue function at a different offset\n \tvec3 baseColor =  vec3(\n        colorWheelValue(theta + 240.0),\n        colorWheelValue(theta),\n        colorWheelValue(theta + 120.0));\n    \n    // Layer color based on log of magnitude, and\n    // darken color for magnitudes less than 1\n    float magnitude = length(point);\n    float layer = mod(log(magnitude) + layerShift * iTime / 2.0, 1.0); // Calculate layer percentage\n    layer = mix(1.0, layer, layerIntensity); // Transform based on layer intensity\n    return baseColor * clamp(magnitude, 0.0, 1.0) * layer;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minDimension = min(iResolution.x, iResolution.y);\n    \n    vec3 color = vec3(0.0);\n    \n    // Supersample\n    for (int j = 0; j < SUPERSAMPLE; j++) {\n        for (int i = 0; i < SUPERSAMPLE; i++) {\n         \tvec2 screenCoord = fragCoord + offset + increment * vec2(float(i), float(j));\n            \n            // Transform screen coord so minimum dimension is on interval \n            vec2 coord = (2.0 * screenCoord - iResolution.xy) / minDimension;\n\n            // Transform coord to account for user-defined scale and center\n            coord = coord*SCALE + CENTER;\n\n            // The output of the complex equation f(z)\n            vec2 fz = f(coord);\n\n            color += getColorFromPoint(fz);\n        }\n    }\n    \n    // Average the samples\n    color /= float(samples);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n// *** Complex operation implementations ***\n\n// c1 * c2\nvec2 complexMultiply(vec2 c1, vec2 c2) {\n    return vec2(\n    \tc1.x*c2.x - c1.y*c2.y,\n    \tc1.x*c2.y + c1.y*c2.x);\n}\n\n// c1 / c2\nvec2 complexDivide(vec2 c1, vec2 c2) {\n    // c1/(a + bi) = c1*(a - bi)/(a^2 + b^2)\n    vec2 numerator = complexMultiply(c1, vec2(c2.x, -c2.y));\n    float denominator = c2.x*c2.x + c2.y*c2.y;\n    \n    return numerator / denominator;\n}\n\n// f / c\nvec2 complexDivide(float f, vec2 c) {\n \t// f/(a + bi) = f*(a - bi)/(a^2 + b^2)\n    vec2 numerator = f * vec2(c.x, -c.y);\n    float denominator = c.x*c.x + c.y*c.y;\n    \n    return numerator / denominator;\n}\n\n// log(c)\nvec2 complexLog(vec2 c) {\n\t// ln(c) = ln(||c||) + i*arg(c)\n    return vec2(0.5 * log(dot(c, c)), atan(c.y, c.x));\n}\n\n// e^c\nvec2 complexExp(vec2 c) {\n    // e^(a + bi) = e^a * (cos b + i*sin b)\n    return exp(c.x) * vec2(cos(c.y), sin(c.y));\n}\n\n// c^exponent\nvec2 complexPow(vec2 c, vec2 exponent) {\n \t// c^exponent = e^(exponent * ln(c))\n    return complexExp(complexMultiply(exponent, complexLog(c)));\n}\n\n// sin(c)\nvec2 complexSin(vec2 c) {\n    // sin(a + bi) = sin a * cosh b + i*cos a * sinh b\n    return vec2(sin(c.x) * cosh(c.y), cos(c.x) * sinh(c.y));\n}\n\n// cos(c)\nvec2 complexCos(vec2 c) {\n    // cos(a + bi) = cos a * cosh b + i*sin a * sinh b\n    return vec2(cos(c.x) * cosh(c.y), sin(c.x) * sinh(c.y));\n}\n\n// tan(c)\nvec2 complexTan(vec2 c) {\n    // tan(a + bi) = (sin 2a + i*sinh 2b) / (cos 2a + cosh 2b)\n    return vec2(sin(2.0*c.x), sinh(2.0*c.y)) / (cos(2.0*c.x) + cosh(2.0*c.y));\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1702, 1804, 1820, 1873, 3177], [3179, 3261, 3307, 3307, 3373], [3375, 3449, 3485, 3485, 3681], [3683, 3743, 3779, 3998, 4867], [4869, 4869, 4926, 4926, 5779], [5827, 5838, 5878, 5878, 5954], [5956, 5967, 6005, 6050, 6201], [6203, 6212, 6249, 6290, 6418], [6420, 6430, 6455, 6488, 6545], [6547, 6554, 6579, 6623, 6673], [6675, 6689, 6729, 6768, 6835], [6837, 6847, 6872, 6927, 6990], [6992, 7002, 7027, 7082, 7145], [7147, 7157, 7182, 7245, 7326]], "test": "error"}
{"id": "ttscD8", "name": "Taiel", "author": "Kali", "description": "My son Taiel", "tags": ["music", "drawing", "pixelart"], "likes": 22, "viewed": 268, "published": "Public", "date": "1592294151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define blend(c,b) mix(c.rgb,b.rgb,b.a)\n#define shape(d,s) smoothstep(s,0.,d)\n#define skin_color vec3(.8,.6,.5)\n#define eyes_color vec3(.35,.25,.1)\n#define lips_color vec3(.8,.45,.4)\n#define hair_color vec3(.07,.0,.0)\n#define headphones_color vec3(.0,.2,.4)\n#define background_color vec3(1.,.2,.0)\n\n\nfloat box(vec2 p, vec2 c) {\n\treturn length(max(vec2(0.),abs(p)-c));\n}\n\n\nvec4 head(vec2 p) \n{\n\tp*=.77;\n \tp.x*=.94-p.y*p.y;\n    p.x*=1.45;\n    p.x*=1.-p.y*.9;\n    p.x*=1.-smoothstep(-.05,.1,-p.y)*.05;\n    p.x*=1.+smoothstep(0.1,.4,-p.y)*.15;\n    float d=length(p)-.3;\n    return vec4(skin_color-d*.7,shape(d,.01));\n}\n\nvec4 neck(vec2 p) \n{\n    float d=p.x-.175-sin(p.y*30.+15.)*.02;\n    return vec4(skin_color*.8,shape(d,.01));\n}\n\nvec4 headphones(vec2 pos) \n{\n    vec2 p=pos;\n    p.x=abs(p.x);\n    p.x-=.28+p.y*p.y;\n    p.x*=1.5;\n    float d1=length(p)-.11;\n    p.x-=.1;\n    p.x*=2.;\n    float d2=length(p)-.05;\n    p=pos;\n\tp.x+=.37+sin(p.y*20.+4.)*.03+p.y*.3;\n    float d3=abs(p.x)-.001;\n    d3=max(d3,p.y);\n    return vec4(headphones_color-min(0.,d1*4.)-shape(d2,.01)*.1-shape(d3,.01)*.2,shape(min(min(d1,d2),d3),.01));\n}\n\n\nvec4 eyes(vec2 pos) \n{\n\tpos.y-=.0;\n    vec3 c=vec3(1.);\n    pos.x-=.145;\n    vec2 p=pos;\n    p.y*=1.5+p.x*p.x*20.;\n    p.y+=smoothstep(0.05,.1,-p.x)*.05;\n    p.y=abs(p.y-.05)+.055;\n    float d1=length(p)-.09;\n    c-=abs(1.-shape(d1+.01,.015))*.4;\n    p=pos;\n    p.y-=.045;\n    float d2=length(p)-.03;\n    float d3=length(p)-.012;\n    c=mix(c,eyes_color,shape(d2,.01));\n    c*=1.-shape(d3,.015);\n    p+=.005;\n    float d4=length(p)-.003;\n    c+=shape(d4,0.01)*.5;\n    return vec4(c,shape(d1,.01));\n}\n\nfloat eyelids(vec2 pos) \n{\n    vec2 p=pos;\n    p.x-=.135;\n    p.y-=.085-p.x*p.x*7.+p.x*.25;\n    p.y*=15.;\n\tfloat d1=length(p)-.07;\n    p=pos;\n    p.x-=.155;\n    p.y-=.06-p.x*p.x*5.;\n    p.y*=15.;\n\tfloat d2=length(p)-.07;\n    p=pos;\n    p.x-=.15;\n    p.x*=.8;\n    p.y+=.01-p.x*p.x*7.;\n    p.y*=15.;\n\tfloat d3=length(p)-.07;\n    return shape(d1,.01)*.15+shape(d2,.03)*.5+shape(d3,.01)*.03;\n}\n\nfloat eyebrows(vec2 p) \n{\n\tp.x-=.135+p.x*.2;\n    p.y-=.13-p.x*p.x*4.-smoothstep(.03,.1,p.x)*.03;\n    p.y*=6.;\n    float d=length(p)-.05;\n    return shape(d,.04)*.7*(.5+fract(p.x*100.+p.y*10.)*.5);\n}\n\nfloat nose(vec2 pos) \n{\n    vec2 p=pos;\n    p*=.9;\n    p.y-=p.x*p.x*3.;\n    p.x*=smoothstep(0.,.05,p.x);\n    p.y+=.16+cos(p.x*90.)*.005;\n    p.y*=15.;\n\tfloat d1=length(p)-.08;\n    p=pos;\n    p.x-=.047;\n    p.y+=.17;\n    p.y*=2.;\n    float d2=length(p)-.005;\n    p=pos;\n    p.y+=.02;\n    p.x-=.045+p.y*p.y*3.;\n    p.x*=10.;\n    float d3=length(p)-.05;\n    return shape(d1,.01)*.1+shape(d2,.03)*.15+shape(d3,.1)*.04;\n}\n\nfloat mouth(vec2 p) \n{\n \tp.y+=.27+cos(p.x*45.)*.005-p.x*p.x*2.-smoothstep(.1,.2,p.x)*.07;\n    p.y*=20.;\n    float d=length(p)-.13;\n    return shape(d,.01)*.2;\n}\n\n\nvec4 lips(vec2 pos) \n{\n    vec2 p=pos;\n    p.y+=.29-p.x*p.x*3.;\n    p.y-=smoothstep(.05,.07,p.x)*.01;\n    p.y*=10.;\n    float d1=length(p)-.12;\n    p=pos;\n    p.y+=.27-p.x*p.x*3.;\n    p.y+=smoothstep(.05,.07,p.x)*.01;\n    p.y*=8.;\n    float d2=length(p)-.12;\n    return vec4(lips_color,shape(min(d1,d2),.01));\n}\n\nvec4 hair(vec2 pos) {\n    vec2 p=pos;    \n    p.x-=.14-p.y*p.y*.3-smoothstep(.25,.6,p.y)*.1;\n    p.x-=p.y*p.y*smoothstep(0.,.3,-p.x)*2.+sin(p.y)*.2;\n    p.y-=.28-p.x*p.x+fract(p.x*20.+p.y*5.)*.1+fract(p.x*10.)*.05-p.x*.5;\n\tfloat d1=box(p,vec2(.2,.25));\n    float h=fract(p.x*40.)*shape(d1,.01);\n    p=pos;\n\tp.x*=-1.;\n    p.x-=.17-p.y*p.y*.3-smoothstep(.22,.7,p.y)*.2;\n    p.x-=p.y*p.y*smoothstep(0.,.3,-p.x)*2.+sin(p.y)*.2;\n    p.y-=.29-p.x*p.x*.5+fract(p.x*15.+p.y*2.+.3)*.1+fract(p.x*20.)*.05-p.x*.5;\n\tfloat d2=box(p,vec2(.16,.25));\n    h+=fract(p.x*40.)*shape(d2,.01);\n    return vec4(hair_color,shape(min(d1,d2),.02));\n}\n\n\nfloat lighting(vec2 pos) {\n    vec2 p=pos;\n    p.y+=.14;\n    p.y*=1.2;\n    p.x*=.8;\n\tfloat d1=length(p)-.01;\n    p.x-=.12;\n    p.y*=1.;\n\tfloat d2=length(p)-.01;\n    p=pos;\n    p.y+=.19+cos(p.x*10.)*.07;\n    p.y*=2.5;\n\tfloat d3=length(p)-.05;\n    p=pos;\n    p.y-=0.04;\n    p.x-=.14;\n    p.y*=1.5;\n\tfloat d4=length(p)-.05;\n    p=pos;\n    p.y-=0.05;\n    p.x*=4.;\n\tfloat d5=length(p*p)+.075;\n    p=pos;\n    p.y+=.24-p.x*.2;\n\tp.x*=.4;\n    float d6=length(p)-.001;\n    p=pos;\n    p.y+=.36-p.x*.4;\n\tp.x*=.4;\n    float d7=length(p)-.01;\n    return shape(d1,.05)*.2+shape(d2,.1)*.1+shape(d3,.1)*.15-shape(d4,.12)*.2+shape(d5,.1)*.7-shape(d6,.02)*.12+shape(d7,.05)*.2;\n}\n\nvec3 background(vec2 p) {\n    float x=1.-p.x*p.x*5.;\n    vec2 id=floor(p*15.);\n\tp=fract(p*15.)-.5;\n    float d=shape(length(p)-.4,.2)*.8;\n    float l=shape(length(p)-.2,.1)*.5;\n    vec3 c=background_color*d+l;\n    c*=fract(cos(iTime+dot(id.x,id.y)));\n    return c*d+x*background_color;\n}\n\n\nvec3 render(vec2 p) \n{\n    p*=.73;\n\tvec2 pos=p;\n    p.x=abs(p.x);\n\tvec3 c=background(pos)*smoothstep(2.,3.,iTime);\n    c=blend(c,neck(p));\n    c=blend(c,headphones(pos));\n    c=blend(c,head(p));\n    c=blend(c,eyes(p));\n    c=blend(c,lips(p));\n    c-=nose(p);\n    c-=eyelids(p);\n    c-=eyebrows(p);\n    c-=mouth(p);\n    c+=lighting(p);\n    c=blend(c,hair(pos));\n    return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tuv=floor(uv*130.)/130.;\n    vec3 col = render(uv);\n\tcol*=mod(gl_FragCoord.y,4.)*.35*min(1.,iTime/2.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4t23R3", "previewfilepath": "https://soundcloud.com/beccabear17/twenty-one-pilots-screen", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/beccabear17/twenty-one-pilots-screen", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttscD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 327, 327, 369], [372, 372, 392, 392, 614], [616, 616, 636, 636, 726], [728, 728, 756, 756, 1120], [1123, 1123, 1145, 1145, 1621], [1623, 1623, 1649, 1649, 2012], [2014, 2014, 2039, 2039, 2212], [2214, 2214, 2237, 2237, 2630], [2632, 2632, 2654, 2654, 2792], [2795, 2795, 2817, 2817, 3106], [3108, 3108, 3129, 3129, 3732], [3735, 3735, 3761, 3761, 4395], [4397, 4397, 4422, 4422, 4684], [4687, 4687, 4709, 4709, 5063], [5067, 5067, 5124, 5124, 5319]], "test": "error"}
{"id": "ttscRN", "name": "XOR ^ n", "author": "FabriceNeyret2", "description": "effect of bitwise operators XOR, AND, OR once powered to 1,2,3,4 (from left to right )\nStrange how Xor \"hashes\" into circuit-like patterns.\n\nsee also [url]https://shadertoy.com/view/wllcRN[/url]", "tags": ["xor", "pattern", "hash", "bitwise", "circuits"], "likes": 5, "viewed": 248, "published": "Public API", "date": "1591598625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/wllcRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy;\n    ivec2 I = ivec2(U+60.*iTime);\n    int t = int(iTime) % 3, \n        n = int(U.x/R.x*4.),\n        i =   t==1 ? I.x ^ I.y\n            : t==2 ? I.x | I.y\n            :        I.x & I.y;\n                 //  I.x * I.y;\n    \n    i = n==0 ? i : n==1 ? i*i : n==2 ? i*i*i : i*i*i*i; \n    float v = float( i );\n\n    O = vec4( fract( v / 256.) );\n    \n    if ( int(U.x)*4 % int(R.x) < 4 ) O.r++; // red separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttscRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 526]], "test": "ok"}
{"id": "ttsyD2", "name": "Flipping triangles", "author": "Oggbog", "description": "Supposed to represent triangles being rotated on the diagonal axis. \n", "tags": ["triangle"], "likes": 3, "viewed": 238, "published": "Public API", "date": "1593177735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat t(vec2 uv, float a){\n   \n   \tfloat d = step(uv.y,1.+tan(-PI/2.+a)*(1.-uv.x));\n    float b = step(uv.y,uv.x*tan(a));\n\n    if(a>PI/4.){\n    \td *= b;\n    } else {\n        d += b;\n    }\n            \n  \treturn clamp(d,0.,1.);    \n}\n\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    p = p/iResolution.y;\n    \n    vec2 pos = fract(p*12.);\n    vec2 id = floor(p*12.);\n    \n    float a = (id.x-id.y)/15.-iTime*.5;\n    \n    float ti = PI*fract(a)/2.;\n    \n    float d = t(pos, ti);\n    \n    a = floor(mod(a,2.));\n    \n    d = mod(a + d, 2.);   \n       \n    c = vec4(vec3(1.0-abs(d)),1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 46, 46, 252], [255, 255, 296, 296, 614]], "test": "ok"}
{"id": "ttsyDB", "name": "mod thundercloud", "author": "Carandiru", "description": "modification of : https://www.shadertoy.com/view/3dcXWS\noriginally by mahalis", "tags": ["storm", "thunder"], "likes": 8, "viewed": 353, "published": "Public API", "date": "1593009051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// modification of - https://www.shadertoy.com/view/3dcXWS by mahalis\n// except where otherwise noted, this code is CC BY-NC https://creativecommons.org/licenses/by-nc/4.0/\n\n// ------\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\n// returns a pair of values for the distances along the ray at which there are sphere intersections, or 0 if none\nvec2 sphereIntersectionDistances(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius) {\n    vec3 toCenter = sphereOrigin - rayOrigin;\n    float toCenterAlongRay = dot(toCenter, rayDirection);\n    \n    float perpendicularDistanceSquared = dot(toCenter, toCenter) - toCenterAlongRay * toCenterAlongRay;\n    float radiusSquared = sphereRadius * sphereRadius;\n    \n    if (perpendicularDistanceSquared > radiusSquared) { // ray doesn’t touch the sphere\n        return vec2(0.);\n    }\n    \n    float insideSphereAlongRay = sqrt(radiusSquared - perpendicularDistanceSquared); // half the length of the portion of the ray inside the sphere\n    \n    float intersection1 = toCenterAlongRay - insideSphereAlongRay;\n    float intersection2 = toCenterAlongRay + insideSphereAlongRay;\n    if (intersection1 > intersection2) {\n        float t = intersection1;\n        intersection1 = intersection2;\n        intersection2 = t;\n    }\n    \n    if (intersection1 < 0.) { // first intersection is before the start of the ray\n        if (intersection2 < 0.) { // ditto second, though that… shouldn’t happen?\n            return vec2(0.);\n        } else {\n            intersection1 = intersection2;\n            intersection2 = 0.;\n        }\n    }\n    \n    return vec2(intersection1, intersection2);\n}\n\n// -----------------\n\n// 3d noise by iq, from https://www.shadertoy.com/view/Xsl3Dl\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n// hash functions by David Hoskins, from https://www.shadertoy.com/view/4djSRW\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\n\n// -----------------\n\nfloat octavedNoise(vec3 position) {\n    vec3 samplePosition = position * 2.;\n    float noiseAmount = noise(samplePosition + iTime * vec3(0.0,0.2,0.0));\n    samplePosition *= 1.99;\n    noiseAmount += noise(samplePosition + iTime * vec3(0.05,-0.37,0.02)) * 0.51;\n    noiseAmount /= 1.51;\n    return noiseAmount;\n}\n\nfloat density(vec3 position) {\n    float baseValue = 1.0 - pow(max(0.0, length(position) * 0.5f), 2.0);\n    float noiseAmount = octavedNoise(position);\n    \n    return max(0.,min(1.,baseValue - max(0.,noiseAmount * 1.5)));\n}\n\nvec4 innerLightPositionAndIntensity() {\n    float scaledTime = iTime * 6.1;\n    float hashInput = floor(scaledTime) * 0.1;\n    \n    if (hash11(hashInput) < 0.75) return vec4(0.); // mask out most of the flashes\n        \n    vec3 hash = hash31(hashInput);\n    float theta = hash.x * 6.283;\n    float z = hash.y * 2. - 1.;\n    float sinPhi = sin(acos(z));\n    vec3 position = vec3(sinPhi * cos(theta), sinPhi * sin(theta), z) * (0.6 + hash.z * 0.2);\n    \n    float intensity = sin(fract(scaledTime) * 3.142);\n    \n    return vec4(position, intensity);\n}\n\n\n// marching logic adapted from Ryan Brucks's article here: https://shaderbits.com/blog/creating-a-volumetric-ray-tracer\n\nvec4 march(vec3 origin, vec3 direction) {\n    \n    const int mainSteps = 30;\n    const int shadowSteps = 10;\n    const vec3 toLight = normalize(vec3(1.0,1.0,0.));\n    const float mainDensityScale = 1.5;\n    \n    const float shadowingThreshold = 0.001;\n    const float shadowDensityScale = 3.;\n    \n    vec3 light = vec3(0.);\n    float transmittance = 1.;\n    \n    vec3 samplePosition = origin;\n   \n    const float mainStepLength = 2. / float(mainSteps); // why does lowering this below 2 change the appearance?\n    const float shadowStepLength = 1. / float(shadowSteps);\n    \n    const vec3 scaledShadowDensity = shadowDensityScale * shadowStepLength / vec3(0.8,0.7,1.0);\n    \n    const float shadowConstant = -log(shadowingThreshold) / scaledShadowDensity.z;\n    \n    const vec3 mainLightColor = vec3(0.6,0.8,1.);\n    const vec3 innerLightColor = vec3(0.7,0.4,1.) * 4.;\n    \n    vec3 mainStepAmount = direction * mainStepLength;\n    \n    vec3 shadowStepAmount = toLight * shadowStepLength;\n    \n    vec4 innerLight = innerLightPositionAndIntensity();\n    \n    for(int i = 0; i < mainSteps; i++) {\n        float localDensity = min(1.0, density(samplePosition) * mainDensityScale);\n        if (localDensity > 0.001) {\n            \n            // - main light (directional)\n            \n            vec3 shadowSamplePosition = samplePosition;\n            float shadowAccumulation = 0.;\n            for(int j = 0; j < shadowSteps; j++) {\n                shadowSamplePosition += shadowStepAmount;\n                \n                shadowAccumulation += min(1.0, density(shadowSamplePosition) * shadowDensityScale);\n                if (shadowAccumulation > shadowConstant || dot(shadowSamplePosition, shadowSamplePosition) > 1.) break;\n            }\n            \n            vec3 shadowTerm = exp(-shadowAccumulation * scaledShadowDensity);\n            float stepDensity = min(1.,localDensity * mainStepLength);\n            vec3 absorbedLight = shadowTerm * stepDensity;\n            \n            // accumulate directional light\n            light += absorbedLight * transmittance * mainLightColor;\n            \n            \n            // - inner light (point)\n            \n            shadowSamplePosition = samplePosition;\n            shadowAccumulation = 0.;\n            vec3 toInnerLight = innerLight.xyz - samplePosition;\n            vec3 innerLightShadowStepAmount = normalize(toInnerLight) * shadowStepLength;\n            \n            for(int j = 0; j < shadowSteps; j++) {\n                shadowSamplePosition += innerLightShadowStepAmount;\n                \n                shadowAccumulation += min(1.0, density(shadowSamplePosition) * shadowDensityScale);\n                \n                // bail out if we’ve accumulated enough or if we’ve gone outside the bounding sphere (squared length of the sample position > 1)\n                if (shadowAccumulation > shadowConstant || dot(shadowSamplePosition, shadowSamplePosition) > 1.) break;\n            }\n            \n            shadowTerm = exp(-shadowAccumulation * scaledShadowDensity);\n            stepDensity = min(1.,localDensity * mainStepLength);\n            absorbedLight = shadowTerm * stepDensity;\n            \n            // inverse-squared fade of the inner point light\n            float attenuation = min(1.0, 1.0 / (dot(toInnerLight, toInnerLight) * 2. + 0.0001)) * innerLight.w;\n            \n            // accumulate point light\n            light += absorbedLight * (transmittance * attenuation) * innerLightColor;\n            \n            // -\n            \n            transmittance *= (1. - stepDensity);\n\n            if (transmittance < 0.01) {\n                break;\n            }\n        }\n        \n        samplePosition += mainStepAmount;\n    }\n    \n    return vec4(vec3(light), transmittance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cameraPosition = rY(vec3(0.0, 0.1, 1.0) * 2.5, iTime * 0.9);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n    \n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 2.0 * cameraForward);\n    \n    // closest and farthest intersections, if any, with the bounding sphere\n    vec2 rayDistances = sphereIntersectionDistances(cameraPosition, rayDirection, vec3(0.), 1.85);\n    \n    vec3 backgroundColor = vec3(0.1) - length(uv) * 0.04; // vignette\n    \n    float bn = texture(iChannel0, uv).r;\n    \n    vec3 color;\n    if (rayDistances.x != 0. && rayDistances.y != 0.) {\n        vec3 farIntersection = cameraPosition + rayDirection * rayDistances.y * 0.5f\n        \t\t\t\t\t\t+ rayDirection * rayDistances.y * 0.5f * bn * (7.0f/255.0f);\n        vec4 value = march(farIntersection, -rayDirection);\n        color = mix(value.rgb, backgroundColor, value.w);\n        \n    } else {\n        color = backgroundColor;\n    }\n    \n    float luminance = dot(color, LUMA);\n    color = color * color;\n    float new_luminance = dot(color, LUMA);\n    \n    float purple = color.b * (luminance - new_luminance);\n    color = color * luminance / new_luminance;\n    color.r += purple * purple;\n    \n    float dither = bn * (17.0f/255.0f);\n    color = mix(color - dither, color + dither, luminance);\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyDB.jpg", "access": "shaders20k", "license": "cc-by-2.5", "functions": [[231, 231, 257, 257, 397], [399, 513, 621, 621, 1818], [2984, 2984, 3005, 3005, 3174], [3176, 3176, 3202, 3202, 4027], [4187, 4187, 4210, 4210, 4295], [4297, 4297, 4319, 4319, 4458], [4483, 4483, 4518, 4518, 4794], [4796, 4796, 4826, 4826, 5020], [5022, 5022, 5061, 5061, 5573], [5697, 5697, 5738, 5738, 9472], [9474, 9474, 9531, 9531, 11153]], "test": "error"}
{"id": "ttsyDs", "name": "test 111", "author": "indere", "description": "test111", "tags": ["test111"], "likes": 2, "viewed": 160, "published": "Public API", "date": "1593499954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float trunct(float x, float num_levels)\n{\n    return floor(x * num_levels) / num_levels;\n}\n\nfloat randomNoise(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat myRandomColor(vec2 uv, float scale){\n\treturn fract(sin(dot(floor(uv * scale), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random1D(float p){\n\treturn fract(sin(p) * 100000.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float uv_color =  myRandomColor(uv.yy + trunct(iTime, 4.0), 4.0);\n    \n    //try 1.0 and 2.0\n    // 1.0 only time Related\n    // 2.0 both time and uv coord Related\n    \n    //1.0\n    //float uv_offset = random1D(iTime * 0.01) * 0.1;\n    //2.0\n    float uv_offset = trunct(iTime, 24.0 * uv_color) * 6.;\n    \n    //生成随机非均匀宽度线条\n    float blockLine_random = 0.5 * myRandomColor(uv.yy + uv_offset, 6.0);\n    blockLine_random += 0.5 * myRandomColor(uv.yy + uv_offset, 10.0);\n    blockLine_random = blockLine_random * 2. - 1.0;\n    \n    fragColor = vec4(vec3(blockLine_random), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 90], [92, 92, 120, 120, 190], [192, 192, 234, 234, 316], [318, 318, 342, 342, 378], [380, 380, 437, 487, 1134]], "test": "ok"}
{"id": "ttsyR4", "name": "shining honeycomb", "author": "darkfox", "description": "colorful hexagonal tiling.", "tags": ["tiling"], "likes": 4, "viewed": 69, "published": "Public", "date": "1591573962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// hexagonal tiling.\n\n// constants.\nconst float pi = 3.14159;\nconst float SCALE = 0.15;\nconst float ROTATION_SPEED = 0.5;\n\n// hsb to rgb.\nvec3 getRGB(float h, float s, float b){\n  vec3 c = vec3(h, s, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// seed hexagonal cell and get color.\nvec3 hexa(vec2 p, float a){\n  // lattice (e1 =(a, 0.0), e2 = (a * 0.5, a * sqrt(3.0) / 2.0))\n  float s = p.x / a - p.y / (sqrt(3.0) * a);\n  float t = 2.0 * p.y / (sqrt(3.0) * a);\n  vec2 q = vec2(s, t);\n  vec2 i = floor(q);\n  vec2 f = fract(q);\n  // search the center of cell.\n  vec2 cell_i;\n  vec2 g = vec2(2.0 * f.x + f.y, f.x + 2.0 * f.y);\n  if(g.x < 1.0 && g.y < 1.0){\n    cell_i = i;\n  }else if(g.x > 2.0 && g.y > 2.0){\n    cell_i = i + vec2(1.0, 1.0);\n  }else{\n    if(f.x > f.y){ cell_i = i + vec2(1.0, 0.0); }else{ cell_i = i + vec2(0.0, 1.0); }\n  }\n  vec2 e1 = vec2(a, 0.0);\n  vec2 e2 = vec2(a * 0.5, a * 0.5 * sqrt(3.0));\n  vec2 cell = cell_i.x * e1 + cell_i.y * e2; // center.\n  vec2 u0 = vec2(1.0, 0.0);\n  vec2 u1 = vec2(0.5, sqrt(3.0) * 0.5);\n  vec2 u2 = vec2(-0.5, sqrt(3.0) * 0.5);\n  // calc distance.\n  float d = abs(dot(p - cell, u0));\n  d = max(d, abs(dot(p - cell, u1)));\n  d = max(d, abs(dot(p - cell, u2)));\n  d *= 2.0 / a; // scaling to 0.0～1.0\n  d = d * d;\n  return getRGB(cell_i.x * 0.02 + mod(iTime * 0.1, 1.0), 1.0 - d, 0.93);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  float t = iTime * ROTATION_SPEED;\n  mat2 m = mat2(cos(t), sin(t), -sin(t), cos(t));\n  p = m * p;\n  vec3 color = hexa(p, SCALE);\n  float diff = abs(p.x * p.y) * 0.4 + 0.6;\n  fragColor = vec4(color, 1.0) * diff;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 138, 177, 177, 375], [376, 414, 441, 506, 1468], [1469, 1469, 1523, 1523, 1823]], "test": "ok"}
{"id": "ttsyRr", "name": "[TWITCH] Peek-a-boomer", "author": "Flopine", "description": "A piece to enjoy with the sound from 20syl <3 \nHeavily inspired by this clip for C2C made in 2012: https://www.youtube.com/watch?v=YwmbbcMHiQ0\nMade during a twitch live, you can watch them here: https://www.twitch.tv/flopine", "tags": ["2d", "raymarching", "refraction", "motiongraphic", "twitch", "20syl"], "likes": 6, "viewed": 142, "published": "Public", "date": "1591309739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// A PIECE TO ENJOY WITH THE SOUND OF 20SYL <3 \n\n#define PI acos(-1.)\n#define TAU 6.28\n#define BPM (100./60.)\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.07,fwidth(val-thre)))\n#define sblur 1.05\n#define tri(puv, s) AAstep(0.005,equitri(puv,s))\n#define wiret(puv,s) AAstep(0.03, abs(equitri(puv,s)))\n\n#define time(speed) fract(iTime*speed)\n#define animswitch(speed) floor(sin(time(speed)*TAU)+1.)\n\n\n// TOOLS ////////////////////////////////////////\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(122,21.1)))*1245.2);}\n\n// 2D //////////////////////////////////////////\nfloat equitri (vec2 p, float r)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat pattern1 (vec2 uv)\n{\n    float d = 1e10;\n    float s = 0.1;\n    for (int i = 0; i<5; i++)\n    {\n        s += 0.3;\n        d = min(d, wiret(uv, s));\n    }\n    return clamp(1.-d,0.,1.);\n}\n\nfloat trapez (vec2 uv)\n{\n    vec2 tuv = uv*rot(PI);\n    tuv += vec2(.2/3.*sqrt(1.25)*cos(PI/6.), .2/3.*sqrt(1.25)*sin(PI/6.))*1.6;\n    return tri(uv, .1) * tri(tuv,.1);\n}\n\nfloat trapezes (vec2 uv)\n{\n    vec2 uu = uv;\n    uv.y = abs(uv.y)-.05;\n    uv.x = abs(uv.x)-0.1;\n    float d = trapez(uv);\n    d += (uu.x>=0. && uu.y<=0. || uu.x<=0. && uu.y >=0.) ? .5:0.;\n    return clamp(d,0.,1.);\n}\n\nfloat pattern2 (vec2 uv)\n{\n    vec2 per = (animswitch(BPM)<=0.) ? vec2(.6,.3) : vec2(.7,.4);\n    uv = mod(uv,per)-per*.5;\n    return trapezes(uv);\n}\n\n// 3D //////////////////////////////////////////\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat pillars (vec3 p)\n{\n    p.z -= 5.;\n    mo(p.xz, vec2(3., 1.));\n    float per = 4.;\n    float id = floor(p.y/per);\n    p.y = mod(p.y,per)-per*.5;\n    p.xy *= rot(hash21(vec2(id*0.8))*0.3);\n    return cyl(p.yzx, 0.4, 8.);\n}\n\nfloat SDF (vec3 p)\n{return stmin(-box(p, vec3(8.,20.,8.)),pillars(p),0.5,4.);}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    bool scene = animswitch(BPM/10.)<= 0.;\n    uv = (animswitch(BPM*.5)<=0.) ? uv : abs(uv)-.4;\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.,-3.+time(0.2)*16.,-5.),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = normalize(vec3(0.,-1.,-1.)),\n        col = vec3(0.);\n    float shad;\n\n    for (float i=0.; i<64.; i++)\n    {\n        float d =SDF(p);\n        if (d<0.1)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= .9 +dither*.1;\n        if (scene) rd += pattern2(uv*2.)*0.02;\n        p += d*rd;\n    }\n\n    vec3 n = getnorm(p);\n    col = vec3(floor((dot(l,n)*.5+.5)*5.)/5.);\n    col *= (1.-shad);\n\n    float mult = (animswitch(BPM)<=0.) ? 1.:3.;\n    if (!scene) col = mix(1.-col, col, pattern1(uv*mult));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "XlB3R3", "previewfilepath": "https://soundcloud.com/20syl/peek-a-boomer-36", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/20syl/peek-a-boomer-36", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[733, 783, 803, 803, 846], [848, 848, 880, 880, 927], [929, 929, 979, 979, 1082], [1084, 1084, 1107, 1107, 1156], [1158, 1207, 1240, 1240, 1447], [1449, 1449, 1475, 1475, 1640], [1642, 1642, 1666, 1666, 1812], [1814, 1814, 1840, 1840, 2031], [2033, 2033, 2059, 2059, 2181], [2183, 2232, 2260, 2260, 2348], [2350, 2350, 2388, 2388, 2427], [2429, 2429, 2453, 2453, 2655], [2657, 2657, 2677, 2677, 2735], [2737, 2737, 2759, 2759, 2872], [2874, 2874, 2929, 2929, 3867]], "test": "timeout"}
{"id": "ttsyWf", "name": "Juliabrot Tomography", "author": "dr2", "description": "Inside and outside views of the quaternion Julia set for f(q) = q^3 + c", "tags": ["fractal", "julia", "quaternion"], "likes": 15, "viewed": 348, "published": "Public API", "date": "1593337874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Juliabrot Tomography\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Inside and outside views of the quaternion Julia set for f(q) = q^3 + c\n Mousing recommended\n Based on \"Fractal Tomography\", with fractal from iq's \"Julia - Quaternion 3\"\n*/\n\n#define AA   0  // optional antialiasing\n\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\n\nvec3 ltDir, slBox, slPos;\nfloat dstFar, tCur, nHit;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtSqr (vec4 q)\n{\n  return vec4 (2. * q.w * q.xyz, q.w * q.w - dot (q.xyz, q.xyz));\n}\n\nvec4 QtCub (vec4 q)\n{\n  float b;\n  b = dot (q.xyz, q.xyz);\n  return vec4 (q.xyz * (3. * q.w * q.w - b), q.w * (q.w * q.w - 3. * b));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 q, qq, c;\n  vec2 b;\n  float s, ss, ot;\n  q = vec4 (p, 0.).yzwx;\n  c = vec4 (0.2727, 0.6818, -0.2727, -0.0909);\n  b = vec2 (0.45, 0.55);\n  s = 0.;\n  ss = 1.;\n  ot = 100.;\n  nHit = 0.;\n  for (int j = VAR_ZERO; j < 256; j ++) {\n    ++ nHit;\n    qq = QtSqr (q);\n    ss *= 9. * dot (qq, qq);\n    q = QtCub (q) + c;\n    ot = min (ot, length (q.wy - b) - 0.1);\n    s = dot (q, q);\n    if (s > 32.) break;\n  }\n  return min (ot, max (0.25 * log (s) * sqrt (s / ss) - 0.001, 0.));\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  dMin = dstFar;\n  if (df > 0. && dn < df) dMin = dn;\n  return vec2 (dMin, df);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec2 d2;\n  float dHit, h;\n  d2 = BlkHit (ro - slPos, rd, slBox);\n  dHit = d2.x;\n  if (dHit < dstFar) {\n    for (int j = VAR_ZERO; j < 1024; j ++) {\n      h = ObjDf (ro + dHit * rd);\n      dHit += min (h, 0.005);\n      if (h < 0.0002 || dHit > d2.y) break;\n    }\n  }\n  if (dHit > d2.y) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ColFun ()\n{\n  return (0.6 + 0.4 * cos (log2 (nHit) + 0.1 * tCur + pi * vec3 (0., 0.33, 0.66))) *\n     mix (vec3 (0.6, 0.6, 0.3), vec3 (1.), smoothstep (5., 10., nHit));\n}\n\nvec3 Illum (vec3 col, vec3 rd, vec3 vn)\n{\n  return col * (0.1 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.7 * max (dot (vn, ltDir), 0.) +\n     0.2 * vec3 (1., 1., 0.5) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colT;\n  float dstObj, dstObjT, c, t;\n  slBox = vec3 (2., 0.03, 2.);\n  t = 50. * mod (0.02 * tCur, 1.);\n  t = (1./50.) * (floor (t) + smoothstep (0.9, 1., mod (t, 1.)));\n  slPos = vec3 (0., 0.5 - SmoothBump (0.25, 0.75, 0.25, t), 0.);\n  dstObj = ObjRay (ro, rd);\n  col = (dstObj < dstFar && nHit > 1.) ? Illum (2. * ColFun (), rd, ObjNf (ro + dstObj * rd)) :\n     vec3 (0.);\n  c = length (col);\n  if (c == 0.) dstObj = dstFar;\n  slBox = vec3 (2.);\n  slPos = vec3 (0.);\n  dstObjT = ObjRay (ro, rd);\n  if (dstObjT < min (dstObj, dstFar) && nHit > 1.) {\n    colT = Illum (0.5 + 1.5 * ColFun (), rd, ObjNf (ro + dstObjT * rd));\n    col = (c > 0.) ? mix (col, colT, 0.25) : 0.4 * colT;\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = floor (tCur / 7.) + smoothstep (0.9, 1., mod (tCur / 7., 1.));\n    az -= 0.22 * pi * t;\n    el -= 0.12 * pi * sin (0.02 * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.);\n  zmFac = 5.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 10.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyWf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[632, 632, 653, 653, 721], [723, 723, 744, 744, 857], [859, 859, 881, 881, 1361], [1363, 1363, 1407, 1407, 1633], [1635, 1635, 1668, 1668, 1987], [1989, 1989, 2010, 2010, 2265], [2267, 2267, 2283, 2283, 2442], [2444, 2444, 2485, 2485, 2667], [2669, 2669, 2704, 2704, 3450], [3452, 3452, 3508, 3508, 4618], [4620, 4620, 4642, 4642, 4680], [4682, 4682, 4704, 4704, 4742], [4744, 4744, 4801, 4801, 4884], [4886, 4886, 4916, 4916, 5029], [5031, 5031, 5067, 5067, 5273]], "test": "timeout"}
{"id": "ttsyWn", "name": "Mandelbrot derivative", "author": "FabriceNeyret2", "description": "just for fun, displaying the derivative of Mandelbrot (yes :-p ).\nleft: hardware derivative after loop. Right: during loop. ( look different in OpenGL, not sure for windows/Angle. see capture below).\n\nInterior looks better with less iterations.", "tags": ["fractal", "mandelbrot", "fwidth", "short", "short"], "likes": 4, "viewed": 292, "published": "Public API", "date": "1591854355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/MllXWM\n\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    O-=O;\n    float k=0., v, l=k, t = mod(iTime,88.); t = min(t,88.-t);\n    vec2  R = iResolution.xy,\n          z = (U-.5*R)/R.y / pow(t,t/20.) - vec2(1.001105,0.300717),\n          c = z;\n    \n    for (; k++ <40. && l<4.; )         // Mandelbrot iterations\n         l = dot( z = mat2(z,-z.y,z.x) *z + c, z ), // z = z*z + c\n         v = fwidth(l);\n    \n    if ( U.x < .5*R.x ) v = fwidth(l); // left: post derivative. right: inloop\n    O +=  pow(v,.2); \n  //O -= .1*log(v);\n    \n  //if (O.x==0.) O++;   // test: difference is just fwidth undefined (thus 0)  at divergences\n    if (int(U)==int(.5*R)) O.r ++;     // red separator\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 88, 88, 720]], "test": "timeout"}
{"id": "ttsyz4", "name": "blue wave", "author": "darkfox", "description": "waving animation.", "tags": ["wave"], "likes": 2, "viewed": 48, "published": "Public", "date": "1591580992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fCol,in vec2 fCor){\n vec2 v=fCor.xy-0.5*iResolution.xy;\n float r=mod(iTime,6.0)*60.0;\n if(dot(v,v)<r*r){v=v+5.0*sin(v.yx*0.02+iTime*6.0);}\n vec2 w=mod(v,20.0)/20.0;\n fCol=vec4(0.0,0.0,(w.x+w.y)/2.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 229]], "test": "ok"}
{"id": "ttsyzM", "name": "Game Console Chat", "author": "dean_the_coder", "description": "Game Console-powered webcam.\nIntended for video meetings using iq's MemixApp.\nThanks to Evvvvil (Glow Broski!), Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!", "tags": ["procedural", "3d", "raymarch", "retro", "gameboy", "webcam"], "likes": 15, "viewed": 586, "published": "Public API", "date": "1592849222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Game Console-powered webcam.\n// Intended for video meetings using iq's MemixApp.\n// Thanks to Evvvvil (Glow Broski!), Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat glow = 0.0;\nfloat pathGlow = 0.0;\nfloat terrainGlow = 0.0;\n\n#define gt (mod(iTime, 10.0))\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.x -= clamp(p.x, 0.0, h);\n  return length(p) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 min4(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec3 sdScreen(vec3 p, vec3 box) {\n    box *= vec3(0.85, 0.45, 0.05);\n    p += vec3(0.0, -0.8, 0.27);\n    return vec3(sdBox(p, box) - 0.025, p.x / box.x * 0.5, p.y / box.y * 0.5);\n}\n\nfloat sdButton(vec3 p) {\n    float d = sdCylinder(p, 0.08, 0.08) - 0.05;\n    float r = 2.0;\n    return smin(d, -sdSphere(p + vec3(0.0, 0.0, r + 0.1), r), -0.05);\n}\n\nfloat sdControls(vec3 p) {\n    // D-pad\n    vec3 pp = p + vec3(0.55, 0.45, 0.37);\n    vec3 dpad = vec3(0.1, 0.3, 0.1);\n    float d = min(sdBox(pp, dpad), sdBox(pp, dpad.yxz));\n    float r = 2.0;\n    d = smin(d, -sdSphere(pp + vec3(0.0, 0.0, r), r), -0.05);\n    r = 0.17;\n    d = max(d, -sdSphere(pp + vec3(0.0, 0.0, r * 0.9), r));\n    \n    // Fire buttons.\n    d = min(d, sdButton(p + vec3(-0.32, 0.5, 0.3)));\n    d = min(d, sdButton(p + vec3(-0.7, 0.35, 0.3)));\n\n    // Start/select.\n    p += vec3(0.0, 1.15, 0.34);\n    p.x = abs(p.x) - 0.12;\n    d = min(d, sdCapsule(p, 0.2, 0.06));\n    \n    return d;\n}\n\nvec4 sdCase(vec3 p) {\n    const float height = 3.4;\n    \n    p.yz *= rot(sin(fract(iTime * 0.1) * 6.283) * 0.1);\n    p.xz *= rot(sin(fract(iTime * 0.2) * 6.283) * 0.2);\n    \n    // Front base.\n    vec3 pp = p;\n    pp.z += pp.z < 0.0 ? (abs(0.5 + 0.5 * cos(pp.y * 0.7)) - 1.0) * max(0.0, (-pp.y - 1.3) / height * 2.0) : 0.0;\n    \n    float edgeIndent = sin(3.14159 * smoothstep(-0.10, -0.04, pp.z)) * 0.005;\n    vec3 box = vec3(1.0, height / 2.0, 0.2);\n    float d = sdBox(pp, box - vec3(edgeIndent, edgeIndent, 0.0)) - 0.1;\n    \n    // P1 P2\n    pp = p + vec3(0.00, 0.99, 0.37);\n    d = max(d, -sdSphere(pp + vec3(0.22, 0.0, 0.0), 0.08));\n    pp.x = abs(pp.x - 0.22) - 0.06;\n    d = max(d, -sdSphere(pp + vec3(0.0, 0.0, 0.0), 0.08));\n\n#if 0\n    // Rear bump.\n    d = smin(d, sdBox(p - vec3(0.0, -0.3, 0.4), box * vec3(0.90, 0.7, 0.2)) - 0.05, 0.2);\n#endif\n    \n    // Power light.\n    float power = sdSphere(p - vec3(-0.75, 1.4, -0.3), 0.03);\n    glow += 0.01 / (0.01 + power * power * 400.0);\n    \n    // Screen indent.\n    return min4(min4(min4(vec4(d, 1.5, 0.0, 0.0), vec4(sdScreen(p, box), 2.5).xwyz), vec4(power, 3.5, 0.0, 0.0)), vec4(sdControls(p), 4.5, 0.0, 0.0));\n}\n\nvec2 sdTraveller(vec3 p) {\n    p.z = mod(p.z + gt * 40.0, 50.0) - 25.0;\n    \n    float open = abs(sin(gt * 4.0));\n    \n    vec3 pp = p;\n    pp.yz *= rot(open);\n    float bodyTop = max(sdSphere(pp, 1.3), -pp.y);\n    \n    pp.yz += vec2(-0.6, 1.0);\n    pp.x = abs(pp.x) - 0.6;\n    float eyes = sdSphere(pp, 0.2);\n    \n    p.yz *= rot(-open);\n    float bodyBottom = max(sdSphere(p, 1.3), p.y);\n    \n    float body = min(bodyTop, bodyBottom);\n   \n    return min2(vec2(body, 6.0), vec2(eyes, 4.0));\n}\n\nvec2 sdRoad(vec3 p) {\n    p.x += 8.0;\n    p.xz *= rot(-0.75 + sin(p.z * 0.1) * 0.06);\n    \n    p.y += sin(p.z * 0.1);\n\n    // Road.\n    p.y += 4.0;\n    \n    vec3 pp = p;\n    pp.x = abs(pp.x) - 2.0;\n    float d1 = length(pp.xy) - 0.3;\n    \n    // Traveller.\n    p.z -= 10.0;\n    p.y -= 1.0;\n    vec2 d2 = sdTraveller(p);\n    \n    // Glow.\n    pathGlow += 0.1 / (0.1 + d1 * d1 * 5.0);\n    \n    return min2(vec2(d1, 5.0), d2);\n}\n\nvec2 sdTerrain(vec3 p) {\n    p.y += 5.0;\n    p.z += iTime;\n    \n    p.xz = mod(p.xz, 5.0) - 2.5;\n\n    float d = min(length(p.xy), length(p.yz));\n    \n    terrainGlow += 0.001 / (0.001 + d * d * 5.0);\n    \n    return vec2(d, 3.5);\n}\n\nvec4 map(vec3 p) {\n    return min4(min4(sdCase(p), vec4(sdRoad(p), 0.0, 0.0)), vec4(sdTerrain(p), 0.0, 0.0));\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.01;\n    for (int i = 0; i < 5; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.08;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 getWebCam(vec2 uv) {\n    if (iTime < 5.0) return vec3(0.01);\n    if (iTime < 6.0) return vec3(0.03);\n    \n    ivec2 t = textureSize(iChannel0, 0);\n    float ar = float(t.y) / float(-t.x);\n    \n    const vec2 res = vec2(160.0, 144.0) * 0.4;\n    uv = floor(uv * res) / res;\n    \n    vec3 col = texture(iChannel0, (uv * vec2(ar, 1.0) + vec2(0.5))).rgb;\n    col = floor(col * 12.0) / 12.0;\n    \n    return mix(vec3(0.03), col, clamp(iTime - 7.0, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    // Raymarch.\n    vec3 ro = vec3(0.0, 1.0, -4.0);\n    vec3 rd = getRayDir(ro, vec3(0.0, 0.2, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    float steps;\n    vec2 puv;\n    for (steps = 0.0; steps < 55.0; steps++) {\n        p = ro + rd * d;\n        vec4 h = map(p);\n\n        if (h.x < 0.001 * d) {\n            hit = int(h.y);\n            puv = h.zw;\n            break;\n        }\n\n        d += h.x;\n    }\n\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(3.0, 3.0, -10.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.05);\n        float occ = calcOcc(p, n, 20.0);\n        float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n        float mainLight = max(0.0, dot(n, lightToPoint));\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1;\n        vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Case\n            mat = vec3(0.1, 0.8, 0.15);\n        } else if (hit == 2) {\n            // Screen.\n            vec2 uv = (puv - vec2(0.0, 0.05)) * 1.4;\n            mat = abs(uv.x) < 0.5 && abs(uv.y) < 0.5 ? getWebCam(uv) : vec3(0.0);\n            \n            if (puv.y < -0.36 && puv.y > -0.45) {\n                puv.x = (puv.x - 0.45) * 15.0 - puv.y * 8.0;\n                if (puv.x > 0.0 && puv.x < 3.0)\n                {\n                    switch(int(puv.x)) {\n                        case 0: mat = vec3(1.0, 0.0, 0.0); break;\n                        case 1: mat = vec3(0.0, 1.0, 0.0); break;\n                        case 2: mat = vec3(0.0, 0.0, 1.0); break;\n                    }\n                }\n            }\n        } else if (hit == 3) {\n            // Power light.\n            mat = vec3(0.1);\n        } else if (hit == 4) {\n            // Controls.\n            mat = vec3(0.1);\n        } else if (hit == 5) {\n            // Road.\n            mat = vec3(0.7);\n        } else if (hit == 6) {\n            // Traveller.\n            mat = vec3(0.7, 0.7, 0.1) * 2.0;\n        }\n        \n        col = (mainLight + (spe + backLight) * occ) * lightCol;\n        col += skyLight * occ;\n        col = mix(col * mat, vec3(0.0), fog);\n    }\n    \n    // Glow.\n    if (iTime < 5.0) glow = 0.0;\n    col += (glow + terrainGlow) * vec3(0.7, 0.1, 0.1);\n    col += pathGlow * vec3(0.1, 0.1, 0.8);\n\n    // Output to screen\n    col = pow(vignette(col, fragCoord), vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[385, 385, 424, 424, 527], [529, 529, 548, 548, 624], [626, 626, 659, 659, 687], [689, 689, 720, 720, 813], [815, 815, 859, 859, 972], [974, 974, 1017, 1017, 1072], [1074, 1074, 1121, 1121, 1326], [1328, 1328, 1355, 1355, 1387], [1389, 1389, 1416, 1416, 1448], [1450, 1450, 1483, 1483, 1630], [1632, 1632, 1656, 1656, 1795], [1797, 1797, 1823, 1836, 2402], [2404, 2404, 2425, 2425, 3577], [3579, 3579, 3605, 3605, 4073], [4075, 4075, 4096, 4096, 4500], [4502, 4502, 4526, 4526, 4733], [4735, 4735, 4753, 4753, 4846], [4848, 4848, 4876, 4894, 5094], [5096, 5096, 5154, 5154, 5452], [5454, 5454, 5501, 5501, 5590], [5680, 5680, 5721, 5721, 5862], [5864, 5864, 5889, 5889, 6324], [6326, 6326, 6383, 6383, 9057]], "test": "error"}
{"id": "ttV3zm", "name": "Gamma vs Linear", "author": "gabrielmuller", "description": "Rendering a point light and a diffuse sphere with perspective\n\nLeft is gamma space, right is linear space.", "tags": ["gamma"], "likes": 1, "viewed": 46, "published": "Public", "date": "1592689538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COLOR vec3(1., .7, .5)\n\n#define SPEED .5\n#define AMBIENT 0.1\n#define LIGHT_DISTANCE 5.\n#define LIGHT_INTENSITY 16.\n#define HDR\n\n#define RADIUS 1.\n#define CENTER vec3(0)\n\n#define CAMERA_POS vec3(0., 0., -3.)\n\n#define GAMMA 2.2\n\nfloat brightnessAt(in vec3 intersection, in vec3 lightPos, in float ambient) {\n\tvec3 normal = normalize(intersection - CENTER);\n    vec3 intersectionToLight = lightPos - intersection;\n    vec3 lightDir = normalize(intersectionToLight);\n    float distance = length(intersectionToLight);\n    float intensity = LIGHT_INTENSITY / (distance*distance);\n\n    return (dot(normal, lightDir) * intensity) * (1.-ambient) + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minResolution = min(iResolution.x*.5, iResolution.y);\n    vec2 uv = (fragCoord - 0.5 * vec2(iResolution.x*.5, iResolution.y)) / minResolution;\n    vec2 half_uv = vec2(uv.x + .5, uv.y);\n    half_uv.x = fract(half_uv.x) - .5;\n    vec3 direction = normalize(vec3(half_uv, -1.));\n    vec3 toCenter = CENTER - CAMERA_POS;\n    \n    float projection = dot(toCenter, direction);\n    float radiusSegment = sqrt(dot(toCenter, toCenter) - projection*projection);\n    float radicand = RADIUS * RADIUS - radiusSegment * radiusSegment;\n    float time = iTime * SPEED;\n\n    vec3 lightPos = vec3(cos(time), sin(time), abs(sin(time *.618))) * LIGHT_DISTANCE;\n    \n    bool linear = uv.x > .5;\n    // Ambient is compensated for better comparison\n    float exponent = linear ? GAMMA : 1.;\n    float ambient = pow(AMBIENT, exponent);\n    float maxBrightness = 1.;\n#ifdef HDR\n    vec3 brightestPoint = normalize(lightPos - CENTER) * RADIUS;\n    maxBrightness = brightnessAt(brightestPoint, lightPos, ambient);\n#endif\n    vec3 finalColor;\n    if (radicand > 0.) {\n        float halfChord = sqrt(radicand);\n        vec3 intersection = CAMERA_POS + (projection - halfChord) * direction;\n\n        float brightness = brightnessAt(intersection, lightPos, ambient) / maxBrightness;\n        vec3 albedo = COLOR;\n\n        albedo = pow(albedo, vec3(exponent));\n        finalColor = brightness * albedo;\n    } else {\n        finalColor = pow(texture(iChannel0, uv).rgb, vec3(exponent));\n        finalColor = finalColor * ambient / maxBrightness;\n    }\n    finalColor = pow(finalColor, vec3(1./exponent));\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttV3zm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 313, 313, 657], [659, 659, 716, 716, 2340]], "test": "error"}
{"id": "ttXcRj", "name": "smooth Mandelbrot 2", "author": "FabriceNeyret2", "description": "playing with iq smooth Mandelbrot technique reusing jorge2017a1 setup.\nin particular:    marquetry pattern    + fade-to-grey antialiasing ( NB: I preferred to trade slight aliasing for pitch).\nAntialiasing tuned with mouse.xy (analytic) + #def N (oversamp", "tags": ["mandelbrot", "smooth", "atialiasing"], "likes": 6, "viewed": 225, "published": "Public API", "date": "1592466527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of jorge2017a1 https://shadertoy.com/view/WlfyR2\n// Fork of IQ https://www.shadertoy.com/view/4df3Rn\n//   See here for more information on smooth iteration count:\n//   http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n// mouse.x controls the threshold to grey,    and mouse.y how the transition span.\n     \n#define N 1   // antialiasing oversampling = NxN\n#define linstep(a,b,x) clamp( (x-(a))/(b-(a)),0.,1.)\n\nfloat mandelbrot( vec2 c , out vec2 z,out vec2 _z )\n{\n#if 1 // --- optimizations : \n    float c2 = 16.* dot(c, c);\n    // skip computation inside M1 - http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n    if( c2*c2 - 6.*c2 + 32.*c.x < 3. ) return 0.;\n    // skip computation inside M2 - http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm\n    if( c2 + 32.*c.x + 16.  < 1. ) return 0.;\n#endif\n\n    float B = 256., l = 0.;\n    z  = vec2(0);\n    for( int i=0; i<512; i++, l++ ) {\n       _z = z;\n        z = mat2(z,-z.y,z.x) * z  + c;\n        if( dot(z,z) >  B*B ) break;\n    }\n    if( l > 511. ) return 0.;\n    \n    return l -= log2(log2(length(z))/log2(B));  // smooth iteration count  \n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float t = iTime, l,lc=0.,l0,AA=1.,a,_a,ac=0.,sac=0.,\n       zoom = pow( .62 + .38*cos(.07*t) ,8.);   \n    vec2 R = iResolution.xy, z, _z,\n         M = length(iMouse.xy)<10. ? vec2(-3.75,2.25) : vec2(4,0)+iMouse.xy/R*vec2(-11,8);\n\n    // --- compute Mandelbrot\n    \n    int k = N*N/2;                              // NxN = subsampling. \n    for (int k=0; k<N*N; k++) {                 // oversampling\n        vec2 sp = vec2(k%N,k/N)/float(N)-.5,    // subpixel pos\n              p = ( 2.* (U+sp) - R ) / R.y,\n              c =   vec2(-.745,.186) \n                  + zoom * p * mat2( cos( .15*(1.-zoom)*t + vec4(0,11,33,0) )) ;\n          l = mandelbrot(c, z,_z);\n          a = atan(z.y,z.x);  _a = atan(_z.y,_z.x); \n        ac +=          mix(_a,a,fract(l)); \n       sac += sin( 6.* mix(_a,a,fract(l)) ); \n        lc += l;\n    } l = lc / float(N*N); ac /= float(N*N), sac /= float(N*N);\n    \n    // --- tweak patterns and color from it\n    \n    l0=l; // keep for LOD & AA\n    if (l0==0.) { O = vec4(.5,0,0,1); return; }\n\n#if 1                                       // play with angle(z) rather than l\n    l = 6.*ac;\n  //l = mod( ac+3.14159*mod(floor(l0),2.), 6.283 );\n#endif    \n    \n // O = vec4( .5 + .5* cos( 3. + l*.15 + vec4(0,.6,1,0)) ); // jorge2017a1 colors\n // O = vec4( .5 + .5* sin(l*vec4(1,.33,.1,0)));\n     \n // l = sin(l); O = vec4( l/fwidth(l) );           // draw strips or isolines\n // l = sin(l); O = vec4( sqrt( abs(l)/fwidth(l) ) );  \n // l = sin(l); O = vec4( .5+ l/fwidth(l) ); \n    \n // AA = smoothstep(-3.,-6.,log2(fwidth(l0)));     // play with antialiasing (fade to grey)\n // AA = smoothstep(exp2(-3.),exp2(-6.),fwidth(l0));\n // AA = linstep(-3.,-6.,log2(fwidth(l0)));\n // AA = linstep(-1.5,-6.,log2(fwidth(l0)));\n    AA = linstep(M.x+M.y,M.x-M.y,log2(fwidth(l0)/float(N)));\n // AA = linstep(exp2(-1.),exp2(-6.),(fwidth(l0)));\n  //l = sin(l); O = vec4( sqrt( .5+ l/fwidth(l)*AA  ) ); \n  //l = sin(l); O = vec4( sqrt( .5- l/fwidth(l) * (.2+.8*AA  )) ); \n    l = sin(l); O = vec4( sqrt( .5- clamp(l/fwidth(l),-.5,.5)* AA ) ); \n  //l = sin(l); O = vec4( sqrt( .5- clamp(l/fwidth(l),-.5,.5)* (.2+.8*AA  )) ); \n\n    O = vec4( sqrt( .5- sac* AA ) ); \n  //O = vec4( sqrt( .5 - sac ) ) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXcRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 484, 484, 1135], [1137, 1137, 1175, 1175, 3386]], "test": "error"}
{"id": "ttXcz7", "name": "broken icosa", "author": "darkfox", "description": "icosahedron broken.", "tags": ["icosahedron"], "likes": 10, "viewed": 107, "published": "Public", "date": "1591672152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// constant.\n#define pi 3.14159\n// palette\nconst vec3 black = vec3(0.2);\nconst vec3 green = vec3(0.3, 0.9, 0.4);\nconst vec3 white = vec3(1.0);\nconst vec3 silver = vec3(0.5);\n// for folding.\nconst vec3 nc5 = vec3(-0.5, -0.809017, 0.309017);\nconst vec3 pab5 = vec3(0.0, 0.0, 0.809017);\nconst vec3 pbc5 = vec3(0.5, 0.0, 0.809017);\nconst vec3 pca5 = vec3(0.0, 0.269672, 0.706011);\nconst vec3 nab5 = vec3(0.0, 0.0, 1.0);\nconst vec3 nbc5 = vec3(0.525731, 0.0, 0.850651);\nconst vec3 nca5 = vec3(0.0, 0.356822, 0.934172);\n// hsb to rgb.\nvec3 getRGB(float h, float s, float b){\n  vec3 c = vec3(h, s, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// rotation.\nvec2 rotate(vec2 p, float t){\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\n// x axis rotation.\nvec3 rotateX(vec3 p, float t){\n  p.yz = rotate(p.yz, t);\n  return p;\n}\n// y axis rotation.\nvec3 rotateY(vec3 p, float t){\n  p.zx = rotate(p.zx, t);\n  return p;\n}\n// z axis rotation.\nvec3 rotateZ(vec3 p, float t){\n  p.xy = rotate(p.xy, t);\n  return p;\n}\n// fold H3 with counting.\nint foldH3Count(inout vec3 p){\n  int n = 0;\n  float _dot;\n  for(int i = 0; i < 5; i++){\n    if(p.x < 0.0){ p.x = -p.x; n++; }\n    if(p.y < 0.0){ p.y = -p.y; n++; }\n    _dot = dot(p, nc5);\n    if(_dot < 0.0){ p -= 2.0 * _dot * nc5; n++; }\n  }\n  return n;\n}\nvec3 getP5(vec3 u){\n  return u.x * pab5 + u.y * pbc5 + u.z * pca5;\n}\nvec3 getP5(float u1, float u2, float u3){\n  return u1 * pab5 + u2 * pbc5 + u3 * pca5;\n}\n// sphere.\nfloat sphere(vec3 p, float r){\n  return length(p) - r;\n}\n// bar. (n:direction, r:radius)\nfloat bar(vec3 p, vec3 n, float r){\n  return length(p - dot(p, n) * n) - r;\n}\n// half open bar.\nfloat halfBar(vec3 p, vec3 n, float r){\n  return length(p - min(0.0, dot(p, n)) * n) - r;\n}\n// update distance.\n// 0:min, union.\n// 1:max, intersection.\n// 2:minus min, difference.\nvoid updateDist(inout vec3 color, inout float dist, vec3 c, float d, int modeId){\n  if(d < dist && modeId == 0){ color = c; dist = d; }\n  if(d > dist && modeId == 1){ color = c; dist = d; }\n  if(-d > dist && modeId == 2){ color = c; dist = -d; }\n}\n// map function.\nvec4 map(vec3 p){\n  vec3 color = black;\n  float t = 1e20;\n  int n = foldH3Count(p);\n  float base = 1.0;\n  float thick = 0.1;\n  float ratio = 2.0 + sin(iTime * pi);\n  base *= ratio;\n  thick *= ratio;\n  updateDist(color, t, getRGB(float(n) / 15.0, 1.0, 1.0), max(dot(p - pbc5 * base, nca5), dot(p - pbc5 * (base - thick), -nca5)), 0);\n  vec3 v = normalize(cross(pbc5 - pab5, nca5));\n  updateDist(color, t, black, dot(p - getP5(0.0, 1.0 / ratio, 0.0) * base, v), 1);\n  updateDist(color, t, silver, halfBar(p - getP5(0.0, 0.0, 0.9) * base, nca5, 0.05), 0);\n  return vec4(color, t);\n}\n// normal vector.\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  // mathematical procedure.\n  vec3 n;\n  n.x = map(p + eps.xyy).w - map(p - eps.xyy).w;\n  n.y = map(p + eps.yxy).w - map(p - eps.yxy).w;\n  n.z = map(p + eps.yyx).w - map(p - eps.yyx).w;\n  return normalize(n);\n}\n// ray marching.\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; // searching limit.\n  const float precis = 0.001; // precision.\n  const int ITERATION = 64; // iteration limit.\n  float h = precis * 2.0; // heuristics.\n\n  float t = 0.0; // current distance.\n\n  float result = -1.0;\n  for(int i = 0; i < ITERATION; i++){\n    if(h < precis || t > maxd){ break; }\n    // adding heuristics value.\n    h = map(camera + t * ray).w;\n    t += h;\n  }\n  // if t < maxd, it means success(h < precis).\n  if(t < maxd){ result = t; }\n  return result;\n}\n// camera move.\nvoid transform(inout vec3 p){\n  p = rotateX(p, pi * iTime * 0.3);\n  p = rotateY(p, pi * iTime * 0.15);\n}\n// background.\nvec3 getBackground(vec2 p){\n  vec2 i = floor(p * 10.0);\n  vec3 color = mix(green, white, 0.6 + 0.3 * mod(i.x + i.y, 2.0));\n  return color;\n}\n// main.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color;\n  // ray vector.\n  vec3 ray = normalize(vec3(p, -1.8));\n  // camera position.\n  vec3 camera = vec3(0.0, 0.0, 4.5);\n  // light vector.\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  // camera rotation.\n  transform(ray);\n  transform(camera);\n  transform(light);\n  color = getBackground(p);\n  // get ray marching result.\n  float t = march(ray, camera);\n  // if t > -0.001, it means success. if not, background color.\n  if(t > -0.001){\n    vec3 pos = camera + t * ray;\n    vec3 n = calcNormal(pos);\n    // lighting.\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    vec3 baseColor = map(pos).xyz;\n    baseColor *= diff;\n    // fadeout.\n    color = mix(baseColor, color, tanh(t * 0.04));\n  }\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXcz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[514, 529, 568, 568, 766], [767, 780, 809, 809, 859], [860, 880, 910, 910, 950], [951, 971, 1001, 1001, 1041], [1042, 1062, 1092, 1092, 1132], [1133, 1159, 1189, 1189, 1414], [1415, 1415, 1434, 1434, 1483], [1484, 1484, 1525, 1525, 1571], [1572, 1583, 1613, 1613, 1639], [1640, 1672, 1707, 1707, 1749], [1750, 1768, 1807, 1807, 1859], [1860, 1949, 2030, 2030, 2196], [2197, 2214, 2231, 2231, 2793], [2794, 2812, 2836, 2836, 3085], [3086, 3103, 3138, 3138, 3638], [3639, 3655, 3684, 3684, 3759], [3760, 3775, 3802, 3802, 3915], [3916, 3925, 3979, 3979, 4819]], "test": "timeout"}
{"id": "ttXczf", "name": "Day 182 v2", "author": "jeyko", "description": "ooo", "tags": ["mdtmjvm"], "likes": 5, "viewed": 209, "published": "Public API", "date": "1592605995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Day ilostcount, will update tmrw\" by jeyko. https://shadertoy.com/view/3lXczf\n// 2020-06-19 22:30:04\n\n\n#define T iTime\n\n#define pi acos(-1.)\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pmod(p,j) mod(p - 0.5*j,j)  - 0.5*j\n\nfloat sdBox(vec3 p, vec3 s){\n  p = abs(p) - s;\n  return max(p.x,max(p.y,p.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv*=1.5;\n\n  vec3 col = vec3(0,0.5,0.5);\n  \n  float tt = T*0.82;\n  \n  uv += vec2(cos(tt*0.7 + cos(tt/2.)), sin(tt*0.9) + sin(tt*0.6))/3.;\n  \n\n  vec3 p = vec3(uv,1);\n  \n  p = mix(p,p/dot(p,p),smoothstep(0.,1.,mod(iTime/4.,2.)-smoothstep(0.,1.,mod(iTime/4. + 1.,2.))));\n  \n  //p.xy = vec2(atan(p.y,p.x)*pi*2./7.,log(length(p.xy) ));\n\n  p.x += tt*0.003;\n  p.y += tt*0.003;\n  p.xz *= rot(0.25*pi - sin(T/2.)/20. + tt*0.1);\n  \n  p.xy *= rot(0.25*pi + sin(T/2.)/20.);\n\n\n  \n  p = pmod(p,0.3);\n  \n  \n  //\n  col = mix(col,vec3(0.1,0.1,0.5),smoothstep(0.001,0.,abs(length(p-0.1)-0.1)-0.02));\n  \n  \n  // \n  float db = sdBox(p - 0.01,vec3(0.1));\n  db = abs(db) - 0.01;\n  \n  col = mix(col,vec3(0.0,0.8,0.5)*1.,smoothstep(0.001,0.,db));\n  \n  // \n  db = sdBox(p,vec3(0.1));\n  col = mix(col,vec3(0.1,0.4,0.1)*4.,smoothstep(0.001,0.,db));\n  \n  //\n  db = sdBox(p,vec3(0.1));\n  \n  db = abs(db)-0.01;\n  col = mix(col,vec3(0.9,0.4,0.5)*0.1,smoothstep(0.001,0.,db));\n  \n  // circ\n  db = length(p + 0.05)-0.05;\n  db = abs(db) - 0.01;\n\n  \n  col = mix(col,vec3(0.9,0.4,0.1)*4.,smoothstep(0.001,0.,db));\n  \n  \n  \n\n  \n  col = pow(col,vec3(0.454545));\n  fragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 323, 323, 375], [377, 377, 434, 434, 1653]], "test": "timeout"}
{"id": "ttXczl", "name": "Screenprinting [Day 184] ", "author": "jeyko", "description": "mdtjvm", "tags": ["halftone", "popart", "art", "pop", "mdtmjvm", "screenprint", "screenprinting"], "likes": 6, "viewed": 292, "published": "Public API", "date": "1592765747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Trying to reprudce the classic screenprinting style\n\n// Most of all of the look comes from the dots() function\n// You feed it the luminosity of the image, and then multiply image by the return value\n\n\n#define CELL_SZ 0.02\n#define COL_SEP 0.2\n#define STR 1.4\n\n#define LUM_EPS (6.0 )\n\n#define T(u) texture(iChannel0,(u)/iResolution.xy)\n\n#define Neighborhood \\\nvec3 n = getImg(U + vec2(0.,1.)*LUM_EPS);vec3 s = getImg(U - vec2(0.,1.)*LUM_EPS);vec3 e = getImg(U + vec2(1.,0.)*LUM_EPS);vec3 w = getImg(U - vec2(1.,0.)*LUM_EPS);\\\nvec3 se = getImg(U + vec2(1.,-1.)*LUM_EPS);vec3 sw = getImg(U - vec2(-1.,-1.)*LUM_EPS);vec3 ne = getImg(U + vec2(1.,1.)*LUM_EPS);vec3 nw = getImg(U + vec2(-1.,1.)*LUM_EPS);\n\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pmod(p,j) mod(p,j) - 0.5*j\n#define pi acos(-1.)\n\n#define smoothness 0.004\n\n//#define noise(i) texture(iChannel0,vec2(mod((i),256.)/256.,floor(i/256.)/256.))\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat noise(vec2 p){\n\tvec2 fruv = fract(p);\n\tvec2 fluv = floor(p);\n    return mix( \n        mix(\n            hash22(fluv).x,\n            hash22(fluv + vec2(1,0)).x,\n        \tfruv.x\n        ), \n        mix(\n            hash22(fluv + vec2(0,1)).x,\n            hash22(fluv + vec2(1,1)).x,\n        \tfruv.x\n        ),\n        fruv.y\n    );\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdCoolBall(vec2 uv){\n\tfloat sdBall = length(uv) - 0.4; \n    sdBall = opSmoothUnion( sdBall, length(uv + 0.5 + vec2(sin(iTime)*0.1)) - 0.1,0.4 );\n    sdBall = opSmoothUnion( sdBall, length(uv - 0.5 + vec2(sin(iTime/2. + cos(iTime))*0.1)) - 0.1,0.4 );\n    sdBall = opSmoothUnion( sdBall, length(uv - vec2(-0.5,0.2) + vec2(sin(iTime/2.), cos(iTime+ 4.) )/14.) - 0.04,0.3 );\n    //sdBall = opSmoothUnion( sdBall, length(uv - vec2(0.5,-0.4) + vec2(sin(iTime/2. )*0.1,cos(iTime))*0.1) - 0.1,0.4 );\n    \n    return sdBall;\n}\n\nvec3 getImg(vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.,0.,0.);\n    \n    vec2 puv = vec2(atan(uv.y,uv.x)/pi + 1.,length(uv));\n    \n    \n    if(puv.x < 0.4)\n    \tcol = vec3(0.2,0.5,0.4)*1.55;\n    else if(puv.x < 1.)\n    \tcol = vec3(0.5,0.5,0.9);\n    else if(puv.x < 1.4)\n    \tcol = vec3(1.,0.716,0.7);\n    else \n    \tcol = vec3(0.9,0.6,0.6);\n    \n    //col *= smoothstep(1.,0.,length(uv)/3.);\n    \n    //uv *= rot(-0.7);\n    \n    col = mix(col,vec3(1,0.1,0.6),smoothstep(1.,0.,length(abs(uv.y) + 0.)*4. + 0.3));\n    \n    uv *= rot(-1.2);\n    col = mix(col,vec3(1,0.1,0.5),smoothstep(1.,0.,length(abs(uv.y) + 0.)*4. + 0.3));\n    \n    \n    uv *= rot(-1.4);\n    \n    \n    vec3 bc = vec3(1.,0.7,0.6) *mix(vec3(1.),vec3(0.1,0.,0.),smoothstep(0.,1.,uv.x + uv.y*1.5 -0.1 + length(uv)/1.5));\n    \n    \n    float dBalla = sdCoolBall(uv);\n        \n    float dBallb = sdCoolBall(uv-0.04);\n        \n    \n    col = mix(col,vec3(1,1.,0.9), smoothstep(smoothness,0.,dBallb));\n    \n    \n    col = mix(col,bc, smoothstep(smoothness,0.,dBalla));\n    \n    \n    col = mix(col,vec3(1,0.7,1.),smoothstep(1.,0.,length(uv + vec2(0.13,0.25))*18. + 0.3));\n    \n    col = mix(col,vec3(1,0.7,1.),smoothstep(1.,0.,length(uv + vec2(0.7,0.4))*14. + 0.3));\n    \n    \n    \n    return col;\n}\n\n\n// get avg lum\nvec3 getAvg(vec2 U){\n    \n    float l = 0.4;\n    Neighborhood;\n    \n    vec3 avg = (n + e + w + s + ne + sw + se + nw)/8.;\n    \n    return avg;\n\n}\n    \n\nfloat dots(vec2 p,float lum){\n\tfloat t = 0.;\n    vec2 q = p ;\n    \n    p *= rot(0.25*pi);\n    \n    \n    q /= CELL_SZ/pi;\n    // some distortion\n    p -= length(sin(q))*normalize(p)*CELL_SZ/6.;\n    \n    \n    p = pmod(p,CELL_SZ);\n    p -= length(sin(q))*normalize(p)*CELL_SZ/6.;\n    \n    float lsz = 0.;\n    \n    float n = noise(q*10.);\n    \n    n = pow(n,2.)*0.07;\n    lsz = pow(smoothstep(0.,1.,lum*(0.45 +n)),STR)*CELL_SZ*0.6;\n    \n    float col = smoothstep(0.003,0.,length(p) - lsz);\n    //col = mix(col,smoothstep(0.01,0.,sin(q.x)*sin(q.y)* lsz*1. ),0.1);\n\t\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 tex = getImg(fragCoord);\n    \n    tex = getAvg(fragCoord);\n    \n    float lum = length(tex);\n    \n    col = vec3(0.1,0.5,0.9)*0.1;\n    col = mix(col,floor(tex/COL_SEP)*COL_SEP,dots(uv,lum));\n    \n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[835, 937, 958, 958, 1092], [1093, 1093, 1113, 1113, 1429], [1432, 1432, 1484, 1484, 1583], [1585, 1585, 1611, 1611, 2108], [2110, 2110, 2138, 2138, 3425], [3428, 3443, 3463, 3463, 3589], [3596, 3596, 3625, 3625, 4175], [4177, 4177, 4234, 4234, 4607]], "test": "timeout"}
{"id": "ttXczn", "name": "Field of asteroids", "author": "jarble", "description": "These asteroid-like objects were constructed using signed distance functions.\nThis is based on my [url=https://www.shadertoy.com/view/ts2fW3]\"Infinite planets\"[/url] shader.\nClick and drag the mouse to look around.", "tags": ["asteroids"], "likes": 1, "viewed": 207, "published": "Public API", "date": "1591245885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float scale_factor = EPSILON*10.0;\n\n\nvec3 animate(vec3 uv){\n    //float distortion = 100.0; //this makes them look like \"comets\"\n    float distortion = 10.0; //this makes them look like \"planets\"\n    \n\tvec3 p1 = uv/100.0+vec3(iTime);\n    uv += vec3(sin(p1.x),cos(p1.z),sin(p1.y))*distortion;\n    return uv;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale_factor;\n    p = animate(p);\n    p /= 100.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 5.0; i++){\n        uv += ceil(col+sin((col.x+col.y)));\n        col /= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,0.5+uv.x/500.0))/5.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF2(vec3 p) {\n\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    vec3 p1 = p / 5.0;\n    return  3.0 + sin(length(p*10.0)/10.0) + cos(p1.x)+cos(p1.y)+cos(p1.z);\n}\n\nfloat sceneSDF1(vec3 p){\n\treturn max(sceneSDF2(p/2.0),-sceneSDF2(p));\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale_factor;\n    p = animate(p);\n    return max(sceneSDF1(p*1.0),sceneSDF1(p/1.5))*scale_factor;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(5.0, 5.0, 5.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 247, 316, 496], [498, 498, 526, 526, 1055], [1057, 1297, 1322, 1449, 1550], [1552, 1552, 1576, 1576, 1623], [1625, 1625, 1649, 1649, 1758], [1760, 2181, 2272, 2272, 2578], [2593, 2847, 2912, 2912, 3044], [3046, 3135, 3164, 3164, 3474], [3476, 3968, 4108, 4108, 4698], [4700, 5070, 5155, 5155, 5913], [5915, 6242, 6291, 6326, 6457], [6459, 6459, 6516, 6516, 7399]], "test": "timeout"}
{"id": "ttXyW2", "name": "moiré_2", "author": "TAKUSAKU", "description": "moiré_2", "tags": ["moir"], "likes": 2, "viewed": 49, "published": "Public", "date": "1593072759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n    vec3 u=normalize(vec3(2.*FC-iResolution.xy,(1e3+16.*sin(iTime))*8.))*5e4;\n    for(int i=0;i<9;i++)\n        u.x+=fract(u.y+iTime)*.2,\n        u.xy+=sin(u.y+iTime*6.)*.1,\n        o=cos(float(u)+vec4(.3,.1,0,0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 258]], "test": "ok"}
{"id": "ttXyzM", "name": "Doodling with Tuxic", "author": "Flopine", "description": "This is a version of the end result from a 30 minutes concert for which I made live coded visuals. \nThanks to BinaryChiptune for having me and Tuxic for his trust :) \nCheck out the set here: https://youtu.be/Nqf8bevzTxE", "tags": ["raymarching", "geometry", "isometric", "orthographic", "twitch", "vjing"], "likes": 6, "viewed": 135, "published": "Public", "date": "1591652372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853071\n#define BPM 120./60.\n#define ITER 64.\n\n#define time iTime\n#define dt(speed) fract(time*speed)\n#define bouncy(speed) (abs(sqrt(sin(dt(speed)*PI))))\n#define ease(speed) easeInOutCirc(dt(speed))\n#define loopease(speed) easeInOutCirc(abs(-1.+2.*dt(speed)))\n\n#define sblur 1.05\n#define wiresquare(s,w,puv) smoothstep(s,s*sblur,length(max(abs(puv.x),abs(puv.y))-w))\n\n\n// TOOLS ////////////////////////////////////////\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = atan(p.y,p.x);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat easeInOutCirc (float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - (2. * x) * (2. * x))) / 2.\n        : (sqrt(1. - (-2. * x + 2.) * (-2. * x + 2.)) + 1.) / 2.;\n}\n\n\n// 2D //////////////////////////////////////////\nvec3 pattern1(vec2 uv)\n{\n    float d = wiresquare(0.02,0.1-ease(BPM)*.8, uv);\n    return (d<=0.)?vec3(1.):vec3(0.);\n}\n\n// 3D //////////////////////////////////////////\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p.xyz, p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    float per = 5.;\n    p.xz = mod(p.xz-per*.5,per)-per*.5;\n    mo(p.xz, vec2(1.));\n    p.x += (-1.+2.*loopease(BPM/2.))*.5;\n    return max(-sc(p,0.9-bouncy(BPM/4.)*0.2),box(p,vec3(1.)));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\n// MAIN ///////////////////////////////////////\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec2 uu = uv;\n    \n    moda(uv, 6.);\n    uv.x -= .5;\n\n    vec3 ro = vec3(uv*9.,-50.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = normalize(vec3(1.,1.,-1.)),\n        col = vec3(0.,0.01,0.04);\n\n    bool hit=false;\n\n    for (float i=0.; i<ITER;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += d*rd*.9;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.);\n        col = mix(vec3(0.1,0.5,0.9),vec3(0.5,0.8,0.1),light);\n    }\n    col = (pattern1(uu).x <= 0.)? col : 1.-col;\n\n    fragColor = vec4(sqrt(clamp(col,0.,1.)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXyzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[726, 776, 796, 796, 839], [841, 841, 873, 873, 920], [922, 922, 959, 959, 1082], [1084, 1084, 1115, 1115, 1255], [1258, 1307, 1331, 1331, 1424], [1426, 1475, 1503, 1503, 1589], [1591, 1591, 1619, 1619, 1700], [1702, 1702, 1722, 1722, 1973], [1975, 1975, 1998, 1998, 2112], [2114, 2162, 2218, 2218, 3023]], "test": "timeout"}
{"id": "wd2BW3", "name": "Light glow", "author": "Paltoquet", "description": "Some fun with sinus random function you can adjust the blur of the image and the number of ray", "tags": ["light", "glow"], "likes": 2, "viewed": 298, "published": "Public API", "date": "1591020040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.142\n#define ANIMATION_DURATION 120.0\n#define ANIMATION_SPEED 15.0\n#define BLUR_RADIUS 6\n\nfloat random (float theta) {\n    float period = 230.000;\n    return fract(sin(dot(theta, period * period))* 2.856);\n}\n\nfloat getCurrentTime() {\n    float coef = mod(iTime * ANIMATION_SPEED, ANIMATION_DURATION);\n    coef = coef / ANIMATION_DURATION;\n    coef = max(0.0, coef);\n    return coef;\n}\n\nfloat period(float theta, float nbCroissant) {\n    float period = 2.0 * PI;\n\tperiod = period * nbCroissant;\n    return sin(theta * period);\n}\n\nfloat square(vec2 position, vec2 dim) {\n    if(abs(position.x) < dim.x && abs(position.y) < dim.y) {\n        return 1.0;\n    } \n    return 0.0;\n}\n\nfloat sphere(vec2 position, vec2 center, float radius) {\n    if(length(position - center) <= radius) {\n        return 1.0;\n    } \n    return 0.0;\n}\n\nfloat circle(vec2 position, float radius, float width){\n    float dist = abs(length(position) - radius);\n    if(dist < width) {\n        return width;\n    }\n    return 0.0;\n}\n\nfloat easingIn(float val) {\n    return pow(val, 3.0);\n}\n\nfloat easingOut(float val) {\n    return 1.0 - pow(1.0 - val, 5.0);\n}\n\nfloat generateSphere(vec2 position) {\n    vec2 centers[8];\n    float radius[8];\n    centers[0] = vec2(0.580,0.230);\n    centers[1] = vec2(0.320,0.630);\n    centers[2] = vec2(-0.340,0.260);\n    centers[3] = vec2(-0.750,0.240);\n\tcenters[4] = vec2(-0.630,-0.430);    \n\tcenters[5] = vec2(-0.120,0.770);   \n    centers[6] = vec2(0.330,-0.630);\n    centers[7] = vec2(0.440,-0.240);\n    \n    radius[0] = 0.028;\n    radius[1] = 0.037;\n    radius[2] = 0.049;\n\tradius[3] = 0.032;\n    radius[4] = 0.024;\n    radius[5] = 0.042;\n    radius[6] = 0.062;\n    radius[7] = 0.080;\n    \n    float result = 0.0;\n    float theta = atan(position.y, position.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    float coef = getCurrentTime();\n    coef = coef * 0.68;\n    for(int i = 0; i < 8; i++){\n        vec2 center = centers[i];\n        float radius = radius[i];\n        center = mix(vec2(0), center, coef);\n        radius = mix(0.001, radius, coef);\n        result = max(result, sphere(position, center, radius));\n    }\n    return result;\n}\n\nfloat generateCroissant(vec2 position, float nbCroissant) {\n    float theta = atan(position.y, position.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    float coef = getCurrentTime();\n    \n    //coef = 1.0;\n    \n    float currentCroissant = floor(current * nbCroissant);\n    \n    float amplitude = random(currentCroissant);\n    \n    float range = period(current, nbCroissant);\n    float dist = length(position);\n    range = range * amplitude * coef;\n    dist = dist < range ? range : 0.0;\n    return dist;\n}\n\n/*float glow(vec2 pos) {\n    float theta = atan(pos.y, pos.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); \n    float firstPeriod = PI;\n    float secondPeriod = 5.0;\n    float soft = 0.436;\n    float constant = 0.552;\n    float curve = (sin(current * firstPeriod) + sin(current * secondPeriod * firstPeriod) * soft) * 0.2 + constant;\n    float dist = length(pos);\n    return max(0.0, curve - dist);\n}*/\n        \n\nvec4 getColor(vec2 pos){\n    float nbCroissant = 120.0;\n    float currentTime = getCurrentTime();\n    //nbCroissant = mix(0.0, 200.0, currentTime);\n    \n    float theta = atan(pos.y, pos.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    vec4 firstRedColor = vec4(0.995,0.364,0.162,1.000);\n    vec4 firstYellowColor = vec4(0.412,0.639,0.995,1.000);\n    vec4 firstColor = mix(firstYellowColor, firstRedColor, easingIn(1.0 - abs((current - 0.5)) * 1.0));\n    vec4 secondColor = vec4(0.995,0.924,0.362,1.000);\n    vec4 backGroundColor = vec4(0.001,0.000,0.005,1.000);\n    \n    float circleRadius = mix(0.0, 0.065, currentTime);\n    float circleWidth = mix(0.01, 0.065, currentTime);\n    \n    float dist = generateCroissant(pos, nbCroissant);\n    dist = max(dist, generateCroissant(pos, nbCroissant / 6.0)); // play with thoose\n    //dist = max(dist, generateCroissant(pos, nbCroissant / 8.0)); // play with thoose\n    //dist = max(dist, square(pos, vec2(0.22, 0.22)));\n    dist = max(dist, generateSphere(pos));\n    dist = max(dist, easingIn(circle(pos, circleRadius, circleWidth)));\n    //st = max(dist, glow(pos));\n    vec4 color = dist != 0.0 ? mix(firstColor, secondColor, easingIn(dist)) : backGroundColor;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st * vec2(2.0) - vec2(1.0);\n    vec2 pixelOffset = vec2(1.0) / iResolution.xy;\n\tint blurRadius = 5;\n    vec4 color = getColor(st);\n    \n    for(int i = -1 * BLUR_RADIUS; i < BLUR_RADIUS; i++) {\n        for(int j = -1 * BLUR_RADIUS; j < BLUR_RADIUS; j++) {\n            vec2 offset = vec2(i, j) * pixelOffset;\n            color += getColor(st + offset);\n        }\n    }\n    \n    color = color / vec4(BLUR_RADIUS * BLUR_RADIUS);\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2BW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 130, 130, 219], [221, 221, 245, 245, 396], [398, 398, 444, 444, 539], [541, 541, 580, 580, 686], [688, 688, 744, 744, 835], [837, 837, 892, 892, 1010], [1012, 1012, 1039, 1039, 1067], [1069, 1069, 1097, 1097, 1137], [1139, 1139, 1176, 1176, 2310], [2312, 2312, 2371, 2371, 2978], [3522, 3522, 3546, 3546, 4907], [4909, 4909, 4965, 4965, 5469]], "test": "error"}
{"id": "wd2fDc", "name": "noise test 0", "author": "tripzilch", "description": "yeah this noise is pretty bad", "tags": ["noise"], "likes": 1, "viewed": 76, "published": "Public", "date": "1591041903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) );\n    vec3 col = vec3(sa);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2fDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 67], [69, 69, 126, 126, 295]], "test": "ok"}
{"id": "Wd2fW3", "name": "六一", "author": "yuehongliang", "description": "font", "tags": ["fontlxs"], "likes": 2, "viewed": 106, "published": "Public", "date": "1590987820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//refreence https://www.shadertoy.com/view/MlfGz8\n//just change the char map\n\nvec2 cur = vec2(0.);\nvec3 cl = vec3(0.);\n\nfloat wave = 0.;\nfloat cshift = 0.1;\nbool bSmall = false;\n\nfloat focus = .5;\nfloat size = 1.;\n\n\n//https://www.shadertoy.com/view/4sXSWs strength= 16.0\nvec3 filmGrain(vec2 uv, float strength ){       \n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 10.0);\n\treturn  vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n\n}\n\nfloat hash(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\n\n\nvec3 circleGlow( vec2 pos ){ \n\n    vec3 col = vec3(\n    \tpow(20. / length((pos+vec2(cshift,0.))*size), focus - .5),\n        pow(20. / length(pos*size), focus ),\n        pow(20. / length((pos-vec2(cshift,0.))*size), focus + .5)\n    );\n    \n\treturn col;\n}\n\n\nvec3 bm(vec3 c1, vec3 c2){\n\treturn 1.- (1.-c1)*(1.-c2);\n}\n\nvoid C(vec2 fragCoord, bool s){\n\tcur.x--;\n    if(!s) return;\n    //if(s){\n        //48 - is the length\n        vec2 pos = vec2((fragCoord.xy - iResolution.xy/2. + (cur+vec2(48.2/2., -2.5))*10.) / 15.);\n        \n        \n        //focus_c = floor( focus *  sin(fragCoord.y - iResolution.y) *1.)/1.;\n        //size_c = size*filmGrain(cur, 1.0).x*1000.; //floor( size *  sin(fragCoord.x - iResolution.x) *1.)/1. ;\n        \n        //float var = clamp(hash(cur)*10., .1, 1.); //variations\n        float var = hash(cur)*.5;\n        //float var = hash2(cur)*.5;\n\n        \n        float t = var + iTime;\n        \n        if(bSmall) {\n            wave = 4.*abs( sin(t)*sin(t*3.) );\n            cshift = .12;\n        }else{\n        \twave = .4*sin(t)*sin(t*3.);\n        \tcshift = .0; //.1?\n        }\n        \n        size = 200.*( 1.-.3+ wave); //br =.4\n        focus = 2.*(.82 + .02*sin(t*40.)*sin(30.+t*20.)); \n        \n        vec3 c = circleGlow(pos);\n        cl = bm(cl, c);\n        //cl = cl*c;         \n        //cl = cl+c;         \n        //cl = max(cl*.5, circleGlow( pos ));\n\n    //}\n} \n\n//next line\nvoid NL(){\n    cur.y++;\n    cur.x=0.;\n}\n\n\n#define X C(fragCoord,true);\n#define _ C(fragCoord,false);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t\n    //size =200.*(1.-iMouse.x/iResolution.x); //size\n    //focus = 2.*(iMouse.y/iResolution.y); // focus\n\n    //prev pulse\n    //size = 200.*(1.-.3+ .4*sin(iTime)*sin(iTime*3.));\n    //focus = 2.*(.82 + .02*sin(iTime*40.)*sin(30.+iTime*20.)); //\n    \n    //flicker - pulse\n    //y = mod(iTime, 1.);\n    \n\ncur = vec2(0.);\ncl = vec3(.0);\n\n// arc\ncur.y-=10.;\nbSmall = true;\n\t\t\t\t\t//printed mars    \n\t\t\t\t\tbSmall = false;\n                    _;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;X;_;_;_;_;_;X;X;X;X;X;_;_;_;_;_;_;X;X;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;X;_;_;_;_;_;_;_;X;_;X;_;_;_;_;_;_;X;X;_;_;_;_;_;_;_;NL();\n                    _;_;_;X;_;X;_;X;_;_;_;_;_;X;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;X;_;X;_;X;_;_;_;X;X;X;X;X;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;X;_;_;_;_;_;_;_;X;_;_;_;X;_;_;_;_;X;X;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;X;_;_;_;_;_;_;_;X;_;_;_;X;_;_;_;_;X;X;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;X;X;_;_;_;_;_;_;_;X;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;_;_;_;_;_;_;_;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    NL();\n                    NL();\n                    _;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;_;_;_;_;X;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;_;_;_;_;_;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;X;X;X;X;X;X;X;X;X;X;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;X;X;X;X;X;X;X;X;X;X;X;X;_;_;_;_;X;X;X;X;X;X;X;X;X;X;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;X;X;X;X;X;X;X;X;X;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;_;_;_;X;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n                    _;_;_;_;_;_;_;X;X;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;X;X;_;X;X;X;_;_;X;X;X;_;_;X;X;X;_;X;_;_;X;_;_;NL();\n                    _;_;_;_;_;_;_;X;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;X;_;X;_;X;_;_;X;_;X;_;_;X;_;X;_;X;X;_;X;_;_;NL();\n                    _;_;_;_;_;_;X;X;_;_;_;_;_;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;X;_;X;_;X;_;_;X;_;X;_;_;X;_;X;_;_;X;_;X;_;_;NL();\n                    _;_;_;_;_;X;X;_;_;_;_;_;_;_;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;X;_;X;X;X;X;_;X;X;X;X;_;X;X;X;_;_;X;X;X;_;_;NL();\n                    _;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;X;_;_;NL();\n                    _;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;X;_;_;NL();\n                    _;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 fg = filmGrain(uv,  20.0);\n    cl = bm(cl, fg);//1.- (1.-cl)*(1.-fg); \n    cl = cl/2.0;\n    fragColor = vec4(cl, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2fW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 271, 312, 312, 473], [475, 475, 494, 494, 561], [565, 565, 593, 593, 818], [821, 821, 847, 847, 878], [880, 880, 911, 911, 1966], [1969, 1981, 1991, 1991, 2020], [2083, 2083, 2140, 2442, 5656]], "test": "timeout"}
{"id": "Wd2yWt", "name": "eggs", "author": "ga354", "description": "eggs", "tags": ["eggs"], "likes": 0, "viewed": 181, "published": "Public API", "date": "1591684368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "                // Some useful functions\n                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n                //\n                // Description : GLSL 2D simplex noise function\n                //      Author : Ian McEwan, Ashima Arts\n                //  Maintainer : ijm\n                //     Lastmod : 20110822 (ijm)\n                //     License :\n                //  Copyright (C) 2011 Ashima Arts. All rights reserved.\n                //  Distributed under the MIT License. See LICENSE file.\n                //  https://github.com/ashima/webgl-noise\n                //\n                float snoise(vec2 v) {\n\n                    // Precompute values for skewed triangular grid\n                    const vec4 C = vec4(0.211324865405187,\n                                        // (3.0-sqrt(3.0))/6.0\n                                        0.366025403784439,\n                                        // 0.5*(sqrt(3.0)-1.0)\n                                        -0.577350269189626,\n                                        // -1.0 + 2.0 * C.x\n                                        0.024390243902439);\n                                        // 1.0 / 41.0\n\n                    // First corner (x0)\n                    vec2 i  = floor(v + dot(v, C.yy));\n                    vec2 x0 = v - i + dot(i, C.xx);\n\n                    // Other two corners (x1, x2)\n                    vec2 i1 = vec2(0.0);\n                    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n                    vec2 x1 = x0.xy + C.xx - i1;\n                    vec2 x2 = x0.xy + C.zz;\n\n                    // Do some permutations to avoid\n                    // truncation effects in permutation\n                    i = mod289(i);\n                    vec3 p = permute(\n                            permute( i.y + vec3(0.0, i1.y, 1.0))\n                                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n                    vec3 m = max(0.5 - vec3(\n                                        dot(x0,x0),\n                                        dot(x1,x1),\n                                        dot(x2,x2)\n                                        ), 0.0);\n\n                    m = m*m ;\n                    m = m*m ;\n\n                    // Gradients:\n                    //  41 pts uniformly over a line, mapped onto a diamond\n                    //  The ring size 17*17 = 289 is close to a multiple\n                    //      of 41 (41*7 = 287)\n\n                    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n                    vec3 h = abs(x) - 0.5;\n                    vec3 ox = floor(x + 0.5);\n                    vec3 a0 = x - ox;\n\n                    // Normalise gradients implicitly by scaling m\n                    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n                    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n                    // Compute final noise value at P\n                    vec3 g = vec3(0.0);\n                    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n                    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n                    return 130.0 * dot(m, g);\n                }\n\n  vec3 lin2srgb( vec3 cl )\n        {\n                //cl = clamp( cl, 0.0, 1.0 );\n                vec3 c_lo = 12.92 * cl;\n                vec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n                vec3 s = step( vec3(0.0031308), cl);\n                return mix( c_lo, c_hi, s );\n        }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    vec2 r = iResolution.xy;\n    \n    float t = iTime;\n    // Time varying pixel color\n    vec4 col;\n\n//@shader_bot\n#define c(s)d=length(g-vec2(.1-0.01*snoise(p-t/5.)))-s \n#define s smoothstep(e, -e, d)\n//void main(){\nvec2 g=p;g.x*=r.x/r.y;\nfloat d,e;e = fwidth(p).x;\ng=mod(g,.2);\nc(.06)-0.01*snoise(5.*p + t/5.);    \ncol += 1.;\ncol-=s*.2;\nd=c(.015);\ncol-=s*vec4(-.2,.5,3.,.1);\ng-=vec2(0.005);d=c(0.0015);col+=s;\n//}\n    \n    // Output to screen\n    fragColor.xyz = lin2srgb(col.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 57, 78, 78, 125], [142, 142, 163, 163, 210], [227, 227, 249, 249, 284], [302, 783, 805, 874, 3307], [3311, 3311, 3345, 3391, 3606], [3609, 3609, 3666, 3716, 4260]], "test": "timeout"}
{"id": "WdBBz3", "name": "Glass Cube With Dispersion", "author": "ChrisK", "description": "Modified version of my previous shader: https://www.shadertoy.com/view/WdSczh", "tags": ["3d", "raytracing", "refraction", "reflections", "translucency", "dispersion"], "likes": 32, "viewed": 525, "published": "Public API", "date": "1592021456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//June 21, 2020: Added chromatic abberation\n\n#define ABSORBTION \t\t\t\tvec3(0.03)\n#define IOR \t\t\t\t\t1.5\n#define DISPERSION \t\t\t\t0.03\n#define CHROMATIC_ABBERATION\t0.01\n\n#define TIMESCALE 0.35\n#define INTERNAL_REFLECTIONS 4\n#define SAMPLES 30.0\n\n\n#define rot2(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nvec3 rotate ( vec3 p, vec3 r ) {\n    p.yz *= rot2(r.x);\n    p.xz *= rot2(-r.y);\n    p.xy *= rot2(r.z);\n    return p;\n}\n\n\nfloat InteriorCubeReflection ( vec3 ro, vec3 rd ) {\n    vec3 d = (0.5*sign(rd)-ro)/rd;\n    return min( min(d.x, d.y), d.z );\n}\n\n\nfloat IntersectCube ( vec3 ro, vec3 rd ) {\n    float dfront = -InteriorCubeReflection(-ro,rd);\n    float dback  = InteriorCubeReflection(ro,rd);\n    return dback>=dfront ? dfront : -1.0;\n}\n\n\nfloat GetReflectance ( vec3 i, vec3 t, vec3 nor, float iora, float iorb ) {\n    vec2 c = nor * mat2x3(i,t);\n    vec2 ior = vec2(iora,iorb);\n    vec2 sp = ( mat2(c,-c.yx)*ior ) / ( mat2(c,c.yx)*ior );\n    return dot(sp,sp)/2.0;\n}\n\n\nvec3 GetSky ( vec3 rd ) {\n    float v = dot(rd, vec3(0.5,-0.15,0.85));\n    v = smoothstep(-0.05, 0.05, sin(v*50.0));\n    return vec3( v );\n}\n\n\nvec3 GetDispersedColor( float w ) {\n    return max( sin( ( w - vec3(0.0,0.25,0.5) ) * 6.28318531 ), 0.0);\n    /*\n    vec3 s = vec3(0.9, 1.0, 0.8);\n    vec3 c = w - vec3( 0.0, 0.25, s.b-0.5 );\n    c = clamp(c*s, 0.0, 1.0) * 6.28318531;\n    c = sin(c) * s;\n    return max( c, 0.0);\n\t*/\n}\n\n\nvec3 GetRenderSample ( vec3 ro, vec3 rd, float df ) {\n\tfloat rl = IntersectCube( ro, rd );\n    \n    if ( rl > 0.0 ) {\n        \n        float iord = IOR + DISPERSION*(df-0.5);\n        \n        vec3 xyz = ro + rd*rl;\n        vec3 nor = round( xyz*1.00001 );\n        vec3 power = vec3(1.0);\n        vec3 refractd = refract( rd, nor, 1.0/iord );\n        vec3 reflectd = reflect( rd, nor );\n        float refl = GetReflectance ( rd, refractd, nor, 1.0, iord );\n        vec3 c = GetSky(reflectd) * refl;\n        power *= 1.0-refl;\n        rd = refractd;\n\n        for ( int i=0; i<INTERNAL_REFLECTIONS; i++ ) {\n        \trl = InteriorCubeReflection( xyz, rd );\n        \txyz += rd*rl;\n            nor = round( xyz*1.00001 );\n        \trefractd = refract( rd, -nor, 1.0/iord );\n        \treflectd = reflect( rd, -nor );\n        \trefl = GetReflectance ( rd, refractd, -nor, iord, 1.0 );\n        \tpower *= exp( -ABSORBTION * rl );\n            c += GetSky(refractd) * (1.0-refl) * power;\n            power *= refl;\n            rd = reflectd;\n        }\n        return c;\n    } else {\n    \treturn GetSky(rd);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.x;\n    \n    vec3 col = vec3(0.0);\n    for ( float f = 0.0; f<SAMPLES; f++ ) {\n        float w = f/SAMPLES;\t\t// wavelength sample ( 0 => 1 across visible spectrum )\n        \n        float b = (fract(f*134.102119) - 0.5) / 60.0;\t\t\t\t\t\t\t//temporal offset for motion blur\n        vec2 aa = (fract((f+uv)*134.102119+iTime)-0.5)/iResolution.x*3.0;\t\t//quick and sloppy positional offset for aa\n        \n        vec3 cp = vec3( aa, -2.5);\n        vec3 cr = normalize( vec3(uv,1.0+w*CHROMATIC_ABBERATION) );\n    \tcp = rotate( cp, vec3( (iTime + b) * TIMESCALE ) );\n        cr = rotate( cr, vec3( (iTime + b) * TIMESCALE ) );\n        \n        vec3 c = GetRenderSample( cp, cr, w );\n        \n        vec3 sp = GetDispersedColor(w);\n    \tcol += c * sp;\n    }\n    col /= SAMPLES/3.0;\n    \n    col = smoothstep(0.0, 1.0, col);\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBBz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 325, 325, 411], [414, 414, 465, 465, 540], [543, 543, 585, 585, 731], [734, 734, 809, 809, 962], [965, 965, 990, 990, 1105], [1108, 1108, 1143, 1143, 1393], [1396, 1396, 1449, 1449, 2495], [2498, 2498, 2555, 2555, 3501]], "test": "timeout"}
{"id": "WdBfDd", "name": "House of Happy", "author": "boeroboy", "description": "Remix of Happy Jumper by Inigo Quilez as I've been learning through the shader deconstruction.", "tags": ["sound"], "likes": 2, "viewed": 212, "published": "Public API", "date": "1591722250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n// An animation test - a happy and blobby creature jumping and\n// looking around. It gets off-model very often, but it looks\n// good enough I think.\n//\n// Making-of and related math/shader/art explanations (6 hours\n// long): https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\n// Video capture: https://www.youtube.com/watch?v=s_UOFo2IULQ\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n//------------------------------------------------------------------\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n\nvec4 map( in vec3 pos, float atime )\n{\n    hsha = 1.0;\n    \n    float js = 2.1;\n    atime *= js;    \n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1); // derivative of p\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.1,\n                     atime/js - 1.5);\n\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );\n\n    if( res.x-1.0 < pos.y ) // bounding volume\n\t{\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t// head\n    vec3 h = r;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    // belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    // arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    // ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.xz = smin( res.xz, ear, 0.01 );\n    }\n    \n    // mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n    res.x = smax( res.x, -d, 0.03 );\n    }\n\n\t// legs\n    {\n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    float ccc = cos(1.57*t6*sign(r.x));\n    float sss = sin(1.57*t6*sign(r.x));\n\tvec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;\n    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n    res.xz = smin( res.xz, legs, 0.07 );\n    }\n        \n    // eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\t}\n    \n    // ground\n    float fh = -0.2 - 0.05*(sin(pos.x)+sin(pos.z));\n    float t5f = fract((atime)+0.05);\n    float t5i = atime/2.1-0.25; \n    float bt4 = abs(fract(t5i/2.0)-0.5)*2.0;\n    vec2  bcen = vec2( floor(cen.x) + .5, cen.z);\n    \n    float k = length(pos.xz-bcen);\n    float tt = t5f*15.0-6.2831 - k*3.0;\n    fh -= 0.05*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);\n    float d = pos.y - fh;\n    \n    // bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );\n    \n    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }\n    }\n\n    // candy\n    {\n        float beat = texture(iChannel0, vec2(0.9,0.)).x * 2.;\n        float fs = 5.0;\n        vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );\n        vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n        vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y - beat,fract(qos.z+0.5)-0.5);\n        vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n        float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n        float fid = id.x*0.143 + id.y*0.372;\n        float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);\n        d = sdSphere( vp, 0.35*ra)/fs;\n        if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);\n    }\n    \n    return res;\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.5-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    // raymarch scene\n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    \n    \n\n    // scene geometry\n    vec4 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  // candy\n        { \n             col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n        }\n        else if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.144,0.09,0.0036),vec3(0.36,0.1,0.04),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n\t\telse // terrain\n        {\n            // base green            \n            col = vec3(0.05,0.09,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.06,0.06,0.02);\n            ks = 0.5 + pos.y*0.15;\n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        // fog\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n#endif\n        time += -2.6;\n        time *= 0.9;\n        \n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        //ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n        // color grading\n        col = col*vec3(1.11,0.89,0.79);\n\n        // compress        \n        col = 1.35*col/(1.0+col);\n        \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "lt2GzV", "previewfilepath": "https://soundcloud.com/cafedelantaarn/house-of-pain-jump-around", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/cafedelantaarn/house-of-pain-jump-around", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfDd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[644, 696, 737, 737, 809], [811, 863, 901, 901, 998], [1000, 1052, 1093, 1093, 1165], [1167, 1241, 1276, 1276, 1302], [1304, 1378, 1437, 1437, 1526], [1528, 1528, 1602, 1602, 1755], [1757, 1809, 1839, 1839, 1872], [2069, 2069, 2107, 2107, 7183], [7185, 7185, 7237, 7237, 7739], [7741, 7803, 7863, 7863, 8301], [8303, 8367, 8411, 8411, 8974], [8976, 8976, 9037, 9037, 9330], [9332, 9332, 9383, 9400, 12672], [12674, 12674, 12726, 12726, 12903]], "test": "error"}
{"id": "wdfczN", "name": "rubik", "author": "6502", "description": "A rubik cube...", "tags": ["rubik"], "likes": 5, "viewed": 112, "published": "Public", "date": "1592334501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 sdf1(vec3 p, float id, float spacing, float side, float offset,\n          vec2 xclip,\n          vec2 yclip,\n          vec2 zclip) {\n    float dx = abs((p.x - clamp(floor(p.x/spacing+0.5), xclip.x, xclip.y)*spacing)) - side;\n    float dy = abs((p.y - clamp(floor(p.y/spacing+0.5), yclip.x, yclip.y)*spacing)) - side;\n    float dz = abs((p.z - clamp(floor(p.z/spacing+0.5), zclip.x, zclip.y)*spacing)) - side;\n    if (dx < 0. && dy < 0. && dz < 0.) return vec2(max(dx, max(dy, dz)) - offset, id);\n    dx = max(dx, 0.); dy = max(dy, 0.); dz = max(dz, 0.);\n    return vec2(sqrt(dx*dx + dy*dy + dz*dz) - offset, id);\n}\n\nfloat pi4 = 3.14159265359*2.;\n\nvec2 sdf(vec3 p) {\n    float t = iTime*0.337;\n    if ((int(t) & 1) == 0) {\n        if (p.x < -35.) {\n            float c = cos(-t*pi4), s = sin(-t*pi4);\n            p = vec3(p.x, p.y*c + p.z*s, p.z*c - p.y*s);\n        }\n    } else {\n        if (p.y > 35.) {\n            float c = cos(t*pi4), s = sin(t*pi4);\n            p = vec3(p.x*c + p.z*s, p.y, p.z*c - p.x*s);\n        }\n    }\n    vec2 full=vec2(-1., 1.);\n    vec2 neg=vec2(-1., -1.);\n    vec2 pos=vec2(1., 1.);\n\tvec2 a = sdf1(p, 0., 70., 30., 5., full, full, full);\n    vec2 b = sdf1(p + vec3(0., -8., 0.), 1., 70., 25., 5., full, pos, full); if (b.x < a.x) a = b;\n    b = sdf1(p + vec3(0., 8., 0.), 6., 70., 25., 5., full, neg, full); if (b.x < a.x) a = b;\n    b = sdf1(p + vec3(-8., 0., 0.), 2., 70., 25., 5., pos, full, full);  if (b.x < a.x) a = b;\n    b = sdf1(p + vec3(8., 0., 0.), 3., 70., 25., 5., neg, full, full);  if (b.x < a.x) a = b;\n    b = sdf1(p + vec3(0., 0., -8.), 4., 70., 25., 5., full, full, pos);  if (b.x < a.x) a = b;\n    b = sdf1(p + vec3(0., 0., 8.), 5., 70., 25., 5., full, full, neg);  if (b.x < a.x) a = b;\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 450., h = r*0.6, dist = r*1.5;\n\tvec3 p = vec3(r*cos(iTime), h, r*sin(iTime));\n    vec3 w = normalize(-p);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 d = normalize(w*dist + (fragCoord.x - iResolution.x*0.5)*u + (fragCoord.y - iResolution.y*0.5)*v);\n    vec4 col = vec4(0., 0., 0., 1.);\n    vec3 pp;\n    float t = 0.;\n    vec2 fv;\n    for (int i=0; i<1000; i++) {\n        pp = p + t*d;\n        fv = sdf(pp);\n        if (abs(fv.x) < 0.1 || t > 1000.) break;\n        t += fv.x * 0.25;\n    }\n    if (t > 1000.) {\n        col = abs(d.y) * vec4(1.0, 1.0, 1.0, 1.0);\n    } else {\n        vec3 n = normalize(vec3(sdf(vec3(pp.x+.1, pp.y, pp.z)).x - fv.x,\n    \t\t\t\t\t\t\tsdf(vec3(pp.x, pp.y+.1, pp.z)).x - fv.x,\n    \t\t\t\t\t\t\tsdf(vec3(pp.x, pp.y, pp.z+.1)).x - fv.x));\n        float L = 0.5 - 0.5*dot(n, d);\n        if (fv.y == 0.) {\n            col = L * vec4(0.2, 0.2, 0.2, 1.0);\n        //*\n        } else if (fv.y == 1.) {\n            col = L * vec4(1.0, 1.0, 1.0, 1.0);\n        } else if (fv.y == 2.) {\n            col = L * vec4(1.0, 0.2, 0.2, 1.0);\n        } else if (fv.y == 3.) {\n            col = L * vec4(1.0, 0.5, 0.2, 1.0);\n        } else if (fv.y == 4.) {\n            col = L * vec4(0.2, 1.0, 0.2, 1.0);\n        } else if (fv.y == 5.) {\n            col = L * vec4(0.2, 0.2, 1.0, 1.0);\n        //*/\n        } else {\n            col = L * vec4(1.0, 1.0, 0.2, 1.0);\n        }\n    }\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfczN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 136, 136, 618], [1759, 1759, 1816, 1816, 3272]], "test": "timeout"}
{"id": "WdjBDd", "name": "polar coordinates, animation tex", "author": "ligaobo", "description": "用于研究极坐标的使用", "tags": ["texture2d", "polarcoordinates"], "likes": 1, "viewed": 55, "published": "Public", "date": "1591149117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = float(3.14159265359);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / (iResolution.y);\n    \n    float r = 1.0;\n    float z = -sqrt(max(r * r - dot(p, p), 0.0));\n\t//uv.x ∈ [1, 0]. uv.y ∈ [1.0, 0.0] (x从左至右；y从下至上)\n    //uv = vec2(1.0 + atan(z, p.x) / PI, 0.5 + asin(p.y) / PI);\n    p *= 2.0;\n\n    if(p.x < 0.0)\n    {\n        if(p.y > 0.0)\n        {\n            vec2 q = p - vec2(-1.0, 1.0);\n            float theta = atan(q.x, q.y);\n            theta += sin(pow(length(q), 3.0) * 15.0 - iTime * 3.0) * 0.5;\n\n            float veins = sin(theta * 20.0) * 0.5 + 0.5;\n            veins *= veins;\n            veins *= (sin(theta * 13.0) * 0.5 + 0.5);\n            veins *= smoothstep( 0.0, 0.2, length(uv.xy - 0.5));\n            veins *= veins;\n            veins *= 0.5;\n            fragColor = vec4(veins); return;\n        }\n        else\n        {\n            vec2 q = p - vec2(-1.0, -1.0);\n            float qLen = length(q);\n            float theta = atan(q.y, q.x);\n            \n            float mode = mod(iTime, 10.0);\n            if(mode < 2.0)\n            {\n                float sfunc = 0.5 +(sin(theta * 14.0) * 2.0);\n                fragColor = vec4(sfunc); return;\n            }\n            else if(mode < 4.0)\n            {\n                float sfunc = 0.5 + 0.05*exp(sin(theta * 14.0) * 2.0);\n                fragColor = vec4(sfunc); return;\n            }\n            else if(mode < 6.0)\n            {\n                float sfunc = 0.5 + 0.05*exp(sin(theta * 14.0) * 2.0);\n                float shape = 1. - smoothstep(sfunc, sfunc + 0.1, qLen);\n                fragColor = vec4(shape); return;\n            }\n            else if(mode < 10.0)\n            {\n                float sfunc = 0.5 + 0.05*exp(sin(theta * 14.0) * 2.0);\n                float shape = 1. - smoothstep(sfunc, sfunc + 0.1, qLen);\n                fragColor = texture(iChannel0, vec2(shape, qLen)); return;\n            }\n        }\n    }\n    else\n    {\n        if(p.y > 0.0)\n        {\n            vec2 q = p - vec2(1.0, 1.0);\n            q *= 0.8;\n            float qLen = length(q);\n            float theta = atan(q.y, q.x) - iTime;\n\n            q = qLen * vec2(cos(theta), sin(theta));\n\t        float sfunc = 0.01 * exp(sin(atan(q.y, q.x) * 10.) * 0.5);\n\n            fragColor = texture(iChannel2, vec2(sfunc * (10.0 * sin(iTime * 0.5) + 22.0), qLen));\n        }\n        \n    }\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 96, 96, 2500]], "test": "error"}
{"id": "WdjBDt", "name": "Colorful Spheres", "author": "JacobC", "description": "Simple ray cast shader. You can use the mouse to rotate the camera (use left click while moving mouse)", "tags": ["3d", "light", "sphere"], "likes": 7, "viewed": 147, "published": "Public", "date": "1591129981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(in vec3 o, in vec3 d, in vec4 c)\n{\n    vec3 oc = o-c.xyz;\n    float B = dot(d, oc);\n    float C = dot(oc, oc) - c.w*c.w;\n    float D = B*B-C;\n    if (D <= 0.)\n        return 0.;\n    return -B-sqrt(D);\n}\n\n#define OBJS 7\n\n#define Kc 1.\n#define Kl 1.7\n#define Kq 4.5\n\n#define S_1 vec3(1., .7, .5)\n#define S_2 vec3(.5, .7, 1.)\n\n#define T iTime*.25\n#define hPi 3.141592*.5\n\n#define AA 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 f_col = vec3(0.);\n    vec2 st = fragCoord.xy;\n    vec2 m = iMouse.xy/iResolution.y*2.-1.;\n    for (float y = 0.; y < AA; y++)\n    {   \n    \tfor (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n\n            vec3 col = vec3(1.);\n            vec3 o = vec3(sin(m.x*hPi), sin(m.y*hPi), cos(m.x*hPi))*6.;\n            vec3 t = vec3(0., 0., -1.);\n\n            vec3 w = normalize(o-t);\n            vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n            vec3 v = cross(w, u);\n\n            vec3 d = normalize(vec3(uv, -1.));\n            d = u*d.x + v*d.y + w*d.z;\n\n            vec4 c[OBJS] = vec4[]\n                (\n                    vec4(cos(T), -sin(T), -cos(T)*sin(T-90.), 1.5),\n                    vec4(-cos(T+.3)*2., sin(T+.9)*2., cos(T+10.2)*-sin(T), 1.26),\n                    vec4(cos(T+1.95)*2., sin(T+.95)*2., -cos(T)*-sin(T-4.), 1.43),\n                    vec4(cos(T+3.4)*2., -sin(T+3.)*2., cos(T+2.)*sin(T), 1.17),\n                    vec4(cos(T+.05)*2., sin(T+4.05)*2., cos(T-2.)*sin(T), 1.41),\n                    vec4(-cos(T+5.)*2., -sin(T+5.1)*2., cos(T+1.2)*sin(T+3.), 1.29),\n                    vec4(-cos(T+6.1)*2., sin(T+6.14)*2., cos(T+.4)*sin(T-8.), 1.5)\n                );\n            vec3 c_c[OBJS] = vec3[]\n                (\n                    vec3(1.),\n                    vec3(1., 0., 0.),\n                    vec3(1., 1., 0.),\n                    vec3(0., 1., 0.),\n                    vec3(0., 1., 1.),\n                    vec3(0., 0., 1.),\n                    vec3(1., 0., 1.)\n                );\n\n            int index = -1;\n            float max_s = 100.;\n            for (int i = 0; i < OBJS; i++)\n            {\n                float s = sphere(o, d, c[i]);\n                if (s > 0. && s < max_s)\n                {\n                    index = i;\n                    max_s = s;\n                }\n            }\n\n            if (index != -1)\n            {\n                vec3 p = o + d * max_s;\n                vec3 n = (p-c[index].xyz)/c[index].w;\n\t\t\t\tvec3 sky = mix(S_1, S_2, (n.y+1.)*.5); \n                for (int i = 0; i < OBJS; i++)\n                {\n                    if (i == index)\n                        continue;\n                    float s = length(p-c[i].xyz)-c[i].w;\n                    float att = 1. / (Kc + Kl*s + Kq*s*s);\n                    \n                    col *= mix(c_c[i]*sky, c_c[index], 1.-att);\n                }\n                col *= sky;\n            }\n            else\n                col *= mix(S_1, S_2, d.y+.5);\n\n            f_col += col;\n        }\n    }\n    f_col /= pow(AA, 2.);\n    \n    fragColor = vec4(sqrt(f_col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 215]], "test": "timeout"}
{"id": "WdjBWc", "name": "Energy plant", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 53, "viewed": 2337, "published": "Public", "date": "1591017640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.0)\n#define TAU PI*2.0\n\nconst float maxd=80.0;\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\nvec2 pSFold(vec2 p,float n)\n{\n    float h=floor(log2(n)),a =6.2831*exp2(h)/n;\n    for(float i=0.0; i<h+2.0; i++)\n    {\n\t \tvec2 v = vec2(-cos(a),sin(a));\n\t\tfloat g= dot(p,v);\n \t\tp-= (g - sqrt(g * g + 5e-3))*v;\n \t\ta*=0.5;\n    }\n    return p;\n}\n\nvec2 sFold45(vec2 p, float k)\n{\n    vec2 v = vec2(-1,1)*0.7071;\n    float g= dot(p,v);\n \treturn p-(g-sqrt(g*g+k))*v;\n}\n\nfloat frameBox(vec3 p, vec3 s, float r)\n{   \n    p = abs(p)-s;\n    p.yz=sFold45(p.yz, 1e-3);\n    p.xy=sFold45(p.xy, 1e-3);\n    p.x = max(0.0,p.x);\n\treturn lpNorm(p,5.0)-r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat deObj(vec3 p)\n{   \n    return min(min(sdRoundBox(p,vec3(0.3),0.1),frameBox(p,vec3(0.7),0.05)),frameBox(p,vec3(0.5),0.01));\n}\n\nfloat g = 0.0;\n\nfloat map(vec3 p)\n{\n    float de=1e9;\n    p.z-=iTime*1.5;\n    p.z=mod(p.z,12.)-6.;\n    vec3 q=p;\n    p.xy=pSFold(p.xy,6.0);\n    p.y-=5.;\n    float s=1.0;\n    for(float i=0.;i<6.;i++)\n    {\n        p.xy=abs(p.xy)-.5;\n        p.z=abs(p.z)-.3;\n        p.xy*=rot(-0.05);\n        p.zy*=rot(0.1);\n        s*=0.7;\n        p*=s;\n        p.xy*=rot(0.05);\n        p.y-=0.3;\n        vec3 sp=p/s;\n        de=min(de,\n           min(sdRoundBox(sp,vec3(0.3),0.1),\n               frameBox(sp,vec3(0.7),0.05)));\n    }\n    q.z-=clamp(q.z,-1.,1.);\n    float d=length(q)-0.5;\n    g += 0.1/(0.2+d*d*5.0); // Distance glow by balkhan\n    de=min(de,d+0.2);\n    return de;\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(0.3,0.5,0.8)+cos(p*0.2)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=vec3(2.5,3.5,8);\n    vec3 ta =vec3(-1,0,0);\n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n    vec3 rd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2.0));\n    vec3 col= vec3(0.05,0.05,0.1);\n    float t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(5,5,1);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.8;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.8,0.6,0.2)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 20.0);\n        col = mix(vec3(0.1,0.1,0.2),col,  exp(-0.001*t*t));\n\t\tcol += vec3(0.7,0.3,0.1)*g*(1.5+0.8*sin(iTime*3.5));\n    \tcol = clamp(col,0.0,1.0);\n            \n    }\n    col=pow(col,vec3(1.5));\n    fragColor.xyz = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 85, 85, 144], [146, 146, 177, 177, 239], [241, 241, 270, 270, 482], [484, 484, 515, 515, 602], [604, 604, 645, 645, 777], [779, 779, 824, 824, 915], [917, 917, 938, 938, 1047], [1065, 1065, 1084, 1084, 1715], [1717, 1717, 1743, 1743, 1895], [1897, 1897, 1951, 1951, 2118], [2120, 2120, 2172, 2172, 2255], [2257, 2257, 2279, 2279, 2328], [2330, 2330, 2387, 2387, 3601]], "test": "timeout"}
{"id": "wdjfWt", "name": "简单的Perlin噪音应用", "author": "tan9710630", "description": "基于perlin噪波，叠加分层实现云效果", "tags": ["cloudperlinnoise"], "likes": 2, "viewed": 59, "published": "Public", "date": "1591156915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// copy from https://www.shadertoy.com/view/4sc3z2\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float dis1 = (perlin_noise(vec3(fragCoord.xy/iResolution.xy, iTime*0.001)*256.0));\n    float dis2 = (perlin_noise(vec3(fragCoord.xy/iResolution.xy, iTime*0.005)*128.0));\n    float dis3 = (perlin_noise(vec3(fragCoord.xy/iResolution.xy, iTime*0.005)*64.0));\n    float dis4 = (perlin_noise(vec3(fragCoord.xy/iResolution.xy, iTime*0.005)*16.0));\n    float dis5 = (perlin_noise(vec3(fragCoord.xy/iResolution.xy, iTime*0.05)*2.0));\n    vec3 color = vec3(sin(dis1*0.1 + dis2*0.1 + dis3*0.2 + dis4*0.5 + dis5*0.8 + 0.2)) * 2.0;\n\tfragColor = vec4(color.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjfWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 114, 114, 266], [267, 267, 295, 295, 1234], [1235, 1235, 1292, 1292, 1857]], "test": "timeout"}
{"id": "wdSBDc", "name": "Infinite spaceships", "author": "jarble", "description": "In this galaxy, there are infinitely many spaceships.\nClick and drag the mouse to look around.", "tags": ["raymarching", "spaceship"], "likes": 1, "viewed": 220, "published": "Public API", "date": "1590972243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\n\nvoid animate(inout vec3 uv){\n    \n    float distortion = 100.0; //this makes them look like \"spaceships\"\n    //float distortion = 10.0; //this makes them look like \"planets\"\n    \n\tvec3 p1 = (uv+5.0*vec3(1.0,1.0,1.0)*iTime)/100.0;\n    uv += vec3(sin(p1.y+p1.z),cos(p1.z+p1.x),sin(p1.x+p1.y))*distortion;\n}\n\nvec3 surface_color(in vec3 uv)\n{\n    animate(uv);\n    uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 4.0; i++)\n    {\n        lar = length(vec2(uv.x, uv.y));\n        uv.x = uv.y + sin(uv.x-(uv.z+uv.y))+(uv.x);\n        uv.y = uv.x + sin(uv.y-(uv.z+uv.x))-(uv.y);\n    }\n    return vec3(cos(lar * 2.0), cos(lar * 3.0), cos(lar * 1.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    animate(p);\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    return  4.0 + sin((p.x+p.y+p.z)/100.0)*.4 + sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(5.0, 5.0, 5.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 210, 210, 486], [488, 488, 520, 520, 828], [830, 1070, 1094, 1094, 1353], [1355, 1776, 1867, 1867, 2173], [2188, 2442, 2507, 2507, 2639], [2641, 2730, 2759, 2759, 3069], [3071, 3563, 3703, 3703, 4293], [4295, 4665, 4750, 4750, 5508], [5510, 5837, 5886, 5921, 6052], [6054, 6054, 6111, 6111, 6989]], "test": "timeout"}
{"id": "WdsBRB", "name": "Hall Of Mirrors", "author": "_pwd_", "description": "Shiny boxes ...lots of", "tags": ["raymarching", "reflection", "cubes", "mirrors"], "likes": 2, "viewed": 73, "published": "Public", "date": "1591967445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Hall Of Mirrors\n// -> adding my 50 cents upon mu6k and XT95 origins by\n//\n//\n// mixing  30 torus by XT95 -> https://www.shadertoy.com/view/3dlcWl\n// with    origin by mu6k -> https://www.shadertoy.com/view/XdfGzS\n//\n\n\n#define object_speed_modifier 1.0\n#define render_steps 64\n#define offset1 4.5\n#define offset2 1.8\n#define att 12.\n\n// helpers\nfloat hash1(float s) { return fract(sin(s)*42422.42); }\nmat2 rot(float v) { float a = cos(v), b = sin(v); return mat2(a,b,-b,a); }\nfloat torus(vec3 p, vec2 q) { return length( vec2(length(p.xz)-q.x,p.y) ) - q.y; } \n\n// global + params\nfloat time;\nfloat id;\nvec3 glow;\nvec3 sync;\n\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat rnd(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\t\n\n// distance function\nfloat map( vec3 p ) {\n    // rotate the world\n\t//p.xz *= rot(time*.05);\n\t//p.xy *= rot(time*.2);\n    \n    // small point light on the center\n\tfloat d =  length(p);\n\tglow += vec3(1.) / ( .1 + d*200.);\n    \n\tfloat t = iTime*object_speed_modifier+5.0;\n\tp.x += t;\t\n\tp.z += t*.4;\n\n\tfloat s = length(p);\n\n\tp.y  = abs(p.y);\n\tp.y -= 5.0;\n\t\n    d = 0.5-p.y;\n\t\n\tfor (int i=0; i<21; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\t\n\t\tp+=vec3(1.25-fi,0.0,1.75+fi);\n\t\tvec3 pm;\n\t\t\n\t\tfloat rep = 10.0+sin(fi*2.0+1.0)*4.0 * sync.g * 0.00005;\n\t\t\n\t\tpm.xz = mod(p.xz+vec2(rep*.5),vec2(rep))-vec2(rep*.5);\n\t\t\n\t\tfloat width  = 1.0  + sin(fi) * .8;\n\t\tfloat height = 2.0  + cos(fi) * 1.2 + ( sync.b * 0.3);\n\t\tfloat offset = -0.5 + cos(fi) * 1.8;\n\n\t\tvec3 df = abs(vec3(pm.x,p.y+1.0/width,pm.z))-vec3(width,height,width);\n\t\tfloat box = max(max(df.x,df.y),df.z);\n        \n\n\t\t//box= length(max(df,0.0)) + min(max(df.x,max(df.y,df.z)),0.0) - 0.095;\n        \n        // we accumulate the lighting here\n    \tfloat intensity = 1. / ( 1. + pow(abs(box*att),1.3));\n    \tif(i == 2 && id == 0.) {\n    \t\tglow += vec3(1.,.3,1.) * intensity;\n    \t} else if(i == 5 && id == 4.) {\n      \t\tglow += vec3(0.,0.,.6) * intensity; \n    \t} else if(i == 7 && id == 1.) {\n      \t\tglow += vec3(1.,1.,.1) * intensity;\n    \t} else if(i == 14 && id == 2.) {\n      \t\tglow += vec3(.1,1.,.1) * intensity;\n    \t} else if(i == 17 && id == 5.) {\n      \t\tglow += vec3(0.16,0.0,0.32) * intensity;            \n    \t} else if(i == 20 && id == 3.) {\n      \t\tglow += vec3(.1,1.,1.) * intensity;\n    \t}\n\n\t\td = min(d,box);\n\t}\n\n\treturn d;    \n    \n    \n}\n\n\nvec3 getNormal(vec3 p) {\n\tvec3 eps=vec3(.1,0,0);\n\treturn normalize(vec3(map(p+eps.xyy),map(p+eps.yxy),map(p+eps.yyx)));\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\n\tacc+=map(p+vec3(-0.5,-0.5,-0.5));\n\tacc+=map(p+vec3(-0.5,-0.5,+0.5));\n\tacc+=map(p+vec3(-0.5,+0.5,-0.5));\n\tacc+=map(p+vec3(-0.5,+0.5,+0.5));\n\tacc+=map(p+vec3(+0.5,-0.5,-0.5));\n\tacc+map(p+vec3(+0.5,-0.5,+0.5));\n\tacc+=map(p+vec3(+0.5,+0.5,-0.5));\n\tacc+=map(p+vec3(+0.5,+0.5,+0.5));\n\treturn acc*.05+.5;\n}\n\nfloat ao1(vec3 p, vec3 n, float d) {\n\n\tfloat s = sign(d);\n\tfloat o = s*.5+.5;\n\tfor (float i = 4.0; i > 0.; --i) {\n\t\to -= (i*d - map(p+n*i*d*s)) / exp2(i);\n\t}\n\treturn o;\n\t\n}\n\n//render background\nvec3 background(vec3 p,vec3 d) {\n\treturn vec3(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime + 10.;\n    \n    // uv stuff\n    vec2 uv = fragCoord/iResolution.xy;\n  \tvec2 v = uv*2.-1.;\n  \tv.x /= iResolution.y / iResolution.x;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    \n    \n    float fft = texture(iChannel0, vec2(.4, .25)).r * 2.; \n\tsync = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n\tid = floor(hash1(floor(iTime*2.*hash(floor(time*.2))))*5.);\n    \n    // ray setup\n  \tvec3 ro = vec3(0.,0.,-4.);\n  \tvec3 rd = normalize(vec3(v, 1.));\n\trd.z -= length(rd)*.54; //lens distort\n    rd = normalize(rd);\n\trd = rotate_x(rd,1.5);\n\trd = rotate_y(rd,mouse.x*9.0+offset2);\n    \n    if( mouse.y != 0. )  rd = rotate_x(rd,mouse.y*9.0+offset1);\n    \n    // raymarching by distance field\n  \tvec3 p = ro + rd ;\n  \tglow   = vec3(.0);\n    \n    float dd;\n    vec3 sp = p;\n    \n  \tfor(int i=0; i<render_steps; i++) {\n        dd = map(p);\n    \tp += dd * rd;\n        if (dd<.001) break;\n  \t}\n\n    vec3 n   = getNormal(p);\n    float a  = ao1(p, n, 0.51);\n    float s  = ao1(p, n, -0.435);\n    vec3 cB  = vec3(a);\n\tfloat ao = amb_occ(p);\n    \n\trd=reflect(rd,getNormal(p));\n\tp+=rd;\n    \n\tfor (int i=0; i<render_steps/2; i++)\n\t{\n\t\tp += rd * map(p);\n\t}    \n     \n    float duration = 15.; \n    float parabola = 0.75;\n    float saw = mod(time/duration,1.);\n\tparabola = 0.8-pow(4.*saw*(1.-saw),2.)*0.6;\n\n    // glow + background + vignetting + gamma correction\n  \tvec3 col = glow * s;\n  \t\n \tif (dd>0.1) col = background(sp,rd);\n   \n    col *= pow(uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .8)*2.;\n  \tcol = pow(col,vec3(1./2.2));\n    \n    col += 0.25*(0.5-rnd(uv.xy*time))*parabola;\t\n\n  \tfragColor = vec4( mix( col, cB, 0.3 ) * ao, 1. );\n}", "image_inputs": [{"id": "Xtj3Wm", "previewfilepath": "https://soundcloud.com/dan-held-2/capillary-action", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dan-held-2/capillary-action", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsBRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[418, 429, 451, 451, 484], [485, 485, 504, 504, 559], [560, 560, 589, 589, 642], [710, 710, 731, 731, 810], [812, 812, 832, 832, 899], [902, 902, 938, 938, 1055], [1057, 1057, 1093, 1093, 1211], [1215, 1236, 1257, 1376, 2807], [2810, 2810, 2834, 2834, 2931], [2933, 2933, 2956, 2956, 3274], [3276, 3276, 3312, 3312, 3448], [3450, 3470, 3502, 3502, 3522], [3525, 3525, 3582, 3582, 5234]], "test": "error"}
{"id": "WdSfDt", "name": "Swirling fireball", "author": "jarble", "description": "It's a ball of fire!", "tags": ["raymarching", "fire", "lava", "fireball"], "likes": 2, "viewed": 282, "published": "Public API", "date": "1591059172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p)\n{\n    //p = animate(p*2.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(p.x,p.y);\n    // Time varying pixel color\n    float time1 = p.z;\n    float scale = 1.0;\n    vec2 col = (uv.xy*scale*(sin(uv.x+time1)));\n    vec2 col2;\n    for(float i = 1.0; i < 3.0; i++){\n        uv += ceil(col+sin((col.x+col.y+iTime*10.0)));\n        col -= sin(uv.x);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(0.5+uv.y,col2.x,0.5+uv.x/200.0);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {    \n    return length(p/4.0)-1.0+sin((p.x+p.y+p.z)/10.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/5.0), 10.0*sin(iTime/5.0), 10.0*cos(iTime/5.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 205, 281, 689], [692, 932, 956, 956, 1016], [1018, 1439, 1530, 1530, 1836], [1851, 2105, 2170, 2170, 2302], [2304, 2393, 2422, 2422, 2732], [2734, 3226, 3366, 3366, 3956], [3958, 4328, 4413, 4413, 5171], [5173, 5500, 5549, 5584, 5715], [5717, 5717, 5774, 5774, 6691]], "test": "timeout"}
{"id": "wlB3zt", "name": "Moving Vornoi", "author": "Helliaca", "description": "Vornoi diagram of moving points", "tags": ["vornoi"], "likes": 1, "viewed": 64, "published": "Public", "date": "1592998041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pl 100\n\nconst vec2[pl] points = vec2[pl](\n    vec2(0.836, 0.184),\n    vec2(0.828, 0.492),\n    vec2(0.989, 0.391),\n    vec2(0.545, 0.667),\n    vec2(0.593, 0.85),\n    vec2(0.689, 0.066),\n    vec2(0.971, 0.358),\n    vec2(0.119, 0.689),\n    vec2(0.775, 0.243),\n    vec2(0.538, 0.938),\n    vec2(0.612, 0.551),\n    vec2(0.109, 0.274),\n    vec2(0.485, 0.357),\n    vec2(0.871, 0.358),\n    vec2(0.178, 0.723),\n    vec2(0.299, 0.242),\n    vec2(0.265, 0.137),\n    vec2(0.466, 0.959),\n    vec2(0.17, 0.206),\n    vec2(0.162, 0.294),\n    vec2(0.202, 0.157),\n    vec2(0.646, 0.533),\n    vec2(0.155, 0.324),\n    vec2(0.977, 0.71),\n    vec2(0.213, 0.716),\n    vec2(0.611, 0.834),\n    vec2(0.806, 0.924),\n    vec2(0.487, 0.433),\n    vec2(0.173, 0.833),\n    vec2(0.694, 0.982),\n    vec2(0.5, 0.621),\n    vec2(0.974, 0.504),\n    vec2(0.649, 0.223),\n    vec2(0.806, 0.596),\n    vec2(0.809, 0.277),\n    vec2(0.936, 0.98),\n    vec2(0.568, 0.76),\n    vec2(0.725, 0.176),\n    vec2(0.834, 0.102),\n    vec2(0.518, 0.646),\n    vec2(0.838, 0.394),\n    vec2(0.964, 0.085),\n    vec2(0.8, 0.124),\n    vec2(0.142, 0.581),\n    vec2(0.035, 0.669),\n    vec2(0.395, 0.338),\n    vec2(0.744, 0.1),\n    vec2(0.507, 0.903),\n    vec2(0.005, 0.914),\n    vec2(0.515, 0.927),\n    vec2(0.45, 0.665),\n    vec2(0.14, 0.99),\n    vec2(0.517, 0.004),\n    vec2(0.882, 0.495),\n    vec2(0.236, 0.453),\n    vec2(0.269, 0.025),\n    vec2(0.729, 0.356),\n    vec2(0.855, 0.543),\n    vec2(0.92, 0.239),\n    vec2(0.151, 0.539),\n    vec2(0.499, 0.726),\n    vec2(0.601, 0.928),\n    vec2(0.165, 0.478),\n    vec2(0.508, 0.446),\n    vec2(0.795, 0.438),\n    vec2(0.093, 0.434),\n    vec2(0.463, 0.604),\n    vec2(0.673, 0.84),\n    vec2(0.043, 0.252),\n    vec2(0.347, 0.003),\n    vec2(0.587, 0.588),\n    vec2(0.32, 0.192),\n    vec2(0.533, 0.821),\n    vec2(0.954, 0.867),\n    vec2(0.183, 0.805),\n    vec2(0.523, 0.934),\n    vec2(0.553, 0.809),\n    vec2(0.199, 0.688),\n    vec2(0.021, 0.712),\n    vec2(0.637, 0.154),\n    vec2(0.838, 0.639),\n    vec2(0.259, 0.092),\n    vec2(0.138, 0.42),\n    vec2(0.298, 0.817),\n    vec2(0.525, 0.457),\n    vec2(0.23, 0.999),\n    vec2(0.922, 0.704),\n    vec2(0.159, 0.882),\n    vec2(0.272, 0.385),\n    vec2(0.149, 0.254),\n    vec2(0.969, 0.379),\n    vec2(0.438, 0.263),\n    vec2(0.317, 0.368),\n    vec2(0.079, 0.46),\n    vec2(0.084, 0.678),\n    vec2(0.942, 0.974),\n    vec2(0.791, 0.609),\n    vec2(0.895, 0.898),\n    vec2(0.568, 0.587),\n    vec2(0.294, 0.036)\n);\n\nconst vec3[pl] colors = vec3[pl](\n    vec3(0.588, 0.856, 0.722),\n    vec3(0.34, 0.681, 0.184),\n    vec3(0.339, 0.631, 0.525),\n    vec3(0.222, 0.172, 0.744),\n    vec3(0.579, 0.098, 0.69),\n    vec3(0.621, 0.044, 0.709),\n    vec3(0.279, 0.393, 0.045),\n    vec3(0.058, 0.968, 0.579),\n    vec3(0.47, 0.78, 0.211),\n    vec3(0.44, 0.045, 0.878),\n    vec3(0.0, 0.187, 0.58),\n    vec3(0.37, 0.138, 0.532),\n    vec3(0.443, 0.996, 0.191),\n    vec3(0.538, 0.807, 0.441),\n    vec3(0.954, 0.433, 0.868),\n    vec3(0.114, 0.852, 0.864),\n    vec3(0.039, 0.481, 0.653),\n    vec3(0.135, 0.64, 0.579),\n    vec3(0.688, 0.662, 0.731),\n    vec3(0.63, 0.811, 0.944),\n    vec3(0.466, 0.834, 0.044),\n    vec3(0.215, 0.29, 0.48),\n    vec3(0.106, 0.203, 0.522),\n    vec3(0.037, 0.6, 0.832),\n    vec3(0.413, 0.313, 0.176),\n    vec3(0.716, 0.763, 0.191),\n    vec3(0.169, 0.042, 0.172),\n    vec3(0.535, 0.213, 0.633),\n    vec3(0.006, 0.668, 0.221),\n    vec3(0.761, 0.01, 0.832),\n    vec3(0.603, 0.439, 0.857),\n    vec3(0.79, 0.31, 0.424),\n    vec3(0.698, 0.868, 0.554),\n    vec3(0.742, 0.057, 0.054),\n    vec3(0.882, 0.753, 0.15),\n    vec3(0.618, 0.243, 0.21),\n    vec3(0.102, 0.621, 0.795),\n    vec3(0.897, 0.759, 0.776),\n    vec3(0.215, 0.463, 0.567),\n    vec3(0.628, 0.647, 0.518),\n    vec3(0.36, 0.408, 0.502),\n    vec3(0.155, 0.955, 0.083),\n    vec3(0.934, 0.023, 0.476),\n    vec3(0.759, 0.313, 0.41),\n    vec3(0.189, 0.624, 0.387),\n    vec3(0.326, 0.629, 0.06),\n    vec3(0.969, 0.204, 0.969),\n    vec3(0.05, 0.608, 0.539),\n    vec3(0.325, 0.515, 0.564),\n    vec3(0.166, 0.044, 0.541),\n    vec3(0.893, 0.556, 0.758),\n    vec3(0.87, 0.105, 0.549),\n    vec3(0.254, 0.082, 0.674),\n    vec3(0.987, 0.867, 0.593),\n    vec3(0.162, 0.334, 0.743),\n    vec3(0.092, 0.448, 0.802),\n    vec3(0.816, 0.999, 0.623),\n    vec3(0.012, 0.902, 0.355),\n    vec3(0.967, 0.559, 0.326),\n    vec3(0.425, 0.143, 0.988),\n    vec3(0.776, 0.52, 0.009),\n    vec3(0.468, 0.817, 0.502),\n    vec3(0.425, 0.529, 0.041),\n    vec3(0.394, 0.346, 0.523),\n    vec3(0.207, 0.322, 0.609),\n    vec3(0.382, 0.631, 0.54),\n    vec3(0.498, 0.842, 0.954),\n    vec3(0.285, 0.576, 0.832),\n    vec3(0.133, 0.736, 0.976),\n    vec3(0.062, 0.776, 0.493),\n    vec3(0.352, 0.765, 0.758),\n    vec3(0.775, 0.358, 0.041),\n    vec3(0.807, 0.759, 0.633),\n    vec3(0.907, 0.09, 0.14),\n    vec3(0.842, 0.196, 0.553),\n    vec3(0.629, 0.119, 0.303),\n    vec3(0.041, 0.135, 0.092),\n    vec3(0.478, 0.78, 0.296),\n    vec3(0.89, 0.761, 0.944),\n    vec3(0.48, 0.078, 0.508),\n    vec3(0.658, 0.678, 0.082),\n    vec3(0.62, 0.376, 0.349),\n    vec3(0.506, 0.568, 0.553),\n    vec3(0.879, 0.861, 0.989),\n    vec3(0.974, 0.164, 0.315),\n    vec3(0.076, 0.602, 0.696),\n    vec3(0.679, 0.07, 0.012),\n    vec3(0.441, 0.055, 0.293),\n    vec3(0.839, 0.666, 0.913),\n    vec3(0.048, 0.802, 0.916),\n    vec3(0.666, 0.518, 0.939),\n    vec3(0.236, 0.961, 0.754),\n    vec3(0.614, 0.894, 0.688),\n    vec3(0.659, 0.831, 0.179),\n    vec3(0.76, 0.742, 0.924),\n    vec3(0.619, 0.363, 0.334),\n    vec3(0.079, 0.453, 0.422),\n    vec3(0.184, 0.538, 0.554),\n    vec3(0.049, 0.598, 0.045),\n    vec3(0.839, 0.775, 0.278)\n);\n\n\nvec2 rotate_around(vec2 point, vec2 pivot, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  // rotate point\n  float xnew = (point.x-pivot.x) * c - (point.y-pivot.y) * s;\n  float ynew = (point.x-pivot.x) * s + (point.y-pivot.y) * c;\n\n  return vec2(xnew + pivot.x, ynew + pivot.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float min_l = 99.0f;\n    int min_i = 0;\n    int i;\n    for(i=0; i<pl-1; i++) {\n        vec2 p = rotate_around(points[i], points[i+1], iTime);\n        if(length(p-uv)<min_l) {\n            min_l = length(p-uv);\n            min_i = i;\n        }\n    }\n\n    fragColor = vec4(colors[min_i],1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlB3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5536, 5536, 5593, 5593, 5834], [5837, 5837, 5894, 5944, 6281]], "test": "timeout"}
{"id": "wlByRR", "name": "Logarithmic Moebius Transform 9", "author": "FabriceNeyret2", "description": "How to get a perfect fit of parameterization along inter-poles arc ?\nvariant of [url]https://shadertoy.com/view/WtlyWs[/url]", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "reproduction"], "likes": 7, "viewed": 274, "published": "Public API", "date": "1593547587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/WtlyWs\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I,\n         U = (u - .5*R) / R.y,                                // normalized coordinates\n\n         z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n    \n#if 1              \n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U+=.5))*vec2(.5, -.5) + iTime/8.\n        + atan(U.y, U.x)/6.283 * vec2(6, 1);  // n  \n  //U *= vec2(10,22)/2.73; // /(.5+iMouse.x/R.x);\n    U *= vec2(11./3., 2./sqrt(3.)*7.); // *1,4,7 ok      // thanks Shane !\n#else                                                    // variant adapted form mla's version\n    U =  vec2( log(length(U+=.5)) , atan(U.y, U.x) ) / 3.1416;\n    U.x += iTime/8.;\n    I = vec2( 7. , 3./sqrt(3.) );\n    // my: (PI/2,  3, -PI/2, .5) * D(3.66,8) = ( 5.75, 11,  -12.6,  4 ) \n    U = mat2(I,-I.y,I) * U;          // here:  ( 7,   1.73, -1.73,  7 )\n    U = U*sqrt(3.)-.5;\n#endif\n    \n    U *= mat2(1,0,.5,sqrt(3.)/2.);                            // triangular mesh\n    z = fwidth(U);\n    I = floor(U); U = fract(U); \n    float s = float(U.x-U.y>0.),                              // parallelogram = 2 triangles\n         id = 6.28*( I.y/6.+I.x/11.)*2.+s*91.;\n    float v = 1.-2.*abs(U.x-U.y);\n    U = abs(U*2.-1.);  v = max(v,max(U.x,U.y));               // dist to border\n    O =   smoothstep(.7,-.7, (v-.95)/( abs(z.x-z.y)>1.?.1:z.y*4.))  // draw AA tiles\n        * (.6 + .6 * cos( id  + vec4(0,23,21,0)  ) );         // color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlByRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 1600]], "test": "ok"}
{"id": "wlfcDj", "name": "moiré_1", "author": "TAKUSAKU", "description": "moiré", "tags": ["moir"], "likes": 5, "viewed": 52, "published": "Public", "date": "1593072629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n    vec3 u=normalize(vec3(2.*FC-iResolution.xy,(1e3-6.)*8.))*5e4;\n    for(int i=0;i<9;i++)\n        u.x+=fract(u.y+iTime)*.2,\n        u.xy+=sin(u.y+iTime*6.)*.1,\n        o=cos(float(u)+vec4(.3,.1,0,0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfcDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 246]], "test": "ok"}
{"id": "WlfcWj", "name": "Projector Laser Show", "author": "Danguafer", "description": "Volumetric projector laser show forked from https://www.shadertoy.com/view/wtlczl", "tags": ["projection", "laser"], "likes": 7, "viewed": 334, "published": "Public API", "date": "1593017661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from https://www.shadertoy.com/view/wtlczl\n\n\nvec3 eye \t\t\t\t\t= vec3(0.f,0.f,5.f);\nvec4 sphere\t\t\t\t\t= vec4(0.f,0.f,0.f, 0.7f);\n// vec3 spotLightDir \t\t\t= normalize(vec3(0.0f,0.0f,-1.f)); // front\nvec3 spotLightDir \t\t\t= normalize(vec3(-0.75f,-0.15f,-1.f));\nvec3 spotLightColor\t\t\t= vec3(0.7f);\nvec3 ambientColor \t\t\t= vec3(0.3f);\nfloat camerafov \t\t\t= 45.f;\nfloat scatteringProbability = 1.f;\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nbool anyHit_sphere(vec3 rayEye, vec3 rayDir, vec4 sphere) {\n    vec3 a = sphere.xyz - rayEye;\n    float a1 = dot(a, rayDir);\n    vec3 a2 = a - a1 * rayDir;\n    float distSq = dot(a2,a2);\n    float rSq = sphere.w*sphere.w;\n    if (distSq < rSq) {\n        float cSq = rSq - distSq;\n        float t = a1 - sqrt(cSq);\n        return t >= -0.01f;\n    } else\n        return false;\n}\n\nbool closestHit_sphere(vec3 rayEye, vec3 rayDir, vec4 sphere, out vec3 hit, out vec3 normal) {\n    vec3 a = sphere.xyz - rayEye;\n    float a1 = dot(a, rayDir);\n    vec3 a2 = a - a1 * rayDir;\n    float distSq = dot(a2,a2);\n    float rSq = sphere.w*sphere.w;\n    if (distSq < rSq) {\n        float cSq = rSq - distSq;\n        float t = a1 - sqrt(cSq);\n        hit = rayEye + rayDir * t;\n        normal = normalize(vec3(hit-sphere.xyz));\n        return true;\n    } else\n        return false;\n}\n\nbool closestHit_plane(vec3 rayEye, vec3 rayDir, vec4 plane, out vec3 hit, out vec3 normal) {\n\tvec3 p0 = plane.xyz * plane.w;\n    vec3 n = -plane.xyz;\n    float d = dot(p0-rayEye,n)/dot(rayDir, n);\n    hit = rayEye + rayDir * d;\n    normal = n;\n    return true;\n}\n\nfloat saturate(float x) { return clamp(x, 0.f, 1.f); }\n\nbool inLightFoV(vec3 Ln, vec3 spotLightDir, float cosHalfAngle) {\n    // return true;\n    return dot(Ln, -spotLightDir) > cosHalfAngle;\n}\n\nvec2 lightUV(vec3 Ln, float fov, vec3 lightLookVector, vec3 lightUpVector, vec3 lightRightVector) {\n    float x = dot(Ln, lightRightVector);\n    float y = dot(Ln, lightUpVector);\n    float d = -1. / dot(Ln, lightLookVector); // 'un-normalize Ln'\n    \n    float q = 1. / (2. * tan(fov));\n    \n    float u = d * x * q + 0.5;\n    float v = d * y * q + 0.5;\n\n    return vec2(u, v);\n}\n\nvoid shading(vec3 Nn, vec3 Ln, vec3 lightColor, inout vec3 result) {\n \t// Diffuse (lambertian) reflectance\n\tfloat dotNL = saturate(dot(Nn, Ln));\n\tvec3 diffuse = dotNL * lightColor;\n    result += diffuse;\n}\n\n// Fast inverse for affine matrix:\nmat4 affineInverse(mat4 m) {\n\tmat3 rot;\n\trot[0] = m[0].xyz;\n\trot[1] = m[1].xyz;\n\trot[2] = m[2].xyz;\n\n\tmat3 invRot = transpose(rot);\n\n\tmat4 result;\n\tresult[0] = vec4(invRot[0], 0);\n\tresult[1] = vec4(invRot[1], 0);\n\tresult[2] = vec4(invRot[2], 0);\n\tresult[3] = vec4(-(invRot * m[3].xyz), 1);\n\treturn result;\n}\n\nvoid SolveQuadratic(float a, float b, float c, out float minT, out float maxT)\n{\n\tfloat discriminant = b*b - 4.0*a*c;\n\n\tif (discriminant < 0.0)\n\t{\n\t\t// no real solutions so return a degenerate result\n\t\tmaxT = 0.0;\n\t\tminT = 0.0;\n\t\treturn;\n\t}\n\n\t// numerical receipes 5.6 (this method ensures numerical accuracy is preserved)\n\tfloat t = -0.5 * (b + sign(b)*sqrt(discriminant));\n\tfloat closestT = t / a;\n\tfloat furthestT = c / t;\n\n\tif (closestT > furthestT)\n\t{\n\t\tminT = furthestT;\n\t\tmaxT = closestT;\n\t}\n\telse\n\t{\n\t\tminT = closestT;\n\t\tmaxT = furthestT;\n\t}\n}\n\nvoid IntersectCone(vec3 rayOrigin, vec3 rayDir, mat4 invConeTransform, float tanAperture, float height, out float minT, out float maxT)\n{\n\tvec4 localOrigin = invConeTransform * vec4(rayOrigin, 1.0);\n\tvec4 localDir = invConeTransform * vec4(rayDir, 0.0);\n\n\tfloat tanTheta = tanAperture * tanAperture;\n\n\tfloat a = localDir.x*localDir.x + localDir.z*localDir.z - localDir.y*localDir.y*tanTheta;\n\tfloat b = 2.0*(localOrigin.x*localDir.x + localOrigin.z*localDir.z - localOrigin.y*localDir.y*tanTheta);\n\tfloat c = localOrigin.x*localOrigin.x + localOrigin.z*localOrigin.z - localOrigin.y*localOrigin.y*tanTheta;\n\n\tSolveQuadratic(a, b, c, minT, maxT);\n\n\tfloat y1 = localOrigin.y + localDir.y*minT;\n\tfloat y2 = localOrigin.y + localDir.y*maxT;\n\n\tif (y1 > 0.0 && y2 > 0.0)\n\t{\n\t\t// both intersections are in the reflected cone so return degenerate value\n\t\tminT = 0.0;\n\t\tmaxT = -1.0;\n\t}\n\telse if (y1 > 0.0 && y2 < 0.0)\n\t{\n\t\t// closest t on the wrong side, furthest on the right side => ray enters volume but doesn't leave it (so set maxT arbitrarily large)\n\t\tminT = maxT;\n\t\tmaxT = 10000.0;\n\t}\n\telse if (y1 < 0.0 && y2 > 0.0)\n\t{\n\t\t// closest t on the right side, largest on the wrong side => ray starts in volume and exits once\n\t\tmaxT = minT;\n\t\tminT = 0.0;\n\t}\n}\n\nfloat InScatter(vec3 start, vec3 dir, vec3 lightPos, float d, vec3 attenuation)\n{\n\t// calculate quadratic coefficients a,b,c\n\tvec3 q = start - lightPos;\n\n\tfloat b = dot(dir, q);\n\tfloat c = dot(q, q);\n\n\t// evaluate integral\n\tfloat s = 1.0f / sqrt(c - b*b);\n\n\tfloat l = s * (atan((d + b) * s) - atan(b*s));\n\n    // attenuation:\n\t//float lightDist = length(q);\n\t//l = l * saturate(1.0 / dot(vec3(1, sqrt(lightDist), lightDist), attenuation));\n\treturn l;\n}\n\nvec4 get_image(vec2 uv) {\n    uv = 2.0 * (uv - 0.5);\n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < 100; i++) {\n        vec2 nuv = uv;\n        float n = float(i) * 0.1 + iTime * 100.0;\n        nuv.x += sin(n*(0.8 + sin(iTime / 200.0) * 0.1))*0.5;\n        nuv.y += cos(n*(0.5 + sin(iTime / 100.0) * 0.1))*0.5;\n    \tcol += vec3(smoothstep(0.05,0.0,length(nuv)));\n\t}\n    return vec4(col.x,0.0,0.0,1.0);\n\t//return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = rayDirection(camerafov, iResolution.xy, fragCoord.xy);\n\n    float spotLightHalfAngle = 25.0f + sin(iTime) * 10.0f;\n    // float spotLightHalfAngle = 35.0f;\n    if (iMouse.z > 0.5f)\n     \t// spotLightDir = normalize(vec3(-normalize(iMouse.xy - iResolution.xy / 2.f), -1.f));\n        spotLightDir = normalize(vec3(sin(6.28*iMouse.x/iResolution.x), cos(3.14*iMouse.y/iResolution.y), cos(6.28*iMouse.x/iResolution.x)));\n    vec3 spotLightOrigin \t= (sphere.xyz - spotLightDir) * 1.4;\n    vec3 lightUp = normalize(cross(spotLightDir, vec3(1,0,0)));\n    vec3 lightRight = cross(spotLightDir, lightUp);\n    float spotfov = radians(spotLightHalfAngle);\n    float cosSpotHalfAngle = cos(spotfov);\n\n    vec3 result = vec3(0.f);\n\n    // lit sphere:\n    vec3 hitPos, hitNormal;\n    float hitDist = 1e5;\n    if (closestHit_sphere(eye, rayDir, sphere, hitPos, hitNormal)) {\n    // if (closestHit_plane(eye, rayDir, vec4(0,0,-1, 0), hitPos, hitNormal)) {\n        hitDist = length(hitPos-eye); // used for cone\n        \n        // for each spotlight:\n        vec3 Ln = normalize(spotLightOrigin-hitPos);\n        if (inLightFoV(Ln, spotLightDir, cosSpotHalfAngle)) {\n            // gobo:\n            vec2 goboUV = lightUV(Ln, spotfov, spotLightDir, lightUp, lightRight);\n            vec4 goboColor = get_image(goboUV);\n            \n        \tshading(hitNormal, Ln, goboColor.xyz * goboColor.a * spotLightColor, result);\n        }\n        \n        shading(hitNormal, normalize(vec3(0.f,0.f,1.f)), ambientColor, result); // directional light\n    } else {\n        // checkerboard background\n        int ix = int(fragCoord.x);\n        int iy = int(fragCoord.y);\n        \n        result = (ix / 16) % 2 == 0 ^^ (iy / 16) % 2 == 0 ? vec3(0.1f) : vec3(0.15f);\n    }\n    \n    // volumetric fog:\n\tfloat height = 30.0;\n\tfloat minT = 0.0;\n\tfloat maxT = 0.0;\n\n\tmat4 LightToWorld;\n\tLightToWorld[0] = vec4(lightRight, 0.0);\n\tLightToWorld[1] = vec4(-spotLightDir, 0.0); // change of basis from XYZ to X-ZY to rotate forward facing cone downward\n\tLightToWorld[2] = vec4(lightUp, 0.0);\n\tLightToWorld[3] = vec4(spotLightOrigin, 1);\n\t\t\t\n\tmat4 invLightToWorld = affineInverse(LightToWorld);\n\n\tfloat tanSpotAngle = tan(radians(spotLightHalfAngle));\n\n\tIntersectCone(eye, rayDir, invLightToWorld, tanSpotAngle, height, minT, maxT);\n\n\tminT = max(minT, 0.f);\n\tmaxT = min(maxT, hitDist);\n\tfloat dt = max(0.0, maxT - minT);\n\n    // analytic fog integral:\n\tvec3 scatter = spotLightColor * /* vec3(0.2, 0.5, 0.8) * */\n        max(0.f, InScatter(eye + rayDir*minT, rayDir,spotLightOrigin, dt, vec3(1,1,1))) \n        * scatteringProbability * 0.5;\n    \n    // ray marched gobo fog:\n    vec3 coneGoboColor = vec3(0.f);\n    for (int i = 0; i < 16; ++i) {\n    \tfloat t = mix(minT, maxT, float(i) / float(16-1));\n        vec3 p = eye + rayDir*t; // point in volume\n        vec3 Ln = normalize(spotLightOrigin-p);\n        // shadow ray:\n        if (!anyHit_sphere(p, Ln, sphere)) \n        {\n        \tvec2 goboUV = lightUV(Ln, spotfov, spotLightDir, lightUp, lightRight);\n        \tvec4 goboColor = get_image(goboUV);\n        \tconeGoboColor += goboColor.xyz * goboColor.a * spotLightColor;\n        }\n    }\n    coneGoboColor /= 16.f;\n\n\tresult += scatter * coneGoboColor;\n    \n    fragColor = vec4(result, 1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 395, 460, 460, 592], [594, 594, 653, 653, 970], [972, 972, 1066, 1066, 1461], [1463, 1463, 1555, 1555, 1725], [1727, 1727, 1752, 1752, 1781], [1783, 1783, 1848, 1868, 1920], [1922, 1922, 2021, 2021, 2301], [2303, 2303, 2371, 2409, 2508], [2510, 2545, 2573, 2573, 2852], [2854, 2854, 2934, 2934, 3405], [3407, 3407, 3544, 3544, 4657], [4659, 4659, 4740, 4783, 5111], [5113, 5113, 5138, 5138, 5556]], "test": "timeout"}
{"id": "wlfcz8", "name": "hexagon id test with iMouse(WIP)", "author": "ShaderLyf", "description": "trying to make a tonnetz grid, this is the start I've made today. I can't figure out how I'd map the rows separated by fifths. I want to use the circles with lines going through as triggers for individual notes and potentially chords for the inner circles", "tags": ["wip", "hexagon", "help", "tiling", "imouse"], "likes": 4, "viewed": 96, "published": "Public", "date": "1591389841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hexD(vec2 p)\n{\n    p = abs(p);\n    float c = dot(p,normalize(vec2(1,1.73)));\n    c = max(c,p.x);\n    return c;\n}\n\nfloat circle(vec2 uv, float rad)\n{\n    float d = length(uv); //distance function\n    return smoothstep(rad,rad-0.01,d); // circle draw\n}\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530718\nvec2 rotate2D(vec2 uv, float r){ // takes uv co-ords and rotates them by r\n    uv =  mat2(cos(r),-sin(r),\n                sin(r),cos(r)) * uv;\n    return uv;\n}\n\nvec3 triD(vec2 uv,float s)\n{\n    vec2 repeat =vec2 (1.,1.73);\n    vec2 h = repeat*0.5;\n    vec2 a1=mod(uv,repeat)-h; // gridify, but it's offset\n\tvec2 b1=mod(uv-h,repeat)-h; // gridify and center\n    vec2 getv = dot(a1,a1)<dot(b1,b1)?a1:b1;//if else function\n    float d = 0.;\n  \t// Remap the space to -1. to 1.\n  \t//uv = uv * 2.-1.;\n\n  \t// Number of sides of your shape\n  \tint N = 3;\n\n  \t// Angle and radius from the current pixel\n  \tfloat a = atan(getv.x,getv.y)+PI;\n  \tfloat r = TWO_PI/float(N);\n\t\n    vec2 id = getv-uv;\n  \t// Shaping function that modulate the distance\n  \td = cos(floor(.5+a/r)*r-a)*length(getv);\n    vec3 col = vec3(1.0-smoothstep(s,s+0.01,d));//*sin(id.x*id.y+iTime)));\n\n  \treturn col;\n}\n\nvec2 getV(vec2 uv)\n{\n    vec2 repeat =vec2 (1.,1.73);\n    vec2 h = repeat*0.5;\n    vec2 a1=mod(uv,repeat)-h; // gridify, but it's offset\n\tvec2 b1=mod(uv-h,repeat)-h; // gridify and center \n    vec2 getv = dot(a1,a1)<dot(b1,b1)?a1:b1;//if else function without if/else  \n    \n    return getv;\n}    \n\nvec4 hexC (vec2 uv)\n{\n    vec2 repeat =vec2 (1.,1.73);\n    vec2 h = repeat*0.5;\n    vec2 a1=mod(uv,repeat)-h; // gridify, but it's offset\n\tvec2 b1=mod(uv-h,repeat)-h; // gridify and center\n    vec2 getv = dot(a1,a1)<dot(b1,b1)?a1:b1;//if else function without if/else\n    float x = atan(getv.x,getv.y);\n    float y = .5-hexD(getv);\n    vec2 id = uv-getv;\n\n    vec4 co = vec4(x,y,id.x,id.y); // coords and id\n    return co;\n\n}\n\nvec3 hexCircs (vec2 uv)\n{\n    vec2 getv = getV(uv);  \n    vec2 id = uv-getv;\n    float o = circle(getv,0.2);\n    vec3 hx = vec3(id.x,id.y,o);\n    return hx;\n}\n\nvec2 getId(vec2 p)\n{\n    vec2 getv = getV(p);\n    vec2 id = p-getv;\n    return id;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec2 uv2 = uv;\n    vec2 uv3 = uv;\n    \n    vec3 col = vec3(0.);\n    uv *= (1.5); \n    //uv *= (5.*1.1547); \n\n    uv3 = rotate2D(uv3,PI*0.16666);\n    uv2*=(3.*1.1547);// scale of space\n    uv3*=(6.);// scale of space\n\n\tfloat circ = hexCircs(uv).z;\n\n    vec3 vis = hexCircs(uv3);\n    \n    vec4 h = hexC(uv3);\n    vec3 t = triD(uv2,0.29);\n    vec3 t2 = triD(uv2,0.27);\n    float c = smoothstep(0.005,.05,h.y);\n    \n    vec2  m  = iMouse.xy / iResolution.xy;\n    vec2 ar = vec2(1.0, iResolution.y/iResolution.x);\n    m*=ar;\n    m*=6.;\n    vec2 id = getId(m);\n    \n    col+=vis.z;//good circles\n    //col+=vis.y; //visual debug\n\tcol+=t;\n    col-=t2;\n    col+=c;\n//  vec3 trp = vec3(col.x-sin(vis.x*vis.y+iTime*0.9),col.y*sin(vis.x*vis.y+iTime*2.2),col.z*cos(vis.x*vis.y+iTime*0.6));\n\tvec3 trp = vec3(col.x-sin((vis.x*8.+m.x)+(vis.y*14.)),col.y*sin((vis.x*2.5+m.y+iTime)+(vis.y*7.)),col.z);\n     //vec3 ms = vec3(col.x-m.x,col.y*sin((vis.x*2.5+m.y)+(vis.y*7.)),col.z);\n\n     //vec3 trp = vec3(id.x,id.y,col.z);\n\n    \t\n    //vec3 e = vec3(col.x,col.y,col.z);\n\n    fragColor = vec4(trp,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfcz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 118], [120, 120, 154, 154, 256], [321, 321, 353, 395, 480], [482, 482, 510, 510, 1192], [1194, 1194, 1214, 1214, 1487], [1493, 1493, 1514, 1514, 1918], [1920, 1920, 1945, 1945, 2078], [2080, 2080, 2100, 2100, 2164], [2171, 2171, 2228, 2278, 3425]], "test": "timeout"}
{"id": "WlfczM", "name": "Bubble ring", "author": "TAKUSAKU", "description": "Bubble ring", "tags": ["bubble", "ring"], "likes": 9, "viewed": 98, "published": "Public", "date": "1591624438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 U )\n{\n    o=vec4(0);//Required on Safari\n    vec3 u=normalize(vec3(2.*U-iResolution.xy,iResolution.y));\n    for(int i=0;i<6;i++){\n        u.x+=sin(u.z+iTime*.1);\n        u.y+=cos(u.x+iTime*.1);\n        o=max(o*.9,cos(3.*dot(u,u)+vec4(.3,.1,0,0)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 291]], "test": "timeout"}
{"id": "wlfczr", "name": "Simple color change", "author": "LeXXik", "description": "Simple color change with border", "tags": ["color", "border", "change"], "likes": 1, "viewed": 76, "published": "Public", "date": "1591268152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = abs(cos(iTime));\n    \n    if (uv.y > t)\n    {\n\t\tfragColor = vec4(1.0);\n    }\n    else\n    {\n\t\tfragColor = vec4(0.403, 0.647, 0.8, 1.0);\n    }\n    \n    if (uv.y > t + 0.01)\n    {\n     \tfragColor = vec4(0.0, 0.090, 0.270, 1.0);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 347]], "test": "timeout"}
{"id": "WlfczS", "name": "cube technical drawing", "author": "FabriceNeyret2", "description": "- silhouette lines in bold\n- hidden lines in grey\n- facing lines in regular\n  ( For high face distortions, I should split edges )   Mouse.x controls rotation (bottom-left corner: back to autodemo)", "tags": ["cube", "short", "technicaldrawing"], "likes": 9, "viewed": 335, "published": "Public API", "date": "1592312099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 point[14];                                       // 8 corners + 6 faces center\nvec2  proj[8];                                        // screen proj of the 8 corners\nint   face[24] = int[]( 4,2,  3,4,  2,5,  5,3,        // 2 faces adjacent to each edge\n                        2,0,  0,3,  1,2,  3,1, \n                        0,4,  5,0,  4,1,  1,5);\n\n// --- utils from https://www.shadertoy.com/view/llySRh\n#define S(d,r) smoothstep( -1.5, 1.5, (r) - (d)*R.y ) // antialiased draw\nfloat seg(vec2 p, vec2 a,vec2 b) {                    // --- draw segment with round ends\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y,\n         M = iMouse.xy;\n    vec3 P,A,B, C = vec3(0,0,-4);                     // C: camera pos 76\n    O-=O;\n    float t = length(M)<20. ? iTime : 6.28 * M.x/R.x;\n    int i = 0, a,b,c;\n    for(; i<8; i++ )                        // --- compute 3D corners coords + 2D proj\n        P =    vec3( i%2, i/2%2, i/4%2 ) *2. - 1.     // cubes corner\n            + .1*cos(iTime+vec3(1+i,2+2*i,3-i)),      // jittering\n        P.zx *= rot(t),\n        P.zy *= rot(-.5),\n        point[i] = P,                                 // corner i\n        point[ 8+i/4  ] += P/4.,                      // faces corner i belongs to\n        point[10+i%2  ] += P/4.,                      // ( indeed, calc faces center)\n        point[12+i/2%2] += P/4.,\n        P -= C , proj[i] = P.xy / P.z;                // screen proj of corner i\n\n#define N(c) dot( cross( point[8+face[2*i+c]]-A , B-A ) , A-C ) // dot(Normal,View)\n    for(i=0; i<12; i++) \n        a = i%4*(i<4?1:2) - (i/4==1 ?i%2:0), b = a + (4>> i/4), // index of line i ends\n        A = point[a], B = point[b],                             // 3D coords of line i  ends\n        //F = ivec3(a/4, 2+a%2 ,4+a/2%2),\n        //G = ivec3(b/4, 2+b%2 ,4+b/2%2) - F,\n        //F.xy= G.x==0 ? F.yz : G.y==0 ? F.xz :F.xy,            // F[c] replaces face[] (but array shorter)\n        c = N(0) < 0. ? 1 : 0 , N(1) > 0. ? c++ : c,            // visibility of adjacent faces \n        O = max(O, S( seg(U,proj[a],proj[b]), c<1 ?0.: c<2 ?4.:2. ) );// draw segment\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfczS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 484, 518, 573, 744], [790, 790, 828, 828, 2369]], "test": "ok"}
{"id": "wlfczX", "name": "Broken Space Division", "author": "petet", "description": "everyone's first instinct when they learn about raymarching infinite things is to rip off the big man himself, m.c. escher.  so that's exactly what i did", "tags": ["raymarching"], "likes": 12, "viewed": 270, "published": "Public API", "date": "1592598014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash3d(vec3 p3) {\n    //thank you mr. hoskins\n   \tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z); \n}\n\nfloat valueNoise(vec3 v) {\n    vec3 vfloor=floor(v);\n \tfloat aaa=hash3d(vfloor);\n    float aab=hash3d(vfloor+vec3(0,0,1));\n    float aba=hash3d(vfloor+vec3(0,1,0));\n    float abb=hash3d(vfloor+vec3(0,1,1));\n    float baa=hash3d(vfloor+vec3(1,0,0));\n    float bab=hash3d(vfloor+vec3(1,0,1));\n    float bba=hash3d(vfloor+vec3(1,1,0));\n    float bbb=hash3d(vfloor+vec3(1,1,1));\n    \n    vec3 vfrac=v-vfloor;\n    vfrac=smoothstep(0.,1.,vfrac);\n    \n    float aa=mix(aaa,aab,vfrac.z);\n    float ab=mix(aba,abb,vfrac.z);\n    float ba=mix(baa,bab,vfrac.z);\n    float bb=mix(bba,bbb,vfrac.z);\n    \n    return mix(mix(aa,ab,vfrac.y),mix(ba,bb,vfrac.y),vfrac.x);\n}\n\nfloat sphereSDF(vec3 v, vec3 p, float r) {\n    return length(v-p)-r;\n}\n\nfloat boxSDF(vec3 v, vec3 p, vec3 b) {\n \tvec3 q=abs(v-p)-b;\n\treturn length(max(q,vec3(0.)))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat SDF(vec3 v) {\n    float decay=clamp(valueNoise(30.*v)*valueNoise(80.*v+sin(20.*v.zxy))-0.3,0.,1.);\n    float rounding=0.02*(1.-decay);\n    //vec3 vmod = v-vec3(0.2,0.2,3);\n    vec3 vmod = mod(v,1.);\n    float box1 = boxSDF(vmod, vec3(0.5,0.5,0.5), vec3(.12,.12,.12));\n    float box2 = boxSDF(vmod, vec3(0.5,0.5,0.5),vec3(1.,.03,.03));\n    float box3 = boxSDF(vmod, vec3(0.5,0.5,0.5),vec3(.03,1.,.03));\n    float box4 = boxSDF(vmod, vec3(0.5,0.5,0.5),vec3(.03,.03,1.));\n    \n    \n    float morphtime=iTime*0.1+(v.x-v.y-v.z)*0.02;\n    \n    float noisemorph = 2.*(floor(morphtime)+smoothstep(0.3,0.7,fract(morphtime)));\n    \n    return max(min(box1,min(box2,min(box3,box4))),valueNoise(v+vec3(0.5)+noisemorph)-0.5)-rounding;\n    \t\t\n}\n\nvec3 normal(vec3 v) {\n    const float epsilon = 0.0001;\n    float sdf1=SDF(v);\n \treturn normalize(vec3(SDF(v+vec3(epsilon,0,0))-sdf1,\n                SDF(v+vec3(0,epsilon,0))-sdf1,\n                SDF(v+vec3(0,0,epsilon))-sdf1));\n}\n\nmat2 rotate2d(float theta) {\n \treturn mat2(cos(theta),-sin(theta),sin(theta),cos(theta));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x;\n\tvec3 col = vec3(1);\n    const int ITERATIONS = 60;\n    \n    \n    vec3 camera = vec3(iTime*0.2,0,iTime*0.5);\n    vec3 pos = camera;\n    vec3 dir = normalize(vec3(uv,1.));\n    float theta=iTime*0.1;\n    \n    dir.yz=rotate2d(sin(iTime*0.1))*dir.yz;\n    \n    dir.xz=rotate2d(theta)*dir.xz;\n                  \n    vec3 light=normalize(vec3(-1,1,-2));\n    \n    float fogdist=13.;\n    \n    const float surf_threshold = 0.002;\n    \n    for (int i = 0; i < ITERATIONS; i++) {\n    \tfloat dist = SDF(pos);\n        if (dist < surf_threshold) {\n            //vec3 light = normalize(vec3(0,0,iTime)-pos);\n            vec3 norm = normal(pos);\n            float luminance = 0.5+0.5*dot(norm,light);\n            //col = vec3(valueNoise(pos*10.));\n            col = vec3(0.2)+0.2*texture(iChannel0,vec2(fract(pos.xy+vec2(0,pos.z)))).xyz;\n            col *= luminance;\n            col *= 0.4+0.6*(SDF(pos+norm*0.1)-dist)/0.1;\n            \n           \t//col += length(pos-camera)/fogdist;\n            \n            float fog=float(i)/float(ITERATIONS);\n            \n            col += fog*fog;\n            break;\n        }\n        pos += dir*dist;\n    }\n\t//col+=vec3(hash3d(vec3(200.*uv,iTime)))*0.05; //ez dither\n\tcol += smoothstep(0.3,2.0,length(uv)); //vignette\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 51, 158], [160, 160, 186, 186, 814], [816, 816, 858, 858, 886], [888, 888, 926, 926, 1012], [1014, 1014, 1033, 1033, 1750], [1752, 1752, 1773, 1773, 1983], [1985, 1985, 2013, 2013, 2079], [2081, 2081, 2138, 2189, 3550]], "test": "error"}
{"id": "WlfyR2", "name": "fork-Mandelbrot - smooth", "author": "jorge2017a1", "description": "fork-Mandelbrot - smooth", "tags": ["mandelbrot", "fork", "smooth"], "likes": 2, "viewed": 62, "published": "Public", "date": "1592438908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// See here for more information on smooth iteration count:\n//\n// http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n\n\n//Creado por iq en 2013-01-14\n//https://www.shadertoy.com/view/4df3Rn\n\n\n// increase this if you have a very fast GPU\n#define AA 2\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat mandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 256.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<512; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>511.0 ) return 0.0;\n    \n    // ------------------------------------------------------\n    // smooth interation count\n    //float sl = l - log(log(length(z))/log(B))/log(2.0);\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n    float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*iTime ) );\n    \n    \n    l = mix( l, sl, al );\n\n    //return l;\n    \n    float sds1= sdSphere( vec3(c.x,c.y, c.x+c.y+ l) , 10.0*l );\n     sds1 = mix( l, sds1, al );\n    return sds1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float w = float(AA*m+n);\n        float time = iTime + 0.5*(1.0/24.0)*w/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        float time = iTime;\n#endif\n    \n        float zoo = 0.62 + 0.38*cos(.07*time);\n        float coa = cos( 0.15*(1.0-zoo)*time );\n        float sia = sin( 0.15*(1.0-zoo)*time );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float l = mandelbrot(c);\n\n        col += 0.5 + 0.5*cos( 3.0 + l*0.15 + vec3(0.0,0.6,1.0));\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfyR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[389, 389, 424, 424, 448], [450, 450, 481, 481, 1626]], "test": "timeout"}
{"id": "wlfyRs", "name": "Strobe Lights Grid Shenanigans", "author": "noobay", "description": "Trying to be creative for once and play around with a grid, instead of having a specific goal in mind.\nThis time it's some strobe lights on a stick! (well, a grid)", "tags": ["grid", "flow", "electricity"], "likes": 3, "viewed": 137, "published": "Public", "date": "1592778624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Random Grid Shenanigans\" by noobay. https://shadertoy.com/view/WlsyR2\n// 2020-06-21 22:06:13\n\n#define PI 3.14\n#define TARGET_COUNT 15\n#define GRID_CELL_SIZE 0.1\n#define RED vec3(1.0,0.0,0.0)\n#define GREEN vec3(0.0,1.0,0.0)\n#define BLUE vec3(0.0,0.0,1.0)\n\n#define SPEED_GROUP_ONE 0.20\n#define SPEED_GROUP_TWO 0.01\n\n#define DIMMNESS_GROUP_ONE 80.0\n#define DIMMNESS_GROUP_TWO 600.0\n\nvec2 getGridPosition(in vec2 uv)\n{\n\treturn vec2((uv.x / GRID_CELL_SIZE), (uv.y / GRID_CELL_SIZE));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized frag coordinates\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    \n    vec2 gridBoundUV = getGridPosition(uv);\n\n    vec2 cellBoundUV = gridBoundUV - round(gridBoundUV);\n    \n    float targetGroupOneIntensity = 0.0;\n    float targetGroupTwoIntensity = 0.0;\n \n    for (int targetIndex = 0; targetIndex < TARGET_COUNT; ++targetIndex)\n    {\n        float f_targetIndex = float(targetIndex);\n\n        float trigOffset = (PI / float(TARGET_COUNT)) * f_targetIndex;\n        vec2 targetPosition = vec2(sin(iTime + trigOffset) * SPEED_GROUP_ONE + tan(f_targetIndex + trigOffset), cos(iTime + trigOffset) * SPEED_GROUP_ONE + sin(f_targetIndex + trigOffset));\n        vec2 gridBoundTargetPosition = getGridPosition(targetPosition);\n        vec2 edgeBoundPosition = vec2(gridBoundTargetPosition.x, gridBoundTargetPosition.y);\n\n        float distanceToTarget = length(gridBoundUV - round(gridBoundTargetPosition)) - length((gridBoundUV) - (edgeBoundPosition));\n\n    \ttargetGroupOneIntensity += length(GRID_CELL_SIZE / (distanceToTarget * DIMMNESS_GROUP_ONE)  / cellBoundUV) * GRID_CELL_SIZE;\n    \n    }\n\n    for (int targetIndex = 0; targetIndex < TARGET_COUNT; ++targetIndex)\n    {\n        float f_targetIndex = float(targetIndex);\n\n        float trigOffset = (PI / float(TARGET_COUNT)) * f_targetIndex;\n\n        vec2 targetPosition = vec2(sin(iTime + trigOffset) * SPEED_GROUP_TWO + sin(f_targetIndex + trigOffset), tan(iTime + trigOffset) * SPEED_GROUP_TWO + sin(f_targetIndex + trigOffset));\n        vec2 gridBoundTargetPosition = getGridPosition(targetPosition);\n        vec2 edgeBoundPosition = vec2(gridBoundTargetPosition.x, gridBoundTargetPosition.y);\n\n        float distanceToTarget = length(gridBoundUV - round(gridBoundTargetPosition)) - length((gridBoundUV) - (edgeBoundPosition));\n\n    \ttargetGroupTwoIntensity += length(GRID_CELL_SIZE / (distanceToTarget * DIMMNESS_GROUP_TWO)  / cellBoundUV) * GRID_CELL_SIZE;\n    \n    }\n\n\n    vec3 col = vec3(smoothstep(0.2, 1.0, targetGroupOneIntensity + targetGroupTwoIntensity));\n\n    col += vec3(targetGroupOneIntensity + sin(iTime), 0.0 , targetGroupTwoIntensity + cos(iTime));\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 392, 426, 426, 492], [494, 494, 551, 586, 2773]], "test": "timeout"}
{"id": "WlfyRX", "name": "Math Animation 1", "author": "Deirin", "description": "fake 3d ring rotation.", "tags": ["2d", "math", "sdf", "animation", "ring"], "likes": 5, "viewed": 99, "published": "Public", "date": "1593123342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remap(float oldMin, float oldMax, float newMin, float newMax, float value){\n    return newMin + (value - oldMin) * (newMax - newMin) / (oldMax - oldMin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    uv += vec2( 0, remap( -1., 1., -.1, .1, sin(iTime * 3.) ) );\n    \n    float r = .8 * remap( -1., 1., 0.97, 1., sin(iTime * 9.) );\n    float sr = .05;\n    float d = abs( length( uv ) - r ) - 0.003;\n    d = min(d, length(uv) - .05 * remap(-1., 1., 0.8, 1.1, cos(iTime*6.)) );\n    \n    float div = 16.;\n    float TAU = 6.28318530718;\n    float a = TAU / div;\n    \n    for ( float i = 0.; i < div; i++ ) {\n        float rad = a * i + remap(-1.,1.,0.5,15.,sin(iTime));\n        float radt = TAU - rad;\n        vec2 pos = r * vec2( cos( rad ), sin( rad ) );\n        vec2 post = r * vec2( cos( radt ), sin( radt ) );\n        float srd = remap(-1., 1., 0.5, 1.7, sin( iTime * 5. + (i * .8 + 1.)) );\n        float sd = length( uv - mix( pos, post, (sin(iTime) + 1.) * .5) ) - sr * srd;\n        d = min( d, sd );\n    }\n    \n    fragColor = vec4( 1. - iResolution.y/3. * d );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 81, 81, 161], [163, 163, 220, 220, 1155]], "test": "timeout"}
{"id": "wlfyWB", "name": "voronoise fire", "author": "ich", "description": "voronoise fire", "tags": ["voronoisewavefire"], "likes": 5, "viewed": 229, "published": "Public API", "date": "1592956690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141\n#define pi2 (pi*2.)\n\nfloat n21(vec2 uv) {\n\treturn fract(9876. * sin(dot(uv, vec2(987, 654))));\n}\n\n\nvec2 n22(vec2 uv) {\n\tfloat n = n21(uv);\n\treturn vec2(n, n21(vec2(n)));\n}\n\n\nfloat n11(float v) {\n\treturn n21(vec2(v));\n}\n\nvec2 cs(vec2 uv) {\n\treturn vec2(cos(uv.x), sin(uv.y));\n}\n\nmat2 rot(float a) {\n\treturn mat2(\n\t\tcos(a), -sin(a),\n\t\tsin(a), cos(a)\n\t);\n}\n\nvec2 voronoi(vec2 uv, float intens) {\n\tvec2 out_id;\n\tfloat lo = 100.;\n\tfloat r = 1.;\n\tfor (float x = -r; x <= r; ++x) {\n\t\tfor (float y = -r; y <= r; ++y) {\n\t\t\tvec2 o = vec2(x, y);\n\t\t\tvec2 id = floor(uv + o) + .1;\n\t\t\tvec2 lv = fract(uv) - o - .5;\n\t\t\tvec2 t = n22(id) * iTime;\n\t\t\tlv += vec2(1, .6) * cs(t) * .5 * intens;\n            lv += (n22(uv) * .4 - .2) * intens;\n            //lv += cs(t + pi2*sin(uv.x*5.)) * .5 * intens;\n\t\t\tfloat l = length(lv);\n\t\t\tif (l < lo) {\n\t\t\t\tlo = l;\n\t\t\t\tout_id = id;\n\t\t\t}\n\t\t}\n\t}\n\treturn out_id;\n}\n\nfloat tri(float v) {\n\treturn abs(mod(v, 2.) - 1.);\n}\n\nfloat flower(vec2 uv) {\n\tfloat t = 3.+floor(3. * tri(iTime * .1));\n\tuv.x += sin(iTime * .2) * pow(max(0., uv.y + .3), 5.) * 5.;\n\tuv = rot(iTime * .1) * uv;\n\treturn length(uv) * sin(atan(uv.y, uv.x) * 3.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    vec2 m = (iMouse.xy - iResolution.xy*.5) / iResolution.y;\n\tvec3 c = vec3(0);\n\n    // mouse controls\n\tuv -= m * .3;\n    \n    // voronoi\n    float s = smoothstep(-2., 1., flower(uv));\n\tvec2 id = voronoi(uv * 20., s) / 20.;\n    \n    // coloring\n\tc.r += n21(id) * .5 + .5;\n    float l = flower(id);\n\tc.rg += vec2(1, .5) * l;\n\tc *= smoothstep(-2., 1., l);\n \n    // sparks\n    float r = n21(id);\n    float sparks = pow(abs(sin(r * 1234. + iTime * 1.)), 10.);\n    c.rg *= sparks * vec2(.5, 1.) * max(0., l) + 1.;\n    c.b += .3 * c.g * sparks;\n\n    fragColor = vec4(c, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 58, 113], [116, 116, 135, 135, 188], [191, 191, 211, 211, 235], [237, 237, 255, 255, 293], [295, 295, 314, 314, 370], [372, 372, 409, 409, 899], [901, 901, 921, 921, 953], [955, 955, 978, 978, 1161], [1163, 1163, 1218, 1218, 1849]], "test": "timeout"}
{"id": "Wlfyz4", "name": "Inferior ball", "author": "TAKUSAKU", "description": "Inferior ball", "tags": ["ball", "inferior", "spherer"], "likes": 4, "viewed": 60, "published": "Public", "date": "1591508640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 st = (vec3(2.0 * fragCoord.xy - iResolution.xy, iResolution.y));\n    st = normalize(vec3(st.xy, sqrt(max(st.z * st.z - dot(st.xy, st.xy) *2.,0.))));\n    st.xy *= rotate(iTime*0.1);\n   \n    st *= 21.*abs(1.1 + sin(iTime*0.3));\n    \n    float len;\n    for (int i = 0; i < 10; i++) {\n    \tlen = length(st);\n        st.x +=  sin(st.y + iTime * 0.3)*1.;\n        st.y +=  cos(st.x + iTime * 1.0 + cos(len * 1.0))*1.;\n    }\n    \n    vec3 color = cos(len + vec3(0.2,0.1,-0.05));\n    fragColor = vec4(color, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlfyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 38, 38, 104], [106, 106, 163, 163, 679]], "test": "timeout"}
{"id": "Wlfyzl", "name": "Line Segment (SDF)", "author": "57ar7up", "description": "Modified https://www.shadertoy.com/view/3tdSDj by IQ", "tags": ["2d", "distancefield", "sdf", "line", "distance", "segment"], "likes": 3, "viewed": 1186, "published": "Public API", "date": "1592726027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and line segment\n\n// Segment:              https://www.shadertoy.com/view/3tdSDj\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\tfloat zoom = 2.5;\n\tpos *= zoom;\n\n\tvec2 v1 = cos(iTime + vec2(0.,5.));\n\tvec2 v2 = cos(iTime + vec2(0.,5.) + 3.1);\n\tfloat thickness = .2 * (.5 + .5 * sin(iTime * 1.));\n\n\tfloat d = line_segment(pos, v1, v2) - thickness;\n\n\tvec3 color = vec3(1.) - sign(d) * vec3(0., 0., 0.);\n\tcolor *= 1.5 - exp(.5 * abs(d));\n\tcolor *= .5 + .3 * cos(120. * d);\n\tcolor = mix(color, vec3(1.), 1. - smoothstep(.0, .015, abs(d)));\n\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlfyzl.jpg", "access": "shaders20k", "license": "mit", "functions": [[1279, 1279, 1332, 1332, 1452], [1454, 1454, 1509, 1509, 2012]], "test": "timeout"}
{"id": "wlfyzN", "name": "Curly", "author": "Oggbog", "description": "An experiment with four layers of Truchets.", "tags": ["truchet"], "likes": 4, "viewed": 243, "published": "Public API", "date": "1591623629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nfloat qCircle(vec2 uv){\n    float p;\n    float d = length(uv);\n    \n    p = smoothstep(0.2,0.19,d);\n    p -= smoothstep(0.1,0.09,d);\n    \n    return p;\n    \n}\n\nvec3 layer(vec2 uv, float size, vec2 scroll, vec3 color,vec3 canvas){\n    uv *= size;\n    uv += scroll;\n    \n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    float n = hash21(id);\n    n = floor(n*2.0);\n    \n    float d1,d2;\n    float off = 1.0;\n    \n    if (n==0.0){\n        d1 = length(gv-vec2(0.0,0.0));\n    \td2 = length(gv-vec2(off,off));  \n    } else {\n        d1 = length(gv-vec2(off,0.0));\n    \td2 = length(gv-vec2(0.0,off));\n    }\n    \n    // truchet\n    float p = smoothstep(0.65,0.64,d1);\n    p -= smoothstep(0.35,0.34,d1);\n    p += smoothstep(0.65,0.64,d2);\n    p -= smoothstep(0.35,0.34,d2);\n    \n    // inner circle\n    p += qCircle(gv-vec2(0.0));\n    p += qCircle(gv-vec2(0.0,off));\n    p += qCircle(gv-vec2(off,0.0));\n    p += qCircle(gv-vec2(off,off));\n    \n    // add color\n    if (p==1.0){\n    \tcanvas = color;\n    }\n    \n    return canvas;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 canvas = mix(vec3(1.0,1.0,0.0),vec3(1.0,0.0,0.0),uv.x);\n    fragColor = vec4(canvas,1.0);\n    \n    float a = iTime/4.0;\n    uv = uv * mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    vec3 l = layer(uv,50.0,vec2(iTime/8.0,0.0),vec3(0.2),canvas);\n    l = layer(uv,20.0,vec2(0.0,sin(iTime/4.0)),vec3(0.5),l);\n    l = layer(uv,8.0,vec2(iTime/2.0,sin(-iTime/2.0)),vec3(0.7),l);\n    l = layer(uv,6.0,vec2(cos(-iTime/1.5),iTime/1.5),vec3(0.98),l);\n    fragColor = vec4(l,1.0);\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 122], [124, 124, 147, 147, 282], [284, 284, 353, 353, 1153], [1155, 1155, 1212, 1212, 1764]], "test": "ok"}
{"id": "Wlfyzr", "name": "Colorful rainbow jungle", "author": "jarble", "description": "This is another colorful \"jungle\" scene.\nClick and drag the mouse to move around.", "tags": ["3d", "raymarching", "jungle"], "likes": 0, "viewed": 194, "published": "Public API", "date": "1591223352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nvec3 surface_color(vec3 p)\n{\n    return sin(p*sin(p/2.0)/4.0);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    //p /= 40.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  4.4 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat sceneSDF(vec3 p){\n    p /= 10.0;\n    float scale_factor = .5;\n    vec3 p1 = p/scale_factor;\n\tfloat p2 = min(sceneSDF1(p1/4.0),min(sceneSDF1(p1.zxy/5.0),sceneSDF1(p1.yzx/2.0)));\n    return p2*scale_factor;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    vec3 eye = vec3(sin(iTime/5.0)*2.0, cos(iTime/5.0)*2.0, -iTime)*10.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlfyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 214, 214, 250], [253, 493, 518, 535, 645], [647, 647, 670, 670, 859], [861, 1282, 1373, 1373, 1679], [1694, 1948, 2013, 2013, 2145], [2147, 2236, 2265, 2265, 2575], [2577, 3069, 3209, 3209, 3799], [3801, 4171, 4256, 4256, 5014], [5016, 5343, 5392, 5427, 5558], [5560, 5560, 5617, 5617, 6532]], "test": "timeout"}
{"id": "wlfyzS", "name": "Ray Tracer Lesson 3 - Phong ", "author": "omegasbk", "description": "Shader made for lesson two of Darko's Gamedev Cookbook series on youtube.\nChannel: https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA", "tags": ["raytracing", "phong", "darko"], "likes": 0, "viewed": 98, "published": "Public", "date": "1592490438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Darko (omegasbk) \n//\n// Darko's Gamedev Cookbok Youtube serial\n// https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA\n//\n// Lesson 3 - Phong Shading\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom; \n} camera;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;     \n} sphere;\n\nstruct Light\n{\n\tvec3 direction;    \n} light;\n\nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n} material;\n\nvoid setupScene()\n{\n    camera.position = vec3(0., 0., 3.5);\n    camera.direction = vec3(0., 0., -1.);\n    camera.zoom = 1.0;\n    \n    sphere.position = vec3(0., 0., 0.);\n    sphere.radius = 0.3;\n    sphere.color = vec3(0.9, 0.2, 0.3);\n    \n    light.direction = normalize(vec3(0., -1., -0.78));\n    \n    material.ambience = 0.2;\n    material.diffuse = 0.7;\n    material.specular = 1.9;\n    material.shininess = 10.0;    \n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nbool intersect(vec3 direction, out vec3 surfaceNormal)\n{\n    vec3 L = camera.position - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        float t = t0;\n        if (t1 < t0)\n        {\n            t = t1;\n        }\n        \n        vec3 Phit = camera.position + t * direction;\n        surfaceNormal = normalize(Phit - sphere.position);\n        \n        return true;\n    }  \n     \n    return false;\n}\n\nvec3 rayTrace(vec3 direction)\n{\n    vec3 surfaceNormal;\n    \n    if (intersect(direction, surfaceNormal))\n    {\n        float coeff = -dot(light.direction, surfaceNormal);                          \n        \n        vec3 ambient = material.ambience * sphere.color;\n        vec3 diffuse = material.diffuse * max(coeff, 0.) * sphere.color;\n        \n        float shininess = pow(max(-dot(direction, reflect(light.direction, surfaceNormal)), 0.), material.shininess);\n        vec3 specular = material.specular * shininess * sphere.color;\n        \n        return ambient + diffuse + specular;\n    }\n    \n    return vec3(0., 0., 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{        \n    setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 direction = normalize(vec3(uv, camera.zoom) - camera.position);\n    \n    sphere.position.y = sin(iTime * 6.) / 3.;\n    \n    \n    light.direction.x = -(iMouse.x / iResolution.x - 0.5);\n    light.direction.y = -(iMouse.y / iResolution.y - 0.5);\n    light.direction = normalize(light.direction);\n    \n    \n    \n    vec3 col = rayTrace(direction);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[496, 496, 515, 515, 919], [921, 921, 997, 997, 1290], [1292, 1292, 1348, 1348, 1883], [1885, 1885, 1916, 1916, 2514], [2516, 2516, 2571, 2571, 3166]], "test": "ok"}
{"id": "wllcD2", "name": "It is frosting out there", "author": "Iranon", "description": "A variation of the precedent shader.", "tags": ["fbm", "domainwarping", "frost"], "likes": 7, "viewed": 119, "published": "Public", "date": "1593176684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n=== VARIATION OF\n\thttps://www.shadertoy.com/view/WtsyW2 ===\n\nMain references and functions from https://thebookofshaders.com/13/ and https://www.iquilezles.org/www/articles/warp/warp.htm\n\nCode structure from Low Pattern(https://www.shadertoy.com/view/WlsyWj)\n\n*/\n\n\n\n\n//2D Random and Noise functions\n\nfloat rand(in vec2 sd) {\n    \n    return fract( sin( dot( sd.xy, vec2(9.128, 3.256) * 293699.963 ) ) );\n}\n\n\nfloat n2D(in vec2 sd) {\n    \n    vec2 iComp = floor(sd);\n    \t\t\t\t\t\t//integer and fractional components\n    vec2 fComp = fract(sd);\n    \n    \n    float a = rand(iComp + vec2(0.0, 0.0));\t//\n    float b = rand(iComp + vec2(1.0, 0.0));\t// interpolation points\n    float c = rand(iComp + vec2(0.0, 1.0));\t// (4 corners)\n    float d = rand(iComp + vec2(1.0, 1.0));\t//\n    \n    vec2 fac = smoothstep(0.0, 1.0, fComp);\t//interpolation factor\n    \n    //Quad corners interpolation\n    return\n        mix(a, b, fac.x) +\n        \n        \t(c - a) * fac.y * (1.0 - fac.x) +\n        \n        \t\t(d - b) * fac.x * fac.y ;\n}\n\n\n\n//fractal Brownian Motion and Motion Pattern\n\n#define OCTAVES 6\n\nfloat fBM(in vec2 sd) {\n    \n    //init values\n    float val = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    \n    float lacunarity = 2.0;\n    float gain = 0.5;\n    \n    //Octaves iterations\n    for(int i = 0; i < OCTAVES; i++) {\n        \n        val += amp * n2D(sd * freq);\n        \n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return val;\n}\n\n\nfloat mp(in vec2 p) {\n    \n    float qx = fBM(p + vec2(0.0, 0.0));\n    float qy = fBM(p + vec2(6.8, 2.4));\n    \n    vec2 q = vec2(qy,qx);\n    \n    float tm = 0.008 * iTime * 1.3;\t//time factor\n    \n    float rx = fBM(p + (1.1 * tm*1.2) * q + vec2(9.5, 9.3) * tm);\n    float ry = fBM(p + (18.5 * tm/1.3) * q + vec2(7.2, 1.5) * -(tm + 0.002));\n    \n    vec2 r = vec2(rx, ry);\n    \n    return fBM(p + (2.0 * r));\n}\n\n\n//From https://www.shadertoy.com/view/XlKSDR\nvec3 Tonemap_ACES(const vec3 t) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (t * (a * t + b)) / (t * (c * t + d) + e);\n}\n\n\n\n//========================================================================\n\n//main()\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    \n    vec3 col = vec3(0.0);\n    //col += fBM(uv*3.0);\n    \n    vec3 mask = texture(iChannel0, uv).rgb;\n    \n    float wFac = mp(uv*3.0); //warping factor\n   \n    col = mix(vec3(0.101961, 0.29608, 0.26567), vec3(0.66667,0.45667,0.89839), clamp(pow(wFac, 2.5), 0.0, 1.0));\n    col = mix(col, vec3(0.24467,0.00567,0.19809), clamp(pow(wFac, 0.4), 0.0, 1.0));\n    col = mix(col, vec3(0.32467,0.22567,0.31809), clamp(wFac * wFac, 0.0, 1.0));\n    col = mix(col, vec3(0.64467,0.32567,0.13809), clamp(smoothstep(0.0, 1.0, wFac), 0.0, 1.0));\n    \n    vec3 bg = mix(col, vec3(0.00467,0.32567,0.93809), clamp(smoothstep(0.0, 1.0, wFac), 0.0, 1.0));\n    bg = mix(bg, vec3(0.12467,0.92567,0.61809), clamp(wFac * wFac, 0.0, 1.0)) * 1.4;\n    \n    \n    col = mix(bg, col, mask);\n    //col = Tonemap_ACES(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 328, 328, 409], [412, 412, 435, 435, 1020], [1089, 1089, 1112, 1135, 1456], [1459, 1459, 1480, 1480, 1870], [1873, 1918, 1951, 2007, 2193], [2284, 2284, 2341, 2390, 3294]], "test": "error"}
{"id": "WllcD4", "name": "Straight Curve - Bridget Riley", "author": "lynnh", "description": "    // Bridget Riley\n\t// Straight Curve, 1963\n    // Original code in ShaderBooth by Max\n    // https://shaderbooth.com/?4ab87\n", "tags": ["art"], "likes": 2, "viewed": 49, "published": "Public", "date": "1592105365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord.xy/iResolution.xy;\n\t\n    pos.x += sin(iTime + pos.x * 3.0) * 0.1;\n    pos.y += cos(iTime + pos.y * 3.0)*0.15;\n    pos.y *= -1.0;\n    pos = mod(pos*12.0, 1.0);\n    \n    vec3 color = vec3(1.0);\n    \n    if(pos.x > pos.y) {\n    \tcolor = vec3(0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n\n    // -------\n    // Bridget Riley\n\t// Straight Curve, 1963\n    // Original code in ShaderBooth by Max\n    // https://shaderbooth.com/?4ab87\n\n \t// vec2 pos = uv;\n    // pos.x += sin(time + uv.x*3.)*0.1;\n    // pos.y += cos(time + uv.y*3.)*0.15;\n\t// pos.y *=-1.;\n  \t// pos = mod(pos*12.,1.0);\n\n  \t// vec3 color = black;\n  \n    // if(pos.x>pos.y){\n    //    color= white;\n    //}\n\n    // gl_FragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllcD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 862]], "test": "ok"}
{"id": "wllcDH", "name": "Ripple Flow", "author": "TAKUSAKU", "description": "Ripple Flow", "tags": ["flow", "ripple"], "likes": 4, "viewed": 158, "published": "Public", "date": "1592049675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 U )\n{\n    vec2 u=vec2(2.*U-iResolution.xy)/iResolution.y*4.;\n    for(float i=1.;i<4.;i++)\n        u.x+=cos(u.y*i*3.)*.1,\n        u.xy+=sin(u.x*u.x+u.y*u.y-iTime*7.),\n        u+=cos(u*5.)*.1,\n        o=cos(float(u*.4)+vec4(.2,.1,.1,0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 273]], "test": "ok"}
{"id": "wllcDM", "name": "Iridescent Light", "author": "Terah", "description": "Iridescent Light", "tags": ["2d", "light", "iridescent"], "likes": 9, "viewed": 134, "published": "Public", "date": "1592261459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(-1.);\nconst float tau = 2.*pi;\n\nmat2 rot(float a){\n    float c=cos(a);float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat light(vec2 p, float t) {\n       \n    p.y *= 2.7;\n      \n    float d = length(p);\n\n    p.x *= p.y*7.;\n\n    float a = sin(t*.7 + d*6.5);\n    \n    p *= a*abs(sin(t*.3 + d*3.1))*pow(abs(sin(t*.3)), 2.);\n        \n    float c = .0005/(sin(length(p*.3)));\n    \n    return pow(c, .6);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n\tvec3 col = vec3(0);\n\n    \n    for(int i=0;i<3;i++) {\n        col[i] += light(p, -iTime + float(i)*.03);\n    }\n    \n    p.xy = p.yx;\n    \n    for(int i=0;i<3;i++) {\n        col[i] += light(p, -iTime + float(i)*.03);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 72, 72, 136], [138, 138, 168, 168, 422], [425, 425, 482, 482, 808]], "test": "error"}
{"id": "wllcDS", "name": "radial sd lines", "author": "dtsmio", "description": "radial lines", "tags": ["radial"], "likes": 8, "viewed": 120, "published": "Public", "date": "1593009646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535\n#define scale vec2(6., 12.)\n\nfloat line (vec2 a, vec2 b, vec2 p)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = min(1., max(0., dot(pa, ba)/dot(ba, ba)));\n    \n    return length(pa - ba * h);\n}\n\nvec2 toDec (vec2 pol)\n{\n \treturn vec2(cos(pol.x * PI * 2.), sin(pol.x * PI * 2.)) * pol.y;   \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col1 = vec3(0);\n    vec3 col2 = vec3(0);\n    \n    vec2 s = scale;\n    \n\tvec2 rv = vec2(atan(uv.y, uv.x) / PI / 2., length(uv));\n    s.x += floor(rv.y * scale.y) * 2.;\n    rv *= s;\n    //rv = fract(rv/scale) * scale;\n    \n    vec2 cv = vec2(fract(rv.x), fract(rv.y));\n    vec2 id = vec2(floor(rv.x), floor(rv.y));\n    \n    col1 = cv.xyy;\n\n    float d = 0.;\n    \n    for ( float i = id.x - 2.; i <= id.x + 2.; i++)\n    {\n        for ( float j = id.y - 2.; j <= id.y + 2. && j >= -2.; j++)\n        {\n            if (j < 0.) continue;\n            \n            vec2 cs = s;\n            cs.x += (j - id.y) * 2.;\n            cs.x = max(scale.x, cs.x);\n            \n            float a1 = smoothstep(0., 0.2, sin(iTime + j/6.) * 0.5);\n            float a2 = smoothstep(0., 0.2, cos(iTime + j/4.) * 0.5);\n            float a3 = smoothstep(-0.6, -0.4, sin(iTime + j/6.)) * 0.5 + \n                \t   smoothstep(0.4, 0.6, sin(iTime + j/6.)) * 0.5;\n            \n            vec2 v = vec2(i, j);\n            vec2 p1 = toDec((v + vec2(a3 * 1., a2 * 0.3 + 0.2))/cs);\n            vec2 p2 = toDec((v + vec2(-a3 * 1., -a2 * 0.3 - 0.2) + 1.)/cs);\n            float t = line(p1, p2, toDec(rv/s));\n            float tt = smoothstep(0.02, 0.01, t);\n            t = 1. - t;\n            d = max(d, t);\n        }\n    }\n    \n    \n    d = smoothstep(0.982, 0.99, d); \n    col2 += d;\n    \n    \n    fragColor = vec4(col2, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 90, 90, 215], [217, 217, 240, 240, 312], [318, 318, 375, 375, 1855]], "test": "timeout"}
{"id": "WllcW2", "name": "Dodecahedralis VIII", "author": "sl2c", "description": "Still similar to [url=https://www.shadertoy.com/view/wtXcDB]this[/url] and [url=https://www.shadertoy.com/view/tlXcz7]this[/url].", "tags": ["fractal", "circles", "hyperbolic"], "likes": 5, "viewed": 67, "published": "Public", "date": "1593190234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nbool flip(inout vec3 z, in vec2 c, in float r, inout int t, in int k) {\n    z.xy -= c;\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        z *= r * r / dot(z,z);\n        t = k - t;\n    }\n    z.xy += c;\n    return res;\n}\n\nbool inside(in vec3 z, in vec2 c, in float r, inout float t) {\n    vec3 p = z - vec3(c,0.0);\n    float res = (dot(p,p)-r*r) / (2.0 * abs(r) * p.z);\n    t = min(t, abs(res));\n    return res < 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.0 / iResolution.y;\n    vec3 z = vec3(z0,ds);\n    \n    vec2[12] c; float[12] r;\n    float r1 = pow(1.5 + 0.5 * sqrt(5.0) - sqrt(1.5 * sqrt(5.0) + 2.5), 0.5);\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1 * sqrt(sqrt(5.0));\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<5; i++) {\n        float theta = tau * 0.2 * float(i);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+6] = r3;\n        c[i+6] = x3 * eit;\n    }\n    float r4 = -1.0 / r1;\n    r[11] = r4; c[11] = vec2(0.0);\n    \n    float period = -8.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    z *= exp(-d);\n    \n    bool fl = false;\n    float yellow = 0.0;\n    int t = 1;\n    int s1 = 0;\n    int s2 = 0;\n    int s3 = 0;\n    bool fl1 = false; bool fl2 = false; bool fl3 = false;\n    for (int i=0; i<7; i++) {\n        fl1 = fl1 ^^ flip(z, c[0], r[0], s1, 1);\n        fl1 = fl1 ^^ flip(z, c[1], r[1], s1, 1);\n        fl3 = fl3 ^^ flip(z, c[2], r[2], s3, 1);\n        fl2 = fl2 ^^ flip(z, c[3], r[3], s2, 1);\n        fl2 = fl2 ^^ flip(z, c[4], r[4], s2, 1);\n        fl3 = fl3 ^^ flip(z, c[5], r[5], s3, -1);\n        fl1 = fl1 ^^ flip(z, c[6], r[6], s1, -1);\n        fl3 = fl3 ^^ flip(z, c[7], r[7], s3, -1);\n        fl2 = fl2 ^^ flip(z, c[8], r[8], s2, -1);\n        fl2 = fl2 ^^ flip(z, c[9], r[9], s2, -1);\n        fl3 = fl3 ^^ flip(z, c[10], r[10], s3, 1);\n        fl1 = fl1 ^^ flip(z, c[11], r[11], s1, -1);\n        \n    }\n    if (fl1) {s1=-s1;}\n    if (fl2) {s2=-s2;}\n    if (fl3) {s3=-s3;}\n    vec3 s = vec3(float(s2+s3));\n    \n    s = s / (1.5 + abs(s));\n    vec3 col = 0.5 + s * 0.45;\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllcW2.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[485, 485, 547, 547, 682]], "test": "timeout"}
{"id": "wllcW4", "name": "Light experiments", "author": "julianlumia", "description": "just playing a bit:)", "tags": ["light"], "likes": 7, "viewed": 93, "published": "Public", "date": "1592136972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 54\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\n\nfloat displacement(vec3 p, float scale)\n{\n    return sin(scale*p.x)*sin(scale*p.y)*sin(scale*p.z);\n}\n\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g5;\n\n\n\nconst float PI = 3.14159265;\n\n\n\nvec3 spherepos;\nvec2 GetDist(vec3 p) {\n vec2 d;\n vec2 e = vec2(p.y +2.5,3);\n vec3 p4 = p;\n float the;\n the = iTime *.2;\n p4.zx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n     the = iTime *.123;\n\n     p4.yx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n\n vec2 box11 = vec2((sdOctahedron(p4, 1.3)),5.);\n     vec2 dbox2 = vec2(sdBox( p4,vec3(1.3)),5);\n\n    box11.x = mix (dbox2.x,box11.x,sin(iTime)*0.5+.7);\n\n \n vec2 box10 = vec2((sdBox(p, vec3(.5,1.,0.0))),5.);\n float displacement = sin(1.5*p.x+ iTime*0.5)*sin(1.2*p.y+ iTime)*cos(.5*p.z+ iTime);\n box10.x += displacement;\n spherepos = vec3(-0.0,2.5,-0.);\n float box9 = (sdSphere(p-spherepos, 0.));\n vec2 box;\n vec3 p2 = p;\n the = (iTime*0.2);\n float two = ((dot(sin(p2.zxy+iTime*0.2)*5., cos(p2.zxy*4.+iTime))));\n\n two = ((dot(sin(p2.zxy*2.+0.), cos(p2.zxy*8.+iTime))));\n box10.x = mix(box10.x,two,0.1);\n box10 = vec2(box10.x,3);\nbox10.x *= 0.7;\n g5 +=1./(.15+pow(abs(box11.x),1.));\n\n    box10.x = smin(box10.x,box11.x,.5);\n\nd = condmin(box10,e);\n return  d;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=100.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 30; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || (t)>10.) break;\n  t += d * .3;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n float d = .1;\n float shadow = 1.0;\n while(d < maxDist)\n {\n  float t = GetDist(r0 + d * rd).x;\n  if(t < 0.002) return 0.0;\n  d += t;\n  shadow = min(shadow,50.0 * (t / d));\n }\n return shadow;\n}\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(spherepos);\n vec3 l = normalize(lightPos-p);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n float d = RayMarch(p+n*SURF_DIST*1., l).x;\n return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\nvec2 m = iMouse.xy/iResolution.xy;\n\nvec3 eye = 1.0*vec3(0.,1.,5.);\nvec3 col;\nvec2 d;\nvec3 hoek = vec3(0,-0.,-2.);  \nfloat   the = (iTime*.5);\n     eye.zx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n\nmat3 camera = setCamera( eye, hoek,0.);\nfloat fov = 1.;\nvec3 dir = camera * normalize(vec3(uv, fov));\nvec3 p;\nvec3 n;\nvec3 focalPoint = eye + (dir * 1.);\nvec3 shiftedRayOrigin = eye;\nvec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n d = RayMarch(shiftedRayOrigin, shiftedRay);\nfloat t =d.x *1.;\nvec3  shiftedRayOrigin2 = shiftedRayOrigin;\nvec3  shiftedRay2= shiftedRay;\nif(t<MAX_DIST) {\n shiftedRayOrigin2 += shiftedRay2 * t;\n vec3 sn = GetNormal(shiftedRayOrigin2);\n shiftedRay2 = reflect(shiftedRay2, sn);\n if(d.y==3.) traceRef(shiftedRayOrigin2 +  shiftedRay2*0.1, shiftedRay2);\n p = shiftedRayOrigin + shiftedRay * t;\n n= GetNormal(p.xyz);\n vec3 lp =    spherepos*1.;\n const int numIter = 90;\n vec3 vD = shiftedRay;\n vD = normalize(vD);\n float stepSize = length(p - shiftedRayOrigin) / float(numIter);\n vec3 vO = shiftedRayOrigin + stepSize * vD;\n float accum = 0.0;\n for(int i = 0; i  < numIter; ++i)\n  {\n\tvec3 ld = normalize(lp - vO);\n\tfloat shad = shadow(vO, ld, 5.);\n\tfloat d = dot(vO, vO);\n\taccum += (.00001+abs(sin(iTime)*0.0008-0.001) / d ) * shad;\n\tvO += stepSize * vD;\n   }\n  vec3   color= vec3(1., 1., 1.);\n col +=g5*vec3(0.015)*vec3(1.,1.,1.)*1.;    \n \n col *= marchCount * vec3(1., 1.,1.) * 0.0003;\n float dif = GetLight(p);\n vec3 sky = vec3(1., 1., 1.);\n col *= mix(sky, col, 10./(t*t/1./1.*1.+1.5));   \n\n col *= accum * color *30.;\n }\n col*=10.;\n col=smoothstep(0.0,15.,col);\n col=pow(col, vec3(0.4545));\n fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllcW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 105, 105, 172], [174, 174, 212, 212, 263], [265, 265, 284, 284, 351], [355, 355, 396, 396, 455], [458, 458, 499, 499, 584], [586, 586, 619, 619, 644], [646, 646, 675, 675, 753], [816, 816, 838, 838, 1823], [1826, 1826, 1859, 1859, 2072], [2093, 2093, 2124, 2124, 2357], [2359, 2359, 2410, 2410, 2571], [2573, 2573, 2596, 2596, 2780], [2782, 2782, 2829, 2829, 3022], [3024, 3024, 3048, 3048, 3243], [3245, 3245, 3302, 3302, 5028]], "test": "timeout"}
{"id": "wllczj", "name": "deep-sea mandelbox", "author": "wj", "description": "This is a stripped down version of a shader that  I had used here: https://youtu.be/0RuYh-5gRGk\n\nThe basic algorithm is very simular to what was used in an old version of Fractal Lab and I thought it might be useful to have it here on shadertoy.", "tags": ["raymarching", "mandelbox", "ambientocclusion", "blinnbong"], "likes": 5, "viewed": 115, "published": "Public", "date": "1592573939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// deep-sea mandelbox\n// by wj\n// \n// This is a stripped down version of a shader I had used on my 2017 page:\n// https://www.wothke.ch/modum\n//\n// The code is rather verbose and it might be useful to play around with\n// here on shadertoy.\n//\n// It is heavily based on the logic from an old version of Fractal Lab \n// (see http://www.subblue.com). Copyright 2011, Tom Beddard\n// \n// I am therefore using the same licence here that Tom Beddard's \n// respective code had used:\n//\n// Licensed under the GPL Version 3 license.\n// http://www.gnu.org/licenses/\n\nprecision highp float;\n\n#define HALFPI 1.570796\n#define MIN_EPSILON 6e-7\n#define MIN_NORM 1.5e-7\n\n#define maxIterations 15                              // 1 to 30\n#define stepLimit 105                                 // 10 to 300\n#define aoIterations 3                                // 0 to 10\n\n#define minRange 6e-5\n\n\t\t\t\n// fractal params\t\t\t\nconst float deFactor= 1.;                             // 0 to 1\nconst float scale= -2.81;                             // -10 to 10\nconst float surfaceDetail= 0.66;                      // 0.1 to 2\nconst float surfaceSmoothness= 0.79;                  // 0.01 to 1\nconst float boundingRadius= 114.02;                   // 0.1 to 150\nconst vec3 offset= vec3(0., 0., 0.);                  // -3 to 3\n\nconst float sphereScale= 1.;                          // 0.01 to 3\nfloat boxScale= 0.5;                                  // 0.01 to 3\nconst float boxFold= 1.;                              // 0.01 to 3\nconst float fudgeFactor= 0.;                          // 0 to 100\n\nfloat glitch;                                         // 0 to 0.02\n\n// unused..  uncomment if needed\n//mat3  objectRotation;\n//mat3  fractalRotation1;\n//mat3  fractalRotation2;\n\n// color\nconst int   colorIterations= 3;                       // 0 to 30\nconst vec3  color1= vec3(0.4, 0.3, 0.9);\nconst float color1Intensity= 2.946;                   // 0 to 3 \nconst vec3  color2= vec3(0.1, 0.1803, 0.1);\nconst float color2Intensity= 0.16;                    // 0 to 3\nconst vec3  color3= vec3(0.3, 0.3, 0.9);\nconst float color3Intensity= 0.11;                    // 0 to 3\nconst bool  transparent= false;                       // transparent background\nconst float gamma= 0.799;                             // gamma correction; 0.1 to 2\n\n// lights\nconst vec3  light= vec3(48, 191, -198);               // light position\nconst vec2  ambientColor= vec2(0.41, 0);              // ambient intensity, ambient color\nconst vec3  background1Color= vec3(0.7882, 1, 1);\nconst vec3  background2Color= vec3(0,0,0);            // background bottom\n\n// glow\nconst vec3  innerGlowColor= vec3(0.23, 0.249, 0.9019);\nconst float innerGlowIntensity= 0.24;                 // 0, 1\nconst vec3  outerGlowColor= vec3(1.0, 1.0, 1.0);\nconst float outerGlowIntensity= 0.08;                 // 0, 1\n\n// fog\nconst float fogIntensity= 0.06;                       // 0, 1\nconst float fogFalloff= 2.8;                          // 0, 10\n\n// shinyness\nconst float specularity= 0.86;                        // 0, 3\nconst float specularExponent= 7.0;                    // 0, 50\n\n// ambient occlusion\nconst float aoIntensity= 0.21;                        // 0 to 1\nconst float aoSpread= 11.79;                          // 0 to 20\n\n// camera\nconst float cameraFocalLength= 0.9;                   // 0.1 to 3\nfloat fovfactor;                                      // field of view\nvec3 cameraPosition;\nmat3  cameraRotation;\n\nfloat aspectRatio;\nfloat pixelScale;\nfloat epsfactor;\n\nvec2  size;\nvec2  halfSize;\n\nvec3  w = vec3(0, 0, 1);\nvec3  v = vec3(0, 1, 0);\nvec3  u = vec3(1, 0, 0);\n\n\n// Pre-calculations\nfloat mR2;                                           // Min radius\nfloat fR2;                                           // Fixed radius\nvec2  scaleFactor;\n\t\t\t\t\t\t\n\n// Details about the Mandelbox DE algorithm:\n// http://www.fractalforums.com/3d-fractal-generation/a-mandelbox-distance-estimate-formula/\nvec3 Mandelbox(vec3 w)\n{\n//    w *= objectRotation;\n    float md = 1000.0;\n    vec3 c = w;\n\t\t\t\t\n\t// distance estimate\n    vec4 p = vec4(w.xyz, deFactor),\n        p0 = vec4(w.xyz, 1.0);  // p.w is knighty's DEfactor\n\t\t\t\t\n    for (int i = 0; i < int(maxIterations); i++) {\n\t\t// box fold:\n        p.xyz = clamp(p.xyz, -boxFold, boxFold) * 2.0 * boxFold - p.xyz;  // box fold\n//        p.xyz *= fractalRotation1;\n\t\t\t\t\t\n\t\t// sphere fold:\n        float d = dot(p.xyz, p.xyz);\n        p.xyzw *= clamp(max(fR2 / d, mR2), 0.0, 1.0);  // sphere fold\n\t\t\t\t\t\n        p.xyzw = p * scaleFactor.xxxy + p0 + vec4(offset, 0.0);\n//        p.xyz *= fractalRotation2;\n\n        if (i < colorIterations) {\n            md = min(md, d);\n            c = p.xyz;\n        }\n    }\n\t\t\t\t\n\t// Return distance estimate, min distance, fractional iteration count\n    return vec3((length(p.xyz) - fudgeFactor) / p.w, md, 0.33 * log(dot(c, c)) + 1.0);\n}\n\n\n// Define the ray direction from the pixel coordinates\nvec3 rayDirection(vec2 pixel)\n{\n    vec2 p = (0.5 * halfSize - pixel) / vec2(halfSize.x, -halfSize.y);\n    p.x *= aspectRatio;\n    vec3 d = (p.x * u + p.y * v - cameraFocalLength * w);\n    return normalize(cameraRotation * d);\n}\n\n\n// Intersect bounding sphere\n//\n// If we intersect then set the tmin and tmax values to set the start and\n// end distances the ray should traverse.\nbool intersectBoundingSphere(vec3 origin,\n                             vec3 direction,\n                             out float tmin,\n                             out float tmax)\n{\n    bool hit = false;\n    float b = dot(origin, direction);\n    float c = dot(origin, origin) - boundingRadius;\n    float disc = b*b - c;           // discriminant\n    tmin = tmax = 0.0;\n\n    if (disc > 0.0) {\n\t\t// Real root of disc, so intersection\n        float sdisc = sqrt(disc);\n        float t0 = -b - sdisc;          // closest intersection distance\n        float t1 = -b + sdisc;          // furthest intersection distance\n\n        if (t0 >= 0.0) {\n\t\t\t// Ray intersects front of sphere\n            tmin = t0;\n            tmax = t0 + t1;\n        } else {\n\t\t\t// Ray starts inside sphere\n            tmax = t1;\n        }\n        hit = true;\n    }\n\n    return hit;\n}\n\n// Calculate the gradient in each dimension from the intersection point\nvec3 generateNormal(vec3 z, float d)\n{\n    float e = max(d * 0.5, MIN_NORM);\n\t\t\t\t\n    float dx1 = Mandelbox(z + vec3(e, 0, 0)).x;\n    float dx2 = Mandelbox(z - vec3(e, 0, 0)).x;\n\t\t\t\t\n    float dy1 = Mandelbox(z + vec3(0, e, 0)).x;\n    float dy2 = Mandelbox(z - vec3(0, e, 0)).x;\n\t\t\t\t\n    float dz1 = Mandelbox(z + vec3(0, 0, e)).x;\n    float dz2 = Mandelbox(z - vec3(0, 0, e)).x;\n\t\t\t\t\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\n\n// Blinn phong shading model\n// http://en.wikipedia.org/wiki/BlinnPhong_shading_model\n// base color, incident, point of intersection, normal\nvec3 blinnPhong(vec3 color, vec3 p, vec3 n)\n{\n\t\t\t\t// Ambient colour based on background gradient\n    vec3 ambColor = clamp(mix(background2Color, background1Color, (sin(n.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0);\n    ambColor = mix(vec3(ambientColor.x), ambColor, ambientColor.y);\n\t\t\t\t\n    vec3  halfLV = normalize(light - p);\n    float diffuse = max(dot(n, halfLV), 0.0);\n    float specular = pow(diffuse, specularExponent);\n\t\t\t\t\n    return ambColor * color + color * diffuse + specular * specularity;\n}\n\n// Ambient occlusion approximation.\n// Based upon boxplorer's implementation which is derived from:\n// http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 p, vec3 n, float eps)\n{\n    float o = 1.0;                  // Start at full output colour intensity\n    eps *= aoSpread;                // Spread diffuses the effect\n    float k = aoIntensity / eps;    // Set intensity factor\n    float d = 2.0 * eps;            // Start ray a little off the surface\n\t\t\t\t\n    for (int i = 0; i < aoIterations; ++i) {\n        o -= (d - Mandelbox(p + n * d).x) * k;\n        d += eps;\n        k *= 0.5;                   // AO contribution drops as we move further from the surface \n    }\n\t\t\t\t\n    return clamp(o, 0.0, 1.0);\n}\n\n// Calculate the output color for each input pixel\nvec4 render(vec2 pixel)\n{\n    vec3  ray_direction = rayDirection(pixel);\n\t\n    float ray_length = minRange;\n    vec3  ray = cameraPosition + ray_length * ray_direction;\n    vec4  bg_color = vec4(clamp(mix(background2Color, background1Color, (sin(ray_direction.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0), 1.0);\n    vec4  color = bg_color;\n\t\t\t\t\n    float eps = MIN_EPSILON;\n    vec3  dist;\n    vec3  normal = vec3(0);\n    int   steps = 0;\n    bool  hit = false;\n    float tmin = 0.0;\t// 'out' params of intersectBoundingSphere()\n    float tmax = 0.0;\n\t\t\t\n    if (intersectBoundingSphere(ray, ray_direction, tmin, tmax)) {\n        ray_length = tmin;\n        ray = cameraPosition + ray_length * ray_direction;\n\n\t   \tvec3  lastDist= vec3(0.,0.,0.);\n\t\t\t\n        for (int i = 0; i < stepLimit; i++) {\n            steps = i;\n            dist = Mandelbox(ray);\n            dist.x *= surfaceSmoothness;\n\t\t\t\t\t\t\n\t\t\t// If we hit the surface on the previous step check again to make sure it wasn't\n\t\t\t// just a thin filament\n            if (hit && dist.x < eps || ray_length > tmax || ray_length < tmin) {\t// XXX ray_length < tmin impossible!\n                steps--;\n                break;\n            }\n\t\t\t\t\t\t\n            hit = false;\n            ray_length += dist.x;\t// XXX dist.x is always positive...\n            ray = cameraPosition + ray_length * ray_direction;\n            eps = ray_length * epsfactor;\n\n\t\t\t// add-on effect hack: \"distant\" stuff turns into water... \t\t\t\n\t\t\tif (ray_length > 0.1) {\n\t\t\t\tray_length+=glitch;\n\t\t\t\thit = true;\n\t\t\t} else if (dist.x < eps || ray_length < tmin) {\n\t\t\t\thit = true;\t// normal mode\n\t\t\t\tlastDist= dist;\t\t\t\n\t\t\t}\n    \t}\n    }\n\t\t\t\t\n\t// Found intersection?\n    float glowAmount = float(steps)/float(stepLimit);\n    float glow;\n\t\t\t\t\n    if (hit) {\n        float aof = 1.0, shadows = 1.0;\n        glow = clamp(glowAmount * innerGlowIntensity * 3.0, 0.0, 1.0);\n\n        if (steps < 1 || ray_length < tmin) {\n            normal = normalize(ray);\n        } else {\n            normal = generateNormal(ray, eps);\n            aof = ambientOcclusion(ray, normal, eps);\n        }\n\t\t\t\t\t\n        color.rgb = mix(color1, mix(color2, color3, dist.y * color2Intensity), dist.z * color3Intensity);\n        color.rgb = blinnPhong(clamp(color.rgb * color1Intensity, 0.0, 1.0), ray, normal);\n        color.rgb *= aof;\n        color.rgb = mix(color.rgb, innerGlowColor, glow);\n\t\t\t\n\t\t// make details disapear in the distant fog\n        color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(abs(ray_length * exp(fogFalloff)), 2.0) * fogIntensity));\n        color.a = 1.0;\n    } else {\n\t\t// Apply outer glow and fog\n        ray_length = tmax;\n        color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(abs(ray_length * exp(fogFalloff)), 2.0)) * fogIntensity);\n        glow = clamp(glowAmount * outerGlowIntensity * 3.0, 0.0, 1.0);\n\t\t\t\t\t\n        color.rgb = mix(color.rgb, outerGlowColor, glow);\n        if (transparent) color = vec4(0.0);\n    }\n    return color; \n}\n\n// Return rotation matrix for rotating around vector v by angle\nmat3 rotationMatrixVector(vec3 v, float angle)\n{\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n\t\t\t\t\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n              (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n              (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\t// size of generated texture   \n\tsize = iResolution.xy;\n\thalfSize= size/2.0;\n\t   \n\t// setup camera\n    vec3 dir= vec3(20.*sin(iTime*.33), 20.*sin(iTime*.33), -22.); \t// 180= full circle\n\tcameraPosition= vec3( 0.17963 + sin(iTime*.1)*.4, \n\t\t\t\t\t\t  0.099261, \n\t\t\t\t\t\t -1.3678434 + sin(iTime*.05)*.2);\t\n\t\t\n    cameraRotation= \trotationMatrixVector(u, dir.x) *\n        \t\t\t\trotationMatrixVector(v, dir.y) * \n        \t\t\t\trotationMatrixVector(w, dir.z);\n\t\n    fovfactor = 1.0 / sqrt(1.0 + cameraFocalLength * cameraFocalLength);\n\taspectRatio = size.x / size.y;\n\tpixelScale = 1.0 / min(size.x, size.y);\n\tepsfactor = 2.0 * fovfactor * pixelScale * surfaceDetail;\n\n\t// animate box scale\n    float freq= 1.0;\t// 0 to 512\t(use some bass frequeny)\n\tfloat fft= texelFetch( iChannel0, ivec2(freq,0), 0 ).x; \n\tboxScale= 0.5 + fft*0.03;\n    \n\t\t// update derived fractal\n\tmR2 = boxScale * boxScale;\n\tfR2 = sphereScale * mR2;\n\tscaleFactor = vec2(scale, abs(scale)) / mR2;\n\t\n\t\n\t// throw in glitch effect once in a while \n\tfloat m= mod(iTime*.2, 2.0); \n    if (m <= 1.0) {\n\t\tglitch= 0.002*(2.0-(cos(m*HALFPI*4.)+1.0));\n    } else {\n\t\tglitch= 0.00;\n\t}\n\t\t\t\t\t\t\n    vec4 color = render(fragCoord);\t// do without antialiasing to limit GPU load\t\t\t\t\n\tfragColor = vec4(pow(abs(color.rgb), vec3(1.0 / gamma)), color.a);\n}\n", "image_inputs": [{"id": "Xt23z3", "previewfilepath": "https://www.soundcloud.com/maniacs-of-noise/jeroen-tel-the-open-soul-preview-v22", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://www.soundcloud.com/maniacs-of-noise/jeroen-tel-the-open-soul-preview-v22", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllczj.jpg", "access": "shaders20k", "license": "gpl-2.0", "functions": [[3794, 3932, 3956, 3983, 4847], [4850, 4905, 4936, 4936, 5133], [5136, 5284, 5462, 5462, 6133], [6135, 6207, 6245, 6245, 6654], [6657, 6798, 6843, 6894, 7297], [7299, 7463, 7514, 7514, 8048], [8050, 8101, 8126, 8126, 11059], [11061, 11125, 11173, 11173, 11574], [11576, 11576, 11634, 11667, 12925]], "test": "error"}
{"id": "wllczM", "name": "Forested planet", "author": "jarble", "description": "I added some trees to my [url=https://www.shadertoy.com/view/tlXyz7]desert planet[/url] shader.", "tags": ["3d", "planet", "forest"], "likes": 1, "viewed": 189, "published": "Public API", "date": "1591729787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\nconst float planet_size = 30000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale/planet_size*1000000.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\nvec3 jungle_color(vec3 p)\n{\n    return vec3(0,1.0,0.5);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat SDF1(vec3 p) {\n    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));\n}\n\nfloat SDF2(vec3 p){\n    p *= 3.0;\n\treturn 0.5 + SDF1(p/2.0+SDF1(p/5.0));\n}\n\nfloat dunes1(vec3 p,float distortion){\n    p *= distortion;\n\treturn sin((p.x/3.0+p.y/5.0+p.z/11.0))/distortion;\n}\nfloat dunes(vec3 p,float distortion){\n\treturn dunes1(p,distortion) + dunes1(p.zxy,distortion);\n}\n\nfloat bump(vec3 p3)\n{\n    //add bumps to the planet's surface\n    float distortion = 5.0;\n    p3 *= distortion;\n    return length(sin(p3))/(distortion*5.0);\n}\n\nfloat jungle(vec3 p,float width) {\n    p /= 200.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    float to_return = width +1.2 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n    return to_return;\n}\n\nfloat sceneSDF(vec3 p) {\n    vec3 p0 = p;\n    p /= scale;\n    float jungle1 = jungle(p,(length(p)-planet_size)/100.0);\n    float planet_surface = 1.1+length(p)-planet_size;\n    //float result = SDF1(p/1000.0+SDF1(p/1000.0));\n    float result = min(jungle1,planet_surface);\n    \n    \n    return result*scale;\n}\n\nvec3 sceneSDF_color(vec3 p) {\n    vec3 p0 = p;\n    p /= scale;\n    float jungle1 = jungle(p,(length(p)-planet_size)/300.0);\n    float planet_surface = 1.1+length(p)-planet_size;\n    //float result = SDF1(p/1000.0+SDF1(p/1000.0));\n    float result = min(jungle1,planet_surface);\n    \n    if(result == planet_surface){\n    \treturn surface_color(p0);\n    }\n    else if(result == jungle1){\n    \treturn jungle_color(p0);\n    }\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    //lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(1.6+.6*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = sceneSDF_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 316, 316, 470], [472, 472, 499, 499, 529], [773, 773, 793, 840, 896], [898, 898, 917, 917, 972], [974, 974, 1012, 1012, 1087], [1088, 1088, 1125, 1125, 1184], [1186, 1186, 1207, 1247, 1344], [1346, 1346, 1380, 1380, 1545], [1547, 1547, 1571, 1571, 1856], [1858, 1858, 1887, 1887, 2281], [2283, 2704, 2795, 2795, 3101], [3116, 3370, 3435, 3435, 3567], [3569, 3658, 3687, 3687, 3997], [3999, 4491, 4631, 4653, 5243], [5245, 5615, 5700, 5700, 6404], [6406, 6733, 6782, 6817, 6948], [6950, 6950, 7007, 7007, 7983]], "test": "error"}
{"id": "wllczN", "name": "Flooded Megacity (no shadows)", "author": "ShnitzelKiller", "description": "I am releasing a no-shadows version of the shader. For some reason uncommenting lines 211-231 and line 255 causes the compile time to go out of control on Windows+Nvidia despite only a handful of shadow steps being taken. Someone know why?", "tags": ["voxels", "city", "ruins"], "likes": 18, "viewed": 332, "published": "Public API", "date": "1591696901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FDIST 0.5\n\n#define CELL_SIZE 3.\n#define MINI_CELL_SIZE .15\n#define WINDOW_SIZE vec3(0.5, 0.5, 0.45)\n#define WINDOW_STRIDE 1.\n#define WINDOW_THICKNESS 0.05\n#define ROOM_DEPTH 10.\n#define MAX_VOXELS 200\n#define REFLECTION_VOXELS 20\n#define REFRACTION_VOXELS 10\n#define MAX_HEIGHT 40.\n#define SHADOW_STEPS 10\n#define EPS 0.005\n#define SHADOW_EPS 0.01\n#define WATER_HEIGHT -2.\n#define IOR 1.33\n#define GLASS_IOR 5.\n#define ABSORPTION_RATE vec3(0.7, 0.8, 0.9)\n\n#define WATER_MAT 6\n\n#define MOON_COL vec3(0.4, 0.4, 0.4)\n#define MOON_RADIUS 0.11\n#define AMBIENT_COL vec3(0.1, 0.1, 0.15)\n\n#define SILL_COLOR vec3(1., 0.9, 0.9)\n\n#define PI 3.141593\n\nstruct Hit {\n    float t;\n    int mat;\n    vec3 n;\n    vec3 id;\n};\n\n\nfloat hash( in vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nvec3 tex(in vec3 p) {\n    float fac = 0.5*(hash(p)+hash(p*2.5));\n    float fac2 = smoothstep(0.45, 0.65, fac);\n    return mix(vec3(0.9, 0.8, 0.8), vec3(0.8, 0.7, 0.6), fac2);\n}\n\nvec3 ramp(in float t) {\n\treturn abs(fract(t + vec3(3,2,1)/3.)*6. - 3.) - 1.;\n}\n\nfloat buildings(in vec3 ro) {\n    return -ro.z/2. + 5.*sin(ro.x/2.) * sin(ro.y/2.);\n}\n\nfloat holes(in vec3 id) {\n    id = mod(id+5., 10.)-5.;\n    return step(10., dot(id, id));\n}\n\nfloat cylinders(in vec3 id) {\n    id.xy = mod(id.xy+22.5, 45.)-22.5;\n    float density = step(abs(length(id.xy)-5.), 1.);\n    density = min(density, step(4., length(id.xz-vec2(0., 2.))));\n\treturn density;\n}\n\nfloat voxMap(in vec3 id) {\n    float build1 = min(max(buildings(id), buildings(id*0.25)) + 2.*(hash(id)-0.5), holes(id));\n\tfloat build2 = cylinders(id);\n    return max(build1, build2);\n}\n\nfloat occupancy(in vec3 id) {\n    //return step(0.5, -step(length(id.xz - vec2(0., 4.)), 2.5) + voxMap(id/10.) + 0.25*(voxMap(id)-0.5));\n    return step(0.5, voxMap(id));\n}\n\n\nvec3 cellID(in vec3 ro) {\n    return floor(ro/(2.*CELL_SIZE) + 0.5);\n}\n\nvec3 cellMod(in vec3 ro) {\n    return mod(ro + CELL_SIZE, CELL_SIZE*2.) - CELL_SIZE;\n}\n\nfloat traceCell(in vec3 ro, in vec3 rd) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = CELL_SIZE * abs(dr);\n    \n    vec3 pout =  k - n;\n    return min(pout.x, min(pout.y, pout.z));\n}\n\nfloat traceCell_normal(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    nn = -sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return min(pout.x, min(pout.y, pout.z));\n}\n\nfloat skinnyBox(in vec3 modpos, in vec3 rd, in vec3 id, out vec3 pnear, out vec3 pfar) {\n    vec2 offset = vec2(1., 0.);\n    vec3 occp = vec3(\n        occupancy(id + offset.xyy),\n    \toccupancy(id + offset.yxy),\n    \toccupancy(id + offset.yyx)\n    );\n    vec3 occm = vec3(\n        occupancy(id - offset.xyy),\n    \toccupancy(id - offset.yxy),\n    \toccupancy(id - offset.yyx)\n    );\n    vec3 sig = step(-0.5, sign(rd));\n    vec3 sizesp = mix(vec3(MINI_CELL_SIZE), vec3(CELL_SIZE), occp);\n    vec3 sizesm = -mix(vec3(MINI_CELL_SIZE), vec3(CELL_SIZE), occm);\n    pnear = (mix(sizesp, sizesm, sig) - modpos)/rd;\n    pfar = (mix(sizesm, sizesp, sig) - modpos)/rd;\n    /*vec3 ts[2];\n    ivec3 index = ivec3(step(-0.5, sig));\n    ts[index.x].x = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.x) - modpos.x)/rd.x;\n    ts[index.y].y = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.y) - modpos.y)/rd.y;\n    ts[index.z].z = (mix(MINI_CELL_SIZE, CELL_SIZE, occp.z) - modpos.z)/rd.z;\n    ts[1-index.x].x = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.x) - modpos.x)/rd.x;\n    ts[1-index.y].y = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.y) - modpos.y)/rd.y;\n    ts[1-index.z].z = (-mix(MINI_CELL_SIZE, CELL_SIZE, occm.z) - modpos.z)/rd.z;\n    pnear = ts[0];\n    pfar = ts[1];*/\n    return occp.x + occp.y + occp.z + occm.x + occm.y + occm.z;\n}\n\n\nHit voxtrace(in vec3 ro, in vec3 rd, int iters, bool stopWater) {\n    Hit h;\n    h.t = 0.;\n    // box marching\n    for (int i=0; i<iters; i++) {\n        vec3 pos = ro + rd*h.t;\n        h.id = cellID(pos);\n        if (stopWater && h.id.z < WATER_HEIGHT) {\n            h.mat = WATER_MAT;\n            return h;\n        } else if (h.id.z > MAX_HEIGHT) {\n            return h;\n        }\n        vec3 modpos = cellMod(pos);\n        float maxdist = traceCell(modpos, rd);\n        \n        \n        if (occupancy(h.id) > 0.5) {\n            vec3 pnear, pfar;\n            float neighbors = skinnyBox(modpos, rd, h.id, pnear, pfar);\n            float tnear = max(pnear.x, max(pnear.y, pnear.z));\n            float tfar = min(pfar.x, min(pfar.y, pfar.z));\n            if (neighbors > 0.5 && tfar > tnear && tnear > -2.*EPS) {\n                if (h.id.z >= WATER_HEIGHT) {\n                    if (neighbors < 2.5) {\n                        h.mat = 3;\n                    } else if (neighbors < 4.5) {\n                        h.mat = 1;\n                    } else {\n                        h.mat = 2;\n                    }\n                } else {\n                    h.mat = 5;\n                }\n                h.t += tnear;\n                h.n = -sign(rd) * step(pnear.zxy, pnear.xyz) * step(pnear.yzx, pnear.xyz);\n                return h;\n            }\n    \t}\n        \n        h.t += maxdist + EPS;\n        \n    }\n     \n    h.mat = 0;\n    return h;\n}\n\n/*float shadowtrace(in vec3 ro, in vec3 rd) {\n    float t = 0.;\n    for (int i=0; i<SHADOW_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        vec3 id = cellID(pos);\n        vec3 modpos = cellMod(pos);\n        float maxdist = traceCell(modpos, rd);\n        \n        if (occupancy(id) > 0.5) {\n            vec3 pnear, pfar;\n            skinnyBox(modpos, rd, id, pnear, pfar);\n            float tnear = max(pnear.x, max(pnear.y, pnear.z));\n            float tfar = min(pfar.x, min(pfar.y, pfar.z));\n            if (tfar > tnear && tnear > -SHADOW_EPS) {\n                return 0.;\n            }\n    \t}\n        t += maxdist + EPS;\n    }\n    return 1.;\n}*/\n\n\n\n// Schlick approximation for the Fresnel factor\nfloat schlick_fresnel(float R0, float cos_ang) {\n    return R0 + (1.-R0) * pow(1.-cos_ang, 5.);\n}\n\nvec3 shade(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + h.t * rd;\n    if (h.mat == 0) {\n        // sky color\n        vec3 sky = mix(vec3(0.), vec3(0.1, 0.05, 0.0), 1.-pow(max(0., rd.z), .5));\n        float c = max(0., dot(rd, sundir));\n        float s = sqrt(1.-c*c);\n        vec2 n = normalize(vec2(s, sqrt(MOON_RADIUS*MOON_RADIUS-s*s)));\n        float fac = max(0.,1.-0.5*(1.-n.y));\n        sky = mix(fac * vec3(0.9, 0.95, 1.), sky, smoothstep(MOON_RADIUS-0.01, MOON_RADIUS, s));\n        return sky;\n    } else if (h.mat == 1 || h.mat == 3 || h.mat == 4 || h.mat == 5) {\n        // buildings\n        \n        float fac = max(0., dot(h.n, sundir));\n        //fac *= shadowtrace(ro + SHADOW_EPS*sundir, sundir);\n        float fac2 = abs(dot(h.n, -sundir));\n        vec3 albedo;\n        if (h.mat == 1) albedo = tex(ro);\n        else if (h.mat == 3) {\n            vec3 absmod = abs(cellMod(ro));\n            float coord = max(absmod.x, max(absmod.y, absmod.z))*1.253;\n            float stripe = smoothstep(0.45, 0.55, 2.*abs(fract(coord)-0.5) + 0.5*(hash(ro*2.)-0.5));\n            albedo = mix(1.-tex(ro), 0.5*tex(ro*2.), stripe);\n        }\n        else if (h.mat == 4) albedo = SILL_COLOR;\n        else if (h.mat == 5) albedo = vec3(1.); //underwater\n        return albedo * (MOON_COL * fac + AMBIENT_COL * fac2);\n    } else return vec3(1., 0., 1.);\n}\n\nvec3 winmod(in vec3 ro) {\n    return (fract(ro/(WINDOW_STRIDE*2.)+0.5)-0.5)*2.*WINDOW_STRIDE;\n}\n\nvec3 winID(in vec3 ro) {\n    return floor(ro/(WINDOW_STRIDE*2.)+0.5);\n}\n\nfloat win_mask(in vec3 ro, in vec3 n, float margin) {\n    vec3 win = step(1.-(WINDOW_SIZE + margin)/WINDOW_STRIDE, abs(fract(ro/(WINDOW_STRIDE*2.))-0.5)*2.);\n    return win.x * win.y * win.z * step(abs(n.z), 0.2) * step(WATER_HEIGHT * CELL_SIZE*2., ro.z);\n}\n\nvec3 shade_interior(in vec3 eye, in vec3 rd, in vec3 id, in vec3 sundir) {\n    vec3 n;\n    float t = traceCell_normal(eye, rd, vec3(WINDOW_THICKNESS,WINDOW_SIZE.y, WINDOW_SIZE.z), n);\n    vec3 albedo;\n    vec3 ro = eye + rd * t;\n    if (n.x > 0.5) {\n        t = traceCell_normal(eye, rd, vec3(ROOM_DEPTH, WINDOW_STRIDE, WINDOW_STRIDE), n);\n    \tro = eye + rd * t;\n        float hass = hash(id);\n        vec3 tilecolor = 0.8 + 0.2 * (ramp(hass)-0.5);\n        float ang = hass * PI * .5;\n        float sr = sin(ang);\n        float cr = cos(ang);\n        mat2 rot = mat2(cr, -sr, sr, cr);\n        vec2 tile = step(mod(rot*ro.xy, hass), vec2(0.5*(1.-hass)));\n        float tilefac = abs(tile.x-tile.y);\n        vec3 floorcol = mix(vec3(0.5+0.5*fract(hass*145.7)), tilecolor, tilefac);\n        vec3 wallcol = 0.95+0.05*(ramp(1.-hass)-0.5);\n        albedo = mix(wallcol, floorcol, step(0.1, n.z));\n    } else {\n        albedo = SILL_COLOR;\n    }\n    vec3 lightpos = vec3(-0.25*ROOM_DEPTH, 0., WINDOW_STRIDE*0.95);\n    vec3 l = lightpos - ro;\n    float ll = length(l);\n    float fac = max(0.25, dot(n, l)/(ll*ll));\n    \n    return albedo * fac * 3. * hash(id);\n}\n\nvec3 shade_fake(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + rd * h.t;\n    if (h.mat == 2) {\n        // add in fake windows without reflections\n        if (win_mask(ro, h.n, 0.) > 0.5) {\n            vec3 id = winID(ro);\n            vec3 row = winmod(ro);\n            mat2 rot = mat2(h.n.x, -h.n.y, h.n.y, h.n.x);\n            vec3 ro2 = vec3(rot * row.xy, row.z);\n            vec3 rd2 = vec3(rot * rd.xy, rd.z);\n            sundir = vec3(rot * sundir.xy, sundir.z);\n            return shade_interior(ro2, rd2, id, sundir);\n        } else if (win_mask(ro, h.n, 0.2) > 0.5) {\n            h.mat = 4;\n\t\t\treturn shade(eye, rd, h, sundir);\n        } else {\n            h.mat = 1;\n            return shade(eye, rd, h, sundir);\n        }\n    } else if (h.mat == WATER_MAT) {\n        // water refractions\n        vec3 rdr = refract(rd, h.n, 1./1.33);\n        Hit h3 = voxtrace(ro, rdr, REFRACTION_VOXELS, false);\n        vec3 refrcol = shade(ro, rdr, h3, sundir);\n        refrcol *= pow(ABSORPTION_RATE, vec3(h3.t));\n        return refrcol;\n    } else {\n        return shade(eye, rd, h, sundir);\n    }\n}\n\n// shade materials which require reflections\nvec3 shade_refl(in vec3 eye, in vec3 rd, in Hit h, in vec3 sundir) {\n    vec3 ro = eye + h.t * rd;\n    if (h.mat == 2) {\n        // windows\n        vec3 basecolor = shade_fake(eye, rd, h, sundir);\n        if (win_mask(ro, h.n, 0.) > 0.5) {\n            vec3 rdr = reflect(rd, h.n);\n            Hit h2 = voxtrace(ro, rdr, REFLECTION_VOXELS, true);\n            vec3 reflcol = shade_fake(ro, rdr, h2, sundir);\n            float R0 = (GLASS_IOR-1.)/(GLASS_IOR+1.);\n            float fresnel = schlick_fresnel(R0, dot(h.n, rdr));\n            return mix(basecolor, reflcol, fresnel);\n        } else {\n            return basecolor;\n        }\n    } else if (h.mat == WATER_MAT) {\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        float fresnel = schlick_fresnel(R0, -rd.z);\n        \n        vec2 disp = 0.01 * vec2(cos(ro.x*0.5 + 0.25*ro.y + 10.*iTime), sin(ro.x +2.*ro.y));\n        vec3 wn = normalize(vec3(disp, 1.));\n        h.n = wn;\n        vec3 refrcol = shade_fake(eye, rd, h, sundir);\n        \n     \t// water reflections\n         \n        vec3 rdr = reflect(rd, wn);\n        Hit h2 = voxtrace(ro, rdr, REFLECTION_VOXELS, false);\n        vec3 reflcol = shade_fake(ro, rdr, h2, sundir);\n        \n        return mix(refrcol, reflcol, fresnel);\n    } else {\n        return shade_fake(eye, rd, h, sundir);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseY = iMouse.y < 1. ? 0. : (0.5-iMouse.y/iResolution.y) * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 eye = vec3(0., iTime * 30., 20.1);\n    vec3 w = vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), -sin(mouseY));\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(FDIST*w + uv.x*u + uv.y*v);\n    \n    Hit h = voxtrace(eye, rd, MAX_VOXELS, true);\n    vec3 ro = eye + h.t * rd;\n    vec3 sundir = normalize(vec3(1., -2., 1.2));\n\n    vec3 col = shade_refl(eye, rd, h, sundir);\n    fragColor = vec4(pow(col, vec3(0.75)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllczN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[718, 718, 743, 864, 1687], [1689, 1689, 1710, 1710, 1865], [1867, 1867, 1890, 1890, 1945], [1947, 1947, 1976, 1976, 2032], [2034, 2034, 2059, 2059, 2125], [2127, 2127, 2156, 2156, 2333], [2335, 2335, 2361, 2361, 2521], [2523, 2523, 2552, 2659, 2695], [2698, 2698, 2723, 2723, 2768], [2770, 2770, 2796, 2796, 2856], [2858, 2858, 2899, 2899, 3053], [3055, 3055, 3127, 3127, 3347], [3349, 3349, 3437, 3437, 4648], [4651, 4651, 4716, 4716, 6092], [6750, 6798, 6846, 6846, 6895], [6897, 6897, 6960, 6960, 8276], [8278, 8278, 8303, 8303, 8373], [8375, 8375, 8399, 8399, 8446], [8448, 8448, 8501, 8501, 8705], [8707, 8707, 8781, 8781, 9862], [9864, 9864, 9932, 9932, 10985], [10987, 11032, 11100, 11100, 12351], [12353, 12353, 12410, 12410, 13121]], "test": "timeout"}
{"id": "WllczX", "name": "U.F.B(Unidentified Flying Boze)", "author": "kaiware007", "description": "\"I saw it! The flying Boze!\"", "tags": ["raymarching"], "likes": 9, "viewed": 107, "published": "Public", "date": "1592649587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG1 6.0\n#define MAT_BG2 7.0\n#define MAT_CS 8.0\n\n#define AA 1\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\nvec2 opI( vec2 d1, vec2 d2 )\n{ \n    return (d1.x > d2.x) ? d1 : d2;\n}\n\nvec2 opPaint(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : vec2(d1.x, d2.y);\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float sc)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0 / sc);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.035, 0.01 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float sc)\n{    \n    float x = 0.05;\n    float z = -0.175;\n    float r = 0.0045 * sc;\n    float rb1 = 100. / sc;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, rb1), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -rb1), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float sc)\n{\n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.1) * sc, vec3(0.0175,0.0025,0.1) * sc, 0.001*sc);\n}\n\nvec2 sdBoze(vec3 p, float sc, float ms)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp, sc);\n    d = opUnion(d, d2);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(d4, MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(mxp, sc);\n    vec2 cheep = vec2(d7, MAT_CHEEP);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp, sc);\n    eye.x = opUnion(eye.x, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    //head = opPaint(head, eye);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    //result = opPaint(result, cheep);\n    \n    return result;\n}\n\nvec2 sdCapsuleBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nvec2 sdUFBoze(vec3 p, float sc, float ms)\n{\n    return opU(sdBoze(p, sc, ms), vec2(sdCappedCone(p + vec3(0, 0.08 * sc, 0), 0.06 * sc, 0.5 * sc, 0.25 * sc), MAT_CS));\n}\n\nvec2 sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(MAX_DIST);\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    float rt = iTime * 10.;\n    \n    //result = sdBoze(rotate(p, M_PI, vec3(0,1,0)) + vec3(0,0.5,0),10., 1.0); // test\n    \n    p = rotate(p, M_PI-rt, vec3(0,1,0));\n    p = rotate(p, rt, normalize(vec3(cos(rt) * 0.2,1.0,sin(rt) * 0.2)));\n    \n    float defspd = 1.0;\n    float quick = 10.;\n    float spd = defspd * quick;\n    float rspd = 1./spd;\n    float ys = 1.3;\n    float rad = M_PI2 / 8.;\n    \n\n    vec3 r = vec3(5,2.0,1);\n    vec3 offset3 = noised(vec2(-iTime * rad * defspd, 0.))*r;\n    \n    float mt = mod(iTime, defspd * 2.);\n    if(mt >= defspd) \n    {\n        mt -= defspd;\n        float tt = (iTime - defspd) * spd;\n        float i = floor(tt)*rspd;\n    \tfloat t = -i * rad * spd;\n    \tfloat t2 = t - rad;\n\n        vec3 offset = mt <= rspd ? offset3 : hash31(t) * r - r * 0.5;\n        vec3 offset2 = mt >= (defspd - rspd) ? mix(hash31(t)*r - r * 0.5, offset3, fract(tt)) : mix(offset, hash31(t2)*r - r * 0.5, fract(tt));\n        result =  opU(result, sdCapsuleUFBoze(p, -offset, -offset2, 1.0, 1.0));\n    }else{\n    \tresult = opU(result, sdUFBoze(p + offset3, 1.0, 1.0));    \n    }\n    \n\treturn result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).x - map(position - epsilon.xyy).x,\n          map(position + epsilon.yxy).x - map(position - epsilon.yxy).x,\n          map(position + epsilon.yyx).x - map(position - epsilon.yyx).x);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).x;\n        if (h < 0.0001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec3 traceRay(in vec3 origin, in vec3 direction) {\n    float material = 0.0;\n\n    float t = 0.02;\n    \n    vec3 pos;\n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = origin + direction * t;\n        vec2 hit = map(pos);\n\n        t += hit.x;\n        material = hit.y;\n\n        count++;\n        if (hit.x <= 0.0001 || hit.x >= MAX_DIST) {\n        \tbreak;\n        }\n    }\n    /*\n    if (t >= MAX_DIST) {\n        t = MAX_DIST;\n        material = 0.0;        \n    }\n*/\n    return vec3(t, material, count);\n}\n\nvec3 subsurfaceTrace(vec3 origin, vec3 direction) {\n    vec3 density = pow(vec3(.7,.5,.4),vec3(.4));\n\tconst float confidence = .01;\n\tvec3 visibility = vec3(1.0);\n\t\n\tfloat lastVal = map(origin).x;\n\tfloat soft = 0.0;\n\tfor ( int i=1; i < 50; i++ )\n\t{\n\t\tif ( visibility.x < confidence )\n\t\t\tcontinue;\n\t\t\n\t\tfloat val = map(origin).x;\n\n\t\tvec3 softened = pow(density,vec3(smoothstep(soft,-soft,val)));\n//tweak this to create soft shadows, by expanding with each step (linearly)\n\t\t\n\t\tif ( (val-soft)*lastVal < 0.0 )\n\t\t{\n\t\t\t// approximate position of the surface\n\t\t\tfloat transition = -min(val-soft,lastVal)/abs(val-soft-lastVal);\n\t\t\tvisibility *= pow(softened,vec3(transition));\n\t\t}\n\t\telse if ( val-soft < 0.0 )\n\t\t{\n\t\t\tvisibility *= softened;\n\t\t}\n\n\t\tsoft += .1;\n\t\tlastVal = val+soft;\n\t\torigin += direction*.4;\n\t}\n\t\n\treturn visibility;\n}\n\nvec4 subsurface(vec3 o, vec3 dir){\n    vec3 p = o;\n    float e = 0.0;\n    for(int i = 0; i < 100; ++i){\n        float d = map(p).x;\n        e += -d;\n        \n        if(d > -0.00001)\n            break;\n\n        p -= d*dir;\n    }\n    \n    return vec4(p, e);\n}\n\nvec3 materialColor(vec3 pos, vec3 mat, out float roughness, out float metalness)\n{\n    vec3 col = vec3(0);\n    \n    //float t = saturate(sin(iTime * 2.5)*0.25+0.25);\n    float m = 0.0;\n    //float m = mix(0.00001, 1., sin(iTime * 5.)*0.5+0.5);\n    //float r = mix(0.00001, 1., cos(iTime * 5.)*0.5+0.5);\n    float r = 0.3;\n\tif(mat.y == MAT_BLACK) {\n        col = vec3(0.1);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_FACE) {\n        col = vec3(1.0, 0.7, 0.6);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_BROW) {\n        col = vec3(1.0, 0, 0.1);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_CHEEP) {\n        col = vec3(1.0, 0.3, 0.4);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_BG1) {\n        vec3 index = floor(pos * 10.+ 0.5);\n\n        //float f = noise(index + iTime * 2.8);\n        //col = mix(vec3(1), vec3(0), f);\n        col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.1;\n        metalness = 0.0;\n    } else if(mat.y == MAT_BG2) {\n        vec3 index = floor(pos * 50.+ 0.5);\n\t\tfloat f = noise(index + iTime * vec3(2.8,-0.8,0.79));\n        //col = sinebow(f);\n        col = vec3(1,0.5,0.2);\n        //col = vec3(1.0,0,0) + vec3(-1,0,1) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.1;\n        metalness = 0.0;\n    } else if(mat.y == MAT_CS) {\n        col = vec3(0.9);\n        //col = vec3(1.0,0,0) + vec3(-1,0,1) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.1;\n        metalness = 0.8;\n    }\n    \n    return col;\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    //return vec3(0);\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, vec3 albedo, float roughness, float metallic) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 indirectHit = traceRay(pos, r);\n    vec3 indirectSpecular = vec3(0.);\n    \n    if (indirectHit.y > 0.0) {\n        vec3 indirectPosition = pos + indirectHit.x * r;        \n\t\tfloat reflength = length(indirectPosition - pos);\n        \n        indirectSpecular = materialColor(indirectPosition, indirectHit, roughness, metallic);\n\t\t\n        if(reflength >= 0.){\n            //vec3 sky = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        \tvec3 sky = 0.8 * SkyColor(r) * metallic;\n\n        \t// fog\n        \tindirectSpecular = mix(indirectSpecular, sky, 1.0 - saturate(exp2(-0.1 * reflength * reflength)));\n        }\n\t\t\n    }\n\t\n    // indirect contribution\n    vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n    vec3 specularColor = f0 * dfg.x + dfg.y;\n\tvec3 ibl = diffuseColor * indirectDiffuse * 1.0 + indirectSpecular * specularColor;\n    \n    color += ibl * indirectIntensity;\n\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 ro, vec3 p, vec3 ray, vec3 mat, vec2 uv)\n{\n    vec3 col = vec3(0);\n    vec3 sky = SkyColor(ray);\n    \n    float t = iTime * 1.0 + M_PI * 1.5;\n    float r = 2.0;\n    vec3 lightPos = vec3(0.6, 0.8, -0.0);\n    \n    if (mat.x >= MAX_DIST) {\n        col = sky;\n    } else {\n        if(mat.y > 0.0)\n        {\n            vec3 nor = norm(p);\n            float roughness, metalness;\n            col = materialColor(p, mat, roughness, metalness);\n\n            vec3 result = vec3(0.);\n            result = calcAmb(p, ray, nor, lightPos, vec3(0.98, 0.92, 0.89) * 3.0, col, roughness, metalness);\n            col = result;\n        }\n    }\n    \n    // Exponential distance fog\n    col = mix(col, 0.8 * sky, 1.0 - saturate(exp2(400.0-mat.x * mat.x)));\n\n    // Glow\n\tcol += (sinebow(iTime * 10.) +vec3(0.1)) * pow(saturate((mat.z * 3. - 10.) / float(MAX_MARCH)), 4.); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    vec3 mat = traceRay(p, ray);\n    \n    pos = p + mat.x * ray;\n    return materialize(p, pos, ray, mat, uv);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float t = iTime * M_PI * 0.2;\n        float y = 0.05;\n        float r = 7.5;\n        vec3 ro = vec3(sin(t) * 0.25, y + cos(t * 2.13 + 3.5354) * 0.25, -r);\n        vec3 ta = vec3(0., y, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[698, 698, 721, 721, 794], [796, 796, 817, 817, 887], [889, 889, 912, 912, 991], [994, 994, 1016, 1016, 1433], [1436, 1436, 1497, 1497, 1635], [1638, 1698, 1724, 1724, 2590], [2592, 2780, 2802, 2802, 2935], [2937, 3036, 3072, 3072, 3100], [3102, 3102, 3148, 3148, 3204], [3206, 3206, 3256, 3256, 3374], [3376, 3376, 3413, 3413, 3502], [3504, 3504, 3574, 3574, 3708], [3710, 3710, 3774, 3774, 3891], [3893, 3893, 3926, 3952, 3983], [3985, 3985, 4010, 4010, 4029], [4030, 4030, 4055, 4055, 4074], [4075, 4075, 4111, 4111, 4139], [4141, 4141, 4200, 4200, 4513], [4515, 4572, 4600, 4600, 4633], [4635, 4635, 4665, 4665, 4717], [4719, 4719, 4759, 4759, 4895], [4897, 4897, 4927, 4927, 4966], [4968, 4968, 5000, 5000, 5050], [5065, 5116, 5153, 5153, 5175], [5177, 5177, 5220, 5220, 5242], [5244, 5244, 5288, 5288, 5309], [5311, 5311, 5363, 5363, 5462], [5465, 5465, 5510, 5510, 5939], [5942, 5942, 5977, 5977, 6125], [6127, 6127, 6161, 6161, 6337], [6339, 6339, 6370, 6370, 6419], [6421, 6421, 6456, 6456, 6491], [6493, 6493, 6530, 6530, 6565], [6567, 6738, 6823, 6823, 6900], [6902, 6945, 7020, 7020, 7412], [7669, 7669, 7700, 7700, 7854], [7880, 7880, 7912, 7912, 8025], [8027, 8027, 8070, 8070, 8302], [8304, 8304, 8337, 8337, 8949], [8951, 8951, 8986, 8986, 9137], [9139, 9139, 9180, 9180, 10241], [10243, 10243, 10307, 10307, 10429], [10431, 10431, 10474, 10474, 10598], [10600, 10600, 10666, 10666, 10884], [11104, 11104, 11122, 11122, 12311], [12813, 12813, 12862, 12862, 13160], [13162, 13162, 13212, 13212, 13689], [13691, 13691, 13742, 13742, 14518], [14520, 14520, 14554, 14554, 14778], [14780, 14780, 14862, 14862, 16455], [16722, 16790, 16818, 16818, 16945], [16947, 17037, 17100, 17100, 17306], [17308, 17374, 17438, 17608, 18239], [18241, 18241, 18267, 18267, 18666], [18842, 18842, 18863, 18863, 18911], [18913, 18913, 18974, 19059, 19258], [19260, 19260, 19333, 19425, 19625], [19627, 19627, 19669, 19749, 19803], [19805, 19805, 19854, 19854, 19902], [19904, 19904, 19977, 20034, 20249], [20251, 20251, 20271, 20271, 20296], [20483, 20483, 20533, 20617, 20975], [20977, 20977, 21032, 21089, 21349], [21351, 21351, 21479, 21479, 23519], [23723, 23723, 23756, 23812, 23998], [24000, 24000, 24039, 24039, 24082], [24084, 24100, 24173, 24173, 24257], [24259, 24385, 24455, 24455, 24738], [24740, 24740, 24840, 24840, 25630], [25632, 25632, 25696, 25696, 26636], [26638, 26638, 26678, 26678, 26805], [26807, 26807, 26849, 26849, 27027]], "test": "timeout"}
{"id": "wllyD4", "name": "1st camera", "author": "bipinoli", "description": "Following tutorial from \"The art of code\"", "tags": ["learningshaders"], "likes": 2, "viewed": 34, "published": "Public", "date": "1592137035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float point2rayDist(vec3 ro, vec3 rd, vec3 p) {\n \treturn length(cross(p-ro, rd))/length(rd);   \n}\n\nfloat drawPoint(vec3 ro, vec3 rd, vec3 p) {\n \tfloat d = point2rayDist(ro, rd, p);\n    d = smoothstep(.04, .041, d); \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n      \n    // ray\n    float zoom = 3.;\n    vec3 ro = vec3(cos(t) + 2., sin(t) + 2., -zoom -4. - 2.*sin(t));\n    \n    vec3 lookat = vec3(.5);\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(f, vec3(0., 1., 0.)));\n    vec3 u = cross(r, f);\n    \n    vec3 c = ro + zoom * f;\n    vec3 i = c - uv.x * r + uv.y * u;\n    vec3 rd = i - ro;\n    //vec3 i = vec3(uv.x, uv.y, -4);  \n    //vec3 rd = uv.x * r + uv.y * u - 4.*f;\n    \n    // cube points in 3d\n    float d = 1.;\n    d *= drawPoint(ro, rd, vec3(0., 0., 0.)); \n    d *= drawPoint(ro, rd, vec3(0., 0., 1.));\n    d *= drawPoint(ro, rd, vec3(0., 1., 0.));\n    d *= drawPoint(ro, rd, vec3(0., 1., 1.));\n    d *= drawPoint(ro, rd, vec3(1., 0., 0.));\n    d *= drawPoint(ro, rd, vec3(1., 0., 1.));\n    d *= drawPoint(ro, rd, vec3(1., 1., 0.));\n    d *= drawPoint(ro, rd, vec3(1., 1., 1.));\n    \n    d *= drawPoint(ro, rd, vec3(0.5, 0., 0.));\n    d *= drawPoint(ro, rd, vec3(0.5, 0., 1.));\n    d *= drawPoint(ro, rd, vec3(0., 0., .5));\n    d *= drawPoint(ro, rd, vec3(1., 0., .5));\n    d *= drawPoint(ro, rd, vec3(.5, 0., .5));\n    \n    d *= drawPoint(ro, rd, vec3(0.5, 1., 0.));\n    d *= drawPoint(ro, rd, vec3(0.5, 1., 1.));\n    d *= drawPoint(ro, rd, vec3(0., 1., .5));\n    d *= drawPoint(ro, rd, vec3(1., 1., .5));\n    d *= drawPoint(ro, rd, vec3(.5, 1., .5));\n    \n    \n    vec3 col = vec3(d);\n\tcol *= vec3(1.0, .5, .5);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 97], [99, 99, 142, 142, 231], [233, 233, 290, 290, 1830]], "test": "timeout"}
{"id": "wllyDB", "name": "Crystal Boze", "author": "kaiware007", "description": "\"It's not about that, it's about Ray Marching!\"", "tags": ["raymarching", "refract"], "likes": 2, "viewed": 77, "published": "Public", "date": "1593346823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n#define AA 1\n    \nstruct surface {\n\tfloat dist;\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec3(0,1,1), \t\t vec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec3(0.),        vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec3(1,0.7,0.6), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec3(1,0,0.1),   vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec3(1,0.3,0.4), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    vec3 index = floor(pos * 10. + 0.5);\n    vec3 col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n#define SURF_CS(d) \t\t(surface(d, vec3(0.9), vec3(0,0,0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec3(0), vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec3(0,1,0), vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec3(0,0,1), vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec3 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float sc)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0 / sc);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.035, 0.01 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float sc)\n{    \n    float x = 0.05;\n    float z = -0.175;\n    float r = 0.0045 * sc;\n    float rb1 = 100. / sc;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, rb1), vec3(-0.005,0.0,0.0) * sc, vec3(0.005, 0., 0.001) * sc, r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -rb1), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float sc)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02) * sc, -6.5);\n    //p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    //p = opBendXZ(p + vec3(0.03, 0, 0) * sc, 0.1);\n    //p = opBendXZ(p + vec3(0.015, 0, 0.1) * sc, 2.5 * sc);\n    //p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(-0.2,0.8,0));\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11) * sc, vec3(0.003,0.0025,0.05) * sc, 0.001*sc);\n}\n\nsurface sdBoze(vec3 p, float sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp, sc);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp, sc);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp, sc);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n            \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, float sc, float ms)\n{\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sc, 0), 0.06 * sc, 0.5 * sc, 0.25 * sc));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, float sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(MAX_DIST);\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float t = iTime * 0.2 * M_PI2;\n\n    p = rotate(p, M_PI, vec3(0,1,0));\n    //vec3 q = opRep(p, vec3(0.5, 5., 0.5));\n    \n    //result = SURF_SPHERE(sdSphere(p - vec3(0,0.125,0), 0.2));\n    surface boze1 = sdBoze(rotate(p + vec3(0.5, 0,0), -M_PI*0.5, vec3(0,1,0)), 1., sin(t*3.)*0.5 + 0.5);\n    //surface boze1 = sdBoze(rotate(p + vec3(cos(t)*0.5, 0, sin(t)*0.5), t-M_PI*0.5, vec3(0,1,0)), 1.0, sin(t*3.)*0.5 + 0.5);\n    //surface boze1 = sdBoze(p + vec3(0.5,0,0), 1.0, sin(t*3.)*0.5 + 0.5);\n    //boze1.albedo = sinebow(t);\n    //boze1.metalness = 0.2;\n    \n    surface boze2 = sdBoze(p, 1.25, cos(t*3.8)*0.5 + 0.5);\n    //surface boze2 = SURF_SPHERE(sdSphere(p - vec3(0,0.125,0), 0.2));\n    //surface boze2 = SURF_SPHERE(sdRoundBox(p - vec3(0,0.125,0), vec3(0.25), 0.01));\n    //surface boze2 = SURF_SPHERE(sdBox(p - vec3(0,0.125,0), vec3(0.2)));\n    //surface boze2 = SURF_SPHERE(sdTorus(rotate(p - vec3(0,0.125,0), t, vec3(0.5,0.5,0)), vec2(0.2,0.1)));\n    \n    boze2.isTransparent = true;\n    boze2.refractPower = 1.53;\n    //boze2.refractPower = 1.;\n\tboze2.roughness = 0.2;\n    boze2.metalness = 0.8;\n    boze2.albedo = vec3(0,0.21,0.2);\n    \n   \n    //boze2.dist = mix(boze2.dist, sdSphere(p - vec3(0,0.125,0), 0.2), saturate(sin(t*2.)*2.));\n    \n    const float tt = -M_PI*0.25;\n    //surface boze3 = sdBoze(p + vec3(cos(t*0.8)*-0.5, 0, sin(t*0.8)*-0.5), 0.5, cos(t*2.98)*0.5 + 0.5);\n    //surface boze3 = sdBoze(rotate(p + vec3(cos(tt+M_PI)*0.5, 0, sin(tt+M_PI)*0.5), tt+M_PI-M_PI*0.5, vec3(0,1,0)), 1., cos(t*2.98)*0.5 + 0.5);\n    //surface boze3 = sdBoze(rotate(p - vec3(0.5, 0,0.5), M_PI*0.25, vec3(0,1,0)), 1., sin(t*2.98)*0.5 + 0.5);\n    //surface boze3 = SURF_CUBE(sdRoundBox(p + vec3(cos(tt+M_PI)*0.5, 0, sin(tt+M_PI)*0.5), vec3(0.25), 0.01));\n    surface boze3 = SURF_SPHERE(sdSphere(p + vec3(cos(tt+M_PI)*0.5, -0.1, sin(tt+M_PI)*0.5), 0.2));\n    //boze3.metalness = 0.8;\n\n    //result = opU(boze1, boze2);\n    //result = boze2;\n    result = opU(opU(boze1, boze2), boze3);\n    //result = sdBoze(p, 1., sin(t*3.)*0.5 + 0.5);\n    //result = opSU(sdBoze(p + vec3(cos(t)*-0.05-0.05,0.05,0), 1., cos(t * 3.8)*0.5+0.5), result, 0.01);\n\t//result = opU(result, SURF_CUBE(sdRoundBox(p - vec3(0.5,0.125,0), vec3(0.25), 0.01)));\n    \n    //result = opU(result, SURF_SPHERE2(sdSphere(p - vec3(-0.5,0.125,0), 0.2)));\n    \n    // background\n    //vec2 bg1 = vec2(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)), MAT_BG1);\n    //surface bg1 = SURF_BG1(sdPlane(p + vec3(0., 0.15, 0.), vec4(0,1,0,0)), p);\n    surface bg1 = SURF_BG1(sdBox(p + vec3(0., 1.15, 0.), vec3(0.75,1.0,0.75)), p);\n    result = opU(result, bg1);\n    /*\n    vec3 index = floor(p * 2. + 0.5);\n    float rnd = hash13(vec3(index.x,0,index.z));\n    vec3 rnd3 = hash33(vec3(index.x,0,index.z));\n    \n    //vec3 q = opRep(p, vec3(0.5, 5., 0.5));\n    q = TwistY(q, 2.*M_PI2);\n    q = rotate(q, t+rnd*M_PI2, vec3(0,1,0));\n    q += vec3(0.02,0,0.02);\n    float w = 0.025;\n    //vec3 col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    vec3 col = sinebow(rnd + iTime * 3.5) * saturate(noise(rnd3 + vec3(iTime * 10.5,0,0))*2.5-1.);\n    surface bg2 = surface(sdRoundBox(q, vec3(w,5.,w), 0.01), vec3(0), saturate((sin(q.y * 100.-t*2.)*10.0-5.))*col, 0.1, 0.8, 0);\n    \n    result = opU(result, opSU(bg1, bg2, 0.1));\n    */\n    \n\treturn result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction) {\n    float material = 0.0;\n\n    float t = 0.0;\n    \n    vec3 pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = abs(hit.dist);\n        t += d;\n        pos = origin + direction * t;\n\n        count++;\n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n    }\n\n    if(d <= EPS){\n    \treturn surface(t, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n    \treturn surface(t, vec3(0), hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0,0,0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // test 2 Grid\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //uv += vec2(10.);\n    //uv = abs(uv);\n    /*\n    // plexus\n    vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    // test 3 sky\n    vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    \n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 ro, vec3 p, vec3 ray, surface mat, vec2 uv)\n{\n    vec3 col = vec3(0,1,0);\n    vec3 sky = SkyColor(ray);\n    \n    //float t = iTime * 1.0 + M_PI * 1.5;\n    //float r = 2.0;\n    vec3 lightPos = vec3(-0.6, 0.8, -0.5);\n    vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n\n    if (mat.dist >= MAX_DIST) {\n        col = sky;\n    } else {\n        vec3 result = vec3(0.);\n        vec3 nor = norm(p);\n\t\tvec3 sky = SkyColor(ray);\n        \n        col = calcAmb(p, ray, nor, lightPos, lightColor, mat);\n        col = mix(col, sky, 1.0 - saturate(exp2(8.0 - mat.dist * mat.dist)));\n        float metalness = mat.metalness;\n        \n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 5; i++)\n            {\n                vec3 nor = norm(p);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    p = p - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    p = p + orientingNormal * OFFSET;\n                }\n\n\n                surface indirectHit = traceRay(p, ray);\n\n                p = p + indirectHit.dist * ray;\n                //float reflength = length(indirectPosition - p);\n                //p = indirectPosition;\n                mat = indirectHit;\n\n                result = calcAmb(p, ray, nor, lightPos, lightColor, mat);\n\n                vec3 sky = SkyColor(ray);\n                \n                // Exponential distance fog\n                result = mix(result, sky, 1.0 - saturate(exp2(4.0 - indirectHit.dist * indirectHit.dist)));\n\n                col += result * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\tif(!mat.isHit)\n                    break;\n\n            }\n        }\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray);\n    \n    pos = p + mat.dist * ray;\n    return materialize(p, pos, ray, mat, uv);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float t = iTime * M_PI2 * -0.05;\n        //float t = 0.;\n        //float y = sin(t * 2.5) * 0.125-0.0;\n        float y = sin(t * 2.5) * 0.1 + 0.075;\n        //float y = 2.0;\n        //float r = 2. + sin(t * 0.5)*0.5;\n        float r = 1.;\n        float theta = t + RAD90 + RAD90*0.25;\n        //float theta = RAD90;\n        //float theta = t + RAD90;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        vec3 ro = vec3(cos(theta) * r, y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0.075, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllyDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1292, 1292, 1329, 1329, 1539], [1894, 1894, 1917, 1917, 1990], [1992, 1992, 2013, 2013, 2083], [2085, 2085, 2108, 2108, 2187], [2190, 2190, 2212, 2212, 2629], [2632, 2632, 2693, 2693, 2831], [2834, 2894, 2920, 2920, 3786], [3788, 3976, 3999, 3999, 4102], [4104, 4124, 4145, 4145, 4279], [4281, 4300, 4322, 4322, 4455], [4457, 4477, 4499, 4499, 4624], [4725, 4725, 4761, 4761, 4789], [4791, 4791, 4837, 4837, 4893], [4895, 4895, 4926, 4926, 5017], [5019, 5019, 5069, 5069, 5187], [5189, 5189, 5226, 5226, 5315], [5317, 5317, 5387, 5387, 5521], [5523, 5523, 5587, 5587, 5704], [5706, 5706, 5739, 5765, 5796], [5798, 5798, 5823, 5823, 5842], [5843, 5843, 5868, 5868, 5887], [5888, 5888, 5924, 5924, 5952], [5954, 5954, 6013, 6013, 6326], [6328, 6328, 6361, 6361, 6426], [6428, 6452, 6504, 6504, 6623], [6625, 6682, 6719, 6760, 6843], [6845, 6845, 6884, 7056, 7165], [7167, 7167, 7216, 7216, 7775], [7777, 7777, 7816, 7862, 7947], [7949, 7949, 7990, 8100, 8214], [8229, 8280, 8317, 8317, 8339], [8341, 8341, 8384, 8384, 8406], [8408, 8408, 8452, 8452, 8473], [8475, 8475, 8527, 8527, 8626], [8629, 8629, 8674, 8674, 9103], [9105, 9105, 9126, 9126, 9194], [9196, 9196, 9236, 9236, 9361], [9364, 9364, 9399, 9399, 9547], [9549, 9549, 9583, 9583, 9759], [9761, 9761, 9792, 9792, 9841], [9843, 9843, 9878, 9878, 9913], [9915, 9915, 9952, 9952, 9987], [9989, 10160, 10245, 10245, 10322], [10324, 10367, 10442, 10442, 10834], [11091, 11091, 11122, 11122, 11276], [11302, 11302, 11334, 11334, 11447], [11449, 11449, 11481, 11481, 11621], [11623, 11623, 11666, 11666, 11912], [11914, 11914, 11947, 11947, 12565], [12567, 12567, 12602, 12602, 13012], [13014, 13014, 13058, 13058, 14059], [14061, 14061, 14128, 14128, 14250], [14252, 14252, 14298, 14298, 14442], [14444, 14444, 14513, 14513, 14731], [14951, 14951, 14972, 14972, 18406], [18926, 18926, 18975, 18975, 19273], [19275, 19275, 19328, 19328, 19986], [20252, 20320, 20348, 20348, 20475], [20477, 20567, 20630, 20630, 20836], [20838, 20904, 20968, 21138, 21769], [21771, 21771, 21808, 21808, 21898], [21900, 21900, 21926, 21926, 23454], [23630, 23630, 23651, 23651, 23699], [23701, 23701, 23762, 23847, 24046], [24048, 24048, 24121, 24213, 24413], [24415, 24415, 24457, 24537, 24591], [24593, 24593, 24642, 24642, 24690], [24692, 24692, 24765, 24822, 25037], [25039, 25039, 25059, 25059, 25084], [25271, 25271, 25321, 25405, 25763], [25765, 25765, 25820, 25877, 26137], [26139, 26139, 26235, 26235, 27622], [27826, 27826, 27859, 27915, 28101], [28103, 28103, 28142, 28142, 28185], [28187, 28203, 28276, 28276, 28360], [28362, 28488, 28558, 28558, 28841], [28843, 28843, 28943, 28943, 29736], [29738, 29738, 29805, 29805, 32381], [32383, 32383, 32423, 32423, 32556], [32558, 32558, 32600, 32600, 32778]], "test": "timeout"}
{"id": "WllyR7", "name": "Kaleidoscope light", "author": "TAKUSAKU", "description": "Kaleidoscope", "tags": ["light", "kaleidoscope"], "likes": 5, "viewed": 77, "published": "Public", "date": "1591707701", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    O=vec4(0);//Required on Safari\n    vec3 u=vec3(2.*U-iResolution.xy,iResolution.y)*iTime/5e2;\n    for(int i=0;i<2;i++){\n        u=cos(u+iTime*.2)*2.;\n        u+=sin(u-iTime*.2);\n        O-=cos(3.*dot(u.xy,u.xy)+vec4(.3,.1,0,0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllyR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 281]], "test": "timeout"}
{"id": "wllyRn", "name": "Bitfall", "author": "yacodes", "description": "Bit waterfall", "tags": ["8bit"], "likes": 5, "viewed": 205, "published": "Public API", "date": "1591296228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat random (float st) {\n  return fract(sin(st)*4375.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy/iResolution.xy;\n  vec2 m = vec2(cos(iTime + 0.7652) / 2. + 0.5, sin(iTime + 0.3745) / 2. + 0.5);\n\tvec2 board = st;\n\n  // Rows/Cols\n  board.y *= 128.0;\n  board.x *= 64.;\n\n  // Speed\n  float freq = random(floor(board.x)) + 0.256;\n  float sy = (freq * iTime * 64.);\n  board.y += sy;\n\n  // Render\n  vec3 color = vec3(\n    smoothstep(m.y - 0.5, m.y, random(floor(board.y))),\n    smoothstep(m.x - 0.5, m.x, random(floor(board.y - 0.5))),\n    smoothstep(m.x, m.y, random(floor(board.y + 0.5)))\n  );\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 95], [96, 96, 121, 121, 161], [163, 163, 218, 218, 770]], "test": "ok"}
{"id": "Wllyz2", "name": "Yet another cave generator", "author": "jarble", "description": "I modified my [url=https://www.shadertoy.com/view/WllyW4]\"Honeycomb Tunnels\"[/url] shader to generate some interesting-looking caves.", "tags": ["3d", "raymarching", "cave"], "likes": 3, "viewed": 224, "published": "Public API", "date": "1592513510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    float color1 = length(sin(p/1000.0))/2.0;\n    return vec3(color1,color1/1.8+sin(length(p/10.0)/10.0)/20.0,color1/2.0);\n}\n\n//vec3 surface_color(vec3 p){\n//\treturn (surface_color1(p)*(3.0/5.0)+surface_color1(p*5.0))*(2.0/5.0);\n//}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    //p1 += sin(length(p/50.0+iTime))/5.0;\n    p = (sin(p1+sin(length(p/50.0)/10.0))+cos(p1.yzx+length(p.yzx/50.0)/10.0))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*50.0;\n    float result = planet_surface(p);\n    float j = 1.0;\n    for(int i = 0; i < 4; i++){\n    \tresult += max(result, planet_surface(p*j)/(j));\n        j *= 2.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wllyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 377, 377, 502], [854, 854, 883, 883, 1064], [1066, 1066, 1090, 1090, 1366], [1368, 1789, 1880, 1880, 2204], [2219, 2473, 2538, 2538, 2670], [2672, 2761, 2790, 2790, 3100], [3102, 3594, 3734, 3734, 4344], [4346, 4716, 4801, 4801, 5573], [5575, 5902, 5951, 5986, 6117], [6119, 6119, 6176, 6176, 7340]], "test": "timeout"}
{"id": "wllyzH", "name": "Expanding Fibonacci Flower", "author": "julianlumia", "description": "just playing around a bit:)", "tags": ["fibonacci"], "likes": 14, "viewed": 141, "published": "Public", "date": "1591485527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// OG based of\"fibonacci flower\" by Derzo. https://shadertoy.com/view/ttjGzR\n\nfloat fib(in vec2 uv)\n{\n    float m = 1e6;\n    for (int x=0; x<200; x++)  \n    {\n\tvec2 p;\n    float a = float(x)*radians(132.165);\n   //         float a = float(x)*radians(-iTime*.5);\n\n    a += (iTime)*.5;\n//\tfloat r = .066*sqrt(float(x-int((sin(iTime)*.5+.5)*190.)));\n\tfloat r = float(x-int((sin(iTime)*.5+.5)*190.));\n    if (r<0.) continue;\n\tr = .066*sqrt(r);\n       \n    //p = vec2(r*cos(a),r*sin(a));\n\t/*\n\tif( length(p - uv) < abs(uv).x*0.06)\t\n\treturn 1.;\n\tif ( length(p - uv) < abs(uv).y*0.06)\n\treturn 1.;         \n\t*/     \n     m = min( m,  length(r*vec2(cos(a),sin(a)) - uv) - max( abs(uv).x, abs(uv).y)*0.06) ;  \n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(2.*fragCoord-iResolution.xy) / iResolution.y;\n    \n    fragColor = vec4(0,1,abs(uv.y),1) * smoothstep(1.5/iResolution.y,-1.5/iResolution.y,fib(uv) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 101, 101, 720], [722, 722, 779, 779, 945]], "test": "timeout"}
{"id": "wllyzN", "name": "fork, strange", "author": "Carandiru", "description": "had to try it out, don't know why I ended up here....", "tags": ["forkntsutaescircuitdiagram2v1"], "likes": 1, "viewed": 227, "published": "Public API", "date": "1591611185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Circuit Diagram2\" by ntsutae\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\n\n#define INV_STATES 0.0619f\n#define V_FREQ 88882.0f\n#define LAYERS 0.075f\n#define RANGE 20000.0f\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \n    float tt = iTime + V_FREQ;\n    \n  int x = int(fragCoord.x * 9911.0001f + tt*4.2);\n  int y = int(fragCoord.y * LAYERS + tt*42.0);\n\n  float state = texture(iChannel0, fragCoord/iResolution.xy).r;\n  int t = int((tt * (INV_STATES + state)));\n    \n  vec3 rgb;\n    \n  int r = ((x+y)/(y*y))^(x-y);\n    \n  rgb.r = float(abs(r*r) % (int(RANGE) + t));\n  rgb.g = float(abs(r*r) % (int(RANGE) + t + 1));\n  rgb.b = float(abs(r*r) % (int(RANGE) + t + 1 + 1));\n    \n  rgb = 1.0f - smoothstep(vec3(RANGE*0.25f), vec3(RANGE*4.0f), rgb);\n  rgb = vec3(rgb.r+rgb.g+rgb.b) * 0.333f;\n  fragColor = vec4(rgb.grb - state, 1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "WlscD2", "name": "Generative Vasarely, Arny", "author": "ciphered", "description": "A generative recreation of the piece Arny, Victor Vasarely. \nMore on my insta: https://instagram.com/ciphrd", "tags": ["vasarely", "arni"], "likes": 2, "viewed": 194, "published": "Public API", "date": "1593140324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DIVS 20.0\n#define PI 3.141592759\n\n\nfloat rand (vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 rotate (vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nbool approx (float a, float b, float d)\n{\n    return abs(a-b)<=d;\n}\n\nfloat circleSquare (vec2 uv, float t)\n{\n    float power = 4./(cos(t*PI/8.)+1.);\n    float lhs =\n        pow(abs(uv.x-uv.y), power) +\n        pow(abs(uv.y+uv.x), power)\n    ;\n    float rhs = 1.;\n    \n    return smoothstep(0.4, 0.5, rhs - lhs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x*= iResolution.x / iResolution.y;\n    \n    // grid\n    vec2 div = uv * DIVS;\n    vec2 sq = fract(div) - .5;\n    vec2 id = floor(div);\n    \n    // rotation\n    float rot = clamp(cos(iTime + id.x *.2 + id.y * .2), -.5, .5) + .5;\n    sq = rotate(sq, rot * PI * .25);\n    \n    // rectangles\n    vec2 asq = abs(sq);\n\tfloat rect = circleSquare(asq * 2., iTime * 2. + id.x);\n    \n    \n    // we give a background in diagonal\n    vec2 idc = id / DIVS;\n    vec3 col = vec3(0);\n    col = mix(vec3(.9, 0, .1), vec3(0.5, 0.5, 0.8), min(1.0, idc.x - idc.y + .5)) * rect;\n    col-= .5 - length((id+.5) / DIVS);\n    \n    // color is made by having circles running in... circles\n    vec2 ptc1 = vec2(cos(iTime*.5) * .4, sin(iTime*.5) * .4);\n    col.rgb+= vec3(0, 1., .5) * (1. - length(ptc1 - idc)) * (1. - rect);\n    \n    vec2 ptc2 = vec2(cos(iTime*.5 + PI) * .4, sin(iTime*.5 + PI) * .4);\n    col.rgb+= vec3(.5, 0., .8) * (1. - length(ptc2 - idc)) * (1. - rect);\n    vec2 ptc3 = vec2(cos(iTime*1.0 + PI*.5) * .4, sin(iTime*1.0 + PI*.5) * .4);\n    col.rgb+= vec3(1., 1., 1.) * (1. - length(ptc3 - idc)) * (1. - rect) * (cos(iTime)*.2 + .4);\n    \n    col*= rand(uv) * .1 + .9;\n    \n\t\n    // Time varying pixel color\n    //col = mix(col, vec3(1), rect);\n    \n    \n    // we square the view\n    float visible = step(abs(uv.x), .5);\n    visible*= step(abs(id.x), DIVS*.5 - 3.);\n    visible*= step(abs(id.y+.5), DIVS*.5 - 1.);\n    col*= visible;\n    \n    id = floor(div * 2. - .5);\n    id.y = floor(div.y * 2.);\n    visible = step(abs(id.x), DIVS - 5.);\n    visible*= step(abs(id.y + .5), DIVS - 1.5);\n    \n    col+= rand(uv) * .1;\n    \n    // the background\n    col+= (1. - visible) * clamp(pow(max(0., (1.-length(uv))), .2)* 1.1, .2, 1.);\n    col.b*= .92;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 64, 64, 131], [133, 133, 164, 164, 248], [250, 250, 291, 291, 317], [319, 319, 358, 358, 563], [565, 565, 622, 672, 2521]], "test": "timeout"}
{"id": "wlscDH", "name": "Minimal raymarching phantom", "author": "TAKUSAKU", "description": "Minimal raymarching phantom", "tags": ["raymarching", "minimal", "phantom"], "likes": 7, "viewed": 99, "published": "Public", "date": "1592051082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 U )\n{\n    vec3 d=vec3(U/iResolution.xy-.3*sin(iTime)-.5,.2*cos(iTime*.3)+.3),\n        p=vec3(sin(iTime),cos(iTime),iTime)*9.,q,c;\n    float s;for(int i=0;i<99;i++)\n        p+=d*(s=max(abs(length(sin(p.zxy*.6)-cos(p))-.5),.02)),\n        c+=exp(-s*9.);\n    o=1.2*vec4(vec3(.8,1,1)-c/55.,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 326]], "test": "ok"}
{"id": "WlscR2", "name": "Restylized Shoreline", "author": "miko3k", "description": "based on: https://www.shadertoy.com/view/3dfBzM\n\nremoves certain things I did not understand or found uncessary.\n\nAlso it is infinitely tileable along X-axis. The way the tileability is handled is very questionable, ugly and repeatititve", "tags": ["water", "stylized", "shore"], "likes": 1, "viewed": 110, "published": "Public", "date": "1592526834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265369\n\n// Simplex 2D noise\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n      dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec4 frag(vec4 snd, vec4 wtr, vec4 foamColor, vec2 uv, float time) {\n    float waveHeight = 0.1;\n    float waveSpeed = 4.0;\n    float bubbleSpeed = 1.0;\n    float bubbleWidth = 20.0;\n    float bubbleHeight = 20.0;\n    float shadowHeight = 0.1;\n    float wiggleDistance = 0.1;\n    float center = 0.5;\n\n\tfloat uvy = uv.y - (sin(time) * 0.5 + 0.5) * wiggleDistance - center;\n\tfloat wuvy = uv.y - center - shadowHeight;\n\n\tfloat shore = sin(uv.x * PI * 4. + time*waveSpeed) + sin(uv.x * PI * 2.);\n    \n\tshore = shore * 0.5 + 0.5;\n\tshore *= waveHeight;\n\tfloat smshore = smoothstep( uvy * 5., uvy * 5. + 2.5, shore);\n\n\n\tfloat wshore = smoothstep( wuvy * 5., wuvy * 5., shore);\n\n\tshore = smoothstep( uvy * 5., uvy * 5. + 2., shore);\n\n    // true if we are below the shore\n\tfloat shmsk = step(0.1, shore);\n    \n    float suvx = uv.x + (uv.y * 5.);\n\n\n\tvec4 res = mix(snd, wtr, smshore);\n\n    float foam = snoise(vec2(abs(uv.x-0.5) * bubbleWidth, uvy * bubbleHeight + time * bubbleSpeed)) * 0.3 + 0.5;\n\tfoam = step(shore, foam) * shmsk;\n\n\n    float soff = mix(0.01, 0.2, smoothstep (0.7, 0., uv.y));\n\n\tres *= (1. - wshore * (1. - shmsk) * (sin(time - PI / 2.) * 0.5 + 0.5) * 0.2);\n\n\tres = mix(res, foamColor, foam);\n\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 wtr = mix(texture(iChannel0, uv), vec4(0.4,0.4,1.0,1.0), .8);\n\tvec4 snd = mix(texture(iChannel1, uv), vec4(0.4,0.5,0.2,1.0), .8);\n    vec4 foamColor = vec4(0.95, 0.95, 1., 1.);\n    \n\tfragColor = frag(snd, wtr, foamColor, uv, iTime);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 46, 68, 68, 107], [109, 109, 130, 130, 992], [994, 994, 1062, 1062, 2217], [2220, 2220, 2277, 2277, 2558]], "test": "error"}
{"id": "wlscR4", "name": "colorful scale", "author": "darkfox", "description": "blue skyblue and red orange.", "tags": ["colorful"], "likes": 1, "viewed": 38, "published": "Public", "date": "1591578129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// colorful scale.\n// https://www.openprocessing.org/sketch/869086\n\nconst float pi = 3.14159;\nconst float SCALE = 5.0;\nconst float ROTATION_SPEED = 0.05;\nconst float BASEHUE1 = 0.05;\nconst float BASEHUE2 = 0.55;\n// hsb to rgb.\nvec3 getRGB(float r, float g, float b){\n    vec3 c = vec3(r, g, b);\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 st = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  st *= SCALE;\n  float angle = iTime * pi * ROTATION_SPEED;\n  st *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  vec3 q = vec3(st.x, st.y, iTime * 0.5);\n  vec3 p = q + (q.x + q.y + q.z) / 3.0;\n  vec3 f = fract(p);\n  vec3 i = floor(p);\n  float hue = (mod(iTime, 10.0) < 5.0 ? BASEHUE1 : BASEHUE2);\n  if(f.x > f.y && f.x > f.z){\n    hue += (f.y > f.z ? 0.0 : 0.06);\n  }else if(f.y > f.x && f.y > f.z){\n    hue += (f.x > f.z ? 0.02 : 0.08);\n  }else{\n    hue += (f.x > f.y ? 0.04 : 0.1);\n  }\n  fragColor = vec4(getRGB(hue, (f.x + f.y + f.z) * 0.5, 0.9), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 227, 266, 266, 472], [473, 473, 527, 527, 1187]], "test": "ok"}
{"id": "wlscRN", "name": "XOR ^ float(n)", "author": "FabriceNeyret2", "description": "effect of bitwise operators XOR, AND, OR once powered by fractionals from 0 (left) to 4 (right)\nStrange how Xor \"hashes\" into circuit-like patterns.\n\nsee also [url]https://shadertoy.com/view/ttscRN[/url] and  [url]https://shadertoy.com/view/wllcRN[/url]", "tags": ["xor", "pattern", "hash", "bitwise", "circuits"], "likes": 9, "viewed": 275, "published": "Public API", "date": "1591599929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/ttscRN\n// variant of https://shadertoy.com/view/wllcRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy;\n    ivec2 I = ivec2(U+60.*iTime);\n    int t = int(iTime) % 3, \n        n = int(U.x/R.x*4.),\n        i =   t==1 ? I.x ^ I.y\n            : t==2 ? I.x | I.y\n            :        I.x & I.y;\n                 //  I.x * I.y;\n    \n    float v = pow( float(i), floor(U.x/R.x*4.*5.)/5. );\n\n    O = vec4( fract( v / 256.) );\n    \n    if ( int(U.x)*20 % int(R.x) < 20 ) O.r++; // red separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 135, 135, 549]], "test": "ok"}
{"id": "wlscRr", "name": "MK_projection", "author": "margotaro", "description": "CG course", "tags": ["3d"], "likes": 2, "viewed": 74, "published": "Public", "date": "1591365177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int TRIANGLES_COUNT = 60;\nconst int VERTICES_COUNT = 38;\n\nconst vec3 vertices[VERTICES_COUNT] = vec3[] (\n    vec3(0.2, 1.4, 0.),//0\n    vec3(0.4,  1.4, 0.),//1 \n    vec3(0.4,  -1.6, 0.),//2 \n    vec3(0.2,  -1.6, 0.),//3\n    vec3(0.2,  0., 0.),//4\n    vec3(0.,  0., 0.),//5\n    vec3(-0.2, 1.4, 0.),//6\n    vec3(-0.2,  0., 0.),//7\n    vec3(0.,  -0.8, 0.),//8\n    vec3(-0.4,  1.4, 0.),//9\n    vec3(-0.2,  -1.6, 0.),//10\n    vec3(-0.4,  -1.6, 0.),//11\n    vec3(0.2, 1.4, 0.2),//12\n    vec3(0.4,  1.4, 0.2),//13 \n    vec3(0.4,  -1.6, 0.2),//14 \n    vec3(0.2,  -1.6, 0.2),//15\n    vec3(0.2,  0., 0.2),//16\n    vec3(0.,  0., 0.2),//17\n    vec3(-0.2, 1.4, 0.2),//18\n    vec3(-0.2,  0., 0.2),//19\n    vec3(0.,  -0.8, 0.2),//20\n    vec3(-0.4,  1.4, 0.2),//21\n    vec3(-0.2,  -1.6, 0.2),//22\n    vec3(-0.4,  -1.6, 0.2),//23\n    vec3(-0.4,  1.4, 0.4),//24\n    vec3(-0.4,  1.4, 0.6),//25\n    vec3(-0.4,  0.2, 0.2),//26\n    vec3(-0.4,  -0.2, 0.3),//27\n    vec3(-0.4,  -0.6, 0.2),//28\n    vec3(-0.4,  -1.6, 0.4),//29\n    vec3(-0.4,  -1.6, 0.6),//30\n    vec3(-0.2,  1.4, 0.4),//31\n    vec3(-0.2,  1.4, 0.6),//32\n    vec3(-0.2,  0.2, 0.2),//33\n    vec3(-0.2,  -0.2, 0.3),//34\n    vec3(-0.2,  -0.6, 0.2),//35\n    vec3(-0.2,  -1.6, 0.4),//36\n    vec3(-0.2,  -1.6, 0.6)//37\n);\n\nconst int trinagleIndexes[TRIANGLES_COUNT * 3] = int[] (\n    0, 1, 2,//M1\n    2, 0, 3,//M1\n    0, 4, 5,//M1\n    6, 7, 5,//M1\n    8, 7, 4,//M1\n    6, 9, 10,//M1\n    9, 10, 11,//M1\n    12, 13, 14,//M2\n    14, 12, 15,//M2\n    12, 16, 17,//M2\n    18, 19, 17,//M2\n    20, 19, 16,//M2\n    18, 21, 22,//M2\n    21, 22, 23,//M2\n    1, 2, 13,//MS\n    14, 2, 13,//MS\n    14, 2, 15,//MS\n    3, 2, 15,//MS\n    4, 16, 15,//MS\n    3, 4, 15,//MS\n    4, 16, 20,//MS\n    4, 8, 20,//MS\n    7, 8, 20,//MS\n    19, 7, 20,//MS\n    7, 19, 22,//MS\n    7, 10, 22,//MS\n    11, 10, 22,//MS\n    11, 23, 22,//MS  \n    11, 23, 9,//MS   \n    9, 23, 21,//MS   \n    9, 18, 21,//MS      \n    9, 18, 6,//MS \n    18, 6, 5,//MS   \n    18, 17, 5,//MS   \n    0, 5, 17,//MS      \n    0, 17, 12,//MS      \n    0, 1, 12,//MS    \n    13, 1, 12,//MS     \n    24, 25, 26,//K1       \n    25, 26, 27,//K1          \n    28, 26, 27,//K1          \n    28, 29, 27,//K1        \n    27, 30, 29,//K1    \n    31, 32, 33,//K2       \n    32, 33, 34,//K2          \n    35, 33, 34,//K2          \n    35, 36, 34,//K2        \n    34, 37, 36,//K2     \n    26, 33, 24,//KS          \n    24, 33, 31,//KS          \n    24, 31, 32,//KS        \n    24, 32, 25,//KS    \n    32, 25, 27,//KS       \n    27, 32, 34,//KS          \n    27, 34, 30,//KS          \n    34, 30, 37,//KS        \n    36, 30, 37,//KS         \n    36, 30, 29,//KS        \n    29, 35, 28,//KS         \n    29, 35, 36//KS \n);\n    \nconst vec3 triangleColor[TRIANGLES_COUNT] = vec3[] (\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.5),\n    vec3(0.3, 0.5, 0.5),\n    vec3(0.3, 0.5, 0.5),\n    vec3(0.3, 0.5, 0.5),\n    vec3(0.3, 0.5, 0.5),\n    vec3(0.3, 0.5, 0.5),\n    vec3(0.3, 0.5, 0.5),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),\n    vec3(0.3, 0., 0.),    \n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.3, 0.5, 0.9)\n);\n\nmat4 t() {\n    float time = iTime * 0.5;\n    return mat4(\n        vec4(1. * cos(time), 0., sin(time), 0.),\n        vec4(0., 1., 0., -1.),\n        vec4(-sin(time), 0., 1.* cos(time), 5.),\n        vec4(0., 0., 0., 1.)\n    );\n}\n\nvec3 v(int i) {\n    return (vec4(vertices[i], 1.) * t()).xyz;\n}\n\nvec3 normalOfTriangle(int index) {\n    vec3 root = v(trinagleIndexes[index * 3]);\n    vec3 d1 = v(trinagleIndexes[index * 3 + 1]) - root;\n    vec3 d2 = v(trinagleIndexes[index * 3 + 2]) - root;\n    return cross(d1, d2);\n}\n\nbool sameSide(vec3 base, vec3 p1, vec3 p2) {\n    return dot(cross(base, p1), cross(base, p2)) >= 0.;\n}\n\nbool pointInsideTriangle(vec3 point, int i) {\n    vec3 a = v(trinagleIndexes[i * 3]);\n    vec3 b = v(trinagleIndexes[i * 3 + 1]);\n    vec3 c = v(trinagleIndexes[i * 3 + 2]);\n    return sameSide(b - a, point - a, c - a) &&\n        sameSide(c - b, point - b, a - b) &&\n        sameSide(a - c, point - c, b - c);\n}\n\nbool testTriangle(int index, vec3 ray, out float colissionZ) {\n    int rootVertexIndex = trinagleIndexes[index * 3];\n    vec3 rootVertex = v(rootVertexIndex);\n    vec3 normal = normalOfTriangle(index);\n    \n    float t = dot(rootVertex, normal) / dot(ray, normal);\n    vec3 intersectionPoint = ray * t;\n    \n    colissionZ = intersectionPoint.z;\n    \n    return pointInsideTriangle(intersectionPoint, index);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - vec2(1.);\n    \n    bool anyTriangle = false;\n    float minimalZ = 9999.;\n    int i = 0;\n    int triangleIndex = 0;\n    float currentZ = 0.;\n    vec3 ray = vec3(uv, 1.);\n    for (; i < TRIANGLES_COUNT; i++) {\n        if (testTriangle(i, ray, currentZ)) {\n            if (minimalZ > currentZ) {\n                minimalZ = currentZ;\n              triangleIndex = i;\n              anyTriangle = true;\n            }\n        }\n    }\n\n    if (anyTriangle) {\n        fragColor = vec4(triangleColor[triangleIndex].rgb, 1.0);\n    } else {\n        fragColor = vec4(0.22, 0.26, 0.3, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4198, 4198, 4208, 4208, 4422], [4424, 4424, 4439, 4439, 4487], [4489, 4489, 4523, 4523, 4710], [4712, 4712, 4756, 4756, 4814], [4816, 4816, 4861, 4861, 5127], [5129, 5129, 5191, 5191, 5539], [5542, 5542, 5597, 5597, 6241]], "test": "timeout"}
{"id": "WlscWj", "name": "Star demo", "author": "Nrx", "description": "A very basic star shape, for educational purposes (with step by step explanations on how things are done).", "tags": ["star"], "likes": 3, "viewed": 151, "published": "Public API", "date": "1593109049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t\t\t3.14159265358979\n#define STEPS\t\t5.0\n#define RADIUS\t\t0.8\n#define SLOPE\t\t2.5\n#define THICKNESS\t0.08\n#define AA\t\t\t0.01\n#define REPEAT\t\t2.0\n\nmat2 rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat starDist (in vec2 p)\n{\n\t// Divide the plan in STEPS sectors\n\tconst float arc = 2.0 * PI / STEPS;\n\tp *= rotate (arc * floor (atan (p.y, p.x) / arc + 0.5));\n\n\t// Compute the signed distance to the triangle edge (there is one triangle per sector)\n\treturn (p.x + abs (p.y) * SLOPE - RADIUS) / sqrt (1.0 + SLOPE * SLOPE);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalization of the fragment coordinates\n\tfragCoord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n\t// Define the strip pattern\n\tfloat strip = smoothstep (0.3 - AA * 10.0, 0.3 + AA * 10.0, cos (fragCoord.y * 40.0 + sin (fragCoord.x * 20.0) + iTime * 10.0));\n\n\t// Translation of the plan\n\tvec2 p = fragCoord + vec2 (0.5 * cos (iTime * 0.7), 0.2 * sin (iTime * 1.4));\n\n\t// Rotation of the plan\n\tp *= rotate (iTime);\n\n\t// Zoom of the plan\n\tfloat zoom = 1.0 + 0.5 * cos (iTime * 1.8);\n\tp /= zoom;\n\n\t// Consider the plan is a grid of squares\n\tp = p / REPEAT + 0.5;\n\tvec2 id = floor (p);\n\tp = REPEAT * (fract (p) - 0.5);\n\n\t// Rotation of the square's contents (the angle depends on the position of the square in the grid)\n\tp *= rotate (iTime * (id.x * 2.0 + id.y * 3.0));\n\n\t// Compute the signed distance to the star shape within each square\n\tfloat star = starDist (p);\n\n\t// For the fun, add little stars in the big stars, using the same approach as above\n\tp /= 0.1;\n\tp = REPEAT * (fract (p / REPEAT + 0.5) - 0.5);\n\tstar = max (star, -abs (starDist (p)));\n\n\t// What about adding other stars in the background? (Again, using the same approach as above but starting with \"fragCoord\") \n\tp = fragCoord * rotate (-iTime * 0.6) / 0.3;\n\tp = REPEAT * (fract (p / REPEAT + 0.5) - 0.5);\n\tstar = min (star, max (-star,  starDist (p)));\n\n\t// Display the stars and strips\n\tconst float halfThickness = THICKNESS * 0.5;\n\tfloat halfThicknessAA = halfThickness + AA / zoom;\n\tfloat redGradient =  0.7 + 0.3 * cos (PI * fragCoord.x * iResolution.y / iResolution.x);\n\tfragColor = vec4 (\n\t\tsmoothstep (-halfThicknessAA, -halfThickness, star) * redGradient,\n\t\tsmoothstep (halfThicknessAA, halfThickness, abs (star)),\n\t\tsmoothstep (-halfThickness, -halfThicknessAA, star) * strip,\n\t\t1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlscWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 180, 180, 258], [260, 260, 288, 325, 584], [586, 586, 642, 688, 2417]], "test": "timeout"}
{"id": "Wlsczr", "name": "When the ocean is marching rays", "author": "postviolet", "description": "In the wake of Char Stiles's workshop ♥ ", "tags": ["raymarching"], "likes": 3, "viewed": 200, "published": "Public API", "date": "1591294959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size * 0.5)/size);\n\tp = mod (p + size * 0.5, size) - size * 0.5;\n\treturn c;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nconst int steps = 250;\nconst float smallNumber = 0.00001;\nconst float maxDist = 10.;\n\nfloat scene(vec3 position){    \n    \n    vec3 st = position;\n    pMod3 (st, vec3 (0.364, 4.2, 0.));\n    \n    float ground = st.y + sin(position.x*8. * abs(sin(iTime/15.)))/9. \n                              + cos(position.z*10. * fract (iTime/5.)) / 10. + 1.5 ;\n    \n    float shar1 = sdSphere (vec3(position.x-0.844, position.y-1.036, position.z+1.788), -0.800 );\n\n    return opSmoothUnion(shar1, ground*ground, 3.);\n}\n\nvec4 trace (vec3 origin, vec3 direction){\n    \n    float dist = 0.;\n    float totalDistance = 0.;\n    vec3 positionOnRay = origin;\n    \n    for(int i = 0 ; i < steps; i++){\n        \n        dist = scene(positionOnRay);\n\n        positionOnRay += dist * direction;\n\n        totalDistance += dist;\n\n        if (dist < smallNumber){\n\n            return 1.000 - (vec4(totalDistance) / maxDist);\n        }\n        \n        if (totalDistance > maxDist){\n \n            return vec4(0);\n        }\n    }\n    \n    return vec4(0.890+sin(iTime),0.583+sin(iTime),0.540,1.000);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  uv += -0.5;\n  uv *= 2.;\n\n  vec3 camOrigin = vec3(0., 0., -2.);\n  vec3 rayOrigin = vec3(uv + camOrigin.xy, camOrigin.z + 1.);\n  vec3 dir = camOrigin + rayOrigin;\n\n  vec4 color = vec4(trace(rayOrigin, dir));\n  fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlsczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 136], [138, 138, 190, 190, 289], [292, 292, 327, 327, 351], [439, 439, 466, 466, 857], [859, 859, 900, 900, 1422], [1425, 1425, 1480, 1480, 1752]], "test": "timeout"}
{"id": "WlSczz", "name": "Mandelbrot disco", "author": "Ausfragezeichen", "description": "My fun first try on implementing z = z² + c", "tags": ["fractal"], "likes": 1, "viewed": 178, "published": "Public API", "date": "1593537992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 3.; //zoom\n    \n    vec2 c = uv;\n    \n    float i2 = 0.;\n    \n    float maxI = 25. + iTime;\n    \n    for( float i = 0.; i < maxI; i++) //iterations\n    {\n        //complex multiplication: c.x = real, c.y = imaginary;\n        float a = c.x * c.x - c.y * c.y;\n        float b = 2. * c.x * c.y;\n        c = vec2( a, b) + uv;\n        \n        //first time it is sure to escape (real | imaginary > 2)\n        if( i2 == 0. && (abs(c.x) > 2. || abs(c.y) > 2.))\n        {\n            i2 = i;\n        }\n    }\n    \n    //red = real, green = imaginary\n    vec3 col = vec3(abs(c.x), abs(c.y), 0.);\n    \n    if( abs(c.x) > 2. || abs(c.y) > 2.)\n    {\n        col = vec3(0.);\n    }\n\t\n    //blue = iterations\n    col += vec3(0.,0.,i2/maxI);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 916]], "test": "timeout"}
{"id": "wlsyD7", "name": "Rounded Rhombic Dodecahedron", "author": "blackle", "description": "remix of yx's shader: https://www.shadertoy.com/view/Wd2Gzt", "tags": ["sdf"], "likes": 3, "viewed": 213, "published": "Public API", "date": "1592881280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Original Shader by yx: https://www.shadertoy.com/view/Wd2Gzt\n\n#define pi (acos(-1.))\n\nconst vec3 color = vec3(.3,.01,.05);\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat scene(vec3 p)\n{\n    float offset = 0.05;\n    float radius = .5;\n    p = sqrt(p*p+offset*offset);\n    p = (p+p.yzx)/2.-radius;\n    return length(max(p,0.))+min(0.,max(p.x,max(p.y,p.z)))-offset;\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t;\n    for(int i = 0; i < 100; ++i)\n    {\n        float k = scene(cam+dir*t);\n        t += k;\n        if (k < .001)\n        {\n            vec3 h = cam+dir*t;\n    \t\tvec2 o = vec2(.001, 0);\n    \t\tvec3 n = normalize(vec3(\n        \t\tscene(h+o.xyy)-scene(h-o.xyy),\n        \t\tscene(h+o.yxy)-scene(h-o.yxy),\n        \t\tscene(h+o.yyx)-scene(h-o.yyx)\n    \t\t));\n\n\t\t\tif (iMouse.z > 0.)\n    \t\t{\n        \t\treturn n*.5+.5;\n    \t\t}\n    \t\telse\n    \t\t{\n                const vec3 lightdir = normalize(vec3(1,5,2));\n                \n\t\t        float light = dot(n,lightdir)*.5+.5;\n\t\t\n\t\t        return light * color;\n    \t\t}\n        }\n    }\n    return vec3(1);\n}\n\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, .3);\n    p.xz = rotate(p.xz, iTime*.1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-15.);\n    vec3 dir = normalize(vec3(uv,6));\n\n    cameraspin(cam);\n    cameraspin(dir);\n    \n    out_color.rgb = trace(cam,dir);\n    if (iMouse.z <= 0.)\n    {\n    \tout_color.rgb *= pow(color, vec3(2.*dot(uv,uv)));\n    \tout_color.rgb = pow(out_color.rgb,vec3(.45));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 156, 156, 279], [281, 281, 302, 302, 481], [483, 483, 515, 515, 1167], [1169, 1169, 1200, 1200, 1266], [1268, 1268, 1320, 1320, 1711]], "test": "timeout"}
{"id": "wlsyDH", "name": "Blur Color", "author": "TAKUSAKU", "description": "Blur Color", "tags": ["blur", "color"], "likes": 3, "viewed": 60, "published": "Public", "date": "1592049220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 U )\n{\n    o=vec4(0);//Required on Safari\n    vec3 u=normalize(vec3(2.*U-iResolution.xy,iResolution.y));\n    for(int i=0;i<6;i++){\n        u.x+=sin(u.z+iTime*.1);\n        u.y+=cos(u.x+iTime*.1);\n        o=max(o*.9,cos(3.*dot(u,u)*vec4(.3,.1,.2,0)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 292]], "test": "timeout"}
{"id": "WlsyR2", "name": "Random Grid Shenanigans", "author": "noobay", "description": "Trying to be creative for once and play around with a grid.", "tags": ["grid", "flow", "electricity"], "likes": 15, "viewed": 514, "published": "Public", "date": "1592776760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define TARGET_COUNT 15\n#define GRID_CELL_SIZE 0.1\n#define RED vec3(1.0,0.0,0.0)\n#define GREEN vec3(0.0,1.0,0.0)\n#define BLUE vec3(0.0,0.0,1.0)\n\nvec2 getGridPosition(in vec2 uv)\n{\n\treturn vec2((uv.x / GRID_CELL_SIZE), (uv.y / GRID_CELL_SIZE));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized frag coordinates\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    \n    vec2 gridBoundUV = getGridPosition(uv);\n\n    vec2 cellBoundUV = gridBoundUV - round(gridBoundUV);\n    \n    float redIntensity = 0.0;\n    float blueIntensity = 0.0;\n \n    for (int targetIndex = 0; targetIndex < TARGET_COUNT; ++targetIndex)\n    {\n        float f_targetIndex = float(targetIndex);\n\n        float trigOffset = (PI / float(TARGET_COUNT)) * f_targetIndex;\n        vec2 targetPosition = vec2(sin(iTime + trigOffset) * 0.51 + tan(f_targetIndex + trigOffset), cos(iTime + trigOffset) * 0.1 + sin(f_targetIndex + trigOffset));\n        vec2 gridBoundTargetPosition = getGridPosition(targetPosition);\n        vec2 edgeBoundPosition = vec2(gridBoundTargetPosition.x, gridBoundTargetPosition.y);\n\n        // change the op between the lengths to subtraction for some extreme strobe effects\n        float distanceToTarget = length(gridBoundUV - round(gridBoundTargetPosition)) + length((gridBoundUV) - (edgeBoundPosition));\n\n    \tredIntensity += length(GRID_CELL_SIZE / (distanceToTarget * 9.5)  / cellBoundUV) * GRID_CELL_SIZE;\n    \n    }\n\n    for (int targetIndex = 0; targetIndex < TARGET_COUNT; ++targetIndex)\n    {\n        float f_targetIndex = float(targetIndex);\n\n        float trigOffset = (PI / float(TARGET_COUNT)) * f_targetIndex;\n\n        vec2 targetPosition = vec2(sin(iTime + trigOffset) * 0.51 + sin(f_targetIndex + trigOffset), tan(iTime + trigOffset) * 0.1 + sin(f_targetIndex + trigOffset));\n        vec2 gridBoundTargetPosition = getGridPosition(targetPosition);\n        vec2 edgeBoundPosition = vec2(gridBoundTargetPosition.x, gridBoundTargetPosition.y);\n\n        float distanceToTarget = length(gridBoundUV - round(gridBoundTargetPosition)) + distance(gridBoundUV, edgeBoundPosition);\n\n    \tblueIntensity += length(GRID_CELL_SIZE / (distanceToTarget * 15.5)  / cellBoundUV) * GRID_CELL_SIZE;\n    \n    }\n\n\n    vec3 col = vec3(smoothstep(0.2, 1.0, redIntensity + blueIntensity));\n\n\tcol += redIntensity * GREEN;\n   \tcol += blueIntensity * BLUE;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 195, 195, 261], [263, 263, 320, 355, 2454]], "test": "timeout"}
{"id": "wlsyR4", "name": "tripole", "author": "darkfox", "description": "triangle like poles.", "tags": ["circle"], "likes": 3, "viewed": 56, "published": "Public", "date": "1591575305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tripole.\n// https://www.openprocessing.org/sketch/838265\n\n// constants.\nconst float PI = 3.14159;\nconst float RADIUS = 0.4;\nconst float ROTATION_SPEED = 0.6;\nconst float SCALE = 6.0;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  float t = iTime * ROTATION_SPEED;\n  vec2 p = fragCoord.xy;\n  float minLen = min(iResolution.x, iResolution.y);\n  vec2 p0 = iResolution.xy * 0.5 + RADIUS * minLen * vec2(cos(t), sin(t));\n  vec2 p1 = iResolution.xy * 0.5 + RADIUS * minLen * vec2(cos(t + (2.0 * PI) / 3.0), sin(t + (2.0 * PI) / 3.0));\n  vec2 p2 = iResolution.xy * 0.5 + RADIUS * minLen * vec2(cos(t + (4.0 * PI) / 3.0), sin(t + (4.0 * PI) / 3.0));\n  // geometric mean(three)\n  float d_mean = pow(distance(p, p0) * distance(p, p1) * distance(p, p2), 0.333333) / max(iResolution.x, iResolution.y);\n  float check = smoothstep(0.0, 1.0, mod(d_mean * 256.0 + iTime * 12.0, SCALE) / SCALE);\n  // turquoise blue.\n  fragColor = vec4(vec3(0.25, 0.88, 0.81) * check, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 240, 240, 971]], "test": "timeout"}
{"id": "wlSyRR", "name": "Double Triangle tiling [Day 193]", "author": "jeyko", "description": "Derp", "tags": ["triangle", "tiling", "mdtmjvm"], "likes": 21, "viewed": 284, "published": "Public API", "date": "1593543353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Mathematically correct with no number-crunching! \n// https://tilings.math.uni-bielefeld.de/substitution/double-triangle/\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\nfloat sdEquilateralTriangle(  vec2 p, float r ){   \n    r = r*1./3.;\n\tp.y -= r;\n    p.y += r*1.5;\n    float d = dot(vec2(abs(p.x),p.y) - -normalize(vec2(0.,1)*rot(tau/3.))*(r), -normalize(vec2(0.,1)*rot(tau/3.)));\n    d = max(d,p.y - r*2.);\n    d = max(d,-p.y - r);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 col = vec3(0);\n    \n    float iters = 6.;\n    \n    float d = 10e5;\n    \n    // mafs\n    float s = 1.;\n\n    \n    \n\n    \n    uv += vec2(sin(iTime/2.6),cos(iTime/2.))*0.4;    \n    uv *= .03;\n    uv.y -= 0.1;\n    uv.x -= 0.2;\n\n    \n    float id = 0.;\n    vec2 p = uv;\n    float sc = 1.;\n    \n    float palvar = 1.;\n    \n    for(float i = 0.; i < iters; i++){\n        \n        \n        float median = s;\n        float outer = median*2./sqrt(3.);\n\n        vec2 pbtrans = - vec2(0.,sc*median/4.);\n        vec2 pctrans = + vec2(0.,sc*median/4.);\n        vec2 pdtrans = + vec2(0. - sc*outer*.125,sc*median/8.);\n        vec2 petrans = + vec2(0. - sc*outer*.25 , sc*median/(2.+2./3.));\n        vec2 pftrans = + vec2(0. - sc*outer*.25, sc*median/(8.));\n        vec2 pgtrans = + vec2(0. - sc*outer*0.375, sc*median/(2.+2./3.));\n\n\n        float tria = sdEquilateralTriangle( p, s*sc*1.);\n        float trib = sdEquilateralTriangle( p + pbtrans, s*sc/2.);\n        float tric = sdEquilateralTriangle( p + pctrans, s*sc/2.);\n\n        p.x = abs(p.x);\n\n        float trid = sdEquilateralTriangle((p + pdtrans )* rot(1.*pi) , s*sc/4.);\n        float trie = sdEquilateralTriangle((p + petrans )* rot(1.*pi) , s*sc/4.);\n\n        float trif = sdEquilateralTriangle((p + pftrans ), s*sc/4.);\n        float trig = sdEquilateralTriangle((p + pgtrans ) , s*sc/4.);\n\n\n        d = min(d,abs(tria));\n\n        d = min(d,abs(trib));\n        d = min(d,abs(tric));\n        d = min(d,abs(trid));\n        d = min(d,abs(trie));\n        d = min(d,abs(trif));\n        d = min(d,abs(trig));\n\n        if(tria < 0.){\n            if( trib < 0.){\n                p += pbtrans;\n                palvar += 0.4;\n            } else if(tric < 0.){\n                p += pctrans;\n                palvar += 1.4;\n            } else if(trid < 0.){\n                p += pdtrans;\n                palvar += .4;\n            } else if(trie < 0.){\n                p += petrans;\n                palvar += 1.4;\n            } else if(trif < 0.){\n                p += pftrans;\n                palvar += .4;\n            } else if(trig < 0.){\n                p += pgtrans;\n                palvar += 2.4;\n            }\n            if(trid < 0. || trie < 0.){\n                p *= rot(pi);\n            }\n            if(trib < 0. || tric < 0. ){\n                sc *= 0.5;\n            } else {\n                sc *= 0.25;\n            }\n\n        } else {\n        \tbreak;\n        }\n            \n            \n        \n    }\n    \n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n    col = mix(col,pal(0.5,0.56,vec3(3.,0.7,0.2),3.4, palvar + iTime + uv.x*2. + uv.y*2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    //col = mix(col,pal(0.5,0.56,vec3(2.,0.7,0.2),1., palvar + iTime + uv.x*2. + uv.y*2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    \n    d = abs(d);\n    \n    float w = 1.1;\n    col = mix(col,vec3(0.01),smoothstep(dFdx(uv.x)*w,dFdx(uv.x)*(w-1.)*1.,d));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 267, 267, 500], [502, 502, 559, 559, 3610]], "test": "timeout"}
{"id": "WlsyW4", "name": "BoS - Dawn to Dusk Transition", "author": "zeta", "description": "Hi there! I'm learning shaders, feedback is always welcome!\n\nhttps://thebookofshaders.com/06/\nExercise: animate a transition between a sunrise and sunset using u_time.", "tags": ["bookofshaders"], "likes": 2, "viewed": 215, "published": "Public API", "date": "1592101306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TIME_SPEED = .2;\nconst float SUN_COLOR_SIZE = 3.;\n\nconst float PI = 3.14159265359;\n\nconst vec3[] sky = vec3[](\n    vec3(2., 28., 78.) / 255.,     // night\n    vec3(12., 228., 223.) / 255.   // day\n);\n\nconst vec3[] sun = vec3[](\n    vec3(255., 102., 0.) / 255.,   // dusk\n    vec3(255., 253., 195.) / 255.  // dawn\n);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = iTime * TIME_SPEED;\n    float sun_h = sin(time);\n    \n    vec3 sky_col = mix(sky[0], sky[1], smoothstep(-1., 1., sun_h));\n    vec3 sun_col = mix(sun[0], sun[1], smoothstep(-1., 1., sun_h));\n    \n    vec3 col;\n    if (uv.y < sun_h) {\n    \tcol = mix(sky_col, sun_col, smoothstep(sun_h-(SUN_COLOR_SIZE/2.), sun_h, uv.y));\n    } else {\n        col = mix(sun_col, sky_col, smoothstep(sun_h, sun_h+(SUN_COLOR_SIZE/2.), uv.y));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 386, 386, 909]], "test": "error"}
{"id": "WlsyWH", "name": "MK-model ", "author": "margotaro", "description": "Hey look it's cool", "tags": ["3d"], "likes": 2, "viewed": 56, "published": "Public", "date": "1591988974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int TRIANGLES_COUNT = 60;\nconst int VERTICES_COUNT = 38;\n\nconst vec3 vertices[VERTICES_COUNT] = vec3[] (\n    vec3(0.2, 1.4, 0.),//0\n    vec3(0.4,  1.4, 0.),//1 \n    vec3(0.4,  -1.6, 0.),//2 \n    vec3(0.2,  -1.6, 0.),//3\n    vec3(0.2,  0., 0.),//4\n    vec3(0.,  0., 0.),//5\n    vec3(-0.2, 1.4, 0.),//6\n    vec3(-0.2,  0., 0.),//7\n    vec3(0.,  -0.8, 0.),//8\n    vec3(-0.4,  1.4, 0.),//9\n    vec3(-0.2,  -1.6, 0.),//10\n    vec3(-0.4,  -1.6, 0.),//11\n    vec3(0.2, 1.4, 0.2),//12\n    vec3(0.4,  1.4, 0.2),//13 \n    vec3(0.4,  -1.6, 0.2),//14 \n    vec3(0.2,  -1.6, 0.2),//15\n    vec3(0.2,  0., 0.2),//16\n    vec3(0.,  0., 0.2),//17\n    vec3(-0.2, 1.4, 0.2),//18\n    vec3(-0.2,  0., 0.2),//19\n    vec3(0.,  -0.8, 0.2),//20\n    vec3(-0.4,  1.4, 0.2),//21\n    vec3(-0.2,  -1.6, 0.2),//22\n    vec3(-0.4,  -1.6, 0.2),//23\n    vec3(-0.4,  1.4, 0.4),//24\n    vec3(-0.4,  1.4, 0.6),//25\n    vec3(-0.4,  0.2, 0.2),//26\n    vec3(-0.4,  -0.2, 0.3),//27\n    vec3(-0.4,  -0.6, 0.2),//28\n    vec3(-0.4,  -1.6, 0.4),//29\n    vec3(-0.4,  -1.6, 0.6),//30\n    vec3(-0.2,  1.4, 0.4),//31\n    vec3(-0.2,  1.4, 0.6),//32\n    vec3(-0.2,  0.2, 0.2),//33\n    vec3(-0.2,  -0.2, 0.3),//34\n    vec3(-0.2,  -0.6, 0.2),//35\n    vec3(-0.2,  -1.6, 0.4),//36\n    vec3(-0.2,  -1.6, 0.6)//37\n);\n\nconst int trinagleIndexes[TRIANGLES_COUNT * 3] = int[] (\n    0, 2, 1,//M1\n    3, 2, 0,//M1\n    0, 5, 4,//M1\n    6, 7, 5,//M1\n    7, 8, 4,//M1\n    6, 9, 10,//M1\n    9, 11, 10,//M1-7\n    12, 13, 14,//M2\n    14, 15, 12,//M2\n    12, 16, 17,//M2\n    19, 18, 17,//M2\n    20, 19, 16,//M2\n    18, 22, 21,//M2\n    21, 22, 23,//M2-14\n    1, 2, 13,//MS\n    13, 2, 14,//MS\n    15, 2, 14,//MS\n    2, 3, 15,//MS\n    4, 16, 15,//MS\n    3, 4, 15,//MS-20\n    4, 20, 16,//MS\n    4, 8, 20,//MS\n    8, 7, 20,//MS\n    20, 7, 19,//MS\n    7, 22, 19,//MS\n    7, 10, 22,//MS\n    11, 10, 22,//MS\n    11, 23, 22,//MS  \n    23, 11, 9,//K2\n    9, 21, 23,//K2-30   \n    9, 18, 21,//MS      \n    6, 18, 9,//MS \n    18, 6, 5,//MS \n    17, 18, 5,//MS   \n    5, 0, 17,//MS      \n    0, 12, 17,//MS      \n    0, 1, 12,//MS    \n    13, 1, 12,//MS    \n    24, 25, 26,//K1 -39      \n    26, 25, 27,//K1 -40          \n    28, 26, 27,//K1       \n    27, 29, 28,//K1        \n    27, 30, 29,//K1    \n    32, 31, 33,//K2       \n    32, 33, 34,//K2          \n    35, 34, 33,//K2          \n    35, 36, 34,//K2        \n    34, 36, 37,//K2     \n    26, 33, 24,//KS  ??        \n    24, 33, 31,//KS ??-50       \n    24, 31, 32,//KS ??\n    25, 32, 24,//KS ?? \n    32, 27, 25,//KS       \n    27, 32, 34,//KS          \n    27, 34, 30,//KS          \n    37, 30, 34,//KS        \n    36, 30, 37,//KS         \n    36, 30, 29,//KS        \n    29, 35, 28,//KS         \n    29, 36, 35//KS \n);\n    \nconst vec3 triangleColor[TRIANGLES_COUNT] = vec3[] (\n    vec3(1., 0.5, 0.1),//1\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),//10\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),//20\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),//30\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),//35\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1),\n    vec3(1., 0.5, 0.1)\n);\n\nmat4 t() {\n    float time = iTime * 0.5;\n    return mat4(\n        vec4(1. * cos(time), 0., sin(time), 0.),\n        vec4(0., 1., 0., 0.),\n        vec4(-sin(time), 0., 1.* cos(time), 3.),\n        vec4(0., 0., 0., 1.)\n    );\n}\n\nvec3 v(int i) {\n    return (vec4(vertices[i], 1.) * t()).xyz;\n}\n\nvec3 normalOfTriangle(int index) {\n    vec3 root = v(trinagleIndexes[index * 3]);\n    vec3 d1 = v(trinagleIndexes[index * 3 + 1]) - root;\n    vec3 d2 = v(trinagleIndexes[index * 3 + 2]) - root;\n    return cross(d1, d2);\n}\n\nbool sameSide(vec3 base, vec3 p1, vec3 p2) {\n    return dot(cross(base, p1), cross(base, p2)) >= 0.;\n}\n\nbool pointInsideTriangle(vec3 point, int i) {\n    vec3 a = v(trinagleIndexes[i * 3]);\n    vec3 b = v(trinagleIndexes[i * 3 + 1]);\n    vec3 c = v(trinagleIndexes[i * 3 + 2]);\n    return sameSide(b - a, point - a, c - a) &&\n        sameSide(c - b, point - b, a - b) &&\n        sameSide(a - c, point - c, b - c);\n}\n\nbool testTriangle(int index, vec3 ray, out float colissionZ) {\n    int rootVertexIndex = trinagleIndexes[index * 3];\n    vec3 rootVertex = v(rootVertexIndex);\n    vec3 normal = normalOfTriangle(index);\n    \n    float t = dot(rootVertex, normal) / dot(ray, normal);\n    vec3 intersectionPoint = ray * t;\n    \n    colissionZ = intersectionPoint.z;\n    \n    return pointInsideTriangle(intersectionPoint, index);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - vec2(1.);\n    \n    bool anyTriangle = false;\n    float minimalZ = 9999.;\n    int i = 0;\n    int triangleIndex = 0;\n    float currentZ = 0.;\n    vec3 ray = vec3(uv, 1.);\n    vec3 normal = vec3(0);\n    for (; i < TRIANGLES_COUNT; i++) {\n        if (testTriangle(i, ray, currentZ)) {\n            if (minimalZ > currentZ) {\n                minimalZ = currentZ;\n              triangleIndex = i;\n        normal = normalOfTriangle(i);\n              normal /= length(normal);\n              anyTriangle = true;\n            }\n        }\n    }\n    if (anyTriangle) {\n        fragColor = vec4(triangleColor[triangleIndex].rgb * normal.x, 1.);\n    } else {\n        fragColor = vec4(0., 0.37, 0.35, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4218, 4218, 4228, 4228, 4441], [4443, 4443, 4458, 4458, 4506], [4508, 4508, 4542, 4542, 4729], [4731, 4731, 4775, 4775, 4833], [4835, 4835, 4880, 4880, 5146], [5148, 5148, 5210, 5210, 5558], [5561, 5561, 5616, 5616, 6372]], "test": "timeout"}
{"id": "Wlsyzn", "name": "ORIGAMI KING GOOMBA", "author": "yasuo", "description": "Hey! I'm Goomba and waiting for Mario, who will stamp on me.", "tags": ["mario", "reproduction"], "likes": 5, "viewed": 274, "published": "Public API", "date": "1591279047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n// The modeling is based on simple plane distance and created a useful custom box distance function that is easy for me to model.\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 80.\n#define SURF_DIST .002\n#define GOOMBA_THICKNESS 0.05\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat customBoxDist(vec3 p, vec4 btm, vec4 top, vec4 rt, vec4 lt, vec4 fw, vec4 b) {\n    float p1 = dot(p,btm.xyz) + btm.w;\n    float p2 = dot(p,top.xyz) + top.w;\n    float p3 = dot(p,rt.xyz) + rt.w;\n    float p4 = dot(p,lt.xyz) + lt.w;\n    float p5 = dot(p,fw.xyz) + fw.w;\n    float p6 = dot(p,b.xyz) + b.w;\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\n// 2D distance box https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 origamiPattern(vec2 p, vec3 col, vec3 colA, vec3 colB) {\n    mat2 rot = Rot(radians(45.0));\n\tfloat d = sdBox(p*rot,vec2(0.1));\n    d = max(-p.x,d);\n    col = mix(col,colA,S(d,0.0));\n    d = sdBox(p*rot,vec2(0.1));\n    d = max(p.x,d);\n    col = mix(col,colB,S(d,0.0));\n    return col;\n}\n\nvec3 background(vec2 p, vec3 col){\n    p*=2.0;\n    p.x+=sin(iTime*0.5)*1.0;\n    vec2 prevP = p;\n    vec3 colA = vec3(0.5,0.7,0.8)*1.05;\n    vec3 colB = vec3(0.4,0.6,0.7)*1.15;\n    \n    p.x = mod(p.x,0.29)-0.145;\n    p.y = mod(p.y,0.29)-0.145;\n    \n    col = origamiPattern(p,col,colA,colB);\n    p = prevP;\n    \n    p.x+=0.145;\n    p.y+=0.145;\n\tp.x = mod(p.x,0.29)-0.145;\n    p.y = mod(p.y,0.29)-0.145;\n    \n    col = origamiPattern(p,col,colA,colB);\n    \n    return col;\n}\n\nvec3 floorMat(vec2 p, vec3 col){\n    p*=0.3;\n    vec2 prevP = p;\n    vec3 colA = vec3(0.3,0.5,0.3);\n    vec3 colB = vec3(0.3,0.5,0.3)*0.9;\n    \n    p.x = mod(p.x,0.28)-0.14;\n    p.y = mod(p.y,0.28)-0.14;\n    \n    col = origamiPattern(p,col,colA,colB);\n    p = prevP;\n    \n    p.x+=0.14;\n    p.y+=0.14;\n\tp.x = mod(p.x,0.28)-0.14;\n    p.y = mod(p.y,0.28)-0.14;\n    \n    col = origamiPattern(p,col,colA,colB);\n    \n    return col;\n}\n\nfloat goombaDist1(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm\n    vec4 a2 = vec4(-3.0,-size,0.0,1.5); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.2); // right     \n    vec4 a4 = vec4(-size,1.0,0.0,0.3); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist2(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm \n    vec4 a2 = vec4(0.0,-size,0.0,1.9); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.7); // right      \n    vec4 a4 = vec4(-size,0.0,0.0,0.7); // left         \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward              \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist3(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm\n    vec4 a2 = vec4(-0.5,-size,0.0,0.3); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.5); // right      \n    vec4 a4 = vec4(-size,0.7,0.0,0.75); // left           \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward            \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist4(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(-0.7,size,0.0,0.3); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,0.3); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.4); // right      \n    vec4 a4 = vec4(-size,0.0,0.0,0.0); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward            \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist5(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,0.3); // top   \n    vec4 a3 = vec4(size,0.0,0.0,0.2); // right       \n    vec4 a4 = vec4(-size,0.0,0.0,0.2); // left           \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward               \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return  customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist6(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.3); // btm\n    vec4 a2 = vec4(-1.0,-size,0.0,0.04); // top   \n    vec4 a3 = vec4(size,0.0,0.0,0.1); // right        \n    vec4 a4 = vec4(-size,0.0,0.0,0.1); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward               \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist7(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,0.3); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,0.105); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.08); // right       \n    vec4 a4 = vec4(-size,0.0,0.0,0.08); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward               \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist8(vec3 p) {\n    float size = 2.0;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,-1.0); // btm\n    vec4 a2 = vec4(-size*2.0,-size,0.0,3.0); // top  \n    vec4 a3 = vec4(size,-size*0.5,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,1.0,0.0,1.0); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist9(vec3 p) {\n    float size = 1.5;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(-0.3,size,0.0,-0.8); // btm\n    vec4 a2 = vec4(0.5,-size,0.0,1.0); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.7); // right     \n    vec4 a4 = vec4(-size,-1.5,0.0,1.5); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist10(vec3 p) {\n    float size = 2.0;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,-1.4); // btm\n    vec4 a2 = vec4(-size*2.0,-size,0.0,2.0); // top  \n    vec4 a3 = vec4(size,-size*0.5,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,1.0,0.0,1.0); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat goombaDist11(vec3 p) {\n    float size = 2.0;\n    float thickness = GOOMBA_THICKNESS;\n    vec4 a1 = vec4(0.0,size,0.0,-1.6); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,2.0); // top  \n    vec4 a3 = vec4(size,0.0,0.0,0.33); // right     \n    vec4 a4 = vec4(-size,0.0,0.0,0.33); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat floorDist(vec3 p) {\n    float size = 1.0;\n    \n    vec4 a1 = vec4(0.0,size,0.0,0.0); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,0.05); // top  \n    vec4 a3 = vec4(size,0.0,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,0.0,-size*0.5,1.0); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,1.0); // foward\n    vec4 a6 = vec4(0.0,0.0,size,1.0); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nvec4 goomba(vec3 p) {\n    vec3 prevP = p;\n    \n    // face1\n    p.x = abs(p.x);\n    p.x-=0.6;\n    float g1 = goombaDist1(p);\n    p = prevP;\n    float g2 = goombaDist2(p);\n    float resG = min(g1,g2);\n    \n    vec4 res1 = vec4(vec3(0.7,0.38,0.0),resG*0.5);\n        \n    // kind of chin, don't know what we call this part.\n    p.x = abs(p.x);\n    p.x-=0.3;\n    \n    mat3 rot = matRotateX(radians(-20.0));\n    \n    g1 = goombaDist3((p-vec3(0.0,0.0,0.2))*rot);\n    resG = g1;\n    p = prevP;\n    vec4 res2 = vec4(vec3(0.7,0.38,0.0),resG*0.5);\n    \n    // body\n    p.x = abs(p.x);\n    p.x-=0.4;\n    g1 = goombaDist4(p-vec3(0.0,-0.4,0.1));\n    p = prevP;\n    g2 = goombaDist5(p-vec3(0.0,-0.4,0.1));\n    p = prevP;\n    resG = min(g1,g2);\n    vec4 res3 = vec4(vec3(0.9,0.8,0.5),resG*0.5);\n    \n    // legs\n    p*=0.8;\n    p.x = abs(p.x);\n    p.x-=0.4;\n  \n    p.x = abs(p.x);\n    p.x-=0.16;\n    g1 = goombaDist6(p-vec3(0.0,-0.5,0.05));\n    \n    p.x+=0.12;\n    g2 = goombaDist7(p-vec3(0.0,-0.5,0.05));\n    resG = min(g1,g2);\n    vec4 res4 = vec4(vec3(0.5,0.2,0.0),resG*0.5);\n    p = prevP;\n    \n    // teeth\n    p.x*=2.0;\n    p.x = abs(p.x);\n    p.x-=0.95;\n    g1 = goombaDist8(p-vec3(0.0,-0.7,0.1));\n    resG = g1;\n    vec4 res5 = vec4(vec3(1.0),resG*0.5);\n    p = prevP;\n    \n    // eyebrow\n    p.x = abs(p.x);\n    p.x-=0.5;\n    g1 = goombaDist9(p-vec3(0.0,0.5,0.1));\n    resG = g1;\n    vec4 res6 = vec4(vec3(0.3),resG*0.5);\n    p = prevP;\n    \n    // eye\n    p.x = abs(p.x);\n    p.x -=0.3;\n    p.y -= 0.65;\n    p.x*=0.9;\n    p.y*=1.5;\n    p.y = abs(p.y);\n    p.y+=0.55;\n    g1 = goombaDist10(p-vec3(0.0,0.0,0.1));\n    p = prevP;\n\tp.x = abs(p.x);\n    p.x -=0.3;\n    p.y -= 0.6;\n    g2 = goombaDist11(p-vec3(0.0,-0.85,0.1));\n    resG = min(g1,g2);\n    vec4 res7 = vec4(vec3(1.0),resG*0.5);\n    p = prevP;\n    \n    // eye ball\n    p.x*=2.0;\n    p.y*=0.8;\n    p.x = abs(p.x);\n    p.x -=0.6;\n\tg1 = goombaDist11(p-vec3(0.0,-0.37,0.13));\n    resG = g1;\n    vec4 res8 = vec4(vec3(0.1),resG*0.5);\n    \n    return combine(combine(combine(combine(combine(combine(combine(res1,res2),res3),res4),res5),res6),res7),res8);\n}\n\nfloat fflowerDist1(vec3 p) {\n\tfloat size = 3.5;\n    float thickness = GOOMBA_THICKNESS;\n    \n    vec4 a1 = vec4(0.0,size,0.0,0.5); // btm\n    vec4 a2 = vec4(-2.0,-size,0.0,1.0); // top  \n    vec4 a3 = vec4(size,0.0,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,0.0,0.0,0.75); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat fflowerDist2(vec3 p) {\n\tfloat size = 3.5;\n    float thickness = GOOMBA_THICKNESS;\n    \n    vec4 a1 = vec4(0.0,size,0.0,1.86); // btm\n    vec4 a2 = vec4(0.0,-size,0.0,1.86); // top  \n    vec4 a3 = vec4(size,0.0,0.0,1.0); // right     \n    vec4 a4 = vec4(-size,0.0,0.0,0.8); // left          \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    return customBoxDist(p,a1,a2,a3,a4,a5,a6)*0.6;\n}\n\nfloat leafDist(vec3 p) {\n    vec3 prevP = p;\n    p.x*=0.9;\n    p.x = abs(p.x);\n    p.x -=0.5;\n    p.y = abs(p.y);\n    p.y -= 0.1;\n    float f1 = fflowerDist1(p);\n    p = prevP;\n    p.x*=0.9;\n    float f2 = fflowerDist2(p);\n    \n    return min(f1,f2);\n}\n\nvec4 fflower(vec3 p) {\n    vec3 prevP = p;\n\tfloat f1 = leafDist(p-vec3(0,0.6,0.0));\n    float resF = f1;\n    vec4 res1 = vec4(vec3(0.9,0.0,0.0),resF*0.5);\n    p = prevP;\n    \n    p.xy*=1.3;\n    f1 = leafDist(p-vec3(0,0.8,0.05));\n    resF = f1;\n    vec4 res2 = vec4(vec3(1.0,0.6,0.0),resF*0.5);\n    p = prevP;\n    \n    p.xy*=1.8;\n    f1 = leafDist(p-vec3(0,1.1,0.1));\n    resF = f1;\n    vec4 res3 = vec4(vec3(1.0,0.9,0.0),resF*0.5);\n    p = prevP;\n    \n    // eye\n    p.x*=5.0;\n    p.y*=4.0;\n    p.x = abs(p.x);\n    p.x-=1.0;\n    f1 = fflowerDist2(p-vec3(0,2.5,0.15));\n    resF = f1;\n\tvec4 res4 = vec4(vec3(0.1),resF*0.5);\n    p = prevP;\n    \n    // branch\n    p.x*=2.5;\n    f1 = fflowerDist2(p-vec3(0,-0.15,-0.05));\n    resF = f1;\n\tvec4 res5 = vec4(vec3(0.5,0.9,0.0),resF*0.5);\n    p = prevP;\n    \n    // leaf\n    mat3 rot = matRotateZ(radians(50.0));\n    p.y+=0.2;\n    p.x = abs(p.x);\n    p.x -=0.5;\n    p*=rot;\n    p.x *=1.8;\n    p.y *=1.2;\n    \n    p.xy = abs(p.xy);\n    p.xy -= vec2(0.2,0.1);\n    \n    f1 = fflowerDist1((p-vec3(0,0.0,-0.05)));\n    resF = f1;\n\tvec4 res6 = vec4(vec3(0.4,0.9,0.0),resF*0.5);\n    \n    return combine(combine(combine(combine(combine(res1,res2),res3),res4),res5),res6);\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n\t\n    // ground\n    p.xz*=0.2;\n    p.xz = abs(p.xz);\n    p.xz -=1.;\n\n    float _floor = floorDist(p+vec3(0.0,0.7,0.0));\n    vec4 f = vec4(floorMat(prevP.xz,vec3(0.5,0.7,0.8)),_floor*0.6);\n    \n    // goomba\n    p = prevP;\n    float c = 2.0;\n    p.z+=3.0;\n    float l = 2.0;\n    p.z += -c*clamp(round(p.z/c),-l,l);\n    \n    float k = sin(iTime*6.0)*0.1;\n    c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    p.xz*=m;\n    \n    mat3 rot = matRotateX(radians(sin(iTime*6.0)*5.0));\n    vec4 g = goomba((p -vec3(0.0,0.25,0.0))*rot);\n    \n    // fire flower\n    p = prevP;\n    p.z+=2.5;\n    p.x=abs(p.x);\n    p.x-=3.0;\n    vec4 ff = fflower(p);\n    \n    vec4 model = combine(f,combine(g,ff));\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    float shadow = shadowMap(p + n * 0.001, l);\n\n    return vec2((lambert+dif),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(180.0)+radians(sin(iTime*0.5)*60.0));\n    ro.yz *= Rot(radians(30.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(0.5,0.7,0.8);\n        col = background(uv,col)*1.2;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlsyzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[802, 802, 843, 843, 934], [936, 936, 972, 972, 1014], [1016, 1016, 1100, 1100, 1404], [1406, 1501, 1538, 1538, 1618], [1620, 1620, 1681, 1681, 1910], [1912, 1912, 1946, 1946, 2384], [2386, 2386, 2418, 2418, 2815], [2817, 2817, 2844, 2844, 3269], [3271, 3271, 3298, 3298, 3737], [3739, 3739, 3766, 3766, 4206], [4208, 4208, 4235, 4235, 4673], [4675, 4675, 4702, 4702, 5146], [5148, 5148, 5175, 5175, 5620], [5622, 5622, 5649, 5649, 6094], [6096, 6096, 6123, 6123, 6560], [6562, 6562, 6589, 6589, 7016], [7018, 7018, 7046, 7046, 7483], [7485, 7485, 7513, 7513, 7940], [7942, 7942, 7967, 7967, 8351], [8353, 8353, 8374, 8374, 10454], [10456, 10456, 10484, 10484, 10912], [10914, 10914, 10942, 10942, 11370], [11372, 11372, 11396, 11396, 11624], [11626, 11626, 11648, 11648, 12829], [12831, 12831, 12853, 12853, 13610], [13612, 13612, 13645, 13645, 13898], [13900, 13900, 13934, 13934, 14248], [14250, 14250, 14274, 14274, 14475], [14477, 14477, 14500, 14500, 14847], [14849, 14849, 14891, 14891, 15086], [15088, 15088, 15145, 15145, 15900]], "test": "timeout"}
{"id": "WlXcDj", "name": "Sandstone cave system", "author": "jarble", "description": "These caves are rendered using a [url=https://www.shadertoy.com/view/3tXyRN]\"minimal raymarching\"[/url] shader.\nUse the mouse to look around.", "tags": ["procedural", "3d", "raymarching", "caves"], "likes": 2, "viewed": 279, "published": "Public API", "date": "1593031346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define r iResolution\n#define iterations 500 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 20.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 surface_color(vec3 p)\n{\n    float color1 = length(sin(p))/2.0;\n    return vec3(color1,color1/1.8+sin(length(p)/10.0)/40.0,color1/2.0)/10.0;\n}\n\nfloat SDF1(vec3 p){\n    return length(sin(p*.6)-sin(p))-1.4;\n}\n\nfloat SDF(vec3 p){\n\tfloat to_return = SDF1(p);\n    for(int i = 1; i <5;i++){\n        p += p.yzx/float(i*i);\n    \tto_return = min(to_return,SDF1(p));\n    }\n    return to_return/1.5;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(0,6,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    for(int i=0;i<iterations;i++)\n    {\n        float sd1 = SDF(p);\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(surface_color(p*100.0),0)+l1/100.0)*3.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXcDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 279, 279, 397], [399, 399, 418, 418, 461], [463, 463, 481, 481, 645], [647, 647, 688, 688, 1185]], "test": "timeout"}
{"id": "WlXcR4", "name": "checkerbox", "author": "disambiguator", "description": ".", "tags": ["checkerbox"], "likes": 2, "viewed": 45, "published": "Public", "date": "1591503290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float spacing = 0.2;\nconst float margin = 0.1;\n\nfloat checkerboard(vec2 pos) {\n    vec2 p = mod(pos, spacing);\n    \n    //Smoothstep\n    float w = fwidth(pos.x); // to recover the scaling;\n    p = smoothstep(-w, w, p-.1);\n    \n    // Step\n    //p = step(margin, p);\n    \n    return max(p.x, p.y);\n}\nconst vec3 blue = vec3(0,0,1);\nconst vec3 green = vec3(0,1,0);\nconst vec3 red = vec3(1,0,0);\nconst vec3 black = vec3(0,0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = (fragCoord*2.- iResolution.xy)/iResolution.y;\n    \n    float time = iTime;\n    \n    float blueCheckerboard = checkerboard((pos + time/8.) * sin(time/8.) * (sin(time/8.) + 0.5));\n    float greenCheckerboard = checkerboard((pos - time/16.)* sin(time/8.));\n    float redCheckerboard = checkerboard((pos + time/8.) * sin(time/8.) + vec2(0.2, 0.2*sin(time/8.)));\n    \n    vec3 color =  blueCheckerboard * blue\n        + (1. - blueCheckerboard) * greenCheckerboard * green\n        + (1. - blueCheckerboard) * (1. - greenCheckerboard) * redCheckerboard * red;\n    //fragColor = vec4(color, 1.0);                    \n \n    fragColor = vec4(pow(color,vec3(1./2.2)), 1);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 84, 84, 304], [431, 431, 488, 538, 1219]], "test": "ok"}
{"id": "wlXcRM", "name": "Xor Roller 2", "author": "Chris_M_Thomasson", "description": "Testing out the granularity...", "tags": ["fractal"], "likes": 6, "viewed": 221, "published": "Public API", "date": "1591651248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Chris M. Thomasson's Stupid Simple Xor Roller. ;^)\n// version: pre-alpha 0.0.3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n    vec2 uv = fragCoord.xy / iResolution.xy; \n\n    int x = int(fragCoord.x); \n    int y = int(fragCoord.y); \n\n    int xy_xor = (x + iFrame) ^ (y);\n    //float s = .01 + abs(sin(iTime * .01)) * (abs(cos(iTime * sin(iTime * .05) * .001) * .01));\n    \n    float s = 0.89 + abs(sin(iTime * .0001)) * .1;\n    \n    float cr = mod(float(xy_xor) * 1.1 * s, 1.0);\n    float cg = cr;\n    float cb = cr;\n\t//float cg = mod(float(xy_xor) * abs(sin(iTime * 0.01)) * 1.234 * s, 1.0);\n    //float cb = mod(float(xy_xor) * 2.253 * s, 1.0);\n    \n    float dis = .5 + abs(sin(iTime * .5)) * .3;\n    \n    if (cr < dis)\n    {\n     \tcg = (cr / dis) * .1;\n        cb = (cr / dis) * .2;\n        cr = 0.;\n    }\n    \n    fragColor = vec4(cr, cg, cb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXcRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 139, 139, 872]], "test": "timeout"}
{"id": "wlXcRr", "name": "Funky mist world", "author": "MikeXenix", "description": "Used https://www.shadertoy.com/view/Xds3zN by iq as starting point, Combined with my old https://www.shadertoy.com/view/tlt3WN\nAdded some ray-marched mist also, for funky feeling", "tags": ["mist"], "likes": 2, "viewed": 73, "published": "Public", "date": "1591258165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Modified by MikeXenix\n\n#define RAY_MARCH_STEPS 100\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nvec3 lerp(in vec3 a,in vec3 b, float t){return (1.0-t)*a+t*b;}\nfloat lerp(float a,float b, float t){return (1.0-t)*a+t*b;}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    res = opU(res, vec2(sdHexPrism(vec3(pos.xzy)-vec3(1,1,0),vec2(0.2,0.5)),50.0));\n    res = opU(res, vec2(sdHexPrism(vec3(pos.xzy)-vec3(-1,1,0),vec2(0.2,0.5)),50.0));\n    res = opU(res, vec2(sdHexPrism(vec3(pos.xzy)-vec3(1,-1,0),vec2(0.2,0.5)),50.0));\n    res = opU(res, vec2(sdHexPrism(vec3(pos.xzy)-vec3(-1,-1,0),vec2(0.2,0.5)),50.0));\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\nfloat hexTex(vec2 Tex)\n{\n    float degAlpha = 57.0;\n    \n    float alpha = (degAlpha) / 360.0 * 2.0 * 3.14159, cal = cos(alpha), sal = sin(alpha);\n\tfloat beta = ((90.0 - degAlpha) / 360.0 * 2.0 * 3.14159), cbe = cos(beta), sbe = sin(beta);\n\tfloat r = 0.5 / cbe;\n\tvec2 P1 = vec2(r*sbe, r*cbe);\n\tvec2 P2 = vec2(2.0 * r*cal, 0.0);\n\tvec2 N = normalize(P2 - P1);\n\tfloat D = dot(vec2(-N.y, N.x), P1);\n    \n\tfloat v = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.y), 1.0));\n\tfloat v2 = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.x), 1.0));\n\tfloat d = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D);\n\tfloat d2 = (dot(vec2(-N.y, -N.x), vec2(v2, v)));\n\n\tif (v2 <= r * cal)\n\t{\n\t\tif (d2 > 0.0)\n\t\t\td = abs(d) / D;\n\t\telse if (v < 0.5)\n\t\t\td = abs(0.5 - v) * 2.0;\n\t\telse if (d > 0.0)\n\t\t\td = abs(d2) / D;\n\t\telse\n\t\t\td = abs(0.5 - v) * 2.0;\n\t}\n\telse if (d <= 0.0)\n\t{\n\t\td = abs(d) / D;\n\t}\n\telse\n\t{\n\t\tif (v2 >= 2.0 * r*cal)\n\t\t{\n\t\t\tif (v < 0.5)\n\t\t\t{\n\t\t\t\tvec2 P3 = vec2(0.25, 0.5);\n\t\t\t\tvec2 N2 = normalize(P3 - P2);\n\t\t\t\tfloat D2 = dot(vec2(-N2.y, N2.x), P2);\n\t\t\t\tfloat d3 = (dot(vec2(-N2.y, -N2.x), vec2(v2, v)) - D2);\n\t\t\t\tif (d3 < 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d) / D;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfloat d4 = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D * 2.0);\n\t\t\t\tif (d4 > 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d2) / D;\n\t\t\t}\n\t\t}\n\t\telse if (v > 0.5)\n\t\t\td = abs(dot(vec2(-N.y, -N.x), vec2(v2, v))) / D;\n\t\telse\n\t\t\td = abs(d) / D;\n\t}\n\n    return min(0.999, d);\n}\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = pow(1.0-hexTex(pos.xz),10.0);//checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + vec3(0,f,f);\n            ks = 0.4;\n        }\n\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        }\n        \n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n        \n    }\n        \n    // mist\n    float density = 0.0;\n    vec3 mpos = ro;\n    float delta = t/float(RAY_MARCH_STEPS);\n    for(int i=0;i<RAY_MARCH_STEPS;i++)\n    {\n        float noise = lerp(texture(iChannel0,mpos.xz*0.1).r*texture(iChannel0,mpos.xy*0.5).r,1.0,abs(sin(iTime*0.3)));\n        float heightFog = clamp(1.0-mpos.y*(2.0+0.5*sin(iTime*2.0+mpos.x*0.5*cos(iTime*2.0)+mpos.z*sin(iTime))),0.0,1.0);\n        density+= delta * lerp(1.0,10.0,abs(sin(iTime*0.4))) * heightFog*noise;\n        mpos+=rd*delta;\n    }\n\n\treturn vec3( clamp(lerp(col,vec3(0,1,1),clamp(density,0.0,1.0)),0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 6.0*mo.x), 1.5 + 2.0*mo.y, 4.5*sin(0.1*time + 6.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,2.5) );\n\n    // ray differentials\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = ca * normalize( vec3(px,2.5) );\n    vec3 rdy = ca * normalize( vec3(py,2.5) );\n\n    // render\t\n    \n    fragColor = vec4( render( ro, rd, rdx, rdy ), 1.0 );\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXcRr.jpg", "access": "shaders20k", "license": "mit", "functions": [[1133, 1202, 1227, 1227, 1246], [1247, 1247, 1272, 1272, 1291], [1292, 1292, 1328, 1328, 1356], [1357, 1357, 1397, 1397, 1419], [1420, 1420, 1457, 1457, 1479], [1480, 1480, 1505, 1505, 1520], [1522, 1522, 1558, 1558, 1869], [1942, 1942, 1972, 1972, 2005], [2177, 2177, 2202, 2202, 2595], [2597, 2665, 2716, 2716, 2921], [2923, 2923, 2963, 2963, 3740], [3742, 3806, 3838, 3838, 4408], [4410, 4486, 4550, 4571, 4804], [4805, 4805, 4829, 4829, 6259], [6260, 6260, 6325, 6344, 8237], [8239, 8239, 8291, 8291, 8468], [8470, 8470, 8527, 8527, 9314]], "test": "error"}
{"id": "wlXcRs", "name": "VPyramid", "author": "Del", "description": "Variable Pyramid, scalable with base etc.", "tags": ["pyramid"], "likes": 2, "viewed": 197, "published": "Public API", "date": "1592781212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Variable Pyramid\n// largely IQ's code, adjusted slightly for my requirements (scalable, box aligned and with a working base)\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// signed distance to a pyramid bs=xz size, h = y size\nfloat sdPyramid( in vec3 p, in float bs, in float h )\n{\n    // box adjust\n    p.y += h;\n    vec3 p2 = p;\n    h*=2.0;\n    bs*=2.0;\n    h/=bs;\n    p/=bs;\n    \n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz); // do p=abs(p) instead for double pyramid\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y-0.5*p.x, h*p.x+0.5*p.y);\n        \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*q.x)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = max(-q.y,q.x*m2+q.y*0.5) < 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    float d = sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    \n    // adjust distance for scale\n    //return bs*d;\n    \n    // hacked on the base\n    vec2 fx = abs(p2.xz)-vec2(bs*0.5);\n    float d1 = length(max(fx,0.0)) + min(max(fx.x,fx.y),0.0);\n\tvec2 w = vec2( d1, abs(p2.y) - 0.0001 );\n    d1= min(max(w.x,w.y),0.0) + length(max(w,0.0));    \n    return min(d1,bs*d);\n    \n}\n\nfloat map( in vec3 pos )\n{\n    vec3 size = 0.5+sin(vec3(iTime,iTime*1.5,iTime*2.0))*0.5;\n    float xs = 0.5 + (size.x);\n    float zs = 0.5 + (size.y);\n    float ys = 0.5 + (0.5*size.z);\n    \n    float d1 = sdPyramid(pos,xs, ys);\n    \n    if (iMouse.z>0.5)\n        return d1;\n    \n    float boff = 0.3;\t\t// bounding box offset\n    float bthick = 0.025;\t// bounding box thickness\n    float d3 =  sdBoundingBox(pos,vec3(xs+boff,ys+boff,xs+boff),bthick);\n    d1 = min(d1,d3);\n    return d1;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 5.0*cos(an), -2.5, 5.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 176, 176, 464], [466, 521, 576, 594, 1639], [1641, 1641, 1667, 1667, 2129], [2131, 2195, 2227, 2227, 2465]], "test": "timeout"}
{"id": "wlXczf", "name": "Lord Oculon's Birthday", "author": "blackle", "description": "coded in 1 hour 30 minutes for the Nova 2020 shader freestyle. the sacrificial altar sure looks like a birthday cake!", "tags": ["eyes", "eye", "livecode", "shaderfreestyle"], "likes": 28, "viewed": 444, "published": "Public API", "date": "1592609657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nconst float bpm = 168.;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec3 arot(vec3 p, vec3 a, vec3 b) {\n    vec3 ax = normalize(cross(a,b));\n    float ro = acos(dot(a,b));\n    return erot(p,ax,ro);\n}\n\nvec3 urot(vec3 p, vec3 a, vec3 b, vec3 u) {\n    float ang = atan(dot(u,cross(a,b)), dot(a,b));\n    p = erot(p, u, ang);\n    a = erot(a, u, ang);\n    return arot(p,a,b);\n}\n\nvec3 face(vec3 p) {\n    vec3 ap = abs(p); vec4 k = vec4(sign(p),0);\n    if (ap.x >= max(ap.y,ap.z)) return k.xww;\n    if (ap.y >= max(ap.x,ap.z)) return k.wyw;\n    if (ap.z >= max(ap.y,ap.x)) return k.wwz;\n}\n\nvec3 edge(vec3 p) {\n    vec3 mask = vec3(1)-abs(face(p));\n    vec3 v = sign(p);\n    vec3 a = v*mask.zxy;\n    vec3 b = v*mask.yzx;\n    return distance(p,a)<distance(p,b)?a:b;\n}\n\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a),y=FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat box(vec2 p, vec2 d) {\n    vec2 q = abs(p)-d;\n    return length(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat pentagram(vec2 p) {\n    float dist = 10000.;\n    for (int i = 0; i < 5; i ++ ){\n        float ang = float(i)*3.14/5.*2.;\n        float ang2 = float(i+2)*3.14/5.*2.;\n        vec2 a = vec2(sin(ang), cos(ang));\n        vec2 b = vec2(sin(ang2), cos(ang2));\n        dist = min(linedist(p,a,b),dist);\n    }\n    return dist;\n}\n\nvec3 lpos;\nvec3 id;\nfloat pedistal;\nfloat l1;\nfloat dbg;\nfloat torch;\nfloat scene(vec3 p) {\n    vec3 op = p;\n    \n    vec2 pc = vec2(length(p.xy),p.z);\n    pedistal = box(pc+vec2(0.,3.8), vec2(2.,0.1));\n    float ang = atan(p.x,p.y);\n    pedistal += smoothstep(-.2,.2,sin(ang*100.))*.02;\n    pedistal = min(pedistal, box(pc+vec2(0.,3.8), vec2(1.9,0.15)));\n    float ang2 = round(ang*4.)/4.;\n    vec2 clos = vec2(sin(ang2),cos(ang2))*1.7;\n    \n    float ang3 = round(ang*2.)/2.;\n    vec2 clos2 = vec2(sin(ang3),cos(ang3))*2.;\n    \n    pc = vec2(length(p.xy-clos),p.z);\n    vec2 pc2 = vec2(length(p.xy-clos2),p.z);\n    dbg = sin(min(pentagram(p.xy),pc.x)*100.);\n    pedistal = min(pedistal, box(pc+vec2(0.,4.), vec2(.01,0.8)))-0.03;\n    pedistal = min(pedistal, box(pc2+vec2(0.,6.5), vec2(.1,2.8)));\n    torch = box(pc+vec2(0.,3.2), vec2(.05,0.05));\n    pedistal = min(torch, pedistal);\n    \n    \n    vec3 beyp = vec3(7,0,0);\n    id = floor(p)+.5;\n    vec3 m = sign(mod(id,2.)-1.);\n    if (m.x*m.y*m.z < 0.) id += face(p-id);\n    float sd = hash(hash(id.x,id.z),id.y);\n    if (length(id) < 6. || sd < -0.5 || distance(id,beyp) < 3.7) {\n        id += edge(p-id);\n    }\n    p -= id;\n    float balls = max(5.-length(op),length(p)-.7);\n    l1 = distance(op,lpos) - .3;\n    if (distance(op,beyp) < 3.1) {\n        id = beyp;\n    }\n    balls = min(distance(op,beyp) - 3.,balls);\n    return min(pedistal, min(l1, balls));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float bpmt = iTime/60.*bpm;\n    float t = mix(pow(sin(fract(bpmt)*3.14/2.),50.) + floor(bpmt), bpmt, 0.8);\n    lpos = vec3(sin(t),cos(t),sin(t/3.))*4.;\n    vec3 cam = normalize(vec3(.8 + sin(t*3.14)*.2,uv));\n    vec3 init = vec3(-3.5+cos(t*3.14/2.),0,0) + cam*.1;\n    \n    cam = erot(cam, vec3(0,1,0), sin(t/2.-.5)*.5);\n    init = erot(init, vec3(0,1,0), sin(t/2.)*.5);\n    cam = erot(cam, vec3(0,0,1), cos(t/5.-.5)*.5);\n    init = erot(init, vec3(0,0,1), cos(t/5.)*.5);\n    cam = erot(cam, vec3(1,0,0), (asin(sin(t/2.))*-1.)*.2);\n    init.z -= 2.; \n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    float glo = 0.;\n    float glo2 = 0.;\n    for (int i = 0; i < 100 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        glo += 100./(1.+l1*2000.)*dist;\n        glo2 += 200./(1.+torch*5000.)*dist;\n    }\n    float dbgg = dbg;\n    bool tc = torch == dist;\n    bool pd = dist == pedistal;\n    vec3 lid = id;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    \n    vec3 lookat = normalize(init-lid);\n    vec3 lookat2 = normalize(lpos-lid);\n    lookat = normalize(mix(lookat,lookat2,smoothstep(8.,5.,distance(lid,lpos))));\n\n    vec3 eycrd = urot(n, lookat, vec3(1,0,0), vec3(0,0,1));\n    float ey = eycrd.x;\n    float garble = atan(eycrd.y,eycrd.z) + dot(sin(eycrd.yz*11.),sin(eycrd.yz*25.))*.05;\n    garble = (sin(garble*50.)+sin(garble*131.))*.2+.9;\n    \n    vec3 ldir = normalize(lpos-p);\n    float ao = smoothstep(12.,6.,length(p));\n    float nd = dot(ldir,n)*.5+.5;\n    float rd = max(0.,dot(ldir,n));\n    float fres = 1.-abs(dot(cam,n))*.98;\n    vec3 ecol = vec3(0.3,0.4,0.7);\n    float sd1 = hash(hash(lid.x,lid.y),lid.z);\n    float sd2 = hash(sd1,sd1);\n    ecol = erot(ecol, vec3(0,1,0), sd2);\n    ecol = erot(ecol, vec3(1,0,0), sd1*.4)*garble;\n    float atten = 3./pow(distance(p,lpos),1.4) + .4/pow(length(vec2(length(p.xy)-1.8, p.z+3.2)), 1.2);\n    \n    vec3 dcol = mix(vec3(.9),ecol, smoothstep(.8,.9,ey));\n    dcol = mix(dcol,vec3(0), smoothstep(.95,.98,ey));\n    \n    if (pd) dcol = vec3(0.5,0.4,0.3)*(dbgg*.25+.75);\n    vec3 col = (dcol*nd + pow(smoothstep(.7,1.,rd),100.)*fres*1.2)*ao*atten;\n    if (distance(lpos,p) < .4) {\n        col = vec3(0.2,0.5,0.9);\n    }\n    if (tc) col = vec3(0.8,0.5,0.2);\n    fragColor.xyz = (hit ? col : vec3(.1))+glo*glo + glo*vec3(0.2,0.5,0.9) +glo2*glo2 + glo2*vec3(0.8,0.5,0.2);\n    fragColor = smoothstep(vec4(0.1),vec4(1.02),sqrt(fragColor));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXczf.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[219, 219, 257, 257, 319], [321, 321, 356, 356, 452], [454, 454, 497, 497, 624], [626, 626, 645, 645, 833], [835, 835, 854, 854, 1010], [1068, 1068, 1098, 1098, 1171], [1173, 1173, 1200, 1200, 1278], [1280, 1280, 1320, 1320, 1411], [1413, 1413, 1438, 1438, 1738], [1810, 1810, 1831, 1831, 3153], [3155, 3155, 3174, 3174, 3287], [3289, 3289, 3346, 3346, 5868]], "test": "error"}
{"id": "WlXczH", "name": "sphere uniform point", "author": "Danielhu", "description": "Different sphere uniform distribution algorithms", "tags": ["sphere", "distribution"], "likes": 10, "viewed": 517, "published": "Public API", "date": "1591376455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nmat3 rotate() {\n    float theta = iTime * 0.3;\n    float phi = iTime * 0.3;\n    \n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nbool drawSphere(vec2 coor, vec3 c, float r, out vec3 hit, out vec3 col) {\n    vec3 p = vec3(coor, -1.0);\n    vec3 dir = vec3(0, 0, 1);\n    for (int i = 0; i < 32; ++i) {\n        float sdf = sphere(p, c, r);\n        if (sdf < 0.0001) {\n            hit = p;\n            col = 0.3  + 0.4 * vec3(dot(normalize(hit - c), vec3(0, 0, -1))) * (sin(iTime) * 0.5 + 0.5);\n            return true;\n        }\n        p += sdf * 0.5 * dir;\n    }\n    return false;\n}\n\n#define axis_num 12.0\n#define PI acos(-1.0)\n\nvec3 snapEachAxis(vec3 p, vec3 c, float r) {\n    vec3 col = vec3(0);\n    vec3 rp = (p - c) * rotate();\n    vec3 d = round(rp * axis_num ) / axis_num ;\n    d = normalize(d) * r;\n    col += step(length(rp - d), 0.004);\n    col += (d * 173.0 - round(d * 173.0)) * (1.0 - (sin(iTime) * 0.5 + 0.5)); \n    return col;\n}\n\nvec3 snapSpherical(vec3 p, vec3 c, float r) {\n    vec3 col = vec3(0);\n    vec3 rp = (p - c) * rotate();\n    vec3 d;\n    float phi = asin(rp.z / r);\n    d.z = sin(round(phi / PI * axis_num) / axis_num * PI) * r;\n    float theta = atan(rp.y, rp.x);\n    \n    float xyMag = sqrt(r * r - d.z * d.z);\n    float roundedTheta = round(theta / PI * round(xyMag / r * axis_num) ) * PI / round(xyMag / r * axis_num);\n    \n    d.x = cos(roundedTheta) * xyMag;\n    d.y = sin(roundedTheta) * xyMag;\n    \n   \n    col += step(length(rp - d), 0.005);\n    col += (d * 173.0 - round(d * 173.0)) * (1.0 - (sin(iTime) * 0.5 + 0.5)); \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coor = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    vec3 hit;\n    \n    vec3 col; \n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    if(drawSphere(coor, vec3(-0.45, 0.0, 0), 0.4, hit, col))\n       fragColor.xyz += col + snapEachAxis(hit, vec3(-0.45, 0.0, 0), 0.4);\n    \n    if(drawSphere(coor, vec3(0.45, 0.0, 0), 0.4, hit, col))\n       fragColor.xyz += col + snapSpherical(hit, vec3(0.45, 0.0, 0), 0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 71], [73, 73, 88, 88, 365], [367, 367, 440, 440, 818], [865, 865, 909, 909, 1178], [1180, 1180, 1225, 1225, 1809], [1812, 1812, 1869, 1869, 2293]], "test": "timeout"}
{"id": "wlXczj", "name": "simple animation 3d ball", "author": "hahnzhu", "description": "practice of Ray Marching & Sign Distance Function & Blinn-Phong refrection model with the toturials from [url=https://www.shadertoy.com/user/iq]iq[/url] and [url=https://www.shadertoy.com/user/jlfwong]jlfwong[/url]\n\n", "tags": ["sdf", "blinnphone"], "likes": 1, "viewed": 97, "published": "Public", "date": "1592911987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\n// reference: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat smoothMin(float dstA, float dstB, float k) {\n    float h = max(k-abs(dstA - dstB), 0.) / k;\n    return min(dstA, dstB) - h*h*h*k*1./6.0;\n}\n\nfloat sdBox( vec3 p, vec3 c, vec3 b ) {\n\tvec3 q = abs(p-c) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, vec3 c, float s ) {\n\treturn length(p-c)-s;\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0., 1., 1., 1.);\n\n    float sphereDist = sdSphere(p, s.xyz, s.w);\n    \n    float boxDist = sdBox(p, vec3(sin(iTime),1.,1.), vec3(.5,.5,.5));\n\n    float planeDist = p.y;\n    \n    float d = smoothMin(sphereDist, boxDist, .5);\n\n    return min(d, planeDist);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat d0 = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd * d0; \n        float dS = GetDist(p);\n        d0 += dS; \n        if(d0>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n\treturn d0;\n}\n\n// https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat GetShadow(vec3 p, vec3 ld, float mint, float maxt){\n    for( float t=mint; t<maxt;) {\n        float h = GetDist(p + ld*t);\n        if( h<0.001)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nfloat GetSoftShadow(vec3 p, vec3 ld, float mint, float maxt, float k ) {\n    float res = 1.0;\n    for( float t=mint; t<maxt; ) {\n        float h = GetDist(p + ld*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat GetSoftShadowAdvance( in vec3 ro, in vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 cameraDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p), // forward\n        r = normalize(cross(vec3(0,1,0), f)), // right\n        u = cross(f,r),\t// up\n        c = p+f*z,\t// center\n        i = c + uv.x*r + uv.y*u, // intersection\n        d = normalize(i-p);\t// direction\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = vec3(\n        d - GetDist(p-e.xyy),\n        d - GetDist(p-e.yxy),\n        d - GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetDiffuse(vec3 p, vec3 lo, vec3 lc) {\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lo - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = RayMarch(p+SURF_DIST*2., l);\n    if (d<length(lo-p) && p.y <= 0.01) dif *= .1;\n    return dif * lc;\n}\n\nvec3 GetSpecular(vec3 p, vec3 ro, vec3 lo, vec3 lc) {\n\tvec3 bisector = normalize(lo + ro);\n\tfloat scope = pow(max(0.0, dot(bisector, GetNormal(p))), 200.0);\n    return scope * lc;\n}\n\nvec3 rotate3D(float radius, float phiAngle, float thetaAngle) {    \n    float phi = radians(phiAngle);\t\n    float theta = radians(thetaAngle);\n    \n    return vec3(\n        radius * cos(phi) * cos(theta) * -1.,\n        radius * sin(phi),\n        radius * cos(phi) * sin(theta)\n    );\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*1.5 );\n    float sunAmount = max( dot( rayDir, sunDir ), 0. );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7)*.1, // bluish\n                           vec3(1.0,0.9,0.7)*.1, // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\n\n// source: https://www.shadertoy.com/view/lt33z7\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N), 0., 1.);\n    float dotRV = dot(R, V);\n    \n    //vec3 ro, vec3 rd, float mint, float maxt\n    float shadow = GetSoftShadowAdvance(p+SURF_DIST*2., L, 0., 10., 10.);\n    if (p.y < 0.1) lightIntensity *= shadow;\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse component\n        return lightIntensity * (k_d * dotLN);\n    }\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    vec3 color = k_a;\n    \n    float angle = mod(iTime/10., 1.)*360.;\n    float angle2 = mod(iTime/20., 1.)*360.;\n    \n    vec3 light1Pos = rotate3D(10., 50., angle);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity);\n    //color += applyFog(color, length(eye-p), normalize(eye-p), normalize(light1Pos-p));\n    \n    vec3 light2Pos = rotate3D(5., angle, angle2);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Intensity); \n\t//color += applyFog(color, length(eye-p), normalize(eye-p), normalize(light2Pos-p));\n    \n    return color;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0., 2., 5.);\n    vec3 lookat = vec3(0.);\n    float zoom = 1.;\n    \n    vec3 lightPos = vec3(0, 10., 5.);\n    vec3 lightPos2 = vec3(0, 10., 5.);\n    \n    vec3 ambientColor = vec3(.5, 1., 1.) * .5;\n    vec3 diffuseColor = vec3(1., .5, 1.);\n    vec3 specularColor = vec3(1., 1., 1.);\n    float shininessCoefficient = 50.;\n    \n    float angle = mod(iTime/10., 1.)*360.;\n\tro = rotate3D(length(ro-lookat), 10., angle);\n    \n    vec3 rd = cameraDir(uv, ro, lookat, zoom); \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 phongColor = phongIllumination(ambientColor, diffuseColor, specularColor, shininessCoefficient, p, ro);\n    \n    fragColor = vec4(phongColor,1.0);\n    //fragColor = vec4(vec3(shadow),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 172, 218, 218, 250], [252, 252, 294, 294, 326], [328, 328, 375, 375, 408], [410, 410, 460, 460, 554], [556, 556, 595, 595, 682], [684, 684, 727, 727, 752], [754, 754, 777, 777, 1052], [1054, 1054, 1088, 1088, 1300], [1302, 1369, 1426, 1426, 1582], [1584, 1584, 1656, 1656, 1868], [1870, 1870, 1956, 1956, 2286], [2289, 2289, 2339, 2339, 2599], [2601, 2601, 2625, 2625, 2813], [2815, 2815, 2858, 2912, 3134], [3136, 3136, 3189, 3189, 3317], [3319, 3319, 3382, 3382, 3604], [3607, 3607, 3852, 3852, 4174], [4228, 4720, 4860, 4860, 5621], [5623, 5993, 6078, 6078, 6783], [6787, 6787, 6842, 6842, 7652]], "test": "timeout"}
{"id": "wlXczS", "name": "1st time: value noise", "author": "bipinoli", "description": "Learning from the amazing:\nhttps://www.shadertoy.com/user/BigWIngs\n\nFollowing his youtube tutorials: \"The art of code\" (https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg)", "tags": ["learningshaders"], "likes": 1, "viewed": 40, "published": "Public", "date": "1592325862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float randomNoise(vec2 uv) {\n\treturn fract(sin(uv.x*500. + uv.y*521.)*1251.);\n}\n\nfloat noise(vec2 uv) {\n \t// idea:\n    // 1: generate a grid\n    // 2: for each cell in a grid\n    //    \t1. put random values at vertices of the grid\n    //\t\t2. smoothly interpolate values inside the grid\n    \n    vec2 insideGrid = fract(uv*10.); // [0-1] -> linear\n    vec2 gridId = floor(uv*10.);\n    \n\tinsideGrid = smoothstep(0., 1., insideGrid); // [0-1] -> non-linear \n    \n    float vBottomLeft = randomNoise(gridId);\n    float vTopLeft = randomNoise(gridId + vec2(0., 1.));\n    float vBottomRight = randomNoise(gridId + vec2(1., 0.));\n    float vTopRight = randomNoise(gridId + vec2(1., 1.));\n    \n    float interpolatedValue1 = mix(vBottomLeft, vTopLeft, insideGrid.y);\n    float interpolatedValue2 = mix(vBottomRight, vTopRight, insideGrid.y);\n    float interpolatedValue = mix(interpolatedValue1, interpolatedValue2, insideGrid.x);\n    \n    return interpolatedValue;  \n}\n\n\nfloat superimposedNoise(vec2 uv) {\n    // lets superimpose multiple harmonics of the noise for \n    // better result\n    float freq = .4;\n    float amp = 1.;\n    \n    float c = noise(uv*freq) * amp; // fundamental\n    c += noise(uv*freq*2.) * amp/2.; // 2nd harmonics\n    c += noise(uv*freq*4.) * amp/4.; // 4th harmonics\n    c += noise(uv*freq*8.) * amp/8.; // 8th harmonics\n    c += noise(uv*freq*16.) * amp/16.; // 16th harmonics\n    c += noise(uv*freq*32.) * amp/32.; // 32nd harmonics\n    c += noise(uv*freq*64.) * amp/64.; // 64th harmonics\n    \n    //normalize c\n    c /= 2.;\n    \n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n   \n\tuv.x += fract(iTime * 0.04);\n    \n    float c = superimposedNoise(uv);\n    \n    vec3 col = vec3(c);\n    //col.gb = insideGrid;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXczS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 79], [81, 81, 103, 285, 961], [964, 964, 998, 1080, 1567], [1570, 1570, 1627, 1627, 1878]], "test": "timeout"}
{"id": "WlXczX", "name": "Polar Flow", "author": "Oggbog", "description": "Messing about with polar coords", "tags": ["polar"], "likes": 2, "viewed": 176, "published": "Public API", "date": "1592728870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.2831853\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 pv = vec2(atan(uv.x,uv.y),length(uv));\n                   \n    uv = vec2(pv.x/TWO_PI+0.5,pv.y);\n   \n    float a = TWO_PI*TWO_PI;\n    float b = TWO_PI/2.;\n    \n\tuv.x += iTime*.01;\n    uv.y += -iTime*.1;\n    float d = b*tan(uv.x/TWO_PI*a)*cos(uv.x/TWO_PI*a)/tan(sin(uv.y/TWO_PI*a));\n    \n    \n    d = floor(d*2.)/16.;\n    vec3 col = vec3(d/2.,d-.4,smoothstep(1.,d,pv.y));\n\t\n    \n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor,vec4(1./2.2))-.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 83, 620]], "test": "ok"}
{"id": "wlXyD8", "name": "Moving Globule", "author": "Mogster", "description": "meh", "tags": ["time", "circle", "globule"], "likes": 1, "viewed": 37, "published": "Public", "date": "1591936167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Generic random function\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     // Find coordinate, flexible to different resolutions\n    float maxSize = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord.xy / maxSize;\n    \n// Find center, flexible to different resolutions\n    vec2 center = iResolution.xy / maxSize / 2.;\n    \tconst float radius = 0.2;\n\n    #define SPEED 0.0025\n    float timeMod = (sin(iTime) + 1.0) * 2.5;\n\n    float randX = sin(uv.x * timeMod * 10.0);\n    float randY = sin(uv.y * timeMod * 5.0);\n    //float rand2 = sin(rand(uv) * iTime * SPEED);;\n    vec2 disp = vec2(randX, randY);\n    disp.x += cos(iTime) * 3.0;\n    disp.y += sin(iTime) * 3.0;\n    uv.xy -= disp.xy * 0.025;\n    \n        float dist = length(uv - center);\n    \tfloat strength = step(dist, radius); \n    \tvec3 col = vec3(strength);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 28, 48, 48, 120], [122, 122, 179, 288, 1043]], "test": "timeout"}
{"id": "wlXyDN", "name": "Dodecahedralis IV", "author": "sl2c", "description": "Another hyperbolic geometry fractal based on right-angled dodecahedra.  This one is designed to produce lots of copies of the limit curve in Dodecahedralis I.", "tags": ["fractal", "circles", "hyperbolic"], "likes": 11, "viewed": 61, "published": "Public", "date": "1592258708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nbool flip(inout vec3 z, in vec2 c, in float r, inout int t, in int k) {\n    z.xy -= c;\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        z *= r * r / dot(z,z);\n        t = k - t;\n    }\n    z.xy += c;\n    return res;\n}\n\nbool inside(in vec3 z, in vec2 c, in float r, inout float t) {\n    vec3 p = z - vec3(c,0.0);\n    float res = (dot(p,p)-r*r) / (2.0 * abs(r) * p.z);\n    t = min(t, abs(res));\n    return res < 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.0 / iResolution.y;\n    vec3 z = vec3(z0,ds);\n    \n    vec2[12] c; float[12] r;\n    float r1 = pow(1.5 + 0.5 * sqrt(5.0) - sqrt(1.5 * sqrt(5.0) + 2.5), 0.5);\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1 * sqrt(sqrt(5.0));\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<5; i++) {\n        float theta = tau * 0.2 * float(i);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+6] = r3;\n        c[i+6] = x3 * eit;\n    }\n    float r4 = -1.0 / r1;\n    r[11] = r4; c[11] = vec2(0.0);\n    \n    float period = -4.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    z *= exp(-d);\n    \n    bool fl = false;\n    float yellow = 0.0;\n    int t = 1;\n    int s1 = 0; int s2 = 0; int s3 = 0;\n    bool fl1 = false; bool fl2 = false; bool fl3 = false;\n    for (int i=0; i<7; i++) {\n        fl = fl ^^ flip(z, c[0], r[0], t, 0);\n        fl = fl ^^ flip(z, c[2], r[2], t, 0);\n        fl = fl ^^ flip(z, c[5], r[5], t, 0);\n        fl = fl ^^ flip(z, c[7], r[7], t, 0);\n        fl = fl ^^ flip(z, c[10], r[10], t, 0);\n        fl = fl ^^ flip(z, c[11], r[11], t, 0);\n        \n        fl1 = fl1 ^^ flip(z, c[1], r[1], s1, -1);\n        fl2 = fl2 ^^ flip(z, c[3], r[3], s2, 1);\n        fl3 = fl3 ^^ flip(z, c[4], r[4], s3, 1);\n        fl1 = fl1 ^^ flip(z, c[6], r[6], s1, 1);\n        fl2 = fl2 ^^ flip(z, c[8], r[8], s2, -1);\n        fl3 = fl3 ^^ flip(z, c[9], r[9], s3, -1);\n    }\n    if (fl1) {s1=-s1;}\n    if (fl2) {s2=-s2;}\n    if (fl3) {s3=-s3;}\n    float st = float(s1*s1+s2*s2+s3*s3);\n    \n    st = st / (3.0 + abs(st));\n    vec3 col = vec3(0.5 + st * 0.45); col.g *= 0.8; col.b *= 0.6;\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXyDN.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[485, 485, 547, 547, 682]], "test": "timeout"}
{"id": "wlXyDX", "name": "Julia - Triangle Inequality", "author": "iq", "description": "Triangle Inequality coloring, designed by Damien M. Jones and Javier Barrallo. This is an adaptation of code I wrote in 2001. Unfortunately it only works in double precision, so what you see is an incomplete picture (hairs/flumes should be way longer)", "tags": ["2d", "fractal", "julia", "triangleinequality"], "likes": 12, "viewed": 464, "published": "Public API", "date": "1593285805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Triangle Inequality coloring. This is an adaptation of\n// code I wrote in 2001. The algorihtm was designed by \n// Damien M. Jones and Javier Barrallo who were trying to\n// measure the average orbit curvature.\n//\n// The algorithm requires double precision floating point\n// numbers, which GLSL doesn't support. See line 32. So\n// this image you see here is just an approximation to the\n// real image, which should have way longer hairs going out\n// all the way to the border of the image.\n\n\n#define AA 2\n\nvec3 render( vec2 p, float time )\n{\n    // animation\n\tfloat ltime = 0.5-0.5*cos(time*0.06);\n    float zoom = pow( 0.9, 40.0*ltime );\n\tvec2  cen = vec2( 0.2655,0.301 ) + zoom*0.8*cos(4.0+2.0*ltime);\n\tvec2 c = vec2( -0.745, 0.186 ) - 0.045*zoom*(1.0-ltime*0.5);\n\n    // pixel to z plane\n    p = (2.0*p-iResolution.xy)/iResolution.y;\n\tvec2 zo = cen + (p-cen)*zoom;\n    \n    // iteration\n    float th  = 1e7; // th needs to be way bigger to work well, but in\n    float ld2 = 1.0; // WebGL we only have floats, so it that sucks!\n    const int kNumIterations = 2048;\n    vec2  z = zo;\n    float lz2 = dot(z,z);\n    float ti_av1 = 0.0;\n    float ti_av2 = 0.0;\n\tfloat ti_lc = length(c);\n    float n = 0.0;\n    for( int i=0; i<kNumIterations; i++ )\n\t{\n        // z' = 2·z·z', derivative of z for distance computation\n        ld2 *= 4.0*lz2; \n        \n        // z = z²+c\n        z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n        \n        // escape condition\n\t\tfloat olz2 = lz2;\n        lz2 = dot(z,z);\n\t\tif( lz2>th*th ) break;\n        \n        // triangle inequality\n        if( i>0 )\n        {\n        \tti_av2 = ti_av1;\n            float mi = abs(olz2 - ti_lc);\n            float ma = olz2 + ti_lc;\n            ti_av1 += (sqrt(lz2)-mi)/(ma-mi);\n        }\n        \n        // iteration counter\n        n += 1.0;\n\t}\n    \n    // --- properties ---\n    \n    // continuous iteration : https://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n    float f = log2(log(length(z))/log(th));\n    float sn = n - f;\n    \n    // distance: https://iquilezles.org/www/articles/distancefractals/distancefractals.htm\n    float d = sqrt(lz2/ld2)*log(lz2);\n\n    // triangle inequality\n\tti_av1 = ti_av1/(n    );\n    ti_av2 = ti_av2/(n-1.0);\n\tti_av1 = ti_av2+(ti_av1-ti_av2)*smoothstep(0.0,1.0,1.0-f);\n    \n    // --- coloring ---\n    \n    vec3 col = max(0.6+0.8*sin(ti_av1*1.5 + 5.5 + vec3(0.0,0.3,0.5)),0.0);\n    col *= clamp( 1024.0*d/zoom, 0.0, 1.0 );\n        \n    return col;\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = vec2(float(i),float(j))/float(AA)-0.5;\n\t    col += render( fragCoord+of, iTime );\n\t}\n\tcol /= float(AA*AA);\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXyDX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1585, 1585, 1620, 1637, 3549], [3552, 3552, 3609, 3609, 3846]], "test": "timeout"}
{"id": "WlXyR7", "name": "Hair chromatic aberration", "author": "TAKUSAKU", "description": "Hair chromatic aberration", "tags": ["color", "hair", "chromatic", "aberration", "string"], "likes": 9, "viewed": 145, "published": "Public", "date": "1591625085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 U )\n{\n    vec3 u = vec3(U/iResolution.xy,iResolution.y)*4.;\n    for(float i=0.;i++<6.;)\n        u.x+=sin(u.z+iTime*.2),\n        u.y+=cos(u.x+iTime*.2),\n        o=max(o*.95,cos(2.*dot(u,u)*i*.1+vec4(.3,.1,0,0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXyR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 249]], "test": "timeout"}
{"id": "WlXyzs", "name": "Plot function of two variables", "author": "TobyBrull", "description": "Plot a function of two variables. Use Mouse to rotate.", "tags": ["function"], "likes": 1, "viewed": 76, "published": "Public", "date": "1592743599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// s along +x axis, t along -z axis.\n// returns function value in .x and\n// upper bound on differential in .y\n\n#define BOUNDARY 3.1415*2.0\nvec2 function(float s, float t) {\n    t += iTime;\n    return vec2(sin(s)*sin(t) + sin(s*2.0)*cos(s*2.0)*0.4, 2.0);\n}\n\n//#define BOUNDARY 1.0\n//vec2 function(float s, float t) {\n//    return vec2(s*s + t*t, 4.0);\n//}\n\nfloat GetDistBox(vec3 p, vec3 o, vec3 s) {\n    p = abs(p-o)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    float h = 0.01;\n    float b1 = GetDistBox(p, vec3(BOUNDARY/2.0, 0.0, 0.0), vec3(BOUNDARY/2.0, h, h));\n    float b2 = GetDistBox(p, vec3(0.0, BOUNDARY/2.0, 0.0), vec3(h, BOUNDARY/2.0, h));\n    float b3 = GetDistBox(p, vec3(0.0, 0.0, BOUNDARY/2.0), vec3(h, h, BOUNDARY/2.0));\n    \n    vec2 f = function(p.x, -p.z);\n    float bf = (abs(f.x - p.y)-0.01)/f.y;\n    bf = max(bf, GetDistBox(p, vec3(0.0), vec3(BOUNDARY)));\n   \t\n    return min(b1, min(b2, min(b3, bf)));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 eye, vec3 center, float z) {\n\tvec3 dir = normalize(center-eye);\n\tvec3 right = normalize(cross(dir, vec3(0,1,0)));\n    vec3 up = cross(right, dir);\n    vec3 c = dir*z;\n    return normalize(c + uv.x*right + uv.y*up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y*2.0;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y*2.0;\n    m.xy-=0.2;\n    \n    // Right-hand coordinate system, x - right, y - up, z - towards    \n    float pi = 3.1415;\n    float theta = -m.y*pi/2.0f;\n    float phi = -m.x*pi/2.0f;\n    vec3 ro = 3.0*vec3(sin(phi)*cos(theta), sin(theta), cos(phi)*cos(theta));\n    vec3 rc = vec3(0.0, 0.0, 0.0);\n    vec3 rd = GetRayDir(uv, ro, rc, 1.);\n\n    vec3 col = vec3(0);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1, 2, 3)))*0.5+0.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(0.4545));\t// gamma correction\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 240, 240, 323], [424, 424, 466, 466, 549], [551, 551, 574, 574, 1042], [1044, 1044, 1078, 1078, 1290], [1292, 1292, 1316, 1316, 1506], [1508, 1508, 1565, 1565, 1753], [1755, 1755, 1812, 1812, 2595]], "test": "timeout"}
{"id": "Ws2fDV", "name": "Eisenstein Gasket", "author": "sl2c", "description": "Based on a conversation [url=https://www.shadertoy.com/view/wdsfWX]here[/url], I created a circle packing based on regular hyperbolic ideal tetrahedra; the centers of all circles should thus be Eisenstein rationals!", "tags": ["fractal", "circles", "gasket"], "likes": 11, "viewed": 154, "published": "Public", "date": "1591028338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n#define swap(u,v) {int t=sigma[u]; sigma[u]=sigma[v]; sigma[v]=t;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float res = 1.0 / iResolution.y;\n    vec3 zh = vec3(z, res);\n    \n    vec2[3] lines = vec2[](\n        vec2(1.0,0.0),\n        vec2(-0.5,sqrt(0.75)),\n        vec2(-0.5,-sqrt(0.75)));\n    zh *= 3.0;\n    float t = 0.2 * iTime;\n    t = mod(t, sqrt(3.0) * 2.0);\n    zh += t * vec3(sqrt(0.75), 0.5, 0.0);\n    \n    vec3[3] colors = vec3[](\n        vec3(1.0,0.2,0.2),\n        vec3(0.2,1.0,0.2),\n        vec3(0.0,0.0,0.0));\n    \n    int[5] sigma = int[](0,1,2,3,4);\n    \n    int i;\n    int br = 2;\n    float err = 2.0;\n    for(i=0; i<50; i++) {\n        if (dot(zh,zh) < 1.0) {\n            zh /= dot(zh,zh);\n            swap(0,4);\n            if (sigma[0]+sigma[4]==4) {\n                br = sigma[0];\n                err = (dot(zh,zh)-1.0)/(2.0 * zh.z);\n                break;\n            }\n        }\n        for(int j=0; j<3; j++) {\n            if (dot(zh.xy, lines[j])>0.5) {\n                zh.xy = zh.xy - 2.0 * lines[j] * (dot(zh.xy, lines[j]) - 0.5);\n                swap(0,j+1);\n                if (sigma[0]+sigma[j+1]==4) {\n                    br = sigma[0];\n                    err = (0.5 - dot(zh.xy, lines[j]))/zh.z;\n                    break;\n                }\n            }\n        }\n        if (br != 2) {\n            break;\n        }\n    }\n\n    if (br > 2) {br = 4 - br;}\n    vec3 col = colors[br] * min(err, 2.0) * 0.5;\n    \n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2fDV.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [], "test": "timeout"}
{"id": "wsBfD3", "name": "Motes", "author": "stb", "description": "From the archive. I made this back in 2015 when I was using a different name... not that it matters since I don't think I ever posted it :D\n\nMouse to rotate camera.\n", "tags": ["2d", "3d", "ray", "voxels", "raycasting", "voxel", "particles", "sprites", "casting", "pollen"], "likes": 15, "viewed": 191, "published": "Public", "date": "1590964098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\tMotes\n\t2015-2020 stb (was BeyondTheStatic back then)\n\tUses raycasting to step through cubic cells. Sprites are 2D and always exist inside a cell otherwise\n\tthere would be clipping, or there would neighbors needing to be checked on (not always a bad thing).\n\tTraces forward from the camera and uses adaptive depth control for a speedup.\n\tFor more info on adaptive depth control, see: http://povray.org/documentation/view/3.6.1/258/\n*/\n\n#define iGlobalTime iTime\n\nconst float ADC\t\t= 0.03;\t// adaptive depth control bailout\t0.0 - 1.0\nconst float maxDist\t= 20.;\t// maximim draw distance\t\t\t0.0 - ?.?\n\nfloat rand(vec3 p){ return fract(sin(dot(p, vec3(12.9898, 78.233, 9.4821)))*43758.5453); }\n\nvec3 rand3v(vec3 p) {\n\tmat3 m = mat3(15.2, 27.6, 35.7, 53.1, 75.8, 99.8, 153.2, 170.6, 233.7);\n\treturn fract(sin(m * p) * 43648.23);\n}\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res\t= iResolution.xy;\n    vec2 uv\t\t= (fragCoord-.5*res) / res.y;\n\tvec2 mPos\t= 3.5 * (iMouse.xy-.5*res) / res.y;\n    \n    mPos += vec2(.2*iTime, 5.+.073*iTime);\n    \n    vec3 camPos\t= vec3(.0, .0, -15.);\n    vec3 rayDir\t= normalize(vec3(uv, .8));\n    \n    camPos.yz = rotate(camPos.yz, mPos.y);\n    camPos.xz = rotate(camPos.xz, mPos.x);\n    rayDir.yz = rotate(rayDir.yz, mPos.y);\n    rayDir.xz = rotate(rayDir.xz, mPos.x);\n    \n    camPos.y += iGlobalTime;\n    \n    vec3 adj, xV, yV, zV, V_;\n    vec3 po\t= sign(rayDir);\n    vec3 V\t= camPos, LV;\n    float dist;\n    \n    // light pos, background\n    vec3 lPos\t= normalize(vec3(.5, -1., .25));\n    vec3 bg\t\t= vec3(.1, .3, 1.) + .06*vec3(1.5, .875, .5)*pow(length(rayDir+lPos)/1., 4.);\n    \n    vec4 RGBA\t= vec4(vec3(0.), 1.);\n    \n    // loop extents should accomodate maxDist\n    for(int i=0; i<150; i++) {\n        dist = length(V-camPos);\n        \n        LV = V;\n        \n        adj = mix(floor(V+po), ceil(V+po), .5-.5*po) - V;\n        \n        xV = adj.x * vec3(1., rayDir.yz/rayDir.x);\n        yV = adj.y * vec3(rayDir.xz/rayDir.y, 1.);\n        zV = adj.z * vec3(rayDir.xy/rayDir.z, 1.);\n\n        V_ = vec3(length(xV)<length(yV) ? xV : yV.xzy);\n    \tV_ = vec3(length(V_)<length(zV) ? V_ : zV);\n        \n        V += V_;\n        if(dist>maxDist || RGBA.a<ADC) break;\n        if(rand(floor((V+LV)/2.))>.5){\n            float pRad = .25*fract(3.141592*rand(floor((V+LV)/2.)));\n            vec3 pOff = 10.*rand3v(floor((V+LV)/2.));\n            pOff = -vec3(sin(iGlobalTime+pOff.x), cos(iGlobalTime+pOff.y), sin(iGlobalTime+pOff.z))*pRad;\n            vec3 pVec = camPos + rayDir * length(floor((V+LV)/2.)+.5-camPos-pOff)+pOff;\n            float circ = length( pVec-floor((V+LV)/2.)-.5 )+.5-pRad*1.25;\n            float alph = float(clamp(smoothstep(0., 1., 2.-4.*circ), 0., 1.));\n            \n            // fake particle lighting\n            //circ += length( pVec-floor((V+LV)/2.)-.5+.2*lPos )+.5-pRad*1.25; \n            circ += 2.*dot( pVec-floor((V+LV)/2.)-.5, lPos );\n            \n            vec3 vCol = (circ/1.+.3) * vec3(.8, 1., .6);\n            RGBA.rgb +=\n                \tRGBA.a * alph\n                \t* mix(vCol, bg, dist/maxDist);\n            RGBA.a *= 1.00001 - alph;\n       \t}\n    }\n    \n    RGBA.rgb += bg * RGBA.a;\n    \n    \n    fragColor = vec4(sqrt(RGBA.rgb), 1.);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 599, 618, 618, 689], [691, 691, 712, 712, 825], [898, 898, 953, 953, 3297]], "test": "timeout"}
{"id": "wsBfDt", "name": "Secret mining", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 23, "viewed": 260, "published": "Public", "date": "1591108065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Distance glow made by balkhan\n// Phantom Mode by aiekick\n\n#define opRepEven(p,s) mod(p,s)-0.5*s \n#define opRepOdd(p,s) p-s*round(p/s)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\nvec2 pSFold(vec2 p,float n)\n{\n    float h=floor(log2(n)),a =6.2831*exp2(h)/n;\n    for(float i=0.0; i<h+2.0; i++)\n    {\n\t \tvec2 v = vec2(-cos(a),sin(a));\n\t\tfloat g= dot(p,v);\n \t\tp-= (g - sqrt(g * g + 5e-3))*v;\n \t\ta*=0.5;\n    }\n    return p;\n}\n\nvec2 sFold45(vec2 p, float k)\n{\n    vec2 v = vec2(-1,1)*0.7071;\n    float g= dot(p,v);\n \treturn p-(g-sqrt(g*g+k))*v;\n}\n\nfloat frameBox(vec3 p, vec3 s, float r)\n{   \n    p = abs(p)-s;\n    p.yz=sFold45(p.yz, 1e-3);\n    p.xy=sFold45(p.xy, 1e-3);\n    p.x = max(0.0,p.x);\n\treturn lpNorm(p,5.0)-r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{   \n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat deObj(vec3 p)\n{   \n    return min(sdRoundBox(p,vec3(0.3),0.05),frameBox(p,vec3(0.8),0.1));\n}\n\n//+++++++++++++++++++++++++++++++\nfloat g1=0.0,g2=0.0,pm=0.0;\nbool fs=false;\n\nfloat map(vec3 p)\n{\n    float de=1.0;\n    p.z-=iTime*1.1;\n    vec3 q= p;\n    p.xy=pSFold(-p.xy,3.0);\n    p.y-=8.5;\n    p.xz=opRepEven(p.xz,8.5);\n    \n    float de1=length(p.yz)-1.;\n    g1+=0.1/(0.1+de1*de1);\n    de=min(de,de1);\n    \n    \n    p.xz=pSFold(p.xz,8.0);\n    p.z-=2.0;\n    float rate=0.5;\n    float s=1.0;\n    for(int i=0;i<3;i++)\n    {\n        p.xy=abs(p.xy)-.8;\n        p.xz=abs(p.xz)-0.5;\n        p.xy*=rot(0.2);\n        p.xz*=rot(-0.9);\n        s*=rate;\n        p*=rate;\n        de=min(de,deObj(p/s));\n    }\n    \n    if(fs)return de;\n    q.z=opRepOdd(q.z,8.5);\n    float de0=length(q)-1.5;\n    pm = step(de0,de);\n    g2+=0.1/(0.1+de0*de0);\n    de=min(de,de0);\n    return de;\n    \n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if(d < 0.001)\n        {\n            if(pm<0.5) return t;\n            t+=3.5;        }\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n    fs=true;\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(-4,-3,3);\n    vec3 ta = vec3(0);\n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,normalize(vec3(0,1,3))));\n    vec3 rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,1.5));\n    vec3 col;\n    float maxd=50.0;\n    float t=march(ro,rd,0.5,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=vec3(1); \n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(1,3,-2);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0)*0.86;\n        float sha = calcShadow( lightPos, -li, len );\n        col *= vec3(1,0.6,0.2)*max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.8;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(1,0.6,0.2)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 20.0);\n    }\n    col+=vec3(0.1,0.3,0.5)*g1*0.12+vec3(1,0.6,0.2)*g2*0.1;\n    col=pow(col,vec3(2.5,1.3,0.8));\n    fragColor.xyz = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 219, 219, 281], [283, 283, 312, 312, 524], [526, 526, 557, 557, 644], [646, 646, 687, 687, 819], [821, 821, 866, 866, 960], [962, 962, 983, 983, 1060], [1140, 1140, 1159, 1159, 1835], [1837, 1837, 1863, 1863, 2015], [2017, 2017, 2071, 2071, 2301], [2303, 2303, 2355, 2355, 2451], [2453, 2453, 2510, 2510, 3658]], "test": "timeout"}
{"id": "WsByDK", "name": "Log Tunnel", "author": "BackwardsCap", "description": "Playing with log", "tags": ["log", "repeating"], "likes": 4, "viewed": 205, "published": "Public API", "date": "1591048477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 c, in vec2 f )\n{\n    vec2  p = (2.*f-iResolution.xy)/iResolution.y;\n    \t  p = vec2(log(length(p.xy)),atan(p.x,p.y)+iTime/3.0)*4.0;\n    \n    float b = sin(p.x*(cos(iTime/2.)+2.0)*2.+p.y)+sin(p.y);\n    \n    c.rgb   = length(b)*vec3(f.x*p.x*.1, f.y*p.x*.5, f.y*(1.+sin(p.x)/1.4)/2.5)*.00125;\n    c.rgb  += pow(c.b,2.75);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 345]], "test": "ok"}
{"id": "wsjBD3", "name": "A battered alien planet", "author": "mrange", "description": "License CC0: A battered alien planet\nBeen experimenting with space inspired shaders\n", "tags": ["raymarching", "terrain"], "likes": 32, "viewed": 813, "published": "Public API", "date": "1591024904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: A battered alien planet\n//  Been experimenting with space inspired shaders\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.00001\n#define MAX_ITER        65\n#define MIN_DISTANCE    0.01\n#define MAX_DISTANCE    9.0\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = vec3(0.4, 0.7, 1.0);\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.6,0.4);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.7);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  mountainColor = 1.0*sqrt(vec3(0.95, 0.65, 0.45));\nconst float cellWidth     = 1.0;\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 center = sphere.xyz;\n  float radius = sphere.w;\n  vec3 m = ro - center.xyz;\n  float b = dot(m, rd);\n  float c = dot(m, m) - radius*radius;\n  if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n  float discr = b * b - c;\n  if(discr < 0.0) return vec2(-1.0);\n  float normalMultiplier = 1.0;\n  float s = sqrt(discr);\n  float t0 = -b - s;\n  float t1 = -b + s;;\n  return vec2(t0, t1);\n}\n\nfloat noise1(vec2 p) {\n  vec2 n = mod2(p, vec2(cellWidth));\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n  \n  float r = 0.225*cellWidth;\n \n  float d = circle(p, 2.0*r);\n  \n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\nfloat noise2(vec2 p) {\n  vec2 n = mod2(p, vec2(cellWidth));\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  rot(p, TAU*hh.y);\n  float r = 0.45*cellWidth;\n \n//  float d = circle(p, 1.0*r);\n  float d = egg(p, 0.75*r, 0.5*r*abs(hh.y));\n  \n  float h = (hh.x)*smoothstep(0.0, r, -2.0*d);\n\n  return h*0.275;\n}\n\n\nfloat height(vec2 p, float dd, int mx) {\n  const float aa   = 0.45;\n  const float ff   = 2.03;\n  const float tt   = 1.2;\n  const float oo   = 3.93;\n  const float near = 0.25;\n  const float far  = 0.65;\n  \n  float a = 1.0;\n  float o = 0.2;\n  float s = 0.0;\n  float d = 0.0;\n  \n  int i = 0;\n  \n  for (; i < 4;++i) {\n    float nn = a*noise2(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float lod = s/d;\n\n  float rdd = dd/MAX_DISTANCE;\n  mx = int(mix(float(4), float(mx), step(rdd, far)));\n  \n  for (; i < mx; ++i) {\n    float nn = a*noise1(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n  \n  float hid = (s/d);\n  \n  return mix(hid, lod, smoothstep(near, far, rdd));\n}\n\nfloat loheight(vec2 p, float d) {\n  return height(p, d, 0);\n}\n\nfloat height(vec2 p, float d) {\n  return height(p, d, 6);\n}\n\nfloat hiheight(vec2 p, float d) {\n  return height(p, d, 8);\n}\n  \nvec3 normal(vec2 p, float d) {\n  vec2 eps = vec2(0.00125, 0.0);\n  \n  vec3 n;\n  \n  n.x = (hiheight(p - eps.xy, d) - hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (hiheight(p - eps.yx, d) - hiheight(p + eps.yx, d));\n  \n  return normalize(n);\n}\n\nconst float stepLength[] = float[](0.9, 0.25);\n\n\nfloat march(vec3 ro, vec3 rd, out int max_iter) {\n  float dt = 0.1;\n  float d = MIN_DISTANCE;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < MAX_ITER; ++i)\n  {\n    vec3 p = ro + d*rd;\n    float h = height(p.xz, d);\n    \n    if (d > MAX_DISTANCE) {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE) {\n      ++currentStep;\n      if (currentStep >= stepLength.length()) {\n        max_iter = i;\n        return d;\n      }\n      \n      d = lastd;\n      continue;\n    }\n\n    float sl = stepLength[currentStep];\n\n    dt = max(hd, TOLERANCE)*sl + 0.0025*d;\n    lastd = d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, skyCol2, max(0.0, angle)), skyCol3, clamp(-angle*2.0, 0.0, 1.0));\n  \n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dust = pow(sunCol2*mountainColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*vec3(0.9, 0.8, 0.7), 0.3*vec3(0.9, 0.8, 0.7), pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 final = vec3(0.0);\n  \n final += step(0.0, si.x)*pow(planetDiff, 0.75)*planetCol*smoothstep(-0.075, 0.0, rd.y)*smoothstep(0.0, 0.1, planetBorder);\n\n final += skyCol + sunCol + smallSunCol + dust;\n\n\n  return final;\n}\n\nvec3 getColor(vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0);\n  \n  float d = march(ro, rd, max_iter);\n\n  if (d < MAX_DISTANCE)   {\n    vec3 sunDir = sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, .0, -1.0);\n    vec3 p = ro + d*rd;\n\n    vec3 normal = normal(p.xz, d);\n    \n    float amb = 0.2;\n\n    float dif1 = max(0.0, dot(sunDir, normal));\n    vec3 shd1 = sunCol2*mix(amb, 1.0, pow(dif1, 0.75));\n\n    float dif2 = max(0.0, dot(osunDir, normal));\n    vec3 shd2 = sunCol1*mix(amb, 1.0, pow(dif2, 0.75));\n\n    vec3 ref = reflect(rd, normal);\n    vec3 rcol = skyColor(p, ref);\n\n    col = mountainColor*amb*skyCol3;\n    col += mix(shd1, shd2, -0.5)*mountainColor;   \n    float fre = max(dot(normal, -rd), 0.0);\n    fre = pow(1.0 - fre, 5.0);\n    col += rcol*fre*0.5;\n    col += (1.0*p.y);\n    col = tanh(col);\n    col = mix(col, skyCol, smoothstep(0.5*MAX_DISTANCE, 1.0*MAX_DISTANCE, d));\n  \n  } else {\n    col = skyCol;\n  }\n  \n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 getSample1(vec2 p, float time) {\n  float off = 0.5*iTime;\n\n  vec3 ro  = vec3(0.5, 1.0-0.25, -2.0 + off);\n  vec3 la  = ro + vec3(0.0, -0.30,  2.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = getColor(ro, rd)  ;\n \n  return col;\n  \n}\n\nvec3 getSample2(vec2 p, float time) {\n  p.y-=time*0.25;\n  float h = height(p, 0.0);\n  vec3 n = normal(p, 0.0);\n  \n  vec3 lp = vec3(10.0, -1.2, 0.0);\n  \n  vec3 ld = normalize(vec3(p.x, h, p.y)- lp);\n  \n  float d = max(dot(ld, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n\n  col = vec3(1.0)*(h+0.1);\n  col += vec3(1.5)*pow(d, 0.75);\n \n  return col;\n  \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = getSample1(p, iTime);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjBD3.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[770, 770, 803, 803, 888], [890, 890, 926, 926, 1020], [1022, 1022, 1053, 1053, 1079], [1081, 1081, 1120, 1120, 1383], [1385, 1385, 1404, 1404, 1527], [1529, 1529, 1576, 1576, 1961], [1963, 1963, 1985, 1985, 2206], [2208, 2208, 2230, 2230, 2522], [2525, 2525, 2565, 2565, 3310], [3312, 3312, 3345, 3345, 3373], [3375, 3375, 3406, 3406, 3434], [3436, 3436, 3469, 3469, 3497], [3501, 3501, 3531, 3531, 3749], [3800, 3800, 3849, 3849, 4500], [4502, 4502, 4523, 4523, 4569], [4571, 4571, 4597, 4597, 4643], [4645, 4645, 4666, 4666, 4695], [4697, 4697, 4730, 4730, 6042], [6044, 6044, 6077, 6077, 7127], [7129, 7129, 7166, 7166, 7508], [7510, 7510, 7547, 7547, 7853], [7855, 7855, 7907, 7907, 8083]], "test": "error"}
{"id": "WsjBDt", "name": "My 1st Try On Shadertoy", "author": "pnoqable", "description": "based on https://www.shadertoy.com/view/3lV3WD experimeting with some sdf stuff which i learned at iqs website. now comes with pretty expensive 2x2 anti alias as seen at https://www.shadertoy.com/view/Mt3BDj", "tags": ["raymarching", "smoothoperators"], "likes": 7, "viewed": 242, "published": "Public API", "date": "1591130553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// Unknown author...\n\n\n// ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.01;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_ellipsoid( vec3 pos, vec3 r )\n{\n    float k0 = length( pos / r );\n    float k1 = length( pos / ( r * r ) );\n    return k0 * ( k0 - 1.0 ) / k1;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nfloat dist_torus( vec3 pos, vec2 t ) {\n    vec2 q = vec2( length( pos.xy ) - t.x, pos.z );\n    return length( q ) - t.y;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * ( 1.0 - h );\n}\n\nfloat smoothSubtract( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5 * ( d2 + d1 ) / k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) +  k * h * ( 1.0 - h );\n}\n\nfloat smoothIntersect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k * h * ( 1.0 - h );\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n    \n    pos.xy = mod( pos.xy + vec2( 2.5 ), 5. ) - vec2( 2.5 );\n    pos.z += 1.;\n    \n    if( pos.z <= 0.1 )\n        pos.z = mod( pos.z + 1., 5. ) - 1.;\n\t\n    float edge = .5 - .49 * cos( iTime );\n\t\n\tfloat sphere = dist_sphere( pos, 1. );\n    \n    float ellipsoid = dist_ellipsoid( pos, vec3( .5, .5, 1.2 ) );\n\t\n\tfloat box = dist_box( pos, vec3( 2.3, 2.3, 0. ) ) - 0.2 * edge;\n    \n    float torus = dist_torus( pos, vec2( 1.7, 0.3 ) );\n    \n    float result = sphere;\n    result = smoothUnion( box, result, edge );\n    result = smoothSubtract( ellipsoid, result, edge );\n    result = smoothUnion( torus, result, edge );\n\n    return result;\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 3.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.4, 0.3 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.2, 0.1 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0., 0., 0., 1. );\n    \n    int antiAlias = 1;\n    \n    for( int offX = 0; offX < antiAlias; offX++ )\n    for( int offY = 0; offY < antiAlias; offY++ )\n    {\n        vec2 offset = vec2( float( offX ), float( offY ) ) / float( antiAlias ) - 0.5;\n        \n        // default ray dir\n        vec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy + offset );\n\n        // default ray origin\n        vec3 eye = vec3( 0.0, 0.0, 10.0 );\n        \n        // uncomment for lg cinema3d:\n        // eye.x -= 0.1 * ( mod( fragCoord.y, 2. ) - 1. );\n\n        // rotate camera\n        mat3 rot = rotationXY( vec2( 0.1 * iTime ) );\n        dir = rot * dir;\n        eye = rot * eye;\n\n        // ray marching\n        float depth = ray_marching( eye, dir, 0.0, clip_far );\n        \n        // shading\n        if ( depth < clip_far ) {\n            vec3 pos = eye + dir * depth;\n            vec3 n = gradient( pos );\n            fragColor.xyz += shading( pos, n, eye );\n        }\n    }\n    fragColor.xyz /= float( antiAlias * antiAlias );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 269, 309, 309, 338], [340, 340, 382, 382, 495], [497, 497, 536, 536, 587], [589, 589, 627, 627, 711], [713, 713, 763, 763, 878], [880, 880, 933, 933, 1050], [1052, 1052, 1106, 1106, 1221], [1223, 1252, 1282, 1309, 1953], [1955, 1972, 2014, 2040, 2871], [2873, 2902, 2929, 2929, 3263], [3265, 3281, 3350, 3350, 3600], [3602, 3623, 3671, 3671, 3847], [3849, 3881, 3912, 3912, 4068], [4070, 4070, 4127, 4127, 5168]], "test": "timeout"}
{"id": "wsjfDc", "name": "Antifascism flag", "author": "Danguafer", "description": "Antifascism flag", "tags": ["flag", "antifa"], "likes": 14, "viewed": 351, "published": "Public API", "date": "1591041806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS (2.0/iResolution.y)\n\n#define SYMBOL_START 0.975\n#define SPACE 0.02\n#define TEXT_START SYMBOL_START - SPACE*2.0\n#define TEXT_SPACE 0.25\n#define INNER_START TEXT_START - TEXT_SPACE - SPACE\n\n#define add(color,df) col = mix(col,color,smoothstep(EPS,-EPS,df));\n#define diff(a,b) max(a,-b)\n#define union(a,b) min(a,b)\n#define inter(a,b) -min(-(a),-(b))\n\nfloat circle(vec2 o, float r) { return length(o) - r; }\nfloat circum(vec2 o, float r, float width) { return diff(circle(o,r),circle(o,r-width)); }\nfloat rect(vec2 o, vec2 d) { return inter(abs(o.x)-d.x,abs(o.y)-d.y); }\n\nfloat flag(vec2 op,vec2 d) {\n    vec2 p = op - d;\n    float stick = rect(p - vec2(0.0,-0.4),vec2(0.04,0.5));\n    vec2 displacement = vec2(-0.56,0.225 + p.x * 0.1 * cos(-iTime * 2.0 - op.x * 8.0 + 1.0));\n    float flag = rect(p - displacement,vec2(0.6,0.3));\n    return min(stick,flag);\n}\n\nmat2 rotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n#define LINES 16.0\n#define COLUMNS 16.0\n#define MAP(C,L) vec2(-float(C)/COLUMNS,float(L)/LINES)\n  #define H MAP(8,4)\n  #define A MAP(1,4)\n  #define C MAP(3,4)\n  #define K MAP(11,4)\n  #define E MAP(5,4)\n  #define R MAP(2,5)\n  #define S MAP(3,5)\n\n//#define A\n  #define N MAP(14,4)\n  #define T MAP(4,5)\n  #define I MAP(9,4)\n  #define F MAP(6,4)\n//#define A\n//#define S\n//#define C\n//#define I\n//#define S\n//#define T\n//#define A\n//#define S\n\nfloat ch(vec2 p, vec2 offset) {\n    float mx = 0.0;\n    float my = (LINES-1.0)/LINES;\n    float Mx = 1.0/LINES;\n    float My = 1.0;\n    vec2 uv = clamp(p,vec2(mx,my),vec2(Mx,My)) - offset;\n    return texture(iChannel0,uv).x;\n}\n\nfloat char_mask(vec2 o) {\n    return abs(o.x)-0.1;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define advance() caret += vec2(0.03,0.0);\n#define type(C) text += vec3(ch(text_mapping - caret,C)); advance();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 n = fragCoord.xy/iResolution.xy;\n    vec2 dp = floor(n*10.0)/10.0;\n    \n    if (mod(iTime,3.0) > 2.0)\n      n = mod(n,0.1) + dp - rand(dp + floor(iTime*20.0)/20.0) + 0.5;\n    if (mod(iTime,4.0) > 3.0)\n      n.x -= sin(20.0 * rand(floor(n.yy * 100.0) - floor(iTime* 10.0)/10.0));\n    \n    vec2 p = (2.0 * n - 1.0);\n    p.x *= iResolution.x/iResolution.y; \n    vec3 col = vec3(1.0);\n\n    float border = circum(p,SYMBOL_START,SPACE);\n    border = union(border,circum(p,TEXT_START,TEXT_SPACE));\n    \n    col = add(vec3(0.0,0.0,0.0),border);\n    \n    float flag_mask = circle(p,INNER_START);\n    vec2 flag_p = p - vec2(0.36,-0.15);\n    flag_p *= rotate(-0.3);\n    float red_flag = inter(flag(flag_p,vec2(0.0,0.0)),flag_mask);\n    float black_flag = inter(flag(flag_p,vec2(-0.25,-0.25)),flag_mask);\n    black_flag = diff(black_flag,red_flag+SPACE);\n    col = add(vec3(0.0),black_flag);\n    col = add(vec3(1.0,0.0,0.0),red_flag);\n    \n    vec2 text_mapping;\n    text_mapping.x = (atan(p.x,p.y)/acos(-1.0)*0.6)+0.11;\n    text_mapping.y = (length(p) + 4.035)*0.2;\n\n    vec2 caret = vec2(0.0,0.0);\n    vec3 text = vec3(0.0);\n    type(H);\n    type(A);\n    type(C);\n    type(K);\n    type(E);\n    type(R);\n    type(S);\n    caret = vec2(0.0,0.0);\n    text_mapping.x = (-atan(-p.x,-p.y)/acos(-1.0)*0.6)+0.2;\n    text_mapping.y = (5.655 - length(p))*0.2;\n    type(A);\n    type(N);\n    type(T);\n    type(I);\n    type(F);\n    type(A);\n    type(S);\n    type(C);\n    type(I);\n    type(S);\n    type(T);\n    type(A);\n    type(S);\n\n    // Masking for removing polar coordinates artifacts on the font atlas sampling.\n    text *= step(INNER_START,length(p));\n    \n    col += text;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 391, 391, 415], [416, 416, 460, 460, 506], [507, 507, 535, 535, 578], [580, 580, 608, 608, 867], [869, 869, 891, 891, 936], [1377, 1377, 1408, 1408, 1603], [1605, 1605, 1630, 1630, 1657], [1659, 1659, 1679, 1679, 1751], [1866, 1866, 1923, 1923, 3630]], "test": "error"}
{"id": "WsjfDt", "name": "Dawn at a distant world", "author": "mrange", "description": "License CC0: Dawn at a distant world.\nBeen working on space themed shaders.\nCode \"borrowed\" from the usual suspects", "tags": ["terrain", "fbm"], "likes": 12, "viewed": 399, "published": "Public API", "date": "1591135285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Dawn at a distant world\n//  Been working on space themed shaders\n//  Code \"borrowed\" from the usual suspects\n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.00001\n#define MAX_ITER        65\n#define MIN_DISTANCE    0.01\n#define MAX_DISTANCE    9.0\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = vec3(0.0);\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.6,0.4);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.7);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  mountainColor = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 center = sphere.xyz;\n  float radius = sphere.w;\n  vec3 m = ro - center.xyz;\n  float b = dot(m, rd);\n  float c = dot(m, m) - radius*radius;\n  if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n  float discr = b * b - c;\n  if(discr < 0.0) return vec2(-1.0);\n  float normalMultiplier = 1.0;\n  float s = sqrt(discr);\n  float t0 = -b - s;\n  float t1 = -b + s;;\n  return vec2(t0, t1);\n}\n\nfloat noise1(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n  \n  const float r = 0.225;\n \n  float d = circle(p, 2.0*r);\n  \n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\nfloat noise2(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  rot(p, TAU*hh.y);\n  const float r = 0.45;\n \n//  float d = circle(p, 1.0*r);\n  float d = egg(p, 0.75*r, 0.5*r*abs(hh.y));\n  \n  float h = -abs(hh.x)*(smoothstep(0.0, r, -2.0*d)-0.3*smoothstep(0.0, 0.2*r, -d));\n\n  return h*0.275;\n}\n\n\nfloat height(vec2 p, float dd, int mx) {\n  const float aa   = 0.45;\n  const float ff   = 2.03;\n  const float tt   = 1.2;\n  const float oo   = 3.93;\n  const float near = 0.25;\n  const float far  = 0.65;\n  \n  float a = 1.0;\n  float o = 0.2;\n  float s = 0.075*sin(p.x+p.y);\n  float d = 0.0;\n  \n  int i = 0;\n  \n  for (; i < 4;++i) {\n    float nn = a*noise2(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  float lod = s/d;\n\n  float rdd = dd/MAX_DISTANCE;\n  mx = int(mix(float(4), float(mx), step(rdd, far)));\n  \n  for (; i < mx; ++i) {\n    float nn = a*noise1(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n  \n  float hid = (s/d);\n  \n  return mix(hid, lod, smoothstep(near, far, rdd));\n}\n\nfloat loheight(vec2 p, float d) {\n  return height(p, d, 0);\n}\n\nfloat height(vec2 p, float d) {\n  return height(p, d, 6);\n}\n\nfloat hiheight(vec2 p, float d) {\n  return height(p, d, 8);\n}\n  \nvec3 normal(vec2 p, float d) {\n  vec2 eps = vec2(0.00125, 0.0);\n  \n  vec3 n;\n  \n  n.x = (hiheight(p - eps.xy, d) - hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (hiheight(p - eps.yx, d) - hiheight(p + eps.yx, d));\n  \n  return normalize(n);\n}\n\nconst float stepLength[] = float[](0.9, 0.25);\n\n\nfloat march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < MAX_ITER; ++i)\n  {\n    vec3 p = ro + d*rd;\n    float h = height(p.xz, d);\n    \n    if (d > MAX_DISTANCE) {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE) {\n      ++currentStep;\n      if (currentStep >= stepLength.length()) {\n        max_iter = i;\n        return d;\n      }\n      \n      d = lastd;\n      continue;\n    }\n\n    float sl = stepLength[currentStep];\n\n    dt = max(hd, TOLERANCE)*sl + 0.0025*d;\n    lastd = d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 rocketDirection() {\n  return normalize(vec3(0.0, -0.2+mod(iTime, 90.0)*0.0125, 1.0));\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, skyCol2, smoothstep(0.0 , 1.0, 5.0*angle)), skyCol3, smoothstep(0.0, 1.0, -5.0*angle));\n  \n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dust = pow(sunCol2*mountainColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n  \n  float dustTransparency = smoothstep(-0.075, 0.0, rd.y);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*vec3(0.9, 0.8, 0.7), 0.3*vec3(0.9, 0.8, 0.7), pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  vec3 rocketDir = rocketDirection();\n  float rocketDot = max(dot(rd, rocketDir), 0.0);\n  float rocketDot2 = max(dot(normalize(rd.xz), normalize(rocketDir.xz)), 0.0);\n  vec3 rocketCol = vec3(0.25)*(3.0*smoothstep(-1.0, 1.0, psin(iTime*15.0*TAU))*pow(rocketDot, 70000.0) + smoothstep(-0.25, 0.0, rd.y - rocketDir.y)*step(rd.y, rocketDir.y)*pow(rocketDot2, 1000000.0))*dustTransparency;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n//  float ringsDiff = max(-dot(rings.xyz, sunDir), 0.0);\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*mountainColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*dustTransparency*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  final += skyCol + sunCol + smallSunCol + dust + rocketCol;\n\n  return final;\n}\n\nvec3 getColor(vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0);\n  \n  float id = (0.125 - ro.y)/rd.y;\n  \n  if (id > 0.0)   {\n    float d = march(ro, rd, id, max_iter);\n    vec3 sunDir = sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, .0, -1.0);\n    vec3 p = ro + d*rd;\n\n    vec3 normal = normal(p.xz, d);\n    \n    float amb = 0.2;\n\n    float dif1 = max(0.0, dot(sunDir, normal));\n    vec3 shd1 = sunCol2*mix(amb, 1.0, pow(dif1, 0.75));\n\n    float dif2 = max(0.0, dot(osunDir, normal));\n    vec3 shd2 = sunCol1*mix(amb, 1.0, pow(dif2, 0.75));\n\n    vec3 ref = reflect(rd, normal);\n    vec3 rcol = skyColor(p, ref);\n\n    col = mountainColor*amb*skyCol3;\n    col += mix(shd1, shd2, -0.5)*mountainColor;   \n    float fre = max(dot(normal, -rd), 0.0);\n    fre = pow(1.0 - fre, 5.0);\n    col += rcol*fre*0.5;\n    col += (1.0*p.y);\n    col = tanh(col);\n    col = mix(col, skyCol, smoothstep(0.5*MAX_DISTANCE, 1.*MAX_DISTANCE, d));\n  \n  } else {\n    col = skyCol;\n  }\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 getSample1(vec2 p, float time) {\n  float off = 0.5*iTime;\n\n  vec3 ro  = vec3(0.5, 1.0-0.25, -2.0 + off);\n  vec3 la  = ro + vec3(0.0, -0.00,  2.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = getColor(ro, rd)  ;\n \n  return col;\n  \n}\n\nvec3 getSample2(vec2 p, float time) {\n  p.y-=time*0.25;\n  float h = height(p, 0.0);\n  vec3 n = normal(p, 0.0);\n  \n  vec3 lp = vec3(10.0, -1.2, 0.0);\n  \n  vec3 ld = normalize(vec3(p.x, h, p.y)- lp);\n  \n  float d = max(dot(ld, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n\n  col = vec3(1.0)*(h+0.1);\n  col += vec3(1.5)*pow(d, 0.75);\n \n  return col;\n  \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = getSample1(p, iTime);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjfDt.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[900, 900, 933, 933, 1018], [1020, 1020, 1056, 1056, 1150], [1152, 1152, 1179, 1179, 1248], [1250, 1250, 1281, 1281, 1307], [1309, 1309, 1348, 1348, 1611], [1613, 1613, 1632, 1632, 1755], [1757, 1757, 1799, 1799, 1846], [1848, 1848, 1895, 1895, 2280], [2282, 2282, 2304, 2304, 2506], [2508, 2508, 2530, 2530, 2840], [2843, 2843, 2883, 2883, 3643], [3645, 3645, 3678, 3678, 3706], [3708, 3708, 3739, 3739, 3767], [3769, 3769, 3802, 3802, 3830], [3834, 3834, 3864, 3864, 4082], [4133, 4133, 4192, 4192, 4833], [4835, 4835, 4856, 4856, 4902], [4904, 4904, 4930, 4930, 4976], [4978, 4978, 5002, 5002, 5070], [5072, 5072, 5093, 5093, 5122], [5124, 5124, 5157, 5157, 7836], [7838, 7838, 7871, 7871, 8951], [8953, 8953, 8990, 8990, 9332], [9334, 9334, 9371, 9371, 9677], [9679, 9679, 9731, 9731, 9907]], "test": "error"}
{"id": "WsjfWc", "name": "Doodling w/ ThronoCrigger #1", "author": "Flopine", "description": "This is the first part of a 30 minutes concert for which I made live coded visuals. \nThanks to 0r4 for the invitation and ThronoCrigger for his trust :D I had a lot of fun", "tags": ["2d", "animation", "chiptune", "mograph", "concert"], "likes": 5, "viewed": 118, "published": "Public", "date": "1591009291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853071\n\n#define BPM (150./60.)\n#define ft(speed) fract(iTime*speed)\n#define bouncy(speed) (abs(sqrt(sin(ft(speed)*PI))))\n#define loopease(speed) easeInOutCirc(abs(-1.+2.*ft(speed)))\n#define switchanim(speed) (floor(sin(ft(speed)*TAU))+1.)\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.07,fwidth(val-thre)))\n#define circle(s,puv) AAstep(s, length(puv))\n#define square(s,puv) AAstep(s, max(abs(puv.x),abs(puv.y)))\n\n/////////////////////// Tools ////////////////////\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = atan(p.y,p.x);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat easeInOutCirc (float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - (2. * x) * (2. * x))) / 2.\n        : (sqrt(1. - (-2. * x + 2.) * (-2. * x + 2.)) + 1.) / 2.;\n}\n\n/////////////////////// 2D  //////////////////////\nvec3 dancing_cir (vec2 uv)\n{\n    vec2 uu = uv;\n\n    uv.x -= iTime;\n    uv.y = abs(uv.y) - 0.1;\n    float uvid = floor(uv.x)-.5; \n    uv.x = fract(uv.x)-.5;\n    uv.y -= bouncy(BPM+(sin(uvid*0.3))*1.5);\n\n    vec2 off = vec2(0.2,0.); \n    vec3 col = vec3(0.1,0.8,0.5)*circle(0.15,uv);\n\n    return (uu.y < 0.) ? col : (1.-col);\n} \n\nvec3 round_circle (vec2 uv)\n{\n    vec2 uu = uv;\n    uu *= rot(sin(loopease(.5))*TAU);\n    uv *= rot(sin(ft(.5)*TAU));\n    moda(uv, 3.);\n    uv.x -= 0.1+bouncy(BPM*.5);\n\n    vec2 off = vec2(0.2,0.);\n    uv *= rot(iTime);\n    float mask = circle(0.1,(uv+off)) * square(0.1,((uv-off)*rot(iTime)));\n    vec3 col = vec3(.1,.4,.5)*mask;\n\n    return (AAstep(0.05,(uu.x+uu.y))<= 0.) ? col : 1.-col;\n}\n\n/////////////////////// Main  ////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n \tvec3 col = (switchanim((BPM/20.))<= 0.) ? round_circle(uv*1.2) : dancing_cir(uv*1.5);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjfWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[785, 836, 856, 856, 899], [901, 901, 938, 938, 1061], [1063, 1063, 1094, 1094, 1234], [1236, 1287, 1315, 1315, 1612], [1615, 1615, 1644, 1644, 2007], [2009, 2060, 2117, 2117, 2313]], "test": "timeout"}
{"id": "wsjfWt", "name": "Swimming rainbow blobs", "author": "jarble", "description": "These rainbow blobs appear to be sentient!\nClick and drag the mouse to look around.", "tags": ["raymarching", "blobs"], "likes": 3, "viewed": 230, "published": "Public API", "date": "1591158675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nvec3 animate(vec3 p){\n    return p + sin((p/100.0+vec3(iTime/10.0+sin((p.x)/100.0))).yzx)*100.0;\n}\nvec3 surface_color(vec3 p)\n{\n    return sin(p/10.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p *= 2.0;\n    p = animate(p)/10.0;\n    return  3.9 +sin(length(p*5.0)/2.0) + (sin(p.x)+sin(p.y)+sin(p.z))*1.1;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth/500.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),0.0,0.0);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    vec3 eye = vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*1.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 268, 268, 345], [346, 346, 374, 374, 400], [402, 642, 666, 666, 783], [785, 1206, 1297, 1297, 1621], [1636, 1890, 1955, 1955, 2087], [2089, 2178, 2207, 2207, 2517], [2519, 3011, 3151, 3151, 3741], [3743, 4113, 4198, 4198, 4956], [4958, 5285, 5334, 5369, 5500], [5502, 5502, 5559, 5559, 6629]], "test": "timeout"}
{"id": "WsSBzt", "name": "Little ShaderToy", "author": "hummingbird", "description": "Trying to fiddle with shader toy. Wrote a simple raymarching scene for testing purposes. Find all the SDF function references from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm", "tags": ["sdf"], "likes": 1, "viewed": 75, "published": "Public", "date": "1591916670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Camera{\n\tvec3 origin;\n    vec3 target;\n    vec3 up;\n    float vfov;\n    float focal_length;\n    float aspect_ratio;\n};\n    \n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, vec3 center){\n\treturn length(p- center) - 1.0;\n}\n\nfloat planeSDF(vec3 p, vec3 normal, float height){\n\treturn dot(p-vec3(0.0,1.0,0.0)*height, normal);\n\n}\n\nfloat roundBoxSDF( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, vec3 center, float s)\n{\n  p = abs(p - center);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sceneSDF(vec3 p){\n  \n    float roundBox = roundBoxSDF(p,vec3(1.0),.25);\n    float sphere = sphereSDF(p, vec3(0.0,0.0,1.5*sin(iTime)));\n    \n    float oct = sdOctahedron(p, vec3(0.0,2.0*sin(iTime), 0.0), 1.0);\n    \n    float result = differenceSDF(roundBox,sphere);\n    result = unionSDF(result, oct);\n    return result;\n}\n\n\nvec3 getSceneNormal(vec3 p){\n\treturn normalize(vec3(sceneSDF(vec3(p.x+0.0001,p.y,p.z)) -sceneSDF(vec3(p.x-0.0001,p.y,p.z)),\n                               sceneSDF(vec3(p.x,p.y+0.0001,p.z)) -sceneSDF(vec3(p.x,p.y-0.0001,p.z)),\n                               sceneSDF(vec3(p.x,p.y,p.z+0.0001)) -sceneSDF(vec3(p.x,p.y,p.z-0.0001))                 \n                              ));\n}\n\nmat4 getViewMatrix(Camera cam){\n\tvec3 f = normalize(cam.target - cam.origin);\n    vec3 r = normalize(cross(f, cam.up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n    \tvec4(r,0.0),\n        vec4(u,0.0),\n        vec4(f,0.0),\n        vec4(cam.origin.x,cam.origin.y,cam.origin.z,1.0)\n    );\n\n}\n\nvec3 getCameraRay(vec2 uv, Camera cam){\n    float half_height = tan(radians(cam.vfov/2.0));\n    float half_width = half_height*cam.aspect_ratio; \n    vec3 lower_left = vec3(-half_width, -half_height, cam.focal_length);\n    vec4 view_plane_point = vec4(lower_left + vec3(2.0*half_width,0.0,0.0)*uv.x+vec3(0.0,2.0*half_height,0.0)*uv.y,1.0);\n    view_plane_point = getViewMatrix(cam)*view_plane_point;\n    return normalize(view_plane_point.xyz-cam.origin);\n    \n}\n\n// map from 0 -  255 to 0 - 1\nvec3 normalizedRGB(vec3 rgb){\n\treturn vec3(rgb/255.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n    // screen UV\n    vec2 uv = fragCoord / iResolution.xy;\n    // fragColor = vec4(uv.x, uv.y, 0.0,1.0);\n   \n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 horizontal = vec3(2.0 * aspect_ratio,0.0,0.0);\n    vec3 vertical = vec3(0.0,2.0,0.0);\n    vec3 lower_left = vec3(-horizontal.x/2.0,-vertical.y/2.0,1.0);\n    \n    // handle input\n    bool isLeft = iMouse.x < iResolution.x/2.0;\n    \n    // setup camera\n    Camera cam;\n    cam.origin = vec3(10.0*cos(iTime/5.0),5.0,10.0*sin(iTime/5.0));\n    // cam.origin = vec3(0.0,5.0,-10.0);\n    cam.target = vec3(0.0,0.0,0.0);\n    cam.up = vec3(0.0,1.0,0.0);\n    cam.vfov = 30.0;\n    cam.focal_length = 1.0;\n    cam.aspect_ratio = aspect_ratio;\n    \n    // render sky\n    fragColor.xyz = mix(vec3(55.0,87.0,99.0)/225.0,vec3(121.0,249.0,255.0)/225.0,uv.y );\n   \n    // render scene\n    vec3 rayDir = getCameraRay(uv, cam);\n    vec3 p = cam.origin;\n    for(int i=0;i<250;i++){\n        float d = sceneSDF(p);\n        p = p+rayDir*d;\n        if(d<0.0001){\n            vec4 finalColor = vec4(0.0,0.0,0.0,1.0);\n            vec3 albedo = vec3(normalizedRGB(vec3(230.0, 141.0, 64.0)));\n            vec3 specular = vec3(0.0,1.0,1.0);\n            vec3 ambient = vec3(0.1,0.1,0.3);\n            vec3 N = getSceneNormal(p);\n            vec3 L = normalize(vec3(1.0,1.0,0.0) - vec3(0.0,0.0,5.0));\n            vec3 E = normalize(cam.origin-p);\n            vec3 H = normalize(L+E);\n            \n            float NdotH = max(dot(N,H), 0.0);\n            float NdotL = max(dot(N, L),0.0);\n            \n            float specularIntensity = pow(NdotH, 300.0);\n            finalColor.xyz = albedo * NdotL + specular*specularIntensity + ambient;\n            finalColor.xyz = pow(finalColor.xyz, vec3(1.0/ 2.2));\n           \n       \n        \tfragColor = finalColor;\n            return;\n        }\n    \n    } \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 174, 174, 206], [208, 208, 255, 255, 288], [290, 290, 327, 327, 362], [364, 364, 414, 414, 466], [468, 468, 514, 514, 605], [607, 607, 658, 658, 720], [722, 722, 763, 763, 835], [837, 837, 860, 860, 1164], [1167, 1167, 1195, 1195, 1548], [1550, 1550, 1581, 1581, 1855], [1857, 1857, 1896, 1896, 2318], [2320, 2350, 2379, 2379, 2406], [2408, 2408, 2465, 2488, 4317]], "test": "timeout"}
{"id": "WsSfDt", "name": "Sea of Eels", "author": "jarble", "description": "It's a sea of colorful swimming creatures.\nClick and drag the mouse to look around.", "tags": ["raymarching", "fish", "swimming", "eels"], "likes": 2, "viewed": 249, "published": "Public API", "date": "1591059295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 animate(vec3 p){\n    vec3 p1 = p/100.0+vec3(iTime/5.0);\n    p += vec3(sin(p1.y)+cos(p1.z),sin(p1.z)+cos(p1.x),sin(p1.x)+cos(p1.y))*100.0;\n    return p;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p = animate(p*2.0);\n    vec3 col;\n    col = p.xyz*sin(p.x+p.y+p.z);\n    \n    // Output to screen\n    return vec3(col.y,col.z,p.x)/500.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p *= 2.0;\n    p = animate(p)/10.0;\n    return  3.9 +sin(length(p*5.0)/2.0) + (sin(p.x+p.y+p.z)+cos(p.y)+cos(p.z))*1.1;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord)+vec3(1.0*(iMouse.x/iResolution.x),1.0*(iMouse.y/iResolution.y),0.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    vec3 eye = vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*50.0;    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 270, 270, 407], [409, 409, 437, 437, 580], [582, 822, 846, 846, 971], [973, 1394, 1485, 1485, 1797], [1812, 2066, 2131, 2131, 2263], [2265, 2354, 2383, 2383, 2693], [2695, 3187, 3327, 3327, 3917], [3919, 4289, 4374, 4374, 5132], [5134, 5461, 5510, 5545, 5676], [5678, 5678, 5735, 5735, 6814]], "test": "timeout"}
{"id": "wsyGRD", "name": "radius wave", "author": "ich", "description": "2d circles change their radius resulting in a fancy wavy pattern\none of my first creations inspired by the ray marching expert 'the art of code' ", "tags": ["2dcircle"], "likes": 4, "viewed": 206, "published": "Public API", "date": "1592957633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define psin(x) (.5+.5*sin(x))\n#define xor(a, b) (a+b-2.*a*b)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - R*.5) / R.y;\n    float s = 15.;\n    uv *= s;\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv) + .5;\n    vec3 col = vec3(0);\n    \n    float m = 0.; \n    for (int i = 0; i < 25; ++i) {\n        vec2 o = vec2(i%5, i/5)-2.;\n        float l = length(id - o) - iTime;\n        float r = psin(l * .4)\n            + .5 * psin(l * .294)\n            + .3 * psin(l * .87)\n            + .2;\n        m = xor(m, smoothstep(r, r - 2.*s/R.y, length(gv + o)));\n    }\n    col += m;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 120, 120, 684]], "test": "timeout"}
{"id": "WtfcD8", "name": "GiVD - Extra effects Shader", "author": "RedReservoir", "description": "Shader for testing some extra effects with SDFs.", "tags": ["givd"], "likes": 2, "viewed": 69, "published": "Public", "date": "1591902414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAYMARCHING_ITERATIONS 100\n#define EPSILON 0.00001\n#define MIN_DIST 0.00001\n#define MAX_DIST 100.0\n\nstruct material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n        \nstruct light {\n    vec3 position;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nmaterial mat_red = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.2, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_green = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_blue = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_orange = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.5, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_turquoise = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.5), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_purple = material(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\n\nlight[] scene_lights = light[] (\n    light(vec3(0.0, 0.0, 0.0), vec3(0.05, 0.05, 0.05), vec3(0.4, 0.4, 0.4), vec3(0.0, 0.0, 0.0)),\n    light(vec3(10.0, 10.0, 10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(-10.0, -10.0, -10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0))\n);\nint l_num = 3;\n\nvec3 background_color = vec3(0.7, 0.7, 0.9);\n\n//---------------------------------------------------------------------------------\n\nfloat mixInverse(float x, float y, float a) {\n\treturn (a - x) / (y - x);    \n}\n\nfloat unitMap(float x) {\n    return (2.0 / (1.0 + exp(-x))) - 1.0;\n}\n\nfloat unitMapInverse(float x) {\n\treturn -log((2.0 / (x + 1.0)) - 1.0);    \n}\n\nfloat unitPow(float x, float p) {\n\treturn unitMap(pow(unitMapInverse(x), p));   \n}\n\nmat4 identityMatrix() {\n\tmat4 id;\n    id[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    id[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    id[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    id[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    return id;\n}\n\nmat4 rotationMatrix(float ax, float ay, float az) {\n\tmat4 rot_x;\n    rot_x[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    rot_x[1] = vec4(0.0, cos(ax), -sin(ax), 0.0);\n    rot_x[2] = vec4(0.0, sin(ax), cos(ax), 0.0);\n    rot_x[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_x = transpose(rot_x);\n\n    mat4 rot_y;\n    rot_y[0] = vec4(cos(ay), 0.0, sin(ay), 0.0);\n    rot_y[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    rot_y[2] = vec4(-sin(ay), 0.0, cos(ay), 0.0);\n    rot_y[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_y = transpose(rot_y);\n\n    mat4 rot_z;\n    rot_z[0] = vec4(cos(az), -sin(az), 0.0, 0.0);\n    rot_z[1] = vec4(sin(az), cos(az), 0.0, 0.0);\n    rot_z[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    rot_z[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_z = transpose(rot_z);\n    \n    return rot_z * rot_y * rot_x;\n}\n\nmat4 scaleMatrix(float sx, float sy, float sz) {\n    mat4 sc;\n    sc[0] = vec4(sx, 0.0, 0.0, 0.0);\n    sc[1] = vec4(0.0, sy, 0.0, 0.0);\n    sc[2] = vec4(0.0, 0.0, sz, 0.0);\n    sc[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    sc = transpose(sc);\n    return sc;\n}\n\nmat4 translationMatrix(float tx, float ty, float tz) {\n    mat4 tr;\n    tr[0] = vec4(1.0, 0.0, 0.0, tx);\n    tr[1] = vec4(0.0, 1.0, 0.0, ty);\n    tr[2] = vec4(0.0, 0.0, 1.0, tz);\n    tr[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    tr = transpose(tr);\n    return tr;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 c, float h, float r) {\n    float inOutRadius = length(p.xy - c.xy) - r;\n    float inOutHeight = abs(p.z - c.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat hexPrismSDF(vec3 p, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid unionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 < d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid intersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 > d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid differenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(-d1 > d2) {\n        d = -d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid smoothUnionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) - k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothIntersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothDifferenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, -d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid sceneSDF(vec3 pos, out float dist, out material obj_mat) {  \n    \n    float round_radius = (1.0 + sin(1.5 * iTime)) / 2.0;\n\tdist = hexPrismSDF(pos, vec2(2.5 - round_radius, 1.25 - round_radius)) - round_radius;\n    obj_mat = mat_turquoise;\n    \n    /*\n    float twist_coef = sin(2.0 * iTime) / 3.0;\n    float c = cos(twist_coef * pos.y);\n    float s = sin(twist_coef * pos.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 new_pos = vec3(m * pos.xz, pos.y);\n\tdist = hexPrismSDF(vec3(new_pos.x, new_pos.z, new_pos.y), vec2(2.5, 1.25));\n    obj_mat = mat_turquoise;\n\t*/\n\n    /*\n\tfloat disp_coef = (3.0 + sin(2.0 * iTime)) / 4.0;\n    float disp_size = (2.0 + sin(iTime)) / 2.0;\n    dist = hexPrismSDF(pos, vec2(2.5, 1.25)) +\n        sin(disp_size * pos.x) * sin(disp_size * pos.y) * sin(disp_size * pos.z) * disp_coef;\n    obj_mat = mat_turquoise;\n\t*/\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 blinnPhong(vec3 pos, vec3 V, vec3 N, material mat, light lt) {\n    //Calculate L and H vectors\n    vec3 L = normalize(vec3(lt.position - pos));\n    vec3 H = normalize(L + V);\n\n    //Ambient\n    vec3 ambient = lt.ambient * mat.ambient;\n\n    //Diffuse\n    vec3 diffuse = lt.diffuse * mat.diffuse * max(dot(L, N), 0.0f);\n\n    //Specular\n    vec3 specular = lt.specular * mat.specular * pow(max(dot(H, N), 0.0f), mat.shininess);\n    \n    //Final color calculation\n    //vec3 color = diffuse + ambient + specular;\n    vec3 color = diffuse + ambient;\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 estimateNormal(vec3 pos) {\n    material placeholder;\n    float nxr, nxl, nyr, nyl, nzr, nzl;\n    sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z), nxr, placeholder);\n    sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z), nxl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z), nyr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z), nyl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON), nzr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON), nzl, placeholder);\n   \n    return normalize(vec3(nxr - nxl, nyr - nyl, nzr - nzl));\n}\n\nvoid castRay(vec3 ray_origin, vec3 ray_direction, float dmin, float dmax, out float scene_dist, out material obj_mat) {    \n    scene_dist = dmin;\n    float step_dist;\n    for(int it = 0; it < MAX_RAYMARCHING_ITERATIONS; it++) {\n        vec3 ray_pos = ray_origin + (ray_direction * scene_dist);\n        sceneSDF(ray_pos, step_dist, obj_mat);\n        scene_dist += step_dist;\n        if(step_dist < EPSILON || scene_dist > dmax) { return; }\n    }\n   \n    scene_dist = dmax + 1.0;\n}\n\nvec3 calculateScreenRayDirection(vec2 fragCoord, vec2 size, float fov) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calculateCameraMatrix(vec3 lookfrom, vec3 lookat, vec3 vup) {\n    vec3 cz = normalize(lookat - lookfrom);\n    vec3 cx = normalize(cross(cz, vup));\n    vec3 cy = cross(cx, cz);\n    return mat3(cx, cy, -cz);\n}\n\n\n//---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Precalculate variables\n    vec2 mouse_UV = iMouse.xy / iResolution.xy;\n    \n    //Camera calculations\n    vec3 cam_lookat = vec3(0, 0, 0);\n    vec3 cam_lookfrom = cam_lookat + vec3(20.0 * cos(iTime),\n                                          7.5,\n                                          20.0 * sin(iTime)\n                                         );\n    vec3 cam_vup = vec3(0, 1, 0);\n    mat3 cam_matrix = calculateCameraMatrix(cam_lookfrom, cam_lookat, cam_vup);\n    \n    //Apply raymarching\n    float scene_dist;\n    material obj_mat;\n    \n    vec3 ray_origin = cam_lookfrom;\n    vec3 ray_direction = cam_matrix * calculateScreenRayDirection(fragCoord, iResolution.xy, 45.0);\n    castRay(ray_origin, ray_direction, MIN_DIST, MAX_DIST, scene_dist, obj_mat);\n    \n    vec3 pos = ray_origin + (ray_direction * scene_dist);\n    vec3 norm = estimateNormal(pos);\n\n    vec3 col = vec3(0);\n    if(scene_dist < MAX_DIST) {\n        for(int l_index = 0; l_index < l_num; l_index++) {\n        \tcol += blinnPhong(pos, vec3(cam_lookfrom - pos), norm, obj_mat, scene_lights[l_index]);\n        }\n    } else {\n        col = background_color;\n    }\n    \n    //Gamma normalization\n    //col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1404, 1404, 1449, 1449, 1482], [1484, 1484, 1508, 1508, 1552], [1554, 1554, 1585, 1585, 1630], [1632, 1632, 1665, 1665, 1714], [1716, 1716, 1739, 1739, 1918], [1920, 1920, 1971, 1971, 2692], [2694, 2694, 2742, 2742, 2945], [2947, 2947, 3001, 3001, 3204], [3291, 3291, 3333, 3333, 3365], [3367, 3367, 3420, 3420, 3710], [3712, 3712, 3744, 3744, 3814], [3816, 3816, 3851, 3851, 4124], [4211, 4211, 4309, 4309, 4422], [4424, 4424, 4529, 4529, 4642], [4644, 4644, 4747, 4747, 4862], [4864, 4864, 4986, 4986, 5376], [5378, 5378, 5507, 5507, 5897], [5899, 5899, 6026, 6026, 6417], [6504, 6504, 6567, 6567, 7354], [7441, 7441, 7508, 7540, 8010], [8097, 8097, 8128, 8128, 8675], [8677, 8677, 8796, 8796, 9157], [9159, 9159, 9231, 9231, 9355], [9357, 9357, 9423, 9423, 9569], [9657, 9657, 9712, 9741, 10958]], "test": "error"}
{"id": "wtfcDM", "name": "HypnoICE", "author": "fersat", "description": "original - http://www.pouet.net/prod.php?which=53164", "tags": ["tunnel"], "likes": 1, "viewed": 73, "published": "Public", "date": "1592205003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float RADIUS=min(iResolution.x,iResolution.y)*0.5;\n    float col=distance(iResolution.xy*0.5,fragCoord);\n    if(col>RADIUS)\n        col=abs(iResolution.x*0.5-fragCoord.x);\n    col = (round(col*0.1)+round(iTime*10.0))*10.0;\n    vec3 pos = vec3(col*.3) + col * 500. + 50.0;\n    pos = fract(pos * vec3(.1031, .1030, .0973));\n    pos += dot(pos, pos.yxz+33.33);\n    fragColor = vec4(fract((pos.xxy + pos.yxx)*pos.zyx).rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 488]], "test": "ok"}
{"id": "wtfcW2", "name": "Shortest Dynamic Maze (64 chars)", "author": "Smake", "description": "snippet for future games.  No one intersection,  just a little miracle in 64 chars )\n\nMake slight randomization - and catch God's beard! Child in Time - use all possibilities!\n", "tags": ["game", "maze", "short", "golf"], "likes": 3, "viewed": 87, "published": "Public", "date": "1593087658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 U){ O += mod( U [int(1.+cos(iTime+U.x*U.y))],6.28);} /*\n\n\n// O += mod( U [int(1.+cos(U.x*U.y))],6.28)  // static\n//O += floor(mod( U [int(1.+cos(U.x*U.y))],6.28)) //BW\n//  O += mod( U [int(1.+cos(U.x*U.y))],6.28)*.2  // 3d\n\n\n\n// 65 chars from Fabrice Neyret, static: https://www.shadertoy.com/view/lt2cRR\n#define mainImage( O, U )   \\\n   O += mod( U [ int( 1e4*length(ceil(U/8.)) ) % 2 ] , 8. ) /*\n   \n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfcW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 84]], "test": "timeout"}
{"id": "WtfcWn", "name": "Grid Ripples", "author": "ShnitzelKiller", "description": "Testing out a simple way of creating ripples around grid cells using 6 basis functions instead of enumerating all cases like marching squares.", "tags": ["2d", "ripples", "grid", "water", "marching", "squares"], "likes": 2, "viewed": 266, "published": "Public API", "date": "1591761323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CELL_SIZE 0.05\n//#define SMOOTH_OFFSET 0.2\n#define DENSITY 0.7\n\nfloat rand(in vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\n//1 if there is land, 0 otherwise\nfloat occupancy(in vec2 id) {\n    return step(DENSITY, rand(id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x/CELL_SIZE + vec2(0.5, 1.7) * iTime + iMouse.xy*CELL_SIZE;\n    vec2 id = floor(uv);\n    vec2 id2 = floor(uv + 0.5);\n    vec2 modpos2 = fract(uv + 0.5)-0.5;\n    \n    vec3 offsets = vec3(-1.,0.,1);\n    bool occ00 = occupancy(id2) > 0.5;\n    bool occ11 = occupancy(id2+offsets.xx) > 0.5;\n    bool occ10 = occupancy(id2+offsets.xy) > 0.5;\n    bool occ01 = occupancy(id2+offsets.yx) > 0.5;\n    \n    //compose wave pattern within each offset grid cell (where each corner is at the center of one of the visual grid cells).\n    //one basis function for each corner block, plus two basis functions for the cases where two opposite corners are occupied\n    //(this gives the smooth ripples in concave regions).\n    float height = 100.;\n    if (occ00)\n    \theight = min(height, length(max(vec2(0.), -modpos2)));\n    if (occ11)\n    \theight = min(height, length(max(vec2(0.), modpos2*offsets.zz)));\n    if (occ10)\n        height = min(height, length(max(vec2(0.), modpos2*offsets.zx)));\n    if (occ01)\n        height = min(height, length(max(vec2(0.), modpos2*offsets.xz)));\n    if (occ11 && occ00) {\n        height = min(height, 0.5-min(length(modpos2 + 0.5*offsets.zx), length(modpos2+0.5*offsets.xz)));\n    }\n    if (occ01 && occ10) {\n        height = min(height, 0.5-min(length(modpos2 + 0.5*offsets.xx), length(modpos2+0.5*offsets.zz)));\n    }\n    /*if (occ11 && occ00) {\n        height = min(height, 0.5-SMOOTH_OFFSET-min(length(min(vec2(0.), (modpos2 + (0.5-SMOOTH_OFFSET)*offsets.zx)*offsets.xz)), length(min(vec2(0.), (modpos2+(0.5-SMOOTH_OFFSET)*offsets.xz)*offsets.zx))));\n    }*/\n    \n    // minimalistic rendering\n    float wavefac = exp(-max(0.,height)*10.) * sin(height*50. - iTime * 5.)*.5+.5;\n    vec2 modpos = fract(uv);\n    modpos = abs(modpos-0.5);\n    modpos *= modpos;\n    fragColor = vec4(mix(mix(vec3(0., 0.4, 1.), vec3(0., 1., 1.), vec3(wavefac)), vec3(0.7, 0.6, 0.4) * 1.-max(modpos.x, modpos.y), vec3(occupancy(id))) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfcWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 96, 96, 149], [151, 185, 214, 214, 252], [254, 254, 311, 311, 2288]], "test": "timeout"}
{"id": "Wtfcz4", "name": "more Circuit Diagram 3 (112 ch)", "author": "FabriceNeyret2", "description": "pattern exploration variant.\n( I already so them in shadertoy under other names, but can find back ).", "tags": ["2d", "xor", "pattern", "onetweet", "golf", "circuits"], "likes": 4, "viewed": 215, "published": "Public API", "date": "1591509829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant https://shadertoy.com/view/3lfyz4\n\nvoid mainImage(out vec4 O, vec2 U) {\n  int r = int(U.x+U.y) ^ int(U.x-U.y);\n  O = fract(vec4(r*r*r)/(99.+ceil(iTime*4.)/4.+vec4(0,1,2,1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtfcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 82, 82, 187]], "test": "timeout"}
{"id": "wtfczM", "name": "Rotating pentagons!", "author": "DavidMazarro", "description": "weeeeeeee", "tags": ["rotation", "alpha", "pentagon"], "likes": 2, "viewed": 49, "published": "Public", "date": "1591658981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define K 40.0\n#define E 2.7182818285\n#define PI 3.14159265359\n\nfloat periodicSigmoid(float t, float speed, float steepness) {\n    float t_0_1 = fract(t*speed);\n    float valueSigmoid = 1.0/(1.0 + pow(E, -K*(t_0_1 - 0.25)));\n    return t_0_1 < 0.5 ? valueSigmoid : 1.0/(1.0 + pow(E, -K*(-t_0_1 + 1.0 - 0.25)));\n}\n\nvec4 colorShape(vec4 pointInShape, vec3 color, float alpha) {\n    return pointInShape.a == 1.0 ? vec4(color, alpha) : pointInShape;\n}\n\nmat2 rotate(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec4 polygonshape(float t, float initRot, vec3 position, float radius, float sides){\n    position = position * 2.0 - 1.0;\n    position.xy *= rotate(initRot);\n    float speed = 0.08;\n    float nTurns = 3.0;\n    float a = nTurns*(2.0*PI)*periodicSigmoid(t, speed, K);//clamp(speed*0.2, 0.0, 10.0);\n    position.xy *= rotate(a);\n    float angle = atan(position.x, position.y);\n    float slice = PI * 2.0 / sides;\n    float isInPoly = step(radius, cos(floor(0.5 + angle / slice) * slice - angle) * length(position.xy));\n    return isInPoly == 1.0 ? vec4(vec3(1.0), 0.0) : vec4(vec3(0.0), 1.0);\n}\n\nvec4 alphaBlend(vec4 bg, vec4 fg) {\n    vec4 outFrag;\n    outFrag.a = fg.a + bg.a*(1.0 - fg.a);\n    outFrag.rgb = (fg.rgb*vec3(fg.a) + bg.rgb*vec3(bg.a)*(1.0 - vec3(fg.a))) / vec3(outFrag.a);\n    return outFrag;\n}\n\nfloat scaleRadius(float t, float rmin, float rmax) {\n    return abs(sin(t))*(rmax - rmin) + rmin;\n}\n\nmat2 scaleMatrix(float xfactor, float yfactor) {\n    return mat2(xfactor, 0, 0, yfactor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 position = gl_FragCoord.xyz / iResolution;\n    \n    mat2 scaleFragMat;\n    float scaleFactor;\n    const float offset = -0.33333333;\n    \n    if (iResolution.x > iResolution.y) {\n        scaleFactor = iResolution.x / iResolution.y;\n        scaleFragMat = scaleMatrix(scaleFactor, 1.0);\n        position.xy *= scaleFragMat;\n        position.x += offset;\n    } else {\n        scaleFactor = iResolution.y / iResolution.x;\n        scaleFragMat = scaleMatrix(1.0, scaleFactor);\n        position.xy *= scaleFragMat;\n        position.y += offset;\n    }\n\n    vec4 background = vec4(1.0);\n\n    vec3 black = vec3(0.0);\n    vec3 red = vec3(1.0, 0.1725, 0.1725);\n    vec3 purple = vec3(0.5882, 0.2706, 0.9059);\n\n    float r1 = scaleRadius(iTime, 0.5, 0.7);\n    float r2 = scaleRadius(iTime+0.2, 0.4, 0.65);\n    float r3 = scaleRadius(iTime+0.5, 0.3, 0.5);\n\n    vec4 polygon1 = polygonshape(iTime, 0.0, position, r1, 5.0);\n    vec4 polygon2 = polygonshape(iTime+0.2, PI, position, r2, 5.0);\n    vec4 polygon3 = polygonshape(iTime+0.4, 0.0, position, r3, 5.0);\n\n    vec4 polyBlack = colorShape(polygon1, black, 1.0);\n    vec4 polyRed = colorShape(polygon2, red, 0.9);\n    vec4 polyPurp = colorShape(polygon3, purple, 0.8);\n\n    fragColor = alphaBlend(background,\n    alphaBlend(polyBlack, alphaBlend(polyRed, polyPurp)));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 126, 126, 312], [314, 314, 375, 375, 447], [449, 449, 474, 474, 542], [544, 544, 628, 628, 1135], [1137, 1137, 1172, 1172, 1350], [1352, 1352, 1404, 1404, 1451], [1453, 1453, 1501, 1501, 1544], [1546, 1546, 1600, 1600, 2919]], "test": "timeout"}
{"id": "WtfyRn", "name": "Exponent Fractal Slide", "author": "cheasify", "description": "Just a new function for my mandelbrot renderer. This is z=b^z+c. Where b is a real number that is changing over time, z is the iterated complex value and c is the position on the complex plane. This animation takes b from 0 to +infinity ", "tags": ["fractal"], "likes": 2, "viewed": 66, "published": "Public", "date": "1591200676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979\n#define E 2.718281828459\nfloat normsin(float x) {return .5+.5*sin(x);}\n\nvec3 color(float x){//x 0 to 1\n\tx=abs(sin(x));\n    //bezier \n    float r=(1.0-x)*(1.0-x);\n    float g=x*x;\n    float b=2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\n\n\n\nfloat ln(float x){\n\treturn log(x)/log(E);\n}\n\n//new complex function for b^p where b is real and p is complex\nvec2 exponent(float b,vec2 p){\n    float v= ln(b)*p.y;\n\treturn pow(b,p.x)*vec2(cos(v),sin(v));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //frame\n    //make camera rotate with power\n    float zoom=1.0;//intial zoom\n    float zoomer=1.0/60.0;//governs the speed of zoom\n   \tconst vec2 center=vec2(-1,0);//where the camera is centered\n    vec2 uv = 2.0/(zoom*exp2(zoomer))*((2.*fragCoord-iResolution.xy)/iResolution.y)+center;\n    \n    const int maxiter=400;\n    float count=0.0;\n    vec2 value=vec2(0);\n\tfloat bound= 150.0;\n   \n\t\n    for(int i=0;i<maxiter;i++){\n        count+=1.0;\n        //change these to change plot\n        //value=square(value)+uv\n        //value=power(value,2.0)+uv;\n        value=exponent(float(iFrame)/200.0,value)+uv;\n    \tif(length(value)>bound)//bounary\n            break;\n    }\n    \n  \n    \n    //printing\n    const float cycleRate=3.0;//how fast colors change\n    const float colorShift=.12;\n    vec3 col=vec3(0);\n    if (length(value)>2.0){\n        col=color(float(count)*cycleRate+colorShift);\n    }\n    fragColor=vec4(col,1);\n    \n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 77, 77, 98], [100, 100, 120, 130, 259], [264, 264, 282, 282, 307], [309, 373, 403, 403, 469], [473, 473, 530, 578, 1471]], "test": "timeout"}
{"id": "WtfyRs", "name": "SphereTreeBulb", "author": "eiffie", "description": "A mod of TGlad's SphereTree fractal based on a mclarekin frag.", "tags": ["spheretree"], "likes": 12, "viewed": 249, "published": "Public API", "date": "1592737336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TGlad's SphereTree fractal mod by eiffie of a mclarekin DE\n#define rez iResolution.xy\nvec3 mcol=vec3(0.0);\n#define dot2(a) dot(a,a)\nfloat InvSc=.4,FF=0.95;\nbool bOutChk=false;\n// a mod of a mod of tglad's sphereTree distance estimation function from mclarekin then I simplified some \nfloat DE(vec3 p0) { \n  vec3 orbitTrap=vec3(1000);\n  vec4 p=vec4(p0,1.);\n  const float root3 = 1.732050807, root3d2 = 0.8660254, t = 0.53333334, M=2.15;  \n  const vec2 t1 = vec2(root3d2, -0.5), t2 = vec2(-root3d2, -0.5);\n  const mat2 mx=mat2(.8660254,.5,-.5,.8660254);//cos(sqrt(.75)) or pi/6\n  p.z=abs(p.z)+0.1725;//more sphere than tree now\n  for (int i = 0; i < 7; i++) {  \n    if(bOutChk){vec3 pC = p.xyz-vec3(0,0,t); if (dot(pC, pC) > t*t) break;} // definitely outside \n    float invSC = InvSc / dot(p.xyz,p.xyz); \n    p *= invSC;\n    p.z -= 1.0; \n    p.z *= -1.0;\n    p *= root3;\n    p.z=abs(p.z+.5)+.5;\n    p.xy=mx*p.xy;//rotate\n    // now modolu the space so we move to being in just the central hexagon, inner radius 0.5  \n    vec2 p2=mod(vec2(dot(p.xy,-t1.yx),dot(p.xy,-t2.yx))*M/root3,1.0); \n    if (p2.x + p2.y > 1.0) p2=vec2(1.)-p2; \n    p.xy = p2.x*t1 - p2.y*t2;\n    // fold the space to be in a kite \n    float l0 = dot2(p.xy), l1 = dot2(p.xy-t1), l2 = dot2(p.xy+t2); \n    if (l1 < min(l0,l2)) p.xy -= t1 * (2.0*dot(t1, p.xy) - 1.0); \n    else if (l2 < min(l0,l1)) p.xy -= t2 * (2.0 * dot(p.xy, t2) + 1.0); \n    p.z *= InvSc;\n    orbitTrap = min(orbitTrap, abs(p.xyz)); \n  }\n  if(mcol.x>0.)mcol+=vec3(1.0)+3.*(orbitTrap.zzx+orbitTrap.zyx);\n  float d = (length(p.xyz-vec3(0,0,0.4)) - 0.4); // the 0.4 is slightly more averaging than 0.5 \n  d = (sqrt(d + 1.0) - 1.) * 2.0; \n  return FF*d / p.w; \n} \n\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=max(0.,0.4+0.6*dot(rd,L));\n  return pow(vec3(d*d*d*d,d*d*0.5,d-pow(d*d,10.0)),vec3(.2));\n}\nfloat rnd=0.;\nfloat rand(){rnd=fract((rnd+1.62340)*342.123);return rnd;}\nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.34,117.71)))*4231.76);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rand(),s=1.0,d,mn=0.01;\n for(int i=0;i<6;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rand(),d,od=1.,px=1.0/rez.y;\n  vec4 edge=vec4(0,0,-1,-1);\n  for(int i=0;i<199;i++){\n    d=DE(ro+rd*t);\n    if(d<px*t*t*.5 && d>od){if(edge.x<0.){edge=vec4(edge.yzw,t);break;}else {edge=vec4(edge.yzw,t);t+=px*t*t;}}\n    t+=d;od=d;\n    if(t>10.0)break;\n  }\n  if(d<px*t*t*.5)edge=vec4(edge.yzw,t);\n  vec3 L=vec3(0,0,1);\n  vec3 col=sky(rd,L);\n  for(int i=0;i<4;i++){\n    if(edge.w>0.){//valid distance, color back to front\n      mcol=vec3(0.01);\n      float d=DE(ro+rd*edge.w);\n      if(d<0.)d*=2.;\n      vec3 so=ro+rd*(edge.w+d);\n      vec3 N=normal(so,px*edge.w);\n      vec3 scol=mcol*0.2;\n      float dif=0.5+0.5*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.05,1.0);\n      float fr=pow(1.-vis,5.0);\n      float shad=ShadAO(so,L);\n      col=mix((scol*dif+fr*sky(reflect(rd,N),L))*shad,col,clamp(0.8*d/(px*edge.w*edge.w*.5),0.,1.));\n    }\n    edge=edge.wxyz;\n  }\n  return col;\n}\nmat3 lookat(vec3 fw){fw=normalize(fw);vec3 up=vec3(0,0,1);vec3 rt=normalize(cross(fw,up));\n  return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=vec2(U-0.5*rez)/rez.x;\n  randomize(U);\n  float t=iTime;\n  vec3 ro=vec3(cos(t),sin(t*1.1),0.5+0.5*sin(t*.7));\n  vec3 rd=lookat(-ro)*normalize(vec3(uv.xy,1.0));\n  t=mod(t,60.);\n  if(t<20.){InvSc=.5;FF=0.75;bOutChk=true;}\n  else if(t<40.){InvSc=1.;FF=0.45;bOutChk=true;}\n  O=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 286, 305, 305, 1696], [1699, 1699, 1728, 1738, 1874], [1875, 1875, 1901, 1901, 2002], [2017, 2017, 2030, 2030, 2075], [2076, 2076, 2102, 2102, 2166], [2168, 2168, 2205, 2205, 2341], [2342, 2342, 2371, 2371, 3264], [3265, 3265, 3286, 3286, 3392], [3393, 3393, 3431, 3431, 3739]], "test": "timeout"}
{"id": "wtfyWB", "name": "Day ilostcount will rename tmrw", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 4, "viewed": 192, "published": "Public API", "date": "1592946775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  2d slice of 4d lattice\n\n\n#define pi acos(-1.)\n#define pmod(p,j) mod(p - 0.5*j,j) - 0.5*j\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define tri(j) asin(sin(j))\n\n#define iTime (iTime + 6.)\n    \nfloat sdBox(vec4 p, vec4 sz){\n\tp = abs(p) - sz;\n\treturn max(p.x,max(p.y,max(p.z,p.w)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(3.,1.,0.1)/2000.; \n        \n    \n    uv *= 12.;\n    \n    vec4 p = vec4(uv,1,1);\n    \n    float md = sin(iTime);\n    \n    float t = tri(uv.x*1. + tri(uv.y + iTime*1.)*md + (iTime)/2. + md/4.  );\n    \n    \n    \n    p.xz *= rot(0.25*pi);\n    \n    \n    p.xy *= rot(0.25*pi );\n    \n    p.xw *= rot(0.125*pi);\n    \n    p.yw *= rot(0.25*pi);\n    \n    //p.yw *= rot(0.25*pi);\n    \n    \n    \n    p.xy += sin(iTime )/300. + t/5. + iTime/76.;\n    \n    \n    //p.y += tri(p.y + iTime)*1.3;\n    \n    \n    \n    p = pmod(p,1.);\n    \n\tfloat db;\n    \n    \n    db = sdBox(pmod(p*1.5,1.),vec4(0.1,0.3,0.3,0.5) );\n    \n    db = abs(db) - 0.05;\n    \n    //col = mix(col,vec3(4.15,1.9,0.6)*0.7,smoothstep(dFdx(uv.x)*1.,0.,db));\n    \n    col = mix(col,vec3(1.15,0.6,0.9)*.15,smoothstep(dFdx(uv.x)*1.,0.,db));\n    \n    \n    db = sdBox(p,vec4(0.3,0.3,0.3,0.5));\n    \n    //col = mix(col,vec3(1.15,1.05,0.2)*1.,smoothstep(dFdx(uv.x)*1.,0.,db));\n    col = mix(col,vec3(.25,.45,0.4)*2.1,smoothstep(dFdx(uv.x)*1.,0.,db));\n    \n    \n    //col = mix(col,vec3(0.05,0.2,1.15)*0.2,smoothstep(dFdx(uv.x)*1.,0.,db));\n    \n    \n    \n    \n    col /= 1. + col;\n    \n    col *= 1.5;\n    col = mix(col,smoothstep(0.,1.,col),0.8);\n    col = pow(col,vec3(0.45454));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 233, 233, 293], [295, 295, 352, 352, 1690]], "test": "error"}
{"id": "WtfyzM", "name": "waveline", "author": "nexor", "description": ".", "tags": ["wave"], "likes": 21, "viewed": 132, "published": "Public", "date": "1591640557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    float t = 1.5/iResolution.y;\n    float k = 3.;\n    float d = 0.;\n    for(float f,i = -.108; i < .108; i+=.008)\n    { \n\t  f = round((i-p.y)*125.)/125.;\n      float x = p.x + cos(f*9.)*.25;\n      x = x*k;\n      float y = p.y+f;\n      y += -cos(x+f*18.+ iTime*.5)*smoothstep(1.,.0,abs(x))*.1;\n      float m = smoothstep(t,-t,y);\n      d = mix(d,m,m);\n    }\n    \n    col += d;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 551]], "test": "timeout"}
{"id": "wtlcDj", "name": "Color Noise", "author": "marcelliino", "description": "Non Black and White Noise", "tags": ["noise", "color"], "likes": 2, "viewed": 81, "published": "Public", "date": "1593152130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 pixelate(vec2 pos, float res){\n    return floor(pos * res+0.5)/res;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy / 0.5 - 1.0;\n    float ratio = max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    if(iResolution.x > iResolution.y){\n        uv.x *= ratio;\n    }else{\n        uv.y *= ratio;\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    uv = mix(pixelate(uv, 2.0), pixelate(uv, 6.0), cos(iTime/6.0)*0.5+0.5);\n  \tuv /= 0.5;\n    \n    float len;\n    const int mult = 3;\n    for(int i = 0; i < mult; i++){\n        len = length(uv);\n        uv.x += sin(uv.y - cos(len)) + cos(iTime/9.0);\n        uv.y += cos(uv.x - sin(len)) + sin(iTime/12.0);\n    }\n    vec3 liq = vec3(uv, len);\n    \n    col = hsv2rgb(vec3(length(fract(liq)), mod(ceil(len*2.5-0.5)/2.5, 5.0+4.0*cos(iTime/3.0)), 1.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 74], [76, 76, 98, 98, 267], [269, 269, 326, 326, 1095]], "test": "timeout"}
{"id": "wtlcDS", "name": "Healt Shader", "author": "MrOkiDoki", "description": "A shader for my game.", "tags": ["health"], "likes": 3, "viewed": 187, "published": "Public API", "date": "1593021725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\nfloat DrawPlus(vec2 uv,float blur)\n{\n    uv = abs(uv);\n    float plusX = length(uv - vec2(min(uv.x,0.2),0));\n    plusX = smoothstep(0.04,0.04-blur,plusX);\n    \n    float plusY = length(uv - vec2(0,min(uv.y,0.2)));\n    plusY = smoothstep(0.04,0.04-blur,plusY);   \n\t\n    return clamp(plusX + plusY,0.,1.);\n}\nfloat DrawCircle(vec2 uv)\n{\n    float offset = (0.5 * (sin(iTime*10.) + 1. )) * 0.002;\n    \n    float INminD = 0.38 + offset;\n\tfloat INmaxD = 0.42 + offset;\n\t\n\tfloat OUminD = 0.39 + offset;\n\tfloat OUmaxD = 0.41 + offset;\n    \n    float alpha = 0.;\n    float dist = length(uv);\n\n\tif(dist > INminD && dist < INmaxD)\n    {\n        //Get the angle given UV\n        float angle = atan(-uv.y,uv.x) * (180. / 3.1415);\n        \n        //Normalize Angle\n        if(angle < 0.)\n        \tangle = angle + 360.;\n        \n        //Shift & Normalize\n        angle -= 270.;\n        angle = fract(angle/360.)*360.;\n        \n        if(angle < ( fract((iTime * 360.) / 360.)*360.))\n        {\n        \talpha = 1.;\n        }\n        else\n        {\n            if(dist > OUminD && dist < OUmaxD)\n    \t\t{\n    \t\t    alpha = fract(angle/10.);\n                if(alpha < 0.4 || alpha > 0.8)\n\t\t\t\t\talpha = 0.;\n                else\n                    alpha = 1.;\n    \t\t}\n        }\n        \n    }\n\n    return clamp(alpha,0.,1.);\n}\n\nconst vec3 PlusColor = vec3(0.9,.15,.1);\nconst vec3 CircleColor = vec3(1,.6,.1);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5 *iResolution.xy) / iResolution.y;\n    \n\n    vec3 col = vec3(0.);\n    \n    //Circle\n\tfloat circleAlpha = DrawCircle(uv);\n    //Plus\n\tfloat plusAlpha = DrawPlus(uv,.001);\n\t\n    \n    col += PlusColor * plusAlpha;\n    col += CircleColor * circleAlpha;\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 40, 40, 309], [310, 310, 337, 337, 1314], [1399, 1399, 1456, 1456, 1772]], "test": "timeout"}
{"id": "WtlcR7", "name": "[TWITCH] Wire Mess", "author": "Flopine", "description": "Shader made during a live stream on Twitch you can watch here: https://www.twitch.tv/flopine/videos\nI did this shader for my friend's videogame called Gentris: https://twitter.com/PiersBishopArt/status/1270294149200318470", "tags": ["raymarching", "isometric", "orthographic", "twitch"], "likes": 7, "viewed": 160, "published": "Public", "date": "1591709702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// I did this shader for my friend's videogame called Gentris\n// https://twitter.com/PiersBishopArt/status/1270294149200318470\n\n#define ITER 64.\n#define PI acos(-1.)\n#define time(speed) fract(iTime*speed)\n#define anim(speed) easeInOutCirc(time(speed))\n#define lines(s, puv) smoothstep(s,s*lines_blur, abs(puv.y))\n\n// SHADER PARAMETERS\n#define BPM (125./60.)\n\n#define spheres_speed 0.6\n#define spheres_speedvariation .1\n\n#define lines_frequency 5.\n#define lines_thickness 0.1\n#define lines_blur 1.05\n#define lines_speed -(.2)\n\n#define color1 vec3(0.5,0.05,0.1)\n#define color2 vec3(0.1,0.8,0.5)\n#define backgroundcolor vec3(.0,.01,.04)\n#define light_position vec3(1.,1.,-2.)\n\nfloat easeInOutCirc (float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - (2. * x) * (2. * x))) / 2.\n        : (sqrt(1. - (-2. * x + 2.) * (-2. * x + 2.)) + 1.) / 2.;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float id = floor(a/per);\n    if (id >= rep*0.5) id = abs(id);\n    a = mod(a,per)-per*.5;\n    p = vec2(cos(a),sin(a)) * length(p);\n    return id;\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat primitive1 (vec3 p, float s_speed)\n{\n    float per = 1.;\n    float thread = cyl(p.xzy, 0.03, 10.);\n\n    float radius = .07;\n    p.y += anim(s_speed);\n    p.y = mod(p.y,per)-per*.5;\n    float spheres = length(p)-radius; \n\n    float d = smin(thread,spheres,0.1);\n    return d;\n}\n\nvec3 new_p;\nfloat scene (vec3 p) \n{\n    p.yz *= rot(atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n\n\n    mo(p.xz,vec2(1.));\n    p.x -= 0.5+sin(p.y)*.5;\n    mo(p.xz, vec2(.2));\n    p.xz *= rot(p.y*2.);\n    float pid = moda(p.xz, 4.);\n    p.x -= 0.2;\n\n    new_p = p;\n    float d =  primitive1(p, (pid * spheres_speedvariation - 1.) * spheres_speed);\n\n    return d;\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(scene(p)-vec3(scene(p-eps.xyy),scene(p-eps.yxy),scene(p-eps.yyx)));\n}\n\nfloat texture_threads (vec2 uv)\n{\n    uv.y += anim(lines_speed);\n    uv *= lines_frequency;\n    uv.y = fract(uv.y)-.5;\n    return clamp(1.-lines(lines_thickness, uv),0.,1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv,-80.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = normalize(light_position),\n        col = backgroundcolor;\n\n    bool hit = false;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = scene(p);\n        if (d<0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += d*rd*.7;\n    }\n\n    float mask = texture_threads(vec2(atan(new_p.z,new_p.x),new_p.y));\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = mix(color1, color2, mask);\n        col *= (dot(n,l)*.5+.5);\n    }\n\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlcR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[992, 992, 1023, 1023, 1163], [1165, 1165, 1185, 1185, 1228], [1230, 1266, 1307, 1307, 1391], [1393, 1393, 1431, 1431, 1640], [1642, 1642, 1674, 1674, 1720], [1722, 1722, 1760, 1760, 1799], [1801, 1801, 1843, 1843, 2083], [2097, 2097, 2120, 2120, 2446], [2448, 2448, 2470, 2470, 2591], [2593, 2593, 2626, 2626, 2768], [2770, 2770, 2826, 2826, 3477]], "test": "timeout"}
{"id": "wtlcRS", "name": "Pulse From Center", "author": "fermion", "description": " ", "tags": ["2d", "pulse", "visualization", "hypnotic"], "likes": 0, "viewed": 67, "published": "Public API", "date": "1592398770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    float aspectRatio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.x;\n    \n    //center at (0, 0)\n    uv = (2.0 * uv) - vec2(1, aspectRatio);\n    \n    //polar coords\n    float distanceFromCenter = distance(vec2(0, 0), uv.xy);\n    float angle = atan(uv.y, uv.x);\n    \n    float angularSpeed = 2.0f;\n    float spiralOffset = sin(iTime * 0.05f) * distanceFromCenter * 25.0f;\n    \n    float rippleVariance = (1.0f - abs( cos(iTime * 0.01f) )) * 0.07f + 0.01f;\n    int numPetals = 9;\n    \n    // apply petals\n    distanceFromCenter += sin(iTime * angularSpeed + angle * float(numPetals) + spiralOffset) * rippleVariance;\n    \n    float speed = 1.0f;\n    float zoom = log(iTime + 1.0f) * 3.0f + 5.0f;\n    float phase = -(speed * iTime / zoom) + distanceFromCenter;\n\n    vec3 brightness = sin(vec3(phase * zoom));\n    \n    //make sin oscillate between 0 and 1\n    brightness = (0.5 * brightness) + 0.5;\n    \n    // blend between colors\n    float lowColorBlend = 0.5f * sin(iTime * 0.1) + 0.5f;\n    vec3  lowColor_0 = vec3(0.9, 0.0, 0.3);\n    vec3  lowColor_1 = vec3(0.2, 0.0, 0.9);\n    vec3  lowColor = mix(lowColor_0, lowColor_1, lowColorBlend);\n    \n    float highColorBlend = 0.5f * sin(iTime * 0.04f) + 0.5f;\n    vec3  highColor_0 = vec3(1.0, 0.5, 0.4);\n    vec3  highColor_1 = vec3(0.3, 0.0, 0.3);\n    vec3  highColor = mix(highColor_0, highColor_1, highColorBlend);\n    \n    vec3 color = mix(lowColor, highColor, brightness);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 1615]], "test": "timeout"}
{"id": "WtlcWX", "name": "Moon and Sea", "author": "dean_the_coder", "description": "First attempt at a water effect.\nStarted off making a 'day time' scene, but by happy accident made a 'night scene' instead!", "tags": ["3d", "raymarching", "sea", "water", "moon"], "likes": 6, "viewed": 317, "published": "Public API", "date": "1593278130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Processed by 'GLSL Shader Shrinker' (2,112 to 1,707 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nfloat sdWaves(vec3 p) {\n\tfloat t,\n\t      h = 0.,\n\t      a = 1.,\n\t      f = 1.1;\n\tmat2 r = rot(3.7692);\n\tt = iTime / 3.;\n\tfor (float i = 0.; i < 6.; i++) {\n\t\tp.xz *= r;\n\t\th += 1. - abs(sin(f * ((p.x + sin(p.z * a)) + t))) * a;\n\t\ta /= 1.97;\n\t\tf *= 2.02;\n\t\tt *= -.95;\n\t}\n\n\treturn p.y - h / 7.;\n}\n\nvec3 calcNormal(vec3 p) {\n\tconst vec2 e = vec2(1, -1) * .0005;\n\treturn normalize(e.xyy * sdWaves(p + e.xyy) + e.yyx * sdWaves(p + e.yyx) + e.yxy * sdWaves(p + e.yxy) + e.xxx * sdWaves(p + e.xxx));\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n\tvec3 rd = normalize(lightPos - p);\n\tfloat h,\n\t      minH = 1.,\n\t      d = .1;\n\tfor (int i = 0; i < 16; i++) {\n\t\th = sdWaves(p + rd * d);\n\t\tminH = abs(h / d);\n\t\tif (minH < .01) return 0.;\n\t\td += h;\n\t}\n\n\treturn minH * sharpness;\n}\n\nfloat glow = 0.;\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col;\n\t{\n\t\tvec3 p,\n\t\t     rd = getRayDir(vec3(0, 1.5, -10), vec3(0), uv);\n\t\tbool hit = false;\n\t\tfloat d = .01;\n\t\tfor (float steps = 0.; steps < 128.; steps++) {\n\t\t\tp = vec3(0, 1.5, -10) + rd * d;\n\t\t\tfloat h = sdWaves(p),\n\t\t\t      dd = length(p - vec3(.1, 2, -2));\n\t\t\tglow += .1 / (.1 + dd * dd * 5.);\n\t\t\tif (dd < h) h = dd;\n\t\t\tif (h < .005 * d) {\n\t\t\t\thit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td += h;\n\t\t}\n\n\t\tif (hit) {\n\t\t\tvec3 n = calcNormal(p),\n\t\t\t     lightToPoint = normalize(vec3(4, 20, 10) - p);\n\t\t\tfloat sha = calcShadow(p, vec3(4, 20, 10), 5.),\n\t\t\t      mainLight = max(0., dot(n, lightToPoint)),\n\t\t\t      fog = 1. - exp(-d * .02);\n\t\t\tcol = mix((mainLight * sha + 2.) * vec3(1, .9, .8), vec3(.15, .2, .25), (1. - .98 * max(0., dot(rd, n))));\n\t\t\tcol *= vec3(.2, .32, .41);\n\t\t\tcol = mix(col, vec3(.15, .2, .25), fog);\n\t\t}\n\t\telse col = vec3(.15, .2, .25);\n\t}\n\tfragColor = vec4(pow(vignette(clamp(col + max(0., glow), 0., 1.), fragCoord), vec3(.4545)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 143, 143, 210], [212, 212, 259, 259, 431], [433, 433, 456, 456, 725], [727, 727, 752, 752, 925], [927, 927, 985, 985, 1215], [1234, 1234, 1275, 1275, 1401], [1403, 1403, 1455, 1455, 2474]], "test": "timeout"}
{"id": "wtlyDM", "name": "Caverns of Chaos", "author": "jarble", "description": "With a few changes to my \"corridor\" fractal, I made these \"caverns.\"", "tags": ["3d", "raymarching", "fractal", "cave"], "likes": 0, "viewed": 194, "published": "Public API", "date": "1592251745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    float color1 = length(sin(p/100.0))/2.0;\n    return vec3(color1,color1/1.8+sin(length(p)/10.0)/20.0,color1/2.0);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat caves1(vec3 p){\n    vec3 p1 = p/size;\n    return length(sin(vec3(sin(p1.x)/p1.x,cos(p1.y)-p1.y,sin(p1.z)+p1.z))*size) - size;\n}\n\nfloat caves(vec3 p) {\n    //p += sin(p.y/100.0)*100.0;\n    float result = caves1(p);\n    for(float i = 1.0; i < 100.0; i *= 10.0){\n        p = p.yxz-p.zyx;\n        result = max(result, caves1(p/i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n\treturn result;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn caves(p/scale)*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float speed = 10.0;\n    vec3 eye = scale*vec3(cos(iTime)/3.0,sin(iTime)/1.8,iTime*speed)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 377, 377, 517], [761, 761, 782, 782, 894], [896, 896, 917, 950, 1180], [1182, 1182, 1205, 1205, 1237], [1239, 1660, 1751, 1751, 2106], [2121, 2375, 2440, 2440, 2572], [2574, 2663, 2692, 2692, 3002], [3004, 3496, 3636, 3636, 4246], [4248, 4618, 4703, 4703, 5407], [5409, 5736, 5785, 5820, 5951], [5953, 5953, 6010, 6010, 7122]], "test": "timeout"}
{"id": "WtlyDN", "name": "Twist towers", "author": "TAKUSAKU", "description": "Twist towers", "tags": ["tower", "twist", "tiers"], "likes": 1, "viewed": 57, "published": "Public", "date": "1592119900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 U )\n{\n  vec3 u=vec3(2.*U-iResolution.xy,iResolution.y)/50.*sin(iTime*.2);\n  for(int i=0;i<5;i++)\n  u.x+=fract(u.y+iTime+cos(u.x))*.2*sin(iTime),\n  u.xy+=sin(u.x+u.y+iTime*5.)*.1,\n  o=cos(float(u)+vec4(.2,.1,0,0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 251]], "test": "timeout"}
{"id": "wtlyDs", "name": "Sinusoids Wave 2D", "author": "changjiu", "description": "Sinusoids Wave; 2D ocean", "tags": ["sinusoidswave"], "likes": 2, "viewed": 215, "published": "Public API", "date": "1593495598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\ncorrect the dot shape to circle;\nantialias;\nsimplify;\nby FabriceNeyret2;\n*/\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R.y, P;\n  \n    float c = length( U - vec2(.9,.73) ) - 0.1435;\n    \n    U = U*50. + U.y*10.* cos( iTime + U.x*5.6+vec2(0,11) );\n\n    P =   ( U - round(U) )                                     // loc coords % dot center\n        * inverse(transpose(mat2(dFdx(U),dFdy(U)))) *50./R.y;  // in screen coords\n\n    O = abs(U.x-45.) < .5 ? vec4(0,1 ,0 ,1) : vec4(0,.2,.2,1); // dots color\n    O = mix( O, vec4(0,.2,.9,0),  smoothstep(0.,50./R.y, length(P) - .2 )); // draw water & dots\n\n    O *= smoothstep( 200./R.y, 0., U.y - 35.5 );               // draw surface\n    O = mix( vec4(1,0,0,0), O, smoothstep(0., 1.5/R.y, abs(c)-.0015) ); // draw circle\n}\n\n/*old version \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvOld = vec2(uv.x,uv.y);\n    uv *= 50.0;\n    \n    float time0 = iTime + fragCoord.x/iResolution.x*10.0;\n    uv += uvOld.y*10.0*vec2(cos(time0), sin(time0));\n    \n    float top = 35.5;\n    float bottom = 15.5;\n\n    float x = uv.x;\n    float y = uv.y;\n\n    vec3 col = vec3(0,0,0);;\n    \n    float x0 = x-round(x);\n    float y0 = y-round(y);\n    vec2 pos0 = vec2(x0,y0);\n    \n    vec2 center = vec2(0,0);\n\n    \n    \n    if(y<top){\n        col = vec3(0.,0.2,0.9);\n        \n    \tif(distance(pos0,center)<0.2){\n            \n        \tcol = vec3(0.0,0.2,0.2);\n            \n            if(uv.x>44.5 && uv.x<45.5){\n                col = vec3(0.,1.0,0.);\n            }\n    \t}\n    }\n    \n   \n\tvec2 center1 = vec2(0.9,0.73);\n    float dis = distance(uvOld,center1);\n    if(dis<0.145 && dis>0.142){\n    \tcol = vec3(1.,0.,0.);\n    }\n    \n\n\n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 117, 117, 806]], "test": "error"}
{"id": "WtlyR4", "name": "March of the Androids 2", "author": "dr2", "description": "Updated, with a more appropriate color scheme", "tags": ["robot", "order"], "likes": 12, "viewed": 264, "published": "Public API", "date": "1591550116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"March of the Androids 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar, rAngH, rAngL, rAngA, gDisp;\nint idObj;\nbool walk;\nconst float pi = 3.1415927;\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], rPath, a, r, tC, tL, tWf, tWb, rDir;\n  bool rotStep;\n  rPath = 34.;\n  tC = pi * rPath / 8.;\n  tL = 2. * rPath / 5.;\n  tWf = 4.;\n  tWb = 2.;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tWf;\n  ti[2] = ti[1] + tL;\n  ti[3] = ti[2] + tWb;\n  ti[4] = ti[3] + tC;\n  p.y = 1.;\n  rDir = 2. * floor (mod (t / ti[4], 2.)) - 1.;\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    tr.y = rPath;\n  } else if (t < ti[2]) {\n    tr.y = rPath - 2. * rPath * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    tr.y = - rPath;\n  } else {\n    rotStep = true;\n    a = 1.5 - rDir * (t - ti[3]) / (ti[4] - ti[3]);\n    r = rPath;\n  }\n  if (rotStep) {\n    a *= pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  p.xz -= 2.5;\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  vec2 ip;\n  float dMin, d, bf, hGap, bFac, ah;\n  int objType;\n  hGap = 2.5;\n  bf = PrBoxDf (p, vec3 (9. * hGap, 6., 9. * hGap));\n  pp = p;\n  ip = floor ((pp.xz + hGap) / (2. * hGap));\n  pp.xz = pp.xz - 2. * hGap * ip;\n  objType = (ip.x == 0. && ip.y == 4.) ? 20 : 10;\n  bFac = (objType == 20) ? 1.6 : 1.;\n  ah = rAngH * (walk ? sign (1.1 - bFac) : - step (1.1, bFac));\n  dMin = dstFar;\n  q = p;\n  d = q.y + 1.;\n  DMINQ (1);\n  q = pp;\n  q.y -= 1.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  d = max (d, bf);\n  DMINQ (objType + 1);\n  q = pp;\n  q.y -= 0.55;\n  d = PrRoundCylDf (q.xzy, 0.9, 0.28, 0.7);\n  d = max (d, bf);\n  DMINQ (objType + 1);\n  q = pp;\n  q.x = abs (q.x) - 0.4;\n  q.yz = Rot2D (q.yz, - rAngL * sign (pp.x));\n  q.y -= -0.525;\n  d = PrRoundCylDf (q.xzy, 0.25, 0.15, 0.55);\n  d = max (d, bf);\n  DMINQ (objType + 1);\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  if (bFac > 1.) {\n    q.xz = Rot2D (q.xz, 2. * pi * floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 6.);\n    q.x += 0.4;\n  } else {\n    q.x = abs (q.x) - 0.4;\n  }\n  q.y -= 2.;\n  q.xy = Rot2D (q.xy, -0.2 * pi * sign (bFac - 1.1));\n  q.y -= 0.2 * (2. * bFac - 1.);\n  d = PrRoundCylDf (q.xzy, 0.06, 0.04, 0.4 * (2. * bFac - 1.));\n  d = max (d, bf);\n  DMINQ (objType + 2);\n  q = pp;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, rAngA * (walk ? sign (pp.x) : 1.));\n  q.y -= -0.6;\n  d = PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6);\n  d = max (d, bf);\n  DMINQ (objType + 3);\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q -= vec3 (0., 1.6 + 0.3 * (bFac - 1.), 0.7 - 0.3 * (bFac - 1.));\n  d = PrSphDf (q, 0.15 * bFac);\n  d = max (d, bf);\n  DMINQ (objType + 4);\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ChqPat (vec3 p, float dHit)\n{\n  vec2 q, iq;\n  float f, s;\n  p.z += gDisp;\n  q = p.xz + vec2 (0.5, 0.25);\n  iq = floor (q);\n  s = 0.5 + 0.5 * Noisefv2 (q * 107.);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = smoothstep (0., 0.02, abs (fract (q + 0.5) - 0.5));\n  f = dHit / dstFar;\n  return s * (1. - 0.9 * exp (-2. * f * f) * (1. - q.x * q.y));\n}\n\nvec3 ObjCol (vec3 rd, vec3 vn, float dHit)\n{\n  vec3 col;\n  int idObjP;\n  idObjP = idObj;\n  if (idObjP == 1) {\n    col = mix (vec3 (0.2, 0.3, 0.2), vec3 (0.3, 0.3, 0.35),\n       (0.5 + 0.5 * ChqPat (qHit / 5., dHit)));\n  } else if (idObjP > 20) {\n    idObjP -= 20;\n    if (idObjP == 1 || idObjP == 2 || idObjP == 3) col = vec3 (1., 0.7, 0.1);\n    else if (idObjP == 4) col = vec3 (0.3, 1., 0.1);\n  } else if (idObjP > 10) {\n    idObjP -= 10;\n    if (idObjP == 1) col = vec3 (0.05);\n    else if (idObjP == 2) col = (qHit.y > 0.) ? vec3 (1.) : vec3 (0.05);\n    else if (idObjP == 3) col = (qHit.y < 0.) ? vec3 (1.) : vec3 (0.05);\n    else if (idObjP == 4) col = vec3 (1., 0.1, 0.1);\n  }\n  return col * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n     0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    col = vec3 (0.1) + 0.2 * pow (1. - max (rd.y, 0.), 8.);\n    col = mix (col, vec3 (1.), clamp (0.1 + 1.5 * Fbm2 (0.05 * (ro.xz +\n       rd.xz * (50. - ro.y) / rd.y)) * rd.y, 0., 1.));\n  } else {\n    col = mix (vec3 (0.6, 0.5, 0.3), 0.9 * (vec3 (0.1) + 0.2) + 0.1, pow (1. + rd.y, 5.));\n  }\n  col *= vec3 (1., 0.7, 0.7);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, c;\n  float dstHit, tCyc, refl, spd;\n  spd = 0.7;\n  tCyc = mod (spd * tCur, 7.);\n  if (tCyc < 4.) {\n    walk = true;\n    tCyc = mod (tCyc, 1.);\n    gDisp = mod (spd * tCur, 1.);\n    rAngH = -0.7 * sin (2. * pi * tCyc);\n    rAngA = 1.1 * sin (2. * pi * tCyc);\n    rAngL = 0.6 * sin (2. * pi * tCyc);\n  } else {\n    walk = false;\n    tCyc = mod (tCyc, 1.);\n    gDisp = 0.;\n    rAngH = 0.4 * sin (2. * pi * tCyc);\n    rAngA = 2. * pi * (0.5 - abs (tCyc - 0.5)); \n    rAngL = 0.;\n  }\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    col = ObjCol (rd, vn, dstHit);\n    if (idObj != 1) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refl = 0.2 + 0.3 * pow (1. - dot (vn, rd), 4.);\n      dstHit = ObjRay (ro, rd);\n      if (dstHit < dstFar) {\n        ro += rd * dstHit;\n        c = ObjCol (rd, ObjNf (ro), dstHit);\n      } else {\n        c = BgCol (ro, rd);\n      }\n      col = mix (col, c, refl);\n    }\n    col *= ObjSShadow (ro, sunDir);\n  } else {\n    col = BgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, vd, u;\n  vec2 canvas, uv;\n  float f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  ro = TrackPath (tCur);\n  vd = normalize (vec3 (0., 2., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 2.2));\n  dstFar = 150.;\n  sunDir = normalize (vec3 (1., 2., 1.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float s, hz;\n  s = length (p.xy) - r;\n  hz = abs (p.z) - h;\n  return min (min (max (s + rt, hz), max (s, hz + rt)), length (vec2 (s, hz) + rt) - rt);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlyR4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[519, 519, 545, 545, 1347], [1349, 1349, 1371, 1371, 3057], [3059, 3059, 3092, 3092, 3268], [3270, 3270, 3291, 3291, 3539], [3541, 3541, 3576, 3576, 3903], [3905, 3905, 3949, 3949, 4712], [4714, 4714, 4751, 4751, 4972], [4974, 4974, 5005, 5005, 5399], [5401, 5401, 5436, 5436, 6522], [6524, 6524, 6580, 6580, 7149], [7151, 7151, 7181, 7181, 7294], [7296, 7296, 7328, 7328, 7428], [7430, 7430, 7463, 7463, 7490], [7492, 7492, 7549, 7549, 7703], [7737, 7737, 7761, 7761, 7873], [7875, 7875, 7900, 7900, 8086], [8088, 8088, 8109, 8109, 8264]], "test": "error"}
{"id": "wtlyR8", "name": "ntsutae's \"Circuit Diagram2\"", "author": "chordbug", "description": "A GLSL port of ntsutae's Processing sketch.", "tags": ["xor"], "likes": 14, "viewed": 227, "published": "Public", "date": "1591460404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Circuit Diagram2\" by ntsutae\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(fragCoord.x);\n  int y = int(fragCoord.y + 30.0 * iTime);\n  int r = (x+y)^(x-y);\n  bool b = abs(r*r*r) % 997 < 97;\n  fragColor = vec4(vec3(b ? 1.0 : 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 139, 194, 194, 370]], "test": "timeout"}
{"id": "wtlyRn", "name": "That's why I want to learn shdrs", "author": "postviolet", "description": "The magic of copy and paste", "tags": ["raymarching"], "likes": 6, "viewed": 230, "published": "Public API", "date": "1591295418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//ромбики фрактальные\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec3 opCheapBend(in vec3 p )\n{\n    const float k = -0.50; \n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2 m = mat2(c,-s,s,c);\n    vec3 q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nmat4 rotateX( in float angle ) {\n  return mat4(  1.0,    0,      0,      0,\n           0,   cos(angle),  -sin(angle),    0,\n          0,   sin(angle),   cos(angle),    0,\n          0,       0,        0,     1);\n}\n\nmat4 rotateY( in float angle ) {\n  return mat4(  cos(angle),    0,    sin(angle),  0,\n               0,    1.0,       0,  0,\n          -sin(angle),  0,    cos(angle),  0,\n              0,     0,        0,  1);\n}\n\nmat4 rotateZ( in float angle ) {\n  return mat4(  cos(angle),    -sin(angle),  0,  0,\n           sin(angle),    cos(angle),    0,  0,\n              0,        0,    1,  0,\n              0,        0,    0,  1);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n  samplePoint = (rotateY(sin(iTime/2.)) * vec4(samplePoint, 1.)).xyz;\n  samplePoint = (rotateX(sin(iTime/2.)) * vec4(samplePoint, 1.)).xyz;\n  samplePoint = (rotateZ(sin(iTime/2.)) * vec4(samplePoint, 1.)).xyz;\n  samplePoint = opRep(samplePoint, vec3(3., 4., 14.));\n    \n    return sdOctahedron(samplePoint, 0.446);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n      return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.800,0.096,0.119);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(1.736,\n                          2.0 ,\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 dir = rayDirection(45., iResolution.xy, fragCoord.xy);\n    vec3 eye = vec3(0., 0., 40.)+sin(iTime);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n    }\n    \n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.222,0.141,0.440);\n    vec3 K_d = vec3(0.700,0.602,0.194);\n    vec3 K_s = vec3(0.179,0.962,1.000);\n    float shininess = 20.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 201, 201, 241], [243, 243, 280, 280, 363], [365, 365, 395, 395, 551], [553, 553, 607, 607, 709], [711, 711, 749, 749, 802], [804, 804, 837, 837, 902], [904, 904, 956, 956, 1055], [1057, 1057, 1092, 1092, 1143], [1145, 1145, 1177, 1177, 1357], [1359, 1359, 1391, 1391, 1570], [1572, 1572, 1604, 1604, 1781], [1783, 1783, 1817, 1817, 2134], [2137, 2137, 2228, 2228, 2537], [2540, 2540, 2605, 2605, 2737], [2740, 2740, 2769, 2769, 3079], [3082, 3082, 3222, 3222, 3651], [3654, 3654, 3739, 3739, 4506], [4509, 4509, 4566, 4566, 5157]], "test": "timeout"}
{"id": "wtlyRS", "name": "Hypnosis [Terah]", "author": "Terah", "description": "Hypnosis \n\nLots of circles xor'ed together with color shifted by a small time delta", "tags": ["2d", "xor", "colorshift"], "likes": 9, "viewed": 146, "published": "Public", "date": "1592395849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(-1.);\n\nfloat xor(float a, float b) { return a*(1.-b) + b*(1.-a); }\n\nmat2 rot(float a){\n    float c=cos(a);float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n\nfloat V(vec2 uv, float t) {\n    \n    \n    \n   \tuv *= rot(pi/4.);\n    \n\n    uv *= 5.;\n    uv += .5;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    \n    float s = 0.;\n    \n    \n    for(float x=-2.;x<3.;++x) {\n        for(float y=-2.;y<3.;++y) {\n        \tvec2 o = vec2(x, y);\n            \n            float d = length(id+o)*mix(.2, .7, sin(3.3*t+pi/4.)*.5+.5);\n            \n            float r = mix(.95, 2.5, sin(d-t)*.5+.5);\n            \n            float c = smoothstep(r, r*.985, length(gv-o));\n            s = xor(s, c);\n    \t}\n    }\n    \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*.3 + 70.;\n      \n    \n    vec3 col = vec3(0);\n    \n    for(int i=0;i<3;++i) {\n    \tcol[i] = V(uv, t + float(i)*0.015);    \n    }\n    \n    \n    col = pow(col, vec3(1./2.2));\n   \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 58, 58, 88], [90, 90, 108, 108, 172], [175, 175, 202, 202, 751], [753, 753, 810, 810, 1106]], "test": "error"}
{"id": "WtlyWs", "name": "Logarithmic Moebius Transform 8", "author": "FabriceNeyret2", "description": "inspired by [url]https://www.facebook.com/eric.wenger.547/videos/2727028317526304/[/url]", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "reproduction"], "likes": 16, "viewed": 373, "published": "Public API", "date": "1593447033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3llcDl\n// inspired by https://www.facebook.com/eric.wenger.547/videos/2727028317526304/\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I,\n         U = (2.*u - R) / R.y,                                // normalized coordinates\n\t     z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n              \n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U+=.5))*vec2(.5, -.5) + iTime/8.\n        + atan(U.y, U.x)/6.2832 * vec2(6, 1);        \n\t                               // n  \n    U *= 3./vec2(2,1); z = fwidth(U);\n    U = fract(U)*5.; I = floor(U); U = fract(U);              // subdiv big square in 5x5\n    I.x = mod( I.x - 2.*I.y , 5.);                            // rearrange\n    U.x += float(I.x==1.||I.x==3.); U.y += float(I.x<2.);     // recombine big tiles\n    float id = -1.;\n    if (I.x!=4.) U /= 2.,                                     // but small times\n        id = mod(floor(I.x/2.)+I.y,5.);\n    U = abs(fract(U)*2.-1.); float v = max(U.x,U.y);          // dist to border\n    O =   smoothstep(.7,-.7, (v-.95)/( abs(z.x-z.y)>1.?.1:z.y*8.))  // draw AA tiles\n        * (id<0.?vec4(1): .6 + .6 * cos( id  + vec4(0,23,21,0)  ) );// color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 167, 167, 1317]], "test": "timeout"}
{"id": "Wtlyz8", "name": "Cycle of light", "author": "photonic", "description": "Wait for it until it forms.\nThe ones that comes from bottom are souls that have just been born. The ones that go away at top are souls that\nIn fullscreen you'll see that in the middle is a humanoid silhouette with the arms lifted representing God", "tags": ["light"], "likes": 11, "viewed": 121, "published": "Public", "date": "1591434396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    uv -= 0.5;\n    uv *= 10.;\n\n    uv.y *= .1;    \n\n    uv.x /= tan(uv.y) * (iResolution.x /1.6) /  tan(uv.x * (iTime + 1000.0) / 10.2) - uv.x * (iResolution.x / 35.);     \n\n    col -=  step(1., abs(uv.y)) - step(uv.y, abs(uv.y));\n    \n    col.r = uv.x / cos(sin(iTime));\n    \n    col.g *= length(uv.x);\n    \n    col.b = sin(uv.x) * (cos(iTime) * 3.0);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4tBGz3", "previewfilepath": "https://soundcloud.com/joevr/tibetan-buddhist-monks-om", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/joevr/tibetan-buddhist-monks-om", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtlyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 532]], "test": "timeout"}
{"id": "wtlyzB", "name": "Atmosphere Learning", "author": "DootNoot", "description": "An extension of https://www.shadertoy.com/view/XtBXDz that I made to better understand atmospheric scattering.\nI also added a second light source to act as a \"moon\"!\nI know you can use an analytical approximation for the nested loops. I'm still learning.", "tags": ["test", "atmosphere", "rayleigh", "mie", "scatering"], "likes": 3, "viewed": 269, "published": "Public", "date": "1592493352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926536\n#define time (iTime/10.)\n\nstruct ray_t{\n    vec3 origin;\n    vec3 direction;\n};\nstruct sphere_t{\n    vec3 origin;\n    float radius;\n};\n   \n    \n// scattering coefficients at sea level (m)\nconst vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6); // Rayleigh \nconst vec3 betaM = vec3(21e-6); // Mie\n\n// scale height (m)\n// thickness of the atmosphere if its density were uniform\nconst float hR = 7994.0; // Rayleigh\nconst float hM = 1200.0; // Mie\n\n\nfloat rayleigh_phase_func(float mu){\n    return 3.*(1.+mu*mu)/(16.*PI);\n}\n\n//A beloved classic\nconst float g = 0.76;\nfloat henyey_greenstein_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t\t(1. - g*g)\n\t/ //---------------------------------------------\n\t\t((4. * PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\n//This function came from https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n//It seems to be an extension of the HG phase function though\n//I don't actually use it anywhere\nfloat mie_phase_func(float mu){\n    return 3.*(1.-g*g)*(1.+mu*mu)/(8.*PI)/(2.+g*g)/pow(1.+g*g-2.*g*mu,1.5);\n}\n    \n//I haven't looked into the specifics of this function yet, I just copied it straight from https://www.shadertoy.com/view/XtBXDz\nbool intersects_sphere(in ray_t ray, in sphere_t sphere, inout float t0, inout float t1){\n    vec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2) return false;\n\tfloat thc = sqrt(radius2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\treturn true;\n}\n\n\nconst float earth_radius = 6360e3; // (m)\nconst float atmosphere_radius = 6420e3; // (m)\n\n//control the intensity and color of the light sources\nconst vec3 sun_power = vec3(20.0);\nconst vec3 moon_power = sun_power * vec3(0.2,0.2,0.35);\n\nconst int num_samples = 14;\nconst int num_samples_light = 3; //The original shader used 8, but I think you can get away with 3 (speedup will be substantial)\n\nconst sphere_t atmosphere = sphere_t(vec3(0.),atmosphere_radius);\nconst sphere_t earth = sphere_t(vec3(0.),earth_radius);\n\nbool get_sun_light(in ray_t ray, inout float opticalDepthR, inout float opticalDepthM){\n    float t0,t1;\n    intersects_sphere(ray, atmosphere,t0,t1);\n    \n    float march_pos = 0.;\n    float march_length = t1 / float(num_samples_light);\n    \n    for(int i=0; i<num_samples_light; i++){\n        vec3 s = ray.origin + ray.direction*(march_pos + 0.5*march_length);\n        float height = length(s)-earth_radius;\n        opticalDepthR += exp(-height/hR) * march_length;\n        opticalDepthM += exp(-height/hM) * march_length;\n        \n        march_pos += march_length;\n    }\n    return true;\n}\n\nvec3 get_incident_light(in ray_t ray){\n    vec3 sun_dir = normalize(vec3(.0, sin(time),cos(time))); //I need a better positioning method than this\n    \n    \n    if(iMouse.z>0.1){sun_dir = normalize(vec3(.0, sin(iMouse.x*2.*PI/iResolution.x - 1.),cos(iMouse.x*2.*PI/iResolution.x - 1.)));}//Mouse control instead of time\n    \n    vec3 moon_dir = -sun_dir; //moon is jus opposite of sun, but it doesn't need to be\n    \n    \n    \n    float t0,t1;\n    if(!intersects_sphere(ray, atmosphere, t0, t1)){return vec3(0.); }\n    \n    float march_length = t1 / float(num_samples);\n    \n    float mu = dot(sun_dir, ray.direction);\n    float muMoon = dot(moon_dir, ray.direction);\n    \n    float phaseR = rayleigh_phase_func(mu);\n    float phaseM = henyey_greenstein_phase_func(mu);\n    float phaseMoonR = rayleigh_phase_func(muMoon);\n    float phaseMoonM = henyey_greenstein_phase_func(muMoon);\n    \n    \n    //The accumulated extincion coefficients multiplied by the path length (optical depth = \"average density\")\n    float opticalDepthR = 0.;\n    float opticalDepthM = 0.;\n    float opticalDepthMoonR = 0.;\n    float opticalDepthMoonM = 0.;\n    \n    vec3 sumR = vec3(0.);\n    vec3 sumM = vec3(0.);\n    vec3 sumMoonM = vec3(0.);\n    vec3 sumMoonR = vec3(0.);\n    \n    float march_pos = 0.;\n    \n    for(int i=0; i<num_samples; i++){\n        vec3 s = ray.origin + ray.direction*(march_pos + 0.5*march_length); //sample middle of step\n        float height = length(s) - earth_radius;\n        \n        //sample densities\n        float hr = exp(-height / hR) * march_length;\n        float hm = exp(-height / hM) * march_length;\n        //Add to optical depth of primary ray - these variables will work for both the sun and moon\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        \n        //The moon is created by literally doing everything twice with extra \"moon\" variables\n        //I'm too lazy to find a better solution\n        ray_t light_ray = ray_t(s, sun_dir);\n        ray_t moon_ray = ray_t(s,moon_dir);\n        \n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float opticalDepthLightMoonR = 0.;\n        float opticalDepthLightMoonM = 0.;\n        \n        \n        bool overground = get_sun_light(light_ray, opticalDepthLightR,  opticalDepthLightM);\n        bool overgroundMoon = get_sun_light(moon_ray, opticalDepthLightMoonR, opticalDepthLightMoonM);\n        \n        if(overground || overgroundMoon){\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) \n                + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            \n            vec3 tauMoon = betaR * (opticalDepthR + opticalDepthLightMoonR) \n                + betaM * 1.1 * (opticalDepthM + opticalDepthLightMoonM);\n\n            vec3 attenuation = exp(-tau);\n            vec3 attenuationMoon = exp(-tauMoon);\n            \n            sumR += hr * attenuation;\n            sumM += hm * attenuation;\n            sumMoonR += hr * attenuationMoon;\n            sumMoonM += hm * attenuationMoon;\n        }\n        march_pos += march_length;\n    }\n    \n    \n    //Compute the final color by adding sun and moon lighting\n    vec3 col = sun_power * (sumR * phaseR * betaR +sumM * phaseM * betaM) \n        + moon_power * (sumMoonR * phaseMoonR * betaR + sumMoonM * phaseMoonM * betaM); \n    \n    //Draw circles around the celesteal bodies\n    //I know if-statements are bad\n    if(dot(ray.direction, sun_dir) > 0.9995)col *= (1.5,1.5,1.5);\n    if(dot(ray.direction, moon_dir) > 0.9995)col *= (1.9,1.9,1.9);\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy *2. - 1.;\n    uv *= vec2(16./9.,1.); //aspec correction\n    vec3 cameraCenter = vec3(0.,earth_radius+1.,0.);\n    if(iMouse.z>0.1){cameraCenter.y += 10e3 * iMouse.y/iResolution.y;}//Mouse control camera altitude\n    float cameraLength = 2.;\n    ray_t primary_ray = ray_t(cameraCenter, normalize(vec3(uv+vec2(0.,.5),cameraLength))); //I probably need to figure out camera transforms before making this better\n    vec3 col = get_incident_light(primary_ray);\n    col = pow(col*5.0 / (col*5.0+vec3(1)),vec3(2.2)); //Gamma correction from someone's comment in the original shader\n    fragColor = vec4(col,1.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 502, 502, 539], [583, 583, 629, 629, 753], [755, 968, 999, 999, 1077], [1083, 1212, 1301, 1301, 1581], [2102, 2102, 2189, 2189, 2694], [2696, 2696, 2734, 2734, 6258], [6260, 6260, 6317, 6317, 6962]], "test": "timeout"}
{"id": "wtlyzH", "name": "earthbound bg 1", "author": "thefox231", "description": "second attempt! this one much more successful, i think it looks nice : )", "tags": ["2d", "abstract", "snes", "earthbound"], "likes": 7, "viewed": 304, "published": "Public API", "date": "1591478318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 mainColor = vec3(.6, .0, 136./255.);\n\nfloat sawtooth(float a, float freq) {\n    if (mod(a, freq) < freq * 0.5) return mod(a, freq * 0.5);\n    return freq * 0.5 - mod(a, freq * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float resolutionRatio = iResolution.x / iResolution.y;\n    \n    // uv fuckery !\n    // pixelate\n    \n    float pxAmt = 60.0;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    // interlacing .\n    float pixAmt = 2.;\n    if (mod(fragCoord.y, pixAmt) < pixAmt * 0.5) {\n        uv += 0.1 + sin(iTime * 0.2 + uv.y * 8.) * 0.05;\n    } else {\n        uv -= 0.1 + sin(iTime * 0.2 + uv.y * 8. + .5) * 0.05;\n    }\n    \n    vec2 uv2 = uv;\n    \n    vec3 color = vec3(0.1);\n    \n    // first one (bg-ish thing??)\n    \n    color = vec3(mod(abs(sawtooth(uv.x, 0.6) * resolutionRatio + sawtooth(uv.y, 0.6) + iTime * 0.3), 0.4)) * mainColor;\n    \n    // second one (stripes-like thing)\n    \n    if (uv2.x < 0.5) {\n        uv2.x = 1.0 - uv2.x;\n    }\n    if (uv2.y > 0.5) {\n        uv2.y = 1.0 - uv2.y;\n    }\n\n    uv2.x += sin(uv2.y * 4.0 + iTime) * 0.1;\n    \n    if (mod(abs(uv2.x * resolutionRatio + uv2.y + iTime * 0.2), 0.2) < 0.1) {\n        vec3 lines = vec3(cos(uv.x * 2.0 + iTime + uv.y * 3.0)) * mainColor * 0.7;\n        color = mix(color, lines, 0.3);\n    }\n    \n    // color shortening\n    // gives it a kind of like snes-like palette\n    float shortAmt = 10.0;\n    color = ceil(color * shortAmt) / shortAmt;\n    \n    // feed the frag color .\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 194], [196, 196, 253, 253, 1611]], "test": "timeout"}
{"id": "wtlyzX", "name": "test:secondAttempt tri-planar", "author": "mehow_one", "description": "Second attempt at 3-planar mapping.\n", "tags": ["triplanar", "uv", "planar", "coord"], "likes": 1, "viewed": 181, "published": "Public API", "date": "1592678627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = normalize(vec3(0, 1, 0));\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n)\n{\n    vec3 blending = abs(p);\n    blending = normalize(max(blending, 0.00001));\n    \n    // normalized total value to 1.0\n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n    vec4 xaxis = texture(tex, p.yz);\n    vec4 yaxis = texture(tex, p.xz);\n    vec4 zaxis = texture(tex, p.xy);\n    \n    // blend the results of the 3 planar projections.\n    return (xaxis * blending.x + yaxis * blending.y + zaxis * blending.z).rgb;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdSphere(vec3 p, vec3 offs, float r)\n{\n    return length(p - offs) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat map(vec3 p)\n{\n    float d1 = sdSphere(p, vec3(-1, sin(iTime)*-1., 0), 1.0);\n    float d2 = sdBox(p, vec3(0.5));\n    return smin(d1, d2, .4);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy*p),\n        map(p - e.yxy*p),\n        map(p - e.yyx*p));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n    \n    float time = iTime * 0.5;\n    vec3 ro = vec3(cos(time) * 7., 2., sin(time) * 7.);\n    vec3 ta = vec3(0);\n    \n    vec3 p = ro;\n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.5));\n    \n    float d = 0., t = 0.;\n\n    for (int i = 0; i < 64; i++)\n    {\n        d = map(p);\n        if (d < 0.01) break;\n        p += ray * d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 n = normal(p);\n        vec3 tex = tex3D(iChannel0, p, n);\n        col = tex;\n    }\n    else\n    {\n    \tvec3 sky = vec3(0.5, 0.8, 1.5) * abs(1.0 - uv.y);\n    \tcol = sky;\n    }\n    \n    col.rgb = pow(col.rgb,vec3(1./1.65));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 216], [218, 218, 261, 261, 710], [712, 712, 741, 741, 784], [786, 786, 830, 830, 865], [867, 867, 908, 908, 1001], [1004, 1004, 1023, 1023, 1152], [1154, 1154, 1175, 1175, 1356], [1358, 1358, 1415, 1415, 2146]], "test": "error"}
{"id": "WtscD7", "name": "Cities on Mars", "author": "jarble", "description": "This planet's surface is covered with mesh-like megastructures.", "tags": ["3d", "raymarching", "planet"], "likes": 1, "viewed": 210, "published": "Public API", "date": "1592245437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float planet_size = 1000.0;\nint color;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*100.0;\n    float color1 = length(sin(p/2.0+sin(p.zxy/11.0+sin(p/17.0))))/5.0;\n    return vec3(color1*2.0,color1,color1);\n}\n\nvec3 plant_color(vec3 p)\n{\n    return vec3(0.8,0.8,0.8)+vec3(sin(length(p*5.0)))/8.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat sceneSDF1(vec3 p) {\n    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));\n}\n\nfloat sceneSDF2(vec3 p){\n    p *= 3.0;\n\treturn 0.5 + sceneSDF1(p/2.0+sceneSDF1(p/5.0));\n}\n\nfloat dunes1(vec3 p,float distortion){\n    p *= distortion;\n\treturn sin((p.x/3.0+p.y/5.0+p.z/11.0))/distortion;\n}\nfloat dunes(vec3 p,float distortion){\n\treturn dunes1(p,distortion) + dunes1(p.zxy,distortion);\n}\n\nfloat planet_surface(vec3 p){\n return\tlength(p)-planet_size;\n}\n\nfloat foliage1(vec3 p){\n    float size = 100.0;\n    p += sin(p/50.0)*50.0;\n    vec3 p1 = p/size;\n    p = sin(vec3(sin(p1.x)-p1.y,cos(p1.y)-p1.z,sin(p1.z)-p1.x))*size;\n    return length(p) - size;\n}\n\nfloat foliage(vec3 p,float jungle) {\n    float result = foliage1(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, foliage1(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return max(result,jungle-3.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = 1.1+dunes(p,10.0)/5.0+max(planet_surface(p),-min(sceneSDF2(p/7.0),min(sceneSDF2(p.xzy/11.0),sceneSDF2(p/13.0))));\n    float mesh_scale = 25.0*sin(length(p/1000.0))+50.0;\n    float foliage1 = min(foliage(p,result-mesh_scale),foliage(p.zxy,result-mesh_scale));\n    float result1 = min(result, foliage1);\n    if(result1 == result){\n    \tcolor = 1;\n    }\n    else if(result1 == foliage1){\n    \tcolor = 2;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result1*scale;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale/1000.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(2.5+1.5*sin(iTime/speed))*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a;\n    if(color == 1){\n    \tK_a = surface_color(p);\n    }\n    else{\n    \tK_a = plant_color(p);\n    }\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 298, 326, 326, 464], [466, 466, 492, 492, 553], [797, 797, 822, 869, 925], [927, 927, 951, 951, 1016], [1018, 1018, 1056, 1056, 1131], [1132, 1132, 1169, 1169, 1228], [1230, 1230, 1259, 1259, 1292], [1294, 1294, 1317, 1317, 1491], [1493, 1493, 1529, 1529, 1759], [1761, 1761, 1785, 1785, 2317], [2319, 2740, 2831, 2831, 3162], [3177, 3431, 3496, 3496, 3628], [3630, 3719, 3748, 3748, 4058], [4060, 4552, 4692, 4692, 5302], [5304, 5674, 5759, 5759, 6531], [6533, 6860, 6909, 6944, 7075], [7077, 7077, 7134, 7134, 8195]], "test": "timeout"}
{"id": "wtscD8", "name": "Lights...", "author": "photonic", "description": "Sutidying", "tags": ["performance", "lights", "help", "question"], "likes": 3, "viewed": 139, "published": "Public", "date": "1592027846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.12, pct, st.y) -\n          smoothstep( pct, pct+0.12, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    //uv += vec2(sin(iTime * 5.0), cos(iTime * 5.0)) / 2.0;\n    vec3 col = vec3(0.0);\n\n    vec2 uvR = uv;\n    vec2 uvG = uv;\n    vec2 uvB = uv;\n    \n    float speed = 4.0;\n    float lightsize = 0.01;\n    float flickerSpped = 2.0;\n    uvR += vec2(.2, .2) + vec2(sin(iTime * speed), cos(iTime * speed)) / 7.0;\n    uvG += vec2(-.2, .2) + vec2(cos((iTime * speed)), sin(iTime * speed)) / 7.0;\n    uvB += vec2(0.0, -.1)+ vec2(cos(iTime * speed), cos(iTime * speed)) / 7.0;\n    \n    float d1 = length(uvG-uvR);\n    \n    vec2 p1 = uvR * 2.0 / d1;\n    vec2 p2 = uvG * 5.0 / d1;\n    \n    float line = plot(uvG*uvR, uvR.x);\n\n    float dR = lightsize * abs(sin(iTime* flickerSpped)) / length(uvR);\n    float dG = lightsize * abs(cos(iTime* flickerSpped))/ length(uvG);\n    float dB = lightsize * abs(sin(0.45+iTime* flickerSpped))/ length(uvB);\n\n    col += dR * vec3(1.0, 0.0, 0.0);\n    col += dG * vec3(0.0, 1.0, 0.5);\n    col += dB * vec3(0.0, 1.0, 2.0);\n    //col += line;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 181, 181, 1245]], "test": "timeout"}
{"id": "wtscDX", "name": "Julia Stripes", "author": "dashxdr", "description": "Stripe Average Coloring", "tags": ["fractal"], "likes": 9, "viewed": 114, "published": "Public", "date": "1593330487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\n//uniform vec2 mouse;\n\n// dashxdr was here\n// Trying to implement Stripe Average Coloring for mandelbrot fractal\n// https://en.wikibooks.org/wiki/Fractals/Iterations_in_the_complex_plane/triangle_ineq\n// Then see the paper:\n// On Smooth Fractal Coloring Techniques master thesis by Jussi Haerkoenen\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord) {\n\tvec2 v = (FragCoord.xy - iResolution.xy/2.0) / min(iResolution.y,iResolution.x);\n//\tv = surfacePosition;\n\tfloat zt = fract(iTime*.01);\n    zt=1.0-2.*min(zt,1.0-zt);\n    vec2 center = vec2(-0.39075330, 0.30274829);\n\tfloat zoom = (1.0+zt*16.)*.02374716/1.33333333;\n\tv*=zoom;v+=center; // sets initial point of interest\n\n\tvec2 m;// = mouse;\nm = vec2(0.42, 0.6); // uncomment this to mess with brightness + contrast\n\n\nvec2 z = v;\n    vec2 c = vec2(0.4, -.325);\n    float iter = 1.;\n    vec3 sum = vec3(0.0);\n    vec3 sum2;\n    float M = 200000.;\n    float M2=M*M;\n    #define N 60\n    for( int i=1;i<N;++i)\n    {\n        iter = float(i);\n        float angle = atan(z.y, z.x);\n        sum2 = sum;\n        sum  += sin(angle*vec3(7,9,6))*.5 + .5;\n        if(dot(z,z)>M2) break;\n        z = vec2(z.x*z.x - z.y*z.y, z.x*z.y + z.y*z.x) + c;\n    }\n    sum/=iter;\n    sum2/=iter-1.0;\n// thanks to iq for following mixing scheme...\n    float f = -log2(log(length(z))/log(M2));\n//\tif(FragCoord.x<iMouse.x) f=1.;\n    sum = mix(sum2, sum, clamp(f, 0. , 1.));\n    \n    vec3 color = sum*vec3(1.0,.9,.82);\n    color = (color - m.x)*(m.y*10.+1.);\n    if(dot(z,z)<M) color=vec3(0);\n    FragColor.rgb = color;\n    FragColor.a=1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 422, 422, 1634]], "test": "error"}
{"id": "WtscR7", "name": "GiVD - CSG Shader", "author": "RedReservoir", "description": "Shader for testing CSG with SDFs.", "tags": ["givd"], "likes": 2, "viewed": 71, "published": "Public", "date": "1591711482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAYMARCHING_ITERATIONS 100\n#define EPSILON 0.00001\n#define MIN_DIST 0.00001\n#define MAX_DIST 100.0\n\nstruct material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n        \nstruct light {\n    vec3 position;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nmaterial mat_red = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.2, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_green = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_blue = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_orange = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.5, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_turquoise = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.5), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_purple = material(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\n\nlight[] scene_lights = light[] (\n    light(vec3(0.0, 0.0, 0.0), vec3(0.05, 0.05, 0.05), vec3(0.4, 0.4, 0.4), vec3(0.0, 0.0, 0.0)),\n    light(vec3(10.0, 10.0, 10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(-10.0, 10.0, -10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(10.0, -10.0, -10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(-10.0, -10.0, 10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0))\n);\nint l_num = 2;\n\nvec3 background_color = vec3(0.7, 0.7, 0.9);\n\n//---------------------------------------------------------------------------------\n\nfloat mixInverse(float x, float y, float a) {\n\treturn (a - x) / (y - x);    \n}\n\nfloat unitMap(float x) {\n    return (2.0 / (1.0 + exp(-x))) - 1.0;\n}\n\nfloat unitMapInverse(float x) {\n\treturn -log((2.0 / (x + 1.0)) - 1.0);    \n}\n\nfloat unitPow(float x, float p) {\n\treturn unitMap(pow(unitMapInverse(x), p));   \n}\n\n//---------------------------------------------------------------------------------\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 c, float h, float r) {\n    float inOutRadius = length(p.xy - c.xy) - r;\n    float inOutHeight = abs(p.z - c.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    return insideDistance + outsideDistance;\n}\n\n//---------------------------------------------------------------------------------\n\nvoid unionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 < d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid intersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 > d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid differenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(-d1 > d2) {\n        d = -d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid smoothUnionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) - k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothIntersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothDifferenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, -d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid sceneSDF(vec3 pos, out float dist, out material obj_mat) {\n\tfloat dist_sphere = sphereSDF(pos, vec3(0, 0, 0), 1.0);\n    material mat_sphere = mat_red;\n    \n    float dist_cylinder = cylinderSDF(pos, vec3(0, 1, 0), 3.0, 0.7);\n    material mat_cylinder = mat_green;\n    \n    //unionSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat);\n    //intersectionSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat);\n    //differenceSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat);\n    //differenceSDF(dist_cylinder, dist_sphere, mat_cylinder, mat_sphere, dist, obj_mat);\n    //smoothUnionSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat, 0.20, 1.0);\n    //smoothIntersectionSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat, 0.2, 1.0);\n    //smoothDifferenceSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat, 0.2, 1.0);\n\tsmoothDifferenceSDF(dist_cylinder, dist_sphere, mat_cylinder, mat_sphere, dist, obj_mat, 0.2, 1.0);\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 blinnPhong(vec3 pos, vec3 V, vec3 N, material mat, light lt) {\n    //Calculate L and H vectors\n    vec3 L = normalize(vec3(lt.position - pos));\n    vec3 H = normalize(L + V);\n\n    //Ambient\n    vec3 ambient = lt.ambient * mat.ambient;\n\n    //Diffuse\n    vec3 diffuse = lt.diffuse * mat.diffuse * max(dot(L, N), 0.0f);\n\n    //Specular\n    vec3 specular = lt.specular * mat.specular * pow(max(dot(H, N), 0.0f), mat.shininess);\n    \n    //Final color calculation\n    //vec3 color = diffuse + ambient + specular;\n    vec3 color = diffuse + ambient;\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 estimateNormal(vec3 pos) {\n    material placeholder;\n    float nxr, nxl, nyr, nyl, nzr, nzl;\n    sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z), nxr, placeholder);\n    sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z), nxl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z), nyr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z), nyl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON), nzr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON), nzl, placeholder);\n   \n    return normalize(vec3(nxr - nxl, nyr - nyl, nzr - nzl));\n}\n\nvoid castRay(vec3 ray_origin, vec3 ray_direction, float dmin, float dmax, out float scene_dist, out material obj_mat) {    \n    scene_dist = dmin;\n    float step_dist;\n    for(int it = 0; it < MAX_RAYMARCHING_ITERATIONS; it++) {\n        vec3 ray_pos = ray_origin + (ray_direction * scene_dist);\n        sceneSDF(ray_pos, step_dist, obj_mat);\n        scene_dist += step_dist;\n        if(step_dist < EPSILON || scene_dist > dmax) { return; }\n    }\n   \n    scene_dist = dmax + 1.0;\n}\n\nvec3 calculateScreenRayDirection(vec2 fragCoord, vec2 size, float fov) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calculateCameraMatrix(vec3 lookfrom, vec3 lookat, vec3 vup) {\n    vec3 cz = normalize(lookat - lookfrom);\n    vec3 cx = normalize(cross(cz, vup));\n    vec3 cy = cross(cx, cz);\n    return mat3(cx, cy, -cz);\n}\n\n\n//---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Precalculate variables\n    vec2 mouse_UV = iMouse.xy / iResolution.xy;\n    \n    //Camera calculations\n    vec3 cam_lookat = vec3(0, 0.5, 0);\n    vec3 cam_lookfrom = cam_lookat + vec3(10.0 * cos(1.2 * iTime),\n                                          1.5,\n                                          10.0 * sin(1.2 * iTime)\n                                         );\n    vec3 cam_vup = vec3(0, 1, 0);\n    mat3 cam_matrix = calculateCameraMatrix(cam_lookfrom, cam_lookat, cam_vup);\n    \n    //Apply raymarching\n    float scene_dist;\n    material obj_mat;\n    \n    vec3 ray_origin = cam_lookfrom;\n    vec3 ray_direction = cam_matrix * calculateScreenRayDirection(fragCoord, iResolution.xy, 45.0);\n    castRay(ray_origin, ray_direction, MIN_DIST, MAX_DIST, scene_dist, obj_mat);\n    \n    vec3 pos = ray_origin + (ray_direction * scene_dist);\n    vec3 norm = estimateNormal(pos);\n\n    vec3 col = vec3(0);\n    if(scene_dist < MAX_DIST) {\n        for(int l_index = 0; l_index < l_num; l_index++) {\n        \tcol += blinnPhong(pos, vec3(cam_lookfrom - pos), norm, obj_mat, scene_lights[l_index]);\n        }\n    } else {\n        col = background_color;\n    }\n    \n    //Gamma normalization\n    //col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1603, 1603, 1648, 1648, 1681], [1683, 1683, 1707, 1707, 1751], [1753, 1753, 1784, 1784, 1829], [1831, 1831, 1864, 1864, 1913], [2000, 2000, 2042, 2042, 2074], [2076, 2076, 2129, 2129, 2419], [2506, 2506, 2604, 2604, 2717], [2719, 2719, 2824, 2824, 2937], [2939, 2939, 3042, 3042, 3157], [3159, 3159, 3281, 3281, 3671], [3673, 3673, 3802, 3802, 4192], [4194, 4194, 4321, 4321, 4712], [4799, 4799, 4862, 4862, 5848], [5935, 5935, 6002, 6034, 6504], [6591, 6591, 6622, 6622, 7169], [7171, 7171, 7290, 7290, 7651], [7653, 7653, 7725, 7725, 7849], [7851, 7851, 7917, 7917, 8063], [8151, 8151, 8206, 8235, 9466]], "test": "error"}
{"id": "wtScRR", "name": "Yellow Blue Mandelbrot Zoom", "author": "milesWaugh", "description": "Does anyone know how to create double-precision floats?", "tags": ["2d", "mandelbrot", "zoom", "firstshader", "mandelbrotset", "mandelbrotzoom"], "likes": 2, "viewed": 73, "published": "Public", "date": "1593544401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x-=0.5;\n    uv.y-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float scale = pow(2.0,iTime-(floor(iTime/30.0)*30.0))/5.0;\n    uv.x/=scale;\n    uv.y/=scale;\n\tuv.x+=-0.748376594185829;\n    uv.y+=-0.09461894273757945;\n    float a = uv.x;\n    float b = uv.y;\n    float a2 = a*a; \n    float b2 = b*b;\n    float as = a;\n    int i=0;\n    while(i<1024){\n        if(a2+b2>4.0){\n            break;\n        }\n        a = a2-b2+uv.x;\n        b = 2.0*as*b+uv.y;\n        as = a;\n        a2 = a*a;\n        b2 = b*b;\n        i++;\n    }\n    float incol = sqrt(float(i)-(log2(log2(a2+b2)))+4.0)*2.0;\n    float r = cos(incol)+1.0;\n    float g = cos(incol-0.4)+1.0;\n    b = cos(incol+3.1415926535)+1.0;\n    vec3 col = vec3(r/2.0, g/2.0, (b/4.0)*(b/4.0));\n    if(i>=1024){col = vec3(0);}\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtScRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 957]], "test": "timeout"}
{"id": "wtscRs", "name": "Mario-Icono-bits", "author": "jorge2017a1", "description": "Mario-Icono-bits", "tags": ["mario", "bits", "icono"], "likes": 0, "viewed": 51, "published": "Public", "date": "1592854965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//MOdificado pOr Jorge F.p \"jorge2017a1\"\n//Referencia https://www.shadertoy.com/view/MlGfD3\n//Creado por rmccampbell7 en 2019-10-24 \n\n\n//32x32\n\n\nconst vec3[1024] heart= vec3 [1024]( vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(1.0,1.0,0.3333333), vec3(1.0,1.0,0.3333333), vec3(0.6666667,0.0,0.0), vec3(1.0,1.0,0.3333333), vec3(1.0,1.0,0.3333333), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(1.0,1.0,0.3333333), vec3(1.0,1.0,0.3333333), vec3(0.6666667,0.0,0.0), vec3(1.0,1.0,0.3333333), vec3(1.0,1.0,0.3333333), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.6666667), vec3(0.0,0.0,0.6666667), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(1.0,0.6705883,0.3411765), vec3(1.0,0.6705883,0.3411765), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.6666667,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0),\n vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.6705883,0.3411765,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    ivec2 pix = ivec2(floor(vec2(1.0,-1.0)*(fragCoord-iResolution.xy/2.)/4.5)) + 16;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 32) \n    {\n        col *= heart[pix.x+pix.y*32]*1.1;\n     }   \n    \n    else {\n        col = vec3(0);\n        \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24161, 24161, 24218, 24218, 24605]], "test": "timeout"}
{"id": "WtscW4", "name": "@Party Concert Visuals 2020", "author": "blackle", "description": "visuals for the concert at @party online 2020, programmed in about 1 hour", "tags": ["raymarching", "4d", "lasers"], "likes": 24, "viewed": 547, "published": "Public API", "date": "1592097490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat comp (vec3 p) {\n    p = asin(sin(p)*.9);\n    return length(p)-1.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvec4 wrot(vec4 p) {\n    return vec4(dot(p,vec4(1)), p.yzw + p.zwy - p.wyz - p.xxx)/2.;\n}\n\nfloat d1, d2, d3;\nfloat t;\nfloat lazors, doodad;\nvec3 p2;\nfloat bpm = 125.;\nfloat scene(vec3 p) {\n    p2 = erot(p, vec3(0,1,0), t);\n    p2 = erot(p2, vec3(0,0,1), t/3.);\n    p2 = erot(p2, vec3(1,0,0), t/5.);\n    \n    float bpt = iTime/60.*bpm;\n        vec4 p4 = vec4(p2,0);\n        p4=mix(p4,wrot(p4),smoothstep(-.5,.5,sin(bpt/4.)));\n        p4 =abs(p4);\n        p4=mix(p4,wrot(p4),smoothstep(-.5,.5,sin(bpt)));\n    float fctr = smoothstep(-.5,.5,sin(bpt/2.));\n    float fctr2 = smoothstep(.9,1.,sin(bpt/16.));\n        doodad = length(max(abs(p4)-mix(0.05,0.07,fctr),0.)+mix(-0.1,.2,fctr))-mix(.15,.55,fctr*fctr)+fctr2;\n    /*\n        vec4 p4 = vec4(p2,0);\n        p4=wrot(p4);\n        p4 = abs(p4);\n        p4=mix(p4,wrot(p4),smoothstep(-.5,.5,sin(t)));\n        doodad = length(max(abs(p4)-0.07,0)+0.2)-.55;\n    }*/\n    \n    p.x += asin(sin(t/80.)*.99)*80.;\n    \n    lazors = length(asin(sin(erot(p,vec3(1,0,0),t*.2).yz*.5+1.))/.5)-.1;\n    d1 = comp(p);\n    d2 = comp(erot(p+5., normalize(vec3(1,3,4)),0.4));\n    d3 = comp(erot(p+10., normalize(vec3(3,2,1)),1.));\n    return min(doodad,min(lazors,.3-smin(smin(d1,d2,0.05),d3,0.05)));\n}\n\nvec3 norm(vec3 p) {\n    float precis = length(p) < 1. ? 0.005 : 0.01;\n    mat3 k = mat3(p,p,p)-mat3(precis);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float bpt = iTime/60.*bpm;\n    float bp = mix(pow(sin(fract(bpt)*3.14/2.),20.)+floor(bpt), bpt,0.4);\n    t = bp;\n\tvec3 cam = normalize(vec3(.8+sin(bp*3.14/4.)*.3,uv));\n    vec3 init = vec3(-1.5+sin(bp*3.14)*.2,0,0)+cam*.2;\n    init = erot(init,vec3(0,1,0),sin(bp*.2)*.4);\n    init = erot(init,vec3(0,0,1),cos(bp*.2)*.4);\n    cam = erot(cam,vec3(0,1,0),sin(bp*.2)*.4);\n    cam = erot(cam,vec3(0,0,1),cos(bp*.2)*.4);\n    vec3 p = init;\n    bool hit = false;\n    float atten = 1.;\n    float tlen = 0.;\n    float glo = 0.;\n    float dist;\n    float fog = 0.;\n    float dlglo = 0.;\n    bool trg = false;\n    for (int i = 0; i <80 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        glo += .2/(1.+lazors*lazors*20.)*atten;\n        dlglo += .2/(1.+doodad*doodad*20.)*atten;\n        if (hit && ((sin(d3*45.)<-0.4 && (dist!=doodad )) || (dist==doodad && sin(pow(length(p2*p2*p2),.3)*120.)>.4 )) && dist != lazors) {\n            trg = trg || dist==doodad;\n            hit = false;\n            vec3 n = norm(p);\n            atten *= 1.-abs(dot(cam,n))*.98;\n            cam = reflect(cam,n);\n            dist = .1;\n        }\n        p += cam*dist;\n        tlen += dist;\n        fog += dist*atten/30.;\n    }\n    fog = smoothstep(0.,1.,fog);\n    bool lz = lazors == dist;\n    bool dl = doodad == dist;\n    vec3 fogcol = mix(vec3(0.5,0.8,1.2), vec3(0.4,0.6,0.9), length(uv));\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.3,0.3,scene(p+vec3(.3)))+.5;\n    float fact = length(sin(r*(dl?4.:3.))*.5+.5)/sqrt(3.)*.7+.3;\n    vec3 matcol = mix(vec3(0.9,0.4,0.3), vec3(0.3,0.4,0.8), smoothstep(-1.,1.,sin(d1*5.+iTime*2.)));\n    matcol = mix(matcol, vec3(0.5,0.4,1.0), smoothstep(0.,1.,sin(d2*5.+iTime*2.)));\n    if (dl) matcol = mix(vec3(1),matcol,0.1)*.2+0.1;\n    vec3 col = matcol*fact*ss + pow(fact,10.);\n    if (lz) col = vec3(4);\n    fragColor.xyz = col*atten + glo*glo + fogcol*glo;\n    \n    fragColor.xyz = mix(fragColor.xyz, fogcol, fog);\n    if(!dl)fragColor.xyz = abs(erot(fragColor.xyz, normalize(sin(p*2.)),0.2*(1.-fog)));\n    if(!trg&&!dl)fragColor.xyz+=dlglo*dlglo*.1*vec3(0.4,0.6,0.9);\n    fragColor.xyz = sqrt(fragColor.xyz);\n    fragColor.xyz = smoothstep(vec3(0),vec3(1.2),fragColor.xyz);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscW4.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 215, 215, 267], [269, 269, 307, 307, 369], [371, 371, 410, 410, 480], [482, 482, 501, 501, 570], [648, 648, 669, 669, 1708], [1710, 1710, 1729, 1729, 1894], [1896, 1896, 1953, 1953, 4266]], "test": "timeout"}
{"id": "wtscWl", "name": "Water Fountain (fbm)", "author": "noobay", "description": "A creative exploration of FBM.", "tags": ["2d", "fbm", "water", "abstract"], "likes": 0, "viewed": 55, "published": "Public", "date": "1593463781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Water Fountain\" by noobay. https://shadertoy.com/view/tllcWl\n// 2020-06-29 20:47:47\n\n\n// noise and fbm taken from https://www.iquilezles.org/www/articles/fbm/fbm.html, https://www.shadertoy.com/view/Msf3WH\n// simplex, fbm and parabola SDF by - Inigo Quilez\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm( in vec2 x, in float H, in int numOctaves )\n{    \n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*noise(f*x);\n    }\n    return t;\n}\n\nfloat sdParabola( in vec2 pos, in float k )\n{    \n    pos.x = abs(pos.x);\n    \n    float p = (1.0-2.0*k*pos.y)/(6.0*k*k);\n    float q = -abs(pos.x)/(4.0*k*k);\n    \n    float h = q*q + p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        pow(-q+r,1.0/3.0) - pow(abs(-q-r),1.0/3.0)*sign(q+r) :\n        2.0*cos(atan(r,-q)/3.0)*sqrt(-p);\n    \n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\n    float parabola = sdParabola(uv, 100.0) * 7.0;\n \t\n    parabola *= (sdParabola(-uv, 2.0) * 1.3);\n\n    vec2 fbmUv = vec2(uv.x, uv.y + iTime);\n    \n    float fbmResult = fbm(fbmUv, 0.55, 3);\n\t\n    vec3 col = mix(fbmResult * vec3(1.0, 1.0, 1.0), parabola * vec3(1.0, 1.0, 1.0), parabola * vec3(1.5));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 291, 291, 406], [408, 408, 434, 434, 913], [915, 915, 970, 970, 1158], [1160, 1160, 1205, 1205, 1570], [1572, 1572, 1629, 1679, 2102]], "test": "timeout"}
{"id": "WtscWN", "name": "Fold", "author": "TAKUSAKU", "description": "fold", "tags": ["fold"], "likes": 2, "viewed": 58, "published": "Public", "date": "1592118518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 U )\n{\n  vec3 u=vec3(2.*U-iResolution.xy,iResolution.y)/1e2;\n  for(int i=0;i<9;i++)\n  u.x+=fract(u.y+iTime+cos(u.x)*sin(iTime*.5))*.2,\n  u.xy+=sin(u.y+iTime*6.)*.1,\n  o=cos(float(u)+vec4(.3,.1,0,0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 236]], "test": "timeout"}
{"id": "wtscWs", "name": "Ray Marching - Ring Sphere Blob ", "author": "azon04", "description": "I made this accidentally while working on my Ray Marching + SDF scene.\n\nThe sphere should be missed by the ray marching algorithm. But since the ring (torus) affecting the algorithm, the sphere is kinda hit in different points inside of the sphere.", "tags": ["raymarching", "accidental"], "likes": 2, "viewed": 103, "published": "Public", "date": "1593491503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_MARCHING_STEPS 128\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\nmat3 rotY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n    \tvec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n    \tvec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat scene(vec3 p)\n{\n    float sphereDist = sphere(p / 0.5, 1.5); // The sphere should be \"missed\", since we scale the p and dont compesate the distance distortion of the scale (simply multiply this with 0.5)   \n    vec3 torusP = (rotZ(iTime) * rotY(radians(90.0)) * p);\n    float torusDist = torus(torusP, vec2(2.0, 0.1));\n    return min(torusDist, sphereDist); // union; try to draw only sphere, the sphere won't be rendered\n}\n\nvec3 calcNormal(vec3 p)\n{\n\treturn normalize(vec3(\n    \tscene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n    \tscene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n    \tscene(vec3(p.x, p.y, p.z + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));    \n}\n\nfloat ditanceToSurface(vec3 eye, vec3 dir, float start, float end)\n{\n    float depth = start;\n    for(int i=0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        float dist = scene(eye + depth * dir);\n        if(dist < EPSILON)\n        {\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end)\n        {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 phong(vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float NdotL = max(dot(L, N), 0.0);\n    float VdotR = max(dot(V, R), 0.0);\n    \n    return lightIntensity * (kd * NdotL + ks * pow(VdotR, alpha));\n}\n\nvec3 phongLights(vec3 ka, vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye)\n{\n    const vec3 ambientLight = 0.5 * vec3(1.0);\n    vec3 color = ambientLight * ka;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime), 1.0, 4.0 * cos(iTime));\n    color += phong(kd, ks, alpha, p, eye, light1Pos, vec3(0.4));\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.4 * iTime), 2.0 * cos(0.4 * iTime), 2.0);\n    color += phong(kd, ks, alpha, p, eye, light2Pos, vec3(0.4));\n    \n    return color;\n}\n\nvec3 rayDir(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s,f);\n    \n    return mat4(\n    \tvec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDir(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.0, 5.0, 7.0);\n    \n    mat4 worldMatrix = viewMatrix(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (worldMatrix * vec4(dir, 0.0)).xyz;\n    \n    float dist = ditanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if(dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 K = vec3(0.0, 0.45, 0.75);\n    fragColor = vec4(phongLights(K, K, vec3(1.), 16., p, eye), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 124, 124, 273], [275, 275, 299, 299, 448], [450, 450, 481, 481, 509], [511, 511, 540, 540, 614], [616, 616, 637, 637, 1045], [1047, 1047, 1072, 1072, 1355], [1357, 1357, 1425, 1425, 1738], [1740, 1740, 1837, 1837, 2133], [2135, 2135, 2211, 2211, 2607], [2609, 2609, 2660, 2660, 2784], [2786, 2786, 2835, 2835, 3064], [3066, 3066, 3123, 3123, 3684]], "test": "timeout"}
{"id": "wtscz7", "name": "SDF Raymarch", "author": "keshav2010", "description": "simple ray-marching program.  simulating diffuse lightening effect (directional light) and ambience. Light-direction is changing.", "tags": ["raymarch", "beginner", "light", "diffuselight"], "likes": 1, "viewed": 88, "published": "Public", "date": "1591742979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 800 \n#define MIN_DIST 0.00099\n\n\n//all items in scene defined below\n\n//Signed distance field function for sphere\nfloat signDistanceSphere(vec3 pos, vec3 sphereCenter, float s_r)\n{\n\treturn length(sphereCenter - pos) - s_r; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec4[] spheresArray =  vec4[](vec4(0., 0.5, 20, .5),\n                                  vec4(0.+ 0.5*sin(iTime)*sin(iTime), 0. , 5., 0.325+0.1*sin(iTime)),\n\t\t\t\t\t\t\t\t  vec4(1.5 , 0.5, 10.+ 5.*sin(iTime), .5),\n                                  vec4(-0.25, -32.5, 222, 35.)\n    \t\t\t\t\t\t);\n    \n    \n    vec3 ambientLightIntensity = vec3(0.05);\n    vec3 rayOrigin = vec3(1., .5, -10);\n    vec3 currentPoint = vec3(uv.x, uv.y, 0);\n    \n    vec3 lightDirection = vec3(2.5*sin(iTime),1.5*sin(iTime*0.5),-1);\n   \n    //ray direction\n    vec3 rd = normalize(currentPoint - rayOrigin);\n    \n    vec3 col = vec3(0);\n    //sphere trace each step\n    vec3 currentTracePoint = currentPoint;\n    \n    vec3 currentSphereCenter;\n    for(int i=0; i<MAX_STEP; i++) \n    {\n        float currentMinDist = 1000.;\n        int id;\n        \n    \tfor(int i=0; i<4; i++)\n        {\n            vec3 sc = vec3(spheresArray[i].x, spheresArray[i].y, spheresArray[i].z); //sphere-center\n            float sr = spheresArray[i].w;\n        \tfloat dist = signDistanceSphere(currentTracePoint, sc, sr);\n            if(dist < 0.){ //don't render\n               continue;\n            }\n            if(dist < currentMinDist)\n            {\n                currentSphereCenter = sc; //to compute surface normal(approx.) later for more well defined color\n                currentMinDist = dist;\n            }\n            \n        }\n        if(currentMinDist <= MIN_DIST)\n        {\n            vec3 surfaceNormal = normalize(currentTracePoint - currentSphereCenter);\n            \n            col=vec3(dot(normalize(surfaceNormal), normalize(lightDirection)), dot(normalize(surfaceNormal), normalize(lightDirection)), 0. );\n            col+=5.*ambientLightIntensity;\n            \n       \t\tbreak; \n        }\n   \t\t//update point \n        currentTracePoint  += rd*currentMinDist;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 129, 195, 195, 240]], "test": "error"}
{"id": "WtSczR", "name": "Equithirds tiling", "author": "jeyko", "description": "Tried making this tiling. Then I remembered I don't know trigonometry haha.", "tags": ["mdtmjvm"], "likes": 13, "viewed": 299, "published": "Public API", "date": "1593521189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is a no-math, all number crunched, Equithirds tiling:\n// https://tilings.math.uni-bielefeld.de/substitution/equithirds/\n\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    float iters = 9.;\n    \n    float d = 10e5;\n    \n    // mafs\n    vec2 s = vec2(0.173,0.1);\n\n    \n    uv.y -= s.y*0.35;\n\n    uv += vec2(sin(iTime),cos(iTime))*0.1;    \n    uv *= 0.06;\n\n    \n    float id = 0.;\n    vec2 p = uv;\n    float sc = 1.;\n    \n    float id0cnt = 0.;\n    float id1cnt = 0.;\n    float palcnt = 0.;\n    \n    for(float i = 0.; i < iters; i++){\n        \n        if( id == 0. ){\n        \n        \tmat2 rb = rot(tau/3.*1.);\n        \tmat2 rc = rot(tau/3.*2.); \n        \n            float szsc = 1.*sc;\n            \n            float da = sdTriangleIsosceles( p   , s*szsc);\n            float db = sdTriangleIsosceles( p*rb, s*szsc);\n            float dc = sdTriangleIsosceles( p*rc, s*szsc);\n\n            if( da < 0. ){\n                palcnt++;\n            } else if( db < 0. ){\n\t\t\t\tp *= rb;\n                palcnt += 1.5;\n            } else if( dc < 0. ){\n                palcnt += 2.5;\n\t\t\t\tp *= rc;\n            } \n            p.y -= 0.5*s.y*szsc;\n            \n            d = min(d,abs(da));\n            d = min(d,abs(db));\n            d = min(d,abs(dc));\n            id = 1.;\n            \n            id0cnt ++;\n        \n        } else if (id == 1.) {\n            float ramt = tau/5.*2.0835;\n            mat2 ra = rot(-ramt);\n            mat2 rb = rot(ramt);\n            \n            vec2 transa = vec2(-0.075,0.0144);\n            vec2 transb = vec2(-transa.x,transa.y);\n            \n            float szsc = sc*0.579;\n            \n            vec2 pa = (p*ra + transa*sc );\n            vec2 pb = (p*rb + transb*sc );\n            \n            \n            float da = sdTriangleIsosceles( pa, s*szsc);\n            float db = sdTriangleIsosceles( pb, s*szsc);\n            \n            \n            if(da < 0.){\n                p = p*ra + transa*sc*vec2(1.,-1.);\n                sc = szsc;\n                id = 1.;\n                palcnt += 1.5;\n            } else if(db < 0.){\n                p = p*rb + transb*sc*vec2(1.,-1.);\n                col += 0.03;\n                sc = szsc;\n                id = 1.;\n                palcnt += 1.;\n            } else {\n                p.y -= s.y*szsc/3.5;\n                \n                sc *= 0.335;\n                id = 0.;\n                palcnt += .5;\n            }\n            \n            \n            id1cnt++;\n        \td = min(d,abs(da));\n        \td = min(d,abs(db));\n        }\n    }\n    \n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n    col = mix(col,pal(0.5,0.5,vec3(2.,0.7,0.2),1., id1cnt*7. +  id0cnt*5. + palcnt*7. + 4. + iTime/2. + uv.x*1. )/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    d = abs(d);\n    \n    float w = 0.00006;\n    \n    col = mix(col,vec3(0.01),smoothstep(dFdx(uv.x) + w,w,d));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSczR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 273, 273, 581], [583, 583, 640, 640, 3495]], "test": "timeout"}
{"id": "WtsyD8", "name": "Playing with circles and fire", "author": "fjavifabre", "description": "Just 5 minutes writing a quick and dirty shader inspired by a GIF I saw in reddit.", "tags": ["procedural", "test"], "likes": 2, "viewed": 80, "published": "Public", "date": "1591977024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float shape_circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0);\n    \n    \n    float time = iTime *1.2;\n    \n    float circle = 111110.;\n    \n\n    \n    for(uint i = 0u; i<150u; i++)\n    {\n        \n        float rg = sin(float(i) *1.17);\n        float rg2 = sin(float(i*11u) *4.17) * cos(float(i*13u) *4.17);\n        \n        \n    float h =  mod(iTime + 6.1+ rg2, 2.) -2.- rg;\n    vec2 circle1Time = vec2(sin(time*rg*rg2*13. + 0.1*rg) * 0.3, h);\n    float circle1Size = mod(time + 3.1, 112.) + 1. +4.7;\n    \n        float aux = shape_circle(p - circle1Time, (-h)*1.12/circle1Size);\n        circle = smin(aux, circle, 0.626);   \n        \n    \n    \n    }\n    \n    float f = -circle;\n    if(circle < -0.0) col = vec3(f, f*f, f*f*f*f) * 3.;\n             \n             \n             \n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 63], [65, 65, 104, 104, 203], [206, 206, 263, 313, 1365]], "test": "timeout"}
{"id": "wtsyRB", "name": "kleinian skulls", "author": "wj", "description": "This is a stripped down version of a shader that  I had used on a 2017 web page (see https://youtu.be/InwEtKS59eI  ).\n\nThe basic algorithm is very simular to what was used in boxplorer2 and I thought it might be useful to have it here on shadertoy.", "tags": ["raymarching", "pseudokleinian"], "likes": 13, "viewed": 200, "published": "Public", "date": "1592411468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// kleinian skulls\n// by wj\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This is a stripped down version of what I am using on my 2017 web \n// page: http://www.wothke.ch/269life (to correctly view that page you may \n// need one of last year's browsers - e.g. no later than Chromium 75 or FireFox 66.0. Sadly \n// KhronosGroup decided to make an incompatible change to their WEBGL GL_EXT_draw_buffers \n// specs which sadly was implemented by most of the browsers in the second half \n// of 2019 and which breaks pages that depend on the original semantics.)\n\n// The code is based on knighty's \"pseudo kleinian\" Fragmentarium stuff with parts\n// pilfered from boxplorer2. More detailed credits can be found below.\n\nprecision highp float;\n\n#define RIM_BLEEDING\t\n\n#define DE_EPS 0.0001\n#define MAX_DIST 10.0\n\n#define MAX_STEPS 137\t// Maximum raymarching stepscoloring\n\t\t\t\t\n#define REFACTOR 0.5\n\n#define TThickness 4.50741e-008\t\t// Change a little the basic d_shape\n#define Ziter 3\n\n#define COLOR_ITERS 7\t\t\t\t\t\t\t\t\t\t\t// Number of fractal iterations for coloring\n#define REFITER 3\t\t\t\t\t\t\t\t\t\t\t\t// reflections\n#define DIST_MULTIPLIER 0.363001\n#define ITERS 11\t\t\t\t\t\t\t\t\t\t\t\t// Number of fractal iterations\t\t\t\n#define CSize vec3(0.808001 ,0.808,1.167)\t\t\t\t\t\t// Size of the box folding cell\n#define Size 1.\t\t\t\t\t\t\t\t\t\t\t\t\t// Size of inversion sphere\n#define C vec3(0,0,0)\t\t\t\t\t\t\t\t\t\t\t// Julia seed\n#define Offset vec3(-4.88759e-007,1.73877e-007,-1.51991e-007)\t// Translation of the basic d_shape\n#define DEoffset 0.\t\t\t\t\t\t\t\t\t\t\t\t// A small value added to the DE - simplify\n#define MAXI 1.0\n\t\t\t\n// \"defines\" used to completely avoid unused calculations\n#define OptionalJuliaSeed p=p;\n#define DEfacScale k\t\t\t\t\n\n#define BLEND 0.543\t \t\t\t\t\t\t\t\t\t\t\t// Blend with 0 trap\n\t\t\t\t\n#define PI_HALF 1.5707963267948966192313216916398\n\n#define ONE_PLUS_ULP 1.000000059604644775390625\n#define ONE_MINUS_ULP 0.999999940395355224609375\n#define ULP 0.000000059604644775390625\n\n#define MIN_NORM 0.00001\n\n#define AO_EPS\t\t0.0499998 \t// Base distance at which ambient occlusion is estimated.\n#define AO_STRENGTH\t0.149624\t// Strength of ambient occlusion.\n\n\nconst vec3 backgroundColor= vec3(0.02, 0.06, 0.16);\nconst float speed= 3.95070000e-004;\nconst float min_dist= 0.000794328;\t\t// Distance at which raymarching stops\nconst float glow_strength= 0.499999;\t// How much glow is applied after MAX_STEPS\nconst float dist_to_color= 0.200951; \t// How is background mixed with the surface color after MAX_STEPS\nconst float time= 0.0;\nconst int preset= 0;\n\n// Colors.\nvec3 specularColor = vec3(1.0, 0.8, 0.4),\n\tglowColor = vec3(0.03, 0.4, 0.4),\n\taoColor = vec3(0, 0, 0);\n\nconst vec3 NORM_LIGHT=  normalize(vec3(1.0,0.5,0.7));\n\n// Compute the distance from `pos` to the PKlein basic shape.\nfloat d_shape(vec3 p) {\n\t// => this is the magic sauce that you want to tinker with :-)\n\t// pearls: nice blue/pearl finish \n   float rxy = (length(p.x));\n   return max(rxy,  -(length(p.xy)*p.z-TThickness) / sqrt(dot(p,p)+abs(TThickness)));\n}\t\n\n// Compute the distance from `pos` to the PKlein.\n\n// stripped down version of knighty's \"pseudo kleinian\" distance \n// estimate.. (see \"Fragmentarium\") - see used \"defines\" to recover standard impl\nfloat d(vec3 p) {\n\tfloat r2;\n\tfloat DEfactor=1.;\n\t\t\t\n\tfor(int i=0; i<ITERS; i++){\t\t\t\t//Box folding (repetition)\n\t\tp=2.*clamp(p, -CSize, CSize)-p;\n\t\t//Inversion\n\t\tr2=dot(p,p);\n\t\tfloat k=max(Size/r2, MAXI);\n\t\tp*=k; DEfactor*= DEfacScale;\n\t\tOptionalJuliaSeed\t\t// use define to completely remove if not used..\n\t\t\t\t\n//\t\tif (!(r2<1.)) break; // add some rectangular beams for menger?\n\t\t\t\t\n\t}\t\t\t\t\n\treturn (DIST_MULTIPLIER*d_shape(p-Offset)/abs(DEfactor)-DEoffset);\n}\n\n// Compute the color (In the original \"Fragmentarium\" impl color would be calculated \n// directly within the above d() function.. and the below impl is repeating the \n// the respective last call of d(p).. still this seems to be faster (e.g. 16fps vs 15fps) than \n// doing the calc for all the d() calls within march() - not counting all the additional d() \n// calls for reflections and AO..\nvec3 color(vec3 p) {\n\tfloat r2=dot(p,p);\n\tfloat DEfactor=1.;\n\tvec4  col=vec4(0.0);\n\tfloat rmin=10000.0;;\n\n\tvec3 Color= vec3(-1.072,5.067, 0.647 );\n\n\tfor(int i=0; i<COLOR_ITERS; i++){\t//Box folding\t\t\t\t\t\n\t\tvec3 p1=2.*clamp(p, -CSize, CSize)-p;\n\t\tcol.xyz+=abs(p-p1);\n\t\tp=p1;\n\t\t//Inversion\n\t\tr2=dot(p,p);\n\t\tfloat k=max(Size/r2, MAXI);\n\t\tcol.w+=abs(k-1.);\n\t\tp*=k; DEfactor*= DEfacScale;;\n\t\tOptionalJuliaSeed\t\t// use define to completely remove if not used..\n\t\t\t\t\n\t\tr2=dot(p,p);\n\t\trmin=min(rmin,r2);\n\t}\t\t\t\t\n\treturn mix(vec3(sqrt(rmin)),(0.5+0.5*sin(col.z*Color)), BLEND);\n}\n\n// Compute the normal at `pos`.\n// `d_pos` is the previously computed distance at `pos` (for forward differences).\nvec3 generateNormal(vec3 pos, float d_pos) {\n\tvec2 Eps = vec2(0, max(d_pos, MIN_NORM));\t\n\treturn normalize(vec3(\n\t\t// calculate the gradient in each dimension from the intersection point\n\t\t-d(pos-Eps.yxx)+d(pos+Eps.yxx),\n\t\t-d(pos-Eps.xyx)+d(pos+Eps.xyx),\n\t\t-d(pos-Eps.xxy)+d(pos+Eps.xxy)\n\t));\n}\n\n// Blinn-Phong shading model (http://en.wikipedia.org/wiki/BlinnPhong_shading_model)\n// `normal` and `view` should be normalized.\nvec3 blinn_phong(vec3 normal, vec3 view, vec3 color) {\n\tvec3 halfLV = normalize(NORM_LIGHT + view);\n\tfloat diffuse= max( dot(normal, halfLV), 0.0 );\n\tfloat specular = pow(diffuse, 32.0 );\t/*specular exponent*/\n\t\t\t\t\t\n#ifdef RIM_BLEEDING\n\t// with rim lighting (diffuse light bleeding to the other side)\n\tdiffuse = dot(normal, NORM_LIGHT); \n#endif\n\treturn color * (diffuse * 0.5 + 0.75) + specular * specularColor;\n}\n\n// FAKE Ambient occlusion approximation. based on\n// http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n// uses current distance estimate as first dist. the size of AO is independent from distance from eye\nfloat ambient_occlusion(vec3 p, vec3 n, float DistAtp, float side) {\n\tfloat ao_ed= DistAtp*AO_EPS/min_dist;\t// Dividing by min_dist makes the AO effect independent from changing min_dist\n\tfloat ao = 1.0, w = AO_STRENGTH/ao_ed;\n\tfloat dist = 2.0 * ao_ed;\n\n\tfor (int i=0; i<5; i++) {\n\t\tfloat D = side * d(p + n*dist);\n\t\tao -= (dist-D) * w;\n\t\tw *= 0.5;\n\t\tdist = dist*2.0 - ao_ed;\n\t}\n\treturn clamp(ao, 0.0, 1.0);\n}\n\nfloat march(inout vec3 p, in vec3 dp, inout float D, inout float totalD, in float side, in float MINDIST_MULT){\n\t// Intersect the view ray with the Mandelbox using raymarching.\n\t// The distance field actually marched is the \"calculated DE\" minus (totalD * min_dist)\n\t// A perfect distance field have a gradient magnitude = 1. Assuming d() gives a perfect DE, \n\t// we have to multiply D with MINDIST_MULT in order to restore a gradient magnitude of 1\n\tint steps= 0;\n\tfor (int dummy=0; dummy<MAX_STEPS; dummy++) {\n\t\ttotalD+=D;\n\t\tD = (side * d(p + totalD * dp) - totalD * min_dist) * MINDIST_MULT;\n\n\t\tsteps++;\t// mimick what any non stupid-WEBGL loop would allow to do in the loop condition\n\t\t\t\t\n\t\tif (!(abs(D)>max(totalD*8192.0*ULP,ULP) && totalD < MAX_DIST)) break;\t\t\t\n\t}\n\tp += (totalD+D) * dp;\n\treturn float(steps);\n}\n\n// original \"noise()\" impl used somewhat cheaper variant of IQ's procedural 2D noise: https://www.shadertoy.com/view/lsf3WH\n// - to reduce GPU load, respective impl has been replaced by a texture-lookup based one (see https://www.shadertoy.com/view/4sfGzS).\nfloat noise3d( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\t f = f*f*(3.0-2.0*f);\n\t\t\t\t\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// By TekF...\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) );\n\tray.z = degree*sqrt(ray.z);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 cameraDirection(vec2 fragCoord) \n{\n\t// Camera direction borrowed from David Hoskins's\n    // https://www.shadertoy.com/view/4s3GW2\n    // I am too lazy to add more sophisticated flight controls for now\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n    mat3 mZ = RotationMatrix(vec3(.0, .0, 1.0), sin(iTime*.2)*.1);\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0),  0.0);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), 0.0);\n    mX = mY * mX * mZ;\n    \n    vec3 dir = vec3(uv.x, uv.y, 1.2);\n    BarrelDistortion(dir, .5);\n    dir = mX * normalize(dir);\n    \n    return dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec3 dir= cameraDirection(fragCoord);\n\tvec3 camera= vec3(1.0+sin(iTime*.13)*.8, 1.4, sin(iTime*.2)*.1);\t\n    \n    \n\tvec3 dp = normalize(dir);\n\tfloat noise =  noise3d(vec3(fragCoord.x, fragCoord.y, 0));\n\n\tvec3 p = camera;\n\n\tfloat totalD = 0.0, D = d(p);\n\t\t\t\t\t\n\tfloat side = sign(D);\n\tD = noise * abs(D);\n\t\t\t\t\t\n\tfloat MINDIST_MULT=1.0/(1.0+min_dist);\n\tD *= MINDIST_MULT;\n\n\tvec3 finalcol= vec3(0.);\n\tfloat refpart= 1.0;\n\n\tbool cont= true;\n\tfloat firstD= 0.;  // save first step for depth buffer\n\t\t\t\t\t\t\n\tfor(int i= 0; i<REFITER; i++){\n\t\tfloat steps= march(p, dp, D, totalD, side, MINDIST_MULT);\n\t\tif (i == 0) { firstD= totalD + D; }\n\t\t\t\t\t\t\n\t\tvec3 col= backgroundColor;\n\n\t\t// We've got a hit or we're not sure.\n\t\tif (totalD < MAX_DIST) {\n\t\t\tfloat D1= min_dist*.5*totalD;\n\t\t\tvec3 n= side * generateNormal(p, max(256.0*ULP, D1));\n\t\t\tcol= color(p);\n\t\t\t\t\t\t\t\n\t\t\tcol= blinn_phong(n, -dp, col);\t\t\t\n\t\t\tcol= mix(aoColor, col, ambient_occlusion(p, n, D1, side));\n\n\t\t\tdp= reflect(dp,n);\t// update the ray\n\n\t\t\tp-= (totalD+D) * dp;\t\t// without this there would be obvious reflection errors..\n\t\t\tD= (9. + noise) * D1;\n\n\t\t\t// We've gone through all steps, but we haven't hit anything.\n\t\t\t// Mix in the background color.\n\t\t\tif (D > max(totalD*8192.0*ULP,ULP)){\n\t\t\t\tfloat dc= clamp(log(D/min_dist) * dist_to_color, 0.0, 1.0);\n\t\t\t\tcol= mix(col, backgroundColor, dc);\n\t\t\t}\n\t\t} else {\n\t\t\tcont= false;\n\t\t}\n\n\t\t// Glow is based on the number of steps.\n\t\tcol= mix(col, glowColor, (float(steps)+noise)/float(MAX_STEPS) * glow_strength);\n\t\tfinalcol+= refpart*col;\n\t\trefpart*= REFACTOR;\n\t\tif (!cont) break;\n\t}\t\t\t\n\n\tfragColor= vec4(finalcol, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4l23R3", "previewfilepath": "https://soundcloud.com/lmanic/mos-techno-logy", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lmanic/mos-techno-logy", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2714, 2776, 2799, 2899, 3017], [3680, 4071, 4091, 4091, 4638], [4640, 4755, 4799, 4799, 5049], [5051, 5181, 5235, 5235, 5594], [5596, 5812, 5880, 5880, 6222], [6224, 6224, 6335, 6673, 7041], [7043, 7301, 7329, 7329, 7540], [7542, 7556, 7611, 7611, 7707], [7709, 7709, 7754, 7754, 8226], [8228, 8228, 8267, 8434, 8874]], "test": "error"}
{"id": "wtsyRS", "name": "Newton's method [Day 180]", "author": "jeyko", "description": "Great lecture on Newton's method - https://www.youtube.com/watch?v=j6ikEASjbWE\n", "tags": ["tutorial", "newton", "maths", "root", "mdtmjvm"], "likes": 8, "viewed": 240, "published": "Public API", "date": "1592403857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Also check out Bisection method demonstration - https://www.shadertoy.com/view/3tsyzj\n\n// Newton's root finding method\n// Great video on the subject - https://www.youtube.com/watch?v=j6ikEASjbWE\n\n// function smoothing thanks to iq and mla\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(j) mat2(cos(j), sin(j), -sin(j), cos(j))\n        \n#define feps 0.0001\n\n#define offs \t\t(iTime/1.5)\n\n#define fn(j) \t\t(cos(j+offs)+sin( (j+offs)*2. ))\n#define deriv(j) \t(fn(j+feps)-fn(j))/feps\n\n\n// Plotting width\nconst float W = 0.025;\n\n\nconst float eps = 0.01;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,W*width*0.5, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*5.;\n\n    vec3 col = vec3(0);\n    \n    // function\n\tcol += graph( uv.y, fn(uv.x),\t  fn(uv.x+eps),     vec3(0.8,.75,0.8), 1. );\n    \n    \n    // plotlines\n    \n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1),0.5);\n    \n    \n    float off = 0.;\n    \n    float iters = 4.;\n    for(float i = 0.; i <= iters; i++){\n        float f = fn(0. - off);\n    \tfloat dfdx = deriv(0. - off);\n    \t\n        vec2 fnuv = uv - vec2(-off,f);\n        \n        \n        vec3 c1 = pal(0.5,0.5,vec3(0.9,0.1,0.1),1.,i*1. + 1.);\n        \n        // slope\n        float theta = atan(dfdx);\n        \n        col = mix(col, c1,smoothstep(W*1., W*0.5, abs( ( fnuv*rot(theta)).y))) ;\n        \n        // column\n        col = mix(col,c1,smoothstep(W*1.,W*0.5, max(abs(fnuv.x), abs(fnuv.y +f/2. ) -abs(f/2.))) );\n        \n        float hypotenuse = f/sin(theta); // cos(theta) = adj / hypotenuse\n        float lowerleg = sqrt(hypotenuse*hypotenuse - f*f); \n        \n        // not my proudest line of code lol\n        lowerleg = lowerleg*(-1. + float(dfdx <0.)*2. - float(f <0. && dfdx < 0.)*2. + float(f <0. && dfdx > 0. )*2. );\n        \n        // lower leg of triangle\n        col = mix(col,c1,smoothstep(W*1.,W*0.5,length(fnuv - vec2( lowerleg,-f))));\n        \n        off -= lowerleg;\n        \n        // function value\n        col = mix(col,c1,smoothstep(W*3.,W*2.,length(fnuv)));\n        \n        \n    }\n    \n    \n    \n    col = smoothstep(0.,1.,col);\n    \n    // gamma correction\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 568, 633, 633, 748], [751, 751, 808, 808, 2406]], "test": "timeout"}
{"id": "WtsyW2", "name": "fBM_Domain_Warping-experiment", "author": "Iranon", "description": "Experimenting and playing around with domain warping and color flow.", "tags": ["fbm", "domainwarping", "colorflow"], "likes": 3, "viewed": 82, "published": "Public", "date": "1593122817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nMain references and functions from https://thebookofshaders.com/13/ and https://www.iquilezles.org/www/articles/warp/warp.htm\n\nCode structure from Low Pattern(https://www.shadertoy.com/view/WlsyWj)\n\n*/\n\n\n\n\n//2D Random and Noise functions\n\nfloat rand(in vec2 sd) {\n    \n    return fract( sin( dot( sd.xy, vec2(9.128, 3.256) * 293699.963 ) ) );\n}\n\n\nfloat n2D(in vec2 sd) {\n    \n    vec2 iComp = floor(sd);\n    \t\t\t\t\t\t//integer and fractional components\n    vec2 fComp = fract(sd);\n    \n    \n    float a = rand(iComp + vec2(0.0, 0.0));\t//\n    float b = rand(iComp + vec2(1.0, 0.0));\t// interpolation points\n    float c = rand(iComp + vec2(0.0, 1.0));\t// (4 corners)\n    float d = rand(iComp + vec2(1.0, 1.0));\t//\n    \n    vec2 fac = smoothstep(0.0, 1.0, fComp);\t//interpolation factor\n    \n    //Quad corners interpolation\n    return\n        mix(a, b, fac.x) +\n        \n        \t(c - a) * fac.y * (1.0 - fac.x) +\n        \n        \t\t(d - b) * fac.x * fac.y ;\n}\n\n\n\n//fractal Brownian Motion and Motion Pattern\n\n#define OCTAVES 6\n\nfloat fBM(in vec2 sd) {\n    \n    //init values\n    float val = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    \n    float lacunarity = 2.0;\n    float gain = 0.5;\n    \n    //Octaves iterations\n    for(int i = 0; i < OCTAVES; i++) {\n        \n        val += amp * n2D(sd * freq);\n        \n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return val;\n}\n\n\nfloat mp(in vec2 p) {\n    \n    float qx = fBM(p + vec2(0.0, 0.0));\n    float qy = fBM(p + vec2(6.8, 2.4));\n    \n    vec2 q = vec2(qx,qy);\n    \n    float tm = 0.008 * iTime * 1.3;\t//time factor\n    \n    float rx = fBM(p + 1.1 * q + vec2(9.5, 9.3) * tm);\n    float ry = fBM(p + 1.5 * q + vec2(7.2, 1.5) * -(tm + 0.002));\n    \n    vec2 r = vec2(rx, ry);\n    \n    return fBM(p + (2.0 * r));\n}\n\n\n//========================================================================\n\n//main()\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    \n    vec3 col = vec3(0.0);\n    //col += fBM(uv*3.0);\n    \n    float wFac = mp(uv*3.0); //warping factor\n   \n    col = mix(vec3(0.101961, 0.29608, 0.26567), vec3(0.66667,0.45667,0.89839), clamp(pow(wFac, 2.5), 0.0, 1.0));\n    col = mix(col, vec3(0.44467,0.00567,0.19809), clamp(pow(wFac, 0.4), 0.0, 1.0));\n    col = mix(col, vec3(0.52467,0.42567,0.01809), clamp(wFac * wFac, 0.0, 1.0));\n    col = mix(col, vec3(0.84467,0.32567,0.13809), clamp(smoothstep(0.0, 1.0, wFac), 0.0, 1.0));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 267, 267, 348], [351, 351, 374, 374, 959], [1028, 1028, 1051, 1074, 1395], [1398, 1398, 1419, 1419, 1786], [1876, 1876, 1933, 1982, 2581]], "test": "timeout"}
{"id": "wtsyWf", "name": "Tileable Gradient Noise", "author": "ming", "description": "Tileable Gradient Noise", "tags": ["noise", "tileable"], "likes": 4, "viewed": 69, "published": "Public", "date": "1593339486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// iq's gradient noise https://www.shadertoy.com/view/Xsl3Dl\n\n//----------------------------------------------------------------------------------------\nvec3 HashALU(in vec3 p, in float numCells)\n{\n\t// This is tiling part, adjusts with the scale\n\tp = mod(p, numCells);\n\t\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nvec3 HashTex(in vec3 p, in float numCells)\n{\n    p = mod(p, numCells);;\n    \n    vec2 uv = (p.xy + vec2(37.0,17.0) * p.zz);\n\treturn -1.0 + 2.0 * texture( iChannel0, (uv+0.5)/256.0).grb;\n}\n\n//#define Hash HashALU\n#define Hash HashTex\n\n//----------------------------------------------------------------------------------------\nfloat Noise(in vec3 p, in float numCells )\n{\n\tvec3 f, i;\n\t\n\tp *= numCells;\n\n\t\n\tf = fract(p);\t\t// Separate integer from fractional\n    i = floor(p);\n\t\n    vec3 u = f*f*(3.0-2.0*f); // Cosine interpolation approximation\n\n    return mix( mix( mix( dot( Hash( i + vec3(0.0,0.0,0.0), numCells ), f - vec3(0.0,0.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,0.0), numCells ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,0.0), numCells ), f - vec3(0.0,1.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,0.0), numCells ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( Hash( i + vec3(0.0,0.0,1.0), numCells ), f - vec3(0.0,0.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,1.0), numCells ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,1.0), numCells ), f - vec3(0.0,1.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,1.0), numCells ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//----------------------------------------------------------------------------------------\n// numCells better be power of two\nfloat NoiseFBM(in vec3 p, float numCells, int octaves)\n{\n\tfloat f = 0.0;\n    \n\t// Change starting scale to any integer value...\n    p = mod(p, vec3(numCells));\n\tfloat amp = 0.5;\n    float sum = 0.0;\n\t\n\tfor (int i = 0; i < octaves; i++)\n\t{\n\t\tf += Noise(p, numCells) * amp;\n        sum += amp;\n\t\tamp *= 0.5;\n\n\t\t// numCells must be multiplied by an integer value...\n\t\tnumCells *= 2.0;\n\t}\n\n\treturn f / sum;\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//#define SHOW_2D_VERSION 1\n#ifdef SHOW_2D_VERSION\n    // uv should be within 0-1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // debug for tiling\n    //uv *= 2.0;\n    \n    float c = NoiseFBM(vec3(uv, 0.5), 4.0, 5) * 0.5 + 0.5;\n    c = c * c;\n    fragColor = vec4(c, c, c , 1.0);\n#else\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n\t\tf = NoiseFBM(pos, 8.0, 3);\n\t\tcol = vec3(f * 0.5 + 0.5);\n\t}\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n#endif\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 153, 197, 245, 444], [446, 446, 490, 490, 633], [680, 771, 815, 815, 1814], [1816, 1942, 1998, 1998, 2346], [2348, 2439, 2496, 2524, 4066]], "test": "error"}
{"id": "WtsyWN", "name": "Pause - Bridget Riley - 1", "author": "lynnh", "description": "1964", "tags": ["art"], "likes": 3, "viewed": 71, "published": "Public", "date": "1592114160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // And keep aspect ratio by deviding by Y only.\n    vec2 pos = vec2(fragCoord.xy/iResolution.y);\n    // Set default backgroun color\n    vec3 pixel = vec3(1.0);\n\n    // Rotate canvas\n    vec2 pos2;\n    float angle = 0.25 * M_PI;\n    pos2.x =   cos(angle)*pos.x + sin(angle)*pos.y;\n\tpos2.y = - sin(angle)*pos.x + cos(angle)*pos.y;\n    \n    // Adding waves based on pre-rotated canvas\n    // This part seems off\n    pos2.x += sin(iTime - 5.5 * pos.x - 1.0 * pos.y) * 0.05;\n\n    // Setting up a grid\n    float num = 12.0;\n\tpos2 *= num;\n    pos2 = fract(pos2);\n    \n    \n    // Draw a circle\n    vec3 col = vec3(0.0);\n    float radius = 0.4;\n    if (length(pos2 - vec2(0.5)) < radius) pixel = col;\n    \n    // Set Color Variation\n    // This part is also off. Maybe transform the grid in the end?\n    vec3 add = vec3((cos(pos.x * 4.0 + pos.y * 2.0) + 1.0)*0.48);\n    pixel += add;\n\n    // Output to screen\n    fragColor = vec4(pixel,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 178, 280, 1168]], "test": "timeout"}
{"id": "wtXcDB", "name": "Dodecahedralis VII", "author": "sl2c", "description": "Variant of [url=https://www.shadertoy.com/view/tlXcz7]Dodecahedralis III[/url] brought about by adding the three components (and thus a three-fold rotational symmetry).", "tags": ["fractal", "hyperbolic"], "likes": 18, "viewed": 144, "published": "Public", "date": "1592940383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nbool flip(inout vec3 z, in vec2 c, in float r, inout int t, in int k) {\n    z.xy -= c;\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        z *= r * r / dot(z,z);\n        t = k - t;\n    }\n    z.xy += c;\n    return res;\n}\n\nbool inside(in vec3 z, in vec2 c, in float r, inout float t) {\n    vec3 p = z - vec3(c,0.0);\n    float res = (dot(p,p)-r*r) / (2.0 * abs(r) * p.z);\n    t = min(t, abs(res));\n    return res < 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.0 / iResolution.y;\n    vec3 z = vec3(z0,ds);\n    \n    vec2[12] c; float[12] r;\n    float r1 = pow(1.5 + 0.5 * sqrt(5.0) - sqrt(1.5 * sqrt(5.0) + 2.5), 0.5);\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1 * sqrt(sqrt(5.0));\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<5; i++) {\n        float theta = tau * 0.2 * float(i);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+6] = r3;\n        c[i+6] = x3 * eit;\n    }\n    float r4 = -1.0 / r1;\n    r[11] = r4; c[11] = vec2(0.0);\n    \n    float period = -8.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    z *= exp(-d);\n    \n    bool fl = false;\n    float yellow = 0.0;\n    int t = 1;\n    int s1 = 0;\n    int s2 = 0;\n    int s3 = 0;\n    bool fl1 = false; bool fl2 = false; bool fl3 = false;\n    for (int i=0; i<7; i++) {\n        fl1 = fl1 ^^ flip(z, c[0], r[0], s1, 1);\n        fl1 = fl1 ^^ flip(z, c[1], r[1], s1, 1);\n        fl3 = fl3 ^^ flip(z, c[2], r[2], s3, 1);\n        fl2 = fl2 ^^ flip(z, c[3], r[3], s2, 1);\n        fl2 = fl2 ^^ flip(z, c[4], r[4], s2, 1);\n        fl3 = fl3 ^^ flip(z, c[5], r[5], s3, -1);\n        fl1 = fl1 ^^ flip(z, c[6], r[6], s1, -1);\n        fl3 = fl3 ^^ flip(z, c[7], r[7], s3, -1);\n        fl2 = fl2 ^^ flip(z, c[8], r[8], s2, -1);\n        fl2 = fl2 ^^ flip(z, c[9], r[9], s2, -1);\n        fl3 = fl3 ^^ flip(z, c[10], r[10], s3, 1);\n        fl1 = fl1 ^^ flip(z, c[11], r[11], s1, -1);\n        \n    }\n    if (fl1) {s1=-s1;}\n    if (fl2) {s2=-s2;}\n    if (fl3) {s3=-s3;}\n    vec3 s = vec3(float(s1+s2+s3) + 4.0 * d / period);\n    \n    s = s / (1.9 + abs(s));\n    vec3 col = 0.5 + s * 0.45;\n    col.rg*=0.8;\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcDB.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[485, 485, 547, 547, 682]], "test": "timeout"}
{"id": "wtXcR4", "name": "earthbound bg 3", "author": "thefox231", "description": "fourth attempt, this one looks the neatest imo\nlooks a lot like a plasma. i like it", "tags": ["2d", "abstract", "snes", "earthbound"], "likes": 2, "viewed": 311, "published": "Public API", "date": "1591533408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float thickness = .1;\nconst vec3 mainColor = vec3(.1, .3, .3);\n\nbool equals(float a, float b) {\n    return mod(abs(a - b), 0.2) < thickness;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(.0);\n    \n    // fix aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    uv.x -= (aspectRatio - 1.) * .5;\n    \n    // pixelate\n    float pxAmt = 90.;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    // repixelate\n    pxAmt = 90.;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    // interlacing .\n    if (mod(fragCoord.y, 2.) < 1.) {\n        uv += .4 + sin(iTime * .5 + uv.y * 15.) * 0.1;\n    } else {\n        uv -= .4 + cos(iTime * .5 + uv.y * 15. + .5) * 0.1;\n    }\n    \n    // weird plasma circles thing......\n    vec2 circlePosition = vec2(.5, .5);\n    float circleDistance = 1.0 - length(circlePosition - uv);\n    \n    vec3 circleColor = mainColor * .8 + sin(iTime + uv.x * 6. + uv.y * 9. + sin(uv.x * 8.) + cos(iTime)) * .15;\n    \n    if (equals(circleDistance, iTime * .1 + sin(uv.y * 3.) * (.6 + sin(iTime * .3) * .4))) {\n    \tcolor += circleColor;\n    } else {\n        float avg = (circleColor.r + circleColor.g + circleColor.b) / 3.;\n        color += vec3(avg) * .4 * circleDistance;\n    }\n    \n    // color shortening\n    // gives it a kind of like snes-like palette\n    float shortAmt = 8.0;\n    color = ceil(color * shortAmt) / shortAmt;\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 101, 101, 148], [150, 150, 205, 205, 1592]], "test": "timeout"}
{"id": "wtXcW2", "name": " Pancake Conf 2020 LiveShading", "author": "Alkama", "description": "Converted from a liveshading session that happened during the Pancake Conference 2020.\nNot very optimal, tons of artefacts, but was fun to do.\nhttps://psenough.github.io/pancake/", "tags": ["raymarching", "distancefield", "liveshading"], "likes": 16, "viewed": 450, "published": "Public API", "date": "1593081416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi=acos(-1.0);\nfloat t,st,m;\n#define sat(a) clamp(a,0.,1.)\nvec2 amod(vec2 p,float m) { float a=mod(atan(p.x,p.y),m)-m*.5; return vec2(cos(a),sin(a))*length(p); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat sphere(vec3 p, float r) { return length(p)-r; }\nfloat caps(vec3 p, float h, float r) { p.y-=clamp(p.y,0.,h); return length(p)-r; }\n///////////////////////////////////////////////////////////////////\n// Simplex  Noise 2D (by IQ): https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nfloat fnoise(vec2 uv) {\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n///////////////////////////////////////////////////////////////////\nfloat scene(vec3 p) {\n  if(length(p)-1.5>.1) return .1;\n  float nz=fnoise(p.xz*8.)*.0001;\n\n  float o=100.;\n  vec3 pp=p;\n  pp*=vec3(1,10.,1);\n  o=min(o,sphere(1.02*pp, 1.)*.1+nz*2.);\n  pp-=vec3(0,1.1+.4*sin(t*6.),0); o=min(o,sphere(1.12*pp, 1.)*.1+nz*6.);\n  pp-=vec3(0,1.1+.4*sin(t*4.),0); o=min(o,sphere(1.1*pp, 1.)*.1+nz*6.);\n  pp-=vec3(0,1.1+.4*sin(t*10.),0); o=min(o,sphere(1.2*pp, 1.)*.1+nz*4.);\n  pp-=vec3(0,1.1+.0*sin(t*4.),0); o=min(o,sphere(1.2*pp, 1.)*.1+nz*4.);\n  vec3 p2=p;\n  p2.xz=amod(p2.xz,pi*.01);\n  p2.xy*=rot(-pi*.34);\n  p2 -= vec3(.55,0,0);\n  float plate=caps(p2,1.2-.05*sin(p.x*p.y*p.z*10.),.05-.01*sin(p.x*p.z*20.));\n  if(plate<o) m=5.;\n  return min(o,plate);\n}\nvec3 camdir(vec2 uv, vec3 og, vec3 tg, float z) {\n  vec3 f=normalize(tg-og);\n  vec3 s=normalize(cross(vec3(.3*sin(t+sin(st)),1,0),f));\n  vec3 u=normalize(cross(f,s));\n  return normalize(f*z+uv.x*s+uv.y*u);\n}\nvec3 normal(vec3 p) {\n  vec2 e=vec2(.001,0);\n  return normalize(scene(p)-vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx)));\n}\nfloat pales(vec2 uv, float screen, float number) {\n  uv*=rot(-t*screen);\n  return floor(smoothstep(.1,.2,cos(atan(uv.y,uv.x)*number)));\n}\nvec4 march(vec3 og, vec3 dir, int it, float tr, float mx) {\n  float d=0.;\n  vec3 p=og;\n  for(int i=0; i<it; i++) {\n    float h=scene(p)*.8;\n    if(abs(h)<tr || d>mx) break;\n    d+=h;\n    p+=dir*h;\n  }\n  return vec4(p,d);\n}\nfloat shadow(vec3 p, vec3 lp) {\n  vec3 ldir=normalize(lp-p);\n  float ldist=length(lp-p);\n  float d=march(p,ldir,100,.0001,5.).w;\n  if(d<ldist) {\n    return .5;\n  } else {\n    return 1.;\n  }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy / iResolution.xy - .5) * vec2(iResolution.x/iResolution.y, 1.);\n\n  t = mod(.4*iTime,10.*pi);\n  float ft=floor(t);\n  float dt=fract(t);\n  st=ft+dt*dt;\n  m=0.;\n\n  vec2 uv2 = uv;\n  uv2.xy+=.4*vec2((sin(st)+.2*sin(t*2.)),sin(st*.5));\n  vec3 bg=vec3(0);\n  bg+=pales(uv2,.4,30.);\n  bg-=pales(uv2,.2,28.);\n  bg+=pales(uv2,-.6,20.);\n  bg-=pales(uv2,-.3,18.);\n  bg=mix(vec3(1.,.9, .5),vec3(1.,.4, .1),sat(bg));\n  float ccc=1.-length(uv2*(1.+.2*sin(t*8.)));\n  bg+=ccc;\n  bg += .05*step(.9,bg.ggg);\n  vec3 col=bg;\n  \n  vec3 eye=3.*vec3(.1,.35,.1);\n  eye += 2.*vec3(sin(st)+.2*sin(t*2.),.2*sin(st*.5),cos(st-sin(t)));\n  vec3 target=vec3(.2*sin(st*4.),.1*sin(st*2.),.2*cos(st));\n  vec3 dir=camdir(uv,eye,target,.75);\n  \n  vec3 lp=vec3(1,3,-2);\n  lp.xz+=1.5*vec2(sin(t*8.),cos(t*6.));\n  \n  vec4 hit=march(eye,dir,400,.001,5.);\n  float d=hit.w;\n  if(d<5.){\n    vec3 p=hit.xyz;\n    vec3 n=normal(p);\n    vec3 ld=normalize(lp-p);\n    float diff=abs(dot(n,ld));\n    if(m==0.) {\n      float miaou=smoothstep(.96,1.,abs(n.y));\n      col=diff*mix(vec3(1.,.9,.5),vec3(1.,.4,.1),miaou);\n      col-=.5*pow(.5+.5*fnoise(p.xz*(5.-p.y)), 4.);\n    } else {\n      float spec=sat(pow(abs(dot(dir,reflect(ld,n))),50.));\n      float fres=1.-sat(pow(abs(1.-dot(n,-dir)),5.));\n      col=sat(vec3(.8+spec)*fres)*cos(dir);\n    }\n    col*=shadow(p,lp);\n  }\n    \n  fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 98, 98, 173], [174, 174, 193, 193, 243], [244, 244, 275, 275, 297], [298, 298, 336, 336, 380], [381, 517, 538, 538, 653], [654, 654, 680, 680, 1158], [1159, 1159, 1182, 1182, 1408], [1409, 1477, 1498, 1498, 2158], [2159, 2159, 2208, 2208, 2366], [2367, 2367, 2388, 2388, 2494], [2495, 2495, 2545, 2545, 2632], [2633, 2633, 2692, 2692, 2855], [2856, 2856, 2887, 2887, 3047], [3048, 3048, 3105, 3105, 4505]], "test": "error"}
{"id": "wtXcWj", "name": "Organic Virus", "author": "kstyler", "description": "Using noise on a sphere to make an organic form.", "tags": ["sick", "virus", "illness"], "likes": 2, "viewed": 200, "published": "Public API", "date": "1593140004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int mat = 0;\nconst float pi=3.14;\nconst int MAXD = 1000;\nconst float EPSI  =0.00001;\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\nfloat hash(vec2 p){\n\tp = fract(p*vec2(1253.4,567.8));\t\n    p+= dot(p,p+91.011);\n    return fract(p.x*p.y);\n}\nfloat noise(vec2 uv){\n\tvec2 id = floor(uv*10.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*10.));\n    \n    float a = hash(id);\n    float b = hash(id + vec2(1.,0.));\n    float c = hash(id + vec2(0.,1.));\n    float d = hash(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n}\n\nfloat octaves(vec2 uv,int octs){\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<10;i++){\n    \tf+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n    return f;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat spheres(vec3 l){\n     int ot = 10;\n    float scl = 100.;\n\t float sphere = length(l)-0.1;\n    return sphere;\n   \n}\nfloat map(vec3 p ){\n    vec3 q = p;\n    vec3 w=p;\n    int ot = 9;\n    float scl = 55.;\n    q.z+=.1;\n    float sphere = length(q)-1.2-octaves((q.zy/scl)+atan(length(q*0.09)),ot);\n    sphere -=octaves((q.zx/scl),ot);\n    sphere -=octaves((q.yx/scl),ot);\n    \n    \n    float ang = (2.*pi)/12.;\n    float sector1=round(atan(w.z,w.x)/ang);\n \n  float ang2 = (2.*pi)/5.;\n    float sector2=round(atan(w.z,w.x)/ang2);\n   \n    vec3 l = p;\n    vec3 e = p;\n    float an = sector1*ang;\n   \n    float an2 = sector2*ang2;\n   \n   \n    l.xz = rot(an)*l.xz; \n    l.xy=rot(100.)*l.xy;\n    e.xz= rot(an2)*e.xz;\n    e.xy=rot(45.21)*e.xy;\n      \n\n    vec3 l2=l;\n    vec3 l3=l;\n    vec3 l4=l;\n    vec3 e2=e;\n    l2.xy=rot(44.4)*l2.xy;\n  \n    l3.xy*=rot(43.1);\n    l4.xy*=rot(42.65);\n   \n    e2.xy*= rot(2.3);\n    \n    vec3 inc = vec3(-2.4,0,0.);\n    e+= vec3(-2.5,0,0.);\n    e2+= vec3(-2.5,0,0);\n    l+=inc;\n    l2+=vec3(-2.4,0,0);\n    l3+= vec3(-2.4,0,0.);\n    l4+=vec3(-2.4,0,0.);\n    float spheres1 = spheres(l);\n    \n    float spheres2 = spheres(l2);\n    float spheres3 = spheres(l3);\n    float spheres4 = spheres(l4);\n    float spheres5 =spheres(e);\n    float spheres6 =spheres(e2);\n    float best= min(sphere,(min(spheres1,min(spheres2,min(spheres3,\n                 min(spheres4,min(spheres5,spheres6)))))));\n   float better=smin(sphere,best,0.9);\n    if(best== sphere){\n     \tmat=2;\n    }\n    if(best== spheres1 ||best ==spheres2||best ==spheres3 || best==spheres4||\n      best==spheres5||best==spheres6){\n     \tmat=3;\n    }\n   \n    return better;\n}\n\nvec3 rayMarch(vec3 ro,vec3 rd){\n    \n    float tot = 0.;\n    float dst = 0.;\n    vec3 p;\n    for(int i = 0; i<MAXD; i++){\n        p = ro+rd*tot;\n        dst = map(p);\n        tot+=dst;\n        if(dst<EPSI || tot > 50.){\n            p=vec3(float(i)/float(MAXD));\n            break;\n        }\n    }\n    if(dst > EPSI){\n        mat = 1;\n    }\n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n   \n    vec3 ro = vec3(0,+0.,-14);\n    vec3 rd = normalize(vec3(uv,1.));\n    ro.xz*=rot(iTime/2.);\n    rd.xz*=rot(iTime/2.);\n    ro.xy*=-rot(iTime/2.);\n    rd.xy*=-rot(iTime/2.);\n    float tot = 0.;\n    float dist = 0.;\n    vec3 p = rayMarch(ro,rd);\n   \n \n    \n    if(mat==1){\n    \tp=1.-vec3(0.9);\n        p*=length(uv*1.7)*1.5;\n        p=p;\n    }\n \n    if(mat==2){\n    \tp*=20.*vec3(1.);\n            \n    }\n     if(mat==3){\n    \tp*=20.*vec3(1.);\n    }\n     if(mat==4){\n    \tp*=8.*vec3(.3,0.2,1);\n    }\n    fragColor = vec4((p),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 103, 103, 169], [170, 170, 189, 189, 278], [279, 279, 300, 300, 632], [634, 634, 666, 666, 813], [815, 815, 858, 858, 958], [959, 959, 981, 981, 1078], [1079, 1079, 1098, 1098, 2613], [2615, 2615, 2646, 2646, 2970], [2971, 2971, 3027, 3027, 3622]], "test": "ok"}
{"id": "wtXcz7", "name": "simple sea", "author": "darkfox", "description": "sea, I like.", "tags": ["sea"], "likes": 2, "viewed": 37, "published": "Public", "date": "1591673746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 v = fragCoord.xy + vec2(0, -0.5 * iResolution.y);\n  float border = 20.0 * sin(PI * (v.x - iTime * 120.0) / 50.0);\n  float deepNess = step(border, v.y);\n  float r;\n  float g;\n  float b;\n  if(deepNess > 0.5){\n    r = (110.0 + 140.0 * smoothstep(-20.0, 200.0, v.y)) / 250.0;\n    g = (120.0 + 130.0 * smoothstep(-20.0, 200.0, v.y)) / 250.0;\n    b = (210.0 + 40.0 * smoothstep(-20.0, 200.0, v.y)) / 250.0;\n  }else{\n    r = (50.0 * smoothstep(-200.0, 20.0, v.y)) / 250.0;\n    g = (60.0 * smoothstep(-200.0, 20.0, v.y)) / 250.0;\n    b = (190.0 * smoothstep(-200.0, 20.0, v.y)) / 250.0;\n  }\n  fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 74, 74, 700]], "test": "timeout"}
{"id": "wtXcz8", "name": "marble of WaveSphere", "author": "foran", "description": "marble of WaveSphere", "tags": ["marbleofwavesphere"], "likes": 2, "viewed": 85, "published": "Public", "date": "1591386330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/MdySzR\n\nvec2 pa(in vec2 uv, in float per){\n    vec2 result = (cos(uv.x*per)) * normalize(vec2(cos((uv.x)*per), .5));\n    return result;\n}\n\nvec2 pb(in vec2 uv, in float per){\n    vec2 result = (cos(uv.y*per)) * normalize(vec2(1., cos((uv.y)*per)));\n    return result;\n}\nmat2x2 rot(float angle)\n{\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat2x2(c,-s,s,c);\n}\nfloat sdWaveSphere(vec3 p,float radius,int waves,float waveSize)\n{\n    //bounding Sphere\n    float d=length(p)-radius*2.2;\n    if(d>0.)return.2;\n    // deformation of radius\n    d=waveSize*(radius*radius-(p.y*p.y));\n    radius+=d*cos(atan(p.x,p.z)*float(waves));\n    return.5*(length(p)-radius);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*.35;\n    \n\tvec2 uv =(fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y*.5+.5;\n         uv*=rot(-.14*t);// вращение uv   \n    vec2 vpert = pa(uv, 5.);//5-15\n    uv += vpert * sin(t) *.32;//.3-.9\n    \n    vec2 hpert = pb(uv, 5.);//5-15\n     uv += hpert * sin(t) * .3208;//.3-.9\n    \n    //vec4 col = texture2D(iChannel0, uv);\n    //fragColor=fragColor=mix(vec4(sin(uv.x*2.),0.,//градиент\n    //cos(uv.y*3.),1.),col,.9);\n\tfragColor = mix(6.*vec4(sin(uv.x*12.), mod(uv.x*12., .25),//градиент \n    cos(uv.y*13.), 1.),vec4(sin(t*.5)*3.,sin(t*.5),sin(t*1.5)*\n    11.,tan(t*22.15)*1.), .49);\n       //float sdWaveSphere(vec3 p,float radius,int waves,float waveSize)\n    float wave=sdWaveSphere(uv.xxy,1.518,15,t*.4);\n    fragColor =fragColor* wave;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXcz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 75, 75, 170], [172, 172, 206, 206, 301], [302, 302, 327, 327, 406], [407, 407, 473, 495, 704], [705, 705, 762, 762, 1571]], "test": "timeout"}
{"id": "WtXczn", "name": "DomainDistortion TheArtOfCode", "author": "stradiotto", "description": "Just a very small adaptation from Example based on code from Youtube - ShaderToy Tutorial Part 4 - Domain distortion", "tags": ["rect", "band", "remap", "remap01", "smokeappearance"], "likes": 3, "viewed": 135, "published": "Public", "date": "1591210840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n1) Example based on code from Youtube - ShaderToy Tutorial Part 4 - Domain distortion\nFrom The Art of Code - https://www.youtube.com/watch?v=jKuXA0trQPE&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5&index=4\n\nThanks again\n\n2) If you want to include your webcam, uncomment the code below and include webcan on iChannel0\n*/\n\nfloat band(float t, float start, float end, float blur)\n{\n\tfloat step1 = smoothstep(start-blur, start+blur, t);\n\tfloat step2 = smoothstep(end  +blur, end  -blur, t);\n    return step1 * step2;\n}\n\nfloat rect(vec2 uv, vec4 coords, float blur)\n{ \n    float x = band(uv.x, coords[0], coords[2], blur);\n    float y = band(uv.y, coords[1], coords[3], blur);\n    return x*y;\n}\n\nfloat remap01(float t, float a, float b)\n{\n\treturn (t-a) / (b-a);\n}\n\nfloat remap(float t, float a0, float b0, float a1, float b1)\n{\n\treturn a1 + (b1 - a1) * remap01(t, a0, b0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv     -= .5;\n    uv.x   *= iResolution.x / iResolution.y;\n    \n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float m = sin(x*8. + 1.*iTime)*.4;\n    m*=m*.35;\n    y-=m;\n    \n    float blur = remap(x, -.5, 1., 0., .25);\n    \n    vec4 i2= \n        vec4(1., 1., 1., 1.)\n        //* texture(iChannel0, uv * vec2(1)  + vec2(.5)) \n        * vec4(1., 1., 1., 1.)  \n        * rect(vec2(x, y), \n               vec4(\n                   -.5, \n                   -.1, \n                    .5, \n                    .1\n               ), \n          blur)\n        ;\n   \n    fragColor = i2;\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 376, 376, 512], [514, 514, 560, 560, 687], [689, 689, 731, 731, 756], [758, 758, 820, 820, 867], [869, 869, 926, 926, 1559]], "test": "timeout"}
{"id": "wtXyDf", "name": "Truchet hex tiles", "author": "vegardno", "description": "Inspired by: https://www.reddit.com/r/generative/comments/hgjq22/circuitous/", "tags": ["truchet", "hex", "tiles"], "likes": 13, "viewed": 163, "published": "Public", "date": "1593271630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cube_round(vec3 cube)\n{\n    float rx = round(cube.x);\n    float ry = round(cube.y);\n    float rz = round(cube.z);\n\n    float x_diff = abs(rx - cube.x);\n    float y_diff = abs(ry - cube.y);\n    float z_diff = abs(rz - cube.z);\n\n    if (x_diff > y_diff && x_diff > z_diff) {\n        rx = -ry - rz;\n    } else if (y_diff > z_diff) {\n        ry = -rx - rz;\n    } else {\n        rz = -rx - ry;\n    }\n\n    return vec3(rx, ry, rz);\n}\n\nvec2 cube_to_axial(vec3 cube)\n{\n    float q = cube.x;\n    float r = cube.z;\n    return vec2(q, r);\n}\n\nvec3 axial_to_cube(vec2 hex)\n{\n    float x = hex.x;\n    float z = hex.y;\n    float y = -x - z;\n    return vec3(x, y, z);\n}\n\nvec2 hex_round(vec2 hex)\n{\n    return cube_to_axial(cube_round(axial_to_cube(hex)));\n}\n\nconst float size = 20.0;\n\nvec2 pixel_to_pointy_hex(vec2 point)\n{\n    float q = (sqrt(3.0) / 3.0 * point.x - 1.0 / 3.0 * point.y) / size;\n    float r = (2.0 / 3.0 * point.y) / size;\n    return hex_round(vec2(q, r));\n}\n\nvec2 pointy_hex_to_pixel(vec2 hex)\n{\n    float x = size * (sqrt(3.0) * hex.x  +  sqrt(3.0) / 2.0 * hex.y);\n    float y = size * (3.0 / 2.0 * hex.y);\n    return vec2(x, y);\n}\n\nvec2 opModPolarMirrored( in vec2 p, float theta, float offset)\n{\n    float a = atan(p.y, p.x) - offset;\n    a = abs(mod(a + .5 * theta, theta) - .5 * theta);\n    return length(p) * vec2(cos(a), sin(a));\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float scale = 150.;\n    scale = 500. + 450. * cos(radians(1.) * iTime + radians(90.));\n\n    vec2 uv = scale * (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv = rotate(radians(2.) * iTime + radians(10.)) * uv;\n    \n    vec2 hex = pixel_to_pointy_hex(uv);\n    vec2 uv2 = pointy_hex_to_pixel(hex);\n\n    float b = smoothstep(-.1, .1, sin(radians(360.) * rand(floor(hex)) + radians(20.) * iTime));\n    \n    vec2 rel = opModPolarMirrored(uv2 - uv, radians(360.) / 3., radians(30. + 60. * b));\n    float r = abs(length(rel - vec2(size, 0.)) - 10.) - 2.;\n    \n    float d = smoothstep(0., 2. * scale / iResolution.y, r);\n    vec3 col = vec3(d);\n\n    uv = fragCoord / iResolution.xy;\n\tcol *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.18 );\n  \tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXyDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 431], [433, 433, 464, 464, 533], [535, 535, 565, 565, 657], [659, 659, 685, 685, 745], [773, 773, 811, 811, 963], [965, 965, 1001, 1001, 1138], [1140, 1140, 1204, 1204, 1344], [1346, 1346, 1367, 1367, 1439], [1441, 1441, 1463, 1463, 1539], [1541, 1541, 1596, 1596, 2375]], "test": "timeout"}
{"id": "WtXyRB", "name": "Desert Reflections", "author": "dr2", "description": "Desert reflections", "tags": ["reflection", "desert"], "likes": 13, "viewed": 270, "published": "Public API", "date": "1592293948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Desert Reflections\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Desert reflections (with bits from \"Extreme Desert\" and \"Ozymandias Redux\")\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nvec4 dateCur;\nvec3 sunDir, qHit, rPos;\nvec2 gId;\nfloat tCur, dstFar, hgSize;\nint idObj;\nbool isOcc;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (isOcc) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= rPos;\n    q = p;\n    q.y -= -1.;\n    d = PrCylDf (q.xzy, 0.5, 2.);\n    DMINQ (1);\n    q.y -= 3.9;\n    d = PrSphDf (q, 2.);\n    DMINQ (2);\n  }\n  return dMin;\n}\n\nvoid SetGrdConf ()\n{\n  rPos.xz = 0.5 * hgSize * sin (2. * pi * Hashfv2 (17.1 * gId + 0.3) + vec2 (0.5 * pi, 0.));\n  rPos.y = GrndHt (HexToPix (gId * hgSize) + rPos.xz);\n  isOcc = (Hashfv2 (19.1 * gId + 0.3) > 0.2);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.03;\n  for (int j = 0; j < 24; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (h < 0.005) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  h = RippleHt (p);\n  e = vec2 (0.002, 0.);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.45, 0.45, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 col, vn;\n  float dFac;\n  dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n  ro += dstObj * rd;\n  vn = ObjNf (ro);\n  if (idObj == 1) {\n    vn = VaryNf (8. * qHit, vn, 4. * dFac);\n    col = vec3 (0.7, 0.75, 0.8);\n  } else if (idObj == 2) {\n    col = (qHit.y > 0.) ? vec3 (0.5, 0.5, 1.) : vec3 (0.7, 0.7, 0.2);\n  }\n  col = col * (0.2 + 0.1 * max (0., - dot (vn, sunDir)) +\n     0.7 * max (0., dot (vn, sunDir))) +\n     0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  col *= 0.7 + 0.3 * dFac;\n  col = mix (col, SkyBg (rd), pow (dstObj / dstFar, 4.));\n  return col;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dFac, f, sh;\n  dFac = 1. - smoothstep (0.15, 0.35, dstGrnd / dstFar);\n  ro += dstGrnd * rd;\n  vn = GrndNf (ro);\n  col = mix (vec3 (0.65, 0.45, 0.1), vec3 (0.9, 0.7, 0.4), smoothstep (1., 3., ro.y));\n  col *= 1. - 0.3 * dFac * Fbm2 (128. * ro.xz);\n  if (dFac > 0.) {\n    if (vn.y > 0.3) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.3, 0.8, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 4. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.95 + 0.05 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrdConf ();\n    if (isOcc) col *= 0.7 + 0.3 * smoothstep (0.5, 0.8, length (ro.xz -\n       HexToPix (gId * hgSize) - rPos.xz));\n  }\n  sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n  sh = min (sh, 1. - 0.6 * smoothstep (0.4, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.))));\n  col *= 0.1 + sh * (0.2 * vn.y + 0.7 * max (0., dot (vn, sunDir)));\n  col *= 0.7 + 0.3 * dFac;\n  col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, dstObj, dstObjO;\n  bool isRef;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  isRef = false;\n  if (dstObj < min (dstGrnd, dstFar) && idObj == 2) {\n    isRef = true;\n    dstObjO = dstObj;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    col = (dstObj < dstGrnd) ? ObjCol (ro, rd, dstObj) : GrndCol (ro, rd, dstGrnd);\n    if (isRef) col = mix (col, SkyBg (rd), pow (dstObjO / dstFar, 8.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 w;\n  vec2 cs;\n  v = normalize (v);\n  cs = sin (clamp (2. * (v.z * a.x - v.x * a.z), -0.2 * pi, 0.2 * pi) + vec2 (0.5 * pi, 0.));\n  w = normalize (vec3 (v.z, 0., - v.x));\n  return mat3 (w, cross (v, w), v) * mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv;\n  float el, az, sunEl, sunAz, t, hSum;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  hgSize = 16.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 150.;\n  vuMat = StdVuMat (el, az);\n  t = 3. * tCur;\n  ro = TrackPath (t);\n  fpF = TrackPath (t + 1.);\n  fpB = TrackPath (t - 1.);\n  flMat = EvalOri ((fpF - fpB) / 2., fpF - 2. * ro + fpB);\n  hSum = 0.;\n  for (float k = 0.; k < 7.; k ++) hSum += GrndHt (TrackPath (t + 0.5 * (k - 1.)).xz);\n  ro.y = 8. * gr.hFac + hSum / 7.;\n  sunAz = 0.005 * 2. * pi * tCur;\n  sunEl = pi * (0.25 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunEl) * sin (sunAz + vec2 (0.5 * pi, 0.)), sin (sunEl)).xzy;\n  rd = flMat * (vuMat * normalize (vec3 (uv, 4.)));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXyRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[735, 735, 758, 758, 1014], [1016, 1016, 1050, 1050, 1516], [1518, 1518, 1540, 1540, 1679], [1752, 1752, 1774, 1774, 2038], [2040, 2040, 2060, 2060, 2256], [2258, 2258, 2291, 2291, 3557], [3559, 3559, 3580, 3580, 3828], [3830, 3830, 3867, 3867, 4273], [4275, 4275, 4300, 4300, 4679], [4681, 4681, 4725, 4725, 4924], [4926, 4926, 4948, 4948, 5042], [5044, 5044, 5076, 5076, 5406], [5408, 5408, 5454, 5454, 6042], [6044, 6044, 6092, 6092, 7119], [7121, 7121, 7156, 7156, 7844], [7846, 7846, 7877, 7877, 8146], [8148, 8148, 8174, 8174, 8287], [8289, 8289, 8345, 8345, 9536], [9538, 9538, 9571, 9571, 9598], [9600, 9600, 9642, 9642, 9693], [9695, 9695, 9717, 9717, 9755], [9757, 9757, 9781, 9781, 10011], [10013, 10013, 10037, 10037, 10097], [10099, 10099, 10129, 10129, 10242], [10244, 10244, 10280, 10280, 10486], [10520, 10520, 10544, 10544, 10674], [10676, 10676, 10700, 10700, 10760], [10762, 10762, 10787, 10787, 10973], [10975, 10975, 10996, 10996, 11151], [11153, 11153, 11182, 11182, 11394], [11396, 11396, 11435, 11435, 11615]], "test": "error"}
{"id": "WtXyW4", "name": "Alien Waterworld", "author": "mrange", "description": "License CC0: Alien Waterworld\n  Been working on space themed shaders\n  Code \"borrowed\" from the usual suspects\n", "tags": ["terrainscifi"], "likes": 26, "viewed": 632, "published": "Public API", "date": "1592052399", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Alien Waterworld\n//  Been working on space themed shaders\n//  Code \"borrowed\" from the usual suspects\n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.00001\n#define MAX_ITER        55\n#define MAX_DISTANCE    31.0\n#define PERIOD          45.0\n#define TIME            mod(iTime, PERIOD)\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = skyCol1*skyCol1*skyCol1*3.0;\nconst vec3  sunCol1       = vec3(1.0,0.9,0.8);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.8);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  ringColor     = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  planetCol     = sqrt(vec3(0.9, 0.8, 0.7));\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere)\n{\n  vec3 ce = sphere.xyz;\n  float ra = sphere.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n\nfloat noise2(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat smoother(float d, float s) {\n  return s*tanh(d/s);\n}\n\nfloat heightMod(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += -pp.x*0.2;\n  p = toRect(pp);\n  return pow((psin(1.0*p.x)*psin(1.0*p.y)), max(0.25, pp.x*0.20))*0.8;\n}\n\nfloat loheight(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 3; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat height(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 5; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat hiheight(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 6; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n  \nvec3 normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n  \n  vec3 n;\n  \n  n.x = (hiheight(p - eps.xy, d) - hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (hiheight(p - eps.yx, d) - hiheight(p + eps.yx, d));\n  \n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = height(p.xz, d);\n    \n    if (d > MAX_DISTANCE) {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE) {\n      return d;\n    }\n\n    float sl = 0.9;\n\n    dt = max(hd*sl, TOLERANCE+0.0005*d);\n    lastd = d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.2, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n  \n  float dustTransparency = smoothstep(-0.15, 0.075, rd.y);\n\n  vec3 skyCol = mix(skyCol1, skyCol2, sqrt(dustTransparency));\n  skyCol *= (1.0-dustTransparency);\n  \n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*dustTransparency*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  final += skyCol + sunCol + smallSunCol;\n\n  return final;\n}\n\nvec3 shipColor(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*0.05;\n  p = toRect(pp);\n\n  float n = mod1(p.x, 0.15);\n  p.y += 3.0-TIME*0.5+0.05*abs(n*n);\n\n  float td = abs(p.x) - (0.005-p.y*0.002);\n  td = abs(td) - (0.02*pow(-p.y, 0.25));\n  float sd = circle(p, 0.05);\n  \n  vec3 trailCol = vec3(0.5)*smoothstep(-5.0, 0.0, p.y)*step(p.y, 0.0)*smoothstep(0.0, 0.025, -td);\n  vec3 shipCol = vec3(0.5+smoothstep(-1.0, 1.0, sin(TIME*15.0*TAU+n)))*smoothstep(0.0, 0.075, -sd);\n  \n  vec3 col = trailCol;\n  col += shipCol;\n\n  float sm = step(abs(n), 2.0);\n  \n  return col*sm;\n}\n\nvec3 getColor(vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0);\n  \n  const float shipHeight = 1.0;\n  const float seaHeight = 0.0;\n  const float cloudHeight = 0.2;\n  const float upperCloudHeight = 0.5;\n  \n  float id = (cloudHeight - ro.y)/rd.y;\n  \n  if (id > 0.0) {\n    float d = march(ro, rd, id, max_iter);\n    vec3 sunDir = sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, 1.0, -1.0);\n    vec3 p = ro + d*rd;\n\n    float loh = loheight(p.xz, d);\n    float loh2 = loheight(p.xz+sunDir.xz*0.05, d);\n    float hih = hiheight(p.xz, d);\n    vec3 normal = normal(p.xz, d);\n\n    float ud = (upperCloudHeight - 4.0*loh - ro.y)/rd.y;\n    \n    float sd = (seaHeight - ro.y)/rd.y;\n    vec3 sp = ro + sd*rd;\n    float scd = (cloudHeight - sp.y)/sunDir.y;\n    vec3 scp = sp + sunDir*scd;\n    \n    float sloh = loheight(scp.xz, d);\n    float cshd = exp(-15.0*sloh);\n\n    float amb = 0.3;\n \n    vec3 seaNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 seaRef = reflect(rd, seaNormal);    \n    vec3 seaCol = .25*skyColor(p, seaRef);\n    seaCol += pow(max(dot(seaNormal, sunDir), 0.0), 2.0); \n    seaCol *= cshd;\n    seaCol += 0.075*pow(vec3(0.1, 1.3, 4.0), vec3(max(dot(seaNormal, seaRef), 0.0)));\n\n    float spe = pow(max(dot(sunDir, reflect(rd, normal)), 0.0), 3.0);\n    float fre = pow(1.0-dot(normal, -rd), 2.0);\n\n    col = seaCol;\n\n    \n    const float level = 0.00;\n    const float level2 = 0.3;\n    // REALLY fake shadows and lighting\n    vec3 scol = sunCol1*(smoothstep(level, level2, hih) - smoothstep(level, level2, loh2));\n    col = mix(vec3(1.0), col, exp(-17.0*(hih-0.25*loh)));\n    col = mix(vec3(.75), col, exp(-10.0*loh*(max(d-ud, 0.0))));\n    col += scol;\n      \n    col += vec3(0.5)*spe*fre;    \n    \n    float ssd = (shipHeight - ro.y)/rd.y;\n\n    col += shipColor((ro + rd*ssd).xz);\n\n    col = mix(col, skyCol, smoothstep(0.5*MAX_DISTANCE, 1.*MAX_DISTANCE, d));\n    \n  } else {\n    col = skyCol;\n  }\n\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 getSample1(vec2 p, float time) {\n  vec3 ro  = vec3(0.5, 5.5, -2.0);\n  vec3 la  = ro + vec3(0.0, -1.+0.9*TIME/PERIOD,  1.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = getColor(ro, rd)  ;\n \n  return col;\n  \n}\n\nvec3 getSample2(vec2 p, float time) {\n  p.y-=time*0.25;\n  float h = height(p, 0.0);\n  vec3 n = normal(p, 0.0);\n  \n  vec3 lp = vec3(10.0, -1.2, 0.0);\n  \n  vec3 ld = normalize(vec3(p.x, h, p.y)- lp);\n  \n  float d = max(dot(ld, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n\n  col = vec3(1.0)*(h+0.1);\n  col += vec3(1.5)*pow(d, 0.75);\n \n  return col;\n  \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = getSample1(p, TIME);\n  \n  col = postProcess(col, q);\n  \n  col *= smoothstep(0.0, 2.0, TIME);\n  col *= 1.0-smoothstep(PERIOD-2.0, PERIOD, TIME);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXyW4.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[956, 956, 989, 989, 1074], [1076, 1076, 1097, 1097, 1126], [1128, 1128, 1149, 1149, 1190], [1192, 1192, 1214, 1214, 1258], [1260, 1260, 1299, 1299, 1424], [1426, 1426, 1457, 1457, 1483], [1485, 1485, 1527, 1527, 1574], [1576, 1576, 1623, 1623, 1874], [1876, 1876, 1900, 1900, 1970], [1973, 1973, 1995, 1995, 2470], [2472, 2472, 2506, 2506, 2530], [2532, 2532, 2557, 2557, 2693], [2695, 2695, 2728, 2728, 3212], [3214, 3214, 3245, 3245, 3729], [3731, 3731, 3764, 3764, 4248], [4252, 4252, 4282, 4282, 4501], [4503, 4503, 4562, 4562, 5038], [5040, 5040, 5061, 5061, 5105], [5107, 5107, 5133, 5133, 5179], [5181, 5181, 5214, 5214, 7300], [7302, 7302, 7326, 7326, 7872], [7874, 7874, 7907, 7907, 9934], [9936, 9936, 9979, 10004, 10253], [10255, 10255, 10292, 10292, 10611], [10613, 10613, 10650, 10650, 10956], [10958, 10958, 11010, 11010, 11308]], "test": "error"}
{"id": "WtXyWj", "name": "Connection parts", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1275792270386532352", "tags": ["2tweets"], "likes": 10, "viewed": 154, "published": "Public", "date": "1593009901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tO-=O;\n\tfor(float s,k,g,e,i=0.;i++<45.;){\n        vec3 p=g*normalize(vec3((C*2.-iResolution.xy)/iResolution.y,2));\n        p.z+=iTime;\n        p.xz=fract(p.xz)-.5;\n        k=1.;\n        for(int i=0;i++<9;)\n            s=2./clamp(dot(p,p),.1,1.),\n            p=abs(p)*s-vec3(.5,3,.5),\n            k*=s;\n        g+=e=length(p)/k-.001;\n        e<.01?O.xyz+=cos(vec3(7)+p*.1)/i:p;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 418]], "test": "ok"}
{"id": "wtXyz4", "name": "earthbound bg 4", "author": "thefox231", "description": "these are too fun to make. help me", "tags": ["2d", "abstract", "snes", "earthbound"], "likes": 5, "viewed": 353, "published": "Public API", "date": "1591534762", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 mainColor = vec3(.8, .1, .2);\n\nfloat spiral(vec2 m, float t) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n\tfloat v = sin(50.*(sqrt(r)-0.02*a-.3*t));\n\treturn clamp(v,0.,1.);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // fix aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    uv.x -= (aspectRatio - 1.) * .5;\n     \n    // pixelate\n    float pxAmt = 90.;\n    \n    uv.x = floor(uv.x * pxAmt) / pxAmt;\n    uv.y = floor(uv.y * pxAmt) / pxAmt;\n    \n    // interlacing .\n    if (mod(fragCoord.y, 2.) < 1.) {\n        uv += .4 + sin(iTime * .5 + uv.y * 5.) * (.3 + sin(iTime) * .1);\n    } else {\n        uv -= .4 + sin(iTime * .5 + uv.y * 5. + .5) * (.3 + sin(iTime) * .1);\n    }\n    \n    // spiralllllllllllllll\n    vec3 color = mainColor * spiral(uv - .5, iTime * .2 + sin(uv.y * 7.) * .2);\n        \n    // color shortening\n    // gives it a kind of like snes-like palette\n    float shortAmt = 4.0;\n    color = ceil(color * shortAmt) / shortAmt;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 73, 73, 192], [194, 194, 249, 249, 1106]], "test": "timeout"}
