{"id": "3df3DH", "name": "GS Rubber Floor with Shadows", "author": "slimyfrog", "description": "GS Second experiment with soft shadows and some optimizations to ray marching", "tags": ["shadows", "checkers", "smoothmin"], "likes": 6, "viewed": 132, "published": "Public", "date": "1545962873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DISTANCE   20.0\n#define MIN_DISTANCE    0.001\n#define PI \t\t\t    3.142\n#define PI2 \t\t   (PI/2.0)\n#define SPHERE_HEIGHT\t0.55\n#define AMBIENT_COLOR    vec3(0.38,0.29f,0.9f)\n// smooth min from iq\nfloat smoothmin( float a, float b)\n{\n    float h = max( 1.0-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h*(1.0/6.0);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat planeDf(vec3 p)\n{    \n    return p.y; // implied p.y - 0.0 where 0.0 is plane height\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sphereDf(vec3 p, vec3 spherePos, float radius)\n{\n    return length(spherePos + p) - radius;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat boxDf( vec3 p, vec3 boxPos, vec3 size )\n{\n  vec3 d = abs(p + boxPos) - size;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sceneDf(vec3 p)\n{\n    float sphereDist = sin(iTime * 0.2) * 10.0;\n    //sphere positions\n    vec3 sp1 = vec3(sin(iTime) * sphereDist,SPHERE_HEIGHT, cos(iTime)* sphereDist);\n    vec3 sp2 = vec3(sin(iTime + PI2)* sphereDist,SPHERE_HEIGHT, cos(iTime +PI2)* sphereDist);\n    vec3 sp3 = vec3(sin(iTime + PI)* sphereDist,SPHERE_HEIGHT, cos(iTime+PI)* sphereDist);\n    vec3 sp4 = vec3(sin(iTime + PI2*3.0)* sphereDist,SPHERE_HEIGHT, cos(iTime+PI2*3.0)* sphereDist);\n    \n    float dist = smoothmin(\n        sphereDf(p, sp1, 1.0), \n        sphereDf(p, sp2, 1.0));\n    dist = smoothmin(\n        sphereDf(p, sp3, 1.0), \n        dist);\n    dist = smoothmin(\n        sphereDf(p, sp4 , 1.0), \n        dist);\n    dist = smoothmin(dist, planeDf(p));\n    \n    dist = smoothmin(dist, boxDf(p, vec3(0), vec3(1)));\n    return dist;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.01f;\n    \n    vec3 normal;\n    normal.x = sceneDf(vec3(p.x + e,p.y,p.z)) - sceneDf(vec3(p.x - e, p.y, p.z));\n    normal.y = sceneDf(vec3(p.x,p.y + e,p.z)) - sceneDf(vec3(p.x, p.y - e, p.z));\n    normal.z = sceneDf(vec3(p.x,p.y,p.z + e)) - sceneDf(vec3(p.x, p.y, p.z - e));\n    \n    return normalize(normal);\n}\n\n// odd/even checker pattern\nfloat checkers( in vec3 p )\n{\n    return int(50.0+p.x)%2 != int(50.0+p.z)%2 ? 1.0 : 0.0;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat calcShadow(vec3 pt, vec3 dir)\n{\n    float shade = 1.0;\n\tfloat t = 0.02;\n    while(t < 5.0)\n    {\n        float dist = sceneDf(pt + dir * t);\n        t += dist;\n        shade = min(shade, 5.0 * dist/t);\n        if (dist <= 0.001){\n            break;\n        }\n    }\n    return shade;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 processLighting(vec3 baseColor, vec3 eyePos, vec3 surfacePoint)\n{\n\tconst vec3 ambientLight =AMBIENT_COLOR;\n    \n    vec3 diffuseDir = normalize(vec3(1,-0.75, -1));\n    float diffuseIntensity = 0.7f;\n    \n    float shaded = calcShadow(surfacePoint, -diffuseDir);\n    vec3 normal = calcNormal(surfacePoint);\n    \n    vec3 e = normalize(eyePos);\n    vec3 r = normalize(reflect(diffuseDir,normal));\n\tfloat specular =  pow(max(dot(r,e),0.0),8.0);\n\tspecular = clamp(specular, 0.0, 1.0);\n                 \n    float diffDot = max(dot(-diffuseDir, normal), 0.0);\n        \n    vec3 color = baseColor * (ambientLight +  (diffDot * vec3(0.8,0.8,0.6) + specular) * shaded);\n    return color;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 marchRay(vec3 eyePos,vec3 dir)\n{\n    vec3 color =  AMBIENT_COLOR * 1.5;\n    float t = 0.001;\n    while(t < MAX_DISTANCE)\n    {\n        vec3 currentPoint = eyePos + (t * dir);\n        float dist = sceneDf(currentPoint);\n        if(dist <= MIN_DISTANCE)\n        {\n            color = processLighting(vec3(checkers(currentPoint)), eyePos, currentPoint);\n            break;\n        }\n        t += dist;\n    }\n    return color;\n}\n\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera\t\n\tvec3 eye = vec3( sin(iTime * 0.2) * 7.0, 3.0, cos(iTime * 0.2) * 7.0 );\n    vec3 lookat = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 forward = normalize( lookat - eye );\n    vec3 right = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 up = normalize( cross(right, forward));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 dir = normalize( p.x*right + p.y*up + 3.5*forward );\n       \n    vec3 color = marchRay(eye, dir);\n    vec3 grayscale = vec3(dot(color, vec3(0.25, 0.7, 0.05)));\n    \n    fragColor = vec4(mix(color, grayscale, sin(iTime)),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3df3DH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 204, 240, 240, 324], [326, 455, 478, 478, 547], [549, 678, 732, 732, 777], [779, 908, 955, 955, 1063], [1066, 1195, 1218, 1218, 2015], [2017, 2146, 2171, 2171, 2497], [2499, 2527, 2556, 2556, 2617], [2619, 2748, 2785, 2785, 3038], [3040, 3169, 3239, 3239, 3855], [3857, 3986, 4023, 4023, 4415], [4419, 4548, 4605, 4621, 5243]], "test": "ok"}
{"id": "3dlGz4", "name": "snowbird army", "author": "bitnenfer", "description": "small shader done for streaming. :3", "tags": ["raymarching", "snowman"], "likes": 5, "viewed": 137, "published": "Public", "date": "1545191469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.001\n#define FARCLIP 100.0\n#define NEARCLIP 0.001\n#define MATERIAL_NONE -1.0\n#define MATERIAL_BODY 0.0\n#define MATERIAL_FLOOR 1.0\n#define MATERIAL_ARMS 2.0\n#define MATERIAL_BUTTON 3.0\n#define MATERIAL_NOSE 4.0\n\nconst vec3 kLightDir = vec3(0.268683, 0.228427, -0.127168);\n\nvec2 opUnion(in vec2 a, in vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec2 mapBody(in vec3 p)\n{\n    p.y *= 1.2;\n    float bottom = sdSphere(p + vec3(0.0, 0.0, 0.0), 0.8);\n    float middle = sdSphere(p + vec3(0.0, -0.99, 0.0), 0.65);\n    float head = sdSphere(p + vec3(0.0, -1.8, 0.0), 0.4);\n    \n    return vec2(min(middle, min(bottom, head)), MATERIAL_BODY);\n}\n\nvec2 mapArms(in vec3 p)\n{\n    p.y -= sin(iTime * 4.0) * 0.33;\n    p.y += sin(p.x * 1.1 + iTime * 4.0) * 0.3;\n    float arm = sdBox(p + vec3(0.0, -0.99, 0.0), vec3(1.4, 0.02, 0.02)) - 0.04;\n\n    return vec2(arm, MATERIAL_ARMS);\n}\n\nvec2 mapButtons(in vec3 p)\n{\n    float b0 = sdSphere(p + vec3(0.0, -0.4, 0.6), 0.1);\n    float b1 = sdSphere(p + vec3(0.0, -0.9, 0.59), 0.1);\n    float b2 = sdSphere(p + vec3(0.0, -1.15, 0.45), 0.1);\n    \n    float e0 = sdSphere(p + vec3(0.25, -1.55, 0.28), 0.05);\n    float e1 = sdSphere(p + vec3(-0.25, -1.55, 0.28), 0.05);\n    \n    return vec2(min(e1, min(e0, min(b0, min(b1, b2)))), MATERIAL_BUTTON);\n}\n\nvec2 mapScene(vec3 p)\n{\n    p.y *= 1.0 + sin(iTime * 4.0 + p.x * 0.25 + p.z * 0.25) * 0.1;\n    vec3 rep = vec3(4.0, 0.0, 4.0);\n    p = mod(p, rep) - 0.5 * rep;\n     \n    vec2 scene = vec2(0.0, -1.0);\n    vec2 body = mapBody(p);\n    vec2 arms = mapArms(p);\n    vec2 buttons = mapButtons(p);\n    vec2 flr = vec2(p.y + 0.28, MATERIAL_FLOOR);\n\n    vec3 size = vec3(0.05, 0.1 * sin(p.z * 10.0), 0.4); \n    vec2 nose = vec2(sdBox(p + vec3(0.0, -1.5, 0.3), size) - 0.05, MATERIAL_NOSE);\n    \n    scene = opUnion(body, flr);\n    scene = opUnion(scene, arms);\n    scene = opUnion(scene, buttons);\n    scene = opUnion(scene, nose);\n    \n    return scene;\n}\n\nvec2 rayMarch(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 400; ++i)\n    {\n        vec2 r =  mapScene(ro + rd * t);\n        if (r.x < EPSILON)\n        {\n            return vec2(t,r.y);\n        }\n        t += r.x * 0.7;\n        if (t > FARCLIP) break;\n    }\n    return vec2(FARCLIP, -1.0);\n}\n\nvoid opRotate(inout vec2 p, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float vx = p.x * c - p.y * s;\n    float vy = p.x * s + p.y * c;\n    p.x = vx;\n    p.y = vy;\n}\n\nvec3 opNormal(vec3 p)\n{\n    float d = mapScene(p).x;\n    vec2 e = vec2(0.0, EPSILON);\n    vec3 n = d - vec3(\n        mapScene(p - e.yxx).x,\n        mapScene(p - e.xyx).x,\n        mapScene(p - e.xxy).x\n    );\n    return normalize(n);\n}\n\nvec3 baseShade(in vec3 ro, in vec3 rd, in vec2 ray)\n{\n    vec3 color = vec3(1.0, 0.0, 1.0);\n    \n    if (ray.y == MATERIAL_BODY)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    else if (ray.y == MATERIAL_FLOOR)\n    {\n        color = vec3(0.9, 0.9, 1.0);\n    }\n    else if (ray.y == MATERIAL_ARMS)\n    {\n        color = vec3(0.55, 0.32, 0.19);\n    }\n    else if (ray.y == MATERIAL_BUTTON)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else if (ray.y == MATERIAL_NOSE)\n    {\n        color = vec3(1.0, 0.37, 0.2);\n    }\n    \n    vec3 p = ro + rd * ray.x;\n    vec3 n = opNormal(p);\n    float diff = max(0.0, dot(n, normalize(kLightDir)));\n    \n    vec2 shadowRay = rayMarch(p + n * 0.001, normalize(kLightDir));\n    if (shadowRay.x < FARCLIP)\n    {\n        color *= vec3(0.5, 0.5, 0.9);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(iResolution.x / iResolution.y, 1.0);    \n    vec3 ro = vec3(0.0, 3.0, -5.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    opRotate(ro.yz, 0.3);\n    opRotate(rd.yz, 0.3);\n    \n    float rx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.15 * 2.0;\n    opRotate(ro.xz, rx);\n    opRotate(rd.xz, rx);\n    \n    vec2 r = rayMarch(ro, rd);\n        \n    if (r.x < FARCLIP)\n    {\n        color = baseShade(ro, rd, r);\n    }\n    \n    color += 1.0 - pow((1.0 - (r.x / FARCLIP)), sqrt(0.1));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 325, 325, 357], [359, 359, 392, 392, 420], [422, 422, 453, 453, 603], [605, 605, 630, 630, 896], [898, 898, 923, 923, 1126], [1128, 1128, 1156, 1156, 1534], [1536, 1536, 1559, 1559, 2182], [2184, 2184, 2223, 2223, 2498], [2500, 2500, 2538, 2538, 2680], [2682, 2682, 2705, 2705, 2916], [2918, 2918, 2971, 2971, 3743], [3745, 3745, 3800, 3800, 4408]], "test": "ok"}
{"id": "3ds3RN", "name": "cold sky", "author": "cailuming", "description": "a cold sky, and simple 2d mountain ", "tags": ["noise"], "likes": 15, "viewed": 293, "published": "Public", "date": "1545234954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\nvec3 getColor(float c){\n   float r = cos((c-0.75)*PI);\n   float g = cos((c-0.55)*PI);\n   float b = cos((c-0.25)*PI);\n   return vec3(r,g,b);\n}\n\nmat2 rot2D(float a){\n   float c = cos(a);\n   float s = cos(a);\n   return mat2(c,s,-s,c); \n}\n\nfloat hash1(vec2 p){\n  vec2 v = vec2(PI*1453.0,exp(1.)*3054.0);\n  return fract(sin(dot(p,v)*0.1)*4323.0);\n}\n\nvec2 hash2(vec2 p){\n  vec2 v = vec2(hash1(p),hash1(p*p));   \n  return v+v*rot2D(iTime*0.5); \n}\n\nfloat noise1D(float x){\n   float p = floor(x);\n   float f = fract(x);\n   \n   float p1 = p+1.0;\n   float h1 = hash1(vec2(p));\n   float h2 = hash1(vec2(p1));\n   \n   f = f*f*f*(f*(f*6.-15.)+10.);\n   float v = mix(h1,h2,f); \n    \n   return v;\n}\n\nfloat noise2D(vec2 uv){\n   vec2 p = floor(uv);\n   vec2 f = fract(uv);\n   vec2 e = vec2(1,0);\n   vec2 p00 = p;\n   vec2 p10 = p+e;\n   vec2 p11 = p+e.xx;\n   vec2 p01 = p+e.yx;\n   float v00 = dot(f-e.yy,hash2(p00));\n   float v10 = dot(f-e.xy,hash2(p10));\n   float v11 = dot(f-e.xx,hash2(p11));\n   float v01 = dot(f-e.yx,hash2(p01));\n    \n   f = f*f*f*(f*(f*6.-15.)+10.); \n   \n   return mix(mix(v00,v10,f.x),mix(v01,v11,f.x),f.y);\n}\n\nfloat fbm1d(vec2 uv){\n    float freq  = 1.0;\n    float ampli = 3.0;\n    float ret   = 0.0;\n\n    for(int i=0;i<5;i++){\n       ret += noise1D(uv.x*freq)*ampli;\n       ampli*=0.6;\n       freq*=2.0;\n       uv+=sin(0.01*float(i));\n    }\n    return ret;\n}\n\nfloat fbm(vec2 uv){\n    float freq  = 1.0;\n    float ampli = 3.0;\n    float ret   = 0.0;\n\n    for(int i=0;i<5;i++){\n       ret += noise2D(uv*freq)*ampli;\n       ampli*=0.6;\n       freq*=2.0;\n       uv+=sin(0.01*float(i));\n    }\n    return ret;\n}\n\nvoid mountain(inout vec3 col,vec2 uv,vec2 cuv){\n    cuv.y+=6.;\n    cuv.x+=7.0;\n    float n = fbm1d(cuv*0.12);\n    vec2  f = vec2(cuv.x,n);\n    float v = 0.1/length(cuv-f);\n    v = pow(v,3.5);\n    if(cuv.y<=n){\n      col-= 20.;\n    }else {\n      col-=v*10.;\n    }\n    \n}\n\nvoid moon(inout vec3 col,vec2 uv,vec2 cuv){\n   uv -= vec2(5.,3.);\n   uv*=vec2(0.1);\n   \n   vec2 f  = vec2(uv.x,uv.y);\n   float r = .1; \n   float v = r/(length(uv));\n   float t =  0.0;\n   \n   for(int i=0;i<4;i++){\n       t = iTime*0.5+float(i)*0.8;\n       v+=fbm(cuv+vec2(t,t*0.1))*0.05;\n   }\n    \n   col+= getColor(0.16)*v; \n}\n\nvoid star(inout vec3 col,vec2 uv,vec2 cuv){\n   float v =0.0;\n   \n    \n   v+=abs(0.5)/length(uv-70.*vec2(hash2(uv*5.0)));\n    \n   col+= getColor(0.14)*v*1.4; \n}\n\n\nvoid drawMeteor(inout vec3 col, in vec2 uv,vec2 startP,vec2 endP,float linWidth){\n \n   uv*=3.0;\n   vec2 lineDir=endP-startP;\n   vec2 fragDir=uv-startP;\n   \n   // keep the line coefficient bewteen [0,1] so that the projective dir on the \n   // lineDir will not exceed or we couldn't get a line segment but a line.\n   float lineCoe=clamp(dot(lineDir,fragDir)/dot(lineDir,lineDir),0.,1.0);\n                       \n   vec2 projDir=lineCoe*lineDir;\n    \n   vec2 fragToLineDir= fragDir- projDir;\n    \n   float dis=length(fragToLineDir);\n   float disToTail = length(projDir);\n   dis=linWidth/dis;\n     \n   col += dis*getColor(0.3)*pow(disToTail,3.0);\n    \n}\n \nvoid drawMeteors(inout vec3 col,vec2 uv){\n    \n    vec2 dir = normalize(vec2(-1.0,-0.5));\n    vec2 mv  = -dir*cos(mod(iTime*2.,PI))*60.0;\n    vec2 sp  = vec2(10.0+100.0*hash1(vec2(floor(iTime*2./PI))),10.0);\n    vec2 ep  = sp+dir*5.0;\n\n    drawMeteor(col,uv,sp+mv,ep+mv,0.0005);\n\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv - vec2(0.5);\n    cuv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    cuv *=10.;\n    moon(col,cuv,uv);\n \n    star(col,uv,cuv);\n    drawMeteors(col,cuv);\n    mountain(col,uv,cuv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ds3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 44, 44, 162], [164, 164, 184, 184, 255], [257, 257, 277, 277, 364], [366, 366, 385, 385, 460], [462, 462, 485, 485, 702], [704, 704, 727, 727, 1131], [1133, 1133, 1154, 1154, 1382], [1384, 1384, 1403, 1403, 1629], [1631, 1631, 1678, 1678, 1900], [1902, 1902, 1945, 1945, 2228], [2230, 2230, 2273, 2273, 2389], [2392, 2392, 2473, 2473, 3042], [3045, 3045, 3086, 3086, 3326], [3329, 3329, 3386, 3436, 3780]], "test": "ok"}
{"id": "3ds3Wn", "name": "Strangered Land", "author": "DanilShekarev", "description": "Shader uses technology SDF. This is my first shader. Created it at random. I did not even expect to create something beautiful. Mouse control!", "tags": ["landscape", "strange", "ground", "land"], "likes": 1, "viewed": 93, "published": "Public", "date": "1545749648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 2048.0;\nconst float EPSILON = 0.0001;\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    float inOutRadius = length(p.xy) - r;\n    float inOutHeight = abs(p.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\t\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float sc = sphereSDF(samplePoint - vec3(0,0,0.0), 5.0);\n    \n    float d = (samplePoint.y+2.0);\n    \n    float time = sin(iTime);\n    \n    float x = samplePoint.x;\n    float y = samplePoint.y;\n    float z = samplePoint.z - iTime*5.0;\n    \n    return d + ((noise(vec2(x*0.1,z*0.1))*10.0)) + noise(vec2(x*0.01,z*0.01))*80.0 + noise(vec2(x,y));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(20.0,20.0,20.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0,\n                          2.0,\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(60.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(20.0, 20.0, 20.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(iMouse.x/50.0, iMouse.y/50.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(worldDir.y, 0.0, 0.0, 1.0);\n\t\treturn;\n    }\n   \n    vec3 p = eye + dist * worldDir;\n    \n    float r = max((p.y+30.0)/50.0,0.0);\n    \n    vec3 col = vec3(r,r,(-p.y-10.0)/50.0 + r*2.0);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ds3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 154, 154, 301], [303, 303, 330, 330, 477], [479, 479, 506, 506, 653], [655, 655, 701, 701, 733], [735, 735, 777, 777, 809], [811, 811, 858, 858, 891], [893, 893, 926, 926, 1120], [1122, 1122, 1156, 1156, 1184], [1186, 1186, 1231, 1231, 1508], [1510, 1510, 1530, 1530, 1597], [1600, 1600, 1621, 1621, 1820], [1822, 1822, 1856, 1856, 2204], [2206, 2206, 2297, 2297, 2603], [2617, 2617, 2682, 2682, 2814], [2816, 2816, 2845, 2845, 3155], [3157, 3157, 3297, 3297, 3726], [3728, 3728, 3813, 3813, 4496], [4498, 4498, 4547, 4547, 4678], [4680, 4680, 4737, 4737, 5369]], "test": "ok"}
{"id": "3dsGR7", "name": "Phased Array Reflection", "author": "wyatt", "description": "rory618 taught me about phased arrays. This is a simulation of a phased array detecting a single point. On a warship they emit microwave radiation and detect many point sources with a detection phased array and are able to reconstruct an image of enemies", "tags": ["phasedarray"], "likes": 5, "viewed": 452, "published": "Public API", "date": "1545855994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    float s = 0.,sp = 0.;\n    for (float i = -30.; i < 30.; i++) {\n        vec2 c = vec2(0.8,0.5)*R + vec2(1,2.*i);\n        float r = length(U-c);\n        vec2 obj = vec2(0.2+0.1*sin(iTime),0.48+0.1*cos(iTime))*R;\n       \tfloat r2 = length(obj-c)+length(obj-U);\n    \ts += sin (r + float(i)*sin(iTime) -10.*iTime)*exp(-.01*i*i)/r/r;\n    \tsp += max(0.,dot(normalize(obj-c),normalize(obj-U)))*sin (r2 + float(i)*sin(iTime) -10.*iTime)*exp(-.001*i*i)/r2/r2;\n    }\n    \n    \n    Q = 0.5+0.5*(sin(log(1.+5e-1*log(1.+5e4*max(0.,sp+s)))*vec4(1,2,3,4)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 618]], "test": "ok"}
{"id": "3dsGzn", "name": "[SH17Abis] crowded gyros (279ch)", "author": "FabriceNeyret2", "description": "Can it be smaller ?\nmore golfing of [url]https://shadertoy.com/view/ldBBDh[/url]\nultra simplification of [url]https://www.shadertoy.com/view/XtlXRB[/url]\nwhich was compact simplified version of [url]https://www.shadertoy.com/view/MllXz7[/url]", "tags": ["3d", "raymarching", "2tweets", "short", "spheremarching", "golf"], "likes": 5, "viewed": 346, "published": "Public API", "date": "1544733052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// more golfing of \"[SH17A] crowded gyros\" by FabriceNeyret2. https://shadertoy.com/view/ldBBDh\n// + now scaling with window size\n\n// new simplification of https://www.shadertoy.com/view/XtlXRB\n// compact simplified version of https://www.shadertoy.com/view/MllXz7 (773 chars)\n// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float j, x = iTime;\n    vec3 p = vec3(u/iResolution.y,0)-.5, d, t, a;\n    p.x -=.4; d = p; p.z += 5.*x;\n    for( o++; o.x>0. && x>.01 ; o-=.01 ) {\n        t = mod(p,8.) - 4.;\n        for( j=3.; j>.8; j-=.4 )\n            t.zy *= mat2(sin(iTime+vec4(0,11,33,0))),\n            a = abs(t),\n            x = min(x, max( max(a.x,max(a.y,a.z)) -j*.8,\n                            abs(length(t)-j)));\n        p -= d*x;\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsGzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 399, 399, 821]], "test": "ok"}
{"id": "3dX3zn", "name": "FBM Toy", "author": "CyanSprite", "description": "Glitch, static, cloud/water like things", "tags": ["noise", "fbm"], "likes": 9, "viewed": 328, "published": "Public", "date": "1544648709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float speed = 2.0;\nfloat brightness = 1.7;\n\nfloat rand(in vec2 p, float speed)\n{\n    float t = speed > 0.0 ? floor(iTime * speed) : 1.0;\n    return fract(\n        sin(\n            dot(p, vec2(t * 67.0, t * 76.0))\n        ) * 67.76\n    );\n}\n\nfloat noise(in vec2 uv, float block)\n{   \n    vec2 fr = fract(uv);\n    vec2 op = floor(uv);\n\n    // here you don't have to add vec2(0,0) but... consistency\n    float a = rand(op+vec2(0,0), block);\n    float b = rand(op+vec2(1,0), block);\n    float c = rand(op+vec2(0,1), block);\n    float d = rand(op+vec2(1,1), block);\n\n\t// u = step(block, lv);\n    // you can use step above if you want complete blockiness.\n    vec2 u;\n    if ( block > 0.0 )\n        u = smoothstep(0.0, 1.0 + block, fr);\n    else\n        u = fr * fr * (3.0 - 2.0 * fr);\n\n    // just mix a bunch of values up.\n   return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec2 uv, int octaves, float block)\n{\n    // In this case just how narrow do you want the glitch lines.\n    float lacunarity = 10.0;\n    \n    // how much increase in amplitude each octave\n    float gain = 0.5;\n\n    // our ending value, and amplitude\n    float v = 0.0;\n    float amp = 0.5;\n\n    // loop for octaves\n    for ( int i = 0; i < octaves; i++ ) \n    {\n    \tv += amp * noise(uv, block);\n        amp *= gain;\n        uv *= lacunarity;    \n    }\n    \n    return v;\n}\n\nvec4 glitch(in vec2 uv, vec2 uv2)\n{\n    const float amp = 0.2;\n    const float block = 10.0;\n    const float reducer = 9.0;\n    const int octaves = 4;\n    \n    float shift = amp * pow(\n        fbm(uv2,\n            octaves,\n            block\n        ),\n        reducer);\n    \n    float colR = texture(iChannel0, vec2(uv.x - shift, uv.y)).r * (1. - shift);\n    float colG = texture(iChannel0, vec2(uv.x + shift, uv.y)).g * (1. - shift);\n    float colB = texture(iChannel0, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n    \n    vec3 f = vec3(colR, colG, colB);\n    //f = vec3(noise(uv, glitchBlockiness));\n    \n    return vec4(f, 1.);\n}\n\nfloat getTime() { return iTime * 0.5 * speed; }\n\nfloat fbm2(in vec2 uv, int octaves)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(22.0);\n    \n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    \n    for (int i = 0; i < octaves; ++i) {\n        v += a * noise(uv, -2.0);\n        uv = rot * uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\n// Noise inception\nvec4 smoke(vec2 uv2, int octaves)\n{\n    vec3 color = vec3(0.0);\n\tvec2 q = vec2(0.);\n\tvec2 r = vec2(0.);\n    \n    // first fbm vec\n    q.x = fbm2(uv2 + 0.01 * getTime() * vec2(0.10), octaves);\n    q.y = fbm2(uv2 + 0.1 * getTime() * vec2(-0.50) , octaves);\n\n    // 2nd fbm vec + 1 fbm vec\n    r.x = fbm2(uv2 + 2.1*q + vec2(0.0, 1.0) * 0.1*sin(getTime()), octaves);\n    r.y = fbm2(uv2 + 3.0*q + vec2(1.0, 0.0) * 0.1*sin(getTime()), octaves);\n\n    // float of an 2nd fbm vec containing 1st fbm vec\n    float f = fbm2(uv2+r, octaves);\n\n    vec3 c1 = vec3(1.0, 0.2, 0.4);\n    vec3 c2 = vec3(0.0, 0.0, 0.3);\n    vec3 c3 = vec3(0.0, 0.5, 0.45);\n    vec3 c4 = vec3(0.4, 0.4, 0.4);\n\n    color = mix(c2,\n                c1,\n                clamp((f*f),0.0,1.0));\n\n    color = mix(color,\n                c3,\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                c4,\n                clamp(length(r.x),0.0,1.0));\n\n    return vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 a = vec2(uv.x * aspect , uv.y);\n    vec2 uv2 = vec2(a.x / iResolution.x, exp(a.y));\n    \n    fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n    // fragColor = glitch(uv, uv2);\n    \n    fragColor = fragColor + smoke(uv*2.5, 3) * brightness;\n    \n    fragColor = 2.0 * brightness * smoke(uv*2.5, 5) - fragColor;\n    \n    fragColor = fragColor - smoke(uv *2.5, 10) * vec4(0.05, 0.15, 0.35, 1.0) * brightness * brightness;\n    fragColor = fragColor * vec4(sin(iTime * .001), cos(iTime * .01), 1.0, 1.0);\n    fragColor = fragColor * vec4(1.5, 1.5, 1.5, 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dX3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 80, 80, 239], [241, 241, 279, 279, 921], [923, 950, 996, 1062, 1432], [1434, 1434, 1469, 1469, 2066], [2068, 2068, 2085, 2085, 2115], [2117, 2117, 2154, 2154, 2470], [2472, 2491, 2526, 2526, 3469], [3472, 3472, 3529, 3529, 4175]], "test": "error"}
{"id": "3sf3D8", "name": "uroboros 4", "author": "morisil", "description": "experiments with math behind the perspective", "tags": ["endless", "loop", "dots", "perspective"], "likes": 2, "viewed": 347, "published": "Public API", "date": "1545934770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 20.0\n\n// negative speed = moving backwards \n#define SPEED 5.0\n\n#define DOT_SHARPNESS 15.0\n\n#define AIR_PERSPECTIVE 3.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (fragCoord -.5 * iResolution.xy) / iResolution.y;    \n    vec2 trans = vec2(pixel.x / pixel.y, -1.0 / pixel.y);\n    trans *= SCALE;\n    float value = cos(trans.x);\n    value += cos(trans.y + iTime * SPEED);\n    value = (value + 2.0) / 4.0;\n    value = pow(value, DOT_SHARPNESS);\n    // apply air perspective\n    value *= pow(abs(pixel.y), AIR_PERSPECTIVE) * 30.0;\n    fragColor = vec4(vec3(value),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sf3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 189, 189, 611]], "test": "ok"}
{"id": "3sfGWH", "name": "weird_tunnel", "author": "CynicRus", "description": "just experiment with shader:)", "tags": ["tunnel"], "likes": 0, "viewed": 54, "published": "Public", "date": "1545940308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 p = (fragCoord.xy / iResolution.xy - 0.8);\nfloat z=1./length(p.xy);\np = p * z - vec2(z+2.*mod(iTime * 1.2,33.),.1);\nfloat a=atan(p.x,p.y)+sin(p.y+z);\nfragColor=2.*abs(5.2*sin(p.x*3.+z*0.6)+sin(p.x+a*0.44)*p.xyxx*sin(vec4(a,z,z,z)))+(z-4.)*.01;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 308]], "test": "ok"}
{"id": "3sl3DH", "name": "Black, Iridescent, Liquid", "author": "spsherk_", "description": "began with 2D clouds by Drift", "tags": ["procedural", "fractal", "noise"], "likes": 4, "viewed": 219, "published": "Public", "date": "1546063985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float cloudscale = 2.1;\nconst float speed = .20;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.7;\nconst float cloudalpha = 10.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.8, 0.1, 1.6);\nconst vec3 skycolour2 = vec3(0.4, 1.1, 1.0);\n\nconst mat2 m = mat2( 1.9,  1.2, -1.2,  0.9 );\n\nvec2 hash( vec2 p ) {\n    p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    vec2 i = floor(p + (p.x+p.y)*K1);   \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));  \n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 0.5;\n    for (int i = 0; i < 7; i++) {\n        total += noise(n) * amplitude;\n        n = m * n;\n        amplitude *= 0.9;\n    }\n    return total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n    float r = 0.0;\n    uv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n        r += abs(weight*noise( uv ));\n        uv = m*uv + time;\n        weight *= 0.7;\n    }\n    \n    //noise shape\n    float f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    uv *= cloudscale;\n    uv -= q - time;\n    weight = 0.9;\n    for (int i=0; i<8; i++){\n        f += weight*noise( uv );\n        uv = m*uv + time;\n        weight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    uv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n        c += weight*noise( uv );\n        uv = m*uv + time;\n        weight *= .6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    uv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.1;\n    for (int i=0; i<7; i++){\n        c1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n        weight *= 0.2;\n    }\n    \n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, (p.x + p.y) * .7);\n    vec3 cloudcolour = vec3(9.10, 0.0, 0.0) * clamp((clouddark + cloudlight*c), 0.0, 0.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 0.0), clamp(f + c, 0.0, 1.0));\n    \n    fragColor = vec4( result, 1.0 );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sl3DH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 340, 361, 361, 480], [482, 482, 508, 508, 1044], [1046, 1046, 1065, 1065, 1249], [1303, 1303, 1360, 1360, 3070]], "test": "ok"}
{"id": "3sl3R8", "name": "Black Hole Sun", "author": "gabbalis", "description": "Just some fun math art.", "tags": ["art"], "likes": 0, "viewed": 73, "published": "Public", "date": "1544943222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool inegraph(float x, float y, float width, float eq){\n    if ((eq+width>=y) || (eq>=y-width && eq<=y+width)){\n        return true;\n    }\n    return false;\n}\nbool graph(float x, float y, float width, float eq){\n    if ((eq+width>=y && eq-width<=y) || (eq>=y-width && eq<=y+width)){\n        return true;\n    }\n    return false;\n}\n\n//rand Taken from stackoverflow.com/questions/4200224\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n\n    // Time varying pixel color\n    float x = uv.x;\n    float y = uv.y;\n\n    float equation;\n\n    //black hole sun~\n    bool draw1 = (pow(x-0.5,2.)+pow(y-0.5,2.)<=pow(.1+sin(0.32+sin(iTime*4.3))/400.,2.));\n    //ocean\n    equation = (0.125*sin(8.0*x))*(1./3.)*sin(iTime)+0.20;\n    bool draw2 = inegraph(x, y, .002, equation);\n    //static rain\n    bool draw3 = int(x*1000.+rand(vec2(x+iTime,y)))%int(6.*sin(.3+sin(iTime))+10.) == 2;\n    \n    if (draw1 || draw2 || draw3){\n        fragColor = vec4(0.0);\n    }\n    else{\n        fragColor = vec4(1.0);\n    }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sl3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 158], [159, 159, 211, 211, 329], [331, 385, 405, 405, 477], [479, 479, 536, 586, 1186]], "test": "ok"}
{"id": "3sl3zH", "name": "slowfont", "author": "Del", "description": "slow font render (SDF)", "tags": ["raymarch", "sdf", "font", "slow", "dirty"], "likes": 4, "viewed": 414, "published": "Public API", "date": "1544980192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Very slow code font, handy for prototyping ideas... (A-Z only)\n//\n// Anyone got any optimizations?\n\n#define PI 3.14159\n#define\tTAU 6.28318\n\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time)\n{\n    vec2 mouse2 = vec2(sin(time*0.25)*0.1, 0.6+((0.5+sin(time) * 0.5)*0.5)*2.8);\n    float an = 7.0*mouse2.x;\n    camPos = vec3(24.5*sin(an),mouse2.y*8.0,24.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\t\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opUnionRound(const in vec2 a, const in vec2 b, const in float r)\n{\n    vec2 res = vec2(smin(a.x,b.x,r),(a.x<b.x) ? a.y : b.y);\n    return res;\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n#define CHS 1.0\n// 2d box for font\nfloat sdBox2(in vec2 p,in vec2 b) {vec2 d=abs(p)-b;return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);}\n// 2d line for font\nfloat line2(float d,vec2 p,vec4 l){vec2 pa=p-l.xy;vec2 ba=l.zw-l.xy;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return min(d,length(pa-ba*h));}\n// font, optimized with mirroring etc.\nfloat LR(vec2 p, float d){p.x=abs(p.x);return line2(d,p,vec4(2,-3.25,2,3.25)*CHS);}\nfloat TB(vec2 p, float d){p.y=abs(p.y);return line2(d,p,vec4(2,3.25,-2,3.25)*CHS);}\nfloat TBLR(vec2 p, float d){return min(d,abs(sdBox2(p,vec2(2,3.25)*CHS)));}\nfloat A(vec2 p,float d){d=LR(p,d);p.y=abs(p.y-1.5*CHS);return line2(d,p,vec4(2,1.75,-2,1.75)*CHS);}\nfloat B(vec2 p,float d){p.y+=1.75*CHS;d=min(d,abs(sdBox2(p,vec2(2.0,1.5)*CHS)));p+=vec2(0.5,-3.25)*CHS;return min(d,abs(sdBox2(p,vec2(1.5,1.75)*CHS)));}\nfloat C(vec2 p,float d){d=TB(p,d);return line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);}\nfloat D(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(2,-1,2,1)*CHS);p.y=abs(p.y);d=line2(d,p,vec4(2,1,1.5,2.75)*CHS);d=line2(d,p,vec4(1.5,2.75,1,3.25)*CHS);return line2(d,p,vec4(1,3.25,-2,3.25)*CHS);}\nfloat E(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);return line2(d,p,vec4(0,-0.25,-2,-0.25)*CHS);}\nfloat F(vec2 p,float d){d=line2(d,p,vec4(2,3.25,-2,3.25)*CHS);d=line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);return line2(d,p,vec4(0,-0.25,-2,-0.25)*CHS);}\nfloat G(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(2,2.25,2,3.25)*CHS);d=line2(d,p,vec4(2,-3.25,2,-0.25)*CHS);return line2(d,p,vec4(2,-0.25,0.5,-0.25)*CHS);}\nfloat H(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(-2,-0.25,2,-0.25)*CHS);}\nfloat I(vec2 p,float d){d=line2(d,p,vec4(0,-3.25,0,3.25)*CHS);p.y=abs(p.y);return line2(d,p,vec4(1.5,3.25,-1.5,3.25)*CHS);}\nfloat J(vec2 p,float d){d=line2(d,p,vec4(-1.5,-3.25,0,-3.25)*CHS);d=line2(d,p,vec4(0,-3.25,1,-2.25)*CHS);d=line2(d,p,vec4(1,-2.25,1,3.25)*CHS);return line2(d,p,vec4(1,3.25,-1.5,3.25)*CHS);}\nfloat K(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(-2,-0.25,-0.5,-0.25)*CHS);d=line2(d,p,vec4(2,3.25,-0.5,-0.25)*CHS);return line2(d,p,vec4(-0.5,-0.25,2,-3.25)*CHS);}\nfloat L(vec2 p,float d){d=line2(d,p,vec4(2,-3.25,-2,-3.25)*CHS);return line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);}\nfloat M(vec2 p,float d){p.x=abs(p.x);d=line2(d,p,vec4(2,-3.25,2,3.25)*CHS);return line2(d,p,vec4(0,0.75,2,3.25)*CHS);}\nfloat N(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(-2,3.25,2,-3.25)*CHS);}\nfloat O(vec2 p,float d){return TBLR(p,d);}\nfloat P(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,0.0)*CHS);p.y-=1.5*CHS;return min(d,abs(sdBox2(p,vec2(2.0,1.75)*CHS)));}\nfloat Q(vec2 p,float d){d=TBLR(p,d);return line2(d,p,vec4(2,-3.25,0.5,-1.75)*CHS);}\nfloat R(vec2 p,float d){d=line2(d,p,vec4(0.5,-0.25,2,-3.25)*CHS);d=line2(d,p,vec4(-2,-3.25,-2,0.0)*CHS);p.y-=1.5*CHS;return min(d, abs(sdBox2(p,vec2(2.0,1.75)*CHS)));}\nfloat S(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,3.25,-2,-0.25)*CHS);d=line2(d,p,vec4(-2,-0.25,2,-0.25)*CHS);return line2(d,p,vec4(2,-0.25,2,-3.25)*CHS);}\nfloat T(vec2 p,float d){d=line2(d,p,vec4(0,-3.25,0,3.25)*CHS);return line2(d,p,vec4(2,3.25,-2,3.25)*CHS);}\nfloat U(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(2,-3.25,-2,-3.25)*CHS);}\nfloat V(vec2 p,float d){p.x=abs(p.x);return line2(d,p,vec4(0,-3.25,2,3.25)*CHS);}\nfloat W(vec2 p,float d){p.x=abs(p.x);d=line2(d,p,vec4(2,-3.25,2,3.25)*CHS);return line2(d,p,vec4(0,-1.25,2,-3.25)*CHS);}\nfloat X(vec2 p,float d){d = line2(d,p,vec4(-2,3.25,2,-3.25)*CHS);return line2(d,p,vec4(-2,-3.25,2,3.25)*CHS);}\nfloat Y(vec2 p,float d){d=line2(d,p,vec4(0,-0.25,0,-3.25)*CHS);p.x=abs(p.x);return line2(d,p,vec4(0,-0.25,2,3.25)*CHS);}\nfloat Z(vec2 p,float d){d=TB(p,d);return line2(d,p,vec4(-2,-3.25,2,3.25)*CHS);}\n\nfloat message(vec3 p)\n{\n    \n\tfloat d = 200.0;\n    float cw = 5.8*CHS;\n    float gap = (cw*2.0)+20.0;\n    float width = (26.0*cw);\n    float xmod = width+gap;\n    \n\tfloat c = pMod1(p.z,12.0);\n\tif (c > 0.0)\t// || p.z > 10.0 || p.z < -10.0)\n        return d;\n    pMod1(p.y,12.0);\n    p.y += 4.0;\n    p.z += 4.0;\n    \n\tp.x += fract(iTime*0.075)*xmod+c*10.0;\n    pMod1(p.x, xmod);\n    p.x -= gap*0.5;\n\n\tfloat t1 = fract(iTime*0.7) * TAU;\n\n\tp.y -= sin(t1+p.x*0.25)*0.7;\n    \n    \n\t//float d2 = sdBox(p+vec3((gap*0.5)-cw,-2.5,0.0),vec3((width*0.5),5.5*CHS,0.8));\n    //if (d2>11.0)\n    //    return d;\n\t\n\tvec2 uv = p.xy + vec2(((width*0.5+gap*0.5)-cw)-cw*0.5, -3.0);\n\t\n\td = A(uv,d); uv.x -= cw;\n\td = B(uv,d); uv.x -= cw;\n\td = C(uv,d); uv.x -= cw;\n\td = D(uv,d); uv.x -= cw;\n\td = E(uv,d); uv.x -= cw;\n\td = F(uv,d); uv.x -= cw;\n\td = G(uv,d); uv.x -= cw;\n\td = H(uv,d); uv.x -= cw;\n\td = I(uv,d); uv.x -= cw;\n\td = J(uv,d); uv.x -= cw;\n\td = K(uv,d); uv.x -= cw;\n\td = L(uv,d); uv.x -= cw;\n\td = M(uv,d); uv.x -= cw;\n\td = N(uv,d); uv.x -= cw;\n\td = O(uv,d); uv.x -= cw;\n\td = P(uv,d); uv.x -= cw;\n\td = Q(uv,d); uv.x -= cw;\n\td = R(uv,d); uv.x -= cw;\n\td = S(uv,d); uv.x -= cw;\n\td = T(uv,d); uv.x -= cw;\n\td = U(uv,d); uv.x -= cw;\n\td = V(uv,d); uv.x -= cw;\n\td = W(uv,d); uv.x -= cw;\n\td = X(uv,d); uv.x -= cw;\n\td = Y(uv,d); uv.x -= cw;\n\td = Z(uv,d);\n\n    d-=0.25*CHS;\t// char thickness...\n\n\tif (d<200.0)\n\t{\n\t\t// extrude\n\t\tfloat dep = 0.3;\n\t\tvec2 e = vec2( d, abs(p.z) - dep );\n\t\td = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n\t\td -= 0.425*CHS;\t\t// rounding\n\t\t// rounding-wibble... :)\n\t\td-=  sin(t1+(p.x*0.05))*0.15;\n\t}\n    //d = min(d,d2);\n\treturn d;\n}\n\nvec2 doModel( vec3 p )\n{\n    float d2 = 10.0;\t//sdPlane(p-vec3(0.0,-1.8,0.0));\t\t// checkered floor distance...\n    float dm = message(p);\n    vec2 res = vec2(d2,0.0);\t\t\t// distance,material index\n    res = opUnionRound(res,vec2(dm,4.0),0.5);\t\n    return res;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal.\n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\n// c.a == specular val fudged in...\nvec4 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=1.0)\n    {\n        // checker floor\n\t\tfloat f = mod( floor(0.125*pos.z) + floor(0.125*pos.x), 2.0) + 0.35;\n        return f*vec4(0.331,0.725,0.951,0.0)*0.6;\t    \n    }\n    return vec4(hsv2rgb_smooth(vec3((pos.x*1.25+(pos.y*0.5))*0.0075,0.95,1.0))*0.5, 1.7);\n    \n    //return vec4(1.0,1.0,1.0,1.7);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mat )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.7,0.875,0.89));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(1.00,1.00,1.00)*sha;\n    float spec = pow(dif, 160.0) *mat.a;\n    \n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mat.xyz*lin;\n    col+=spec;\n    \n    // fog    \n    //-----------------------------\n    col *= exp(-0.0001*dis*dis);\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 160.0;           // max trace distance\n    const float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<60; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        t += h;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.001;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n    vec3 col = mix( vec3(0.2, 0.2, 0.2), vec3(0.0, 0.0, 0.1), fragCoord.y / iResolution.y )*0.4;\n\n    // raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mat = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mat );\n    }\n\n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------\n    // gamma\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    \n    fragColor = vec4(col,1.);\t\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sl3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 303, 368, 368, 571], [738, 738, 763, 763, 781], [783, 783, 814, 814, 905], [908, 908, 949, 949, 1042], [1195, 1370, 1410, 1410, 1531], [1549, 1568, 1603, 1603, 1674], [1675, 1695, 1730, 1730, 1839], [1840, 1879, 1905, 1905, 1962], [1963, 1963, 1989, 1989, 2046], [2047, 2047, 2075, 2075, 2122], [2123, 2123, 2147, 2147, 2222], [2223, 2223, 2247, 2247, 2375], [2376, 2376, 2400, 2400, 2456], [2457, 2457, 2481, 2481, 2685], [2686, 2686, 2710, 2710, 2806], [2807, 2807, 2831, 2831, 2955], [2956, 2956, 2980, 2980, 3153], [3154, 3154, 3178, 3178, 3234], [3235, 3235, 3259, 3259, 3358], [3359, 3359, 3383, 3383, 3548], [3549, 3549, 3573, 3573, 3745], [3746, 3746, 3770, 3770, 3856], [3857, 3857, 3881, 3881, 3975], [3976, 3976, 4000, 4000, 4055], [4056, 4056, 4080, 4080, 4098], [4099, 4099, 4123, 4123, 4224], [4225, 4225, 4249, 4249, 4308], [4309, 4309, 4333, 4333, 4476], [4477, 4477, 4501, 4501, 4636], [4637, 4637, 4661, 4661, 4743], [4744, 4744, 4768, 4768, 4824], [4825, 4825, 4849, 4849, 4906], [4907, 4907, 4931, 4931, 5027], [5028, 5028, 5052, 5052, 5138], [5139, 5139, 5163, 5163, 5259], [5260, 5260, 5284, 5284, 5339], [5341, 5341, 5364, 5364, 6971], [6973, 6973, 6997, 6997, 7233], [7235, 7235, 7269, 7269, 7451], [7453, 7836, 7889, 7889, 8201], [8414, 8414, 8498, 8498, 9163], [9165, 9165, 9214, 9214, 9763], [9765, 9765, 9797, 9797, 10217], [10219, 10219, 10267, 10267, 10695], [10697, 10697, 10761, 10761, 10939], [10941, 10941, 10998, 10998, 12314]], "test": "error"}
{"id": "3slGD8", "name": "Conjulia (Tricorn julia)", "author": "Pork", "description": "Conjulia - A tricorn where C is a constant (julia vriant)", "tags": ["fractal"], "likes": 0, "viewed": 321, "published": "Public API", "date": "1546023075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cmul (vec2 c1, vec2 c2)\n{\n\tfloat a = c1.x;\n\tfloat b = c1.y;\n\tfloat c = c2.x;\n\tfloat d = c2.y;\n\n\treturn vec2 (a * c - b * d, b * c + a * d);\n}\n\nfloat cabs (in vec2 complex)\n{\n\tfloat x = complex.x;\n\tfloat y = complex.y;\n\n\treturn sqrt(x*x + y*y);\n}\n\n//Based on explanation http://www.hiddendimension.com/fractalmath/Divergent_Fractals_Main.html\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = fragCoord.xy / iResolution.xy;\n    //scaling real axis to [-2.5, 1.5] and  imaginary axis to  [-1.5, 1.5]\n    c = c * vec2(4.7,3.5) - vec2(2.5, 1.7); \n\n    vec2 z = c;\n    fragColor = vec4(0);\n    \n    int i = 0;\n    for (;i<100;i++)\n    {\n        if (cabs(z) >= 4.) \n        {\n            break;\n        }\n        \n       z.y = -z.y;\n       z = cmul(z, z);\n       z += vec2(sin(iTime)/2.);\n    }\n    fragColor = vec4(i)/100.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slGD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 146], [148, 148, 178, 178, 250], [252, 347, 404, 404, 846]], "test": "ok"}
{"id": "3slGRH", "name": "alien shield", "author": "morisil", "description": "Quite accidental creation, but I like the achieved pseudo 3d illusion.", "tags": ["procedural", "spiral", "illusion", "pseudo3d", "hypnotic", "polar"], "likes": 21, "viewed": 1205, "published": "Public API", "date": "1545045566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 50.0\n// rotation speed, might be negative to spin counter-clockwise\n#define ROTATION_SPEED -1.0\n\n#define INTENSITY_PULSE_SPEED 1.3\n\nfloat getColorComponent(float dist, float angle, float scaleIncrement) {\n  return sin(\n      (dist * SCALE)\n      + angle\n      + (cos(dist * SCALE))\n      - (iTime * ROTATION_SPEED)\n  )\n      - dist * (2.3 + sin(iTime * INTENSITY_PULSE_SPEED))\n      + 0.3;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(uv),\n    angle = atan(uv.x, uv.y);\n    fragColor = vec4(\n        getColorComponent(dist, angle, 0.0),\n        getColorComponent(dist * 0.99, angle - 0.05, 1.0),\n        getColorComponent(dist * 0.98, angle - 0.1, 2.0),\n        1.0\n    );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 218, 218, 405], [407, 407, 462, 462, 790]], "test": "ok"}
{"id": "3ss3R4", "name": "Polar Night", "author": "supervitas", "description": "Simple raymarching terrain, thanks nimitiz for aurora", "tags": ["raymarching", "terrain", "aurora", "winter"], "likes": 46, "viewed": 1584, "published": "Public", "date": "1545183972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: supervitas\n\n#define MAX_MARCHING_STEPS 256\n#define MAX_DIST 6. // far\n#define EPSILON 0.001\n#define PI 3.1415926535\n\n#define u_time iTime\n#define u_resolution iResolution\n\n\nfloat random(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  vec2 df = 20.0*f*f*(f*(f-2.0)+1.0);\n  f = f*f*f*(f*(f*6.-15.)+10.);\n\n  float a = random(i + vec2(0.5));\n  float b = random(i + vec2(1.5, 0.5));\n  float c = random(i + vec2(.5, 1.5));\n  float d = random(i + vec2(1.5, 1.5));\n\n  float k = a - b - c + d;\n  float n = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\n  return vec3(n, vec2(b - a + k * f.y, c - a + k * f.x) * df);\n}\n\nmat2 terrainProps = mat2(0.8,-0.4, 0.5,0.8);\nfloat fbmM(vec2 p) {\n  vec2 df = vec2(0.0);\n  float f = 0.0;\n  float w = 0.5;\n\n  for (int i = 0; i < 8; i++) {\n    vec3 n = noise(p);\n    df += n.yz;\n    f += abs(w * n.x / (1.0 + dot(df, df)));\n    w *= 0.5;\n    p = 2. * terrainProps * p;\n  }\n  return f;\n}\n\nfloat fbmH(vec2 p) {\n  vec2 df = vec2(0.0);\n  float f = 0.0;\n  float w = 0.5;\n\n  for (int i = 0; i < 12; i++) {\n    vec3 n = noise(p);\n    df += n.yz;\n    f += abs(w * n.x / (1.0 + dot(df, df)));\n    w *= 0.5;\n    p = 2. * terrainProps * p;\n  }\n  return f;\n}\n\n\nfloat fbmL(vec2 p) {\n  vec2 df = vec2(0.0);\n  float f = 0.0;\n  float w = 0.5;\n\n  for (int i = 0; i < 2; i++) {\n    vec3 n = noise(p);\n    df += n.yz;\n    f += abs(w * n.x / (1.0 + dot(df, df)));\n    w *= 0.5;\n    p = 2. * terrainProps * p;\n  }\n  return f;\n}\n\n\n\nfloat map(vec3 p) {\n    float scene = p.y;\n    \n    float h = fbmM(p.xz);\t\n    scene -= h;\n\n  \treturn scene;\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd) {\n  float d = 0.;\n  float t = 0.;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    d = map(ro + t * rd);\n    if (d < EPSILON * t || t > MAX_DIST) break;\n    t += 0.5 * d;\n  }\n\n  return d < EPSILON * t ? t : -1.;\n}\n\nvec3 normal(vec3 pos, float t) {\n\tvec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( fbmH(pos.xz-eps.xy) - fbmH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            fbmH(pos.xz-eps.yx) - fbmH(pos.xz+eps.yx) ) );\n}\n\nstruct light {\n  vec3 lightPosition;\n  vec3 amibnetColor;\n  float ambientIntencity;\n  vec3 directLightColor;\n  vec3 directLightIntencity;\n};\n\nvec3 diffuseLight(vec3 k_d, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {\n  vec3 N = normal(p, 0.01);\n  vec3 L = normalize(lightPos - p);\n\n  float dotLN = dot(L, N);\n\n  if (dotLN < 0.0) {\n    return vec3(0.0, 0.0, 0.0);\n  }\n\n  return lightIntensity * (k_d * dotLN);\n}\n\nvec3 calcLights(light data, vec3 p, vec3 eye) {\n  vec3 ambientColor = data.ambientIntencity * data.amibnetColor;\n  vec3 phongColor = diffuseLight(data.directLightColor, p, eye, data.lightPosition, data.directLightIntencity);\n\n  return ambientColor + phongColor;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = cross(ww, rr);\n  vec3 vv = cross(uu, ww);\n\n  return mat3(uu, vv, ww);\n}\n\nvoid setColor(vec3 p, vec3 n, out vec3 color) {\n  float a = smoothstep(0.440 * n.y, 0.816 * n.y, fbmM(p.xz));\n  vec3 ground = vec3(0.046,0.043,0.100);\n  color = mix(vec3(1.), ground, a);  \n}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat fbmAurora(vec2 p, float spd) {\n    float z = 1.8;\n    float z2 = 2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x * 0.06);\n    vec2 bp = p;\n\tfor (float i = 0.; i < 5.; i++ ) {\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(u_time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= sin(u_time * 0.05) * cos(u_time * 0.01);\n\t}\n    return clamp(1. / pow(rz * 20., 1.3), 0.,1.);\n}\n\n\nvec4 aurora( vec3 rd) {\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);    \n\n    for (float i=0.; i < 50.; i++) {\n        float of = 0.006*random(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)) / (rd.y * 2. + 0.4);\n        pt -= of;\n    \tvec3 bpos = 5.5 + pt * rd;\n        vec2 p = bpos.zx;\n        float rzt = fbmAurora(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2) +i * 0.043) * 0.5 + 0.5)*rzt;\n        avgCol = mix(avgCol, col2, .5);\n        col += avgCol * exp2(-i*0.065 - 2.5) * smoothstep(0., 5., i);\n    }\n    col *= (clamp(rd.y*15.+.4,0.,1.));\n \n    return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n}\n\nvec3 stars(vec2 p) {\n    float r = fbmL(p * 20.  );\n    float isStar = step(0.707, r);\n    return vec3(r) * isStar;\n}\n\nvoid setSkyColor(vec2 uv, out vec3 color, vec3 dir) {\n   color = mix(vec3(0.006,0.026,0.095), vec3(0.007,0.011,0.035), uv.y);\n   color += stars(dir.xz / dir.y);\n   color += aurora(dir).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / u_resolution.xy;\n  vec2 p = (-u_resolution.xy + 2.0 * gl_FragCoord.xy) / u_resolution.y;\n\n  float speed = 0.002;\n  float terrainEndTime = abs(sin(u_time * speed));\n  vec3 ro = vec3(mix(0., 100., terrainEndTime), 1.2, mix(0., 100., terrainEndTime)); // cause endless will have problems with floats\n    \n  float minHeight = 0.2 + 1.1 * fbmL(ro.xz);\n  ro.y = minHeight;\n\n  float a = sin(u_time * speed * 2.);\t\n  vec3 target = ro + vec3(mix(0.9, 1.64, (sin(u_time * 0.25  ))),\n                          mix(-.1, .1, abs(sin(u_time * 0.125 + cos(u_time * 0.0125) ))),\n                          a); // revert camera when near to end\n  mat3 cam = calcLookAtMatrix(ro, target, 0.);\n  vec3 rd = cam * normalize(vec3(p.xy, 1.064));\n\n  vec3 color = vec3(0.0);\n  float scene = raymarch(ro, rd);\n  vec3 point = ro + scene * rd;\n  if (scene > -1.) {\n    light light1 = light(\n      ro + vec3(10., 150., 100.), // light position\n      vec3(0.931,0.975,0.906), 0.412, // ambient color - ambient intencity\n      vec3(0.254,1.000,0.777), vec3(0.162,0.555,0.560)); // direct light color - direct light intencity\n\n\n    vec3 nor = normal(point, scene);\n\n    setColor(point, nor, color);\n\n    color *= calcLights(light1, point, ro);\n  } else {\n    point = ro + scene * rd;\n    setSkyColor(uv, color, rd);\n  }\n\n  color = pow(color, vec3(1. / 2.2)); // gamma correction\n  color = smoothstep(0., 1.,color);\n\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4tl3z4", "previewfilepath": "https://soundcloud.com/dj-finao/sun", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dj-finao/sun", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ss3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 206, 206, 326], [329, 329, 349, 349, 765], [812, 812, 832, 832, 1069], [1071, 1071, 1091, 1091, 1329], [1332, 1332, 1352, 1352, 1589], [1593, 1593, 1612, 1612, 1703], [1706, 1706, 1740, 1740, 1956], [1958, 1958, 1990, 1990, 2212], [2356, 2356, 2439, 2439, 2633], [2635, 2635, 2682, 2682, 2898], [2900, 2900, 2961, 2961, 3130], [3132, 3132, 3179, 3179, 3322], [3324, 3324, 3345, 3345, 3397], [3398, 3398, 3420, 3420, 3462], [3463, 3463, 3484, 3484, 3534], [3536, 3536, 3572, 3572, 4031], [4034, 4034, 4057, 4057, 4728], [4730, 4730, 4750, 4750, 4847], [4849, 4849, 4902, 4902, 5040], [5042, 5042, 5099, 5099, 6542]], "test": "ok"}
{"id": "3ss3W4", "name": "Cyber Space Explained", "author": "Xor", "description": "Here's a requested explanation of my older shader: https://www.shadertoy.com/view/XlVSzh", "tags": ["3d", "voxels", "light", "glow"], "likes": 5, "viewed": 142, "published": "Public", "date": "1546285784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"Cyber Space Explained\" by Xor\n\n\tYou can see the original here: https://www.shadertoy.com/view/XlVSzh\n*/\n\nvoid mainImage(out vec4 Color,vec2 Coord)\n{\n    //Here is the camera ray vector. It has an approximate length of 2.\n    vec3 R = vec3(2, (Coord*2.-iResolution.xy)/iResolution.y);\n\n    //The color must be initialized on some machines. Color -= Color also works.\n    Color = vec4(0);\n    \n    //Loop through the z layers.\n    for (float Z = -8.; Z<8.; Z+=.1)\n    {\n        //Fade in and out near the z edges.\n        float Fade = 1.-Z*Z/64.;\n        \n        //Set a color and fade it.\n        vec4 Col = vec4(.3,.6,1,1) * Fade;\n        \n        //Calculate the ray position.\n        vec3 Pos = iTime*vec3(4,1,0)+(Z+14.)*R;\n        \n        //Get a voxel hash at the ray position using a simple hash.\n        float Hash = fract(3e2*cos(dot(floor(Pos),vec3(7,8,86))));\n        \n        //Filter all lower amplitude results out.\n        Col *= smoothstep(.99,1.,Hash);\n        \n        //Add to the final color.\n        Color += Col;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ss3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 153, 225, 1047]], "test": "ok"}
{"id": "3ssGR8", "name": "An attempt of real-time ray trac", "author": "zzzhhh", "description": "An attempt of real-time ray tracing using knowledge I learnt in the course \"Rendering and Shading\" which includes: Full GGX material, Separation of Direct Illumination and Indirect Illumination, Multiple Light Source Illumination.\n", "tags": ["raytracing", "realtime", "ggx"], "likes": 2, "viewed": 213, "published": "Public", "date": "1544931266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Play with the two following values to change quality.\n// You want as many samples as your GPU can bear. :)\n#define SAMPLES 16\n#define SUB_SAMPLES (SAMPLES/4)\n#define MAXDEPTH 6\n\n// Uncomment to see how many samples never reach a light source\n//#define DEBUG\n\n// Not used for now\n#define DEPTH_RUSSIAN 2\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define GGX_REFR 3\n#define GGX_DIFF 4\n#define NUM_SPHERES 14\n#define NUM_LIGHTS 4\n#define LIGHT_INDEX 8\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n    float roughness;\n};\n\n//Sphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF, 0.);//Left \n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF, 0.);//Rght \n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF, 0.);//Back\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF, 0.);//Frnt\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF, 0.);//Botm \n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF, 0.);//Top\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC, 0.);//Mirr\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR, 0.);//Glas \n\t//spheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);//Lite\n\t//spheres[8] = Sphere(1.5, vec3(50.,81.6 - 16.5,81.6),vec3(4.) * 100.,  vec3(0.), DIFF, 0.);//Lite\n\tspheres[8] = Sphere(2.,  vec3(20.,81.6 - 16.5,110), vec3(1.)*100., vec3(0.), DIFF, 0.);//Lite1\n\tspheres[9] = Sphere(1.5, vec3(80.,81.6 - 16.5,110), vec3(1.)*60., vec3(0.), DIFF, 0.);//Lite2\n\tspheres[10] = Sphere(1., vec3(20.,81.6 - 20.,40.),\tvec3(1.)*140., vec3(0.), DIFF, 0.);//Lite3\n\tspheres[11] = Sphere(1., vec3(80.,81.6 - 20.,40.),\tvec3(1.)*90., vec3(0.), DIFF, 0.);//Lite4\t\n\tspheres[12] = Sphere(12.5, vec3(50.,12.5,100.),     vec3(0.),vec3(1.,1.,1.)*.999,  GGX_REFR, 0.05); //GGX refractive\n  \tspheres[13] = Sphere(12.5, vec3(15.,12.5,90.),      vec3(0.),vec3(1.,1.,0.5)*.999, GGX_DIFF, 0.9);\t//GGX diffuse\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, eps = 1e-4, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > eps ? t : ((t = b + det) > eps ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 SpherCoord(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nfloat G1(in vec3 m, in vec3 s, in vec3 n, in float roughness) {\n\tif (dot(s,m)*dot(s,n) <= 0.) return 0.;\t//sidedness agreement\n\tfloat temp_a = dot(n,s);\n\tfloat a = temp_a / (roughness*sqrt(1. - temp_a*temp_a));\n\tfloat Lumbda = (-1. + sqrt(1. + 1. / (a*a))) / 2.;\n\treturn 1. / (1. + Lumbda);\n}\n\nfloat pmf[NUM_LIGHTS];\nfloat Ptotal = 0.;\nvoid PrecomputeMultipleLights() {\n\tfor (int i = LIGHT_INDEX; i < LIGHT_INDEX+NUM_LIGHTS; i++) {\n\t\tSphere s = spheres[i];\n\t\tfloat Pk = s.r*s.r*dot(vec3(0.2989,0.5870,0.1140), s.e);\n\t\tPtotal += Pk;\n\t\tpmf[i-LIGHT_INDEX]=Pk;\n\t}\n\tfor (int i = 0; i < NUM_LIGHTS; i++)\n\t\tpmf[i] /= Ptotal;\n}\n\nvec3 DirectIllum(in vec3 x, in vec3 f, in vec3 n, in int avoid) {\n    float rv = rand(), left = 0., right;\n\tint idx_obj;\n  \tSphere s;\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tright = left + pmf[i];\n\t\tif (left <= rv && rv < right) {\n    \t\tidx_obj = i + LIGHT_INDEX;\n      \t\ts = spheres[i + LIGHT_INDEX];\n\t\t\tbreak;\n        }\n        left = right;\n    }\n\n\tfloat t;                               // distance to intersection \n\tvec3 e=vec3(0.);\n\tvec3 sw = s.p - x;\n\tfloat cos_a_max = sqrt(1. - clamp(s.r*s.r / dot(sw,sw), 0., 1.));\n\tfloat eps1 = rand(), eps2 = rand();\n\tfloat cos_a = mix(1., cos_a_max, eps1);\n\tfloat sin_a = sqrt(1. - cos_a*cos_a);\n\tfloat phi = 2. * PI*eps2;\n  \tvec3 l = SpherCoord(sw, phi, sin_a, cos_a);\n\tif (intersect(Ray(x, l), t, s, avoid) == idx_obj) {  // shadow ray\n\t\tfloat omega = 2. * PI*(1. - cos_a_max);\n\t\te = f*clamp(dot(l,n),0.,1.)*omega/(s.r*s.r)*Ptotal;\n\t}\n\treturn e;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n    float E = 1.;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id=intersect(r, t, obj, id))<0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d)), f = obj.c, n_save = nl;\n\t\t//vec3 f = obj.c;\n\t\t//float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n\t\t//if (depth > DEPTH_RUSSIAN || p == 0.) if (rand() < p) f /= p; else { acc += mask * obj.e * E; break; }\n\t\tfloat p = f.x > f.y && f.x > f.z ? f.x : f.y > f.z ? f.y : f.z; // max refl \n\t\tif (depth > DEPTH_RUSSIAN) if (rand() < p) f /= p; else { acc += mask * obj.e * E; break; }\t\t\n\t\tbool into = dot(n,nl) > 0.;              // Ray from outside going in? \n\t\tif (obj.refl == DIFF) {\n\t\t\tfloat r2 = rand();\n\t\t\tvec3 d = SpherCoord(nl, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = DirectIllum(x,f/PI,nl,id);\n\t\t\tacc += mask * (obj.e * E + e);\n            E=0.;\n\t\t\tmask *= f;\n\t\t\tr = Ray(x, d);\n            continue;\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e*E;\n\t\t\tmask *= f;\n\t\t\tr = Ray(x, reflect(r.d, n));\n            E = 1.;\n            continue;\n\t\t} else if (obj.refl == GGX_REFR || obj.refl == GGX_DIFF) {\n\t\t\tfloat r1 = rand();\n\t\t\tfloat theta_m = atan(obj.roughness*sqrt(r1 / (1. - r1)));\n\t\t\tfloat phi_m = 2. * PI*rand();\n\t        vec3 m = SpherCoord(nl,phi_m,sin(theta_m), cos(theta_m));\n\t\t\tnl = m;\t\t\t\t//nl always faces r.d, as before\n\t\t\tn = into ? nl : nl*-1.;\t\t//now n and nl is colinear with m, with desired direction\n\t\t} \n\n        Ray reflRay=Ray(x, reflect(r.d, n));   // Ideal dielectric REFRACTION \n        float nc = 1., nt = 1.5, nnt = into ? nc / nt : nt / nc, ddn = dot(r.d,nl), cos2t;\n        if ((cos2t = 1. - nnt*nnt*(1. - ddn*ddn)) < 0.) {   // Total internal reflection \n            acc += mask * obj.e*E;\n            mask *= f;\n            E = 1.;\n            r = reflRay;\n            continue;\n        }\n        vec3 tdir = normalize(r.d*nnt - n*((into ? 1. : -1.)*(ddn*nnt + sqrt(cos2t))));\n        float a = nt - nc, b = nt + nc, R0 = a*a / (b*b), c = 1. - (into ? -ddn : dot(tdir,n));\n        float Re = R0 + (1. - R0)*c*c*c*c*c, Tr = 1. - Re, P = .25 + .5*Re, RP = Re / P, TP = Tr / (1. - P);\n        if (obj.refl == GGX_REFR || obj.refl == GGX_DIFF) {\n            float G = G1(nl, r.d*-1., n_save, obj.roughness)*G1(nl, reflRay.d, n_save, obj.roughness);\n            float weight_r = abs(dot(n,r.d) / (dot(n_save,r.d)*dot(n,n_save)))*G;\n            float temp1 = obj.roughness*obj.roughness;\n            float temp2 = dot(nl,n_save);\n            float temp3 = 1. + temp2*temp2*(temp1 - 1.);\n            float D = temp1 / (PI*temp3*temp3);\n            if (obj.refl == GGX_DIFF) {\n                vec3 F = f + (vec3(1.) - f)*c*c*c*c*c;   //f serves as F0 here\n                vec3 fr = F*G*D/(4. * abs(dot(n_save,r.d)*dot(n_save,reflRay.d)));\t//BRDF\n                vec3 e = DirectIllum(x,fr,n_save,id)*1.7;\n                acc += mask * (obj.e * E + e);\n                mask *= F*weight_r;\n                r = reflRay;\n                E=0.;\n                continue;\n            }\n            vec3 fr = vec3(Re)*G*D/(4. * abs(dot(n_save,r.d)*dot(n_save,reflRay.d)));\n            G = G1(nl, r.d*-1., n_save, obj.roughness)*G1(nl, tdir, n_save, obj.roughness);\n            float weight_t = abs(dot(n,r.d) / (dot(n_save,r.d)*dot(n,n_save)))*G;\n            if (obj.roughness >= 0.6) {\n                temp1 = nnt*dot(nl,r.d*-1.) + dot(nl,tdir);\n                vec3 ft = vec3(Tr)*G*D/(temp1*temp1)*abs(dot(nl,r.d)*dot(nl,tdir) / (dot(n_save,r.d)*dot(n_save,tdir)));\t//BTDF\n                if (rand()<P) { \n                \tvec3 e = DirectIllum(x,fr,n_save,id)*pow(obj.roughness, 17.);\n \t                acc += mask * (obj.e*E + e);\n                \tmask *= RP*weight_r; \n                \tr = reflRay;\n                }\n                else { \n                \tvec3 e = DirectIllum(x,ft,n_save*-1.,id)*pow(obj.roughness, 17.);\n                \tacc += mask * (obj.e*E + e);\n                \tmask *= TP*weight_t;\n                \tr = Ray(x, tdir);\n                }\n               \tE=0.;\n            }\n            else {\n                acc += mask * obj.e*E;\n                if (rand()<P) { mask *= RP*weight_r; r = reflRay;}\n                else { mask *= TP*weight_t; r = Ray(x, tdir); }\n                E=1.;\n            }\n        }else {\n\t\t\t\t\t\tacc += mask * obj.e*E;\n            if (rand()<P) { mask *= f*RP; r = reflRay;}\n            else { mask *= f*TP; r = Ray(x, tdir); }\n            E=1.;            \n        }\n\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n    PrecomputeMultipleLights();\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    seed=iTime + dot(st.xy, vec2(85.,78.233));\n\tvec2 uv = 2. * st - 1.;\n\tvec3 camPos = vec3(50., 40.8, 169.)+sin(iTime*1.)*vec3(48.,0.,0.);\n\tvec3 cz = normalize(vec3(50., 40.8, 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz));\n\tvec3 color = vec3(0.);\n\tint samps=SAMPLES/4;\n\tfor (int sy = 0; sy < 2; sy++)     // 2x2 subpixel rows \n\t\tfor (int sx = 0; sx < 2; sx++)         // 2x2 subpixel cols \n\t\t\tfor (int s = 0; s < SUB_SAMPLES; s++) {\n\t\t\t\t//importance sampling\n\t\t\t\tfloat r1 = 2. * rand(), dx = r1 < 1. ? sqrt(r1) - 1. : 1. - sqrt(2. - r1);\n\t\t\t\tfloat r2 = 2. * rand(), dy = r2 < 1. ? sqrt(r2) - 1. : 1. - sqrt(2. - r2);\n    \t\t\tcolor += radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*(uv.x+(float(sx)+.5+dx)/(2.*iResolution.x)) * cx + (uv.y+(float(sy)+.5+dy)/(2.*iResolution.y)) * cy) + cz)));\n  \t\t}\n\tfragColor = vec4(pow(clamp(color/float(SAMPLES), 0., 1.), vec3(1./2.2)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 513, 513, 556], [783, 783, 803, 803, 2352], [2354, 2354, 2388, 2388, 2605], [2607, 2607, 2667, 2667, 2876], [2878, 2878, 2938, 2938, 3066], [3068, 3068, 3131, 3131, 3360], [3404, 3404, 3437, 3437, 3687], [3689, 3689, 3754, 3754, 4586], [4588, 4588, 4610, 4610, 9166]], "test": "timeout"}
{"id": "3ssGWn", "name": "Reflect and Refract", "author": "gest", "description": "almost original https://www.shadertoy.com/view/MtlBDj", "tags": ["lighting", "materials", "reflect", "refract", "sphereiandntersect", "sphera"], "likes": 13, "viewed": 240, "published": "Public", "date": "1545744217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\nfloat u_time;\n\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//\nstruct Camera {\n\t// \n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t// \n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n// ,   \nstruct Object {\n\tfloat   distance;\t//      (  0     )\n\tint \tid;\t\t\t//id  \n};\n//\nstruct Ray {\n\t// \n\tvec3  origin;\t\t// \n\tvec3  direction;\t// \n\tfloat near;\t\t\t//   \n\tfloat far;\t\t\t//   \n\tfloat epsilon;\t\t//\n\tint\t  steps;\t\t//  \n\t// \n\tfloat distance; \t//      ray.origin   ray.direction\n\tvec3  position; \t//    ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//   \n\tvec3  normal;\n\tObject object;\t\t// ,   \n};\n//  \nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//  \n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t// \n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\nstruct Sphere {\n\tvec3  center;\n\tfloat radius;\n};\n\nstruct Plane {\n\tvec3 center;\n\tvec3 normal;\n};\n\nstruct Light {\n    vec3 position;\n\tvec3 color;\n};\nLight light_0 = Light ( vec3(1.5, 1.5, 0), vec3(0.9, 0.9, 0.6) );\nLight light_1 = Light ( vec3(1.5, 1.5, 0), vec3(0.6, 0.9, 0.9) );               \n\nstruct Material {\n    vec3  colorAmbient;     \n    vec3  colorDiffuse;    \n    vec3  colorSpecular;  \n    float shininess;   \t\n\t\n    float reflectivity;  \t//1 -  \n    float refractivity;\t\t//1 -  \n    float indexRefractive;\n};\nMaterial material_0 = Material ( \n\tvec3(0), vec3(0.3, 0.6, 0.9), vec3(0.0), 32.0,\n\t0.0, 0.0, 0.0\n);\t\t\t\t\t\t\t\t\t\t              \nMaterial material_1 = Material (\n\tvec3(0), vec3(0.9, 0.3, 0.6), vec3(1.0), 32.0,\n\t0.2, 0.0, 0.0\n);            \nMaterial material_2 = Material (\n\tvec3(0), vec3(0.6, 0.9, 0.3), vec3(0.0), 32.0,\t\n\t0.8, 0.0, 0.0\n);\n//            \nMaterial material_3 = Material (\n\tvec3(0), vec3(.95, .9, .85), vec3 (1.0), 32.0,\t\n\t0.5, 0.5, 0.95\n);              \n//------------- -----------------------------\n// \nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n// \nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n// \nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//---------------------------------------\n//   \nfloat intersectSphere (in Ray ray, in Sphere sphere) {\n    float a = dot (ray.direction, ray.direction);\n    // exit early, if denominator would almost be zero \n    if (a <= 0.) return ray.far;\n    // set up coefficients a, b and c\n    float b = dot (2. * ray.direction, ray.origin - sphere.center);\n    vec3 op = ray.origin - sphere.center;\n    float c = dot (op, op) - sphere.radius * sphere.radius;\n    float d = sqrt (b * b - 4. * a * c);\n    float twoA = 1. / 2.*a;\n    // compute possible values for t\n    float t1 = (-b + d) * twoA;\n    float t2 = (-b - d) * twoA;\n    // this case should not be possible \n    if (t1 <= .0 && t2 <= .0) return ray.far;\n\tfloat dist = ray.far;\n    if (t1 > .0 && t2 > .0) {\n        if (t1 < t2) {\n\t\t\tdist = t1;\n\t\t} else {\n\t\t\tdist = t2;\n\t\t}\n    }\n    return dist;\n}\n//   \nfloat intersectPlane (in Ray ray, in Plane plane) {\n\t// are ray and plane parallel?\n\tfloat d = dot (ray.direction,plane.normal);\n    if ( d >= 0.) return ray.far;\n\tfloat dist = dot(plane.center - ray.origin, plane.normal) / d;\n\treturn dist;\n}\n//    \nvoid rayMarch (inout Ray ray) {\n\tray.origin += ray.near * ray.direction;\n\tray.distance = ray.far;\n\tray.hit = false;\n\tray.position = ray.origin + ray.distance * ray.direction;\n\tray.normal = vec3(0);\n\tray.object.id = 0;\n\t\n\tfloat d;\n\t\n\tSphere sphere;\n\tPlane plane;\n\t\n\t//\n\tsphere = Sphere(vec3 (-2.,-1.4*0.5,-0.5), 0.6);\n\tsphere.center.y += -1.4*0.5*cos(0. + u_time);\n    d = intersectSphere (ray, sphere);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= normalize (ray.position - sphere.center);\n\t\tray.object.id \t= 1;\n\t}\n    \n\tsphere = Sphere(vec3 ( 1.,-1.5*0.5, 0.5), 0.5);\n\tsphere.center.y += -1.5*0.5*cos(1. + u_time);\n\td = intersectSphere (ray, sphere);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= normalize (ray.position - sphere.center);\n\t\tray.object.id \t= 2;\n\t}\n\n\tsphere = Sphere(vec3 ( 0.,-1.6*0.5, 1.5), 0.4);\n\tsphere.center.y += -1.6*0.5*cos(2. + u_time);\n    d = intersectSphere (ray, sphere);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= normalize (ray.position - sphere.center);\n\t\tray.object.id \t= 3;\n\t}\n\t\n\t//\n\tplane = Plane(vec3 (.0, -2., .0),  vec3 ( 0, 1, 0));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 4;\n\t}\n\t//\n\tplane = Plane(vec3 (.0, 2.0, 0.),  vec3 ( 0,-1, 0));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 5;\n\t}\n\t// \n\tplane = Plane(vec3 (.0, .0, 4.),   vec3 ( 0, 0,-1));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 6;\n\t}\n\t// \n\tplane = Plane(vec3 (.0, .0, -4.),  vec3 ( 0, 0, 1));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit\t\t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 7;\n\t}\n\t// \n\tplane = Plane(vec3 (-6.0, .0, 0.), vec3 ( 1, 0, 0));\n    d= intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 8;\n\t}\n\t// \n\tplane = Plane(vec3 (6.0, .0, 0.),  vec3 (-1, 0, 0));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 9;\n\t}\n\n\n}\n//    \nvec3 lighting (in Ray ray, in Light lights[2], in Material material) {\n\tvec3 color = vec3(0);\n\t\n\tfor (int i=0; i<2; i++) {\n\t\tvec3 lightDirection = normalize (lights[i].position - ray.position);\n    \tfloat lightDistance = length (lights[i].position - ray.position);\n\t\tvec3 rayDirection_ref = reflect (ray.direction, ray.normal);\n\t\t//\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin \t= ray.position;\n\t\t\tray1.direction \t= lightDirection;\n\t\t\tray1.near\t\t= 0.01; //\n\t\t\tray1.far \t\t= lightDistance;\n\t\t}\n\t\trayMarch (ray1);\n\t\tfloat shadow = ray1.distance<lightDistance ? 0.5 : 1.0;\n\t\t\n\t\tfloat attenuation = 1.4 / (lightDistance * lightDistance);\n\t\tfloat diffuse = max (dot (ray.normal, lightDirection), .0);\n\t\tfloat specular = pow (max (dot (rayDirection_ref, lightDirection), .0), material.shininess);\n\t\tif (shadow >= 0.5)  specular = 0.;\n\n\t\tvec3 col = vec3(0);\n\t\tcol += material.colorAmbient;\n\t\tcol += material.colorDiffuse * diffuse * shadow * attenuation;\n\t\tcol *= lights[i].color;\n\t\tcol += material.colorSpecular * specular;\n\t\t\n\t\tcolor += col;\n\t}\n\treturn color;\n}\n/*\n//  \nvec3 getColorTexture(sampler2D texture, vec3 p, vec3 normal) {\n\tmat3 m = mat3(\n\t\ttexture(texture, p.yz).rgb,\n\t\ttexture(texture, p.zx).rgb,\n\t\ttexture(texture, p.xy).rgb\n\t);\n\treturn m * abs(normal);\n}\n*/\n// \nMaterial getMaterial(Ray ray) {\n\tMaterial material;\n\tif (ray.object.id==1) {\n\t\t// \n\t\tmaterial = material_3;\n\t\tmaterial.colorDiffuse = vec3 (0);\n\t} else if (ray.object.id==2) {\n\t\t// \n\t\tmaterial = material_3;\n\t\tmaterial.colorDiffuse = vec3 (0.5);\n\t} else if (ray.object.id==3) {\n\t\t// \n\t\tmaterial = material_3;\n\t\tmaterial.colorDiffuse = vec3 (0.5, 0.1, 0.1);\n\t} else if (ray.object.id==4) {\n\t\t// ( )\n\t\tmaterial = material_1;\n    \tfloat pattern = clamp (pow (abs(2. * cos(ray.position.x + u_time) * sin (ray.position.z + u_time) * .5 + .5), .3), 0., 1.);\n\t\tmaterial.colorDiffuse = mix (vec3 (.9, .3, .3), vec3 (.9), 1. - pattern);\n\t} else if (ray.object.id==5) {\n\t\t// ( )\n\t\tmaterial = material_1;\n    \tfloat pattern = clamp (pow (abs(2. * cos(ray.position.x + u_time) * sin (ray.position.z + u_time) * .5 + .5), .3), 0., 1.);\n\t\tmaterial.colorDiffuse = mix (vec3 (.9, .9, .3), vec3 (.5), 1. - pattern);\n\t} else if (ray.object.id==6 || ray.object.id==7) {\n\t\t//    ( )\n\t\tmaterial = material_2;\n    \tfloat pattern = clamp (mod (length(ray.position*sin(.1*u_time)), .5), 0., 1.);\n\t\tmaterial.colorDiffuse = mix (vec3 (.6, .9, .3), vec3 (.5), 1. - pattern);\n//    \tfloat pattern = clamp (pow (length (4.*sin(mod((ray.position.y*ray.position.x), .3))), .125), 0., 1.);\n//\t\tmaterial.colorDiffuse = mix (vec3 (.6, .9, .3), vec3 (.5), 1. - pattern);\n\t} else if (ray.object.id==8) {\n\t\t//  (  )\n\t\tmaterial = material_0;\n\t\tfloat pattern = clamp (pow (abs(15. * cos(ray.position.x+u_time) * sin (ray.position.z+u_time)), .3), 0., 1.);\n\t\tmaterial.colorDiffuse = mix (vec3 (.3, .6, .9), vec3 (.8), 1. - pattern);\n\t} else if (ray.object.id==9) {\n\t\t//  (  )\n\t\tmaterial = material_0;\n        vec3 p = ray.position * 0.5;\n        mat3 m = mat3(\n            texture(iChannel0, p.yz).rgb,\n            texture(iChannel0, p.zx).rgb,\n            texture(iChannel0, p.xy).rgb\n        );\n\t\tmaterial.colorDiffuse = m * abs(ray.normal);;\n\t}\n\treturn material;\n}\n\n// \nvec3 rayReflect(in Ray ray, in Light lights[2]) {\n\t// \n\tvec3 color = vec3(0);\n\t// \n\tfloat factorReflect = 1.0;\n\t\n\tfor (int i=0; i<5; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tcolor += factorReflect * lighting(ray, lights, material);\n\t\t\tfactorReflect *= material.reflectivity;\n\t\t\tif (factorReflect < 0.01) break;\n\t\t\t// \n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\tray.near \t\t= 0.01; //\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n// \nvec3 rayRefract(in Ray ray, in Light lights[2]) {\n\tvec3 color = vec3(0);\n\t// \n\tfloat factorRefract = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\t// \n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tfactorRefract *= material.refractivity;\n\t\t\tif (factorRefract < 0.01) break;\n\t\t\t//   \n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //\n\t\t\t}\n            rayMarch (ray);\n\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    //\n    u_time = iTime;\n    vec2 u_canvas = iResolution.xy;\n    vec2 u_mouse  = iMouse.xy;\n    \n    float aspect = u_canvas.x / u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv * 2. - 1.;\n\n    vec2 mouse = u_mouse.xy / u_canvas.xy;\n    mouse = mouse * 2. - 1.;\n    mouse = (u_mouse.xy==vec2(0)) ? vec2(0) : (mouse.xy);\n\n    // \n    Light lights[2];\n    lights[0] = light_0;\n    lights[1] = light_1;\n    rotate (lights[0].position, vec3(0,1,0)*u_time/5.);\n    rotate (lights[1].position, vec3(0,1,0)*-u_time/5.);\n    //\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n        cam.origin \t= vec3 (.0, .0, -3.);\n\n        float rotX = 0.5*PI*sin (0.5 * PI * mouse.y);\n        float rotY = PI*sin (0.5 * PI * mouse.x);\n        rotate(cam.origin, vec3(rotX, rotY, 0));\n\n        cam.target  = vec3(0,0,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n    //  \n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.0;\n        ray.far  \t= 15.0;\n        ray.epsilon = 0.0001;\n        ray.steps \t= 1;\n    }\n    \n    vec3 color = vec3(0);\n\n    color += rayReflect(ray, lights);\n    color += rayRefract(ray, lights);    \n  \n\n    //\n    color = pow(color, vec3(1.0/2.2));\n\n    GL_FragColor = vec4 (color, 1.);\n\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1688, 1737, 1780, 1844, 2323], [3383, 3505, 3540, 3540, 3554], [3555, 3595, 3638, 3638, 3656], [3657, 3691, 3728, 3728, 4016], [4017, 4111, 4165, 4165, 4913], [4914, 4972, 5023, 5055, 5214], [5215, 5284, 5315, 5315, 8387], [8388, 8455, 8525, 8525, 9522], [9523, 9817, 9848, 9848, 12117], [12119, 12149, 12198, 12229, 12781], [12782, 12816, 12865, 12865, 13528], [13530, 13530, 13593, 13614, 14948]], "test": "error"}
{"id": "3ssGzM", "name": "modulo kaleidoscope", "author": "morisil", "description": "variation of my previous modulo squares", "tags": ["circle", "kaleidoscope", "square", "modulo"], "likes": 2, "viewed": 510, "published": "Public API", "date": "1545478922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 800.0\n#define SQUEEZE_RATE 4.0\n#define SPEED -100.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float squizeFactor = sin(iTime / SQUEEZE_RATE) * 2.0 + 1.0;\n    pixel = pow(abs(pixel), vec2(squizeFactor));\n    pixel *= vec2(SCALE);\n    float x = pixel.x;\n    float y = pixel.y;\n \tfloat t = iTime * SPEED;    \n    fragColor = vec4(\n          mod(x + mod(y + t, 64.0) + y + mod(x + t, 64.0), 256.0) / 256.0,\n          0,\n          mod(x + mod(y + t, 128.0) + y + mod(x + t, 128.0), 256.0) / 256.0,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 122, 122, 613]], "test": "ok"}
{"id": "3ssGzN", "name": "circle modulation", "author": "arthursw", "description": "simple 2d circle spiral", "tags": ["2d", "circles", "spiral"], "likes": 7, "viewed": 170, "published": "Public", "date": "1545227306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// From Marteen's great \"2d signed distance functions\" shader: https://www.shadertoy.com/view/4dfXDn\n\n/**\n\n\tHi all,\n\n\tThis is just my playground for a bunch of 2D stuff:\n\n\tSome distance functions and blend functions\n\tCone marched 2D Soft shadows\n\tUse the mouse to control the 3rd light\n\n*/\n\n\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////////////\n// The scene //\n///////////////\n\n\nfloat sceneDist(vec2 p)\n{\n    p -= iResolution.xy / 2.0;\n    float m = 100000.0;\n    float r = min(iResolution.x, iResolution.y);\n    float ratio = 400.0 / r;\n    for(int i=0 ; i<500 ; i++) {\n        float ip1 = float(i+1);\n        float ip100 = float(i+100);\n        \n    \tfloat angle = 0.0002*iTime*ip100+float(i);\n        float rm = 1.0 + 0.05 * sin(5.0*angle);\n        float x = rm * ip100 * 0.30 * cos(angle) / ratio;\n        float y = rm * ip100 * 0.30 * sin(angle) / ratio;\n\t\tfloat c = circleDist(\t\ttranslate(p, vec2(x, y)), 3.0*(1.0+0.5+0.5*sin(50.0*angle)) * ip100 / 600.0 );\n        m = merge(m, c);\n    }\n    \n\treturn m;\n}\n\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDist(p);\n\taccum += sceneDist(p + vec2(0.0, r));\n\taccum += sceneDist(p + vec2(0.0, -r));\n\taccum += sceneDist(p + vec2(r, 0.0));\n\taccum += sceneDist(p + vec2(-r, 0.0));\n\treturn accum / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\n\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n\tvec2 dir = normalize(pos - p);\n\tfloat dl = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * dl;\n\t\n\t// distance traveled\n\tfloat dt = 0.01;\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\t\t\t\t\n\t\t// distance to scene at current position\n\t\tfloat sd = sceneDist(p + dir * dt);\n\n        // early out when this ray is guaranteed to be full shadow\n        if (sd < -radius) \n            return 0.0;\n        \n\t\t// width of cone-overlap at light\n\t\t// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage\n\t\t// should be '(sd / dt) * dl', but '*dl' outside of loop\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(1.0, abs(sd));\n\t\tif (dt > dl) break;\n\t}\n\n\t// multiply by dl to get the real projected overlap (moved out of loop)\n\t// add one radius, before between -radius and + radius\n\t// normalize to 1 ( / 2*radius)\n\tlf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\treturn lf;\n}\n\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = shadow(p, pos, radius);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p);\n\t\n\tvec2 light1Pos = iMouse.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\tsetLuminance(light1Col, 0.4);\n\t\n\tvec2 light2Pos = vec2(iResolution.x * (sin(iTime + 3.1415) + 1.2) / 2.4, 175.0);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\tsetLuminance(light2Col, 0.5);\n\t\n\tvec2 light3Pos = vec2(iResolution.x * (sin(iTime) + 1.2) / 2.4, 340.0);\n\tvec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n\tsetLuminance(light3Col, 0.6);\n\t\n\t// gradient\n\tvec4 col = vec4(0.0, 0.0, 0.0, 1.0);// * (1.0 - length(c - p)/iResolution.x);\n\t// grid\n\t//col *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n\t// ambient occlusion\n\t//col *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(p, sceneDist(p), 40.0, 1.0);\n\t// light\n\t//col += drawLight(p, light1Pos, light1Col, dist, 150.0, 6.0);\n\t//col += drawLight(p, light2Pos, light2Col, dist, 200.0, 8.0);\n\t//col += drawLight(p, light3Pos, light3Col, dist, 300.0, 12.0);\n\t// shape fill\n\tcol = mix(col, vec4(0.354, 0.454, 0.87, 1.0), fillMask(dist));\n\t// shape outline\n\t//col = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 412, 460, 460, 561], [564, 564, 597, 597, 620], [623, 623, 663, 663, 706], [709, 709, 746, 746, 770], [773, 773, 810, 810, 833], [931, 931, 964, 964, 1031], [1034, 1034, 1066, 1066, 1132], [1135, 1135, 1167, 1167, 1184], [1282, 1282, 1314, 1314, 1421], [1424, 1424, 1464, 1464, 1494], [1497, 1497, 1539, 1539, 1621], [1624, 1624, 1679, 1679, 1788], [1791, 1791, 1861, 1861, 1973], [1976, 1976, 2024, 2024, 2140], [2143, 2143, 2202, 2202, 2390], [2467, 2467, 2495, 2495, 2529], [2532, 2532, 2580, 2596, 2709], [2712, 2712, 2760, 2776, 2889], [2942, 2942, 2967, 2967, 3575], [3578, 3578, 3614, 3614, 3824], [3898, 3898, 3944, 3944, 4950], [4954, 4954, 5039, 5061, 5353], [5356, 5356, 5383, 5383, 5443], [5446, 5446, 5492, 5492, 5531], [5534, 5534, 5595, 5595, 5763], [5822, 5822, 5879, 5879, 7128]], "test": "ok"}
{"id": "3sX3D8", "name": "ouroboros 3", "author": "morisil", "description": "experiments with math behind the perspective, rotation, and the endless chessboard", "tags": ["endless", "loop", "checker", "rotation", "perspective", "double", "chess"], "likes": 1, "viewed": 352, "published": "Public API", "date": "1545932820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 7.0\n\n#define SCENE_ROTATION_SPEED 0.5\n\n#define PLANE_ROTATION_SPEED -0.2\n\nmat2 rotate2d(float angle){\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    pixel *= rotate2d(iTime * SCENE_ROTATION_SPEED);\n    vec2 trans = vec2(pixel.x / pixel.y, 1.0 / log(abs(pixel.y)));\n    trans *= rotate2d(iTime * PLANE_ROTATION_SPEED);    \n    trans *= SCALE;\n    \n    float value = (1.0 - pow(sin(trans.x), 20000.0)) * sign(cos(trans.x));\n    value *= (1.0 - pow(sin(trans.y), 20000.0)) * sign(cos(trans.y));\n    value = (value + 1.0) / 2.0;\n\n    // apply air perspective\n    value *= abs(pixel.y * 2.0);\n    fragColor = vec4(vec3(value),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sX3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 115, 115, 205], [207, 207, 262, 262, 813]], "test": "ok"}
{"id": "3sXGD8", "name": "Rubber floor", "author": "slimyfrog", "description": "My first experiment with ray marching", "tags": ["checkers", "smoothmin"], "likes": 2, "viewed": 111, "published": "Public", "date": "1545936581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DISTANCE   20.0\n#define MIN_DISTANCE    0.001\n#define PI \t\t\t    3.142\n#define PI2 \t\t   (PI/2.0)\n#define SPHERE_HEIGHT\t0.55\n\n// smooth min from iq\nfloat smoothmin( float a, float b)\n{\n    float h = max( 1.0-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h*(1.0/6.0);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat planeDf(vec3 p)\n{    \n    return p.y; // implied p.y - 0.0 where 0.0 is plane height\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sphereDf(vec3 p, vec3 spherePos, float radius)\n{\n    return length(spherePos + p) - radius;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat boxDf( vec3 p, vec3 boxPos, vec3 size )\n{\n  vec3 d = abs(p + boxPos) - size;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sceneDf(vec3 p)\n{\n    float sphereDist = sin(iTime * 0.2) * 10.0;\n    //sphere positions\n    vec3 sp1 = vec3(sin(iTime) * sphereDist,SPHERE_HEIGHT, cos(iTime)* sphereDist);\n    vec3 sp2 = vec3(sin(iTime + PI2)* sphereDist,SPHERE_HEIGHT, cos(iTime +PI2)* sphereDist);\n    vec3 sp3 = vec3(sin(iTime + PI)* sphereDist,SPHERE_HEIGHT, cos(iTime+PI)* sphereDist);\n    vec3 sp4 = vec3(sin(iTime + PI2*3.0)* sphereDist,SPHERE_HEIGHT, cos(iTime+PI2*3.0)* sphereDist);\n    \n    float dist = smoothmin(\n        sphereDf(p, sp1, 1.0), \n        sphereDf(p, sp2, 1.0));\n    dist = smoothmin(\n        sphereDf(p, sp3, 1.0), \n        dist);\n    dist = smoothmin(\n        sphereDf(p, sp4 , 1.0), \n        dist);\n    dist = smoothmin(dist, planeDf(p));\n    \n    dist = smoothmin(dist, boxDf(p, vec3(0), vec3(1)));\n    return dist;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.01f;\n    \n    vec3 normal;\n    normal.x = sceneDf(vec3(p.x + e,p.y,p.z)) - sceneDf(vec3(p.x - e, p.y, p.z));\n    normal.y = sceneDf(vec3(p.x,p.y + e,p.z)) - sceneDf(vec3(p.x, p.y - e, p.z));\n    normal.z = sceneDf(vec3(p.x,p.y,p.z + e)) - sceneDf(vec3(p.x, p.y, p.z - e));\n    \n    return normalize(normal);\n}\n\n// odd/even checker pattern\nfloat checkers( in vec3 p )\n{\n    return int(50.0+p.x)%2 != int(50.0+p.z)%2 ? 1.0 : 0.0;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 processLighting(vec3 baseColor, vec3 eyePos, vec3 surfacePoint)\n{\n\tconst vec3 ambientLight = vec3(0.38,0.29f,0.9f);\n    \n    vec3 diffuseDir = normalize(vec3(1,-0.75, -1));\n    float diffuseIntensity = 0.7f;\n    \n    vec3 normal = calcNormal(surfacePoint);\n    \n    vec3 e = normalize(eyePos);\n    vec3 r = normalize(reflect(diffuseDir,normal));\n\tfloat specular =  pow(max(dot(r,e),0.0),8.0);\n\tspecular = clamp(specular, 0.0, 1.0);\n                 \n    float diffDot = max(dot(-diffuseDir, normal), 0.0);\n        \n    vec3 color = baseColor * (ambientLight +  diffDot * vec3(0.8,0.8,0.6) + specular);\n    return color;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 marchRay(vec3 eyePos,vec3 dir)\n{\n    vec3 color = normalize(-dir);\n    vec3 currentPoint = eyePos;\n    while(length(currentPoint) < MAX_DISTANCE)\n    {\n        float dist = sceneDf(currentPoint);\n        if(dist <= MIN_DISTANCE)\n        {\n            color = processLighting(vec3(checkers(currentPoint)), eyePos, currentPoint);\n            break;\n        }\n        currentPoint += (dist * dir);\n    }\n    return color;\n}\n\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera\t\n\tvec3 eye = vec3( 9.0, 3.0, 9.0 );\n    vec3 lookat = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 forward = normalize( lookat - eye );\n    vec3 right = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 up = normalize( cross(right, forward));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 dir = normalize( p.x*right + p.y*up + 3.5*forward );\n       \n    vec3 color = marchRay(eye, dir);\n    \n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXGD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 158, 194, 194, 278], [280, 409, 432, 432, 501], [503, 632, 686, 686, 731], [733, 862, 909, 909, 1017], [1020, 1149, 1172, 1172, 1969], [1971, 2100, 2125, 2125, 2451], [2453, 2481, 2510, 2510, 2571], [2573, 2702, 2772, 2772, 3328], [3330, 3459, 3496, 3496, 3884], [3888, 4017, 4074, 4090, 4584]], "test": "ok"}
{"id": "3sXGzH", "name": "Hypnotic Eye", "author": "raffjones", "description": "A hypnotic animated eyeball, created after following Inigo Quilez (@iquilezles) live coding video here: https://www.youtube.com/watch?v=emjuqqyq_qc. I modified the shadows, highlights and added my own animation. My first ever shader.", "tags": ["noise", "eye", "animation"], "likes": 5, "viewed": 165, "published": "Public", "date": "1544835168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// My first shader :) \n// Based almost completely on the work of Inigo Quilez @iquilezles so I can't really take credit\n// for any of it. I created this after following his live coding video here:\n// https://www.youtube.com/watch?v=emjuqqyq_qc\n// I modified the reflections, shadows and highlights, and added some new animation\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// rotation matrix (proportional to sides of right triangle)\nmat2 m = mat2( 0.8, 0.6, -0.6, 0.8 );\n\n// fractional brownian motion\nfloat fbm( vec2 p ) {\n\tfloat f = 0.0;\n\tf += 0.5000 * noise( p );\n\tp *= 2.02;\n\n\t// repeat to add octaves\n\tf += 0.2500 * noise( p );\n\tp *= 2.02;\n\n\tf += 0.1250 * noise( p );\n\tp *= 2.01;\n\n\tf += 0.0625 * noise( p );\n\tp *= 2.04;\n\n\t// Add all of the above up - this normalizes it\n\tf /= 0.9375;\n\n\treturn f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 q = fragCoord/iResolution.xy;\n\t\n    // Work from the centre\n\tvec2 p = -1.0 + 2.0 * q;\n    \n    // Correct aspect ratio\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\tfloat r = sqrt( dot( p, p) );\n\tfloat a = atan( p.y, p.x );\n\t\n    // Sin of time to get some animation\n\tfloat ss = 0.5 + 0.5 * sin( 1.0 * iTime );\n\tfloat anim = 1.0 + 0.1 * ss * clamp( 1.0 - r, 0.0, 1.0 );\n\tr *= anim;\n\n\tfloat speed = 0.5;\n\tfloat s = sin( iTime * speed );\n\tfloat c = cos( iTime * speed );\n\n\tvec3 col = vec3(1.0);\n\t\n\tfloat f;\n\n\tif ( r < 0.8 ) {\n        \n        // This creates the base colour, using some noise\n\t\tcol = vec3( 0.2, 0.3, 0.4 );\n\t\tfloat f = fbm( 5.0 * p );\n\t\tcol = mix( col, vec3( 0.2, 0.3 + 0.3 * c, 0.4), f );\n\n\t\t// Yellow layer out from centre\n\t\tf = 1.0 - smoothstep( 0.2 + 0.1 * s, 0.3 + clamp(0.0, 0.3, 0.7 * s), r );\n\t\tcol = mix( col, vec3(0.9, 0.6, 0.2), f );\n\n\t\t// angle distortion\n\t\tfloat distortionFreq = 5.0 + c * 5.0 + 20.0 * sin( iTime * 0.001 );\n\t\ta += 0.05 + (0.5 * s) * fbm( p * distortionFreq );\n\n\t\t// Add white fibre noise with polar co-ordinates\n\t\tf = smoothstep( 0.3, 1.0, fbm( vec2( 10.0 * r, 15.0 * a) ) );\n\t\tcol = mix( col, vec3(1.0), f);\n\n\t\t// black areas - reducing 2nd number makes the blacks darker\n\t\tf = smoothstep( 0.5, 0.8 + s * 0.1, fbm( vec2( 8.0 * r, 10.0 * a ) ) );\n\t\tcol *= ( 1.0 - 0.5 * f );\n\t\t\n\t\t// dark edges - offset slightly down and left\n\t\tf = smoothstep( 0.6, 0.9, r - p.x/10.0 - p.y/10.0 );\n\t\tcol *= ( 1.0 - 0.8 * f); // Multiply\n\n\t\t// lighten in opposite corner\n\t\tf = smoothstep( 0.6, 0.9, r + p.x/10.0 + p.y/10.0 );\n\t\tcol += vec3( 0.8, 0.9, 1.0) * f * 0.4; // add\n\n\t\t// pupil\n\t\tf = smoothstep( 0.2 + 0.01 * s, 0.25 + 0.01 * s, r );\n\t\t// f = smoothstep( 0.2, 0.25, r );\n\t\tcol *= f;\n\n\t\t// reflection 1\n\t\tf = 1.0 - smoothstep( 0.0, 0.6, length( p - vec2(0.2, 0.2) ) );\n\t\tcol += vec3( 1.0, 0.9, 0.8 ) * f * 0.3;\n\n\t\t// reflection 2 (small glint in pupil)\n\t\tf = 1.0 - smoothstep( 0.0, 0.075 + 0.025 * s, length( p - vec2(0.1 + 0.01 * s, 0.1 + 0.01 * s) ) );\n\t\tcol += vec3( 1.0 ) * f * 0.3;\n\t\t\n        // Antialias the edges\n\t\tf = smoothstep( 0.75, 0.8, r );\n\t\tcol = mix( col, vec3(1.0), f);\n\t}\n\t\n    // and we're done\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 342, 369, 369, 486], [488, 488, 514, 514, 999], [1101, 1131, 1152, 1152, 1431], [1434, 1434, 1491, 1541, 3729]], "test": "ok"}
{"id": "4lGfDc", "name": "fake 3D triangle logo (204 ch)", "author": "FabriceNeyret2", "description": ".", "tags": ["fake3d", "2tweets", "short", "golf"], "likes": 8, "viewed": 418, "published": "Public API", "date": "1544203437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(r)  smoothstep(  9./R, R-R, abs( l*cos(a) -r ) -.1 )    //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = u+u - R,\n         l = length(U+U)/R,    /* .955 = 3/pi  1.05 = pi/3 */\n         a =  ( mod( .955*atan(U.y,U.x) + iTime ,2.) - R/R ) *1.05;\n    O += mix( .5* S(.5), S(.7), .5+.5 *l*sin(a) ).y; }                /*\n\n\n\n\n\n\n// --- 210 chars\n\n#define S(r)  smoothstep(  9./R.y, 0., abs( l*cos(a) -r ) -.1 )  //\n#define mainImage(O,u)                                            \\\n    vec2 R = iResolution.xy,                                      \\\n         U = u+u - R;                                             \\\n    float l =  length(U+U)/R.y,                                   \\\n          a = ( mod( .955*atan(U.y,U.x) + iTime ,2.) - 1. ) *1.05;\\\n    O += mix( .5* S(.5), S(.7), .5+.5 *l*sin(a) )                /*\n\n\n\n\n\n\n// --- 282 chars\n\n#define S(v)      smoothstep(  9./R.y, 0., v )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = 2.* ( U+U - R ) /R.y;\n    float a = atan(U.y,U.x) - iTime, l = length(U), PI = 3.14;\n    a = ( mod( 3.*a +PI, 2.*PI ) - PI ) /3.;\n    U = l * vec2(cos(a),sin(a));\n    O-=O;\n    O +=    S( abs(U.x-.7)-.1 ) * (.5+.5*U.y)\n      + .5* S( abs(U.x-.5)-.1 ) * (.5-.5*U.y);\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 105, 105, 341]], "test": "ok"}
{"id": "4lGfDV", "name": "Baby's first garbage shader", "author": "TheSteveIAm", "description": "Practicing some basic things, manual box placement, color mixing, scaling, rotating, nothing fancy.\nI have no idea what I'm doing, but I'm doing something!\nFeedback and tips are very welcome!", "tags": ["practice"], "likes": 2, "viewed": 74, "published": "Public", "date": "1544042662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define PI 3.14159265359\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n    st.x *= iResolution.x/iResolution.y;\n\n    vec3 color = vec3(0.);    \n    \n    st += vec2(-0.4,0.0);\n    \n    st *= 3.;\n\tst = fract(st);\n    st -= vec2(0.5);\n    st = rotate2d( sin(iTime)*PI * 2.) * st;\n    st = scale( vec2(sin(iTime)+1.0)) * st;\n    //st = scale(vec2(0.3)) * st;\n    st += vec2(0.5);\n    \n    //box shapes yo \n    color += box(st + vec2(0., 0.1), vec2(0.02,0.3/6.));\n    color += box(st + vec2(0., -0.1), vec2(0.02,0.3/6.));\n    color += box(st + vec2(0.1, 0.), vec2(0.3/6., 0.02));\n    color += box(st + vec2(-0.1, 0.), vec2(0.3/6., 0.02));\n    \n    st -= vec2(0.5);\n    st = rotate2d(0.75) * st;\n    st += vec2(0.5);\n    \n    color += box(st + vec2(0., 0.1), vec2(0.02,0.3/6.));\n    color += box(st + vec2(0., -0.1), vec2(0.02,0.3/6.));\n    color += box(st + vec2(0.1, 0.), vec2(0.3/6., 0.02));\n    color += box(st + vec2(-0.1, 0.), vec2(0.3/6., 0.02));\n    \n    st -= vec2(0.5);\n    st = rotate2d(0.4) * st;\n    st += vec2(0.5);\n    \n    color += box(st + vec2(0., 0.066), vec2(0.01,0.016));\n    color += box(st + vec2(0., -0.066), vec2(0.01,0.016));\n    color += box(st + vec2(0.066, 0.), vec2(0.016,0.01));\n    color += box(st + vec2(-0.066, 0.), vec2(0.016,0.01));\n    \n    st -= vec2(0.5);\n    st = rotate2d(0.8) * st;\n    st += vec2(0.5);\n\t\n    color += box(st + vec2(0., 0.066), vec2(0.01,0.016));\n    color += box(st + vec2(0., -0.066), vec2(0.01,0.016));\n    color += box(st + vec2(0.066, 0.), vec2(0.016,0.01));\n    color += box(st + vec2(-0.066, 0.), vec2(0.016,0.01));\n    \n    //random circle stuff, messing with mixing\n    color += mix(vec3(0.0,0.0,0.0), vec3(0.000,1.000,0.981), smoothstep(circle(st, vec2(0.5), 1.0, 1.0), 0.21, 0.21));\n    color -= mix(vec3(0.0,0.0,0.0), vec3(0.000,1.000,0.723), smoothstep(circle(st, vec2(0.5), 1.0, 1.0), 0.20, 0.22));\n    color += mix(vec3(0.0,0.0,0.0), vec3(0.974,0.472,1.000), smoothstep(circle(st, vec2(0.5), 1.0, 1.0), 0.19, 0.23)); \n    color -= mix(vec3(0.0,0.0,0.0), vec3(1.000,0.010,0.038), smoothstep(circle(st, vec2(0.5), 1.0, 1.0), 0.18, 0.24));\n   \tcolor += mix(vec3(0.0,0.0,0.0), vec3(1.000,0.456,0.000), smoothstep(circle(st, vec2(0.5), 1.0, 1.0), 0.17, 0.2)); \n    color -= mix(vec3(0.0,0.0,0.0), vec3(1.000,0.891,0.130), smoothstep(circle(st, vec2(0.5), 1.0, 1.0), 0.16, 0.8));\n    \n    fragColor = vec4(color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 142, 142, 245], [247, 247, 271, 271, 334], [336, 336, 374, 374, 641], [643, 643, 671, 671, 757], [759, 759, 816, 866, 3222]], "test": "ok"}
{"id": "4lKfDV", "name": "Triangle20", "author": "Jkulvich", "description": "Triangle", "tags": ["triangle", "lesson"], "likes": 1, "viewed": 50, "published": "Public", "date": "1544131044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getTriangleArea( vec2 p[3] ) {  \n    float area = \n        (p[1].x - p[0].x) * (p[2].y - p[0].y) - \n        (p[2].x - p[0].x) * (p[1].y - p[0].y);   \n    return abs(area) * .5;\n}\n\nfloat getDistanceTriangle( vec2 coords[3], vec2 point ) { \n    // Area of the main triangle\n    float area = getTriangleArea(coords);\n            \n    // Building 3 triangles areas for every point pair + our positon\n    float subAreas[3];\n    subAreas[0] = getTriangleArea(vec2[3](coords[0], coords[1], point));\n    subAreas[1] = getTriangleArea(vec2[3](coords[0], point, coords[2]));\n    subAreas[2] = getTriangleArea(vec2[3](point, coords[1], coords[2]));\n    \n    // Calc total sum for triangles\n    float subArea;\n    for (int i = 0; i < subAreas.length(); i++)\n        subArea += subAreas[i];        \n    \n    // \"Distance\" to the triangle\n\treturn subArea - area;   \n}\n\nbool isPointInTriangle( vec2 coords[3], vec2 point ) {\n    // Allows to remove artifacts (larger value - less artifacts, but more inaccurate)\n    float deviation = 0.0001;\n    \n    // If point in the triangle (distance 0 or lower)\n    if (getDistanceTriangle(coords, point) - deviation <= 0.)\n        return true;\n    \n    return false;\n}\n\nvec2 getRotatedPoint(vec2 point, vec2 pivot, float angle) {\n    // Prepare transformation matrix\n    mat2x2 rotMtx;\n    rotMtx[0] = vec2(cos(angle), -sin(angle));\n    rotMtx[1] = vec2(sin(angle), cos(angle));\n    \n    // Make point relative start of coordinates, rotate and restore it\n    point -= pivot;    \n    point = rotMtx * point;    \n    point += pivot;\n    \n    return point;\n}\n\nvec2 getScaledPoint(vec2 point, vec2 pivot, float ratio) {\n    // Prepare transformation matrix\n    mat2x2 scalMtx;\n    scalMtx[0] = vec2(ratio, 0);\n    scalMtx[1] = vec2(0, ratio);\n    \n    // Make point relative start of coordinates, scale and restore it\n    point -= pivot;    \n    point = scalMtx * point;    \n    point += pivot;\n    \n    return point;\n}\n\nvec2 pointToUV(vec2 point) {\n\treturn point / iResolution.xy;   \n}\nvec2 uvToPoint(vec2 uv) {\n\treturn uv * iResolution.xy;   \n}\n\n\n\n\nvec4 figureRender(vec2 fragCoord, float ratio) {   \n    vec2 uv = pointToUV(fragCoord);\n    vec3 col = vec3(0., 0., 0.);\n    \n    // Coordinates of triangles (in UV)\n    vec2 coords[3];\n    coords[0] = vec2(0.5, 0.3);\n    coords[1] = vec2(0.3, 0.7);\n    coords[2] = vec2(0.7, 0.7);\n    \n    // Rotate & scale points by matrix\n    for (int i = 0; i < coords.length(); i++) {\n    \tcoords[i] = getRotatedPoint(coords[i], vec2(.5, .5), ratio + abs(sin(ratio)));\n        coords[i] = getScaledPoint(coords[i], vec2(.5, .5), abs(sin(ratio)) * .8 + .2);\n    }\n    \n\t// Get distance to the triangle\n    float dist = getDistanceTriangle(coords, uv);\n    dist = max(dist * 300., 1.);\n    col = vec3(1., 1., 1.) / dist;\n    \n    return vec4(col, 1.0);\n}\n\n\n\n// The entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    float ratio = iTime;\n    \n    float pi = 3.1415;    \n    ratio += abs(sin(ratio));    \n    \n    vec2 shift = vec2(.14 * sin(ratio), .0);\n    \n    vec2 uv = pointToUV(fragCoord);\n    \n    vec4 colR = figureRender(uvToPoint(uv + shift), ratio) * vec4(1., 0., 0., 0.);\n    vec4 colG = figureRender(fragCoord, ratio) * vec4(0., 1., 0., 0.);\n    vec4 colB = figureRender(uvToPoint(uv - shift), ratio) * vec4(0., 0., 1., 0.);\n    \n    fragColor = colR + colG + colB;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 184], [186, 186, 243, 277, 859], [861, 861, 915, 1002, 1199], [1201, 1201, 1260, 1297, 1586], [1588, 1588, 1646, 1683, 1946], [1948, 1948, 1976, 1976, 2013], [2014, 2014, 2039, 2039, 2073], [2078, 2078, 2126, 2126, 2819], [2823, 2842, 2899, 2899, 3367]], "test": "ok"}
{"id": "4lVfRD", "name": "try perlin noise", "author": "cailuming", "description": "apply perlin noise to sphere, 3D is ok , but 2D can not be mapped to the sphere surface correctly", "tags": ["noise", "volumetric"], "likes": 2, "viewed": 113, "published": "Public", "date": "1543763745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//hash function is modified from iq's demo, for easy to remember \n//see https://www.shadertoy.com/view/4tXyWN\n\n#define PI   3.1415926\n#define U_PI 3141592657U\n#define MAXIT 256\n#define SCALE  7.01592657e+3\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n    \nmat2 rot2D(float arc){\n   float c = cos(arc);\n   float s = sin(arc);\n   \n   return mat2(c,s,-s,c); \n}\n\nvec3 getColor(float c){\n   float r= cos((c-0.85)*PI);\n   float g= cos((c-0.55)*PI);\n   float b= cos((c-0.15)*PI);\n    \n   return vec3(r,g,b); \n}\n\nfloat hash( vec2 x ) //modified from iq's hash function\n{\n    uvec2 q = U_PI * uvec2(x);\n    uint  n = U_PI * (q.x^(q.y>>1U));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash1( vec2 x )  // modified from iq's hash function\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    vec2 v = -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) ); \n    v*=k;\n    v*=rot2D(iTime*4.);\n    return v;\n}\n\nvec3 hash2( vec3 x )  // modified from iq's hash function\n{\n    const vec3 k = vec3( 0.3183099, 0.3678794,.3787694 );\n    x = x*k + k.zyx;\n    vec3 v = -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*x.z*(x.x+x.y+x.z)) ); \n\n    return v;\n}\n\n//see http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n//refuse to remember ,but to understand what is going on is so important \n\n// 2d noise ,inspired by iq ,but without the gradient\n// 2d noise cann't be apllied to a sphere no matter what drivers I use vec3(x,y,z) or vec2(atan(p.y,p.x),atan(p.z,p.y)\n\nfloat noise2D(vec2 uv){\n   vec2 x00 = floor(uv);\n   vec2 x01 = x00+vec2(0,1);\n   vec2 x10 = x00+vec2(1,0);\n   vec2 x11 = x00+vec2(1);\n   vec2 cp  = fract(uv);\n    \n   vec2 v00 = hash1(x00);\n   vec2 v01 = hash1(x01);\n   vec2 v10 = hash1(x10);\n   vec2 v11 = hash1(x11);\n    \n   float d00 = dot(v00,uv-x00);\n   float d01 = dot(v01,uv-x01);\n   float d10 = dot(v10,uv-x10);\n   float d11 = dot(v11,uv-x11);\n    \n   cp = 3.*cp*cp - 2.*cp*cp*cp;\n     \n   d00 = mix(d00,d10,cp.x);\n   d01 = mix(d01,d11,cp.x);\n    \n       \n   return mix(d00,d01,cp.y);\n    \n}\n\n// 3d noise ,inspired by iq ,but without the gradient\nfloat noise3D(vec3 p){\n   vec3 x000 = floor(p);\n   //evaluate the eight corner first \n   vec3 x001 = x000+vec3(0,0,1);\n   vec3 x010 = x000+vec3(0,1,0);\n   vec3 x011 = x000+vec3(0,1,1);\n   \n   vec3 x100 = x000+vec3(1,0,0);\n   vec3 x101 = x000+vec3(1,0,1);\n   vec3 x110 = x000+vec3(1,1,0);\n   vec3 x111 = x000+vec3(1,1,1);\n   \n   // get the interpolation coe  \n   vec3 cp  = fract(p);\n   \n   //get each random vector of the corner \n   vec3 v000 = hash2(x000);\n   vec3 v001 = hash2(x001);\n   vec3 v010 = hash2(x010);\n   vec3 v011 = hash2(x011);\n   vec3 v100 = hash2(x100);\n   vec3 v101 = hash2(x101);\n   vec3 v110 = hash2(x110);\n   vec3 v111 = hash2(x111);\n    \n   //do the projection \n   float d000 = dot(v000,p-x000);\n   float d001 = dot(v001,p-x001);\n   float d010 = dot(v010,p-x010);\n   float d011 = dot(v011,p-x011);\n    \n   float d100 = dot(v100,p-x100);\n   float d101 = dot(v101,p-x101);\n   float d110 = dot(v110,p-x110);\n   float d111 = dot(v111,p-x111);\n    \n   //interpolation curve vector \n   cp = 6.*cp*cp*cp*cp*cp - 15.*cp*cp*cp*cp+10.*cp*cp*cp;\n   \n    \n   d000 = mix(d000,d010,cp.y);\n   d100 = mix(d100,d110,cp.y);\n   \n   d001 = mix(d001,d011,cp.y);\n   d101 = mix(d101,d111,cp.y);\n   \n   return mix(mix(d000,d100,cp.x),mix(d001,d101,cp.x),cp.z);\n    \n}\n\n \nvec2 planet(vec3 p,vec3 c){\n   p-=c;\n   p.xz*=rot2D(iTime*0.1);\n   vec3 p1 = p; \n\n   float n =  noise3D(p*1.94)*.3;\n\n   return vec2(mix(length(p)-1.,n,.4),1); \n}\n\nvec2 ocean(vec3 p,vec3 c){\n   p-=c;\n   p.xz*=rot2D(iTime*0.1);\n    \n   float a1 = atan(p.y,p.x);  \n   float a2 = atan(p.z,p.y);  \n    \n   return vec2(mix(length(p)-1.,noise2D(vec2(p.y,atan(p.z,p.x))*15.)*0.02,0.5),2); \n}\n \n\nvoid cmp(inout vec2 a, vec2 b){\n   a = a.x<b.x?a:b;\n}\n\nvec2 map(vec3 p){\n  vec2 ref = vec2(1000.);\n  cmp(ref,planet(p,vec3(0)));\n  cmp(ref,ocean(p,vec3(0)));\n    \n  return ref;  \n}\n\n\nvec3 grad(vec3 p){\n   float m = map(p).x;\n   vec2 e = vec2(1,0)*0.001;\n   return -normalize(vec3(m-map(p+e.xyy).x,m-map(p+e.yxy).x,m-map(p+e.yyx).x));\n}\n\nvoid shading(inout vec3 col,vec3 lp,vec3 p,vec3 vd,inout float id){\n   vec3 n  = grad(p);\n   vec3 ld = normalize(lp-p);\n   vec3 rd = reflect(-ld,n);\n   vec3 hv = normalize(ld-vd);\n    \n   float nl = smoothstep(0.,1.,dot(n,ld));\n   float rl = clamp(dot(rd,-vd),0.,1.);\n   float fr = clamp(dot(hv,n),0.,1.);\n   fr = 0.2+0.8*pow(1.-fr,5.);\n   if(id==1.){\n       p.xz*=rot2D(iTime*0.1);\n       col += texture(iChannel0,vec2(atan(p.z,p.x)+PI*0.5,p.y*0.5)).xyz*getColor(length(p*p)*1.2+1.6)*nl;\n       \n   }else if(id==2.){\n       col += getColor(0.1)*nl+pow(rl*1.,550.)*getColor(0.6);\n   } \n \n}\n \nvoid atmosphere(inout Ray r,inout vec3 col,vec3 p,vec3 lp){\n   vec3 p1   = vec3(0); \n   vec3 ld   = vec3(0);\n   vec3 rd   = vec3(0);\n   vec3 n    = vec3(0); \n   float ar  = 1.5; \n   float t  = 5.;\n   float lv = 0.;\n   float tens = 0.;\n \n   for(int i=0;i<MAXIT;i++){\n       p1 = r.o+r.d*t;\n       \n       if(length(p1)-ar<=0.0001){\n           \n           tens+=exp(t)*0.00003;\n       \n       }else if(length(p1)<=length(p)){\n           ld = normalize(lp-p);\n           rd = reflect(r.d,normalize(p));  \n           break;\n       } \n       \n       t+=0.015; \n   }\n       \n    col+=vec3(0.4,0.8,0.9)*(tens*smoothstep(-0.2,1.,dot(ld,rd))); \n}\n\nvoid drawStars(inout vec3 col,vec2 uv,vec2 c){\n   uv-=c;\n    \n   uv*=9.8;\n   \n   float l =length(uv);\n   float arc = atan(uv.y,uv.x); \n     \n   float d = abs(dot(vec2(0,1),uv));\n   float d1 = abs(dot(vec2(1,0),uv));\n   float ctv = c.x*10.0;\n   // clip the star\n   d+=pow(l,1.1+0.6*cos(iTime*2.0+ctv));\n   d1+=pow(l,1.1+0.6*cos(iTime*2.0+ctv));\n   \n   float v =0.0005/l;  \n   // blend the star\n   v+=0.01/(d);\n   v+=0.01/(d1);\n   v=pow(v,1.6);\n    \n   col+=vec3(cos(iTime+ctv)*0.1+0.5,sin(iTime+ctv)*0.4+0.5,sin(iTime)*0.3+0.7)*v;\n}\n\nvoid drawStarGroup(inout vec3 col,vec2 uv,float starNum){\n    for (float i=0.0;i<starNum;i++){\n        drawStars(col,uv,vec2(i*0.2*sin(i),cos(i)*0.3));\n    }\n    \n}\n\nvoid rayTrace(inout Ray r,inout vec3 col,vec3 lp){\n   vec2 res = vec2(0);\n   vec3 p   = vec3(0); \n   vec3 n  = vec3(1.); \n   float t  = 0.;\n   \n   for(int i=0;i<MAXIT;i++){\n       p = r.o+r.d*t;\n       res = map(p);\n       if(t>=32.){\n           \n          break;\n       }\n       if(res.x<=0.0001){\n          shading(col,lp,p,r.d,res.y);\n         \n          break;\n       }\n      \n       t+=res.x;\n   \n   }\n   atmosphere(r,col,p,lp); \n    \n}\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n   vec3 look = normalize(tar-eye);\n   vec3 right = normalize(cross(vec3(0,1,0),look));\n   vec3 up    = normalize(cross(look,right));\n    \n   r.o = eye;\n   r.d = normalize(uv.x*right+uv.y*up +look);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv - vec2(0.5);\n    vec3 lp = vec3(10.0*sin(iTime*0.1),1,10.0*cos(iTime*0.1));\n    vec3 eye = vec3(0,1,-5);\n    vec3 tar = vec3(0,0,1);\n    vec3 col = vec3(0);\n    cuv.x*= iResolution.x/iResolution.y;\n    \n    Ray r;\n    \n    setCamera(r,eye,tar,cuv);\n    drawStarGroup(col,cuv,12.);\n    rayTrace(r,col,lp);\n    col = smoothstep(0.,1.,col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVfRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 270, 270, 349], [351, 351, 374, 374, 495], [497, 497, 554, 554, 665], [667, 667, 726, 726, 915], [917, 917, 976, 976, 1150], [1470, 1470, 1493, 1493, 2018], [2020, 2074, 2096, 2096, 3338], [3342, 3342, 3369, 3369, 3503], [3505, 3505, 3531, 3531, 3725], [3729, 3729, 3760, 3760, 3782], [3784, 3784, 3801, 3801, 3909], [3912, 3912, 3930, 3930, 4064], [4066, 4066, 4133, 4133, 4655], [4658, 4658, 4717, 4717, 5295], [5297, 5297, 5343, 5343, 5828], [5830, 5830, 5887, 5887, 5994], [5996, 5996, 6046, 6046, 6437], [6439, 6439, 6493, 6493, 6693], [6695, 6695, 6752, 6802, 7260]], "test": "error"}
{"id": "4lVyzh", "name": "Dancy Tree Doodle 3D", "author": "wyatt", "description": "I've been on this site for a little bit now, but I've always been too shy to ask: Did iq invent raymarching? or did he just popularize it with articles and make this site? All of that is very impressive.", "tags": ["raymarching", "kifs"], "likes": 71, "viewed": 1514, "published": "Public API", "date": "1545791021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926\nvec3 light;\nfloat ln (vec3 p, vec3 a, vec3 b, float R) { \n    float r = dot(p-a,b-a)/dot(b-a,b-a);\n    r = clamp(r,0.,1.);\n    p.x+= 0.2*sqrt(R)*smoothstep(1.,0.,abs(r*2.-1.))*cos(pi*(2.*iTime));\n    return length(p-a-(b-a)*r)-R*(1.5-0.4*r);\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat map (vec3 p) {\n    float l = length(p-light)-1e-2;\n    l = min(l,abs(p.y+0.4)-1e-2);\n    l = min(l,abs(p.z-0.4)-1e-2);\n    l = min(l,abs(p.x-0.7)-1e-2);\n    p.y += 0.4;\n    p.z += 0.1;\n    p.zx *= ro(.5*iTime);\n    vec2 rl = vec2(0.02,.25+ 0.01*sin(pi*4.*iTime));\n    for (int i = 1; i < 11; i++) {\n        \n        l = min(l,ln(p,vec3(0),vec3(0,rl.y,0),rl.x));\n    \tp.y -= rl.y;\n        p.xy *= ro(0.2*sin(3.1*iTime+float(i))+sin(0.222*iTime)*(-0.1*sin(0.4*pi*iTime)+sin(0.543*iTime)/max(float(i),2.)));\n        p.x = abs(p.x);\n        p.xy *= ro(0.6+0.4*sin(iTime)*sin(0.871*iTime)+0.05*float(i)*sin(2.*iTime));\n        p.zx *= ro(0.5*pi+0.2*sin(0.5278*iTime)+0.8*float(i)*(sin(0.1*iTime)*(sin(0.1*pi*iTime)+sin(0.333*iTime)+0.2*sin(1.292*iTime))));\n        \n        rl *= (.7+0.015*float(i)*(sin(iTime)+0.1*sin(4.*pi*iTime)));\n        \n        l=min(l,length(p)-0.15*sqrt(rl.x));\n    }\n\treturn l;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float o = 1e3;\n    for (int i = 0; i < 24; i++) {\n        float l = map(p);\n    \tp += l*d;\n        if (l < 1e-3)break;\n    }\n    return p;\n}\nvec3 norm (vec3 p) { // iq\n\t\tvec2 e = vec2 (.001,0.);\n\t\treturn normalize(vec3(\n\t\t\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\t\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\t\t\tmap(p+e.yyx) - map(p-e.yyx)\n\t\t\t));\n\t}\nvoid mainImage( out vec4 C, in vec2 U )\n{   vec2 R = iResolution.xy;\n    light = vec3(0.2*sin(iTime),0.5,-.5);\n    if (iMouse.z > 0.) light = vec3(vec2(-0.5,0.5)*0.+0.7*(iMouse.xy-0.5*R)/R.y,-.3);\n    \n    U = (U-0.5*R)/R.y;\n    vec3 p = vec3(0,0,-1);\n    vec3 d = normalize(vec3(U,1));\n    p =  march(p,d);\n    vec3 n = norm(p);\n\tC = 0.6+0.4*sin(1.1*vec4(1,2,3,4)*dot(d,n));\n    vec3 D = light-p;\n    d = normalize(D);\n    vec3 lp = march(p+d*1e-2,d);\n    C *= 2.5*(dot(d,n))*(.3+0.7*length(lp-p)/length(light-p));\n    C = atan(C)/pi*2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 77, 77, 264], [265, 265, 284, 284, 344], [345, 345, 365, 365, 1252], [1254, 1254, 1283, 1283, 1428], [1429, 1429, 1449, 1455, 1615], [1616, 1616, 1657, 1657, 2156]], "test": "timeout"}
{"id": "4lyBDV", "name": "Visualizing Raymarching", "author": "josemorval", "description": "Visualization of raymarching using 2D signed distance functions. With the mouse you can choose a direction for the \"camera\", located near bottom right corner. Automatically you see travel of the ray throught the distance field until it hits the \"world\".", "tags": ["2d", "raymarching", "tutorial", "steps", "section"], "likes": 17, "viewed": 594, "published": "Public API", "date": "1544042370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 10\n#define ANIMDIR mouse.x-mouse.y>0.75\n#define VELANIMDIR 0.5\n#define ANIMRAY false\n#define VELANIMRAY 10.\n\nfloat sdCircle(vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox(vec2 p, vec2 r){\n    vec2 d = abs(p)-r;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n    //return max(abs(p.x)-r.x,abs(p.y)-r.y);\n}\n\nfloat sdLine( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//Signed distance scene (one square and four circles)\nfloat scene(vec2 p){\n    \n    float res = sdCircle(p+vec2(-0.3,-0.5),0.25);\n    res = min(res,sdCircle(p+vec2(-1.5,-0.1),0.4));\n    res = min(res,sdCircle(p+vec2(0.3,0.2),0.1));\n    res = min(res,sdCircle(p+vec2(1.2,-0.7),0.2));\n    res = min(res,sdBox(p+vec2(1.2,-0.0),vec2(0.1,0.8)));\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * fragCoord.xy/iResolution.xy;\n    vec2 p = uv;\n    p.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    //Here we draw the scene\n    float res = scene(p);\n    \n    //We make some kind of posterize over distances\n    res = floor(res*15.)/15.;\n    \n    //Some colour based on distances\n    float att =(1.+0.1*(0.5+0.5*sin(-15.*abs(res)+3.*iTime)));\n    if(res<0.){\n    col = 5.*vec3(0.,0.5,1.)*abs(res)*att;\n    }else{\n    col = 1.*vec3(1.,0.5,0.)*(abs(res)*1.1)*att;\n    }\n    \n    vec2 inipos = vec2(1.1,-0.8);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    mouse.x *= iResolution.x/iResolution.y;\n    \n    //We decide if we like a direction vector animated (simple) or no\n    vec2 dir;\n    if(ANIMDIR){\n        float angle = 3.14159/1.3+1.6*sin(VELANIMDIR*iTime);\n        dir = normalize(vec2(cos(angle),sin(angle))-inipos);  \n    }else{\n    \tdir = normalize(vec2(2.*mouse.x,2.*mouse.y)-inipos);    \n    }\n    \n\t\n    //Here we \"fake\" a raymarching ray, but it is the core of 3D raymarching\n    //Because there no raymarching in 2D, in this case,each pixel knows automatically its distance to the scene\n    \n    float dis = 0.;\n    float c = 0.;\n    float a = 0.;\n    \n    vec2 pos = inipos;\n    for(int i=0;i<STEPS;i++){\n\t\t\n        //Animated raymarch\n        if(ANIMRAY && mod(floor(VELANIMRAY*iTime),float(STEPS))<float(i)){\n        \tbreak;   \n        }\n        \n        //Raymarch core/////\n        pos+=dis*dir;\n        dis = scene(pos);\n        if(dis<0.001) break;\n        ////////////////////\n        \n        //Drawing stuff\n        if(i==0){\n            //Camera position, a annulus with an animated radii\n            c = 1.-smoothstep(0.0,0.003,abs(sdCircle(sin(p-pos),0.05+0.005*sin(10.*iTime)))-0.005);\n        \tcol =  mix(col,vec3(1.,1.,1.),0.5*c);\n        }else{\n            //Steps points, color based on step number\n        \tc = sdCircle(p-pos,0.01);\n         \ta = 3.14159*float(i)/(float(STEPS)+1.);\n        \tcol =  mix(col,\n                   vec3(sin(a),cos(a),0.),\n                   (1.-step(0.,c)));   \n        }\n\n        \n        //Distance region circle: in raymarch you can move in any direction inside this circle\n        //because you have enough distance to move. The color is based in step number of raymarch\n        c = sdCircle(p-pos,dis);\n        col += mix(vec3(0.),0.2*vec3(sin(a),cos(a),0.),(1.-smoothstep(0.0,0.005,c)));\n        \n        //Distance region circumference: only for visual purposes\n        c = abs(sdCircle(p-pos,dis))-0.001;\n        col = mix(col,0.75*col,(1.-smoothstep(0.0,0.05,c)));\n        col += mix(vec3(0.),0.75*vec3(0.5,0.5,0.),(1.-smoothstep(0.0,0.005,c)));\n\n    }\n    \n    //Raymarch ray: only for visual purposes\n    c = sdLine(p,inipos,pos,0.001);\n    col = mix(col,0.75*col,(1.-smoothstep(0.0,0.05,c)));\n    col += mix(vec3(0.),0.5*vec3(1.,1.,1.),(1.-smoothstep(0.0,0.005,c)));\n    \n    \n    //Show the color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 155, 155, 181], [183, 183, 211, 211, 340], [342, 342, 391, 391, 518], [520, 574, 594, 594, 883]], "test": "ok"}
{"id": "4lyBWG", "name": "Object Hierarchy", "author": "gest", "description": "Experiment. The mouse wheel does not work. It's a pity!", "tags": ["sphere", "intersection", "lights", "hierarchy"], "likes": 3, "viewed": 126, "published": "Public", "date": "1543731079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\nfloat u_time;\nvec2  u_canvas;\nvec3  u_mouse;\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//\nstruct Camera {\n\t// \n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t// \n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\nstruct Material {\n\tvec3  colorAmbient;\n\tvec3  colorDiffuse;\n    vec3  colorSpecular;\n    float reflectance;\n    float shininess;\n};\n\n//     \nstruct Hit {\n    float\t distance;\t\t//   \n\tvec3\t position;\t\t//  \n\tvec3\t normal;\t\t//    \n    int\t\t id;\t\t\t// id  \n\tMaterial material;\t\t//  \n};\n\n//\nstruct Ray {\n\t// \n\tvec3  origin;\t\t// \n\tvec3  direction;\t// \n\tfloat near;\t\t\t//   \n\tfloat far;\t\t\t//   \n\tfloat epsilon;\t\t//\n\tint\t  steps;\t\t//  \n\t// \n\tbool  HIT;\t\t\t//   \n\tHit   hit;\t\t\t//  ,   \n};\n//  \nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//  \n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t// \n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\nstruct Light {\n    vec3  position;\n    vec3  color;\n\tfloat radius;\n};\n   \nstruct Sphere {\n\tvec3 \t center;\n    float \t radius;\n};\n\n// \t(    )\nmat4 vMatrix;\t\t\n//  (     )\nmat4 mMatrix;\n// - (      )\t\t\nmat4 vmMatrix;\t\t\n\n//------------- ------------------------------\nvoid translate (inout mat4 m, vec3 v) {\n\tmat4 tMat = mat4( 1,0,0,0,  0,1,0,0,  0,0,1,0,  v.x,v.y,v.z,1 );\n\tm = tMat * m;\n}\nvoid rotateX (inout mat4 m, float rad) {\n\tfloat c = cos(rad), s = sin(rad);\n\tmat4 tMat = mat4( 1,0,0,0,  0,c,s,0,  0,-s,c,0,  0,0,0,1 );\n\tm = tMat * m;\n}\nvoid rotateY (inout mat4 m, float rad) {\n\tfloat c = cos(rad), s = sin(rad);\n\tmat4 tMat = mat4( c,0,-s,0,  0,1,0,0,  s,0,c,0,  0,0,0,1 );\n\tm = tMat * m;\n}\nvoid rotateZ (inout mat4 m, float rad) {\n\tfloat c = cos(rad), s = sin(rad);\n\tmat4 tMat = mat4( c,s,0,0,  -s,c,0,0,  0,0,1,0,  0,0,0,1 );\n\tm = tMat * m;\n}\nvoid rotate (inout mat4 m, vec3 axis, float rad) {\n\tvec3 c = cos(axis*rad), s = sin(axis*rad);\n\tmat4 tMatX = mat4( 1,0,0,0,  0,c.x,s.x,0,  0,-s.x,c.x,0,  0,0,0,1 );\n\tmat4 tMatY = mat4( c.y,0,-s.y,0,  0,1,0,0,  s.y,0,c.y,0,  0,0,0,1 );\n\tmat4 tMatZ = mat4( c.z,s.z,0,0,  -s.z,c.z,0,0,  0,0,1,0,  0,0,0,1 );\n\tm = tMatX * tMatY * tMatZ * m;\n}\nvoid scale (inout mat4 m, vec3 s) {\n    mat4 tMat = mat4( s.x,0,0,0,  0,s.y,0,0,  0,0,s.z,0,  0,0,0,1 );\n\tm = tMat * m;\n}\nvoid transform(inout vec3 v, mat4 m) {\n\tv = (m * vec4(v, 1.0)).xyz;\n}\n//-------------------------------------------------------\n//   \nfloat intersectSphere(Ray ray, Sphere sphere){\n    vec3 d = ray.origin - sphere.center;\n    float A = dot(ray.direction, ray.direction);\n    float B = 2. * dot(ray.direction, d);\n    float C = dot(d, d) - sphere.radius * sphere.radius;\n    float D = B*B - 4.*A*C;\n    if (D < 0.0) return ray.far;\n    float t = -B - sqrt(D);\n\t// Closest intersection behind the ray\n\tfloat dist = (-B - sqrt(D)) / (2.0 * A);\n\tif (dist < 0.) dist = (-B + sqrt(D)) / (2.0 * A);\n\tif (dist < ray.near) return ray.far;\n \treturn dist;   \n}\n//  \nHit map (Ray ray) {\n\t// (    )\n\tHit hit;\n\t{\n\t\thit.distance = ray.far;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n//\t\thit.normal \t = vec3(0.0);\n//\t\thit.id \t\t = 0;\n//\t\thit.material = Material(vec3(0), vec3(0), vec3(0), 0.0, 0.0);\n\t}\n\t\n\tfloat d;\n\tSphere sphere;\n\t\n\t// \n\tsphere = Sphere(vec3(0), 20.0);\n\t// \n\tvMatrix = mat4(1);\t//  \n\t//  ( )\n\tmMatrix = mat4(1);\n\t// -\n\tmat4 vmMatrix_1 = vMatrix * mMatrix; //   1\n\t//    \n\ttransform (sphere.center, vmMatrix_1);\n\t//  \n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 1;\n\t\thit.material = Material(vec3(0.1), vec3(0.8, 0.8, 0.8), vec3(1.00), 1.0, 100.);\n\t}\n\n\n\t// \n\tsphere = Sphere(vec3(0), 5.0);\n\t// \n\tvMatrix = mat4(1);\t//  \n\t//  ( )\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix,vec3(40,0,0));\n\trotateY(mMatrix, u_time/6.);\n\t// -\n\tmat4 vmMatrix_2 = vMatrix * mMatrix; //   2\n\t//    \n\ttransform (sphere.center, vmMatrix_2);\n\t//  \n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 2;\n\t\thit.material = Material(vec3(0.1), vec3(0.3, 0.6, 0.4), vec3(0.20), 0.5, 14.);\n\t}\n\n\t// \n\tsphere = Sphere(vec3(0),  2.0);\n\t// \n\tvMatrix = vmMatrix_2; //   2\n\t//  ( )\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix, vec3(15,0,0));\n\trotateY(mMatrix, u_time);\n\t// -\n\tmat4 vmMatrix_3 = vMatrix * mMatrix; //   3\n\t//    \n\ttransform (sphere.center, vmMatrix_3);\n\t//  \n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 3;\n\t\thit.material = Material(vec3(0.1), vec3(0.2, 0.2, 0.8), vec3(0.30), 0.5, 14.);\n\t}\n\n\t// \n\tsphere = Sphere(vec3(0), 1.0);\n\t// \n\tvMatrix = vmMatrix_3;\t//   3\n\t//  ( )\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix, vec3(4,0,0));\n\trotateZ(mMatrix, u_time*2.);\n\t// - \n\tmat4 vmMatrix_4 = vMatrix * mMatrix; //   4\n\t//    \n\ttransform (sphere.center, vmMatrix_4);\n\t//  \n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 4;\n\t\thit.material = Material(vec3(0.1), vec3(0.4, 0.2, 0.4), vec3(0.80), 0.0, 14.);\n\t}\n\n\t// \n\tsphere = Sphere(vec3(0), 6.0);\n\t// \n\tvMatrix = mat4(1); //  \n\t//  ( )\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix,vec3(30,10,0));\n\trotateY(mMatrix, u_time/3. + PI);\n\t// -\n\tmat4 vmMatrix_5 = vMatrix * mMatrix; //   5\n\t//    \n\ttransform (sphere.center, vmMatrix_5);\n\t//  \n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 5;\n\t\thit.material = Material(vec3(0.1), vec3(0.2, 0.2, 0.8), vec3(0.30), 1.0, 14.);\n\t}\n\n\t// \n\tsphere = Sphere(vec3(0),  2.0);\n\t// \n\tvMatrix = vmMatrix_5; //   5\n\t//  ( )\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix, vec3(0,10,0));\n\trotateX(mMatrix, u_time);\n\t// - \n\tmat4 vmMatrix_6 = vMatrix * mMatrix; //   6\n\t//    \n\ttransform (sphere.center, vmMatrix_6);\n\t//  \n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 6;\n\t\thit.material = Material(vec3(0.1), vec3(0.4, 0.2, 0.4), vec3(0.80), 0.0, 14.);\n\t}\n\n\t// \n\tsphere = Sphere(vec3(0), 6.0);\n\t// \n\tvMatrix = mat4(1);\t//  \n\t//  ( )\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix,vec3(30,-10,0));\n\trotateY(mMatrix, u_time + PI);\n\tscale(mMatrix, vec3(2,1,1));\n\t// - \n\tmat4 vmMatrix_7 = vMatrix * mMatrix;//   7\n\t//    \n\ttransform (sphere.center, vmMatrix_7);\n\t//  \n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 7;\n\t\thit.material = Material(vec3(0.1), vec3(0.4, 0.2, 0.4), vec3(0.80), 0.0, 14.);\n\t}\n\n\t// \n\tsphere = Sphere(vec3(0,0,0),  2.0);\n\t// \n\tvMatrix = vmMatrix_7; //   7\n\t//  ( )\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix, vec3(0,10,0));\n\trotateX(mMatrix, u_time*2.);\n\tscale(mMatrix, vec3(1,2,1));\n\t// - \n\tmat4 vmMatrix_8 = vMatrix * mMatrix;//   8\n\t//    \n\ttransform (sphere.center, vmMatrix_8);\n\t//  \n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 8;\n\t\thit.material = Material(vec3(0.1), vec3(0.8, 0.8, 0.8), vec3(1.00), 1.0, 14.);\n\t}\n\n\treturn hit;\n}\n//     \nvoid rayMarch(inout Ray ray) {\n\t// \n\tray.HIT = false;\n\t//  \n\tRay ray1 = ray;\n\tray1.origin = ray.origin + ray.near * ray.direction;\n\t//    \n\tray.hit = map(ray1);\n\t\n\tif (ray.hit.distance >= ray.near && ray.hit.distance < ray.far) {\n\t\tray.HIT = true;\n\t}\n}\n//\nfloat hardShadow(vec3 p, Light light){\n\tfloat shadow = 0.0; // \n\t//         \n\tRay ray;\n\t{\n\t\tray.origin \t\t= p;\n\t\tray.direction \t= normalize(light.position - p);\n\t\tray.near \t\t= 0.001; //    \n\t\tray.far\t\t\t= Infinity;\n\t}\n\trayMarch(ray);\n\t\n\tif (ray.HIT) shadow = 1.0; //    \n\n    return shadow;\n}\n//  ( )\nvec3 lighting(vec3 p, vec3 normal, vec3 camPos, Light light, Material material, float shadow) {\n\tvec3 color = vec3(0);\n\t\n\tvec3 rayDirection = normalize(p - camPos); \t\t\t//  ( ray.direction)\n\tvec3 lightDir = normalize(light.position - p);  \t//        \n\tvec3 lightDir_reflect = reflect(lightDir, normal);\t//  \n\t//   \n\tfloat diffuse = max(0.0, dot(normal, lightDir));\t\n\t//  \n\tfloat specular = pow(max(dot(rayDirection, lightDir_reflect), 0.0), material.shininess);\n\t//  \n\tcolor += material.colorAmbient;\n\t//  \n\tcolor += light.color * diffuse * material.colorDiffuse * (1. - shadow);\n\t// \n\tcolor += light.color * specular * material.colorSpecular * (1. - shadow);\n\t//  \n\treturn color;\n}\n//  \nvec3  drawLight(vec3 color, Ray ray, Light light){\n    vec3 v = ray.origin - light.position;\n\tvec3 v_proj = dot(v, ray.direction) * ray.direction;\n    float d = length(v - v_proj);\n    \n    if (d < light.radius){\n       \tfloat a = 1.0 - d/light.radius;\n       \tcolor =  mix(color, light.color, pow(a, 4.0));\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    //\n    u_time = iTime;\n    u_canvas = iResolution.xy;\n    u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv - 0.5;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n    mouse.xy = (mouse.xy==vec2(0)) ? (vec2(0)) : (mouse.xy-0.5);\n\n    const int numLights = 5;\n    // \n    Light lights[5];\n    lights[0] = Light(vec3(0), vec3(0.9, 0.9, 0.9), 10.0);\n    lights[1] = Light(vec3(0), vec3(0.3, 0.3, 0.3),  5.0);\n    lights[2] = Light(vec3(0), vec3(0.9, 0.1, 0.1), 10.0);\n    lights[3] = Light(vec3(0), vec3(0.1, 0.9, 0.1), 10.0);\n    lights[4] = Light(vec3(0), vec3(0.1, 0.1, 0.9), 10.0);\n\n    //   (  )\n    vMatrix = mat4(1);\n    rotateY(vMatrix, PI/2.);\n    translate(vMatrix, vec3(0,0,100));\n\n    //  \n    mMatrix = mat4(1);\n    //  - (    )\n    vmMatrix = vMatrix * mMatrix;\n    //   0\n    transform(lights[0].position, vmMatrix);\n\n    //  \n    mMatrix = mat4(1);\n    translate(mMatrix, vec3(0,7,0));\n    rotateX(mMatrix, u_time);\n    //  - (    )\n    vmMatrix = vMatrix * mMatrix;\n    //   2\n    transform(lights[1].position, vmMatrix);\n\n    rotateY(vMatrix, PI/2.);\n\n    //  \n    mMatrix = mat4(1);\n    //  - (    )\n    vmMatrix = vMatrix * mMatrix;\n    //   1\n    transform(lights[2].position, vmMatrix);\n\n    rotateY(vMatrix, PI/2.);\n\n    //  \n    mMatrix = mat4(1);\n    //  - (    )\n    vmMatrix = vMatrix * mMatrix;\n    //   1\n    transform(lights[3].position, vmMatrix);\n\n    rotateY(vMatrix, PI/2.);\n\n    //  \n    mMatrix = mat4(1);\n    //  - (    )\n    vmMatrix = vMatrix * mMatrix;\n    //   1\n    transform(lights[4].position, vmMatrix);\n\n    Camera cam;\n    {\n        cam.fov     = 70.;\n        cam.aspect  = aspect;\n        /*\t\t\t\t\n        //  \n        float theta \t= mouse.x*2.*PI;\n        float phi\t\t= mouse.y*PI;\n        float radius  \t= 50. + mouse.z;\n        cam.origin  = vec3(\n            radius * sin(theta) * cos(phi), \n            radius * sin(theta) * sin(phi), \n            radius * cos(theta) \n        );\n\t\t*/\t\n\n        cam.origin  = vec3(0, 0, 110.);\n\n        vMatrix = mat4(1);\n        rotateY(vMatrix, mouse.x*2.*PI - u_time/10.);\n\n        mat4 mMatrix = mat4(1);\n        rotateX(mMatrix, mouse.y*PI);\n        //translate(mMatrix, vec3(0, 0, mouse.z)); //Shadertoy does not support mouse wheel\n\n        transform(cam.origin, vMatrix * mMatrix);\n\n        cam.target  = vec3(0,0,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.001;\n        ray.far  \t= Infinity;\n    }\n\n    // \n    vec3 color = vec3(0);\n\n    vec3 colorTotal = vec3(0.0);\n    vec3 colorReflect = vec3(1.0);\n    vec3 colorLighting = vec3(0.0);\n\n    // \n    float ref = 1.0;\n\n\n    // \n    for (int j = 0; j < 3; j++) {\n\n        rayMarch(ray);\n\n\n        // \n        vec3 colorLighting = vec3(0.0);\n\n        if ( !ray.HIT) {\n            //     (  )\n            if ( j==0 ) {\n                for (int i = 0; i < numLights; i++){\n                    if (dot(ray.direction, normalize(ray.origin - lights[i].position))<=0.) {\n                        color = drawLight(color, ray, lights[i]);\n                    }\n                }\n            }\n            break;\n        }\n\n\n        for (int i = 0; i < numLights; i++){\n            // \n            float shadow = hardShadow(ray.hit.position, lights[i]);\n            // \n            colorLighting += lighting(ray.hit.position, ray.hit.normal, ray.origin, lights[i], ray.hit.material, shadow);\n\n            //        \n            Ray ray2;\n            {\n                ray2.origin \t= lights[i].position;\n                ray2.direction \t= normalize(ray.origin - lights[i].position);\n                ray2.near \t\t= 0.0;\n                ray2.far  \t\t= Infinity;\n            }\n            rayMarch (ray2);\n\n            if ( !ray2.HIT ) { //  \n                //  \n                color = drawLight(color, ray, lights[i]);\n            }\n        }\n        colorLighting /= float(numLights);\n\n\n        colorReflect *= pow(ray.hit.material.colorDiffuse, vec3(1. - ray.hit.material.reflectance));\n        colorTotal += colorReflect * colorLighting;\n\n        ref *= ray.hit.material.reflectance;\n        if (ref<0.1) break;\n\n        //  - \n        ray.origin \t\t= ray.hit.position;\n        ray.direction \t= reflect(ray.direction, ray.hit.normal);\n    }\n    color += colorTotal;\n    //-\n    color = pow( color, vec3(0.4545) );\n\n\n    GL_FragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1608, 1657, 1700, 1764, 2243], [2832, 2923, 2962, 2962, 3045], [3046, 3046, 3086, 3086, 3199], [3200, 3200, 3240, 3240, 3353], [3354, 3354, 3394, 3394, 3507], [3508, 3508, 3558, 3558, 3846], [3847, 3847, 3882, 3882, 3968], [3969, 3969, 4007, 4007, 4038], [4039, 4149, 4195, 4195, 4664], [4665, 4708, 4727, 4814, 12243], [12244, 12324, 12354, 12389, 12736], [12737, 12748, 12786, 12786, 13268], [13269, 13325, 13420, 13420, 14492], [14493, 14534, 14584, 14584, 14867], [14869, 14869, 14932, 14953, 21131]], "test": "error"}
{"id": "4sVfzd", "name": "FBM Learning", "author": "felipunkerito", "description": "learning from BigWingz", "tags": ["2d", "noise", "fbm", "valuenoise"], "likes": 8, "viewed": 542, "published": "Public API", "date": "1544433557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( vec2 a )\n{\n\n    return fract( sin( a.x * 3433.8 + a.y * 3843.98 ) * 45933.8 );\n\n}\n\nfloat noise( vec2 uv )\n{\n    \n    vec2 lv = fract( uv );\n    lv = lv * lv * ( 3.0 - 2.0 * lv );\n    vec2 id = floor( uv );\n    \n    float bl = hash( id );\n    float br = hash( id + vec2( 1, 0 ) );\n    float b = mix( bl, br, lv.x );\n    \n    float tl = hash( id + vec2( 0, 1 ) );\n    float tr = hash( id + vec2( 1 ) );\n    float t = mix( tl, tr, lv.x );\n    \n    float c = mix( b, t, lv.y );\n    \n    return c;\n\n}\n\nfloat fbm( vec2 uv )\n{\n    \n    vec2 mou = iMouse.xy / iResolution.y;\n\n\tfloat f = noise( uv * 4.0 );\n    f += noise( uv * 8.0 ) * 0.5;  \n    f += noise( uv * 16. ) * 0.25; \n    f += noise( uv * 32. ) * 0.125; \n    f += noise( uv * 64. ) * 0.0625;\n    f /= 2.0;\n    \n    return f;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 mou = iMouse.xy / iResolution.y;\n    vec2 q = vec2( 0.0 );\n    vec2 r = vec2( 0.0 );\n    \n    float tim = iTime * 0.2;\n    \n    float a = fbm( uv + fbm( uv + mod( tim, 200.0 ) + fbm( uv ) ) );\n    float b = fbm( uv + vec2( mou ) + fbm( uv + mod( tim, 200.0 ) + fbm( uv ) ) );\n    \n    vec3 col = vec3( a );\n    \n    //vec3 col = vec3( mix( r.y, q.x, c ) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVfzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 93], [95, 95, 119, 119, 507], [509, 509, 531, 531, 791], [793, 793, 850, 850, 1347]], "test": "timeout"}
{"id": "4tdcRl", "name": "Plasmacones", "author": "Peetu", "description": "some cones swimming back and forth in plasma", "tags": ["plasma", "cones"], "likes": 1, "viewed": 51, "published": "Public", "date": "1545345592", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.,78.)))*\n        43758.);\n}\n\nvec3 normaliz(vec3 a) {\n    float l = sqrt(a.x * a.x + a.y * a.y);\n    a /= l; \n    return a;\n}\n\nfloat dotProduct(vec3 a, vec3 b) {\n    a = normaliz(a);\n    b = normaliz(b);\n    \n    return a.x * b.x + a.y * b.y;\n}\n\nfloat circle (float bx, float by, float r, float px, float py) {\n    float y = py - by;\n    float x = px - bx;\n    float d = y*y + x*x;\n    \n    if(d > r) {\n     \treturn 0.0;\n    };\n        \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = vec3(px - bx, py - by, 0.0);\n    float brightness = dotProduct(up, dir) / 3.0 + .5;\n        \n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n\t//plasma\n    float f0 = (sin(iTime * 2. + uv.x * 21.) + 1.) / 2.;\n    \n    float f1 = sin(9. * (uv.x * sin(iTime / 6.)+uv.y*cos(iTime / 2.)));\n    \n    float x = uv.x - 0.5f * cos(iTime * 1.5)* .2;\n    float y = uv.y - 0.5f * sin(iTime * 2.) * .2;\n    \n    float d = sqrt(x*x + y*y);\n    \n    float f2 = (sin(iTime * 1.5 + d * 41.) + 1.) / 2.;\n    \n    float i = (f0 + f1 + f2) / 3.;\n    \n    vec4 color = vec4(i, cos(i * 3.14f), sin(i * 1.8f), 1.) * .5;\n    \n    //cones\n    float brightness = 0.0;\n    for(int j = 1; j < 5; j++) {\n        for(int i = 0; i < 10; i++) {\n            float x = sin((iTime + 10.) / 2.0 *\n                          random(vec2(i, j))) + 1.0;\n            if(brightness == 0.0){\n                brightness = circle(\n                    x, \n              \t\tfloat(i) * 0.1 + sin(float(j) * 0.1) * 0.5,\n                    0.025 / float(j), \n                    uv.x,\n                    uv.y\n                );\n            }\n        }\n    }\n    \n    if(brightness != 0.0){\n    \tcolor += vec4(brightness - 0.5);   \n    }\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdcRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 142, 142, 214], [216, 216, 250, 250, 333], [335, 335, 399, 399, 693], [695, 695, 752, 802, 1923]], "test": "ok"}
{"id": "4tGBDd", "name": " 2D Clouds (test2)", "author": "RaduBT", "description": "https://www.shadertoy.com/view/4tdSWr", "tags": ["fractal", "clouds"], "likes": 9, "viewed": 883, "published": "Public API", "date": "1544455455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// original : https://www.shadertoy.com/view/4tdSWr\n\nconst float cloudscale = 1.71;\nconst float speed = 0.02;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.22, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.2);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time*texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).y;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    // Music fft\n    \n    vec2 pr = fragCoord.xy/iResolution.xy;\n\n    vec3 col = texture( iChannel0, pr ).xyz;\n    //vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n    \n    col *= 0.5 + 0.5*pow( 16.0*pr.x*pr.y*(1.0-pr.x)*(1.0-pr.y), 0.05*texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).x );\n    \n    float fft = (((texture( iChannel0, vec2(pr.y+1.0, 1.0) ).x)) * 1.21);\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f*.1*fft;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time; \n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}", "image_inputs": [{"id": "ltsGD7", "previewfilepath": "https://soundcloud.com/oddlingmusic/hotel-pools-oddling-remain", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/oddlingmusic/hotel-pools-oddling-remain", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 395, 416, 416, 529], [531, 531, 557, 557, 1081], [1083, 1083, 1102, 1102, 1256], [1310, 1310, 1367, 1367, 3442]], "test": "error"}
{"id": "4tGBDG", "name": "[TDF2018]Traveler 2", "author": "kaneta", "description": "TokyoDemoFest 2018 GLSL Graphics Compo 1st place.", "tags": ["3d", "raymarching", "tdf"], "likes": 70, "viewed": 5587, "published": "Public API", "date": "1543745948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307\n#define PI 3.141592654\n#define HALF_PI 1.5707963267948966\n#define U(z,w) (mix(z,w,step(w.x,z.x)))\n\n#define MAT_WING  1.0\n#define MAT_BODY  2.0\n#define MAT_STAGE 3.0\n\n#define saturate(x) (clamp(x, 0.0, 1.0))\n\n#define BPM (130.)\n\nconst int Iterations = 3;\n\nfloat orgBeat, beat, sceneBeat, kick, hihat, snare;\nfloat stageScale;\nfloat edgeOnly;\nvec3 fogColor;\nmat3 sphereRot, stageRot, stageRot2;\nvec3 ray;\nvec3 ro, ta, sp;\nvec3 cameraLight, stageLight, travelerLight;\nvec3 stageFlareCol, travelerFlareCol;\nfloat stageFlareIntensity, travelerFlareIntensity, stageFlareExp, travelerFlareExp;\nfloat shadeIntensity, glowIntensity, particleIntensity;\nfloat stageFold, stageRotateZ;\nfloat particle1Intensity, particle2Intensity;\nfloat switchTraveler;\nfloat glitchIntensity;\nvec3 glitchColor;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nfloat sm2(float start, float end, float t, float bs, float es)\n{\n    return smoothstep(start, start + bs, t) - smoothstep(end - es, end, t);\n}\n\nvec3 hash3( vec3 p ){\n    vec3 q = vec3(dot(p,vec3(127.1,311.7, 114.5)), dot(p,vec3(269.5,183.3, 191.9)), dot(p,vec3(419.2,371.9, 514.1)));\n    return fract(sin(q)*43758.5453);\n}\n\nmat3 rotateMat(float roll, float pitch, float yaw)\n{\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n\n    return mat3(cp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n                cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n                -sp, sr * cp, cr * cp);\n}\n\nfloat stepUp(float t, float len, float smo)\n{\n    float tt = mod(t += smo, len);\n    float stp = floor(t / len) - 1.0;\n    return smoothstep(0.0, smo, tt) + stp;\n}\n\nfloat pingPong(float t, float len, float smo)\n{\n    t = mod(t + smo, len * 2.);\n    return 1.0 - (smoothstep(0., smo, t) - smoothstep(len, len + smo, t));\n}\n\nfloat glowTime(vec3 p)\n{\n    float t = mix(beat, beat - 45.0, step(44.0, beat));\n    t = mix(t, mod(beat - 53.0, 8.), step(108.0, beat));\n    t = mix(t, beat - 177.0, step(176.0, beat) * step(beat, 184.0));\n    t = mix(t, mod(beat - 177.0, 8.), step(184.0, beat) * step(beat, 224.0));\n    t = mix(t, -1.0, saturate(step(beat, 44.0) + (step(52.0, beat) * step(beat, 108.0)) + step(224.0, beat)));\n    return t;\n}\n\nfloat patternIntensity(vec3 p)\n{\n    float t = beat - 28.0;\n    if (t < 0.0) {\n        return 0.0;\n    }\n    t -= 2.5;\n    float len = distance(sp, p);\n    return sm(0.0, 2.5, mod(len - t * 1.5, 6.0), .5);\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat de(vec3 p, mat3 rot, float scale) {\n    vec3 offset = vec3(1,1,1);\n\n    float freq = 64.0;\n    for (int i=0; i<Iterations; i++) {\n        if (i != 0) {\n            p*=rot;\n        }\n        p = abs(p);\n\n        // ->->->->->->\n        float b = mix(beat - 44., beat - 192.0, step(176.0, beat));\n        b = mix(b, 0.0, step(beat, 44.0));\n        b = mix(b, mod(beat, 8.0) + 64.0, step(108.0, beat) * step(beat, 176.0));\n        p.yx = mix(p.yx, p.xy, (1.0 - pingPong(b, freq * 0.25, 1.0)) * step(p.x, p.y));\n        p.xz = mix(p.xz, p.zx, (1.0 - pingPong(b, freq * 0.75, 1.0)) * step(p.x, p.z));\n        p.yz = mix(p.yz, p.zy, (1.0 - saturate(pingPong(mod(b, freq * 0.75), freq * 0.25, 1.0) - step(freq * 0.75 - 1.0, mod(b, freq*0.75)))) * step(p.y, p.z));\n\n        p.z -= 0.5*offset.z*(scale-1.)/scale;\n        p.z = -abs(-p.z);\n        p.z += 0.5*offset.z*(scale-1.)/scale;\n\n        p.xy = scale*p.xy - offset.xy*(scale-1.);\n        p.z = scale*p.z;\n    }\n\n    vec3 d = abs(p) - vec3(1.,1.,1.);\n    float distance = length(vec3(max(d, vec3(0.0))));\n    distance *= pow(scale, -float(Iterations));\n    \n    return distance;\n}\n\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = TAU / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\nvec2 distStage(vec3 p, mat3 rot, float scale)\n{\n    p.xy = (p.xy - 0.75) * rotate(p.z * stageRotateZ) + 0.75;\n    p.xy = foldRotate(p.xy - 0.75, stageFold) + 0.75;\n    p = mod(p, 1.5) - 0.75;\n    float d = de(p, rot, scale);\n    d = mix(d, 100., step(144.0, beat) * step(beat, 176.0));\n    return vec2(d, MAT_STAGE);\n}\n\nvec2 distSphere(vec3 p)\n{\n    float wing = sphere(p, 0.1);\n    float b1 = sdBox(p, vec3(10.0, 0.02, 10.0));\n    float b2 = sdBox(p, vec3(0.02, 10.0, 10.0));\n    float b3 = sdBox(p, vec3(10.0, 10.0, 0.02));\n    float s = sphere(p, 0.098);\n    wing = max(-b1, wing);\n    wing = max(-b2, wing);\n    wing = max(-b3, wing);\n    wing = max(-s, wing);\n\n    vec2 w = vec2(wing, MAT_WING);\n    vec2 body = vec2(sphere(p, 0.08), MAT_BODY);\n    return U(w, body);\n}\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n/*float ifs(vec3 p) {\n    p *= 15.;\n\tfor(int i = 0; i < 3; i++) {\n        p.xy *= rot(0.8 + .8*stepUp(beat + 1.0, 2.0, 0.5));\n        p.xz *= rot(0.4 + .4*stepUp(beat, 2.0, 0.5));\n\t\tp = abs(p);\n\t\tp = 2.0*p - 1.0;\n\t}\n\treturn sdBox(p, vec3(.9))*pow(2.0, -3.0) / 15.0;\n}*/\n\nvec2 distMetaBall(vec3 p)\n{\n    float s1 = sphere((p + vec3(sin(beat) * 0.1, sin(beat) * 0.1, 0.)), 0.05);\n    float s2 = sphere((p + vec3(0., sin(beat * 0.5) * 0.1, sin(beat * 0.5) * 0.1)) , 0.04);\n    float s3 = sphere((p + vec3(sin(beat * 0.25) * 0.1, 0., sin(beat * 0.25) * 0.1)), 0.03);\n    float d = smin(s3, smin(s1, s2, .1), .1);\n    return vec2(d, MAT_WING);\n}\n\nvec2 distTorus(vec3 p)\n{\n    mat3 m1 = rotateMat(beat * 0.1, beat, beat * 0.7);\n    mat3 m2 = rotateMat(beat, beat * 0.5, beat * 0.25);\n    mat3 m3 = rotateMat(beat * 0.3, beat, beat * 0.8);\n    float t1 = sdTorus(p * m1, vec2(0.1, 0.01));\n    float t2 = sdTorus(p * m2, vec2(0.08, 0.005));\n    float t3 = sdTorus(p * m3, vec2(0.06, 0.004));\n    return vec2(min(t3, min(t1, t2)), MAT_WING);\n}\n\nvec2 distBox(vec3 p)\n{\n    float i = sdBox(p, vec3(.06));\n    return vec2(i, MAT_WING);\n}\n\nvec2 distTraveler(vec3 p)\n{\n    return distSphere(p);\n}\n\nvec2 distTraveler2(vec3 p)\n{\n    vec2 d1 = distMetaBall(p);\n    vec2 d3 = distTorus(p);\n    vec2 d2 = distBox(p);\n    float s = mod(stepUp(beat, 6.0, 3.0), 3.0);\n    vec2 d = d1;\n    d.x = mix(d.x, d2.x, saturate(s));\n    d.x = mix(d.x, d3.x, saturate(s - 1.0));\n    d.x = mix(d.x, d1.x, saturate(s - 2.0));\n    return d;\n}\n\nvec2 distAll(vec3 p)\n{\n    vec2 st1 = distStage(p, stageRot, stageScale);\n    vec2 st2 = distStage(p, stageRot2 * stageRot, stageScale);\n    vec2 tr = distTraveler((p - sp) * sphereRot);\n    vec2 tr2 = distTraveler2((p - sp) * sphereRot);\n\n    vec2 trd = tr;\n    trd = mix(trd, tr2, step(0.75 + switchTraveler* 0.1, p.y));\n    trd.x = mix(trd.x, tr2.x, saturate(beat - 208.));\n    trd.x = mix(trd.x, tr.x, saturate(beat - 224.));\n    trd.x *= 0.9;\n\n    float visibleStage = step(176.0, beat) * step(max(beat - 177.0, 0.0) * 1.7, distance(p, sp));\n    st1.x = mix(st1.x, 100.0, visibleStage);\n    st2.x = mix(st2.x, 100.0, visibleStage);\n    return U(trd, U(st1, st2));\n}\n\nvec2 distGlow(vec3 p)\n{\n    vec2 st1 = distStage(p, stageRot, stageScale);\n    vec2 st2 = distStage(p, stageRot2 * stageRot, stageScale);\n\n    float gt = glowTime(p);\n\n    float frontSp = sphere(p - sp, gt + 1.);\n    float backSp = sphere(p - sp, gt);\n    float cut = max(frontSp, -backSp);\n    vec2 st = U(st1, st2);\n    st.x = max(st.x, cut);\n    return st;\n}\n\nfloat distCubeParticle(vec3 pos)\n{\n    pos.y -= beat * 0.25;\n    vec3 id = floor(pos / 1.);\n    pos = mod(pos, 1.) - 0.5;\n    vec3 rnd = hash3(id) * 2.0 - 1.0;\n    mat3 rot = rotateMat(rnd.x * beat * 2.0, rnd.y * beat * 2.0, rnd.z * beat * 2.0);\n    float d = sdBox((pos + rnd * 0.25) * rot, vec3(.025));\n    d = mix(d, .5, step(rnd.x, -0.7));\n    return d;\n}\n\nfloat distSphereParticle(vec3 pos)\n{\n    pos.y -= beat * 0.4;\n    vec3 id = floor(pos / 0.4);\n    pos = mod(pos, 0.4) - 0.2;\n    vec3 rnd = hash3(id) * 2.0 - 1.0;\n    mat3 rot = rotateMat(rnd.x * beat * 2.0, rnd.y * beat * 2.0, rnd.z * beat * 2.0);\n    float d = sphere((pos * rot + rnd * 0.1), 0.01);\n    d = mix(d, .1, step(rnd.x, 0.0));\n    return d;\n}\n\n/*\nvec3 normal(vec3 pos, float e)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize( vec3(\n           distAll(pos+eps.xyy).x - distAll(pos-eps.xyy).x,\n           distAll(pos+eps.yxy).x - distAll(pos-eps.yxy).x,\n           distAll(pos+eps.yyx).x - distAll(pos-eps.yyx).x ) );\n}\n*/\n\nvec3 normal( in vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*distAll( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*distAll( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*distAll( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*distAll( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<8; i++ )\n    {\n        float h = distAll( ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.05, 0.2 );\n        if( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y),0.0) + length(max(d,0.0));\n}\n\nfloat tex(vec2 p, float z)\n{\n    vec2 q = (fract(p / 10.0) - 0.5) * 10.0;\n    float d = 9999.0;\n    for (int i = 0; i < 3; ++i) {\n        q = abs(q) - 0.5;\n        q *= rot(0.785398);\n        q = abs(q) - 0.5;\n        q *= rot(z * 0.5);\n        float k = sdRect(q, vec2(1.0, 0.55 + q.x));\n        d = min(d, k);\n    }\n    float f = 1.0 / (1.0 + abs(d));\n    return pow(f, 16.0) + smoothstep(0.95, 1.0, f);\n}\n\nvec3 light(vec3 pos, vec3 normal, vec3 ray, vec3 col, vec3 lpos, vec3 diffuse, vec3 specular, float smoothness)\n{\n    vec3 lvec = normalize(lpos - pos);\n    vec3 hvec = normalize(lvec - ray);\n    float llen = length(lpos - pos);\n    vec3 diff = diffuse * col * (dot(normal, lvec) * 0.5 + 0.5)  * (1.0 / PI);\n\n    float bpnorm = ( smoothness + 2.0 ) / ( 2.0 * PI );\n    vec3 spec = specular * col * bpnorm * pow( max( 0.0, dot( normal, hvec ) ), smoothness );\n\n    return vec3(diff + spec) / (llen * llen);\n}\n\nvec3 shade(vec3 pos, vec3 normal, vec3 ray, vec3 diffuse, vec3 specular, float smoothness)\n{\n    vec3 col = light(pos, normal, ray, cameraLight * 2.0, ro, diffuse, specular, smoothness);\n    col += light(pos, normal, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), diffuse, specular, smoothness);\n    return col;\n}\n\nvec3 rgb2hsv(vec3 hsv)\n{\n\tvec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(vec3(hsv.x) + t.xyz) * 6.0 - vec3(t.w));\n\treturn hsv.z * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), hsv.y);\n}\n\nvec3 materialize(vec3 ro, vec3 ray, float depth, vec2 mat)\n{\n    vec3 pos = ro + ray * depth;\n    vec3 nor = normal(pos, 0.0025);\n    vec3 spLocalNormal = normalize((pos - sp) * sphereRot);\n    vec3 col = vec3(0.);\n\n    vec3 coord = mix(19.3602379925 * spLocalNormal, pos * 9.3602379925, step(MAT_BODY, mat.y));\n    vec3 pattern = vec3(tex(coord.zy, 113.09),  tex(coord.xz, 113.09),  tex(coord.xy, 113.09));\n\n    if (mat.y == MAT_WING) {\n        float wing_pattern = saturate(pattern.x + pattern.y + pattern.z);\n        vec3 cameraLightCol = light(pos, nor, ray, cameraLight * 2.0, ro, vec3(.1), vec3(.1), mix(5.0, 100.0, wing_pattern));\n        vec3 stageLightCol = light(pos, nor, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), vec3(.1), vec3(.1), mix(5.0, 100.0, wing_pattern));\n        col += cameraLightCol + stageLightCol;\n\n        col += vec3(1.0, 0.25, 0.35) * 1.3 * wing_pattern * (cos(beat * 0.5) * 0.5 + 1.0);\n    } else if (mat.y == MAT_BODY) {\n        col += vec3(1.0, 0.25, 0.35) * 1. * saturate(cos(beat * 0.5) * 0.5 + 1.0);\n    } else if (mat.y == MAT_STAGE) {\n        vec3 lpos = ro + vec3(0.0, 0.0, 2.0);\n        vec3 lvec = normalize(lpos - pos);\n\n        vec3 cameraLightCol = light(pos, nor, ray, cameraLight * 2.0, ro, vec3(1.), vec3(1.), 25.);\n        vec3 stageLightCol = light(pos, nor, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), vec3(1.), vec3(1.), 25.);\n        float sha = (softshadow(pos, lvec, 0.01, length(lpos - pos), 4.0) + mix(.2, .4, step(160.0, beat)));\n\n        // \n        float noShade = 0.0;\n        noShade = step(distance(pos, sp), sceneBeat) * step(45.0, beat);\n\n        float wing_pattern = pow(saturate(pattern.x + pattern.y + pattern.z), 1.5) * 1.2;\n        col += ((cameraLightCol + stageLightCol * sha + light(pos, nor, ray, travelerLight, sp, vec3(1.), vec3(1.), mix(25., 100., step(176.0, beat)))) * edgeOnly * noShade + max(wing_pattern, 0.0) * (mix(vec3(0.1,0.2,0.4), rgb2hsv(vec3(pos.z * 1.0 + beat * 0.1, .85, 1.5)), step(160.0, beat))) * 4.0 * patternIntensity(pos)) * glowIntensity;\n    }\n\n    return mix(col, fogColor, pow(depth * 0.018, 2.1));\n}\n\nvec3 glowTrace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.);\n    for (int i = 0; i < 16; i++) {\n        vec3 p = ro+ray*t;\n        float len = distance(sp, p);\n        float gt = glowTime(p);\n\n        // -1.0\n        if (gt < 0.0) {\n            break;\n        }\n\n        vec3 h = hash3(floor(p * 30.0) / 30.0) * 2.0 - 1.0;\n        float val = 1.0 - sm(gt, gt + 2.0, len, .25);\n        // TODO: sm\n        vec2 res = distGlow(p + h * 0.15 * val);\n        col += saturate(0.002 / res.x) * rgb2hsv(vec3(p.x * 1., 0.8, 1.0));\n        t += res.x;\n        if (maxDepth < t) {\n            break;\n        }\n    }\n    return col;\n}\n\n\nvec4 particleTrace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n\tfor (int i = 0; i < 48; i++)\n\t{\n        vec3 p = ro+ray*t;\n        float d = distSphereParticle(p);\n        col += max(vec3(0.0), particle1Intensity / d * vec3(1.0, 0.5, 0.5));\n        t += d * 0.5;\n        if (maxDepth < t) {\n            break;\n        }\n\t}\n\treturn vec4(saturate(col), t);\n}\n\nvec4 particle2Trace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n\tfor (int i = 0; i < 48; i++)\n\t{\n        vec3 p = ro+ray*t;\n        float d = distCubeParticle(p);\n        col += max(vec3(0.0), particle2Intensity / d * vec3(0.0, 0.5, 1.0));\n        t += d * 0.25;\n        if (maxDepth < t) {\n            break;\n        }\n\t}\n\treturn vec4(saturate(col), t);\n}\n\nvec4 trace(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    float stepIntensity = 0.0;\n    vec2 res;\n    for (int i = 0; i < 80; i++) {\n        vec3 p = ro+ray*t;\n        res = distAll(p);\n        if( res.x < 0.0001 || t > 100.0) {\n            stepIntensity = float(i) / 64.0;\n            break;\n        }\n        t += res.x;\n    }\n    vec3 p = ro + ray * t;\n    float val = patternIntensity(p);\n    vec3 sg1 = pow(stepIntensity * 1.0, 5.0) * vec3(.2, .4, .8) * val * 5.;\n    vec3 sg2 = pow(stepIntensity * 1.0, 1.0) * vec3(1., 0., 0.) - pow(stepIntensity * 1.0, 2.0) * vec3(0., 1., 1.);\n    vec3 sg3 = pow(stepIntensity * 1.0, 1.0) * vec3(0., 0.5, .75);\n    float v = saturate((beat - 236.0) / 4.0);\n    float v2 = 1.0 - saturate((beat - 239.5) / 1.5);\n    float v3 = saturate((beat - 232.0) / 8.0);\n    return vec4(saturate(materialize(ro, ray, t, res) + sg1 * shadeIntensity - mix(vec3(0.), sg3 * 2.0 * v2, v3) + mix(vec3(0.), sg2 * 2.0 * v2, v)), t);\n}\n\nvoid initBeat(float b)\n{\n    sceneBeat = b;\n\n    kick = mod(sceneBeat, 1.);\n    hihat = sceneBeat < 16.0 ? 0.0 : pingPong(sceneBeat + 0.5, 1.0, 0.1) * 0.1;\n    snare = sceneBeat < 32.0 ? 0.0 : stepUp(sceneBeat - 32.5, 2.0, 0.5);\n}\n\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*43758.5453) * 2.0 - 1.0;\n}\n\nvec2 fbm_hash( vec2 x )\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( fbm_hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( fbm_hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( fbm_hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( fbm_hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 uv, float s)\n{\n    uv *= s;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    return f * 0.5 + 0.5;\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat elasticOut(float t) {\n\treturn sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat exponentialInOut(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat exponentialIn(float t) {\n\treturn t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialOut(float t) {\n\treturn t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvec3 scene(vec2 p)\n{\n\n    float cameraF = sin(beat * 0.25);\n    float scene0Beat = beat;\n    float scene1Beat = beat - 12.;\n    float scene2Beat = beat - 44.;\n    float scene3Beat = beat - 124.;\n    float scene4Beat = beat - 176.;\n\n    float cscene0to1 = step(12.0, beat);\n    float cscene1to2 = exponentialOut(saturate(beat - 44.));\n    float cscene2_1to2_2 = saturate((beat - 108.0) / 16.0);\n    cscene2_1to2_2 = quadraticInOut(cscene2_1to2_2 * cscene2_1to2_2);\n    float cscene3to4 = quadraticInOut(saturate((beat - 172.0) / 4.0));\n    float cscene3to4_2 = exponentialOut(saturate((beat - 176.0) / 1.0));\n\n    float scene2to3FadeOut = saturate((beat - 140.0) / 4.0 );\n\n    ////// Traveler //////\n    float toffset = max(0.0, beat - 239.5) * 0.7;\n    sp = mix(vec3(0.75, 0.75, mix(-20.0, 20.0, beat / 16.0)), vec3(0.75, 0.75, 0.2 + beat * 0.25 + toffset), cscene0to1);\n    //travelerInit(vec3(0.75, 0.75, 0.2 + beat * 0.25 + toffset));\n    //////////////////////\n\n    ////// Camera //////\n    vec3 scene0CameraPos = vec3(0.9, 0.8, 0.0);\n    vec3 scene1CameraPos = sp + vec3(sin(scene1Beat * 0.475) * 0.3 + cameraF * 0.05, .15 + cameraF * 0.05, cos(scene1Beat * 0.475) * 0.3 + cameraF * 0.05);\n    vec3 scene2CameraPos = sp + vec3(sin(scene2Beat * 0.2) * 0.15, cos(scene2Beat * 0.4) * 0.05 + 0.05, cos(scene2Beat * 0.15 + PI) * 0.05 - 0.2);\n    vec3 scene3CameraPos = sp + vec3(cos(scene1Beat * 0.25) * 0.7 + cameraF * 0.05, .15 + cameraF * 0.05, sin(scene1Beat * 0.25) * 0.5 + cameraF * 0.05);\n\n    float cb = scene1Beat - 4.0;\n    vec3 scene4CameraPos = sp + vec3(sin(cb * 0.2) * 0.15, cos(cb * 0.4) * 0.05 + 0.05, cos(cb * 0.15 + PI) * 0.05 - 0.2);\n\n    vec3 scene0CameraTarget = vec3(0.75, 0.75, 1.0);\n    vec3 scene1CameraTarget = sp;\n    vec3 scene2CameraTarget = sp + vec3(0.0, 0.0, (sin(scene2Beat * 0.05) * 0.5 + 0.5) * 3.0);\n    vec3 scene3CameraTarget = sp;\n    vec3 scene4CameraTarget = sp + vec3(0.0, 0.0, (sin(scene2Beat * 0.05) * 0.5 + 0.5) * 3.0);\n\n    float scene0CameraAngle = 0.0;\n    float scene1CameraAngle = sin(beat * 0.5) * 0.1;\n\n    float scene0CameraFov = 3.0;\n    float scene1CameraFov = 2.5;\n    float scene2_1CameraFov = 1.0;\n    float scene2_2CameraFov = 3.5;\n    float scene3_1CameraFov = 1.0;\n    float scene3_2CameraFov = 3.5;\n    float scene3_3CameraFov = 3.5;\n    float scene3_4CameraFov = 1.5;\n    float scene4CameraFov = 0.45;\n\n    vec2 rnd = hash(vec2(beat * 0.5)) * 0.05;\n    rnd *= saturate(max(0.0, 1.0 - distance(scene0CameraPos, sp) / 3.0) * (1.0 - cscene0to1) +\n                     saturate((beat - 234.0) / 6.0) * (1.0 - saturate(beat - 240.0)));\n\n    ro = mix(scene0CameraPos + vec3(rnd, 0.0), scene1CameraPos, cscene0to1);\n    ro = mix(ro, scene2CameraPos, cscene1to2);\n\n    // scene2 side camera\n    float cscene2to2_1 = exponentialInOut(saturate((beat - 61.0) / 4.0));\n    float cscene2to2_2 = exponentialInOut(saturate((beat - 65.0) / 9.0));\n    float cscene2to2_3 = exponentialInOut(saturate((beat - 67.0) / 8.0));\n    float cscene2to2_3_2 = exponentialInOut(saturate((beat - 67.0) / 12.0));\n    vec3 scene2_1SidePos = sp + mix(vec3(30.0, 1.0, -10.0), vec3(1.0, .0, 1.0), cscene2to2_1);\n    vec3 scene2_2SidePos = sp + mix(vec3(1.0, 0.0, 1.0), vec3(sin(-beat * 3. + 0.8) * 1.25, 0.0, cos(-beat * 3. + 0.8)), cscene2to2_2);\n    ro = mix(ro, scene2_1SidePos, cscene2to2_1);\n    ro = mix(ro, scene2_2SidePos, cscene2to2_2);\n    ro = mix(ro, scene2CameraPos, cscene2to2_3);\n    ////\n\n    // scene2 vertical camera\n    float cscene2to2_4 = exponentialInOut(saturate((beat - 96.0) / 4.0));\n    float cscene2to2_5 = exponentialInOut(saturate((beat - 100.0) / 8.0));\n    vec3 scene2VerticalPos = sp + mix(vec3(1.0, 30.0, -10.0), vec3(0.1, sin(-beat * 0.5) * 2., cos(-beat * 0.5)) * 2., cscene2to2_4);\n    ////\n\n    ro = mix(ro, scene2VerticalPos, cscene2to2_4);\n    ro = mix(ro, scene2CameraPos, cscene2to2_5);\n\n    ro = mix(ro, scene3CameraPos, cscene2_1to2_2);\n    ro = mix(ro, scene4CameraPos + vec3(rnd * 2.0, 0.0) - vec3(0., 0., toffset), cscene3to4);\n\n    ta = mix(scene0CameraTarget + vec3(rnd * 2.0, 0.0), scene1CameraTarget, cscene0to1);\n    ta = mix(ta, scene2CameraTarget, cscene1to2);\n\n    // scene2 side camera\n    ta = mix(ta, sp, cscene2to2_1);\n    ta = mix(ta, scene2CameraTarget, cscene2to2_3_2);\n    ////\n\n    // scene2 vertical camera\n    ta = mix(ta, sp, cscene2to2_4);\n    ta = mix(ta, scene2CameraTarget, cscene2to2_5);\n    ////\n\n    ta = mix(ta, scene3CameraTarget, cscene2_1to2_2);\n    ta = mix(ta, scene4CameraTarget + vec3(rnd, 0.0), cscene3to4_2);\n\n    float fov = mix(scene0CameraFov, scene1CameraFov, cscene0to1);\n    fov = mix(fov, scene2_1CameraFov, cscene1to2);\n\n    // scene2 vertical camera\n    fov = mix(fov, 1.0, cscene2to2_4);\n    fov = mix(fov, scene2_1CameraFov, cscene2to2_5);\n    ////\n\n    fov = mix(fov, scene2_2CameraFov, cscene2_1to2_2);\n\n    float scene2_2to3_1FovAnim = elasticOut(quadraticInOut(saturate((beat - 144.0) / 1.0)));\n    fov = mix(fov, scene3_1CameraFov, scene2_2to3_1FovAnim);\n\n    float scene3_1to3_2FovAnim = exponentialInOut(saturate((beat - 148.0) / 12.0));\n    fov = mix(fov, scene3_2CameraFov, scene3_1to3_2FovAnim);\n    fov = mix(fov, scene3_3CameraFov, cscene3to4);\n    fov = mix(fov, scene3_4CameraFov, cscene3to4);\n    fov = mix(fov, scene4CameraFov, cscene3to4_2);\n\n    float cameraAng = mix(scene0CameraAngle, scene1CameraAngle, cscene0to1);\n\n    mat3 cm = createCamera(ro, ta, cameraAng);\n    ray = cm * normalize(vec3(p, fov));\n    ////////////////////\n\n    ////// Fog //////\n    vec3 scene0Fog = vec3(0.0);\n    vec3 scene2Fog = vec3(8., 16., 32.);\n    vec3 scene3Fog = vec3(0.0);\n    vec3 scene4Fog = vec3(8., 16., 32.);\n\n    float scene0to1Fog = saturate((beat - 46.0) * 0.5);\n    float scene3to4Fog = saturate((beat - 184.0) * 0.5);\n    fogColor = mix(scene0Fog, scene2Fog, scene0to1Fog);\n    fogColor = mix(fogColor, scene3Fog, scene2to3FadeOut);\n    fogColor = mix(fogColor, scene4Fog, scene3to4Fog);\n    /////////////////\n\n    ////// Flare //////\n    float scene0StageFlareIntensity = 0.0;\n    float scene2StageFlareIntensity = 0.5;\n    float scene3StageFlareIntensity = 0.0;\n    float scene4StageFlareIntensity = 0.45;\n\n    float scene0StageFlareExp = 1.0;\n    float scene2StageFlareExp = 7.5;\n    float scene4StageFlareExp = 2.0;\n\n    float scene0TravelerFlareIntensity = max(0.2, cos(sceneBeat * 0.5) * 0.5 + 0.5);\n    float scene1TravelerFlareIntensity = max(0.2, cos(beat * 0.5) * 0.5 + 0.5);\n\n    float scene0TravelerFlareExp = mix(1.0, 800.0, distance(ro, sp) / 10.0);\n    float scene1TravelerFlareExp = 8.0;\n\n    stageFlareCol = vec3(.3, .6, 1.2);\n    travelerFlareCol = vec3(1., .25, .35);\n\n    float scene3to4Flare = saturate((beat - 176.0) / 4.0);\n\n    stageFlareIntensity = mix(scene0StageFlareIntensity, scene2StageFlareIntensity, scene0to1Fog);\n    stageFlareIntensity = mix(stageFlareIntensity, scene3StageFlareIntensity, scene2to3FadeOut);\n    stageFlareIntensity = mix(stageFlareIntensity, scene4StageFlareIntensity, scene3to4Flare);\n\n    stageFlareExp = mix(scene0StageFlareExp, scene2StageFlareExp, cscene0to1);\n    stageFlareExp = mix(stageFlareExp, scene4StageFlareExp, scene3to4Flare);\n\n    travelerFlareIntensity = mix(scene0TravelerFlareIntensity, scene1TravelerFlareIntensity, cscene0to1);\n\n    travelerFlareExp = mix(scene0TravelerFlareExp, scene1TravelerFlareExp, cscene0to1);\n    ///////////////////\n\n    ////// Light //////\n    vec3 scene0CameraLight = vec3(.005);\n    vec3 scene4CameraLight = vec3(0.04, 0.06, 0.08) * 0.2;\n\n    vec3 scene0StageLight = vec3(.0);\n    vec3 scene2StageLight = vec3(0.2, 0.4, 0.8);\n    vec3 scene3StageLight = vec3(0.);\n    vec3 scene4StageLight = vec3(0.4, 0.8, 1.6) * 2.;\n\n    cameraLight = mix(scene0CameraLight, scene4CameraLight, cscene3to4_2);\n\n    stageLight = mix(scene0StageLight, scene2StageLight, cscene1to2);\n    stageLight = mix(stageLight, scene3StageLight, scene2to3FadeOut);\n    stageLight = mix(stageLight, scene4StageLight, cscene3to4_2);\n    ///////////////////\n\n    ////// Edge //////\n    edgeOnly = mix(0.0, 1.0, cscene1to2);\n    //////////////////\n\n    ////// Particle //////\n    particleIntensity = mix(0.0, 1.0, saturate((beat - 145.0) * 10.0));\n\n    float particleAnim = saturate((beat - 145.0) / 4.0 );\n    particle1Intensity = mix(0.003, 0.0002, particleAnim);\n    particle2Intensity = mix(0.016, 0.0007, particleAnim);\n    //////////////////////\n\n    ////// Shade //////\n    shadeIntensity = mix(1.0, 0.0, scene2to3FadeOut);\n    shadeIntensity = mix(shadeIntensity, 1.0, cscene3to4);\n    ///////////////////\n\n    ////// Glow //////\n    glowIntensity = mix(1.0, 0.0, scene2to3FadeOut);\n    glowIntensity = mix(glowIntensity, 1.0, cscene3to4);\n    //////////////////\n\n    ////// Last Stage //////\n    stageFold = mix(1.0, stepUp(scene4Beat, 64. * 0.25, 1.0) * 4.0 + 5.0 + stepUp(max(0.0, beat - 244.0), 1.0, 0.2) * 10.0, cscene3to4_2);\n    stageRotateZ = mix(0.0, 1.0 - pingPong(scene4Beat, 64. * 0.25, 1.0), cscene3to4_2);\n    ////////////////////////\n\n    ////// Traveler Light //////\n    travelerLight = mix(vec3(.02, 0.004, 0.004) * 0.8, vec3(.02, .004, .004) * 1.5, cscene3to4_2);\n    ////////////////////////////\n\n    ////// Beat //////\n    float bb = mix(scene1Beat, scene2Beat, cscene1to2);\n    initBeat(bb);\n    /////////////////\n\n    ////// stage //////\n    stageScale = 3.4 - mix(0.00, 0.25, clamp(kick, 0.0, 1.0));\n    stageRot = rotateMat(0.1-hihat,-hihat, 0.4-hihat);\n    vec3 angle = mod(vec3(snare * 1.3, snare * 0.27, snare * 0.69), vec3(TAU) * 0.5);\n    stageRot2 = rotateMat(angle.x, angle.y, angle.z);\n    sphereRot = rotateMat(sin(beat * 0.5),cos(beat * 0.5), sin(beat * 0.5 * .33));\n    ///////////////////\n\n    vec4 c = trace(ro, ray);\n    c.rgb += glowTrace(ro, ray, c.w + 0.01) * glowIntensity;\n    vec4 p1 = particleTrace(ro, ray, c.w);\n    vec4 p2 = particle2Trace(ro, ray, c.w);\n    c.rgb += p1.rgb * particleIntensity;\n    c.rgb = mix(c.rgb + p2.rgb * particleIntensity, mix(p2.rgb, fogColor, pow(p2.w * 0.04, 2.1)), saturate(p2.g) * particleIntensity);\n    return c.rgb;\n}\n\n// https://www.shadertoy.com/view/MdfBRX\nfloat Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)\n{\n    float d = length(p - sp);\n    float c = smoothstep(size, size*(1.-blur), d);\n    c *= mix(mi, 1., smoothstep(size*.8, size, d));\n    return c;\n}\n\nvec3 dirt(vec2 uv, float n)\n{\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) / n;\n    vec2 rnd = hash(st);\n    float c = Bokeh(p, vec2(0.5, 0.5) + vec2(0.3) * rnd, 0.2, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);\n    \n    return vec3(c) * exp(rnd.x * 4.0);\n}\n\nvec3 postProcess(vec2 uv, vec3 col)\n{   \n    uv *= 0.5;\n    \n    vec3 di = dirt(uv, 3.5);\n    di += dirt(uv - vec2(0.17), 3.0);\n    di += dirt(uv- vec2(0.41), 2.75);\n    di += dirt(uv- vec2(0.3), 2.5);\n    di += dirt(uv - vec2(0.47), 3.5);\n    di += dirt(uv- vec2(0.21), 4.0);\n    di += dirt(uv- vec2(0.6), 4.5);\n\n    float flare = pow(max(0.0, dot(vec3(0.0, 0.0, 1.0), ray)), stageFlareExp * 1.25);\n    float flare2 = pow(max(0.0, dot(vec3(0.0, 0.0, 1.0), ray)), stageFlareExp);\n    vec3 f = flare * stageFlareCol + flare2 * di * stageFlareCol * 0.05;\n    \n    float sflare = pow(max(0.0, dot(normalize(sp - ro), ray)), travelerFlareExp * 1.25);\n    float sflare2 = pow(max(0.0, dot(normalize(sp - ro), ray)), travelerFlareExp);\n    vec3 s = sflare * travelerFlareCol + sflare2 * di * travelerFlareCol * 0.05;\n    \n    return col + f * stageFlareIntensity + s * travelerFlareIntensity;\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat Logo1(vec3 p)\n{\n    float d = 99999.9;\n    d = min(d, triPrism((p + vec3(2.75, -8.0, 0.0)) * vec3(0.76, 1.0, 1.0), vec2(11.45, 0.0)));\n    d = min(d, triPrism((p + vec3(-11.6, -13.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(11.45, 0.0)));\n    d = min(d, triPrism((p + vec3(16.9, -13.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(11.45, 0.0)));\n    return d;\n}\n\n\nfloat Logo2(vec3 p)\n{\n    float d = 99999.9;\n    d = min(d, triPrism((p + vec3(5.7, -10.05, 0.0)) * vec3(0.76, 1.0, 1.0), vec2(6.85, 0.0)));\n    d = min(d, triPrism((p + vec3(-17.0, -10.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(8.45, 0.0)));\n    return d;\n}\n\nfloat gage(vec2 p)\n{\n    float d = 99999.9;\n    p.x += 2.8;\n    p.y += 0.1;\n    d = min(d, sdRect(p, vec2(14.0, 1.0)));\n\n    float t = clamp((iTime + 30.) / 30.0 * 13.8, 0.0, 13.8);\n    p.x -= t;\n    d = max(d, -sdRect(p, vec2(13.8 - t, 0.8)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float t = iTime - 0.;\n    orgBeat = t * BPM / 60.0;\n    \n    float b = orgBeat;\n    b = mix(b, 226.0 + mod(orgBeat * 2.0, 0.5), step(228.0, orgBeat) * step(orgBeat, 228.5));\n    b = mix(b, 229.0 + mod(orgBeat * 2.0, 0.5), step(231.0, orgBeat) * step(orgBeat, 231.5));\n    b = mix(b, 227.0 + mod(orgBeat * 2.0, 0.5), step(232.0, orgBeat) * step(orgBeat, 232.5));\n    b = mix(b, 238.3 + mod(orgBeat * 4.0, 1.0), step(238.0, orgBeat) * step(orgBeat, 244.0));\n    t = b * 60.0 / BPM;\n    \n    beat = (t + hash(p).x * 0.0065 * (1.0 - saturate((orgBeat - 230.0) / 4.0)) * step(12., orgBeat)) * BPM / 60.0;\n\n    switchTraveler = mix(2.0, -2.0, saturate(sm(126.0, 172.0, orgBeat, 8.0)));\n    glitchIntensity = step(44.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 44.0)) +\n                                 step(144.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 144.0)) +\n                                 step(176.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 176.0)) +\n                                 step(228.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 228.0)) +\n                                 step(231.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 231.0)) +\n                                 step(232.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 232.0)) +\n                                 sm2(234.0, 242.65, orgBeat, 4.0, 0.5);\n    glitchColor = vec3(1.0);\n\n    //// Glitch ////\n\n    vec2 block = floor((p * vec2(100, 400.0)) / vec2(16));\n    vec2 uv_noise = block / vec2(64);\n    uv_noise += floor(vec2(t) * vec2(1234.0, 3543.0)) / vec2(64);\n\n    float block_thresh = pow(fract(t * 1236.0453), 2.0) * .5;\n    float line_thresh = pow(fract(t * 2236.0453), 3.0) * .6;\n\n    vec2 noise1 = hash(uv_noise) * 0.5 + 0.5;\n    vec2 noise2 = hash(vec2(uv_noise.y, 0.0)) * 0.5 + 0.5;\n\n    if  (noise1.r < block_thresh ||\n        noise2.g < line_thresh) {\n        float intensity = 1.0 - smoothstep(0.3, 1.0, length(p));\n        intensity *= sm(-0.4 + switchTraveler, 0.4 + switchTraveler, p.y, 0.1);\n        intensity = saturate(intensity + glitchIntensity);\n        vec2 dist = (fract(uv_noise) - 0.5) * intensity;\n        fragCoord.x -= dist.x * 350.1 * intensity;\n        fragCoord.y -= dist.y * 350.2 * intensity;\n        vec3 h = hash3(vec3(fract(uv_noise) - 0.5, 0.0)) * 2.0;\n        glitchColor = mix(vec3(1.0), h, intensity);\n    }\n    ////////////////\n\n    p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //// shutdown effect ////\n    float ttt = (orgBeat - 242.0) * 4.;\n    float val = min(150.0, mix(mix(mix(1.0, 5.0, saturate(exponentialIn(ttt))), 1.1, saturate(exponentialOut(ttt - 1.0))), 2000.0, saturate(exponentialIn(ttt - 2.0))));\n    val = mix(val, 2000.0, saturate(ttt - 3.00));\n    p.y *= val;\n    p.x *= mix(mix(1.0, 3.0, saturate(exponentialOut(ttt - 1.0))), 0.1, saturate(exponentialOut(ttt - 2.0)));\n    ////////////////////////\n\n    vec2 size = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 pp = p + (vec2(fbm(vec2(beat * 0.1), 1.0), fbm(vec2(beat * 0.1 + 114.514), 1.0)) * 2.0 - 1.0) * .65;\n    vec3 col =  scene(pp) * glitchColor;\n\n    col = postProcess(p, col);\n    col = saturate(col);\n    \n    //// Nega-Posi ////\n    col = mix(col, 1.0 - col, step(228.0, orgBeat) * step(orgBeat, 228.5));\n    col = mix(col, 1.0 - col, step(231.0, orgBeat) * step(orgBeat, 231.5));\n    col = mix(col, 1.0 - col, step(232.0, orgBeat) * step(orgBeat, 232.5));\n    col = mix(col, 1.0 - col, step(242.0, orgBeat) * step(orgBeat, 244.0));\n    ///////////////////\n\n    //// vignet ////\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 200.0;\n    vig = pow(vig, 0.1);\n    col = saturate(pow(col, vec3(1.0 / 2.2))) * vig;\n    ///////////////\n\n    col = mix(col, vec3(1.), saturate((beat - 251.0) / 4.0));\n    col = mix(col, vec3(0.), saturate((beat - 256.0) / 2.0));\n\n    //// loading screen ////\n    vec2 ppp = p;\n    p *= 12.5 * 1.33333333;\n    p+= vec2(-1.55, 9.5);\n\n    float logo1 = 1.0 - smoothstep(0.0, 0.1, Logo1(vec3(p, 0.0)));\n    float logo2 = 1.0 - smoothstep(0.0, 0.1, Logo2(vec3(p, 0.0)));\n    float g = 1.0 - smoothstep(0.0, 0.1, gage(p));\n\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(1.0, 1.5, t));\n    col = mix(col, vec3(0.23), logo1 * (1.0 - smoothstep(2.0, 3.3, t)));\n    col = mix(col, vec3(0.85, 0.35, 0.35), logo2 * (1.0 - smoothstep(2.0, 3.3, t)));\n    col = mix(col, vec3(0.85, 0.35, 0.35), g * (1.0 - smoothstep(1.0, 1.5, t)));\n    ///////////////////////\n\n    col = mix(col, vec3(1.), smoothstep(1.9, 2.0, ttt));\n    col = mix(col, vec3(0.), saturate(step(size.y, ppp.y) + step(ppp.y, -size.y) + step(size.x, ppp.x) + step(ppp.x, -size.x) + step(3.3, ttt)));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[808, 808, 849, 849, 942], [944, 944, 998, 998, 1078], [1080, 1080, 1144, 1144, 1222], [1224, 1224, 1245, 1245, 1402], [1404, 1404, 1456, 1456, 1817], [1819, 1819, 1864, 1864, 1982], [1984, 1984, 2031, 2031, 2140], [2142, 2142, 2166, 2166, 2553], [2555, 2555, 2587, 2587, 2762], [2764, 2764, 2797, 2797, 2823], [2825, 2825, 2856, 2856, 2947], [2949, 2949, 2982, 2982, 3047], [3049, 3049, 3090, 3090, 4208], [4210, 4210, 4235, 4235, 4301], [4303, 4344, 4384, 4384, 4508], [4510, 4510, 4557, 4557, 4828], [4830, 4830, 4855, 4855, 5284], [5286, 5286, 5305, 5305, 5357], [5630, 5630, 5657, 5657, 5999], [6001, 6001, 6025, 6025, 6393], [6395, 6395, 6417, 6417, 6484], [6486, 6486, 6513, 6513, 6541], [6543, 6543, 6571, 6571, 6866], [6868, 6868, 6890, 6890, 7538], [7540, 7540, 7563, 7563, 7901], [7903, 7903, 7937, 7937, 8262], [8264, 8264, 8300, 8300, 8619], [8908, 8908, 8947, 8947, 9396], [9398, 9398, 9446, 9446, 9637], [9639, 9639, 9724, 9724, 9994], [9996, 9996, 10028, 10028, 10111], [10113, 10113, 10141, 10141, 10520], [10522, 10522, 10635, 10635, 11029], [11031, 11031, 11123, 11123, 11340], [11342, 11342, 11366, 11366, 11548], [11550, 11550, 11610, 11610, 13682], [13684, 13684, 13735, 13735, 14473], [14476, 14476, 14531, 14531, 14870], [14872, 14872, 14928, 14928, 15266], [15268, 15268, 15299, 15299, 16219], [16221, 16221, 16245, 16245, 16451], [16453, 16453, 16473, 16473, 16590], [16592, 16592, 16617, 16617, 16755], [16757, 16757, 16783, 16783, 17194], [17196, 17196, 17225, 17225, 17464], [17466, 17466, 17497, 17497, 17569], [17571, 17571, 17598, 17598, 17670], [17672, 17672, 17705, 17705, 17839], [17841, 17841, 17871, 17871, 17924], [17926, 17926, 17957, 17957, 18009], [18011, 18011, 18031, 18031, 28023], [28025, 28066, 28130, 28130, 28279], [28281, 28281, 28310, 28310, 28565], [28567, 28567, 28604, 28604, 29455], [29457, 29457, 29491, 29491, 29578], [29580, 29580, 29601, 29601, 29933], [29936, 29936, 29957, 29957, 30190], [30192, 30192, 30212, 30212, 30452], [30454, 30454, 30511, 30511, 35309]], "test": "timeout"}
{"id": "4tGBDy", "name": "chakra wheel", "author": "dilip019", "description": "chakra, wheel  It can be moved by using the mouse", "tags": ["wheel", "chakra"], "likes": 3, "viewed": 76, "published": "Public", "date": "1543781962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//whith the helpe of this https://www.shadertoy.com/view/XtSfDV\n#define wheelSize .75\n\n#define S(v) smoothstep( 2./R.y, -2./R.y, v )\n#define B(v,e) S( abs(v) - e )\n \n \n// x resolution 500\n// y resolution 281\n \n\n              \nvec4 chakra(vec2 u,vec2 pos,float size ,vec3 color)    {  \n            \n    float speed  = 1.0;\n    vec2 u1 = u  ;\n\tvec2  R = iResolution.xy;\n    \n    \n    vec2  U =u1 - pos; \n    \n    float l =2.29* length(U)/size;\n    float d =.131;      \n    float a = mod( atan(U.y,U.x) +d +speed*iTime, d+d ) - d;   \n    float c =   \n         \t- B(l,.1)  \n    \t\t- B(l,.22)*1.4 \n        \t+ B(l,.26) \n            + B(l-1.,.07)        \n            + B(a*l,.03)*S(l-1.1)\n            + B((a+d)*l,.03)*S(abs(l-.92)-.02) \n            + B(l-1.12,.02)*S(abs(a)-.05) \n            ;\n      return vec4(color,c);        \n              \n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   vec4 backGround = vec4(135.,206.,250.,255.0)/255.;\n   vec4 backGroundWhite = vec4(1.0);\n    \n   vec4 backGroundBlack = vec4(0.,0.,0.,255.0)/255.;\n   vec3 blue =  vec3(.0,0.0,1.0);\n   vec2 pos = vec2(500.,281.) * abs(sin(iTime));\n   vec4 chakra1 = chakra(fragCoord ,iMouse.xy,281.0*wheelSize,blue );\n     \n    \n      \n   fragColor = mix(backGround,chakra1,chakra1.a);\n    \n    \n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGBDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 282, 282, 839], [841, 841, 898, 898, 1333]], "test": "ok"}
{"id": "4tGfWy", "name": "[TDF2018]Autumn", "author": "Pentan", "description": "Tokyo Demo Fest 2018 GLSL Graphics Compo entry product.\n", "tags": ["2d", "tdf"], "likes": 27, "viewed": 643, "published": "Public API", "date": "1543773160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SUPERSAMPLE 2\n\nvec3 rotX(vec3 p, float a) {\n    vec2 sc = sin(vec2(a, a + 1.57079632));\n    return vec3(\n        p.x,\n        p.y * sc.y + p.z * sc.x,\n        p.y * -sc.x + p.z * sc.y\n    );\n}\n\nvec3 rotY(vec3 p, float a) {\n    vec2 sc = sin(vec2(a, a + 1.57079632));\n    return vec3(\n        p.x * sc.y + p.z * sc.x,\n        p.y,\n        p.x * sc.x - p.z * sc.y\n    );\n}\n\nvec3 rotZ(vec3 p, float a) {\n    vec2 sc = sin(vec2(a, a + 1.57079632));\n    return vec3(\n        p.x * sc.y + p.y * sc.x,\n        p.x * -sc.x + p.y * sc.y,\n        p.z\n    );\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 noise(vec2 p) {\n    const vec2 k = vec2(0.0, 1.0);\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 h00 = hash22(i + k.xx);\n    vec2 h01 = hash22(i + k.xy);\n    vec2 h10 = hash22(i + k.yx);\n    vec2 h11 = hash22(i + k.yy);\n    // f = f * f * (3.0 - 2.0 * f);\n    f = f * f * f * (f * (6.0 * f - 15.0) + 10.0);\n    return mix(mix(h00, h10, f.x), mix(h01, h11, f.x), f.y);\n}\n\nvec2 fbm(vec2 p) {\n    mat2 m = mat2(-0.73736887, 0.67549029, 0.67549029, 0.73736887);\n    vec2 f = vec2(0.0);\n    float s = 0.5;\n    for(int i = 0; i < 4; i++) {\n        f += noise(p) * s;\n        s *= 0.5;\n        p = (p + vec2(0.03, 0.07)) * 2.01 * m;\n    }\n    return f;\n}\n\n//\nfloat sdEllipsoid(vec2 p, vec2 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdCapsule(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 d = b - a;\n    float l = length(d);\n    d = normalize(d);\n    vec2 v = p - a;\n    float h = min(l, max(0.0, dot(v, d)));\n    return length(v - d * h) - r;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nvec2 leaf(vec2 p) {\n    float d;\n    p.x = abs(p.x);\n    float d0 = max(sdEllipsoid(p, vec2(0.85, 1.0)), -p.y);\n    float d1 = sdCapsule(p, vec2(0.0, 0.7), vec2(0.0, 1.0), 0.02);\n    float d2 = sdEllipsoid(p - vec2(0.8, 0.0), vec2(0.78, 0.3));\n    float d4 = sdCapsule(p, vec2(0.0, 0.1), vec2(0.0, -0.8), 0.02);\n\n    d = -smin(-d0, d1, 0.15);\n    d = -smin(-d, d2, 0.1);\n    d = smin(d, d4, 0.05);\n\n    float r = length(p);\n    float th = asin(p.y / r);\n    float h = (p.y < 0.0)? 1.0 : abs(sin(th * 60.0));\n    h = max(h, 1.0 - pow(length(p) * 2.0, 3.0));\n\n    return vec2(d, h);\n}\n\nvec3 h2c(float h) {\n    const vec3 c0 = vec3(0.18, 0.96, 0.93);\n    const vec3 c1 = vec3(0.14, 0.96, 0.98);\n    vec3 c = mix(c0, c1, h);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat roadh(vec2 p, inout vec4 m) {\n    const float xs = 2.0;\n    p *= vec2(1.0/xs, 1.0);\n    vec2 ip = floor(p);\n    vec2 ap = p + vec2(ip.y * 0.5, 0.0);\n    vec2 fp = fract(ap);\n    float d;\n\n    fp = min(fp, 1.0 - fp) * 2.0;\n    d = min(1.0, min(fp.x * xs, fp.y) * 8.0);\n\n    vec2 n = fbm(p * 8.0);\n    float d0 = n.x;\n    float d1 = 1.0 - min(1.0, n.y * 3.5);\n\n    d -= d0 * 0.2;\n    d -= d1 * 0.4;\n\n    if(m.x > 0.0) {\n        vec2 iap = floor(ap);\n        m.xy = hash22(iap);\n        m.yz = iap;\n    }\n    return d;\n}\n\nvec3 road(vec2 p) {\n    const vec2 eps = vec2(1e-2, 0.0);\n    vec4 m;\n\n    // normal\n    m = vec4(0.0);\n    vec3 n;\n    n.x = roadh(p - eps.xy, m) - roadh(p + eps.xy, m);\n    n.y = roadh(p - eps.yx, m) - roadh(p + eps.yx, m);\n    n.z = eps.x * 3.0;\n    n = normalize(n);\n\n    // main\n    m = vec4(1.0);\n    float d = roadh(p, m);\n\n    float ao = 1.0 - pow(max(0.0, 1.0 - d), 8.0);\n    ao = mix(0.6, 1.0, max(0.0, ao));\n\n    vec3 l = normalize(vec3(0.5, 0.7, 2.0));\n    float dfs = dot(l, n);\n    dfs = mix(0.8, 1.0, pow(clamp(dfs * 3.0, 0.0, 1.0), 4.0));\n\n    vec3 col;\n\n    const vec3 c0 = vec3(0.74, 0.72, 0.49);\n    const vec3 c1 = vec3(0.66, 0.64, 0.42);\n    col = mix(c0, c1, m.x);\n\n    vec2 f = fbm(p * 2.0);\n    //col = f.xxx;\n    const vec3 c2 = vec3(0.73, 0.68, 0.44);\n    col = mix(col, c2, f.x);\n\n    // lit\n    col *= dfs * ao;\n\n    return col;\n}\n\nvec3 spreadleaf(vec2 p, float R) {\n    const int N = 2;\n    vec2 ip = floor(p);\n    float h = -1.0;\n    vec3 col = road(p);\n    vec2 f = fbm(p * 4.0);\n\n    for(int j = -N; j <= N; j++) {\n        float y = float(j);\n        for(int i = -N; i <= N; i++) {\n            float x = float(i);\n            vec2 cp = ip + vec2(x, y);\n            vec2 ch = hash22(cp);\n            cp += (ch * 2.0 - 1.0) * R;\n\n            vec2 lp = cp - p + (f * 2.0 - 1.0) * 0.05;\n            ch = hash22(ch * 123.4567);\n            float angl = ch.x * 6.28318530;\n            lp = rotZ(vec3(lp, 0.0), angl).xy;\n\n            vec2 lfd = leaf(lp * 1.2);\n            col = mix(col, col * vec3(0.4), smoothstep(0.04, -0.02, lfd.x)); // shadow\n            vec3 tint = mix(vec3(0.75, 0.7, 0.6), vec3(1.0), lfd.y);\n            col = mix(col, h2c(ch.y) * tint, smoothstep(0.0, -0.01, lfd.x)); // leaf\n        }\n    }\n\n    return col;\n}\n\nvec3 render(vec2 sp) {\n    vec3 op = vec3(0.0, 0.0, 4.0);\n    vec3 dv = normalize(vec3(sp, -2.0));\n\n    vec3 angle = vec3(\n        0.8 + sin(iTime * 1.2) * 0.02,\n        sin(iTime * 1.5) * 0.05,\n        0.0\n    );\n    op = rotZ(rotY(rotX(op, angle.x), angle.y), angle.z);\n    dv = rotZ(rotY(rotX(dv, angle.x), angle.y), angle.z);\n    op += vec3(0.0, 1.0 + abs(sin(iTime * 6.0)) * 0.06, 0.0);\n\n    vec3 gp = dv * op.y / dv.y;\n    vec3 col;\n    col = spreadleaf(gp.xz * 2.0 + vec2(0.0, -iTime), 0.5);\n\n    vec3 vgn = exp(-pow(length(sp), 2.0) * vec3(0.5, 0.6, 1.0) * 0.2);\n    // col *= vgn;\n    col -= 1.0 - vgn;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / mr;\n    \n#ifdef SUPERSAMPLE\n    vec3 c = vec3(0.0);\n    float dr = 2.0 / mr;\n    for(int j = 0; j < SUPERSAMPLE; j++) {\n        float dy = dr * float(j) / float(SUPERSAMPLE);\n        for(int i = 0; i < SUPERSAMPLE; i++) {\n            float dx = dr * float(i) / float(SUPERSAMPLE);\n            vec2 sp = p + vec2(dx, dy);\n            c += render(sp);\n        }\n    }\n    c /= float(SUPERSAMPLE * SUPERSAMPLE);\n#else\n    vec3 c = render(p);\n#endif\n    \n    c = pow(clamp(c, 0.0, 1.0), vec3(1.0/1.8));\n    fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGfWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 52, 52, 201], [203, 203, 231, 231, 379], [381, 381, 409, 409, 558], [560, 560, 581, 581, 714], [716, 716, 736, 736, 1099], [1101, 1101, 1119, 1119, 1377], [1379, 1382, 1417, 1417, 1518], [1520, 1520, 1570, 1570, 1736], [1738, 1738, 1777, 1777, 1860], [1862, 1862, 1881, 1881, 2444], [2446, 2446, 2465, 2465, 2751], [2753, 2753, 2788, 2788, 3276], [3278, 3278, 3297, 3297, 4136], [4138, 4138, 4172, 4172, 5039], [5041, 5041, 5063, 5063, 5671], [5673, 5673, 5730, 5730, 6364]], "test": "ok"}
{"id": "4tGfz3", "name": "StarGazingHippo", "author": "kuvkar", "description": "Star gazing hippo. It's winter and all! Hadn't done a shader in while.", "tags": ["snow", "winter", "hippo"], "likes": 13, "viewed": 470, "published": "Public API", "date": "1545233050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nvec3 lightDir = normalize(vec3(1.5, 1.2, -1.0));\nconst float groundH = .05;\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\t#define HASHSCALE1 .1031\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// https://www.shadertoy.com/view/Ml2XDw\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat opBentBox(in vec3 p, in vec3 v , float bend)\n{\n    float c = cos(bend*p.y);\n    float s = sin(bend*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return sdBox(q, v);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec3 traceSphere(in vec3 ro, in vec3 rd, float r, out float t1, out float t2)\n{\n    t1=t2=-1.0;\n    vec3 X = ro + rd * (dot(normalize(-ro), rd)) * length(ro);\n    float disc = r*r-pow(length(X), 2.0);\n    if (disc < 0.0) return vec3(1000000.0);\n    disc=sqrt(disc);\n    vec3 p=X-disc*rd;\n    t1=length(p-ro);t2=t1+disc*2.;\n    return p;\n}\n\nconst int NOTHING = 0;\nconst int EYES = 1;\n\nstruct HitInfo\n{\n    int id;\n    vec3 pos;\n    float d;\n};\n\n\n\nHitInfo map(in vec3 rp)\n{\n\tHitInfo hi;\n    rp.x = abs(rp.x);\n    hi.id = NOTHING;\n    \n    // head\n    float head = sdRoundBox(rp*1.7, vec3(.04, .05, .2)*1., 0.1);\n    head += length(rp + vec3(0.0, 0.0, 0.1)) - 0.15;\n    head = smin(head, length(rp * vec3(1.1, 1.3, 1.0)+ vec3(0.0, -0.1, -.07)) -0.08, 0.05);\n    \n    // nostrils\n    float nostril = length(rp * vec3(6.0, 10.0, 1.0) + vec3(-0.27, -.5, 0.25)) - 0.1;\n    head = max(head, -nostril );\n    \n    // ears\n    float ear = length(rp * vec3(1.0, 1.0, 5.0) + vec3(-0.05, -.14, -0.5)) - 0.02;\n    head = smin(head, ear, 0.02);\n    // eyes\n    vec3 eyePos = vec3(-0.02, -0.11, -0.02);\n    float eye = length(rp + eyePos) - 0.03;\n    \n    if(eye < 0.0) \n    {\n    \thi.id = EYES;\n        hi.pos = rp-eyePos;\n        hi.d = eye;\n        return hi;\n    }\n\n    head = min(head, eye);\n    \n    \n    // mouth\n    float mouth = sdBox(rotx(-0.2) * rp + vec3(0.0, 0.02, 0.215), vec3(0.15, 0.001 * max( -((rp.z))*25., 0.), 0.15));\n    head = max(head, -mouth);\n    \n\t// torso    \n    float torso = length(rp * vec3(1.0, 1., 1.) + vec3(0.0, 0.12, -0.04)) - 0.13;\n    torso = smin(torso, head, max(0.0, rp.z*1.));\n    \n    // legs\n    float leg = sdRoundBox(rp + vec3(-.075, 0.2, -0.1), vec3(0.04, 0.3, 0.04)*.25, 0.04);\n    float feet = sdBox(rp + vec3(-.075, 0.35, -0.07), vec3(0.07, 0.01, 0.06)*.25)-.025;\n    leg = smin(leg, feet, 0.14);\n    torso = smin(torso,leg, 0.04);\n    \n    // arms\n   \tfloat arm = opBentBox(rotz(0.8)*(rp + vec3(-0.15, 0.09, -0.08)), vec3(0.01, 0.3, 0.07*max(1.0, -rp.y*0.))*.25, 5.) - .02;\n    const float fingerWidth = .03;\n    const float fingerBend = 40.;\n    const float fingerX = -0.185;\n    const float roundness = .004;\n    const float spacing = 0.025;\n    const float smoothen = .02;\n    const float fingerY = .184;\n    \n    float finger1 = opBentBox(rp + vec3(fingerX, fingerY, -0.08-spacing), vec3(fingerWidth, .02, .01)*.2, fingerBend)-roundness;\n    arm = smin(finger1, arm, smoothen);\n\n    float finger2 = opBentBox(rp + vec3(fingerX, fingerY, -0.08), vec3(fingerWidth, .02, .01)*.2, fingerBend)-roundness;\n    arm = smin(finger2, arm, smoothen);\n\n    float finger3 = opBentBox(rp + vec3(fingerX, fingerY, -0.08+spacing), vec3(fingerWidth, .02, .01)*.2, fingerBend)-roundness;\n    arm = smin(finger3, arm, smoothen);\n    \n    head = smin(arm, torso, 0.05);\n    \n    \n    float body = min(head, torso);\n    hi.d = body;\n    return hi;\n}\n\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.002, 0.0);\n    vec3 g = vec3(map(rp + off.xyy).d - map(rp - off.xyy).d,\n                  map(rp + off.yxy).d - map(rp - off.yxy).d,\n                  map(rp + off.yyx).d - map(rp - off.yyx).d);\n    return normalize(g);\n}\n\n\nfloat ao(in vec3 n, in vec3 rp)\n{\n    float dist = 0.1;\n    rp += n*dist;\n    float occ = 0.;\n    const int steps = 4;\n    \n    for (int i = 0; i < steps; ++i)\n    {\n        float d = map(rp).d;\n        float o= clamp(d/(dist*float(i + 1)), 0.0, 1.0);\n        \n        occ += o;\n        rp += n * dist;\n    }\n    \n    occ /= float(steps);\n    return occ;\n          \n}\n\n\nfloat fbm(in vec3 rp)\n{\n    rp += vec3(5.0, 0.0, 0.0);\n    vec2 p = rp.xz*.2;\n    float f = noise(p) * 0.5;\n    f += noise(p * 2.) * 0.5 * 0.5;\n    f += noise(p * 4.) * 0.5 * 0.5 * 0.5;\n    return f;\n}\n\n\nfloat sampleGround(in vec3 rp)\n{\n    rp *= 3.;\n    float texCol = 0.;\n\tfloat f = fbm(rp);\n    texCol=1.-f;\n    return texCol;\n}\n\nvec3 g_hitp = vec3(0.0);\n\nvec3 groundNormal(in vec3 rp)\n{\n    float h0 = sampleGround(rp);\n    vec2 off = vec2(0.1, 0.0);\n    float h1 = h0 - sampleGround(rp + off.xyy);\n    float h2 = h0 - sampleGround(rp + off.yyx);\n    float h =.5;\n    vec3 f=(vec3(off.x, h1*h, 0.0));\n    vec3 u=(vec3(0.0, h2*h, off.x));\n    vec3 n = normalize(cross(u, f));\n    n += (1.0 - 2.0 * texture(iChannel3, rp.xz*2.).rgb)*.15;\n    n = normalize(n);\n    return n*vec3(-1.0, 1.0, -1.0);\n}\n\n\nbool trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n \n    bool hit = false;\n    vec3 ro = rp;\n    float dist = 0.0;\n    HitInfo hi;\n    \n    // trace to character bounding sphere\n    float t1, t2 = 0.0;\n    traceSphere(ro, rd, .38, t1, t2);\n    \n    // character\n    if(t1 > 0.0)\n    {\n        rp = ro + t1 * rd;\n        for (int i = 0; i < 140 + min(0, iFrame); ++i)\n        {\n            hi = map(rp);\n            dist = hi.d;\n            if(dist < 0.0)\n            {\n                hit = true;\n                break;\n            }\n            rp += rd * max(dist*.2, 0.001);\n\n            if(length(ro - rp) > t2) break;\n\n        }\n        rp += rd * dist*.5;\n        hi = map(rp);\n    }\n\t\n    // character color\n    vec3 albedo = vec3(180., 190., 200.)/255.;\n    if(hi.id == EYES)\n    {\n        float off = .155;\n        albedo = vec3(1.-smoothstep(off, off+.001, dot(hi.pos, normalize(vec3(0.0, 1., -1.0)))));\n    }\n           \n    \n    if(hit)\n    {\n        \n        color = vec4(.0);\n        vec3 g = grad(rp);\n        g_hitp = rp;\n        \n        //diff\n        float d = dot(g, lightDir);\n        float wrap = 0.8;\n        d = d+wrap/(1.0+wrap);\n        d = clamp(d, 0.1, 1.0);\n        color.rgb += d*albedo*.5;\n        \n        //ao\n        color.rgb += ao(g, rp)*vec3(239., 219., 159.)/255.*.15;\n        \n        // rim/fresn\n        vec3 source = normalize(vec3(1.0, 2.0, 5.0));\n        float rim = max(0.0, (dot(reflect(source, g), rd)));\n        rim = pow(rim, 4.0)*.5;\n        color.rgb += rim*vec3(.2, 0.2, 0.3);\n        \n        // some grounding for character + shadow\n        color.rgb *= mix(vec3(1.0), vec3(0.4, 0.6, 0.8), 1.-smoothstep(-.7, 0.3, g.y));\n        color.rgb *= 0.4 + 0.6 * smoothstep(-0.5, 0., rp.y);\n    }\n    \n    float travel = length(ro - rp);\n    vec3 hitp = ro;\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float t = (-dot(n, ro)+groundH)/dot(rd, n);\n    \n    // ground\n    if(t > 0.)\n    {\n        hitp = ro + rd*t;\n\n\t\tfloat vdist = 0.0;\n        \n        // rougher tracing\n        for (int i = 0; i < 40 + min(0, iFrame); ++i)\n        {\n            float texCol = sampleGround(hitp);\n            vdist = hitp.y - (groundH - texCol);\n            if(vdist < 0.)\n            {\n                break;\n            }\n\n            hitp += rd*.05*log(2.+dot(ro-hitp, ro-hitp));\n        }\n        \n        // hone into the surface\n        for (int i = 0; i < 40 + min(0, iFrame); ++i)\n        {\n            hitp += rd * vdist;\n            float texCol = sampleGround(hitp);\n            vdist = hitp.y - (groundH - texCol);\n        }\n\t\t\n        if(!hit || (travel > length(ro - hitp)))\n        {\n            // dif\n            vec3 n = groundNormal(hitp);\n            float d = dot(n, normalize(vec3(0.0, 1., 0)));\n            d = clamp(d, 0.1, .99);\n            vec3 groundCol = vec3(0.7, 1., 1.) *pow(d, 4.)*.5;\n            \n            // rim            \n            float _rimd = 1.-(n.y * -rd.y);\n            float rimd = pow(_rimd, 8.0) * 4.;\n            rimd = clamp(rimd, 0.0, 1.0);\n            \n            groundCol += vec3(0.4, 0.6, 0.8) * rimd;\n            groundCol += texture(iChannel1, hitp.xz*.02).rrr * texture(iChannel3, hitp.xz).rrr;\n            \n            float specd = dot(reflect(normalize(vec3(0., -1., 0.)), n), -rd); \n            specd = pow((clamp(specd, .0, 1.0)), 4.0) * .3;\n            groundCol += vec3(0.8, 0.9, 1.0)*specd;\n            \n            color.rgb = groundCol;\n\n            g_hitp = hitp;\n\t\t    \n            color.rgb *= 0.5 + 0.5 * smoothstep(0.0, .5, length(hitp.xz));\n        }\n    }\n    \n    return hit;\n}\n\n    \nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec2 im = 2.0 * ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    im.y *= .7;\n    vec3 rd = normalize(vec3(uv, .4));\n    vec3 rp = vec3(0.0, .7, -.7);\n    vec3 _rp = rp;\n    rp = roty(im.x) * rp;\n    rp.y = (rotx(im.y) *_rp).y;\n    \n    if(iMouse.z <= 0.0)\n    {\n        float T = iTime * .2;\n        rp.x = sin(T+.4);\n        rp.y = sin(T) * 0.25 + .3;\n        rp.z = -0.6;\n    }\n    \n    rd = lookat(rp, vec3(0.0)) * rd;\n    vec4 bgCol = vec4(.0, .1+rd.y*.2, 0.2, 0.15)*.15;\n    bool hit = trace(rp, rd, fragColor);\n    \n    float light = smoothstep(5.0, 1.0, length(g_hitp));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.02), .99-light);\n    if(!hit)\n    {\n\t    fragColor.rgb = mix(fragColor.rgb, bgCol.rgb, smoothstep(-0.15, 0., rd.y));\n        \n        vec2 starCoord = vec2( atan(rd.x, rd.z), rd.y);\n        vec3 stars = texture(iChannel0,starCoord).rrr*smoothstep(-1., .1, rd.y);\n        stars = smoothstep(0.5, 1.0, stars-.3);\n        stars *= texture(iChannel0, starCoord+vec2(iTime*.02)).rrr;\n        fragColor.rgb += stars;\n        \n    }\n    fragColor = smoothstep(0.0, 1.0, fragColor);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n    \n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGfz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 147], [148, 148, 168, 168, 295], [296, 296, 316, 316, 443], [522, 562, 582, 582, 730], [733, 774, 800, 800, 1094], [1097, 1138, 1177, 1177, 1216], [1218, 1289, 1330, 1330, 1423], [1426, 1426, 1457, 1457, 1607], [1610, 1610, 1662, 1662, 1808], [1810, 1810, 1855, 1855, 2009], [2011, 2011, 2090, 2090, 2349], [2457, 2457, 2482, 2482, 4877], [4880, 4880, 4903, 4903, 5147], [5150, 5150, 5183, 5183, 5517], [5520, 5520, 5543, 5543, 5721], [5724, 5724, 5756, 5756, 5851], [5879, 5879, 5910, 5910, 6319], [6322, 6322, 6376, 6376, 9905], [9912, 9912, 9945, 9945, 10145], [10148, 10148, 10205, 10205, 11488]], "test": "error"}
{"id": "4tKBDK", "name": "abeRRation", "author": "nabehide", "description": "Music: https://soundcloud.com/nabehide/wpbj\nYoutube: https://youtu.be/SrC7SmlsjTY", "tags": ["loop", "soundcloud"], "likes": 12, "viewed": 601, "published": "Public API", "date": "1544101261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265358979;\n\nconst float c1 = 0.8;\nconst float c2 = 0.01;\nconst float c3 = 0.49;\n\nmat2 rot(float t){\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat line(vec2 p, float w){\n    // return (1.0 - step(w, abs(p.y)));\n    return (1.0 - smoothstep(0.0, w, abs(p.y)));\n    // return smoothstep(w, -w, abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p.x += 0.3;\n\n    float f = textureLod( iChannel0, p/256.0, 0.0 ).x;\n    \n    vec3 draw = vec3(0.0);\n    \n    float period = 5.0;\n    float t = mod(iTime * 0.2, period);\n\n    for (int i=0; i<3; i++) {\n\t    float b = (t + float(i) * period / 3.0 + f*0.2) * PI * 0.4;\n        float s = sin(b);\n        float ss = s * 1.0 - 0.5;\n\n        vec2 pos = vec2(p.x*cos(b+1.0)/2.0, p.y*(sin(b+1.0)/2.0));\n        pos *= rot(ss * length(p-vec2(s, cos(b))));\n        pos *= rot(0.5 * PI);\n\n        vec3 color;\n        if (i == 0) {\n        \tcolor = vec3(c1, c2, c3);\n        } else if (i==1) {\n        \tcolor = vec3(c2, c3, c1);\n        } else {\n        \tcolor = vec3(c3, c1, c2);\n        }\n        \n        draw += line(pos, 0.6+f*0.01) * color;\n    }\n    \n    // invert color\n    draw = 1. - draw;\n    \n    fragColor = vec4(draw,1.0);\n}", "image_inputs": [{"id": "lls3zN", "previewfilepath": "https://soundcloud.com/nabehide/wpbj", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/nabehide/wpbj", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKBDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 123, 123, 175], [177, 177, 205, 246, 340], [342, 342, 399, 399, 1316]], "test": "error"}
{"id": "4tKBRz", "name": "Clouds?", "author": "lhog", "description": "Clouds", "tags": ["clouds"], "likes": 1, "viewed": 83, "published": "Public", "date": "1543964982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//SETTINGS//\nconst float timeScale = 10000.0;\nconst float cloudScale = 0.001;\nconst float skyCover = 0.5; //overwritten by mouse x drag\nconst float softness = 0.2;\nconst float brightness = 0.9;\nconst int noiseOctaves = 4;\nconst float curlStrain = 0.1;\n//SETTINGS//\n\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\nfloat saturate(float num)\n{\n    return clamp(num,0.0,1.0);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise(vec2 n)\n{\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b), hash12(b + d.yx), f.x), mix(hash12(b + d.xy), hash12(b + d.yy), f.x), f.y);\n}\n\nvec2 rotate(vec2 uv)\n{\n    uv = uv + noise(uv*0.2)*0.005;\n    float rot = curlStrain;\n    float sinRot=sin(rot);\n    float cosRot=cos(rot);\n    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);\n    return uv * rotMat;\n}\n\nfloat fbm (vec2 uv)\n{\n    float f = 0.0;\n    float total = 0.0;\n    float mul = 0.5;\n    \n    for(int i = 0;i < noiseOctaves;i++)\n    {\n        f += noise(uv+iTime*0.00015*timeScale*(1.0-mul))*mul;\n        total += mul;\n        uv *= 3.0;\n        uv=rotate(uv);\n        mul *= 0.5;\n    }\n    return f/total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenUv = fragCoord.xy/iResolution.xy;\n    vec2 uv = fragCoord.xy/(40000.0*cloudScale);\n    \n    //float mouseXAffect = (iMouse.x/iResolution.x);\n    \n    //float cover = mouseXAffect*1.1+0.1;\n    //if( iMouse.z<=0.0001 ) cover = 0.5;\n    float cover = skyCover;\n    \n    float bright = brightness*(1.8-cover);\n    \n    float color1 = fbm(uv-0.5+iTime*0.00004*timeScale);\n    float color2 = fbm(uv-10.5+iTime*0.00002*timeScale);\n    \n    float clouds1 = smoothstep(1.0-cover,min((1.0-cover)+softness*2.0,1.0),color1);\n    float clouds2 = smoothstep(1.0-cover,min((1.0-cover)+softness,1.0),color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    \n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n   \t//cloudCol = (cloudCol);\n    vec3 clouds1Color = vec3(cloudCol,cloudCol,cloudCol);\n\n    //fragColor = mix(texture(iChannel1, screenUv), vec4(0.0), cloudsFormComb);\n    fragColor.rgb = mix(0.3 * clouds1Color, texture(iChannel1, screenUv).rgb, cloudsFormComb);\n    //fragColor = texture(iChannel1, screenUv) * cloudsFormComb;\n    //fragColor = texture(iChannel1, screenUv) * (1.0 - cloudsFormComb) + clouds1Color * cloudsFormComb;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKBRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[476, 476, 503, 503, 536], [538, 538, 560, 560, 682], [685, 685, 706, 706, 911], [913, 913, 935, 935, 1132], [1134, 1134, 1155, 1155, 1443], [1445, 1445, 1502, 1502, 2679]], "test": "error"}
{"id": "4tKfWG", "name": "Stairs with Ball", "author": "SolidTux", "description": "Stairs with hopping ball", "tags": ["raymarching", "stairs"], "likes": 3, "viewed": 99, "published": "Public", "date": "1543874984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define TIME mod(iTime, float(10))\n\nprecision highp float;\n\nconst float MIN_DEPTH = float(1);\nconst float MAX_DEPTH = float(100);\nconst int MAX_ITER = 100;\nconst float EPS = float(0.001);\nconst float SHADOW = float(0);\nconst float SHADOW_EPS = float(0.1);\nconst float SHADOW_DEPTH = float(3);\nconst float SHADOW_SMOOTH = float(15);\nconst float PI = 3.14159265359;\nconst float KEYFRAME_0 = float(0);\nconst float KEYFRAME_1 = float(5);\nconst float KEYFRAME_2 = float(10);\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\nstruct RayResult {\n    float depth;\n    int object;\n    vec3 norm;\n};\nstruct SdfResult {\n    float distance;\n    vec3 pos;\n    vec2 uv;\n    int object;\n};\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float zoom;\n};\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\nvec2 norm_coord(in vec2 coord, in vec2 res) {\n    vec2 uv = coord.xy/res.xy;\n    uv = 2.*uv - 1.;\n    if (res.x > res.y) {\n        uv.x *= res.x/res.y;\n    } else {\n        uv.y *= res.y/res.x;\n    }\n    return uv;\n}\nvec3 ray_direction(in Camera cam, in vec2 coord, in vec2 res) {\n    vec2 uv = norm_coord(coord, res);\n    vec3 dir = normalize(cam.target - cam.position);\n    vec3 right = normalize(cross(dir, cam.up));\n    vec3 u = normalize(cross(right, dir));\n    vec3 target = cam.position + normalize(dir)/cam.zoom + uv.x*right + uv.y*u;\n    return normalize(target - cam.position);\n}\nRay get_ray(in Camera cam, in vec2 coord, in vec2 res) {\n    return Ray(cam.position, ray_direction(cam, coord, res));\n}\nvec2 sphere_map(in vec3 pos) {\n    // TODO\n    return vec2(0.);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\nSdfResult sdf_union(in SdfResult a, in SdfResult b) {\n    if (a.distance < b.distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\nmat3 rotx(in float a) {\n    return mat3(\n            1., 0., 0.,\n            0., cos(a), -sin(a),\n            0., sin(a), cos(a)\n            );\n}\nmat3 roty(in float a) {\n    return mat3(\n            cos(a), 0., -sin(a),\n            0., 1., 0.,\n            sin(a), 0., cos(a)\n            );\n}\nmat3 rotz(in float a) {\n    return mat3(\n            cos(a), -sin(a), 0.,\n            sin(a), cos(a), 0.,\n            0., 0., 1.\n            );\n}\nSdfResult sdf(in vec3 pos) {\n    SdfResult res = SdfResult(MAX_DEPTH, vec3(0.), vec2(0.), -1);\n    vec3 p = pos;\n    \n    if (p.y < 5.5) {\n    p.xy += mod(TIME, 1.)*vec2(2., 1.);\n    p.xy = vec2(p.x - 2.*floor(p.y), mod(p.y, 1.));\n    res = SdfResult(box(p, vec3(float(2), float(1), float(4))), p, vec2(0., 0.), 0);\n    p += vec3(float(2), float(1), float(0));\n    res = sdf_union(res, SdfResult(box(p, vec3(float(2), float(1), float(4))), p, vec2(0., 0.), 0));\n    p += vec3(float(-4), float(-2), float(0));\n    res = sdf_union(res, SdfResult(box(p, vec3(float(2), float(1), float(4))), p, vec2(0., 0.), 0));\n    }\n    ;\n    p = pos;\n    p += vec3(float(0), float(3), float(0));\n    res = sdf_union(res, SdfResult(p.y, p, vec2(0., 0.), 0));\n    ;\n    p = pos;\n    p += vec3(float(-108), float(-5.5), float(0));\n    res = sdf_union(res, SdfResult(box(p, vec3(float(100), float(1), float(400))), p, vec2(0., 0.), 0));\n    ;\n    p = pos;\n    p += vec3(float(1.75), float(-1.5), float(0));\n    p += vec3(0., -8.*(mod(TIME, 1.) - mod(TIME, 1.)*mod(TIME, 1.)), 0.);\n    res = sdf_union(res, SdfResult(length(p) - float(0.5), p, vec2(0., 0.), 1));\n    return res;\n}\nvec3 norm(in vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPS, p.y, p.z)).distance - sdf(vec3(p.x - EPS, p.y, p.z)).distance,\n        sdf(vec3(p.x, p.y + EPS, p.z)).distance - sdf(vec3(p.x, p.y - EPS, p.z)).distance,\n        sdf(vec3(p.x, p.y, p.z + EPS)).distance - sdf(vec3(p.x, p.y, p.z - EPS)).distance\n    ));\n}\nRayResult raymarcher(in Ray ray) {\n    float depth = MIN_DEPTH;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < EPS) {\n            return RayResult(depth, res.object, norm(pos));\n        }\n        depth += min(float(1), res.distance);\n        if (depth > MAX_DEPTH) {\n            return RayResult(MAX_DEPTH, -1, vec3(0.));\n        }\n    }\n    return RayResult(MAX_DEPTH, -1, vec3(0.));\n}\nfloat lightmarch(in Ray ray, in float maxd, in float k) {\n    float depth = 0.;\n    float r = 1.;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < SHADOW_EPS) {\n            return 0.;\n        }\n        r = min(r, k*res.distance/depth);\n        depth += res.distance;\n        if (depth >= (maxd - SHADOW_DEPTH)) {\n            return r;\n        }\n    }\n    return r;\n}\nvec4 color(in vec2 coord, in vec2 resolution) {\n    Camera cam = Camera(mix(mix(vec3(float(-15), float(30), float(10)), vec3(float(-10), float(30), float(10)), smoothstep(KEYFRAME_0, KEYFRAME_1, TIME)), vec3(float(-15), float(30), float(10)), smoothstep(KEYFRAME_1, KEYFRAME_2, TIME)), vec3(float(0), float(0), float(0)), vec3(float(0), float(1), float(0)), float(1));\n    Ray ray = get_ray(cam, coord, resolution);\n    RayResult res = raymarcher(ray);\n    vec3 pos = ray.origin + res.depth*ray.direction;\n    vec3 col;\n    if (res.object == 0) {\n        vec3 amb = vec3(float(1), float(1), float(0.8));\n        vec3 spec = vec3(0.);\n        vec3 diff = vec3(0.);\n        vec3 h;\n        vec3 l;\n        vec3 lpos;\n        vec3 ldir;\n        float bright = 1.;\n        lpos = vec3(15.*cos(0.2*PI*TIME), 4., 15.*sin(0.2*PI*TIME));\n        l = normalize(lpos - pos);\n        h = normalize(-ray.direction + l);\n        spec += vec3(float(1), float(1), float(1))*pow(dot(res.norm, h), float(4));\n        diff += amb * clamp(dot(l, res.norm), 0., 1.);\n        if (SHADOW > 0.) {\n            Ray light_ray = Ray(lpos, -l);\n            float s = SHADOW*lightmarch(light_ray, length(lpos - pos), SHADOW_SMOOTH) + 1. - SHADOW;\n            spec *= s;\n            diff *= s;\n        }\n        col = float(0.3)*amb + float(0.7)*diff + float(0)*spec;\n    }\n    \n    if (res.object == 1) {\n        vec3 amb = vec3(float(1), float(0), float(0));\n        vec3 spec = vec3(0.);\n        vec3 diff = vec3(0.);\n        vec3 h;\n        vec3 l;\n        vec3 lpos;\n        vec3 ldir;\n        float bright = 1.;\n        lpos = vec3(15.*cos(0.2*PI*TIME), 4., 15.*sin(0.2*PI*TIME));\n        l = normalize(lpos - pos);\n        h = normalize(-ray.direction + l);\n        spec += vec3(float(1), float(1), float(1))*pow(dot(res.norm, h), float(4));\n        diff += amb * clamp(dot(l, res.norm), 0., 1.);\n        if (SHADOW > 0.) {\n            Ray light_ray = Ray(lpos, -l);\n            float s = SHADOW*lightmarch(light_ray, length(lpos - pos), SHADOW_SMOOTH) + 1. - SHADOW;\n            spec *= s;\n            diff *= s;\n        }\n        col = float(0.3)*amb + float(0.7)*diff + float(0)*spec;\n    }\n    col -= float(1) * smoothstep(float(50), float(70), res.depth);\n    col = clamp(col, 0., 1.);\n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = color(fragCoord, iResolution.xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[764, 764, 784, 784, 828], [829, 829, 874, 874, 1045], [1046, 1046, 1109, 1109, 1418], [1419, 1419, 1475, 1475, 1539], [1540, 1540, 1570, 1582, 1605], [1606, 1606, 1633, 1633, 1720], [1721, 1721, 1774, 1774, 1866], [1867, 1867, 1890, 1890, 2012], [2013, 2013, 2036, 2036, 2158], [2159, 2159, 2182, 2182, 2304], [2305, 2305, 2333, 2333, 3464], [3465, 3465, 3487, 3487, 3796], [3797, 3797, 3831, 3831, 4287], [4288, 4288, 4345, 4345, 4756], [4757, 4757, 4804, 4804, 7052], [7054, 7054, 7109, 7109, 7161]], "test": "ok"}
{"id": "4tVfDV", "name": "five rolling triangles", "author": "FabriceNeyret2", "description": "reference: \n[url]https://www.facebook.com/groups/procgenart/permalink/1475222319275259[/url]", "tags": ["2d", "geometry", "gif", "short", "reproductions"], "likes": 17, "viewed": 582, "published": "Public API", "date": "1544176747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 R;\nfloat t, PI=3.14159;\n\n#define wrap(a) ( mod( 3.*a +PI, 2.*PI ) - PI ) /3.\n#define ofs(t)    2.* cos( wrap(t) )\n#define S(v)      smoothstep( 0., 9./R.y, v )\n\nfloat tri(float x, float y) {\n    float a = atan(y,x) - t, l = length(vec2(x,y));\n    a = wrap(a); // U = l * cos(a - vec2(0,1.57) );\n    return S( .5 - l*cos(a) ); \n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    R = iResolution.xy;\n    t = iTime;\n\n    U = 3.* ( U+U - R ) / R.y;\n    float x = U.x, y = U.y;\n    \n    O-=O;\n    O.gb += tri(  x            , y  );               // center\n    O.rb += tri(  ofs(t+PI) -x , y  );               // right\n    O.rg += tri( -ofs(t)    -x , y  ) * vec2(1,.5);  // left\n    O.rg += tri(  x ,  ofs(t-PI/2.) -y  );           // top\n    O.g  += tri(  x , -ofs(t+PI/2.) -y  );           // bottom\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 195, 195, 333], [335, 335, 373, 373, 799]], "test": "ok"}
{"id": "4tyfDG", "name": "cave", "author": "sako", "description": "submited tokyo demo fest 2018", "tags": ["raymarching"], "likes": 2, "viewed": 136, "published": "Public", "date": "1543756862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float epsilon = 0.001;\nconst float PI = 3.14159265;\nconst int isMove = 1;\n\n\n// util func\n//-------------------------------------------------------------------------------------\nfloat deg2rad(float angle){\n    return angle * PI / 180.0;\n}\n\n//x 0-1\nfloat saturate(float x){\n    return clamp(x,0.0,1.0);\n}\n\nvec3 LinearToGamma( in vec3 value, in float gammaFactor ) {\n    return pow( value, vec3(1.0 / gammaFactor) );\n}\n\nvec3 brightnessContrast(vec3 value, float brightness, float contrast)\n{\n    return (value - 0.5) * contrast + 0.5 + brightness;\n}\n\n//simplex noise\n//-------------------------------------------------------------------------------------\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n  \n//pbr\n//-------------------------------------------------------------------------------------\n\nstruct PBRMaterial{\n    vec3 albedo;\n    vec3 metallic;\n    float roughness;\n    vec3 emission;\n};\n\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n  vec3 viewDir;\n};\n\nstruct IncidentLight {\n  vec3 direction;\n  vec3 color;\n  bool visible;\n};\n\nstruct DirectionalLight {\n  vec3 direction;\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 position;\n  vec3 color;\n  float visible_distance;\n  float decay;\n};\n\nstruct ReflectedLight {\n  vec3 directDiffuse;\n  vec3 directSpecular;\n  vec3 indirectDiffuse;\n  vec3 indirectSpecular;\n};\n\n//test lighth visible\nbool testLightInRange(const in float lightDistance, const in float cutoffDistance) {\n  return any(bvec2(cutoffDistance == 0.0, lightDistance < cutoffDistance));\n}\n\n//light decay by distanc\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float decayExponent) {\n  if (decayExponent > 0.0) {\n    return pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);\n  }\n\n  return 1.0;\n}\n\n//directional light irradiance\nvoid getDirectionalDirectLightIrradiance(const in DirectionalLight directionalLight, out IncidentLight directLight) {\n  directLight.color = directionalLight.color;\n  directLight.direction = directionalLight.direction;\n  directLight.visible = true;\n}\n\n//point light irradiance\nvoid getPointDirectLightIrradiance(const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight directLight) {\n  vec3 L = pointLight.position - geometryPosition;\n  directLight.direction = normalize(L);\n\n  float lightDistance = length(L);\n  if (testLightInRange(lightDistance, pointLight.visible_distance)) {\n    directLight.color = pointLight.color;\n    directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.visible_distance, pointLight.decay);\n    directLight.visible = true;\n  } else {\n    directLight.color = vec3(0.0);\n    directLight.visible = false;\n  }\n}\n\n//material from colors\nvec3 diffuseColor(vec3 albedo, vec3 metallic){\n    return mix(albedo, vec3(0.0), metallic);\n}\n\nvec3 specularColor(vec3 albedo, vec3 metallic){\n    return mix(vec3(0.04), albedo, metallic);\n}\n\n// Normalized Lambert\nvec3 DiffuseBRDF(vec3 diffuseColor) {\n    return diffuseColor / PI;\n}\n\n\n\nvec3 F_Schlick(vec3 specularColor, vec3 H, vec3 V) {\n    return (specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(V,H)), 5.0));\n}\n\nfloat D_GGX(float a, float dotNH) {\n    float a2 = a*a;\n    float dotNH2 = dotNH*dotNH;\n    float d = dotNH2 * (a2 - 1.0) + 1.0;\n    return a2 / (PI * d * d);\n}\n\nfloat G_Smith_Schlick_GGX(float a, float dotNV, float dotNL) {\n    float k = a*a*0.5 + epsilon;\n    float gl = dotNL / (dotNL * (1.0 - k) + k);\n    float gv = dotNV / (dotNV * (1.0 - k) + k);\n    return gl*gv;\n}\n\n// Cook-Torrance\nvec3 SpecularBRDF(const in IncidentLight directLight, const in GeometricContext geometry, vec3 specularColor, float roughnessFactor) {\n\n    vec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = directLight.direction;\n\n    float dotNL = saturate(dot(N,L));\n    float dotNV = saturate(dot(N,V));\n    vec3 H = normalize(L+V);\n    float dotNH = saturate(dot(N,H));\n    float dotVH = saturate(dot(V,H));\n    float dotLV = saturate(dot(L,V));\n    float a = roughnessFactor * roughnessFactor;\n    \n    float D = D_GGX(a, dotNH);\n    float G = G_Smith_Schlick_GGX(a, dotNV, dotNL);\n    vec3 F = F_Schlick(specularColor, V, H);\n\n    return (F*(G*D))/(4.0*dotNL*dotNV+epsilon);\n}\n\n// RenderEquations(RE)\nvoid RE_Direct(const in IncidentLight directLight, const in GeometricContext geometry, const in PBRMaterial material, inout ReflectedLight reflectedLight) {\n\n    float dotNL = saturate(dot(geometry.normal, directLight.direction));\n    vec3 irradiance = dotNL * directLight.color;\n\n    // punctual light\n    irradiance *= PI;\n  \n    vec3 diffuse = diffuseColor(material.albedo, material.metallic);\n    vec3 specular = specularColor(material.albedo, material.metallic);\n\n    reflectedLight.directDiffuse += irradiance * DiffuseBRDF(diffuse);\n//    reflectedLight.directSpecular += specular;\n    reflectedLight.directSpecular += irradiance * SpecularBRDF(directLight, geometry, specular, material.roughness);\n}\n\n//---------------------------\n\nconst int rayLoopCount = 256;\nconst int aoLoopCount = 8;\n\n\nuniform float time;\nuniform vec2 resolution;\nuniform float debugTime;\nfloat app_time;\n\n\nint materialId = 0;\n\n//transform func\n//-------------------------------------------------------------------------------------\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nvec3 rotate(vec3 pos, vec3 angle){\n    vec3 theta = angle / 180.0 * PI;\n    mat4 m = rotateZ(theta.z)*rotateY(theta.y)*rotateX(theta.x);\n    return (m * vec4(pos, 1.0)).xyz;\n}\n\nvec3 translate(vec3 pos, vec3 to){\n    to.y = -1.0*to.y;\n    return pos + to;\n}\n\nvec3 scale(vec3 pos, vec3 scale){\n    return pos/scale;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// dist func\n//-------------------------------------------------------------------------------------\n\nfloat dBox(vec3 p, vec3 size){\n    vec3 q = abs(p);\n    return length(max(q - size, 0.0));\n}\n\n\nfloat dSphere(vec3 pos, float size){\n    return length(pos) - size; \n}\n\nvec3 onRep(vec3 p, float interval){\n    return mod(p, interval) - interval * 0.5;\n}\n\nfloat distPlane(in vec3 p, vec4 n){\n    return dot(p, n.xyz) * n.w;\n}\n\n\nfloat dCylinder(vec3 p, vec3 c){\n    p += c;\n    return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat dCappedCylinder( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dRoundCone( in vec3 p, in float r1, float r2, float h ){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\n// scene\n//-------------------------------------------------------------------------------------\n\nconst int LIGHT_MAX = 4;\nDirectionalLight directionalLights[LIGHT_MAX];\nPointLight pointLights[LIGHT_MAX];\nint numPointLights;\nint numDirectionalLights;\n\nstruct Camera{\n    vec3 position;\n    vec3 target;\n    float fov;\n    float roll;\n    float farClip;\n};\n\nuniform Camera debugCam;\n\nCamera cam;\n\nmat3 setCamLookAt(in Camera c){\n    vec3  cw = normalize(c.target-c.position);\n    vec3  cp = vec3(sin(deg2rad(c.roll)), cos(deg2rad(c.roll)), 0.0);\n    vec3  cu = normalize( cross(cw,cp) );\n    vec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nmat2 rotate2d(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));   \n}\n\nvec2 fold(in vec2 p, in float s)\n{\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI*2.0 / s;\n    a = floor(a / n) * n;\n    p *= rotate2d(a);\n    return p;    \n}\n\n\nvec3 getTunnelMoveDirection(float t){\n    vec3 left = vec3(1.0, 0.0, 0.0);\n    vec3 right = vec3(-1.0, 0.0, 0.0);\n    vec3 front = vec3(0.0, 0.0, 1.0);\n   \n    if(t >= 0. && t<10.){\n        return front;\n    }else if(t>=10. && t<20.){\n        return left;\n    }else if(t>=20. && t<30.){\n        return front;\n    }else if(t>=30. && t<40.){\n        return right;\n    }else{\n        return front;\n    }\n}\n\nvec3 getBirdPos(float t){\n    vec3 left = vec3(-10.0, 0.0, 0.0);\n    vec3 right = vec3(5.0, 0.0, -5.0);\n    vec3 back = vec3(0.0, 0.0, 10.0);\n    vec3 front = vec3(0.0, 0.0, -10.0);\n    \n    if(t >= 0. && t<10.){\n        return back;\n    }else if(t>=10. && t<20.){\n        return left;\n    }else if(t>=20. && t<30.){\n        return front;\n    }else if(t>=30. && t<40.){\n        return right;\n    }else{\n        return back;\n    }\n}\n\n\n\nfloat sceneDist(vec3 pos){\n    float result;\n  \n    float tunnelSize = 10.0;\n    float tunnelRep = 60.0;\n    vec3 tunnelPos = pos;\n    tunnelPos -= tunnelRep/2.0;\n    \n    if(isMove == 1){\n        float speed = tunnelSize*3.0;\n\n        float t = app_time;\n        tunnelPos += getTunnelMoveDirection(t)*t*speed;\n    }\n    \n    tunnelPos = onRep(tunnelPos, tunnelRep);\n    \n    float tunnelR = tunnelSize*0.8;\n    float boxCenter = dBox(tunnelPos, vec3(tunnelSize));\n    \n    vec3 cylinderPos = tunnelPos;\n    cylinderPos = cylinderPos + 0.05*(snoise(cylinderPos*2.0)+1.0/2.0);\n    cylinderPos = cylinderPos + 1.65*(snoise(cylinderPos/10.0)+1.0/2.0);\n    float cylinderZ = dCylinder(rotate(cylinderPos, vec3(90.0, 0.0, 0.0)), vec3(tunnelR));\n    float cylinderX = dCylinder(rotate(cylinderPos, vec3(90.0, 0.0, 90.0)), vec3(tunnelR));\n    \n    boxCenter = max(-min(cylinderX, cylinderZ), boxCenter);\n    \n    vec3 boxZPos = rotate(translate(tunnelPos, vec3(0.0, 0.0, 0.0)), vec3(0.0, 0.0, 90.0));\n    boxZPos.yz = fold(boxZPos.yz, 4.0);\n    float boxZ = dBox(translate(boxZPos, vec3(0.0, 0.0, -tunnelSize*2.0)), vec3(tunnelSize));\n    boxZ = max(-min(cylinderX, cylinderZ), boxZ);\n        \n    vec3 tubePos = tunnelPos;\n    \n    tubePos.xy = fold(tubePos.xy, 5.0);\n    float cylinderTube = dCylinder(rotate(translate(tubePos, vec3(0., tunnelR*0.95, 0.)), vec3(90, 0, 0)), vec3(tunnelR*0.03)); \n    float cylinderTubeSub = dCappedCylinder(rotate(translate(tubePos, vec3(0., tunnelR*0.95, -tunnelSize*1.4)), vec3(90, 0, 0)), vec2(tunnelR*0.045, 0.5));\n    cylinderTubeSub = min(cylinderTubeSub, dCappedCylinder(rotate(translate(tubePos, vec3(0., tunnelR*0.95, tunnelSize*1.4)), vec3(90, 0, 0)), vec2(tunnelR*0.045, 0.5)));\n    cylinderTube = min(cylinderTube, cylinderTubeSub);\n    vec3 decoPos = tunnelPos;\n    decoPos.x = onRep(decoPos,3.0).x;\n\n    float decoBox = dBox(rotate(translate(decoPos, vec3(0., -tunnelR+0.15, 0.)), vec3(0, 0, 0)), vec3(tunnelSize/10., 0.15, tunnelSize*0.44)); \n    decoBox = max(-cylinderZ, decoBox);\n    \n    vec3 partitionPos = tunnelPos;\n    partitionPos.xy = fold(partitionPos.xy, 5.0);\n    float partitions = dBox(rotate(translate(partitionPos, vec3(0., tunnelR*0.9, -tunnelSize*2.0)), vec3(90, 0, 0)), vec3(tunnelSize, 0.3, tunnelR*0.15)); \n    \n    float tunnel = min(boxZ, boxCenter);\n    float unit = tunnel;\n    unit = min(unit, cylinderTube);\n    unit = min(unit, decoBox);\n    unit = min(unit, partitions);\n\n    \n    float birdBodyAngle = cos(PI*app_time/4.0)*20.0;\n    float birdPosX = snoise(vec3(app_time/10.0, 0.3, 0.4)) * 1.0;\n    float birdPosY = sin(PI*app_time/6.0) / 3.0;\n    float turnTime = 2.0;\n    vec3 birdCenter =  mix(getBirdPos(app_time), getBirdPos(app_time+turnTime), fract(app_time/turnTime));\n    vec3 birdDir = vec3(0.0, normalize(birdCenter).x*-90.0, 0.0) + vec3(0.0, 180.0, birdBodyAngle);\n    vec3 birdPos = scale(rotate(translate(pos, birdCenter+vec3(birdPosX, birdPosY, 0.0)), birdDir), vec3(0.7));\n    \n   \n    float bird = 0.0;\n    \n    \n    float bird1 = dSphere(scale(translate(birdPos, vec3(0.0, 0.0, 0.0)), vec3(1.0, 0.7, 2.0)), 0.5);\n    float bird2 = dSphere(scale(rotate(translate(birdPos, vec3(0.0, 0.0, 0.5)), vec3(30.0, 0.0, 0.0)), vec3(1.0, 0.8, 2.0)), 0.5);\n    float birdHead = dSphere(scale(rotate(translate(birdPos, vec3(0.0, 0.6, 1.5)), vec3(00.0, 0.0, 0.0)), vec3(1.0, 1.0, 1.5)), 0.3);\n    float birdTail = dRoundCone(rotate(translate(birdPos, vec3(0.0, 0.0, -2.7)), vec3(-90, 0.0, 0.0)), 0.04, 0.2, 1.9);\n    float birdBeak = dRoundCone(rotate(translate(birdPos, vec3(0.0, 0.55, 2.7)), vec3(90, 0.0, 0.0)), 0.01, 0.05, 0.8);\n    vec3 birdEyePos = rotate(translate(birdPos, vec3(0.0, 0.73, 1.8)), vec3(00.0, 0.0, 90.0));\n    birdEyePos.xy = fold(birdEyePos.xy, 2.0);\n    float birdEye =  dSphere((translate(birdEyePos, vec3(0.0, 0.16, 0.0))), 0.06);\n    \n    vec3 birdWingPos = scale(rotate(translate(birdPos, vec3(0.0, 0.25, 0.4)), vec3(0.0, 0.0, 90.0)), vec3(0.5, 1.0, 3.0));\n    float wingAngle = birdWingPos.y > 0.0 ? -1.0 : 1.0;\n    \n    int isWing = sin(app_time*PI/2.0) > PI/5.0 ? 1 : 0;\n    wingAngle = isWing == 1 ? (-20.0 + 40.0 * sin(5.*app_time*PI))*wingAngle : (-20.0 + 10.0 * sin(app_time*PI))*wingAngle;\n    birdWingPos.xy = fold(birdWingPos.xy, 2.0);\n    float birdWing = dRoundCone(rotate(translate(birdWingPos, vec3(0.0, 0.4, 0.0)), vec3(13.0, 0.0, wingAngle)), 0.1, 0.3, 1.7);\n    float birdBody = opSmoothUnion(bird1, bird2, 0.4);\n    bird = opSmoothUnion(birdBody, birdHead, 0.4);\n    bird = opSmoothUnion(bird, birdTail, 0.4);\n    bird = opSmoothUnion(bird, birdBeak, 0.1);\n    bird = opSmoothUnion(bird, birdEye, 0.03);\n    bird = min(bird, birdWing);\n    \n    \n    result = min(unit, bird);\n    \n    \n    if(result >= tunnel)\n        materialId = 1;\n    if(result >= decoBox)\n        materialId = 2;\n    if(result >= cylinderTube)\n        materialId = 3;\n    if(result >= partitions)\n        materialId = 4;\n    if(result >= birdBody-epsilon || result >= birdTail-epsilon)\n        materialId = 5;\n    if(result >= birdWing || result >= birdHead)\n        materialId = 6;\n    if(result >= decoBox)\n        materialId = 7;\n\n\n    return result;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    return normalize(vec3(\n        sceneDist(pos + vec3(epsilon, 0., 0.)) - sceneDist(pos - vec3(epsilon, 0., 0.)),\n        sceneDist(pos + vec3(0., epsilon, 0.)) - sceneDist(pos - vec3(0., epsilon, 0.)),\n        sceneDist(pos + vec3(0., 0., epsilon)) - sceneDist(pos - vec3(0., 0., epsilon))\n    ));\n}\n\n\nfloat genAo(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float occ = 0.0;\n    for(int i=0; i<aoLoopCount; i++){\n        float len = 0.15 + float(i) * 0.15;\n        float dist = sceneDist(rd * len + ro);\n        occ += (len - dist) * k;\n        k *= 0.5;\n    }\n    return saturate(1.0-occ);\n}\n\n\n\n\nvec3 doBackground(){\n    return vec3(0.1);\n}\n\nPBRMaterial doPBRMaterial(int matId, vec3 pos){\n    PBRMaterial mat;\n    mat.albedo = vec3(1.0);\n    //tunnel\n    mat.emission = vec3(1.0);\n    if(matId == 1){\n        mat.albedo = vec3(1.0, 1.0, 1.0);\n        mat.metallic = vec3(1.0);\n        mat.roughness = 0.6;\n        \n    }else if(matId == 2){\n        mat.albedo = vec3(1.0, 1.0, 1.0);\n    }else if(matId == 3){\n        mat.albedo = vec3(1.0, 1.0, 0.25);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.1;\n        mat.emission = vec3(2.0);\n    }else if(matId == 4){\n        mat.albedo = vec3(0.7, 0.7, 0.65);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.1;\n    }else if(matId == 5){ //bird other\n        mat.albedo = vec3(0.4, 0.8, 1.0);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.0;\n\n    }else if(matId == 6){ // bird wing\n        mat.albedo = vec3(0.8, 0.9, 1.0);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.0;\n    }else if(matId == 7){ // bird heada\n        mat.albedo = vec3(41.0/255.0, 13.0/255.0, 4.0/255.0);\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.0;\n    }\n    return mat;\n}\n\n\nvec3 pbr(vec3 surfacePos, vec3 normal, vec3 col, int matId){\n    DirectionalLight directionalLight;\n    directionalLight.direction = vec3(-1.0, 0.3, -0.4);\n    directionalLight.color = vec3(1.0);\n    \n    directionalLights[0] = directionalLight;\n    numDirectionalLights = 1;\n    \n    PointLight pointLight;\n    pointLight.visible_distance = 50.0;\n    pointLight.decay = 4.4;\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 cameraLookDir = normalize(cam.target-cam.position);\n    for(int i=0; i<LIGHT_MAX; i++){\n        pointLights[i] = pointLight;\n        if(i==0){\n            pointLights[i].position = cameraLookDir*10.0;\n            //pointLights[i].position = cam.target*30.0;\n            pointLights[i].color = lightColor;\n        }\n        if(i==1){\n            pointLights[i].position = cameraLookDir*30.0 + 5.0 * sin(app_time*PI);\n            vec3 c = vec3(1.0, 1.0, 1.0);\n            if(app_time >=4.5 && app_time < 10.0){\n                c = vec3(1.0, 0.3, 0.0);\n            }else if(app_time >= 24.5 && app_time < 30.0){\n                c = vec3(1.0, 0.3, 1.0);\n            }\n            pointLights[i].color = c;\n        \n        }\n        if(i==2){\n            pointLights[i].position = cam.target*50.0 + 5.0 * cos(app_time*PI);\n            vec3 c = vec3(0.0, 1.0, 0.0);\n            if(app_time >= 4.5 && app_time < 10.0){\n                c = vec3(1.0, 1.0, 1.0);\n            }else if(app_time >= 24.5 && app_time < 30.0){\n                c = vec3(0.0, 0.3, 1.0);\n            }\n            pointLights[i].color = c;\n        }\n        if(i==3){\n            pointLights[i].position = cam.target*40.0 + 5.0 * sin((app_time+PI)*PI);\n\n            vec3 c = vec3(0.0, 0.0, 1.0);\n            if(app_time >= 4.5 && app_time < 10.0){\n                c = vec3(1.0, 0.3, 0.0);\n            }else if(app_time >= 24.5 && app_time < 30.0){\n                c = vec3(0.0, 0.5, 1.0);\n            }\n            pointLights[i].color = c;\n        }\n        \n\n    }\n    numPointLights = 4;\n    PBRMaterial material;\n    material = doPBRMaterial(matId , surfacePos);\n\n    \n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    vec3 emissive = vec3(0.0);\n    \n    IncidentLight directLight;\n    \n    GeometricContext geometry;\n    geometry.position = surfacePos;\n    geometry.normal = normal;\n    geometry.viewDir = normalize(cam.position-surfacePos);\n    \n    // point light\n    for (int i=0; i<LIGHT_MAX; ++i) {\n        if (i >= numPointLights) break;\n        getPointDirectLightIrradiance(pointLights[i], geometry.position, directLight);\n        if (directLight.visible) {\n            RE_Direct(directLight, geometry, material, reflectedLight);\n        }\n    }\n    \n\n    \n    // directional light\n    for (int i=0; i<LIGHT_MAX; ++i) {\n        if (i >= numDirectionalLights) break;\n        getDirectionalDirectLightIrradiance(directionalLights[i], directLight);\n        RE_Direct(directLight, geometry, material, reflectedLight);\n    }\n\n\n    vec3 specular = (reflectedLight.directSpecular + reflectedLight.indirectSpecular);\n    vec3 diffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n    col += specular;\n    col += diffuse;\n    \n\n    return col;\n}\n\nvec3 doColor(vec3 pos, int matId){\n    vec3 col;\n    \n    \n    vec3 normal = getNormal(pos);\n    float depth = distance(pos, cam.position)/cam.farClip;\n\n    vec3 surfacePos = pos + normal * epsilon;\n    float ambient = 0.1;\n    vec3 lightDir = vec3(1.0, 1.0, 0.0);\n\n    col += pbr(surfacePos, normal, col, matId);\n    col += ambient;\n    \n    //ambient occlusion\n    col *= genAo(surfacePos, normal);\n\n    //postprocess\n    col = LinearToGamma(col, 1.1);\n        \n    float luminance = ( 0.298912 * col.r + 0.586611 * col.g + 0.114478 * col.b );\n    \n    return col;\n}\n\nvec3 fog(vec3 origin, float total_d, vec3 fogColor, float intensity){\n    vec3 fog = vec3(1.0-total_d/cam.farClip) * intensity;\n    return origin * fogColor * fog;\n}\n\n\nvec3 trace(vec2 uv){\n    float camShake = (snoise(vec3(0.0, 0.0, sin(fract(time/4.5)*PI)))+1.0)-0.5;\n    camShake /= 100.0;\n    cam.position = vec3(cos(app_time/10.0*PI)/5.0, sin(app_time/5.0*PI)/5.0, cos(app_time/10.0*PI)*5.0);\n    cam.position += vec3(camShake, camShake, 0.0);\n\n    cam.fov = 120.0;\n    cam.farClip = 1000.0;\n\n    float turnTime = 1.0;\n    cam.target = mix(getTunnelMoveDirection(app_time), getTunnelMoveDirection(app_time+turnTime), fract(app_time/turnTime));\n//    cam.target = vec3(1.0, 0.0, 0.0);\n    if(isMove == 0) cam = debugCam;\n \n    mat3 ca = setCamLookAt(cam);\n    float fov = deg2rad(cam.fov / 2.0);\n    \n    vec3 ro = cam.position;\n    vec3 rd = normalize(ca * vec3(uv.xy, fov));    \n    vec3 cur = ro;\n    \n    //trace\n    float result;\n    float total_d;\n    int savedMaterialId;\n\n    for (int i = 0; i < rayLoopCount; i++)\n    {\n        result = sceneDist(cur);\n        total_d += result;\n        if (result < epsilon || distance(cur, cam.position) > cam.farClip){\n            savedMaterialId = materialId;\n            \n            break;\n            \n        }\n        cur += rd * result;\n    }\n    \n    if(result >= epsilon){\n        return doBackground();\n    }\n    \n    vec3 col = doColor(cur, savedMaterialId);\n\n    col = brightnessContrast(col, 0.5, 2.6);\n    col = fog(col, total_d, vec3(1.0), 1.0);\n    \n    col *= clamp(vec3(2.0-length(uv)), 0.0, 1.0);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    app_time = fract(iTime/40.0)*40.0;\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    fragColor = vec4(trace(uv), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 183, 210, 210, 243], [245, 253, 277, 277, 308], [310, 310, 369, 369, 421], [423, 423, 494, 494, 552], [554, 658, 679, 679, 728], [730, 730, 751, 751, 800], [802, 802, 824, 824, 864], [866, 866, 894, 894, 946], [948, 948, 972, 972, 3118], [5157, 5180, 5226, 5226, 5273], [5275, 5275, 5322, 5322, 5370], [5372, 5394, 5431, 5431, 5463], [5467, 5467, 5519, 5519, 5610], [5612, 5612, 5647, 5647, 5772], [5774, 5774, 5836, 5836, 5985], [7622, 7727, 7754, 7754, 7937], [7939, 7939, 7966, 7966, 8149], [8150, 8150, 8177, 8177, 8360], [8362, 8362, 8396, 8396, 8537], [8539, 8539, 8573, 8573, 8618], [8620, 8620, 8653, 8653, 8677], [8679, 8679, 8731, 8731, 8830], [8832, 8832, 8890, 8890, 8990], [8992, 8992, 9051, 9051, 9150], [9254, 9254, 9284, 9284, 9346], [9349, 9349, 9385, 9385, 9419], [9421, 9421, 9456, 9456, 9504], [9506, 9506, 9541, 9541, 9575], [9578, 9578, 9610, 9610, 9658], [9661, 9661, 9701, 9701, 9800], [9802, 9802, 9864, 9864, 10142], [10541, 10541, 10572, 10572, 10806], [10809, 10809, 10833, 10833, 10888], [10890, 10890, 10924, 10924, 11057], [11060, 11060, 11097, 11097, 11462], [11464, 11464, 11489, 11489, 11895], [11899, 11899, 11925, 11925, 17050], [17052, 17052, 17078, 17078, 17381], [17384, 17384, 17414, 17414, 17672], [17677, 17677, 17697, 17697, 17721], [17723, 17723, 17770, 17770, 18840], [18843, 18843, 18903, 18903, 22061], [22063, 22063, 22097, 22097, 22631], [22633, 22633, 22702, 22702, 22798], [22801, 22801, 22821, 22821, 24216], [24218, 24218, 24275, 24299, 24464]], "test": "error"}
{"id": "4tyfWy", "name": "Cheap star", "author": "FraglessPlayer", "description": "Really fast and useful for Christmas related shaders :)", "tags": ["christmas", "sun", "fast", "star", "glow"], "likes": 14, "viewed": 769, "published": "Public", "date": "1543777199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n    fragColor = vec4(cheap_star(uv,anim) * vec3(0.35,0.2,0.15), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyfWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 185], [187, 187, 244, 244, 511]], "test": "ok"}
{"id": "llGBzw", "name": "Activit 6", "author": "Elra", "description": "animation", "tags": ["act6"], "likes": 1, "viewed": 43, "published": "Public", "date": "1545230502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FLT_MAX = 1000000.0; \nstruct Material {\n    float Ka; //ambiant coef\n    float Kd; //diffuse coef\n    float Ks; //specular coef\n    float Kn; //specular power coef\n};\n\n//sky parameters\nconst vec3 skyCol = vec3(0); //black\nconst int skyId = 0;\n    \n//Camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nvec3 cameraTarget = vec3(3,1,-8);\nconst vec3 ScameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0;\n\n//Sphere parammeters\nconst int sphereId = 1;\nvec3 spherePos = ScameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0); //red\nconst Material sphereMat = Material(0.2, 0.7, 1.0, 50.0);\n\n// Light(s) parameters\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1); //white\nvec3 lightPos = vec3(8, 10, -12);\n\n//Plane parameters\nconst vec3 planePos = vec3(0.,0.1,0.);\nconst vec3 planeNormal = vec3(0.,1.0,0);\nconst vec3 planeCol1 = vec3(1.0); //white\nconst vec3 planeCol2 = vec3(0.4); //gray\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\nfloat f, delta, a , b, c, t, t1, t2;\nvec2 pt;\nvec3 PT, cz, PO, cyT, cxT, cx, cy, OS, PS, SP, SO;\nfloat res;\n\nvec2 transform_to_apply(vec2 fragCoord){\nvec2 pt;\npt = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\nreturn pt;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir){\nrayPos = cameraPos;\nf = 1.0/tan(radians(cameraFovY) / 2.0);\nPT = cameraTarget - cameraPos;\n\ncz = normalize(PT);\nPO = f * cz;\ncyT = vec3(0.0, -1.0, 0.0);\ncxT = cross(cyT, cz);\ncx = normalize(cxT);\ncy = cross(cz, cx);\npt = transform_to_apply(pixCoord);\nOS = pt.x * cx - pt.y * cy;\nPS = PO + OS;\nrayDir = normalize(PS);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS,out vec3 normalS){\n    SO = rayPos - spherePos;\n    a = dot(rayDir, rayDir);\n    b = 2.0* dot(SO, rayDir);\n    c = dot(SO, SO) - dot ( sphereRadius, sphereRadius);\n    delta = b*b - 4.0*a*c;\n    if (delta <= 0.0){\n        res = -1.0;\n    }\n  \n    if (delta > 0.0){\n        t1 = (-b + sqrt(delta)) / 2.0*a;\n        t2 = (-b - sqrt(delta)) / 2.0*a;\n        if (t1 >=0.0 && t2 >=0.0){\n            res = t2;\n        }else {\n            res = -1.0;\n        }\n    }\n    return res;\n}\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V){\n    vec3 ambiant = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd * objectCol * lightCol * max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks * lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\nfloat rayPlane ( vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normalPt){\n            \n    if (dot(planeNormal, rayDir) == 0.0f)\n        return -1.0;\n    \n    float t = dot(planePos - rayPos,planeNormal) / dot(planeNormal, rayDir); \n    \n    intersecPt = rayPos + t * rayDir;\n    normalPt = -sign(dot(planeNormal, rayDir)) * planeNormal;\n    \n    return t;\n}\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,out int objectId, out vec3 intersecI, out vec3 normalI){\n    float minDist  = FLT_MAX;\n    objectId = skyId;\n    \n    // Sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    intersecS = rayPos + distS * rayDir;\n    normalS = normalize(intersecS - spherePos);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId = sphereId;\n        minDist = distS;\n        intersecI = intersecS;\n        normalI = normalS;\n    }\n    \n    // Plane\n    vec3 intersecPt, normalPt;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecPt, normalPt);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId = planeId;\n        minDist = distP;\n\t    intersecI = intersecPt;\n    \tnormalI = normalPt;\n    }\n    \n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\nvec3 getSphereColorAtPoint(vec3 pt){\n    return sphereCol;\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt){\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat){\n\tif (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist){\n\tfloat shadow;\n    int objectId;\n    vec3 intersectI;\n    vec3 normalI;\n    float nearest = computeNearestIntersection(I,L,objectId,intersectI,normalI);\n    if (nearest <= Ldist && nearest>0.0){\n        shadow = objectMat.Ka;\n    }else{\n        shadow = 1.0;\n    }    \n   return shadow;\n}\nvoid AnimateScene(float time){\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    // NOTE: at time=0, the sphere position is the same than the default one defined at\n    \t//       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n    \n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time=0.\n    lightPos += vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    \n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time=0.\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat time = iTime;\n    AnimateScene(time);\n    \n   vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n\t// Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (distI > 0.0)\n    {\n        // unit-vector going from the surface point toward the light\n\t    vec3 L = normalize(lightPos - intersecI);\n        float Ldist = length(lightPos - intersecI);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n        //ombre\n        vec3 ptI = intersecI + normalI * 0.001;\n        float shadowFactor = getShadowFactorAtPoint(ptI, normalI, objectMat, L, Ldist);\n                \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n    \tfragColor = vec4(computePhongShading(objectCol, objectMat, shadowFactor, normalI, L, R, V), 1);\n    }\n    else\t// We did not hit the sphere, so we have the sky color (here: black)\n     \tfragColor = vec4(skyCol, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGBzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1148, 1148, 1188, 1188, 1268], [1270, 1270, 1353, 1353, 1672], [1674, 1674, 1789, 1789, 2248], [2250, 2250, 2362, 2362, 2752], [2754, 2754, 2870, 2870, 3155], [3157, 3157, 3271, 3271, 4105], [4107, 4107, 4143, 4143, 4167], [4169, 4169, 4204, 4204, 4559], [4561, 4561, 4635, 4635, 4894], [4896, 4896, 4982, 4982, 5271], [5272, 5272, 5302, 5337, 6276], [6278, 6278, 6334, 6334, 7985]], "test": "error"}
{"id": "llGfW3", "name": "rolling triangle tiling (310 ch)", "author": "FabriceNeyret2", "description": "Funnily, drawing all triangles makes [url]https://www.shadertoy.com/view/4tVfDV[/url] less mysterious and more trivial...", "tags": ["2d", "geometry", "gif", "short", "reproductions"], "likes": 9, "viewed": 493, "published": "Public API", "date": "1544218176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/4lGfD3\n\n#define W(a)   2.* cos( ( mod( a + iTime ,2.) - 1. ) *1.05 )  // 1.05 = pi/3  .955 = 3/pi\n#define T(X,Y) max(0., 1.- length(vec2(Y U.y, X U)) * W( -.955*atan(Y U.y,X U.x) ) ) *R.y/20.//\n#define L(Y)   T(,Y) + T( W(1.)     - ,Y )     \\\n                     + T(-W(1.)-W() + ,Y )     \\\n                   + T(2.*W(1.)+W() - ,Y )    //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = 3.* abs(u+u - R) / R.y\n             -.5* vec2( W(), W(.5) );\n    O += L(                   )\n      +  L(  W(-.5) -         )\n      +  L(  W(-.5) + W(.5) + )  ; O = sin(O); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "llKBzd", "name": "AOBench comparative", "author": "kig", "description": "AOBench normalized to 1920x1080 with 4x4 supersampling and 256 AO rays per primary.\n\nThis is for comparing with CPUs using an ISPC build at similar settings.\n", "tags": ["aobench", "ao", "benchmark"], "likes": 2, "viewed": 441, "published": "Public API", "date": "1543715783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tby kioku / System K\n\thttps://www.shadertoy.com/view/ldl3Rn\n\n\t[ Modified to add normalized resolution and supersampling and attempt at a less bandy PRNG. ]\n*/\n/*\n    AOBench normalized to 1920x1080 with 4x4 supersampling and 256 AO rays per primary.\n\n    This is for comparing with CPUs using an ISPC build at similar settings.\n\n\tResults table:\n\n    WebGL\n    -----\n\t0.033s Nvidia RTX 2070\n\t0.1s Nvidia GTX 1050 4GB\n    0.2s Intel Iris Graphics 655\n    0.6s Intel UHD Graphics 630\n    1.8s Snapdragon 835\n    5.2s Snapdragon 820\n\n    ISPC\n    ----\n\t0.6s AMD TR 2950X [16c HT, ~AVX2]\n\t1.2s Dual-Xeon E5-2650 v2 [16c HT, AVX]\n\t1.5s i5-8259U [4c HT, AVX2]\n\t1.6s Xeon E3-1231v3 [4c HT, AVX2]\n\t2.9s i7-3770 [4c HT, AVX]\n\t7.8s i5-3317U [2c HT, AVX]\n\t11s Snapdragon 835 [8c, 4+4c, NEON, aarch64]\n\t15s Exynos 7420 Octa [8c, 4 a53 + 4 a57, NEON, aarch64]\n    19s Snapdragon 820 [4c, 2+2c, NEON, aarch64]\n\t55s Raspberry PI 3B+ [4c a53, NEON, armv7l]\n\t56s AllWinner H5 [4c a53, NEON, aarch64]\n\t100s AllWinner H3 [4c a7, NEON, armv7l]\n\n    FWIW, single-threaded scalar C++ on the fast x86s runs in ~50-60s.\n    Extrapolating that, WASM ~75s, JS 150s+, Workers for ~4-40s runtimes [16c wasm / 4c JS]\n\n*/\n\n// To benchmark, uncomment this. For most representative results, run fullscreen at 1920x1080. Count the cyan bars for fps :P\n// Frame times above are calculated as 1/fps.\n//\n//#define BENCHMARK\n\n// Control benchmark heaviness.\n// Set this to 1.0 or even 0.5 for mobile SoCs.\n// To normalize frame times:\n//   2.0 subsamples - divide fps by 4\n//   1.0 - divide fps by 16\n//   0.5 - divide fps by 64\n//\n#define BENCHMARK_SUBSAMPLES 4.0\n\n// Control demo mode supersampling (SUBSAMPLES * SUBSAMPLES primary rays per pixel)\n#define SUBSAMPLES 2.0\n\n\nmat3 rotationXY( vec2 angle ) {\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n         cy, -sy, 0.0,\n         sy,  cy, 0.0,\n        0.0, 0.0, 1.0\n\t) * mat3(\n        cp, 0.0, -sp,\n        0.0, 1.0, 0.0,\n        sp, 0.0, cp\n    );\n}\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\nstruct Sphere\n{\n\tvec3 center;\n\tfloat radius;\n};\nstruct Plane\n{\n\tvec3 p;\n\tvec3 n;\n};\n\nstruct Intersection\n{\n\tfloat t;\n\tvec3 p;     // hit point\n\tvec3 n;     // normal\n\tint hit;\n};\n\nSphere sphere[3];\nPlane plane;\nfloat aspectRatio = 16.0/9.0;\n\nvoid shpere_intersect(Sphere s, Ray ray, inout Intersection isect)\n{\n\tvec3 rs = ray.org - s.center;\n\tfloat B = dot(rs, ray.dir);\n\tfloat C = dot(rs, rs) - (s.radius * s.radius);\n\tfloat D = B * B - C;\n\n\tif (D > 0.0)\n\t{\n\t\tfloat t = -B - sqrt(D);\n\t\tif ( (t > 0.0) && (t < isect.t) )\n\t\t{\n\t\t\tisect.t = t;\n\t\t\tisect.hit = 1;\n\n\t\t\t// calculate normal.\n\t\t\tisect.p = ray.org + ray.dir * t;\n\t\t\tisect.n = normalize(isect.p - s.center);\n\t\t}\n\t}\n}\nvoid plane_intersect(Plane pl, Ray ray, inout Intersection isect)\n{\n\tfloat d = -dot(pl.p, pl.n);\n\tfloat v = dot(ray.dir, pl.n);\n\n\tif (abs(v) < 1.0e-6) {\n\t\treturn;\n\t} else {\n\t\tfloat t = -(dot(ray.org, pl.n) + d) / v;\n\n\t\tif ( (t > 0.0) && (t < isect.t) )\n\t\t{\n\t\t\tisect.hit = 1;\n\t\t\tisect.t   = t;\n\t\t\tisect.n   = pl.n;\n\t\t\tisect.p = ray.org + t * ray.dir;\n\t\t}\n\t}\n}\n\n\nvoid Intersect(Ray r, inout Intersection i)\n{\n\tfor (int c = 0; c < 3; c++)\n\t{\n\t\tshpere_intersect(sphere[c], r, i);\n\t}\n\tplane_intersect(plane, r, i);\n}\n\n\t\t\nvoid orthoBasis(out vec3 basis[3], vec3 n)\n{\n\tbasis[2] = vec3(n.x, n.y, n.z);\n\tbasis[1] = vec3(0.0, 0.0, 0.0);\n\n\tif ((n.x < 0.6) && (n.x > -0.6))\n\t\tbasis[1].x = 1.0;\n\telse if ((n.y < 0.6) && (n.y > -0.6))\n\t\tbasis[1].y = 1.0;\n\telse if ((n.z < 0.6) && (n.z > -0.6))\n\t\tbasis[1].z = 1.0;\n\telse\n\t\tbasis[1].x = 1.0;\n\n\n\tbasis[0] = cross(basis[1], basis[2]);\n\tbasis[0] = normalize(basis[0]);\n\n\tbasis[1] = cross(basis[2], basis[0]);\n\tbasis[1] = normalize(basis[1]);\n\n}\n\nint seed = 0;\n\nfloat randomn()\n{\n\tseed = int(mod(float(seed)*1364.0+626.0,5209.0));\n\treturn float(seed)/5209.0;\n}\n\n\nfloat hash2(vec2 n) { \n\treturn fract(sin(dot(n, vec2(18.99221414, 15.839399))) * 13454.111388);\n}\n\nvec3 computeAO(inout Intersection isect)\n{\n\tconst int ntheta = 8;\n\tconst int nphi   = 8;\n\tconst float eps  = 0.0001;\n\n\t// Slightly move ray org towards ray dir to avoid numerical problem.\n\tvec3 p = isect.p + eps * isect.n;\n\n\t// Calculate orthogonal basis.\n\t vec3 basis[3];\n\torthoBasis(basis, isect.n);\n\n\tfloat occlusion = 0.0;\n\n\tfor (int j = 0; j < ntheta; j++)\n\t{\n\t\tfor (int i = 0; i < nphi; i++)\n\t\t{\n\t\t\t// Pick a random ray direction with importance sampling.\n\t\t\t// p = cos(theta) / 3.141592\n\t\t\tfloat r = randomn(); //hash2(isect.p.xy+vec2(i,j));\n\t\t\tfloat phi = 2.0 * 3.141592 * hash2(isect.p.xy+vec2(float(i)*9.1,float(j)*9.1));\n\n\t\t\tvec3 ref;\n\t\t\tfloat s, c;\n\t\t\ts = sin(phi);\n\t\t\tc = cos(phi);\n\t\t\tref.x = c * sqrt(1.0 - r);\n\t\t\tref.y = s * sqrt(1.0 - r);\n\t\t\tref.z = sqrt(r);\n\n\t\t\t// local -> global\n\t\t\tvec3 rray;\n\t\t\trray.x = ref.x * basis[0].x + ref.y * basis[1].x + ref.z * basis[2].x;\n\t\t\trray.y = ref.x * basis[0].y + ref.y * basis[1].y + ref.z * basis[2].y;\n\t\t\trray.z = ref.x * basis[0].z + ref.y * basis[1].z + ref.z * basis[2].z;\n\n\t\t\tvec3 raydir = vec3(rray.x, rray.y, rray.z);\n\n\t\t\tRay ray;\n\t\t\tray.org = p;\n\t\t\tray.dir = raydir;\n\t\t\t\n\t\t\tIntersection occIsect;\n\t\t\toccIsect.hit = 0;\n\t\t\toccIsect.t = 1.0e30;\n\t\t\toccIsect.n = occIsect.p = vec3(0);\n\t\t\tIntersect(ray, occIsect);\n\t\t\tocclusion += (occIsect.hit != 0 ? 1.0 : 0.0);\n\t\t}\n\t}\n\n\t// [0.0, 1.0]\n\tocclusion = (float(ntheta * nphi) - occlusion) / float(ntheta * nphi);\n\treturn vec3(occlusion, occlusion, occlusion);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pxMul = vec2(1920, 1080) / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 duv = ((fragCoord.xy+1.0) / iResolution.xy) - uv;\n    fragColor = vec4(0.0);\n    seed = int(mod((fragCoord.x+0.5) * (fragCoord.y*iResolution.y+0.5), 65536.0));\n#ifdef BENCHMARK\n    float subSamples = round(pxMul.x * BENCHMARK_SUBSAMPLES);\n    for (float y = 0.; y < subSamples; y++) {\n        for (float x = 0.; x < subSamples; x++) {\n#else\n    const float subSamples = SUBSAMPLES;\n    for (float y = 0.; y < SUBSAMPLES; y++) {\n        for (float x = 0.; x < SUBSAMPLES; x++) {\n            float dt = iTimeDelta * (x+y*subSamples+randomn()) / (subSamples*subSamples+1.0);\n            float t = iTime - dt;\n\t\t    mat3 rot = rotationXY( vec2( t, cos(t*0.3) * 0.05 ) );\n#endif\n            vec2 fuv = uv + (duv / subSamples * vec2(x,y));\n            \n            vec3 dir = normalize(vec3((fuv-0.5)*2.0*vec2(1.0,1.0/aspectRatio),-1.0));\n            Ray ray;\n#ifdef BENCHMARK\n            ray.org = vec3(0.0);\n            ray.dir = dir;\n#else\n            ray.org = 3.5*vec3(sin(t),0,cos(t)) - vec3(0.0, 0.0, 3.0);\n            ray.dir = normalize(rot * dir);\n#endif\n            Intersection it;\n            it.hit = 0;\n            it.n = vec3(0,0,0);\n            it.p = vec3(0,0,0);\n            it.t = 10000.0;\n\n            sphere[0].center = vec3(-2.0, 0.0, -3.5);\n            sphere[0].radius = 0.5;\n            sphere[1].center = vec3(-0.5, 0.0, -3.0);\n            sphere[1].radius = 0.5;\n            sphere[2].center = vec3(1.0, 0.0, -2.2);\n            sphere[2].radius = 0.5;\n            plane.p = vec3(0,-0.5, 0);\n            plane.n = vec3(0, 1.0, 0);\n            \n            Intersect(ray,it);\n\n            if (it.t < 1e3) {\n\t            fragColor += vec4(computeAO(it),1.0);\n            }\n        }\n    }\n    fragColor /= subSamples * subSamples;\n    if (fragCoord.x < iFrameRate * 10.0 && fragCoord.y < 10.0 && mod(fragCoord.x, 10.0) >= 1.0) {\n        fragColor = vec4(0.4, 1.0, 0.85, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKBzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1740, 1740, 1771, 1771, 2051], [2333, 2333, 2401, 2401, 2763], [2764, 2764, 2831, 2831, 3122], [3125, 3125, 3170, 3170, 3275], [3280, 3280, 3324, 3324, 3739], [3756, 3756, 3773, 3773, 3854], [3857, 3857, 3878, 3878, 3954]], "test": "ok"}
{"id": "llVBD3", "name": "try atmosphere scattering", "author": "cailuming", "description": "My first try about atmosphere scattering, still, there are some problem to be solved  ", "tags": ["mieandrayleigh"], "likes": 8, "viewed": 280, "published": "Public", "date": "1545065922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define U_PI 3141592657U\n\n#define MAXIT 32.0\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n \nmat2 rot2D(float a){\n   float c =cos(a);\n   float s =sin(a);\n   return mat2(c,s,-s,c); \n}\n \n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      8pi * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n// Rayleigh\n// g : 0\n// F = 3/16PI * ( 1 + c^2 )\nfloat phase_ray( float cc ) {\n\treturn ( 3.0 / 16.0 / PI ) * ( 1.0 + cc );\n}\n\nfloat density(float h,float s){\n   return exp(-h/s);\n}\n \n// get the optical depth\nfloat optic(float h,float b,float s){\n    \n    float ret = 0.0;\n    float smc = 4.0;\n    float t   = b;\n    float len = h/smc;\n    for(float i=0.0;i<smc;i++){\n        ret+= density(t,s);\n        t+= len;\n    }\n    ret*=len;\n    return clamp(ret,0.,1.0);\n}\n\n\nvec2 hash2(vec2 uv){\n   float drive = 1.0+iTime*0.2*PI; \n   float r = fract(sin(dot(uv,vec2(3.7345236,PI))*PI*128493.0)); \n   float r1 = fract(sin(dot(uv,vec2(r,PI))*PI*14327.0)); \n   \n   return vec2(r,r1)*rot2D(drive);\n}\n\nfloat noise2D(vec2 uv){\n   vec2 p = floor(uv);\n   vec2 f = fract(uv);\n   vec2 e = vec2(1,0);\n   vec2 p00 = p;\n   vec2 p10 = p+e;\n   vec2 p11 = p+e.xx;\n   vec2 p01 = p+e.yx;\n   float v00 = dot(f-e.yy,hash2(p00));\n   float v10 = dot(f-e.xy,hash2(p10));\n   float v11 = dot(f-e.xx,hash2(p11));\n   float v01 = dot(f-e.yx,hash2(p01));\n    \n   f = f*f*f*(f*(f*6.-15.)+10.); \n   \n   return mix(mix(v00,v10,f.x),mix(v01,v11,f.x),f.y);\n}\n\nfloat fbm(vec2 uv){\n    float freq = .2;\n    float ampli = 4.0;\n    float ret   = 0.5;\n    for (int i=0;i<8;i++){\n       ret+= noise2D(uv*freq)*ampli;\n       uv +=vec2(ret,ret);\n       freq*=2.0;\n       ampli*=0.5;\n    }\n    return smoothstep(-1.0,1.0,ret);\n}\n \nvec2 sphere(vec3 o,vec3 dir,vec4 sp){\n   vec3 a = sp.xyz - o;\n   float b = dot(dir,a);\n   float d = sqrt(dot(a,a)-b*b);\n   float t = sqrt(sp.w*sp.w-d*d);\n   if(d>sp.w) return vec2(-1); \n   return vec2(b-t,b+t);\n}\n\nvec2 intersect(vec4 p){\n    if(p.z<=-1.0){\n       return p.xy;\n    }\n    return vec2(p.x,p.z);\n}\n\nvec3 getColor(float c){\n   float r= cos((c-0.85)*PI);\n   float g= cos((c-0.55)*PI);\n   float b= cos((c-0.15)*PI);\n    \n   return vec3(r,g,b); \n}  \n \nvoid planet(inout Ray r,inout vec3 col,vec3 lp,vec3 sc){\n    float t  = 0.0;\n    float er = 2.0;\n    float ar = er*1.5;\n    float h  = 0.0;\n    float lh  = 0.0;\n    float c  = 0.0;\n    float td = 0.0;\n    float h_mie = 0.01;\n    float h_ray = 0.04;\n    float d_mie = 0.0;\n    float d_ray = 0.0;\n    float t_mie0 = 0.0;\n    float t_ray0 = 0.0;\n    float t_mie1 = 0.0;\n    float t_ray1 = 0.0;\n    float nl     = 0.0;\n    vec3 c_ray = vec3(0.);\n    vec3 c_mie = vec3(0.);\n    vec3 c_mul = vec3(0.);\n   \n    vec3 kray = vec3(15, 40, 85.0);\n    \n    vec3 kmie = vec3(80.);\n   \n    vec2  et = sphere(r.o,r.d,vec4(sc,er));\n    vec2  at = sphere(r.o,r.d,vec4(sc,ar));\n    vec2  lt = sphere(lp,-lp,vec4(sc,ar));\n    \n    vec2  pt = intersect(vec4(at,et));\n    vec3  ps = pt.x*r.d+r.o;\n    vec3  pe = pt.y*r.d+r.o;\n    vec3  pl = lt.x*normalize(-lp)+lp;\n    vec3  n  = vec3(0);\n    vec3  ep = pt.x*r.d+r.o;\n    \n    vec3  p  = ps;\n    float stp = length(pt.y-pt.x)*1.1/MAXIT;\n    \n    if(at.x<=0.) return;\n    \n    for(int i=0;i<int(MAXIT);i++){\n        p = p+r.d*stp;\n        h = length(p)-er;\n        lh = length(pl-p)*0.6;\n         \n        d_mie=density(h,h_mie);\n        d_ray=density(h,h_ray);\n        \n        t_mie0+=d_mie*stp;\n        t_ray0+=d_ray*stp;\n        \n        t_mie1=optic(lh,h,h_mie);\n        t_ray1=optic(lh,h,h_ray);\n        \n        c_mul= exp(-(t_ray0+t_ray1)*kray*0.02-(t_mie0+t_mie1)*kmie*0.007);\n        c_ray+= d_ray*c_mul*stp;\n        c_mie+= d_mie*c_mul*stp;\n        \n    }\n    \n    n = normalize(p);\n    c =  dot(normalize(lp),-r.d);\n    nl = dot(n,normalize(lp));\n   \n    \n    col += c_ray*kray*phase_ray(c*c)+c_mie*kmie*phase_mie(-0.77,c,c*c);\n\n    if(length(p)<=er+0.001){\n        nl = smoothstep(-0.3,1.0,nl);\n        col +=fbm(3.*vec2(atan(p.z,p.x),p.y))*getColor(0.4)*0.6*nl;\n        col *=nl;\n        \n    }\n       \n}\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n    vec3 look = normalize(tar-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up    = normalize(cross(look,right));\n    \n    r.o = eye;\n    r.d = normalize(uv.x*right+uv.y*up+look);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv -vec2(0.5);\n    cuv.x*= iResolution.x/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec3 eye = vec3(0,0,-5.);\n    vec3 tar = vec3(0,0,1);\n    vec3 lp  = vec3(5.0*cos(iTime*0.2),0.0,5.0*sin(iTime*0.2));\n    Ray r;\n    setCamera(r,eye,tar,cuv);\n    planet (r,col,lp,vec3(0));\n   \n    \n    col = pow(col,vec3(.45));\n    col = smoothstep(0.,1.,col);\n\n    //Atmosphere(r,col,lp);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 125, 125, 194], [197, 394, 441, 441, 612], [614, 663, 692, 692, 738], [740, 740, 771, 771, 794], [797, 822, 859, 859, 1077], [1080, 1080, 1100, 1100, 1301], [1303, 1303, 1326, 1326, 1730], [1732, 1732, 1751, 1751, 1991], [1994, 1994, 2031, 2031, 2206], [2208, 2208, 2231, 2231, 2304], [2306, 2306, 2329, 2329, 2450], [2455, 2455, 2511, 2511, 4301], [4303, 4303, 4357, 4357, 4566], [4568, 4568, 4625, 4675, 5199]], "test": "ok"}
{"id": "llVBDy", "name": "Kaiware raymarching", "author": "kaiware007", "description": "\"kaiware\" is my character.", "tags": ["raymarching"], "likes": 1, "viewed": 88, "published": "Public", "date": "1543993206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// kaiware raymarching\n//\n// Original Raymarching code(CalcNormal, CalcAO)\n// Deformed by XBE\n// https://www.shadertoy.com/view/XdfSDB\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdKaiware(vec3 p, float sc)\n{\n\t\n\t// scale\n\tp = p / sc;\n\n\t// head - \n\tfloat d1 = sdRoundBox(p, vec3(1, 0.8, 1), 0.1);\n\n\t// beak - \n\tfloat d2_0 = sdRoundBox(p - vec3(0, -0.2, 0.7), vec3(0.8, 0.25, 0.4), 0.1);\n\tfloat d2_1 = sdRoundBox(p - vec3(0, -0.0, 0.7), vec3(1.1, 0.35, 1.1), 0.0);\n\tfloat d2_2 = sdRoundBox(p - vec3(0, -0.4, 0.7), vec3(1.1, 0.35, 1.1), 0.0);\n\tfloat d2_3 = sdRoundBox(p - vec3(0, -0.2, 0.7), vec3(0.75, 0.1, 0.35), 0.1);\n\n\tfloat d2_top = max(d2_0, d2_1);\n\tfloat d2_bottom = max(d2_0, d2_2);\n\tfloat d2 = min(min(d2_top, d2_bottom), d2_3);\n\n\t// stem - \n\tfloat d3_0 = sdCapsule(p, vec3(0, 0.5, 0), vec3(0, 0.75, 0), 0.05);\n\t// leaf - \n\tfloat d3_1 = sdEllipsoid(p - vec3(0.2, 0.75, 0), vec3(0.2, 0.025, 0.1));\n\tfloat d3_2 = sdEllipsoid(p - vec3(-0.2, 0.75, 0), vec3(0.2, 0.025, 0.1));\n\tfloat d3 = min(d3_0, min(d3_1, d3_2));\n\n\t// eyes - \n\tfloat d4_0 = sdCapsule(p, vec3(0.2, 0.25, 0.6), vec3(0.4, 0.2, 0.6), 0.025);\n\tfloat d4_1 = sdCapsule(p, vec3(-0.2, 0.25, 0.6), vec3(-0.4, 0.2, 0.6), 0.025);\n\tfloat d4 = min(d4_0, d4_1);\n\n\t// combine - \n\tfloat sum = max(min(min(d1, d2), d3), -d4);\n\n\tsum *= sc;\n\n\treturn sum;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat map( in vec3 pos )\n{    \n    \n    //pos = repeat(pos, vec3(1.5, 1.5, 1.5));\n\n    pos = rotate(pos, iTime * -2.5, vec3(0,1,0));\n    \n    float l = sdKaiware(pos, 0.5);\n    \n    return l;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n\t\tmap(pos+eps.xyy) - map(pos-eps.xyy),\n\t\tmap(pos+eps.yxy) - map(pos-eps.yxy),\n\t\tmap(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\n// Raymarching\nbool raymarch(vec3 origin, vec3 dir, out float dist, out vec3 norm)\n{\n\tfloat epsilon = 0.001;\n\tfloat maxdist = 10.0;\n\tfloat marched = 0.0;\n\tfloat delta = 2.*epsilon;\n\tdist = -1.0;\n\tfor (int steps=0; steps < 128; steps++)\n\t{\n\t\tif ( ( abs(delta) < epsilon ) || (marched > maxdist) ) continue;\n\t\tdelta *= 0.5;\n        \n        marched += delta;\n        delta = map(origin + marched * dir);\n\t}\n\tbool res = false;\n\tif (marched < maxdist)\n\t{\n\t\tnorm = calcNormal(origin + marched * dir);\n\t\tdist = marched;\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n\tfloat dist = 0.;\n\tvec3 nor = vec3(0.,0.,0.);\n\t//\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\tvec3 sky = vec3(0.32,0.36,0.4) - rd.y*0.4;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tsky += vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n\tsky *= 0.9;\n\t//\n    if ( raymarch(ro, rd, dist, nor) )\n    {\n        vec3 pos = ro + dist*rd;\n\n\t\tcol = vec3(0.65, 1.0, 0.3);\n        \n        float ao = calcAO( pos, nor );\n\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.20*amb*vec3(0.20,0.22,0.26)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.00*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(0.8)*vec3(1.00,0.70,0.60)*spe + 0.2*fre*(0.5+0.5*col);\n\t\tcol = mix( col, sky, 1.0-exp(-0.0025*dist*dist*dist) );\n\t}\n\telse\n\t{\n\t\tcol = sky;\n\t}\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n    // camera\n    vec3 ro = vec3( 0., 0.75, -2. );\n    // target\n\tvec3 ta = vec3(0., 0., 0.);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\tcol = sqrt(col);\n\t\n\tfragColor=vec4( clamp(col,0.,1.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVBDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 238, 284, 284, 340], [342, 342, 392, 392, 510], [512, 512, 549, 549, 638], [640, 640, 675, 687, 1825], [1827, 1827, 1872, 1872, 2301], [2303, 2303, 2329, 2384, 2496], [2498, 2498, 2530, 2530, 2711], [2713, 2728, 2797, 2797, 3258], [3260, 3260, 3302, 3302, 3605], [3607, 3607, 3646, 3646, 4822], [4824, 4824, 4881, 4881, 5385]], "test": "timeout"}
{"id": "llVfD3", "name": "voxel kaiware", "author": "kaiware007", "description": "voxel kaiware", "tags": ["raymarching", "voxel"], "likes": 3, "viewed": 129, "published": "Public", "date": "1544373676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// voxel kaiware\n//\n// Original Raymarching code(CalcNormal, CalcAO)\n// Deformed by XBE\n// https://www.shadertoy.com/view/XdfSDB\n\n#define SQRT3\t1.73205080757\n#define KAIWARE_SIZE 2.5\n\nfloat voxelResolution = 0.1;\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdKaiware(vec3 p, float sc)\n{\n\t\n\t// scale\n\tp = p / sc;\n\n\t// head - \n\tfloat d1 = sdRoundBox(p, vec3(1, 0.8, 1), 0.1);\n\n\t// beak - \n\tfloat d2_0 = sdRoundBox(p - vec3(0, -0.2, 0.7), vec3(0.8, 0.25, 0.4), 0.1);\n\tfloat d2_1 = sdRoundBox(p - vec3(0, -0.0, 0.7), vec3(1.1, 0.35, 1.1), 0.0);\n\tfloat d2_2 = sdRoundBox(p - vec3(0, -0.4, 0.7), vec3(1.1, 0.35, 1.1), 0.0);\n\tfloat d2_3 = sdRoundBox(p - vec3(0, -0.2, 0.7), vec3(0.75, 0.1, 0.35), 0.1);\n\n\tfloat d2_top = max(d2_0, d2_1);\n\tfloat d2_bottom = max(d2_0, d2_2);\n\tfloat d2 = min(min(d2_top, d2_bottom), d2_3);\n\n\t// stem - \n\tfloat d3_0 = sdCapsule(p, vec3(0, 0.5, 0), vec3(0, 0.75, 0), 0.05);\n\t// leaf - \n\tfloat d3_1 = sdEllipsoid(p - vec3(0.2, 0.75, 0), vec3(0.2, 0.025, 0.1));\n\tfloat d3_2 = sdEllipsoid(p - vec3(-0.2, 0.75, 0), vec3(0.2, 0.025, 0.1));\n\tfloat d3 = min(d3_0, min(d3_1, d3_2));\n\n\t// eyes - \n\tfloat d4_0 = sdCapsule(p, vec3(0.2, 0.25, 0.6), vec3(0.4, 0.2, 0.6), 0.025);\n\tfloat d4_1 = sdCapsule(p, vec3(-0.2, 0.25, 0.6), vec3(-0.4, 0.2, 0.6), 0.025);\n\tfloat d4 = min(d4_0, d4_1);\n\n\t// combine - \n\tfloat sum = max(min(min(d1, d2), d3), -d4);\n\n\tsum *= sc;\n\n\treturn sum;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 repeat(vec3 p, vec3 size)\n{\n    return mod(p, size) - 0.5 * size;\n}\n\n// Distance to the voxel\nfloat distVoxel (in vec3 p) {\n\n\t// Rounded box\n\tconst float voxelRadius = 0.1;\n\treturn length (max (abs (p) - 0.5 + voxelRadius, 0.0)) - voxelRadius;\n}\n\nfloat map( in vec3 pos )\n{    \n    \n    pos *= voxelResolution;\n    \n    //pos = repeat(pos, vec3(KAIWARE_SIZE * 2.5));\n\n    //pos = rotate(pos, iTime * -0.5, vec3(0,1,0));\n    \n    float l = sdKaiware(pos, KAIWARE_SIZE);\n    \n    // Scaling\n\tl /= voxelResolution;\n    \n    return l;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n\tvec2 h = vec2 (0.001, -0.001);\n\tvec3 n;\n    p = fract (p + 0.5) - 0.5;\n    n = h.xxx * distVoxel (p + h.xxx) +\n        h.xyy * distVoxel (p + h.xyy) +\n        h.yxy * distVoxel (p + h.yxy) +\n        h.yyx * distVoxel (p + h.yyx);\n\n\treturn normalize (n);\n}\n\n// Distance to the (voxelized?) scene\nbool raymarch(inout vec3 p, in vec3 ray, out float dist, out vec3 norm)\n{\n\tfloat rayLength = 0.0;\n\tfloat rayLengthInVoxel = 0.0;\n\tfloat rayLengthCheckVoxel = 0.0;\n\tvec3 raySign = sign (ray);\n\tvec3 rayDeltaVoxel = raySign / ray;\n    float epsilon = 0.001;\n\tfloat maxdist = 250.0 / voxelResolution;\n\tfloat marched = 0.0;\n\tfloat delta = 2.*epsilon;\n    float rayLengthMax = maxdist / voxelResolution;\n    dist = -1.0;\n    \n\tfor (float rayStep = 0.0; rayStep < 128.0; ++rayStep) {\n\t\tif (rayLength < rayLengthInVoxel) {\n\t\t\tdelta = distVoxel (fract (p + 0.5) - 0.5);\n\t\t\tif (delta < epsilon) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (rayLength < rayLengthCheckVoxel) {\n            \n\t\t\tvec3 rayDelta = (0.5 - raySign * (fract (p + 0.5) - 0.5)) * rayDeltaVoxel;\n\t\t\tfloat dNext = min (rayDelta.x, min (rayDelta.y, rayDelta.z));\n            delta = map(floor (p + 0.5));\n\t\t\tif (delta < 0.0) {\n\t\t\t\trayDelta = rayDeltaVoxel - rayDelta;\n\t\t\t\tdelta = max (rayLengthInVoxel - rayLength, epsilon - min (rayDelta.x, min (rayDelta.y, rayDelta.z)));\n\t\t\t\trayLengthInVoxel = rayLength + dNext;\n\t\t\t} else {\n\t\t\t\tdelta = epsilon + dNext;\n\t\t\t}\n\t\t} else {\n            delta = map(p);\n            if (delta < SQRT3 * 0.5) {\n                rayLengthCheckVoxel = rayLength + abs (delta) + SQRT3 * 0.5;\n                delta = max (rayLengthInVoxel - rayLength + epsilon, delta - SQRT3 * 0.5);\n            }\n\t\t}\n\t\trayLength += delta;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += delta * ray;\n\t}\n    bool res = false;\n    if(delta < epsilon)\n    {\n    \tnorm = calcNormal(p);\n\t\tdist = marched;\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = distVoxel( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n\tfloat dist = 0.;\n\tvec3 nor = vec3(0.,0.,0.);\n\t//\n\tvec3 lig = normalize( vec3(0.6, 0.7, 0.5) );\n    vec3 sky = vec3(0.32,0.36,0.4) - rd.y*0.4;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tsky += vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n\tsky *= 0.9;\n\t//\n    if ( raymarch(ro, rd, dist, nor) )\n    {\n        vec3 pos = ro + dist*rd;\n\n\t\tcol = vec3(0.65, 1.0, 0.3);\n        \n        float ao = calcAO( pos, nor );\n\t\t//float ao = 1.;\n        \n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.20*amb*vec3(0.20,0.22,0.26)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.00*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(0.8)*vec3(1.00,0.70,0.60)*spe + 0.2*fre*(0.5+0.5*col);\n\t\tcol = mix( col, sky, 1.0-exp(-0.0025*dist*dist*dist) );\n\t}\n\telse\n\t{\n\t\tcol = sky;\n\t}\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n    voxelResolution = mix(0.05, 0.25, (sin(iTime * 0.25) * 0.5 + 0.5));\n    \n    float rotSpeed = iTime * 0.7;\n    \n    float camDist = exp(sin(iTime * -0.2) * 4.0 ) * 0.05 + KAIWARE_SIZE * 2.0;\n    //float camDist = 15.;\n    \n    // camera\n    //vec3 ro = vec3( 0., 0.75, -15. ) / voxelResolution;\n    //vec3 ro = vec3( 0., 0., 0. ) / voxelResolution;\n    vec3 ro = vec3(cos(rotSpeed) * camDist, sin(iTime * 0.5) * KAIWARE_SIZE, sin(rotSpeed) * camDist) / voxelResolution;\n    \n    // target\n\tvec3 ta = vec3(0., 0., 0.);\n\t//vec3 ta = ro + vec3(cos(rotSpeed) * camDist, sin(iTime * 0.5) * KAIWARE_SIZE * 10., sin(rotSpeed) * camDist) / voxelResolution;\n    \n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\tcol = sqrt(col);\n\t\n\tfragColor=vec4( clamp(col,0.,1.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 316, 362, 362, 418], [420, 420, 470, 470, 588], [590, 590, 627, 627, 716], [718, 718, 753, 765, 1903], [1905, 1905, 1950, 1950, 2379], [2381, 2381, 2413, 2413, 2453], [2455, 2480, 2509, 2526, 2631], [2633, 2633, 2659, 2659, 2918], [2920, 2920, 2950, 2950, 3207], [3209, 3247, 3320, 3320, 4838], [4840, 4840, 4882, 4882, 5191], [5193, 5193, 5232, 5232, 6436], [6438, 6438, 6495, 6495, 7561]], "test": "ok"}
{"id": "llVfWc", "name": "color saturation", "author": "FabriceNeyret2", "description": "for ultra-bright color sources, the 3 rings of different chrominance in images corresponds to levels of saturation (crossed down as intensity fade).\nColor sliders = intensity at r=1 ( top screen: r=3 ). \n\nMouse control.   bottom-left corner: back to demo.", "tags": ["color", "saturation"], "likes": 12, "viewed": 671, "published": "Public API", "date": "1544382085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         M = iMouse.xy;\n    float t = iTime;\n    if ( length(M) > 10. ) M /= R;\n    else M = .5 + .5* vec2( cos(t)+.5*sin(-3.7*t), cos(.317*t)+.5*cos(4.21*t) ) / 1.5;\n\n  //vec4 C = vec4(2.*M,.5,0);\n    vec4 C =   2.* M.y \n            * ( .5 + .5 * cos( 6.3 *  M.x  + vec4(0,23,21,0) )); // https://www.shadertoy.com/view/ll2cDc\n    O = C / length(3.*(U+U-R)/R.y);\n    \n    U *= 4./R; \n    \n#define S(p,c) if ( abs(U.x-p) < .05 ) O-=O, O.c = step( U.y, C.c )\n    S( .3, r );\n    S( .5, g );\n    S( .7, b );\n    if ( U.x < .8 && abs (U.y-1.) < .01 ) O++;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVfWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 622]], "test": "ok"}
{"id": "llVfWG", "name": "Cookie 2018 NuSan - Round 02", "author": "NuSan", "description": "Shader made live in 25 minutes during Cookie Demo Party 2018, round 02, semifinals", "tags": ["3d", "cookie"], "likes": 9, "viewed": 300, "published": "Public", "date": "1543946234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cookie 2018 NuSan - Round 02\n// Shader made live by NuSan in 25 minutes\n// during Cookie Demo Party 2018 in round 02, semifinals\n// Slightly tweeked as the texture is not the same\n\n#define time iTime\n#define PI 3.1415926535\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat rnd(float t) {\n\n  return fract(sin(t*425.232)*7423.235);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)),10.0) ); \n}\n\nvec3 tunnel(vec3 p) {\n  float t = p.z * 0.3 + curve(p.z, 2.9) + curve(p.z + 74.0, 0.9) * 0.2;\n  p.x += sin(t) * 0.3 + (curve(p.z+42.0,1.0)-0.5)*0.5;\n  p.y += sin(t*1.7 + 23.0)*0.4;\n  p.xy *= rot(p.z*0.1+curve(time, 0.8)*10.1);\n  return p;\n}\n\nfloat map(vec3 p) {\n\n  p = tunnel(p);\n\n  vec3 rp = vec3(atan(p.x,-p.y)*PI, length(p.xy), p.z);\n\n  float j = 2.1 + curve(p.z, 2.9)*2.0;\n  float t = texture(iChannel0, rp.xz*vec2(0.2,1.0)*0.2).x;\n  float a = -cyl(p.xy,j);\n  \n  float c = t + 1.0-cyl(p.xy, 0.9); \n\n  return min(a, min(c, -p.y+1.4 +t*0.3));\n}\n\nvec3 norm(vec3 p) {\n  float base=map(p);\n  vec2 off=vec2(0.01,0);\n  return normalize(vec3( base-map(p-off.xyy), base-map(p-off.yxy), base-map(p-off.yyx) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro = vec3(0,0,-3);\n  vec3 rd = normalize(vec3(-uv, 1));\n\n  ro.z += time * 4.0;\n  ro = tunnel(ro);\n\n  vec3 p = ro;\n  float dd=0.0;\n  float at = 0.0;\n  for(int i=0; i<100; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    p+=rd*d*0.5;\n    dd+=d * 0.5;\n    at += exp(-d);\n  }\n\n  vec3 n = norm(p);\n  vec3 l = normalize(vec3(-1));\n  vec3 h = normalize(l-rd);\n  float lum = max(0.0, dot(l,n));\n\n  vec3 col = vec3(0);\n  col += vec3(0.8,0.7,0.2) * lum;\n  col += vec3(0.8,0.7,1.0) * 0.3 * lum * pow(max(0.0, dot(n,h)), 10.0);\n  col += vec3(0.2,0.3,0.7) * 0.02 * at;\n\n  col += vec3(1,0.5,0.3) * 0.1 * exp(dd*0.1) * (1.0 + curve(time+7.0,0.2)) * 1.0;\n\n  float t1 = time + curve(time+2.0,.9) - length(uv) ;\n  col.xy *= rot(t1);\n  col.yz *= rot(t1*1.2);\n\n  col = abs(col);\n\n  col *= 3.0/dd;\n\n  \n\n  fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 256, 256, 280], [282, 282, 310, 310, 334], [336, 336, 356, 356, 400], [402, 402, 421, 421, 490], [492, 492, 523, 523, 630], [632, 632, 653, 653, 872], [874, 874, 893, 893, 1178], [1180, 1180, 1199, 1199, 1338], [1340, 1340, 1397, 1397, 2375]], "test": "error"}
{"id": "llyfWy", "name": "LSD Circle", "author": "pilad0hwtts", "description": "Just for fun, btw my first shader", "tags": ["circle"], "likes": 3, "viewed": 143, "published": "Public", "date": "1543857881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0., 0., 0., 1.);\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 circle = vec2(0., 0.);\n    float radius = .3f;\n    float size = .05f;\n    float len = length(circle - uv);\n    if (len <= radius + size) {\n        for (float i = 1.; i <= 10.; i++) {\n    \tfloat currentRadius = radius * abs(sin(iTime + i));\n        \tif ((len <= currentRadius + size / i) && (len >= currentRadius - size / i)) {\n        \t\tfragColor.r = (abs(radius - len) / radius) - \n               (abs(currentRadius - len)) / (currentRadius);\n               \tfragColor.b = (abs(radius - len) / radius) - \n               (abs(currentRadius - len)) / (currentRadius) + sin(iTime + i);\n               \tfragColor.g = (abs(radius - len) / radius) - \n               (abs(currentRadius - len)) / (currentRadius) + cos(iTime + i);\n        \t}\n        }\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyfWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 918]], "test": "ok"}
{"id": "ltGBRW", "name": "Wuszt's Ray Marching", "author": "Wuszt", "description": "This is my first ray marching.", "tags": ["raymarching"], "likes": 0, "viewed": 82, "published": "Public", "date": "1545915978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int STEPS_AMOUNT = 1500;\nconst float STEP_VALUE = 0.01f;\nconst vec3 AMBIENT_LIGHT = vec3(0.1f,0.1f,0.1f);\n\n\nfloat SphereSDF(vec3 p)\n{\n    return length(p) - 1.0f;\n}\n\nfloat CubeSDF(vec3 p)\n{\n    vec3 d = abs(p) - vec3(1.0f,1.0f,1.0f);\n    \n    float inside = min(0.0f, max(d.x, max(d.y,d.z)));\n    \n    float outside = length(max(d, 0.0));\n    \n    return inside + outside;\n}\n\nfloat Intersect(float a, float b)\n{\n    return max(a,b);\n}\n\nfloat Difference(float a, float b)\n{\n    return Intersect(a, -b);\n}\n\nfloat Union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat SceneSDF(vec3 p)\n{\n    return Union(SphereSDF(vec3(sin(iTime) * 5.0f,0.0f,0.0f) + p * 2.0f) * 0.5f, Difference(CubeSDF(p) * 1.2f, SphereSDF(p / 1.2f) * 1.2f));\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float e = 0.00001f;\n    \n    vec3 normal;\n    normal.x = SceneSDF(vec3(p.x + e,p.y,p.z)) - SceneSDF(vec3(p.x - e, p.y, p.z));\n    normal.y = SceneSDF(vec3(p.x,p.y + e,p.z)) - SceneSDF(vec3(p.x, p.y - e, p.z));\n    normal.z = SceneSDF(vec3(p.x,p.y,p.z + e)) - SceneSDF(vec3(p.x, p.y, p.z - e));\n    \n    return normalize(normal);\n}\n\nvec3 ProcessLighting(vec3 baseColor, vec3 eyePos, vec3 surfacePoint)\n{\n    vec3 diffuseDir = normalize(vec3(sin(iTime),cos(iTime),1.0f));\n    float diffuseIntensity = 0.7f;\n    \n    vec3 color = AMBIENT_LIGHT * baseColor;\n    \n    vec3 normal = GetNormal(surfacePoint);\n    \n    float d = dot(-diffuseDir, normal);\n    \n    d = abs(d);\n    \n    color += baseColor * d * diffuseIntensity;\n    \n    return color;\n}\n\nvec3 GetColor(vec3 eyePos,vec3 dir)\n{\n    for(int i=0;i<STEPS_AMOUNT;++i)\n    {\n        vec3 currentPoint = eyePos + dir * float(i) * STEP_VALUE;\n        if(SceneSDF(currentPoint) < 0.0f)\n        {\n            vec3 color = vec3(1.0f, 0.0f,0.0f);\n\n            color = ProcessLighting(color, eyePos, currentPoint);\n            \n            return color;\n        }\n    }\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nmat4 GetViewMatrix(vec3 eyePos, vec3 lookAt, vec3 worldUp)\n{\n    vec3 forward = lookAt - eyePos;\n    vec3 side = cross(forward, worldUp);\n    vec3 up = cross(side, forward);\n    \n    forward= normalize(forward);\n    side = normalize(side);\n    up = normalize(up);\n    \n    return mat4(\n        vec4(side, 0.0f),\n        vec4(up, 0.0f),\n        vec4(forward, 0.0f),\n        vec4(0.0f,0.0f,0.0f,1.0f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45.0f, iResolution.xy, fragCoord);\n    \n    vec3 eyePos = vec3(8.0f *sin(iTime),sin(iTime) * 5.0f,8.0f *cos(iTime));\n    \n    dir = (GetViewMatrix(eyePos, vec3(0.0f,0.0f,0.0f), vec3(0.0f,1.0f,0.0f)) * vec4(dir,0.0f)).xyz;\n\n       \n    vec3 color = GetColor(eyePos, dir);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 139, 139, 170], [172, 172, 195, 195, 380], [382, 382, 417, 417, 440], [442, 442, 478, 478, 509], [511, 511, 542, 542, 566], [568, 568, 592, 592, 735], [737, 737, 761, 761, 1096], [1098, 1098, 1168, 1168, 1510], [1512, 1512, 1549, 1549, 1881], [1883, 1883, 1948, 1948, 2079], [2081, 2081, 2141, 2141, 2483], [2485, 2485, 2542, 2542, 2881]], "test": "error"}
{"id": "ltKBRt", "name": "", "author": "hanyeah", "description": "", "tags": ["elecfieldline"], "likes": 2, "viewed": 59, "published": "Public", "date": "1543801709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float jifen(float x, float y0){\n\treturn x * atan(x, y0) - y0 * 0.5 * log(x * x + y0 * y0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    float x0 = uv.x - 0.5;\n    float y0 = uv.y - 0.5;\n    \n    x0 = x0 * col.r;\n    float l = 0.2;\n    float ly = 0.02;\n    float theta1 = jifen(l - x0, abs(y0 - ly)) - jifen(-l - x0, abs(y0 - ly));\n    float theta2 = jifen(l - x0, abs(y0 + ly)) - jifen(-l - x0, abs(y0 + ly));\n    float theta = theta1 + theta2;\n    \n    // float theta = atan(y0, x0);\n    theta = 180.0 * theta / 3.141592653 + 180.0;\n    float alp = mod(theta , 10.0) / 5.0;\n    if(alp > 1.0){\n       alp = 2.0 - alp;\n    }\n    alp = pow(alp, 10.0);\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    fragColor.r = alp;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKBRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 92], [94, 94, 151, 201, 975]], "test": "ok"}
{"id": "ltVBDG", "name": "Mini thingy (129 chars)", "author": "Plento", "description": "My attempt at writing a simple small shader. I bet it could reduce ALOT lol. Curious to see what can be done to it because I dont know many tricks.", "tags": ["2d", "onetweet"], "likes": 6, "viewed": 463, "published": "Public API", "date": "1543963475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// 129 chars by Fabrice \n\nvoid mainImage(out vec4 c,vec2 u){\n    vec2 f = u / iResolution.xy - .5,\n         m = max( abs(f), .1 ),\n         b = ceil( 2.* vec2( f.y * 8.,\n                             f / m.y + iTime ) );\n    c += 1.5 * mod( b.y - b.x, 2. ) * m.y;}\n\n\n             \n             \n// original 172 char            \n             /* \nvoid mainImage( out vec4 c, in vec2 f ){\n    \n    f = f / iResolution.xy - .5;\n    \n    vec2 b = ceil(vec2(f.x / max(abs(f.y), .1) + iTime, f.y * 8.)*2.);\n    \n    c = vec4((1.5) * vec3(mod(b.x - b.y, 2.)), 1.) * max(abs(f.y), .1);\n   \n}\n\n\n*/\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 62, 62, 265]], "test": "ok"}
{"id": "ltVBzt", "name": "Ice Nine", "author": "PianiGiani", "description": "Lines fading in and out", "tags": ["blobs", "lines", "kaleidoscope"], "likes": 10, "viewed": 193, "published": "Public", "date": "1544308971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define nTime (iTime+9000.)/7.\n#define bluridx 35.\n#define BLUE vec3(0.1,.5,.9)*clamp(vec3(abs(sin(nTime+1.))),.1,.9)\n#define RED vec3(0.9,.2,.1)*clamp(vec3(abs(sin(nTime+2.))),.1,.9)\n#define GREEN vec3(0.1,.9,.6)*clamp(vec3(abs(sin(nTime+3.))),.1,.9)\n#define YELLOW vec3(0.9,.9,.0)*clamp(vec3(abs(sin(nTime+4.))),.1,.9)\n\nfloat DDot(vec2 p1,vec2 p2, float blr) {\n    return 1.-(distance(p1,p2)*blr);\n}\n    \n\nfloat N21(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float k = clamp(dot(ap, ab)/dot(ab, ab), 0.0, 1.0);\n    return 1.-smoothstep(0.0, 1.0/iResolution.y, length(ap - k*ab) - 0.0001);\n\n}\n\nvec2 blob_pos(float i) {\n    float t=N21(vec2(i,i+9.));\n    float tt=N21(vec2(i+7.,i+9.));\n    return vec2(sin(nTime+i*t)+tt, cos(nTime+i+t)+tt)*vec2(0.42,0.22);\n}\n\nvec3 ShapeThing(vec2 uv, vec3 inCol, float seed) { \n    \n    vec3 col=vec3(0.,0.,0.);\n    vec3 colmask;\n    vec2 pos;\n    \n    vec2 pos1 = blob_pos(1.+seed);\n\tvec2 pos2 = blob_pos(2.+seed);\n\tvec2 pos3 = blob_pos(3.+seed);\n\tvec2 pos4 = blob_pos(4.+seed);\n    vec2 pos5 = blob_pos(5.+seed);\n\n\tfloat blur1=80.-(bluridx*(sin(iTime*N21(vec2(1.+seed,1.)))));\n    float blur2=80.-(bluridx*(sin(iTime*N21(vec2(2.+seed,2.)))));\n    float blur3=80.-(bluridx*(sin(iTime*N21(vec2(3.+seed,3.)))));\n    float blur4=80.-(bluridx*(sin(iTime*N21(vec2(4.+seed,4.)))));\n    float blur5=80.-(bluridx*(sin(iTime*N21(vec2(5.+seed,5.)))));\n\n   \tcolmask=inCol;\n\tcol=max(colmask*vec3(DDot(uv,pos1,blur1)),col);\n    col=max(colmask*vec3(DDot(uv,pos2,blur2)),col);\n    col=max(colmask*vec3(DDot(uv,pos3,blur3)),col);\n    col=max(colmask*vec3(DDot(uv,pos4,blur4)),col);\n    col=max(colmask*vec3(DDot(uv,pos5,blur5)),col);\n    col += segment(uv,pos1,pos2)*inCol;\n    col += segment(uv,pos1,pos3)*inCol;\n    col += segment(uv,pos3,pos2)*inCol;\n    col += segment(uv,pos1,pos4)*inCol;\n    col += segment(uv,pos2,pos4)*inCol;\n    col += segment(uv,pos3,pos4)*inCol;\n    col += segment(uv,pos5,pos1)*inCol;\n    col += segment(uv,pos5,pos2)*inCol;\n    col += segment(uv,pos5,pos3)*inCol;\n    col += segment(uv,pos5,pos4)*inCol;\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    fragColor = vec4(ShapeThing(uv,RED,0.1),1.0)+vec4(ShapeThing(uv,BLUE,0.2),1.0)+vec4(ShapeThing(uv,GREEN,0.5),1.0)+vec4(ShapeThing(uv,YELLOW,0.6),1.0);\n\tvec2 uv2=uv*vec2(-1.,-1.);\n    fragColor += vec4(ShapeThing(uv2,RED,0.1),1.0)+vec4(ShapeThing(uv2,BLUE,0.2),1.0)+vec4(ShapeThing(uv2,GREEN,0.5),1.0)+vec4(ShapeThing(uv2,YELLOW,0.6),1.0);\n\tuv2=uv*vec2(-1.,1.);\n    fragColor += vec4(ShapeThing(uv2,RED,0.1),1.0)+vec4(ShapeThing(uv2,BLUE,0.2),1.0)+vec4(ShapeThing(uv2,GREEN,0.5),1.0)+vec4(ShapeThing(uv2,YELLOW,0.6),1.0);\n\tuv2=uv*vec2(1.,-1.);\n    fragColor += vec4(ShapeThing(uv2,RED,0.1),1.0)+vec4(ShapeThing(uv2,BLUE,0.2),1.0)+vec4(ShapeThing(uv2,GREEN,0.5),1.0)+vec4(ShapeThing(uv2,YELLOW,0.6),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVBzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 397, 397, 436], [443, 443, 462, 518, 661], [663, 663, 702, 702, 881], [883, 883, 907, 907, 1046], [1048, 1048, 1098, 1098, 2357], [2359, 2359, 2416, 2466, 3233]], "test": "timeout"}
{"id": "ltVfW3", "name": "Modified Star Nest 2", "author": "RaduBT", "description": "Original: Star Nest by Pablo Andrioli (user Kali on Shadertoy). \n\nhttps://www.shadertoy.com/view/XlfGRj\n\nStar Nest by Pablo Andrioli (user Kali on Shadertoy). \n\n\nhttps://www.defold.com/tutorials/shadertoy/#_the_modified_star_nest_shader\n\n", "tags": ["starnest"], "likes": 10, "viewed": 611, "published": "Public API", "date": "1544350368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Star Nest by Pablo Roman Andrioli\n\n// This content is under the MIT License.\n\n#define iterations 20\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.400\n#define tile   0.850\n#define speed  0.0150\n\n#define brightness 0.0055\n#define darkmatter 0.7300*fft\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 pr = fragCoord.xy/iResolution.xy;\n\n    vec3 col = texture( iChannel0, pr ).xyz;\n    //vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n    \n    col *= 0.5 + 0.5*pow( 16.0*pr.x*pr.y*(1.0-pr.x)*(1.0-pr.y), 0.05 );\n    \n    float fft = (((texture( iChannel0, vec2(pr.y+1.0, 0.0) ).y)) * 3.0);\n    \n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.9;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,0.51);\n\tfloat time=iTime*speed+0.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*.03;\n\tfloat a2=.8+iMouse.y/iResolution.y*.03;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.01,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n\t\n}", "image_inputs": [{"id": "XtB3RR", "previewfilepath": "https://soundcloud.com/conromusic/04-conro-midnight-lights-feat-ini-oladosu", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/conromusic/04-conro-midnight-lights-feat-ini-oladosu", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVfW3.jpg", "access": "shaders20k", "license": "mit", "functions": [[343, 343, 400, 400, 1983]], "test": "error"}
{"id": "ltVfWG", "name": "Cookie 2018 NuSan - Round 01", "author": "NuSan", "description": "Shader made live in 25 minutes during Cookie Demo Party 2018, round 01", "tags": ["3d", "cookie"], "likes": 10, "viewed": 244, "published": "Public", "date": "1543945623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cookie 2018 NuSan - Round 01\n// Shader made live by NuSan in 25 minutes\n// during Cookie Demo Party 2018, round 01\n\n#define time iTime\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n\n}\n\n\nfloat cyl(vec3 p, float r) {\n  return length(p.xy) - r;\n\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b, k) - k * (1.0-k) * h;\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*234.231)*7423.215);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0, fract(g) ), 10.0));\n\n}\n\nfloat map(vec3 p) {\n\n  float d = 10000.0;\n  float j = 10000.0;\n\n  for(int i=0;i<8; ++i) {\n\n    float t1 = time + float(i)*2.354 + curve(time+85.24, 20.9*float(i)+0.2)*3.0;\n    p.xy *= rot(t1);\n    p.yz *= rot(t1*0.7);\n\n    d = smin(d, sph(p, 0.1 * float(i)+.1), 0.2);\n\n    p -= 0.2;\n    p = abs(p);\n\n    p.xy *= rot(t1*1.3);\n    \n    d = smin(d, -cyl(p, 0.05), -0.3);\n    j = min(j, cyl(p.yzx, 0.05));\n  }\n\n  j = smin(j, sph(p, 1.0), 0.3);\n\n  return min(j,d);\n}\n\nvec3 norm(vec3 p) {\n  float base=map(p);\n  vec2 off=vec2(0.01,0);\n  return normalize( vec3(base-map(p-off.xyy), base-map(p-off.yxy), base-map(p-off.yyx) ));\n}\n\nvec3 cam(vec3 p) {\n  float t2 = time + curve(time, 0.9)*3.0;\n  p.xy *= rot(t2);\n  p.xz *= rot(t2*1.2);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  uv.x += (curve(time+85.0,0.8)-0.5) * 0.4;\n  uv.y += (curve(time+85.0,0.7)-0.5) * 0.3;\n\n  vec3 ro = vec3(0,0,-3);\n  vec3 rd = normalize(vec3(-uv,0.1 + curve(time+52.0, 1.2)));\n\n  ro=cam(ro);\n  rd=cam(rd);\n\n  vec3 p = ro;\n  float dd = 0.0;\n  float at = 0.0;\n  for(int i=0;i<100; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd = 100.0;\n      break;\n    }\n\n    p+=rd*d;\n    dd+=d;\n    at += exp(-d);\n  }\n\n\n  vec3 n = norm(p);\n  vec3 l = normalize(vec3(-1));\n  vec3 h = normalize(l-rd);\n\n\n  vec3 col = vec3(0);\n  \n  float lum = max(0.0, dot(n, l));\n  float amb = -n.y*0.5+0.5;\n  col += vec3(0.8,0.7,0.2) * lum;\n  col += vec3(0.2,0.3,1.0) * amb;\n\n  col += vec3(0.8,0.9,1.0) * 0.4 * lum * pow(max(0.0,dot(n,h)), 10.0);\n  col += vec3(0.1,0.2,1.0) * 4.7 * amb * pow(1.0-max(0.0,dot(n,-rd)), 3.0);\n\n  col *= 4.0/dd;\n\n  col += pow(at*0.02,0.3) * 0.7;\n  \n  col += pow(abs(fract(at)-0.5) * (1.0-step(dd,50.0)), 5.0) * 10.2 * curve(time+81.0,1.4);\n\n  float t3 = time + curve(time+85.0,1.5);\n  col.xy *= rot(t3);\n  col.yz *= rot(t3*1.2);\n  col.xz *= rot(t3*0.7);\n  col = abs(col);\n\n  col *= pow(clamp(1.0-length(uv),0.0,1.0),2.0);\n\n  fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 167, 167, 194], [197, 197, 225, 225, 255], [257, 257, 276, 276, 345], [347, 347, 386, 386, 472], [474, 474, 494, 494, 537], [539, 539, 570, 570, 679], [681, 681, 700, 700, 1142], [1144, 1144, 1163, 1163, 1302], [1304, 1304, 1322, 1322, 1420], [1422, 1422, 1479, 1479, 2813]], "test": "ok"}
{"id": "ltyfDd", "name": "Procedural City", "author": "Gr", "description": "Procedural Generated City developed as a part of a final project in a graphics course.\nProcedural texture generation is also a feature.", "tags": ["city"], "likes": 5, "viewed": 189, "published": "Public", "date": "1544811254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define BOX 3\n#define HEX 4\n#define SW 5\n\n#define STORY 0.125\n#define BUILD_R 0.32\n#define MID_SEC 0.1\n\n//Section Heights\n#define MAX_S1 4.0\n#define MAX_S2 2.0\n#define MAX_S3 2.0\n    \n//DownTownSPECS\n#define D_RAD 10.0\n\n\n//Road Mapping\n#define SIDEWALK_H 0.01\n#define SIDEWALK_W 0.01\n\n#define YELLOW_MIN 0.48\n#define YELLOW_MAX 0.49\n\n#define DASH_MIN 0.36\n#define DASH_MAX 0.39\n#define DASH_LEN 0.03\n\n#define CROSS_MIN 0.25\n#define CROSS_MAX 0.35\n#define CROSS_LEN 0.08\n\n\n#define M_PI 3.14159265358979323846264338327950288\n//Noise Funcs\n//2D func adapted from terrain\nfloat rand_2_1(vec2 v) {\n    return fract(sin(v.x * 127.1 + v.y * 311.7) * 43758.5453123);\n}\nfloat rand_1_1(float f) {\n    return fract(sin(f * 435.23) * 5489.9847);\n}\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n    \n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 x = texture(sam, p.yz);\n    vec4 y = texture(sam, p.xz);\n    vec4 z = texture(sam, p.xy);\n    x *= abs(n.x);\n    y *= abs(n.y);\n    z *= abs(n.z);\n    vec3 projections = vec3(x + y + z);\n\n   return projections;\n}\n\n//From TheBookOfShaders Rotation article\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n//http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotate3d(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\n//From http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdHexPrism(vec3 pos, vec2 h)\n{\n    vec3 p = vec3(pos.x, pos.y - h.y, pos.z);\n    p = rotate3d(vec3(1.0, 0.0, 0.0), M_PI/2.0) * p;\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox(vec3 pos, vec3 b)\n{\n  vec3 p = pos;\n  p = vec3(pos.x, pos.y - b.y, pos.z);\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n//Compare pd by distance\nPrimitiveDist compPD(PrimitiveDist d1, PrimitiveDist d2)\n{\n    if(d1.dist<d2.dist){\n        return d1;\n    } else {\n        return d2;\n    }\n}\n\nPrimitiveDist section(vec3 p, float rad, int stories, vec2 id){\n    float side = rad*0.75;\n    float randForShape = rand_1_1(rand_2_1(id));\n    if(randForShape < 0.6){\n        float box = sdBox(p, vec3(side, float(stories) * STORY, side));\n\t\tPrimitiveDist boxPD = PrimitiveDist(box, BOX);\n        \n        float randForTower = rand_1_1(rand_1_1(id.x) + rand_1_1(id.y));\n        if(randForTower > 0.7){\n            float randTower = rand_1_1(randForTower);\n            vec3 offsetPos;\n            if(randTower < 0.25){\n                offsetPos = p + vec3(side * 0.5, 0.0, 0.0);\n            } else if((randTower > 0.25) && (randTower < 0.5)) {\n                offsetPos = p + vec3(-side * 0.5, 0.0, 0.0);\n            } else if((randTower > 0.5) && (randTower < 0.75)) {\n                offsetPos = rotate3d(vec3(0.0, 1.0, 0.0), M_PI/2.0) * (p + vec3(0.0, 0.0, side * 0.5));\n            } else {\n                offsetPos = rotate3d(vec3(0.0, 1.0, 0.0), M_PI/2.0) * (p + vec3(0.0, 0.0, -side * 0.5));\n            }\n            float tower = sdHexPrism(offsetPos, vec2(side, float(stories) * STORY));\n            PrimitiveDist towerPD = PrimitiveDist(tower, HEX);\n            return compPD(boxPD, towerPD);\n        } else {\n            return boxPD;\n        }\n    } else {\n        float hex = sdHexPrism(p, vec2(side, float(stories) * STORY));\n\t\tPrimitiveDist hexPD = PrimitiveDist(hex, HEX);\n        \n        float randForTower = rand_1_1(rand_1_1(id.x) + rand_1_1(id.y));\n        if(randForTower > 0.5){\n            float randTower = 0.9 * rand_1_1(randForTower); // Scale to make probabilities nicer\n            vec3 offsetPos;\n            mat3 rot = rotate3d(vec3(0.0, 1.0, 0.0), M_PI/3.0);\n            vec3 dir1 = vec3(cos(M_PI/6.0),0.0, sin(M_PI/6.0));\n            vec3 dir2 = vec3(cos(M_PI*5.0/6.0),0.0, sin(M_PI*5.0/6.0));\n            float mag = side * sqrt(3.0)/2.0;\n            if(randTower > 0.5){\n                offsetPos = rot * (p + mag * dir1);\n            } else if((randTower > 0.15) && (randTower < 0.3)) {\n                offsetPos = rot * (p + mag * -dir1);\n            } else if((randTower > 0.3) && (randTower < 0.45)) {\n                offsetPos = rot * (p + mag * dir2);\n            } else if((randTower > 0.45) && (randTower < 0.6)){\n                offsetPos = rot * (p + mag * -dir2);\n            } else if((randTower > 0.6) && (randTower < 0.75)){\n                offsetPos = p + mag * vec3(0.0, 0.0, 1.0);\n            } else {\n                offsetPos = p - mag * vec3(0.0, 0.0, 1.0);\n            }\n    \t\tfloat tower = sdBox(offsetPos, vec3(side * 0.5, float(stories) * STORY, side * 0.5));\n            PrimitiveDist towerPD = PrimitiveDist(tower, BOX);\n            return compPD(hexPD, towerPD);\n        } else {\n            return hexPD;\n        }\n    }\n}\n\nPrimitiveDist building(vec3 p){\n    vec2 block = floor(p.xz);\n    vec3 blockPos = vec3(fract(p.x) - 0.5, p.y, fract(p.z)- 0.5);\n    float randSections = rand_2_1(block);\n    float sf1 = 2.0 + floor(rand_1_1(randSections) * MAX_S1 * D_RAD/length(block));\n    if(length(block) == 0.0){\n        sf1 = 8.0;\n        //Inifinte edge case due to division by 0\n    }\n    if(sf1 > 15.0){\n    \tsf1 = 15.0;\n    }\n    PrimitiveDist s1 = section(blockPos, BUILD_R, int(sf1), block);\n    PrimitiveDist outSh = s1;\n    if(randSections > 0.5) {\n        //2nd section\n        float sf2 = 1.0 + floor(rand_1_1(sf1) * MAX_S2 * D_RAD/length(block)/1.5);\n        if(sf2 > 15.0){\n    \t\tsf2 = 15.0;\n    \t}\n        PrimitiveDist s2 = section(blockPos + vec3(0.0, -2.0 * sf1 * STORY, 0.0), 0.5 * BUILD_R, int(sf2), 2.0 * block);\n        outSh = compPD(outSh, s2);\n        //Third section\n        if(randSections > 0.75){\n            float sf3 = 1.0 + floor(rand_1_1(sf2) * MAX_S3 * D_RAD/length(block)/1.5);\n            PrimitiveDist s3 = section(blockPos + vec3(0.0, -2.0 * (sf1 + sf2 )* STORY, 0.0), 0.25 * BUILD_R, int(sf3), 3.0 * block);\n            outSh = compPD(outSh, s3);\n        }\n    }\n    float sideWalk = sdBox(blockPos, vec3(BUILD_R, SIDEWALK_H, BUILD_R));\n    PrimitiveDist sw = PrimitiveDist(sideWalk, SW);\n    return compPD(outSh, sw);\n}\n\n\nPrimitiveDist map(vec3 p) {\n\tPrimitiveDist building = building(p);\n    float plane = sdFloor(p);\n    PrimitiveDist outSh = building;\n    outSh = compPD(outSh, PrimitiveDist(plane, 1));\n    return outSh;\n}\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float xCom = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    float yCom = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    float zCom = map(p + e.yyx).dist - map(p - e.yyx).dist;\n\n    return normalize(vec3(xCom, yCom, zCom));\n//    return normalize(vec3(0.5));\n\n}\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n\n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n        darkness = min(darkness, k*h/marchDist);\n        marchDist += h * 0.7;\n    }\n    return darkness;\n}\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 500.0;\n    float threshold = 0.001;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 4000; i++) {\n        // Fill in loop body\n        vec3 currPos = ro + rd*(marchDist);\n        PrimitiveDist dist2Geo = map(currPos);\n\n        if(dist2Geo.dist < threshold){\n            return PrimitiveDist(marchDist, dist2Geo.primitive);\n        }if(marchDist > boundingDist){\n            return PrimitiveDist(-1.0, NO_INTERSECT);\n\n        }\n        marchDist += dist2Geo.dist*0.1f;\n    }\n\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 roadColor(vec3 blockPos){\n    vec3 material = vec3(0.0);\n    if(abs(blockPos.x) > CROSS_MIN && abs(blockPos).z > CROSS_MIN) {\n        //Intersections\n        if(abs(blockPos.x) > CROSS_MIN && abs(blockPos.x) < CROSS_MAX){\n            //Crosswalk\n            material = vec3(0.8, 0.8, 0.8);\n            float linePos = fract((blockPos.z + 0.5)/CROSS_LEN);\n            if(linePos < 0.5 && \n               !(abs(blockPos.z) > CROSS_MIN && abs(blockPos.z) < CROSS_MAX)){\n                material = vec3(0.8, 0.8, 0.8);\n            } else {\n                material = vec3(0.2, 0.2, 0.2);\n            }                                                            \n        } else if(abs(blockPos.z) > CROSS_MIN && abs(blockPos.z) < CROSS_MAX){\n            //Crosswalk\n            material = vec3(0.8, 0.8, 0.8);\n            float linePos = fract((blockPos.x + 0.5)/CROSS_LEN);\n            if(linePos < 0.5 &&\n              !(abs(blockPos.x) > CROSS_MIN && abs(blockPos.x) < CROSS_MAX)){\n                material = vec3(0.8, 0.8, 0.8);\n            } else {\n                material = vec3(0.2, 0.2, 0.2);\n            } \n        }else {\n            material = vec3(0.2, 0.2, 0.2);\n        }\n    }else if(abs(blockPos.x) > DASH_MIN && abs(blockPos.x) < DASH_MAX){\n        //White Dashes\n        float linePos = fract((blockPos.z + 0.5)/DASH_LEN);\n        if(linePos < 0.5){\n            material = vec3(0.8, 0.8, 0.8);\n        } else {\n            material = vec3(0.2, 0.2, 0.2);\n        } \n    } else if(abs(blockPos.z) > DASH_MIN && abs(blockPos.z) < DASH_MAX){\n        //White Dashes\n        float linePos = fract((blockPos.x + 0.5)/DASH_LEN);\n        if(linePos < 0.5){\n            material = vec3(0.8, 0.8, 0.8);\n        } else {\n            material = vec3(0.2, 0.2, 0.2);\n        }\n    } else if((abs(blockPos.z) > YELLOW_MIN && abs(blockPos.z) < YELLOW_MAX)||\n              (abs(blockPos.x) > YELLOW_MIN  && abs(blockPos.x)< YELLOW_MAX)){\n        //Yellow Line(s)\n        material = vec3(0.8, 0.6, 0.2);\n    } else {\n        material = vec3(0.2, 0.2, 0.2);\n    }\n    return material;\n}\nvec3 texCol(vec2 uv, vec2 id){\n    float r1 = rand_2_1(id);\n    float g1 = rand_1_1(r1);\n    float b1 = rand_1_1(g1);\n    \n    float r2 = rand_1_1(b1);\n    float g2 = rand_1_1(r2);\n    float b2 = rand_1_1(g2);\n    \n    vec3 colFrom = vec3(0.4, 0.4, 0.4);\n    vec3 colTo = vec3(1.0, 0.6, 0.5);\n    vec3 col1 = colFrom + colTo*vec3(r1, g1, b1);\n    vec3 col2 = colFrom + colTo*vec3(r2, g2, b2);\n    if(uv.y < 0.333){\n        return col1;\n    } else if (uv.y < 0.999 && uv.y > 0.666){\n        return col1;\n    } else if(uv.x > 0.333 && uv.x < 0.666){\n        return vec3(0.2, 0.2, 0.2);\n    } else {\n        return col2;\n    }\n}\n//We assume a STORYxSTORY texMap\nvec3 buildTex(vec3 pos, vec2 id, vec3 nor){\n    vec2 uv;\n    vec3 dir1 = vec3(cos(M_PI/6.0),0.0, sin(M_PI/6.0));\n    vec3 dir2 = vec3(cos(M_PI*5.0/6.0),0.0, sin(M_PI*5.0/6.0)); \n    \n    if(nor == vec3(0.0, 1.0, 0.0)){\n        return vec3(0.1, 0.4, 0.8);\n    }\n    //CubeGriding\n    \n    else if (abs(nor) == vec3(1.0, 0.0, 0.0)){\n        float yFr = fract(pos.y/STORY);\n        float zFr = fract(pos.z/STORY);\n        uv = vec2(zFr, yFr);\n    }else if (abs(nor) == vec3(0.0, 0.0, 1.0)){\n        float yFr = fract(pos.y/STORY);\n        float xFr = fract(pos.x/STORY);\n        uv = vec2(xFr, yFr);\n    }\n    //ExtraChecks for Hex\n    else if (length(nor - dir1) < 0.001 || length(-nor - dir1) < 0.001){\n        vec2 posRot = rotate2d(-M_PI/3.0) * vec2(pos.x, pos.z);\n        float yFr = fract(pos.y/STORY);\n        float xFr = fract(posRot.x/STORY);\n        float zFr = fract(posRot.y/STORY);\n        uv = vec2(xFr, yFr);\n    } else if (length(nor - dir2) < 0.001 || length(-nor - dir2) < 0.001){\n        vec2 posRot = rotate2d(M_PI/3.0) * vec2(pos.x, pos.z);\n        float yFr = fract(pos.y/STORY);\n        float xFr = fract(posRot.x/STORY);\n        float zFr = fract(posRot.y/STORY);\n        uv = vec2(xFr, yFr);\n    }\n    return texCol(uv, id);\n}\nvec3 skyCol(vec3 ro, vec3 rd, float t, int which) {\n    vec3 col = vec3(0.2, 0.5, 0.65);\n    vec3 pos = ro + rd * t;\n    if(pos.y < 1.0){\n        col *= dot(normalize(rd), normalize(vec3(rd.x, 3.0, rd.z)));\n    }\n    return col;\n}\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n\n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n\n    // Normal vector\n    vec3 nor = calcNormal(pos);\n\n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0;\n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n\n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n\n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    \n    vec2 block = floor(pos.xz);\n    vec3 blockPos = vec3(fract(pos.x) - 0.5, pos.y, fract(pos.z)- 0.5);\n    \n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = roadColor(blockPos);\n    } else if (which == SW){\n        material = vec3(0.8, 0.8, 0.6);\n    } else if (which == HEX || which == BOX) {\n        material = buildTex(blockPos, block, nor);\n    } else {\n        material = vec3(0.3, 0.3, 0.8);\n    }\n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    return col;\n}\nfloat smoothRand(vec2 cellPos, vec2 cellId){\n    float vecNoiseVal = rand_2_1(cellId);\n\n    float topVal = rand_2_1(cellId);\n    float botVal = rand_2_1(cellId + vec2(1.0, 0.0));\n    float mixedH = mix(topVal, botVal, cellPos.x);\n\n    float lVal = rand_2_1(cellId + vec2(0.0, 1.0));\n    float rVal = rand_2_1(cellId + vec2(1.0, 1.0));\n    float mixedW = mix(lVal, rVal, cellPos.x);\n\n    float mixedFull = mix(mixedH, mixedW, cellPos.y);\n    return mixedFull;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 rayOrigin = vec3(sin(iTime * 0.3) * 6.0, 6., -3.0 + 6.0 *  cos(iTime * 0.3));\n\n    float focalLength = 2.0;\n\n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n\n    // TODO [Task 1] Construct the ray direction vector\n    vec2 uv = vec2(0.0);\n    vec3 rayDirection = vec3(0.0);\n    float u = gl_FragCoord.x/iResolution.x;\n    float v = gl_FragCoord.y/iResolution.y;\n    u= 2.0f*u - 1.0f;\n    v= 2.0f*v - 1.0f;\n    u= u*(iResolution.x/iResolution.y);\n    uv = vec2(u, v);\n\n    rayDirection = vec3(uv, focalLength);\n\n    cameraRight *= rayDirection.x;\n    cameraUp *= rayDirection.y;\n    cameraForward *= rayDirection.z;\n    rayDirection = normalize(cameraRight + cameraUp + cameraForward);\n\n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n        col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    } else {\n        vec2 cellPos = fract(fragCoord/iResolution.xy * 10.);\n        vec2 cellId = floor(fragCoord/iResolution.xy * 10.);\n        \n        float mixedFull = smoothRand(cellPos, cellId);\n        col = mixedFull * vec3(1.0, 1.0, 1.0) + vec3(0.2, 0.45, 0.650);\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[579, 624, 648, 648, 716], [717, 717, 742, 742, 791], [899, 1016, 1068, 1068, 1290], [1292, 1333, 1361, 1361, 1447], [1449, 1517, 1556, 1556, 2028], [2031, 2031, 2054, 2054, 2072], [2074, 2152, 2188, 2188, 2570], [2572, 2572, 2603, 2603, 2754], [2756, 2781, 2839, 2839, 2923], [2925, 2925, 2988, 2988, 5711], [5713, 5713, 5744, 5744, 7042], [7045, 7045, 7072, 7072, 7249], [7351, 7368, 7393, 7393, 7658], [7659, 7659, 7700, 7700, 8125], [8126, 8126, 8168, 8195, 8783], [8785, 8785, 8815, 8815, 10872], [10873, 10873, 10903, 10903, 11498], [11499, 11532, 11575, 11575, 12780], [12781, 12781, 12832, 12832, 13011], [13012, 13012, 13063, 13116, 14338], [14339, 14339, 14383, 14383, 14799], [14800, 14800, 14854, 14854, 16425]], "test": "error"}
{"id": "MdlyDn", "name": "Koleidoskopic Distance", "author": "gPlatl", "description": "Show 2d koleidoskopic projection distance.    mouse.x -> changes leave count", "tags": ["2d", "distance", "koleidoskop"], "likes": 6, "viewed": 115, "published": "Public", "date": "1545319288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------------\n// KoleidoskopicDistance.glsl\n// Show 2d koleidoskopic projection distance.    \n// mouse.x -> changes leave count\n// Based on:   \n//  Flower-DF:         https://www.shadertoy.com/view/MldXRN\n//  Ellipse-Distance:  https://www.shadertoy.com/view/4sS3zz\n//----------------------------------------------------------\n\nconst float TWO_PI  = 6.28318530718;\n\n//----------------------------------------------------------\nfloat sdKoleidoskopic(vec2 pos, int N) // calculate distance\n{\n    float st = sin(iTime*0.4);\n\tfloat ka = atan(pos.x, pos.y) / TWO_PI * float(N);\n    return length(pos) - mix(0.6, 0.5+st,abs(fract(ka)-.5));\n}\n//----------------------------------------------------------\nvec3 distanceColors (in float d)         // d=distance \n{\n  vec3 color = vec3(0.1, 0.4, 0.7);      // inner color\n  color = vec3(1.0) - sign(d)*color;     // + outer color\n  color *= 1.0 - exp(-2.0*abs(d));       // distance darken\n  color *= 0.8 + 0.2*cos(120.0*abs(d));  // distance lines \n  color = mix(color, vec3(1.0), 1.-smoothstep(0.0,0.02,abs(d)));  //white frame\n  return color;  \n}\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2.0 -iResolution.xy) / iResolution.y;\n    \n    int leaves = 10 - int (10.*iMouse.x / iResolution);\n    \n    float d = sdKoleidoskopic (uv, leaves);    \n\n    fragColor = vec4(distanceColors(d),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 474, 536, 536, 682], [683, 744, 801, 801, 1135], [1136, 1197, 1254, 1254, 1474]], "test": "ok"}
{"id": "Ml3fDB", "name": "Quaternion RGB vector rotation", "author": "cardinalsine", "description": "A demo using quaternion math to rotate a 3D (r, g, b) vector through color space. Also featured: the logistic map, and a version interpolated by a raised inverted cosine.", "tags": ["math", "abstract"], "likes": 4, "viewed": 158, "published": "Public", "date": "1544302191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define u_t iTime\n#define u_res iResolution\n#define u_mouse iMouse\n#define PI 3.1415926\n\nvec4 qNorm(vec4 q) {\n    float magnitude = sqrt(q.x*q.x+q.y*q.y+q.z*q.z+q.w*q.w);\n    return q/magnitude;\n}\n\nvec4 qMatToVec(mat4 q) {\n    //return transpose(q)[1];\n    return vec4(q[0][0],q[0][1],q[0][2],q[0][3]);\n}\n\nmat4 qNorm(mat4 q) {\n    return q/length(qMatToVec(q));\n}\n\nmat4 qVecToMat(vec4 q) {\n    return mat4( q.x, q.y, q.z, q.w,\n                -q.y, q.x,-q.w, q.z,\n                -q.z, q.w, q.x,-q.y,\n                -q.w,-q.z, q.y, q.x);\n}\n\nmat4 qRotate(mat4 q, float theta) {\n    float r = cos(theta/2.);\n    vec3 v = vec3(sin(theta/2.));\n    mat4 a = qVecToMat(vec4(r,v));\n    return q*a;\n}\n\nmat4 qConj(mat4 q) {\n    return transpose(q);    \n}\n\nvec3 qRotate3D(vec3 v, vec3 axis, float theta) {\n    mat4 p = qVecToMat(vec4(0.,v));\n    mat4 q = qRotate(qVecToMat(qNorm(vec4(1.,axis))),theta);\n    mat4 q_ = transpose(q);\n    mat4 p_ = q*p*q_;\n    \n    return qMatToVec(p_).yzw;\n}\n\nfloat logisticMap(float n, float x0, float r){\n\tx0 = clamp(x0, 0., 1.);\n    r = clamp(r,0.,4.);\n    \n    float x = x0;\n    for(float i = 0.; i < n; i++) {\n        x *= r*(1.-x);\n    }\n    return x;\n}\n\nfloat cosInterp(float x, float p0, float p1) {\n    return p0+(p1-p0)*0.5*(1.-cos(PI*fract(x)));\n}\n\nfloat logisticMapInterp(float n, float x0, float r) {\n    return cosInterp(n, logisticMap(n,x0,r), logisticMap(n+1.,x0,r));\n}\n\nfloat cosNorm(float x) {\n    // cos(x) normalized to be between 0 and 1\n    return 0.5*(1.+cos(x));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = abs(-1.+2.*fragCoord/iResolution.xy);\n    vec2 mpos = iMouse.xy/iResolution.xy;\n    \n    vec3 a = 0.5+vec3(0.25,-0.125,0.125);\n    vec3 b = 0.5+vec3(0.);\n    \n    vec3 a_ = normalize(a)/sqrt(3.);\n    vec3 b_ = normalize(b)/sqrt(3.);\n    \n    float n = -1.;\n    float m = 4.0;\n    \n    float w_r = exp2(-4.)*PI;\n    \n    float r1 = 2.+2.*cosNorm(w_r*u_t);\n    float r2 = 2.+2.*cosNorm(w_r*u_t+PI/2.);\n\n\tfloat lMap_xy = (2.*(logisticMap(m*uv.x, uv.y, r1)))/2.;\n    float lMap_yx = floor(2.*(logisticMapInterp(m*uv.y, uv.x, r2)))/2.;\n    float lMap_intersect = lMap_xy*lMap_yx;\n    \n    float steps_x = 0.5*(1.+1.*floor((uv.x)*m)/(m));\n    float colGrad_y = (0.9+0.1*uv.y);\n    float colGrad_x = 1.;\n\n    float colorOffset = 0.5*steps_x*(lMap_xy*colGrad_y+lMap_yx*colGrad_x);\n    float theta = 2.*PI*(0.125*uv.y+0.75*lMap_intersect+0.*colorOffset);\n\n    // invert colors when the pattern repeats\n    float s = mod(floor(w_r/PI*u_t+0.5), 2.);\n    \n    vec3 col = qRotate3D(a_, b_, theta);\n    col = mix(col, 1.-col, s);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3fDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 109, 109, 196], [198, 198, 222, 252, 304], [306, 306, 326, 326, 363], [365, 365, 389, 389, 540], [542, 542, 577, 577, 693], [695, 695, 715, 715, 746], [748, 748, 796, 796, 980], [982, 982, 1028, 1028, 1181], [1183, 1183, 1229, 1229, 1280], [1282, 1282, 1335, 1335, 1407], [1409, 1409, 1433, 1480, 1510], [1514, 1514, 1571, 1621, 2709]], "test": "ok"}
{"id": "MlGBDc", "name": "Simple Raytracer with Atmosphere", "author": "skythedragon", "description": "A simple raytracer that also includes atmospheric fog.\nIt's the first shader I ever made.", "tags": ["raytracer", "fog", "rendering", "atmosphere", "dem"], "likes": 7, "viewed": 291, "published": "Public", "date": "1544279345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// define some standard values\n#define Epsilon 1e-3\n#define Bounces 4 // light bounces\n#define Max 1e24 // high value for distance\n\n\n// ray struct\nstruct Ray {\n    vec3 Origin;\n    vec3 Direction;\n};\n    \n// Material struct, stores material properties\nstruct Material {\n    vec3 Color;\n    float Diffuse;\n    float Specular;\n};\n    \n// struct representing a ray hitting the surface\n// length is 0 for a miss\nstruct Hit {\n\tvec3 Normal;\n    float Length;\n    Material material;\n};\n\nconst Hit miss = Hit(vec3(0), 0.0, Material(vec3(0), 0.0, 0.0));\n\n// a sunlight\nstruct DirectionalLight {\n    vec3 Direction;\n    vec3 Color;\n};\n    \n// objects\nstruct Sphere {\n    float Radius;\n    vec3 Position;\n    Material material;\n};\n\nstruct Plane {\n    vec3 Normal;\n    Material material;\n};\n\n// intersection functions\n// sphere\nHit Intersect(Ray ray, Sphere sphere) {\n    // Check for a Negative Square Root\n    vec3 oc = sphere.Position - ray.Origin;\n    float l = dot(ray.Direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.Radius, 2.0);\n    if (det < 0.0) return miss;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Hit((ray.Origin + len*ray.Direction - sphere.Position) / sphere.Radius, len, sphere.material);\n}\n\n\n\n\n// Plane\nHit Intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.Origin, plane.Normal) / dot(ray.Direction, plane.Normal);\n    if (len < 0.0) return miss;\n    return Hit(plane.Normal, len, plane.material);\n}\n\n// traces the scene, in this case it's hardcoded\nHit Trace(Ray ray) {\n    // scene\n    Hit SphereA = Intersect(ray, Sphere(2.0, vec3(-3, 1.9, 2), Material(vec3(0.0, 0.16, 0.28), 0.1, 0.1)));\n    Hit SphereB = Intersect(ray, Sphere(2.0, vec3(3, 1.9, 2), Material(vec3(0.9, 0.9, 0.9), 0.5, 0.1)));\n    Hit plane = Intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\n    // distance\n    float dist = 1e12;\n    Hit vout = miss;\n    if (SphereA != miss && SphereA.Length < dist) { vout = SphereA; dist = SphereA.Length; }\n    if (SphereB != miss && SphereB.Length < dist) { vout = SphereB; dist = SphereB.Length; }\n    if (plane != miss && plane.Length < dist) { vout = plane; dist = plane.Length; }\n    return vout;           \n}\n\n// function to add atmospheric fog to the image\n// original by Inigo Quilez https://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 ApplyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0; - exp( -distance*1.0);\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.3,0.7,1.0)*8.0, // bluish\n                           vec3(1.0,0.9,0.7)*32.0, // yellowish\n                           pow(sunAmount,64.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n \n\n// const DirectionalLight light = DirectionalLight(normalize(vec3(-1.0, 0.75, 1.0)), vec3(100));\n\n// computes the color of a ray\nvec3 CalculateColor(Ray ray) {\n    \n    DirectionalLight light = DirectionalLight(normalize(vec3(cos(iTime/2.0), 0.5, sin(iTime/2.0))), vec3(200,200,200));\n    \n    vec3 Color = vec3(0);\n    vec3 fresnel = vec3(0);\n    vec3 mask = vec3(1.0);\n    for(int i = 0; i < Bounces; ++i) {\n        Hit hit = Trace(ray);\n        if (hit != miss) { \n            // if it hit something\n            vec3 r0 = hit.material.Color.rgb * hit.material.Specular;\n            float hv = clamp(dot(hit.Normal, -ray.Direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 8.0);\n            mask *= fresnel;\n            \n            if (Trace(Ray(ray.Origin + hit.Length * ray.Direction + Epsilon * light.Direction, light.Direction)) == miss) {\n                \n                Color += clamp(dot(hit.Normal, light.Direction), 0.0, 1.0) * light.Color\n                       * hit.material.Color.rgb * hit.material.Diffuse\n                       * (1.0 - fresnel) * mask / fresnel;\n                // mask = vec3(0);\n            \n            }\n\n            // new ray\n            vec3 reflection = reflect(ray.Direction, hit.Normal);\n            ray = Ray(ray.Origin + hit.Length * ray.Direction + Epsilon * reflection, reflection);\n\n        } else {\n            \n            Color += mask * ApplyFog(Color, float(Max), ray.Direction, light.Direction)*8.0; // apply fog too\n            break;\n            \n        }\n    }\n    return Color;\n}\n  \n\n\n// now render the image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\t\n    float exposure = 1e-2;\n\tfloat gamma = 2.3;\n\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n    fragColor = vec4(pow(CalculateColor(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[780, 816, 855, 895, 1339], [1344, 1353, 1390, 1390, 1558], [1560, 1609, 1629, 1642, 2311], [2313, 2441, 2686, 2686, 3013], [3115, 3146, 3176, 3176, 4584], [4590, 4614, 4669, 4669, 4988]], "test": "error"}
{"id": "MlGfDd", "name": "Light My Fire", "author": "daumkuchen", "description": "fire effect using distance function & noise.", "tags": ["effect"], "likes": 9, "viewed": 169, "published": "Public", "date": "1544508090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\nconst float angle = 60.;\nconst float fov = angle * .5 / PI / 180.;\nconst vec3 lightDir = normalize(vec3(-.5, .5, .5));\nconst vec3 ambient = vec3(-.5, .5, .5);\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,\n                        0.309016994374947451);\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n  i = mod(i, 289.0);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfloat random (in vec2 _uv){\n  return fract(sin(dot(_uv.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n  vec3 a = floor(p);\n  vec3 d = p - a;\n  d = d * d * (3.0 - 2.0 * d);\n\n  vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n  vec4 k1 = perm(b.xyxy);\n  vec4 k2 = perm(k1.xyxy + b.zzww);\n\n  vec4 c = k2 + a.zzzz;\n  vec4 k3 = perm(c);\n  vec4 k4 = perm(c + 1.0);\n\n  vec4 o1 = fract(k3 * (1.0 / 41.0));\n  vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n  vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n  vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n  return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n#define NUM_OCTAVES 5\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n    a.x * a.x * r + c,\n    a.y * a.x * r + a.z * s,\n    a.z * a.x * r - a.y * s,\n    a.x * a.y * r - a.z * s,\n    a.y * a.y * r + c,\n    a.z * a.y * r + a.x * s,\n    a.x * a.z * r + a.y * s,\n    a.y * a.z * r - a.x * s,\n    a.z * a.z * r + c\n  );\n  return m * p;\n}\n\nfloat sdSphere(vec3 p, float s){\n  return length(p) - s;\n}\n\nvec2 distanceFunc(vec3 p){\n  float t = iTime * .2;\n  float n = fbm(normalize(p) + t) * 6.;\n        n = snoise(vec4(vec3(n) * .2, .1));\n  vec3 r = rotate(p, radians(iTime * 20.), vec3(1.));\n  float s = sdSphere(r, 1. + n * .5);\n\n  return vec2(s);\n}\n\nvec3 getNormal(vec3 p){\n  vec3 d = vec3(.2, 0., 0.);\n  return normalize(vec3(\n    distanceFunc(p + d.xyy).x - distanceFunc(p - d.xyy).x,\n    distanceFunc(p + d.yxy).x - distanceFunc(p - d.yxy).x,\n    distanceFunc(p + d.yyx).x - distanceFunc(p - d.yyx).x\n  ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n  vec3 lightDir = normalize(vec3(sin(iTime * 20.), cos(iTime * 20.), 1.));\n\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n  // vec2 tUv = fragCoord.xy / iResolution;\n\n  vec3 ray = normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov)));\n\n  vec2 d = vec2(0.);\n  vec2 rLen = vec2(0.);\n\n  vec3 cPos = vec3(.0, .0, 1.);\n  vec3 rPos = cPos;\n\n  for(int i = 0; i < 12; i++){\n    d = distanceFunc(rPos);\n    rLen += d;\n    rPos = cPos + ray * vec3(rLen, 1.);\n  }\n\n  vec3 normal = getNormal(rPos);\n\n  float diffuse = max(dot(lightDir, normal), 0.);\n  float specular = max(dot(normal, lightDir), 0.);\n        specular = pow(specular, 2.);\n  vec3 ambientColor = min(ambient + diffuse, 1.);\n\n  float dot = dot(vec3(.0), normal);\n  float value = cos(dot * PI * 16.);\n\n  float r1 = random(vec2(iTime));\n  vec3 fCol = vec3(.7);\n  vec3 nCol1 = vec3(normal.z * 1., normal.z * 10., normal.z * (4. - sin(iTime * .5)));\n  vec3 nCol2 = vec3(normal.z * 2., normal.z * 1., normal.z * (2. - sin(iTime * .5))) * (cos(iTime * .7) + 1.);\n  vec3 col = nCol1 * nCol2 * fCol;\n\n  col *= smoothstep(.01, .1, value);\n  col = abs(col - .01) * 6.;\n  col = col + (random(normal.yz) * .1);\n\n  vec3 dest = (.8 - col + vec3(specular * .4)) * 1.5;\n\n  fragColor = vec4(dest, 1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 210, 210, 247], [248, 248, 271, 271, 315], [316, 316, 343, 343, 391], [392, 392, 421, 421, 469], [470, 470, 499, 499, 757], [759, 759, 780, 780, 2494], [2496, 2496, 2523, 2523, 2594], [2596, 2596, 2618, 2618, 2663], [2664, 2664, 2684, 2684, 2729], [2730, 2730, 2748, 2748, 2787], [2789, 2789, 2809, 2809, 3272], [3296, 3296, 3314, 3314, 3484], [3486, 3486, 3530, 3530, 3909], [3911, 3911, 3943, 3943, 3969], [3971, 3971, 3997, 3997, 4218], [4220, 4220, 4243, 4243, 4481], [4483, 4483, 4537, 4537, 5825]], "test": "error"}
{"id": "MlGfDG", "name": "[TDF2018] Morph", "author": "soma_arc", "description": "For Tokyo Demo Fest 2018 GLSL Graphics compo.", "tags": ["2d", "fractal"], "likes": 41, "viewed": 1282, "published": "Public API", "date": "1543835680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\nconst vec3 BLACK = vec3(0, 0, 0.01);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float PI = 3.141592;\n\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(const vec2 pos, const vec4 circle){\n    vec2 p = pos - circle.xy;\n    float d = length(p);\n    return (p * circle.w)/(d * d) + circle.xy;\n}\n\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y;\n\tz *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nvec3 computeColor2(float n, float numTransA) {\n    if(n == 0.) {\n        return vec3(0, 0, 0.05);\n    }\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;\n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nconst int LOOP_NUM = 500;\nvec3 josKleinianIIS(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        numTransA++;\n        if(uv.x < pos.y) {\n            pos.y -= uv.x;\n            pos.y *= -1.;\n            pos.y += uv.x;\n            loopNum++;\n        }\n        if(pos.y <= 0.){\n            pos.y *= -1.;\n            loopNum++;\n        }\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return computeColor2(loopNum, numTransA);\n\n        llz=lz; lz=pos;\n    }\n    return computeColor2(loopNum, numTransA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    const int SAMPLE_NUM = 10;\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n\n    float p_scale = 4.;\n    vec2 p_translate = vec2(-1, 1);\n    vec4 p_inversionCircle = vec4(0, 1, 1, 1);\n\n    vec2 p_symmetricalPoint = vec2(0., 1.);\n\n    float n = 1.;\n    float p_maskitK = 2. * cos(PI / n); // default value is k = 2\n\n    float t = mod(iTime, 16.);\n    float start = 0.0;\n    float duration = 1.5;\n\n    p_inversionCircle.x += mix(0., 0.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_inversionCircle.x += mix(0., -1.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n\n    // arms start\n    duration = 0.8;\n    p_scale += mix(0., .9, circEasingInOut(scene(t, start, duration)));\n    p_symmetricalPoint += mix(vec2(0), vec2(0.1, -0.1), circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.2;\n    p_symmetricalPoint -= mix(vec2(0), vec2(0.1, -0.1), circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n\n    p_symmetricalPoint += mix(vec2(0), vec2(-0.1, -0.1), circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.2;\n    p_symmetricalPoint -= mix(vec2(0), vec2(-0.1, -0.1), circEasingInOut(scene(t, start, duration)));\n    p_scale += mix(0., -.9, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    // arms end\n\n    duration = 1.0;\n    p_inversionCircle.y += mix(0., -1., circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_inversionCircle.x += mix(0., 1., circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_inversionCircle.x += mix(0., -0.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n\n    p_scale += mix(0., 15.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n\n    p_translate.x += mix(0., 1.5, circEasingInOut(scene(t, start, duration)));\n    p_translate.y += mix(0., -.5, circEasingInOut(scene(t, start, duration)));\n    p_inversionCircle.y += mix(0., -0.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_scale -= mix(0., 15.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.25;\n\n    // ending\n    p_inversionCircle.y += mix(0., 1.5, circEasingInOut(scene(t, start, duration)));\n    start += duration + 0.1;\n    p_inversionCircle.x += mix(0., 0.5, circEasingInOut(scene(t, start, duration)));\n    p_translate.x += mix(0., -1.5, circEasingInOut(scene(t, start, duration)));\n    p_translate.y += mix(0., .5, circEasingInOut(scene(t, start, duration)));\n\n    vec2 p_maskitUV = vec2(p_symmetricalPoint.y * 2., -p_symmetricalPoint.x * 2.);\n    for(int i = 0 ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + (rand2n(fragCoord.xy, float(i)))) / iResolution.yy ) - vec2(ratio, 0.5);\n        position *= p_scale;\n        position += p_translate;\n\n\n        position = circleInvert(position, p_inversionCircle);\n\n        if(true) {\n            sum += josKleinianIIS(position,\n                                  p_maskitUV, p_maskitK);\n        } else {\n            //sum += josKleinian(position,\n            //                  p_maskitUV, p_maskitK);\n        }\n    }\n\n\n    fragColor = vec4(gammaCorrect(sum / float(SAMPLE_NUM)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 377, 377, 666], [668, 668, 721, 721, 825], [911, 911, 940, 940, 1117], [1119, 1119, 1143, 1143, 1296], [1298, 1298, 1329, 1329, 1476], [1478, 1478, 1507, 1507, 1600], [1602, 1602, 1634, 1634, 1759], [1761, 1761, 1783, 1783, 1952], [1954, 1954, 1981, 1981, 2028], [2030, 2030, 2076, 2076, 2192], [2194, 2224, 2272, 2272, 2311], [2314, 2314, 2341, 2341, 2381], [2382, 2382, 2411, 2411, 2447], [2449, 2449, 2480, 2480, 2587], [2589, 2589, 2617, 2617, 2653], [2681, 2681, 2739, 2739, 3803], [3805, 3805, 3861, 3861, 7147]], "test": "ok"}
{"id": "MljfWh", "name": "ray X plane", "author": "jasonaugur", "description": "rusty vector math", "tags": ["ray", "intersection", "plane"], "likes": 2, "viewed": 117, "published": "Public", "date": "1543820716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime * .25\n#define M mat2( cos(T), sin(T), -sin(T), cos(T) )\n#define L(a,b) d = min(d, seg( p, a, b ) )\n#define thick 0.005\n#define R(c) Out = mix( Out, c, smoothstep(thick,0.,d) ); d = 999.\n\nvec2 V(vec3 a ) { a.xz = a.xz * M; return a.xy/(a.z+1.); }\nvec2 V(float x,float y,float z) { return V(vec3(x,y,z)); }\n\nfloat seg( vec2 p, vec2 a, vec2 b ) {\n    vec2 v = b - a;\n    \t p = p - a;\n    float t = dot(v,p) / dot(v,v);\n    t = max( 0., t);\n    t = min( 1., t);\n    return distance( p, v * t );\n}\n\nvec3 linePlainIntersect( vec3 e, vec3 f, vec3 a, vec3 b, vec3 c ) {\n    vec3 n = cross(b-a,c-a);\n    float t = dot(n,a-e)/dot(n,f-e);\n    return e + (f-e) * t;\n}\n\nvoid mainImage( out vec4 Out, in vec2 Frag )\n{\n\tvec2 uv = Frag.xy / iResolution.xy;\n    vec2 p = (Frag+Frag-iResolution.xy)/iResolution.y;\n\tfloat d =  999.;\n    \n    vec3 a = vec3(-.5,.0,.5);\n    vec3 b = vec3(.5,.3,.5);\n    vec3 c = vec3(.0,-.5,.5);\n    \n    vec3 e = vec3(-.2,-.3,-.7);\n    vec3 f = vec3(.1,.0,.7);\n    \n    vec3 X = linePlainIntersect( e, f, a, b, c );\n    \n    vec3 n = cross(b-a,c-a); vec3 blu = .1 * normalize(n);\n    vec3 s = b-a; \t\t\t vec3 red = .1 * normalize(s);\n    vec3 t = cross(n, s);\t vec3 grn = .1 * normalize(t); \n    \n    Out = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    L( V( a ), V( b ) );\n    L( V( b ), V( c ) );\n\tL( V( c ), V( a ) ); \t R( vec4(1.) );\n    \n\tL( V( e ), V(   f   ) ); R( vec4(.75,1.,1.,0.) );\n    L( V( X ), V( X+red ) ); R( vec4(1.,0.,0.,0.) );\n    L( V( X ), V( X+grn ) ); R( vec4(0.,1.,0.,0.) );\n    L( V( X ), V( X+blu ) ); R( vec4(0.,0.,1.,0.) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljfWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 220, 220, 261], [262, 262, 295, 295, 320], [322, 322, 359, 359, 508], [510, 510, 577, 577, 671], [673, 673, 719, 719, 1577]], "test": "ok"}
{"id": "MlKBzd", "name": "Weird shape and video artifacts", "author": "Vermifuge", "description": "A deformed sphere and video artifacts", "tags": ["artifacts"], "likes": 2, "viewed": 101, "published": "Public", "date": "1543715779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 one = vec2(1., 0.);\n\nfloat hash(vec2 x) {\n\treturn fract(cos(\n\t\tdot(x, vec2(672.529,198.3862))\n\t\t)*9857.733);\n}\n\nfloat noise(vec2 x) {\n\tvec2 ix =floor(x);\n\tvec2 fx = fract(x);\n\tfx=fx*fx*(3.-2.*fx);\n\n\tfloat bl = hash(ix);\n\tfloat br = hash(ix+one.xy);\n\tfloat tl = hash(ix+one.yx);\n\tfloat tr = hash(ix+one.xx);\n\n\treturn mix(\n\t\tmix(bl, br, fx.x),\n\t\tmix(tl, tr, fx.x),\n\t\tfx.y);\n}\n\nfloat fbm(vec2 p) {\n\treturn (\n\t\t.5* noise(p)\n\t\t+ .25* noise(p*2.1)\n\t\t+ .175* noise(p*3.9)\n\t\t+ .0875* noise(p*7.03)\n\t);\n}\n\nfloat sphere(vec3 p, float r) {\n\tp += .2*sin(6.*p.zxy+one.yxy*iTime);\n\tp += .1*sin(12.*p.yzx+one.yxy*iTime);\n\treturn length(p) - r;\n}\n\nfloat map(vec3 p) {\n\treturn sphere(p, 1.5);\n}\n\nvec4 raymarch(vec2 uv) {\n\tvec3 camera = vec3(0., 0., -5.);\n\tvec3 dir = normalize(vec3(uv, 1.));\n\tvec4 res = vec4(camera, 0.);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 60; ++i) {\n\t\tvec3 p = camera + t*dir;\n\t\tfloat d = map(p);\n\t\tif (d < .001) {\n\t\t\tres = vec4(p, 1.);\n\t\t}\n\t\tt += d;\n\t}\n\treturn res;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\treturn normalize(vec3(\n\t\tmap(p - e.xyy) - map(p + e.xyy),\n\t\tmap(p - e.yxy) - map(p + e.yxy),\n\t\tmap(p - e.yyx) - map(p + e.yyx)));\n}\n\nvec2 artifacts(vec2 uv, float cells) {\n    // random displacement vector\n\tvec2 glitch = 2.*vec2(\n\t\tfbm(floor(cells*uv)+1.5*iTime),\n\t\tfbm(floor(cells*uv)+1.5*iTime+7383.42))-1.;\n    \n    // randomly enable / disable displacement\n\tglitch *= step(.95, noise(floor(cells*uv)+10.*noise(iTime*one)));\n\treturn uv + .1*glitch;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // center the origin and make it span -0.5 to 0.5\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    uv = artifacts(uv, 10.);\n\t\n    //background\n\tvec3 color = (uv.y+.5)*vec3(.1,.4,.5);\n    \n    //sphere\n\tvec4 obj = raymarch(uv);\n    float orthogonal = abs(dot(normal(obj.xyz), vec3(0., 1., -.6)));\n\tcolor = mix(color, vec3(1.), obj.w * orthogonal - .2);\n\tcolor = mix(color, vec3(.7,.2,.2),\n\t\t.5*smoothstep(.1, 1., obj.w*noise(obj.z+obj.xy*5.)));\n\tfragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKBzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 115], [117, 117, 138, 138, 378], [380, 380, 399, 399, 500], [502, 502, 533, 533, 635], [637, 637, 656, 656, 682], [684, 684, 708, 708, 975], [977, 977, 998, 998, 1157], [1159, 1159, 1197, 1231, 1479], [1481, 1481, 1536, 1590, 2065]], "test": "timeout"}
{"id": "MlKfDc", "name": "circling_Beams", "author": "lazerkatz", "description": "circling beams", "tags": ["particles", "beams"], "likes": 6, "viewed": 199, "published": "Public", "date": "1544448096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//FUNCTION particleDraw - creates circles based on arguments\n//Arguments - UVs, Position, Radius, Blur Amount, Color\nvec3 particleDraw(vec3 col, int circleType, vec2 uv, vec2 p, float r, float blur, vec3 colTint) {\n   \n    float d = length(uv-p);\n    float ysinred = 0.;\n    float ysinblue = 0.;\n    float ysingreen = 0.;\n    vec3 preGlowCol;\n    //ysinred = fract(sin(1.)*1.0);\n    //col = col*(ysinred);\n   // vec3 col = colTint;\n   \n    //Branch for Glow stamps vs core stamps\n     if (circleType==1)                                          \n    {\n      //Basic multiply circle stamp\n      col *= (smoothstep(r,r-blur,d))*colTint;\n     \n    }   \n      if (circleType==2)                                          \n    {\n      //Glow Add circle stamp\n     \n     col *= smoothstep(r,r-blur,d)*.1*colTint; \n     col += (smoothstep(r,r-blur,d)*.2*colTint);\n      //col *= smoothstep(r,r-blur,d);                                          \n    }       \n    \n    \n    return col;\n}\n\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord.xy/iResolution.xy; // 0 <> 1.\n   \n    uv -= .5;\n    uv.x = uv.x*(iResolution.x/iResolution.y);\n   \n     vec2 p = vec2(.0, .0);   \n   \n    vec3 col = vec3(0.,0.,0);\n         \n    float ypos = .5;\n    float startRadius = .0002;\n    vec3 targetColor = vec3(.8,.5,1.);\n     vec3 glowColor = vec3(.50,.3,.9);\n    float randomSeed = 799199.;\n    float xStreakPos = -.9;\n \n     \n    for(float streaks = 0.; streaks <=120.; streaks++) {\n       \n   \n        float randNumber = fract(sin(randomSeed*.01)*5166.);\n        startRadius += randNumber*.004;\n        glowColor += randNumber*.001;\n        targetColor += randNumber*.01;\n\n        for(float i = 0.; i <= randNumber*140.; i++) {\n\n\n\n            //glow stamp\n            col += particleDraw(col, 2, uv, vec2(xStreakPos, ypos), startRadius+.05, .53, glowColor);\n            //base stamp\n            col += particleDraw(col, 1, uv, vec2(xStreakPos, ypos), startRadius, .16, targetColor); \n            targetColor =+ vec3 (.85,.8,.8);\n            //glowColor =+ vec3 (.1,.1,.1);\n\n\n\n            //increment size and position\n            ypos -= .007;\n            startRadius += .00048;\n        }\n        targetColor += vec3(-0.52,0.0,0.0);\n        glowColor += vec3(-.005,.005,.0);\n        ypos = .5;\n        startRadius = .0005;\n        xStreakPos = (sin(randomSeed+(iTime*1.)))*.7+0.0;\n        randomSeed += 27.2727;\n     }\n   \n   \n   \n    // Output to screen\n    fragColor = vec4(col,.001);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 117, 214, 214, 977], [983, 983, 1040, 1040, 2504]], "test": "ok"}
{"id": "MlKfDy", "name": "Modified Star Nest ", "author": "RaduBT", "description": "Original: Star Nest by Pablo Andrioli (user Kali on Shadertoy). \n\nhttps://www.shadertoy.com/view/XlfGRj\n\nStar Nest by Pablo Andrioli (user Kali on Shadertoy). \n\n\nhttps://www.defold.com/tutorials/shadertoy/#_the_modified_star_nest_shader\n\n", "tags": ["startnest"], "likes": 10, "viewed": 739, "published": "Public API", "date": "1544005873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Star Nest by Pablo Roman Andrioli\n\n// This content is under the MIT License.\n\n#define iterations 20\n#define formuparam 0.53\n\n#define volsteps 23\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\t\n    \n    vec2 pr = fragCoord.xy/iResolution.xy;\n\n    vec3 col = texture( iChannel0, pr ).xyz;\n    //vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n    \n    //col *= 0.08 + 0.6*pow( 16.0*pr.x*pr.y*(1.0-pr.x)*(1.0-pr.y), 0.05 );\n    \n    float fft = 0.5 + 0.6 *(((texture( iChannel0, vec2(uv.y+5.0, 5.0) ).x)) * 2.51);\n\tfloat time=iTime*speed+1.025;\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.5*fft;\n\tvec3 v=vec3(0.)*1.2*fft;\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*fft*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\tv+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01*fft,1.);\t\n\t\n}", "image_inputs": [{"id": "XtSGzR", "previewfilepath": "https://soundcloud.com/user-678908875/lp-when-im-over-you-live-at", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-678908875/lp-when-im-over-you-live-at", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKfDy.jpg", "access": "shaders20k", "license": "mit", "functions": [[338, 338, 395, 423, 2004]], "test": "error"}
{"id": "MlKfWK", "name": "DiskGrid", "author": "XRNZ", "description": "grids of disks, wow !", "tags": ["grid", "disk"], "likes": 6, "viewed": 81, "published": "Public", "date": "1544126197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float freqR = 1.6;\nfloat freqG = 2.7;\nfloat freqB = 3.5;\n    \nfloat distoR = 1.1;\nfloat distoG = 2.2;\nfloat distoB = 3.3;\n\nfloat Disk(vec2 uv, vec2 center, float radius)\n{\n    return 1.-step(radius,length(uv-center));\n}\n\n\nvec3 DiskGrid(vec2 pixel, float gridRes, vec2 gridOffset)\n{\n    \n    float o = .1*gridRes;\n    float radius = .15*gridRes;\n    \n    vec2 offsetR = o*vec2(cos(freqR*iTime+distoR*pixel.x),sin(freqR*iTime+distoR*pixel.y));\n    vec2 offsetG = o*vec2(cos(freqG*iTime+distoG*pixel.x),sin(freqG*iTime+distoG*pixel.y));\n    vec2 offsetB = o*vec2(cos(freqB*iTime+distoB*pixel.x),sin(freqB*iTime+distoB*pixel.y));\n    \n    vec2 gridCoord = 0.8*mod(gridOffset+pixel,gridRes);\n    vec2 center = gridRes * 0.5 * vec2(1.,1.);\n    \n    float r = Disk(gridCoord, center + offsetR, radius);\n    float g = Disk(gridCoord, center + offsetG, radius);\n    float b = Disk(gridCoord, center + offsetB, radius);\n\n    return vec3(r,g,b);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 pixel = (fragCoord / iResolution.xy)*2.0-1.0;\n    pixel = pixel * vec2(iResolution.x/iResolution.y,1.0);\n    \n    \n    vec3 col =\n        + 0.2*DiskGrid(pixel, 0.025, vec2(.44,.11))\n        + 0.3*DiskGrid(pixel, 0.05, vec2(.15,.22))\n        + 0.6*DiskGrid(pixel, 0.1,vec2(.1,.15))\n        + 1.0*DiskGrid(pixel, 0.2,vec2(.15,.33));\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 171, 171, 219], [222, 222, 281, 281, 936], [939, 939, 996, 996, 1371]], "test": "ok"}
{"id": "MlscWr", "name": "RGB test shader 2", "author": "Jeffrey122", "description": "Test shader 2", "tags": ["test"], "likes": 2, "viewed": 316, "published": "Public API", "date": "1545074947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy;\n    pos.x = pos.x / iResolution.x;\n    pos.y = pos.y / iResolution.y;\n    \n    vec4 colorDraw = vec4(0, 0, 0, 1.0);\n    colorDraw.r = pos.y * 2.0 *  abs(sin(iTime));\n    colorDraw.g = pos.y / pos.x * pos.y - 2.0 * abs(cos(iTime - 2.0));\n    colorDraw.b = pos.x / pos.y * pos.x + 0.8 * abs(cos(iTime - 2.0));\n    \n    fragColor = colorDraw;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlscWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 425]], "test": "ok"}
{"id": "MlVfRd", "name": "sketch_000", "author": "nepster", "description": "Sketching shaping functions", "tags": ["sin", "gradient", "cos", "abs"], "likes": 5, "viewed": 283, "published": "Public", "date": "1543712676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define u_time iTime\n\nvec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.0);\n    vec3 pct = vec3(uv.x);\n    \n    pct.r = abs(sin(cos(uv.y + u_time) * 10. * uv.x + u_time));\n    pct.g = abs(cos(sin(u_time + 5. * uv.x) * 5. * uv.y + u_time));\n    pct.b = abs(cos(sin(u_time + 2. * uv.x) * 7. * cos(uv.y + u_time)));\n    \n    color = mix(colorA, colorB, pct);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVfRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 159, 209, 618]], "test": "ok"}
{"id": "MlVfWG", "name": "Cookie 2018 NuSan - Round 03", "author": "NuSan", "description": "Shader made live in 25 minutes during Cookie Demo Party 2018, round 03, finals", "tags": ["3d", "cookie"], "likes": 10, "viewed": 322, "published": "Public", "date": "1543946595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cookie 2018 NuSan - Round 03\n// Shader made live by NuSan in 25 minutes\n// during Cookie Demo Party 2018, round 03, finals\n// Slightly tweeked as the texture is not the same\n\n\n#define time iTime\n\n\nfloat sph(vec3 p, float r){\n  return length(p)-r;\n}\n\n\nfloat cyl(vec2 p, float r){\n  return length(p)-r;\n}\n\nvec3 rep(vec3 p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a,float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0); \n  return mix(a,b, k) - k * (1.0-k)*h;\n}\n\nfloat rnd(float t){\n  return fract(sin(t*423.23)*4568.232);\n}\n\nfloat curve(float t, float d) {\n  float g = t/d;\n  return mix( rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0, fract(g)), 10.0));\n}\n\nfloat map(vec3 p) {\n\n  vec3 rp = rep(p, 0.1);\n  vec3 rp2 = rep(p, 0.12);\n\n  float f = texture(iChannel0, p.xz * 0.05).x;\n\n  float v = clamp(length(p.xz)*0.5, 0.0, 1.0) * 1.5;\n\n  float m = -p.y + 0.1 + f*2.0 + v;\n\n  float o = -p.y + 2.1;\n\n  float c = cyl(rp.xz, 0.02);\n  float c2 = cyl(rp2.xz, 0.02);\n\n    float m2 = -p.y + 0.1 + f*2.0 + v;\n\n  c = smin(m+.2 - f*2.0, c, -0.2);\n    c = smin(m+.2 - f*2.0+0.1, c2, -0.2);\n\n  return min(c,min(m, o));\n}\n\n\n\nvec3 norm(vec3 p) {\n  float base = map(p);\n  vec2 off = vec2(0.01,0);\n  return normalize( vec3( base-map(p-off.xyy), base-map(p-off.yxy), base-map(p-off.yyx) ));\n}\n\nvec3 cam(vec3 p) {\n  float t = time;\n  p.xz *= rot(t);\n  p.yz *= rot(sin(t + curve(time+5.0,1.2)*0.5) * 0.1);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  uv.x += (curve(time+5.0, 0.7)-0.5) * 0.4;\n  uv.y += (curve(time+5.0, 0.8)-0.5) * 0.3;\n\n  vec3 ro = vec3(0,1,-5);\n  vec3 rd = normalize(vec3(-uv, 0.1 + curve(time, 0.2) * 2.0));\n\n  ro = cam(ro); \n  rd = cam(rd);\n  \n\n  vec3 p = ro;\n  float dd = 0.0;\n  for(int i=0; i<100; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=rd*d*0.5;\n    dd+=d*0.5;\n  }\n\n  vec3 n = norm(p);\n  vec3 l = normalize(vec3(-1));\n  vec3 h = normalize(l-rd);\n\n  float lum = max(0.0, dot(n,l));\n  float amb = -n.y*0.5+0.5;\n\n  vec3 col = vec3(0);\n\n  col += vec3(1,0.9,0.5) * lum * 0.5;\n  col += vec3(0.2,0.2,1.0) * amb * 0.2;\n  col += vec3(0.9,0.9,1.0) * lum * pow(max(0.0, dot(n,h)),30.0);;\n\n  col *= 3.0/dd;\n\n  col += vec3(1,0.5,0.2) * 0.1 * exp(dd*0.2);\n\n  float t2 = time + curve(time+85.0, 0.8) + curve(time+45.0, 1.3);\n\n\n  col.xy *= rot(t2);\n  col.zy *= rot(t2*0.7);\n  col.xz *= rot(t2*1.2);\n\n  col = abs(col);\n\n  col *= min(1.0,pow(1.0-length(uv*0.9),2.0) * 10.0);\n\n  fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 227, 227, 251], [254, 254, 281, 281, 305], [307, 307, 334, 334, 369], [371, 371, 390, 390, 459], [461, 461, 499, 499, 582], [584, 584, 603, 603, 645], [647, 647, 678, 678, 788], [790, 790, 809, 809, 1237], [1241, 1241, 1260, 1260, 1404], [1406, 1406, 1424, 1424, 1529], [1531, 1531, 1588, 1588, 2777]], "test": "error"}
{"id": "MlyBRt", "name": "aircraft3", "author": "lise", "description": "aircraft", "tags": ["aircraft"], "likes": 1, "viewed": 348, "published": "Public API", "date": "1544067479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MATH_PI = float( 3.14159265359 );\nconst vec3 SKY_COLOR = vec3(0.05, 0.2, 0.5);\nconst vec3 LIGHT = normalize( vec3(  0.1, 0.8,  0.9 ) );\nconst vec3 LIGHT_BACK = LIGHT * - 1.0;\nconst float AIRPLANE_SIZE = 20.0; // AIRPLANE\nconst float AIRPLANE_SCALE = 1.0; // AIRPLANE\nconst float TIME_SCALE = 1.0;\nconst float EP = 0.0001;\nconst int AIRPLANE_COUNT = 5;\nconst float PI = 3.141592;\nconst float PI2 = PI * 2.0;\n\nmat3 airplanes[AIRPLANE_COUNT];\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\nvec3 foldXZ(vec3 p)\n{\n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    return p;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec4 dElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat dSphere(vec3 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat dEllipsoid(vec3 pos, vec3 size)\n{\n    return dSphere(pos / size, 1.0);\n}\n\nfloat dRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat dBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat dTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat dTree(vec3 po, inout vec4 hitColor)\n{\n    vec3 p = po;\n    // p = vec3(floor(p.x),floor(p.y),floor(p.z));\n    p.x = mod(p.x, 20.) - 10.0;\n    p.z = mod(p.z, 20.) - 10.0;\n\n    vec3 size = vec3(0.4, 4.0, 0.4);\n    float branch = dBox(p, size);\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 q = foldXZ(p);\n        q.y -= size.y;\n        q.xy *= rotate(-0.4);\n        q.zy *= rotate(-0.4);\n        branch = min(branch, dBox(q, size));\n        p = q;\n    }\n\n    p.y -= size.y;\n    float leaf = dEllipsoid(p, vec3(3,2,3));\n\n    if (branch < leaf)\n    {\n        hitColor = vec4(0.44, 0.29, 0.22, 1.0);\n    }\n    else\n    {\n        float hoge = step(fract(po.x) + fract(po.y) + fract(po.z), 0.9) * 0.5;\n        hitColor = vec4(0.44 - hoge, 0.99 - hoge, 0.22 - hoge, 1.0);\n    }\n\n    return min(branch, leaf);\n}\n\nvec3 rotateX(vec3 position, float rotate)\n{\n    return vec3(position.x, position.z * -sin(rotate) + position.y * cos(rotate), position.z * cos(rotate) + position.y * sin(rotate));\n}\n\nfloat dAircraft(vec3 ray, inout vec4 hitColor)\n{\n    vec3 body1 = vec3(0.5, 0.6, 2.0) * AIRPLANE_SCALE;\n    vec3 body1Pos = vec3(0, 0.2, -1.) * AIRPLANE_SCALE;\n    float body1Rot = 3.14 * -0.03;\n    vec3 body2 = vec3(1, 1, 5) * AIRPLANE_SCALE;\n    vec3 body2Pos = vec3(0, 1, 0) * AIRPLANE_SCALE;\n    float body2Rot = 3.14 * 0.0;\n    vec3 body3 = vec3(0.5, 0.9, 7) * AIRPLANE_SCALE;\n    vec3 body3Pos = vec3(1, -1, 1.1) * AIRPLANE_SCALE;\n    float body3Rot = 3.14 * 0.5;\n    vec2 body4 = vec2(0.3, 0.1) * AIRPLANE_SCALE;\n    vec3 body4Pos = vec3(-1.5, 1.5, 1) * AIRPLANE_SCALE;\n    float body4Distortion = 3.14 * 0.0;\n    vec2 body5 = vec2(8.0, -6.0) * AIRPLANE_SCALE;\n    vec3 body5Pos = vec3(0, -1, 0) * AIRPLANE_SCALE;\n    vec2 body6 = vec2(4.0, -3.0) * AIRPLANE_SCALE;\n    vec3 body6Pos = vec3(0, -1.1, -5) * AIRPLANE_SCALE;\n    vec3 body7 = vec3(2.4, 0.5, 2.0) * AIRPLANE_SCALE;\n    vec3 body7Pos = vec3(0, 1.5, 5) * AIRPLANE_SCALE;\n    vec3 body8_1 = vec3(1.2, 0, -4.0) * AIRPLANE_SCALE;\n    vec3 body8_2 = vec3(2.4, 2.5, -7.5) * AIRPLANE_SCALE;\n    vec3 body8_3 = vec3(1.4, -1., -7.5) * AIRPLANE_SCALE;\n    vec3 body8Pos = vec3(0, -1, 0) * AIRPLANE_SCALE;\n\n    float body1Depth = dEllipsoid(rotateX(ray, body1Rot) + body1Pos, body1);\n    float body2Depth = dEllipsoid(rotateX(ray, body2Rot) + body2Pos, body2);\n    float body3Depth = dRoundCone(rotateX(vec3(ray.x, ray.y, ray.z), body3Rot) + body3Pos, body3.x, body3.y, body3.z);\n    // abs\n    float body3_1Depth = dRoundCone(rotateX(vec3(-ray.x, ray.y, ray.z), body3Rot) + body3Pos, body3.x, body3.y, body3.z);\n    vec4 body4_ = dElongate(vec3(abs(ray.x), ray.y, ray.z) + body4Pos + vec3(0, 0, ray.y * -0.5), vec3(0.6, 0.1, 2.0));\n    float body4Depth = body4_.w + dTorus(rotateX(body4_.xzy + vec3(0, 0, 0), body4Distortion), body4);\n    float body5Depth = dTriangle(ray, vec3(body5.x, 0.0, body5.y) + body5Pos, vec3(-body5.x, 0.0, body5.y) + body5Pos, body5Pos) - 0.3;\n    float body6Depth = dTriangle(ray, vec3(body6.x, 0.0, body6.y) + body6Pos, vec3(-body6.x, 0.0, body6.y) + body6Pos, body6Pos) - 0.2;\n    float body7Depth = dBox(ray + body7Pos + vec3(0, 0, ray.y * -0.5), body7);\n    float body8Depth = dTriangle(vec3(abs(ray.x), ray.y, ray.z), body8_1 + body8Pos, body8_2 + body8Pos, body8_3 + body8Pos) - 0.1;\n\n    hitColor = vec4(1.0, 1.0, 1.0, 1.0);\n    float depth = min(min(min(min(min(min(min(min(body1Depth, body2Depth), body3Depth), body3_1Depth), body4Depth), body5Depth), body6Depth), body7Depth), body8Depth);\n\n    if (EP > abs(depth - body1Depth))\n    {\n        hitColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n\n    return depth;\n}\n\nvec3 dAircraftNormal(vec3 pos)\n{\n    vec4 _tmp;\n    return normalize(vec3(\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x - EP, pos.y, pos.z), _tmp),\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x, pos.y - EP, pos.z), _tmp),\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x, pos.y, pos.z - EP), _tmp)\n        ));\n}\n\nmat4 getWorldMat(mat3 transform)\n{\n    // trans world\n    vec3 axisX = cross(transform[1], transform[2]) * -1.0;\n\n    return mat4(\n        axisX.x, axisX.y, axisX.z, 0,\n        transform[1].x, transform[1].y, transform[1].z, 0,\n        transform[2].x, transform[2].y, transform[2].z, 0,\n        0, 0, 0, 1 \n        );\n}\n\nbool needRender(vec3 cameraPos, vec3 rayDirection, vec3 position, float size)\n{\n    // \n    return size > length(cameraPos + rayDirection * length(cameraPos - position) - position);\n}\n\nvoid airplaneRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    for (int i = 0; i < AIRPLANE_COUNT; i++)\n    {\n        if (!needRender(cameraPos, rayDirection, airplanes[i][0], AIRPLANE_SIZE))\n        {\n            // fixme\n            //return;\n        }\n\n        mat4 worldMat = getWorldMat(airplanes[i]);\n\n        vec3 localCameraPosition = (worldMat * vec4(cameraPos - airplanes[i][0], 1.0)).xyz;\n        vec3 localRayDirection = (worldMat * vec4(rayDirection, 1.0)).xyz;\n\n        float airplaneDepth = length(localCameraPosition) - AIRPLANE_SIZE * 0.5;\n        vec4 hitColor = color;\n\n        for (float marchDepth = 0.0; marchDepth < airplaneDepth + AIRPLANE_SIZE; marchDepth += AIRPLANE_SIZE * 0.001)\n        {\n            vec3 ray = localCameraPosition + localRayDirection * marchDepth;\n            float diff = dAircraft(ray, hitColor);\n\n            if (diff < EP)\n            {\n                if (depth > marchDepth + diff)\n                {\n                    depth = marchDepth + diff;\n                    vec3 normal = dAircraftNormal(ray);\n                    color = vec4(vec3(clamp(dot(normal, LIGHT) * hitColor, 0.0, 1.0)) + 0.2, 1.0);\n                }\n            }\n            else\n            {\n                // \n                marchDepth += diff;\n            }\n        }\n    }\n}\n\nvoid skyRender(inout vec4 color, float time, vec3 rayDirection)\n{\n    float sundot = clamp(dot(rayDirection, LIGHT), 0.0, 1.0);\n    float t = pow(1.0 - 0.7 * rayDirection.y, 15.0);\n    \n    vec3 col = 0.8 * SKY_COLOR;\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0 );\n    color = vec4(col, 1.0);\n}\n\nvoid groundRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{        \n    //  EP\n    if (-EP > rayDirection.y)\n    {\n        float groundDepth = abs((cameraPos.y) / rayDirection.y);\n        vec3 groundPoint = cameraPos + rayDirection * groundDepth;\n\n        depth = groundDepth;\n        float normal = clamp((dot(LIGHT, rayDirection) + 5.0) * 0.08, 0.2, 0.5);\n        color = vec4(normal, normal, normal, 1.0);\n\n        float line = step(mod(groundPoint.x, 10.0), 0.1) + step(mod(groundPoint.z, 10.0), 0.1);\n        color = color + vec4(line, line, line, 0);\n    }\n\n    // \n    float groundForestDepth = abs((cameraPos.y - 13.0) / rayDirection.y);\n    vec3 groundPoint = cameraPos + rayDirection * groundForestDepth;\n\n    vec4 hitColor = vec4(1,1,1,1);\n    for (float marchDepth = 0.0; marchDepth < 50.0; marchDepth += 0.1)\n    {\n        vec3 ray = groundPoint + rayDirection * marchDepth;\n        float diff = dTree(ray, hitColor);\n\n        if (diff < EP)\n        {\n            if (depth > groundForestDepth + marchDepth + diff)\n            {\n                depth = groundForestDepth + marchDepth + diff;\n                color = hitColor;\n                return;\n            }\n        }\n        else\n        {\n            // \n            marchDepth += diff;\n        }\n    }\n}\n\nvoid objectRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    airplaneRender(color, depth, time, cameraPos, rayDirection);\n}\n\nvec3 getAirplanePosition(float time)\n{\n    vec3 outline = vec3(cos(time * 0.2) * 1000.0, 40.0 + abs(sin(time * 0.1) * 100.0), sin(time * 0.2) * 1000.0);\n    return outline + vec3(cos(time) * 10.0, sin(time), sin(time) * 10.0);\n}\n\nvoid objectUpdate(float time)\n{\n    vec3 position = getAirplanePosition(time);\n    vec3 prevPosition = getAirplanePosition(time - EP);\n    vec3 nextPosition = getAirplanePosition(time + EP);\n    vec3 dir = normalize(nextPosition - position);\n    vec3 top = vec3(0, 1, 0);\n\n    airplanes[0] = mat3(position, top, dir);\n\n    mat4 leaderWorld = inverse(getWorldMat(airplanes[0]));\n\n    for(int index = 1; index < AIRPLANE_COUNT; index++)\n    {\n        int temp =index - 1;\n        airplanes[index] = mat3(position + (leaderWorld * vec4((float(temp) - 1.5) * 4.0, 0, step(1.0, abs(float(temp) - 1.5)) * 2.0 - 3.0, 1.0)).xyz * 10.0, top, dir);\n    }\n}\n\nvoid cameraUpdate(vec2 fragCoord, float time, out vec3 cameraPosition, out vec3 rayDirection)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    cameraPosition = vec3(800.0, 44.0 + clamp(airplanes[0][0].x * 0.1, 28.0, 200.), 400.0 + airplanes[0][0].z * 0.4);\n\n    vec3 cameraDirection = normalize(airplanes[0][0] - cameraPosition);\n    vec3 cameraTop = normalize(cameraDirection + vec3(0, 1, 0));\n    vec3 right = normalize(cross(cameraDirection, cameraTop));\n    cameraTop = cross(cameraDirection, right) * -1.0;\n\n    rayDirection = normalize(uv.x * right + uv.y * cameraTop + cameraDirection);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    float time = iTime * TIME_SCALE;\n    vec3 cameraPos;\n    vec3 rayDirection;\n    vec4 color;\n    float depth = 10000.0;\n\n    objectUpdate(time);\n    cameraUpdate(fragCoord, time, cameraPos, rayDirection);\n\n    skyRender(color, time, rayDirection);\n    groundRender(color, depth, time, cameraPos, rayDirection);\n    objectRender(color, depth, time, cameraPos, rayDirection);\n\n\tfragColor = color;\n\n    float debugcolor = depth * 0.01;\n    //fragColor = vec4(debugcolor, debugcolor, debugcolor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyBRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[483, 483, 507, 507, 526], [527, 527, 551, 551, 570], [572, 572, 593, 593, 649], [651, 651, 673, 673, 738], [740, 740, 780, 780, 868], [870, 870, 907, 907, 940], [942, 942, 981, 981, 1020], [1022, 1022, 1085, 1085, 1363], [1365, 1365, 1397, 1397, 1462], [1464, 1464, 1494, 1494, 1581], [1583, 1583, 1634, 1634, 2141], [2143, 2143, 2186, 2186, 2956], [2958, 2958, 3001, 3001, 3139], [3141, 3141, 3189, 3189, 5751], [5753, 5753, 5785, 5785, 6092], [6094, 6094, 6128, 6147, 6413], [6415, 6415, 6494, 6541, 6637], [6639, 6639, 6744, 6744, 8023], [8025, 8025, 8090, 8090, 8390], [8392, 8392, 8495, 8538, 9771], [9773, 9773, 9876, 9876, 9943], [9945, 9945, 9983, 9983, 10173], [10823, 10823, 10918, 10918, 11479], [11481, 11481, 11536, 11536, 12043]], "test": "error"}
{"id": "MtGfWK", "name": "dFdx terrain gen", "author": "ocb", "description": "Experimenting dFdx() and fwidth() on map gen", "tags": ["noise", "fbm", "dfdx", "fwidth"], "likes": 32, "viewed": 1044, "published": "Public API", "date": "1544045371", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: ocb\n\n/*****************************************************************************/\n/* dFdx Terrain Gen\n/* First try to use dFdx() and fwidth()\n/* dFdx/dFdy is used to find local normal on a value noise.\n/* fwidth() is used as an indicator of slope (ex. to avoid forest or snow on steep slope\n/*****************************************************************************/\n\n\n#define R iResolution\n#define STEP 9.\n\nfloat H2(in vec2 st) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ti = iTime*.2;\n    vec2 uv = (2.*fragCoord-R.xy)/R.y;\n    uv.y += ti+2.;\n    float h = 0., hsea = 0.;\n    vec3 col = vec3(.5);\n    vec3 lit = normalize(vec3(.5,.0,1.));\n    \n\tfloat a = 1., Hz = 1., m = 1.;\t\t\t\t\t// fbm\n    vec2 d = vec2(1.,0.);\n    for(float i=1.;i<=STEP; i++){\n        vec2 e = floor(uv*Hz), f = fract(uv*Hz);\n        f = smoothstep(0.,1.,f);\n        h += mix(\n            \tmix(H2(e),H2(e+d.xy),f.x)*a,\n            \tmix(H2(e+d.yx),H2(e+d.xx),f.x)*a,\n            \tf.y);\n        \n        a *= .3+.1*h+.015*i;\n        //a *= .5;\n        Hz *= 2.;\n        m += a;\n        \n        hsea += .1*h;\t\t// kind of integrated h to smooth the sea bottom\n    }\n    h/=m;\n    h = h-.5;\n    \n    \n\n    float below = step(h,0.), above = 1.-below;\t\t// above and below sea level\n    float fwdh = R.x*fwidth(h);\t\t// fwidth is used to reduce or avoid snow or trees on steep slope\n\n    col.b += .4*below;\t\t\t\t\t\t\t\t// sea water\n    col.g += .6*smoothstep(.4,.8,hsea)*below;\n        \n    col += vec3(smoothstep(.2,.4-.02*fwdh,h));\t\t// snow\n    \n    col -= vec3(.3-h,.25,.35)*(1.-smoothstep(.1,.2,h))*above*(1.-smoothstep(1.,6.,(h*h+.9)*fwdh));\t// forest\n\n    float dx= R.x*dFdx(h)*above + R.x*dFdx(hsea)*below;\t\t\t// derivatives\n    float dy= R.y*dFdy(h)*above + R.y*dFdy(hsea)*below;\n    vec3 n = normalize(cross(vec3(1.,dx,0.),vec3(0.,dy,1.)));\t// local normal\n    float shad = (.5+.5*dot(n,-lit));\t\t\t\t\t\t\t// shadowing\n    col *= shad*smoothstep(-.3,.0,h)*(.2+.8*above);\n    col += vec3(.2,.15,.0)*(shad-.5)*above;\t\t\t\t// warmer the light on the sunny side \n\n    col += .03*max(0.,-dx)*fwdh*below*smoothstep(-.02,0.,h)*shad;\t// wave foam along coast\n    \n\tfragColor = vec4(1.7*col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[426, 426, 448, 448, 525], [527, 527, 584, 584, 2272]], "test": "ok"}
{"id": "MtKfWd", "name": "Equispaced points", "author": "josemorval", "description": "Another viz", "tags": ["points", "maths", "equispaced"], "likes": 5, "viewed": 407, "published": "Public API", "date": "1544615632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VELAPPEARPOINTS 5.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv-0.5;\n    p.x*=iResolution.x/iResolution.y;    \n\tp*=1.5;\n    \n    float angle = 3.14159/2.*mod(floor(iTime),4.)+3.14159/2.*smoothstep(0.,1.,mod(iTime,1.));\n    p=mat2(cos(angle),sin(angle),-sin(angle),cos(angle))*p;\n    p*=(0.5+\n        mix(1.-1.*sin(15.1*mod(floor(iTime),4.)),\n            1.-1.*sin(15.1*mod(floor(iTime)+1.,4.)),\n            smoothstep(0.,1.,mod(iTime,1.))\n           ));\n    \n    vec3 col = 0.2*vec3(0.3,0.5,0.7);\n    col += 1.5*max(step(0.99,cos(50.*p.y)),step(0.99,cos(50.*p.x)))*col;\n    col += (1.-smoothstep(-0.01,0.01,length(p-vec2(1.,0.))-0.02+0.005*sin(13.*iTime)))*vec3(0.,0.7,0.5);\n    col += (1.-smoothstep(-0.01,0.01,length(p-vec2(-1.,0.))-0.02+0.005*sin(13.*iTime)))*vec3(0.,0.7,0.5);\n    \n    col-=0.1*fract(0.5*iTime+123.*sin(12.3*floor(50./(2.*3.14159)*p.x))+341.*sin(12.3*floor((50./(2.*3.14159))*p.y)));\n        \n    int np = 2+int(mod(VELAPPEARPOINTS*iTime,15.));\n    float st = 1./float(np-1);\n    st = st*(1.2-0.7*sin(iTime));\n    \n    for(int i=0;i<np;i++){\n    \tfloat x = st*float(i)-st*float(np-1)/2.; \n        col = mix(col+0.2*vec3(1.,0.5,0.),col,smoothstep(-0.1,0.1,length(p-vec2(x,0.))-0.01));\n        col += (1.-smoothstep(-0.003,0.003,length(p-vec2(x,0.))-(0.005-0.003*sin(iTime))))*vec3(1.,0.5,0.);\n    \n    }\n\n\tcol *= smoothstep(1.9,0.5,length(p)+0.1*sin(3.*atan(p.y,p.x)+10.*iTime));\n    \n    float gamma = 0.8;\n\tcol.x = pow(col.x,gamma+0.15*sin(iTime+0.3));\n    col.y = pow(col.y,1.3*gamma+0.15*sin(iTime));\n    col.z = pow(col.z,1.2*gamma+0.15*sin(2.1*iTime-0.4));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKfWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 1698]], "test": "ok"}
{"id": "MtKfWy", "name": "Swirly Strands", "author": "Plento", "description": " just playing with raymarching", "tags": ["3d", "raymarch", "domain"], "likes": 32, "viewed": 1298, "published": "Public API", "date": "1544480166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// PLENTO\n\n\n\n\n#define FAR 80.0\n#define DISTANCE_BIAS 0.6\n#define HASHSCALE1 .1031\n#define EPSILON 0.001\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 rp)\n{\n \n    float res = 0.0;\n    \n    vec3 pos = rp - vec3(1.0, -0.25, 4.0);\n  \n    vec3 b = vec3(1.0, 1.0, 1.0);\n   \n    pos.xy *= rot(pos.z*0.3);\n    pos.y += sin(pos.z + iTime + pos.x*1.0)*0.2;\n    pos.x += cos(pos.y - pos.z * 2.0 + iTime)*0.3;\n \n    pos = mod(pos, b)-0.5*b;\n    \n    //res = sdBox(pos, vec3(0.01, 0.01, 2.0));\n   res = sdBox(pos, vec3(0.033, 0.033, 2.0));\n   \n  \n    return res;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0035, -0.0035); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\n// swirly color thing\nvec3 oc(vec3 p)\n{\n    p.xy *= rot(p.z*0.64);\n    vec3 col = mix(vec3(0.0, 0.3, 1.3), vec3(1.2, 1.2, 0.0),  smoothstep(0.0, 1.0, p.x));\n    return col;\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 norm, vec3 lp, float t)\n{\n    \n    // Lighting\n    vec3 ld = lp-ro;\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    float atten = 1.0 / (1.0 + lDist*0.2 + lDist*lDist*0.1); // light attenuation \n    \n    ld /= lDist;\n    \n    // Diffuse\n    float diff = max(dot(norm, ld), 0.0);\n    \n    // specular\n    float spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 12.0);\n    \n    //Colors\n    vec3 objCol = oc(ro);\n    \n    objCol = oc(ro);\n    \n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(1.0, 1.0, 1.0)*spec*1.2) * atten;\n   \n    // Get final color\n    return sceneCol;\n    \n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0, d = 0.0; \n   \n    for (int i = 0; i < 100; i++) \n    {\n        d = map(ro + rd*t);\n       \n        if(abs(d)<EPSILON || t > FAR) break;\n         \n        \n        t += d * DISTANCE_BIAS;\n    }\n    return t;\n}\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0.0, d = 0.0;\n    \n    for (int i = 0; i < 64; i++)\n    {\n        d = map(ro + rd*t);\n      \n        if(abs(d)<.0025 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n \n    vec3 ro = vec3(0.0, 0.0, 0.0); \n    vec3 rd = normalize(vec3(uv,2.0));\n    ro.z -= iTime * 0.7;\n   \n    // fish eye\n     rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.75));\n    \n    // light position\n    vec3 lp = ro + vec3(0.0, 1.0, -0.5);\n    \n    \n    // Scene\n    float t = trace(ro, rd);\n \n    ro += rd * t;\n    vec3 rr = ro;\n    vec3 norm = getNormal(ro); \n    \n    vec3 col = color(ro, rd, norm, lp, t);\n    \n    float fog = t;\n    \n   \n    // Reflection  \n    rd = reflect(rd, norm);\n    \n    t = traceRef(ro +  rd*.01, rd);\n    \n    ro += rd*t;\n    \n    norm = getNormal(ro);\n   \n    col += color(ro, rd, norm, lp, t) * 0.25;\n    \n   \n    fog = smoothstep(0.0, 0.15, fog / 130.);\n    col = mix(col, vec3(0), fog);\n    \n   \n    col *= smoothstep(2.0, 0.29, length(uv));\n    \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKfWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 124, 124, 176], [178, 178, 209, 209, 296], [298, 298, 318, 318, 714], [717, 717, 741, 741, 937], [939, 961, 978, 978, 1113], [1115, 1115, 1174, 1195, 1761], [1763, 1763, 1794, 1794, 2022], [2023, 2023, 2056, 2056, 2261], [2265, 2265, 2322, 2322, 3246]], "test": "ok"}
{"id": "MtKfzd", "name": "BlueCross", "author": "Vermifuge", "description": "Cross", "tags": ["cross"], "likes": 5, "viewed": 85, "published": "Public", "date": "1543721834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 one = vec2(1., 0.);\n\nfloat sphere(vec3 p, float r) {\n\tp = .55*sin(iTime * .02) * sin(p + one.yyx * iTime);\n\treturn length(p) - r;\n}\n\nfloat map(vec3 p) {\n\treturn sphere(p, .7);\n}\n\nvec4 raymarch(vec2 uv) {\n\tvec3 camera = vec3(0., 0., -3.);\n\tvec3 dir = normalize(vec3(uv, 1.));\n\tvec4 res = vec4(camera, 0.);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 60; ++i) {\n\t\tvec3 p = camera + t*dir;\n\t\tfloat d = map(p);\n\t\tif (d < .001) {\n\t\t\tres = vec4(p, 1.);\n\t\t}\n\t\tt += d;\n\t}\n\treturn res;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\treturn normalize(vec3(\n\t\tmap(p - e.xyy) - map(p + e.xyy),\n\t\tmap(p - e.yxy) - map(p + e.yxy),\n\t\tmap(p - e.yyx) - map(p + e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\tvec3 color = vec3(.1,.4,.5);\n\tvec4 obj = raymarch(uv);\n\tcolor = mix(color, vec3(1.),\n\t\tobj.w*dot(normal(obj.xyz), normalize(vec3(uv, 1.))));\n\tfragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKfzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 57, 57, 136], [138, 138, 157, 157, 182], [184, 184, 208, 208, 475], [477, 477, 498, 498, 657], [659, 659, 714, 714, 977]], "test": "timeout"}
{"id": "MtKyD1", "name": "IQs-Raytraced Shapes", "author": "gPlatl", "description": "A collection of IQs basic Raytracer shapes (3d intersection functions).     \nmouse: y=shape selection, x=rotationZ\n\nVersion 1.4 with 7 shapes having now unified return values ...", "tags": ["raytracer", "sphere", "iq", "cone", "cylinder", "capsule"], "likes": 2, "viewed": 154, "published": "Public", "date": "1545302087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------------------\n// IQ_Raytracer.glsl     https://www.shadertoy.com/view/MtKyD1   \n//\n//   v1.0  2018-12-20  initial release\n//   v1.1  2018-12-27  current version\n//   v1.2  2019-01-18  ellipsoid & axis added\n//   v1.3  2020-03-16  corrected CappedCone & RoundedCone\n//   v1.4  2020-09-28  iRoundedCone corrected\n//         2020-09-28  working on...\n//\n// Collection of raytracing different basic geometric shapes designed by Inigo Quilez.\n//   The MIT License   Copyright  2018 Inigo Quilez\n//   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// infos:\n//   https://iquilezles.org/www/articles/diskbbox/diskbbox.htm\n//   https://iquilezles.org/www/articles/intersectors/intersectors.htm\n//   https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//\n// basic shapes intersection:\n//   Sphere           https://www.shadertoy.com/view/4d2XWV\n//   Sphere AA        https://www.shadertoy.com/view/MsSSWV\n//   Ellipsoid        https://www.shadertoy.com/view/ltsSzn\n//   Cylinder         https://www.shadertoy.com/view/MtcXRf\n//   Capped Cylinder  https://www.shadertoy.com/view/4lcSRn\n//   Capsule          https://www.shadertoy.com/view/Xt3SzX\n//   Rounded Cone     https://www.shadertoy.com/view/MlKfzm\n//   Capped Cone      https://www.shadertoy.com/view/llcfRf\n//   Torus            https://www.shadertoy.com/view/4sBGDy\n//\n// not included:\n//   Cone (no base)   https://www.shadertoy.com/view/MtcXWr\n//-----------------------------------------------------------------\n\n// antialiasing level... \n#define AA 2\n\n#define SHAPES 7.\n\n/* test objects:   \n\n         Torus\n      Ellipsoid\n        Sphere\n      Rounded Cone \n      Capped Cone\n        Capsule\n    Capped Cylinder\n*/\n\n// result = sqr(v) = v^2\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sqr ( in vec3 v ) { return dot(v,v); }\n\n//=================================================================\n// sphere distance, normal & intersection\n//=================================================================\n\n// get distance of ray - sphere intersection\nfloat sdSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n  vec3 oc = ro - sph.xyz;\n  float b = dot (oc, rd);\n  float c = dot (oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h<0.0) return -1.0;\n  return -b -sqrt(h);\n}\n\n// sphere normal\nvec3 sphereNormal( in vec3 pos, in vec4 sph )\n{\n  return normalize(pos - sph.xyz);\n}\n\n// ray-sphere intersection, return.xyz=normal, return.w=distance\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 M, in float radius)\n{\n  vec4 sph = vec4(M,radius);  \n  float t = sdSphere(ro,rd,sph);\n  if (t<0.0)    return vec4(-1);         //===>\n  vec3 pos = ro + t * rd;\n  vec3 n = sphereNormal (pos, sph);\n  return vec4(n,t);\n}\n\n//=================================================================\n// ellipse distance & intersection     https://www.shadertoy.com/view/ltsSzn\n//=================================================================\nstruct Ellipsoid { vec3 center; vec3 radius; };\n\n// get distance of ray - ellipsoid intersection\nfloat sdEllipsoid (in vec3 ro, in vec3 rd\n                  ,in Ellipsoid sph)\n{\n  vec3 oc = ro - sph.center;\n  vec3 ocn = oc / sph.radius;\n  vec3 rdn = rd / sph.radius;\n    \n  float a = dot( rdn, rdn );\n  float b = dot( ocn, rdn );\n  float c = dot( ocn, ocn );\n  float h = b*b - a*(c-1.0);\n  if (h <= 0.0)    return h;         //===>\n  return (-b -sqrt(h))/a;\n}    \n            \n// ellipsoid normal\nvec3 ellipsoidNormal( in vec3 pos, in Ellipsoid sph )\n{\n  return normalize((pos-sph.center) / sph.radius);\n}\n\n// ray - ellipsoid intersection, return.xyz=normal, return.w=distance\nvec4 iEllipsoid (in vec3 ro, in vec3 rd, in vec3 center, in vec3 radii)\n{\n  Ellipsoid ellipsoid = Ellipsoid(center, radii);\n  float t = sdEllipsoid (ro,rd,ellipsoid);\n  if (t<0.0)    return vec4(-1);         //===>\n    \n  vec3 pos = ro + t * rd;\n  vec3 n = ellipsoidNormal (pos, ellipsoid);\n  return vec4(n,t);\n}\n\n//=================================================================\n// cylinder distance & intersection\n//=================================================================\n\n//-----------------------------------------------------------------\n// get distance of ray - cylinder intersection\n//   cylinder distance:  https://www.shadertoy.com/view/wdXGDr\n//-----------------------------------------------------------------\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n//-----------------------------------------------------------------\n// ray - cylinder intersection, return.xyz=normal, return.w=distance\n//   https://www.shadertoy.com/view/MtcXRf\n//-----------------------------------------------------------------\nvec4 iCylinder( in vec3 ro, in vec3 rd  // ray origin & direction\n               ,in vec3 pa, in vec3 pb  // point a, point b\n               ,in float ra )           // radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);\n    vec3 ab = pb - pa;\n    float ch = length(ab);\n    vec3 ca = ab / ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 )         return vec4(-1.0);\n    h = sqrt(h);\n    float t1 = (-b-h)/a;  \n    //float t2 = (-b+h)/a; // exit point\n\n    float y = caoc + t1*card;\n\n    // body\n    if( abs(y)<ch )\n        return vec4( normalize( oc+t1*rd - ca*y ), t1 );\n    \n    // caps\n    float sy = sign(y);\n    float tp = (sy*ch - caoc)/card;\n   \n    if( abs(b+a*tp) < h)  return vec4(ca*sy, tp);\n\n    return vec4(-1.0);\n}\n\n//=================================================================\n// endless cylinder intersection\n//=================================================================\n\n//-----------------------------------------------------------------\n// ray - endless cylinder intersection, return.xyz=normal, return.w=distance\n//   https://www.shadertoy.com/view/MtcXRf\n//-----------------------------------------------------------------\nvec4 iEndlessCylinder( in vec3 ro, in vec3 rd  // ray origin & direction\n                      ,in vec3 pa, in vec3 pb  // point a, point b\n                      ,in float ra )           // radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);   // center point \n    vec3 ab = pb - pa;       // axis direction from A -> B\n    float axisLen = length(ab);\n    vec3 ca = ab / axisLen;  // identity axis vector\n\n    vec3  oc = ro - cc;   // origin to center vector\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if (h <= 0.0)         return vec4(-1.0);\n    h = sqrt(h);\n    float t1 = (-b-h)/a; // nearest distance \n  //float t2 = (-b+h)/a; // exit point distance\n\n    float y = caoc + t1*card;\n\n    vec3 normal = normalize(oc+t1*rd - ca*y);\n    return vec4 (normal, t1);\n}\n\n//=================================================================\n// capsule distance, normal & intersection\n//=================================================================\n\n// get distance of ray - capsule intersection\nfloat sdCapsule(in vec3 ro, in vec3 rd,   // ray origin & direction\n                in vec3 pa, in vec3 pb,   // position of A & B\n                in float r )              // radius\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h<0.0 ) return -1.0;      //===>\n\n    float t = (-b-sqrt(h))/a;\n    float y = baoa + t*bard;\n        \n    // body\n    if( y>0.0 && y<baba ) return t;\n\n    // sphere caps\n    vec3 oc = (y<=0.0) ? oa : ro - pb;\n    b = dot(rd,oc);\n    c = dot(oc,oc) - r*r;\n    h = b*b - c;\n//    if( h>0.0 ) \n        return -b - sqrt(h);\n    return -1.0;\n}\n\n// get capsule normal\nvec3 capsuleNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  u = b - a;\n    vec3  v = pos - a;\n    float h = clamp(dot(v,u)/dot(u,u), 0.0, 1.0);\n    return (v - h*u) / r;\n}\n\n// ray-capsule intersection,  return.xyz=normal, return.w=distance \nvec4 iCapsule( in vec3 ro, in vec3 rd, \n               in vec3 pa, in vec3 pb,   // Endpunkte\n               in float r )              // Radius\n{\n  float t = sdCapsule(ro,rd, pa,pb,r);\n  if (t<0.0)    return vec4(-1);         //===>\n  vec3 pos = ro + t * rd;\n  vec3 n = capsuleNormal (pos, pa,pb, r);\n  return vec4(n,t);\n}\n\n//=================================================================\n//  capped cone intersection  \n//     https://www.shadertoy.com/view/llcfRf of 2019-04-04\n//=================================================================\nvec4 iCappedCone( in vec3  ro, in vec3  rd,   // ray origin & direction \n                  in vec3  pa, in vec3  pb,   // end points A & B\n                  in float ra, in float rb )  // disc radii of A & B\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n    if     ( m1 < 0.0 )\n    { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) \n        return vec4(-ba*inversesqrt(m0), -m1/m3); \n    }\n    else if( m2 > 0.0 ) \n    { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) \n        return vec4(ba*inversesqrt(m0), -m2/m3); \n    }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);         //===>\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if( y>0.0 && y<m0 ) \n    {\n        return vec4(normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y), t);\n    }\n    \n    return vec4(-1.0);\n}\n\n//=================================================================\n// rounded cone (distance), intersection\n//=================================================================\n\n// rounded cone distance see https://www.shadertoy.com/view/tdXGWr\nfloat sdRoundedCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// rounded cone intersection  https://www.shadertoy.com/view/MlKfzm\nvec4 iRoundedCone( in vec3  ro, in vec3  rd,   // ray origin & direction\n                   in vec3  pa, in vec3  pb,   // end points A & B\n                   in float ra, in float rb )  // sphere radii of A & B\n{\n  vec3  ba = pb - pa;\n  vec3  oa = ro - pa;\n  vec3  ob = ro - pb;\n  float rr = ra - rb;\n  float m0 = dot(ba,ba);\n  float m1 = dot(ba,oa);\n  float m2 = dot(ba,rd);\n  float m3 = dot(rd,oa);\n  float m5 = dot(oa,oa);\n  float m6 = dot(ob,rd);\n  float m7 = dot(ob,ob);\n    \n  float d2 = m0    - rr*rr;\n  float k2 = d2    - m2*m2;\n  float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n  float k0 = d2*m5 - m1*m1 + m1*rr*ra*2.0 - m0*ra*ra;\n    \n  float h = k1*k1 - k0*k2;\n  if (h < 0.0) return vec4(-1.0);   //===>\n  float t = (-sqrt(h)-k1)/k2;\n\n  float y = m1 - ra*rr + t*m2;\n  if (y>=0.0 && y<=d2)        // coat hit ?\n    return vec4(normalize( d2*(oa + t*rd)-ba*y), t);\n\n  // Caps. I feel this can be done with a single square root instead of two\n  float h1 = m3*m3 - m5 + ra*ra;\n  float h2 = m6*m6 - m7 + rb*rb;\n  if (max(h1,h2) < 0.0)       // no sphere hit?   \n    return vec4(-1.0);        //===>\n\n  vec4 r = vec4(1e20);\n  if (h1 > 0.0)\n  {                           // sphere-1 hit\n    t = -m3 - sqrt(h1);\n    r = vec4((oa+t*rd)/ra, t);\n  }\n  if (h2 > 0.0)\n  {                           // sphere-2 hit\n    t = -m6 - sqrt(h2);\n    if(t < r.w)               // nearer?\n      r = vec4((ob+t*rd)/rb, t);\n  }\n  return r;                   // distance\n}\n\n//=================================================================\n// ray - torus distance, normal & intersection\n// https://www.shadertoy.com/view/4sBGDy\n// f(x) = (|x| + R - r) - 4R|xy| = 0\n//=================================================================\n\n// get distance of ray - torus intersection\nfloat sdTorus( in vec3 ro, in vec3 rd, in vec2 torus )\n{\n\tfloat Ra2 = torus.x*torus.x;\n\tfloat ra2 = torus.y*torus.y;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\t\t\n\tfloat k = (m - ra2 - Ra2)/2.0;\n\tfloat a = n;\n\tfloat b = n*n + Ra2*rd.z*rd.z + k;\n\tfloat c = k*n + Ra2*ro.z*rd.z;\n\tfloat d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    //----------------------------------\n\n\tfloat p = -3.0*a*a     + 2.0*b;\n\tfloat q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;\n\tfloat r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;\n\tp /= 3.0;\n\tr /= 3.0;\n\tfloat Q = p*p + r;\n\tfloat R = 3.0*r*p - p*p*p - q*q;\n\t\n\tfloat h = R*R - Q*Q*Q;\n\tfloat z = 0.0;\n\tif( h < 0.0 )\n\t{\n\t\tfloat sQ = sqrt(Q);\n\t\tz = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n\t}\n\telse\n\t{\n\t\tfloat sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n\t\tz = sign(R)*abs( sQ + Q/sQ );\n\t}\n\t\n\tz = p - z;\n\t\n    //----------------------------------\n\t\n\tfloat d1 = z   - 3.0*p;\n\tfloat d2 = z*z - 3.0*r;\n\n\tif( abs(d1)<1.0e-4 )\n\t{\n\t\tif( d2<0.0 ) return -1.0;\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\tif( d1<0.0 ) return -1.0;\n\t\td1 = sqrt( d1/2.0 );\n\t\td2 = q/d1;\n\t}\n\n    //----------------------------------\n\t\n\tfloat result = 1e20;\n\n\th = d1*d1 - z + d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = -d1 - h - a;\n\t\tfloat t2 = -d1 + h - a;\n\t\t     if( t1>0.0 ) result=t1;\n\t\telse if( t2>0.0 ) result=t2;\n\t}\n\n\th = d1*d1 - z - d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = d1 - h - a;\n\t\tfloat t2 = d1 + h - a;\n\t\t     if( t1>0.0 ) result=min(result,t1);\n\t\telse if( t2>0.0 ) result=min(result,t2);\n\t}\n\treturn result;\n}\n\n// torus normal:  df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// ray-torus intersection,  return.xyz=normal, return.w=distance \nvec4 iTorus( in vec3 ro, in vec3 rd, in vec2 torusRadii )\n{\n    float t = sdTorus (ro,rd,torusRadii);\n    if (t <= 0.0)    return vec4(-1);    //===>\n    vec3 pos = ro + t * rd;\n    vec3 n = nTorus (pos, torusRadii);\n    return vec4(n,t);\n}\n\n//=================================================================\n// please set AA level for antialiasing... \n//=================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 tot = vec3(0.0);\n  vec2 mpos = iMouse.xy / iResolution.xy;  // 0 .. 1\n  int selection = int (SHAPES*mpos.y);     // 0 .. shapes-1\n\n#if AA>1\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ )\n  {\n    // pixel coordinates\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 p = (2.0*(fragCoord+o) - iResolution.xy) / iResolution.y;\n#else                                // p.y:  -1 .. 1\n    vec2 p = (2.0* fragCoord    - iResolution.xy) / iResolution.y;\n#endif                                      \n\n    // camera position\n    float an = 0.5*iTime + 6.4*mpos.x;\n    vec3 ro = vec3( cos(an), 0.3, sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // animate point A,B and radius\n    vec3 pA =  0.2 + 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n    vec3 pB = -0.2 + 0.3*sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0));\n    vec3 center = 0.5*(pA+pB);\n    float radius  = 0.2 + 0.02*sin(iTime*1.3+0.5);\n    float radius2 = 0.2 + 0.04*sin(iTime*2.3+0.5);\n\n    // background color\n    vec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    vec3 ellipsoidRadii = radius * vec3(0.5, 1, 2);\n        \n    // raytrace\n    vec4 nt = vec4(-1.0);  // nt.xyz=normal, nt.w=distance \n    if      (selection == 0) nt = iCylinder   (ro,rd, pA,pB, radius);\n    else if (selection == 1) nt = iCapsule    (ro,rd, pA,pB, radius);\n    else if (selection == 2) nt = iCappedCone (ro,rd, pA,pB, radius, radius2);\n    else if (selection == 3) nt = iRoundedCone(ro,rd, pA,pB, radius, radius2);\n    else if (selection == 4) nt = iSphere     (ro,rd, center, 2.0*radius);\n    else if (selection == 5) nt = iEllipsoid  (ro,rd, center, ellipsoidRadii);\n    else                     nt = iTorus      (ro,rd, 2.0*vec2(radius, 0.2*radius));\n    float t = nt.w;   // distance\n\n    vec3 surfaceColor = vec3(1.0, 0.7, 0.3);\n    // draw axis through point A an B\n    if (selection < 5)\n    { \n      vec4 nt2 = iEndlessCylinder (ro,rd, pA,pB, 0.01);\n      if (nt2.w > 0.0)     // hit endless line axis ?  \n      {\n        if ((t < 0.0)      // no object intersection  \n        ||  (nt2.w < t))   // or axis distance nearer ?\n        {\n          surfaceColor = vec3(0.7);  // set axis color\n          nt = nt2;        // set normal  \n          t = nt2.w;       // set distance\n        }\n      } \n    }\n            \n    if (t > 0.0)      // intersection?\n    {\n      vec3 pos = ro + t*rd;\n      vec3 normal = nt.xyz;\n  \n      // shading/lighting\n      float dif = clamp( dot(normal,vec3(0.5, 0.7, 0.2)), 0.0, 1.0 );\n      float amb = 0.5 + 0.5*dot(normal,vec3(0.0, 1.0, 0.0));\n      const vec3 ambientColor = vec3(0.2, 0.3, 0.4);\n      const vec3 diffuseColor = vec3(0.8, 0.7, 0.5);\n      col = sqrt (ambientColor*amb + diffuseColor*dif);\n      col *= surfaceColor;\n    }\n    tot += col;\n#if AA>1\n  }\n  tot /= float(AA*AA);\n#endif\n\n  fragColor = vec4( tot, 1.0 );\n    \n  // draw selection marker\n  if (fragCoord.x < 8. || fragCoord.x > iResolution.x-8.)\n  {\n    int spos = int (SHAPES * fragCoord.y / iResolution.y);  // 0 .. shapes-1\n    if (selection == spos)\n      fragColor += vec4(0.4,0.4,0,1);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKyD1.jpg", "access": "shaders20k", "license": "mit", "functions": [[2718, 2743, 2768, 2768, 2787], [2788, 2788, 2813, 2813, 2832], [3013, 3058, 3113, 3113, 3276], [3278, 3295, 3342, 3342, 3379], [3381, 3446, 3513, 3513, 3709], [3973, 4021, 4101, 4101, 4383], [4401, 4421, 4476, 4476, 4529], [4531, 4601, 4674, 4674, 4913], [5088, 5334, 5385, 5385, 5751], [5752, 6000, 6177, 6220, 6974], [7146, 7402, 7600, 7643, 8361], [8543, 8589, 8773, 8773, 9462], [9464, 9486, 9555, 9555, 9677], [9679, 9747, 9893, 9893, 10070], [10072, 10298, 10507, 10507, 11529], [11709, 11776, 11841, 11905, 12492], [12494, 12562, 12775, 12775, 14010], [14290, 14334, 14390, 14390, 15833], [15835, 15862, 15900, 15900, 15988], [15990, 16056, 16115, 16115, 16296]], "test": "ok"}
{"id": "MtVBR3", "name": "CS1230 - Lab 10", "author": "dylleealt", "description": "shadertoy lab", "tags": ["raymarcher"], "likes": 2, "viewed": 144, "published": "Public", "date": "1544760312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NO_INTERSECT 0\n#define SPHERE 1\n#define PLANE 2\n#define TERRAIN 3\n#define HILLS 4\n#define DISPLACEMENT_FACTOR 0.1\n\n#define MOD2 vec2(3.07965, 7.4235)\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n    \n//--------------------------------------------------------------------------\n// Noise functions\n\nfloat Hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat Hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n//--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw = w*0.6;\n\t\txy = 2.0 * xy;\n\t}\n\treturn f;\n}\n\nvec2 Voronoi( in vec2 x )\n{\n\tvec2 p = floor( x );\n\tvec2 f = fract( x );\n\tfloat res=100.0,id;\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2 b = vec2( float(i), float(j) );\n\t\tvec2 r = vec2( b ) - f  + Hash( p + b );\n\t\tfloat d = dot(r,r);\n\t\tif( d < res )\n\t\t{\n\t\t\tres = d;\n\t\t\tid  = Hash(p+b);\n\t\t}\t\t\t\n    }\n\treturn vec2(max(.4-sqrt(res), 0.0),id);\n}\n\n//--------------------------------------------------------------------------\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)/(b-a),0.,1.);\n}\n\nfloat heightMap( in vec2 p)\n{\n\tvec2 pos = p*0.003;\n\tfloat w = 60.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = w * 0.62;\n\t\tpos *= 2.5;\n\t}\n\n\treturn f;\n}\n\nvec3 DE(vec3 p)\n{\n\tfloat base = heightMap(p.xz) - 1.9;\n\tfloat height = Noise(p.xz*2.0)*.7 + Noise(p.xz)*.15 + Noise(p.xz*.5)*.001;\n\t//p.y += height;\n\tfloat y = p.y - base - height;\n\ty = y*y;\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*0.4+p.zx*0.3)*.12+vec2(sin(2.3+0.1*p.z),sin(3.6+0.1*p.x))*y*.5));\n\tfloat f = ret.x * .6 + y * .58;\n\treturn vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);\n}\n\nfloat CircleOfConfusion(float t)\n{\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\n}\n\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\n{\n\tfloat d = 0.0;\n\t// Only calculate cCoC once is enough here...\n\tfloat rCoC = CircleOfConfusion(dist*2.3);\n\tfloat alpha = 0.0;\n\t\n\tvec4 col = vec4(mat*0.15, 0.0);\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif (col.w > .99) break;\n\t\tvec3 p = rO + rD * d;\n\t\t\n\t\tvec3 ret = DE(p);\n\t\tret.x += .5 * rCoC;\n\n\t\tif (ret.x < rCoC)\n\t\t{\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\n\t\t\t// Mix material with white tips for grass...\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\n\t\t\tcol += vec4(gra * alpha, alpha);\n\t\t}\n\t\td += max(ret.x * .7, .1);\n\t}\n\tif(col.w < .2)\n\t\tcol.xyz = vec3(0.1, .19, 0.05);\n\treturn col.xyz;\n}\n\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis)\n{\n    // Random colour...\n    vec3 mat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.25));\n    // Random shadows...\n    float t = FractalNoise(pos.xz * .1)+.5;\n    // Do grass blade tracing...\n    mat = GrassBlades(pos, dir, mat, dis) * t;\n\treturn mat;\n}\n\n//--------------------------------------------------------------------------\nPrimitiveDist sdHills(in vec3 p, in float scale)\n{\n\tfloat h = heightMap(p.xz * scale) / scale - 24.0 / scale;\n    return PrimitiveDist(p.y - h, HILLS);\n}\n\nPrimitiveDist sdTerrain(in vec3 p, in float scale)\n{\n\tfloat h = max(heightMap(p.xz * scale) / scale - 50.0 / scale, 0.0);\n    return PrimitiveDist(p.y - h, TERRAIN);\n}\n\n\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\n// helper functions\n\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; }\nfloat smin2( float a, float b, float k ) { return -log(exp2(-k*a)+exp2(-k*b))/k; }\n                                         \nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec2 cmpDist(vec2 a, vec2 b){\n \treturn (a.x < b.y) ? a : b; \n}\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n   // p = tri3(p);\n   return pow(sin(p.x * p.y), 2.0);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 x = texture(sam, p.yz * abs(n.x));\n    vec4 y = texture(sam, p.xz * abs(n.y));\n    vec4 z = texture(sam, p.xy * abs(n.z));\n    vec4 texColor = x + y + z; \n    return texColor.xyz;\n}\n\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\nfloat mapCar(in vec3 p0){ \n\tvec3 p=p0+vec3(0.0,1.24,0.0);\n\tfloat r=length(p.yz);\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\n\tr=length(p.yz);\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\n\td=max(d,-max(p.x-0.165,r-0.24));\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\n\td=min(d,d2);\n\n\treturn d;\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    p = 2.0 * vec3(fract(p.x), p.y, fract(p.z)) - 1.0;\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.0;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float inCity = sdCylinder(vec3(floor(p.x), p.y, floor(p.z)), vec2(32.0, 10000.0));\n    if (inCity < 0.01){\n        float planeDist = sdFloor(p); \n        // city buildings\n        float buildingDist = sdCylinder(vec3(floor(p.x), p.y, floor(p.z)) - vec3(0.0, 0.0, 0.0), vec2(7.6, 10000.0));\n        // inside park\n        if (buildingDist < 0.1){\n            PrimitiveDist terrainDist = sdTerrain(p, 98.0);\n//            vec2 block = floor(p.xz);\n//            p.xz = fract(p.xz);\n//            if (Hash21(block) < 0.15){\n//                float treeDist = sdBox(p - vec3(0.0, terrainDist.dist, 0.0), vec3(0.25));//\n//                if (treeDist < terrainDist.dist){\n//                    return PrimitiveDist(treeDist, TERRAIN);\n//                }\n//            }\n            return terrainDist;\n        } else {\n            // outside park\n            vec2 block = floor(p.xz);\n            p.xz = fract(p.xz);\n            vec4 rand;\n            rand.xy = Hash22(block);\n            rand.zw = Hash22(rand.xy);\n            float baseRad = 0.5 + 2.0 / length(block.xy);\n            float height = rand.w*rand.z + 0.1;\n            float downtown = saturate(4.0 / length(block.xy + vec2(8.8, 7.0)));\n            height *= downtown;\n            height *= 1.5+(baseRad-0.15)*20.0;\n            buildingDist = sdBox(p, vec3(baseRad, height, baseRad));     \n        }\n        // float sphereDist = mapCar(p);\n        if (planeDist < buildingDist){\n           return PrimitiveDist(planeDist, PLANE);\n        } \n        return PrimitiveDist(buildingDist, SPHERE);\n    }\n    return sdHills(p, 2.4);\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float dx = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    float dy = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    float dz = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    \n    return normalize(vec3(dx,dy,dz));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.01;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    float hprev = 1e20;\n    \n    for(int i = 0; i < 100; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n        if (h < threshold) {\n\t\t\treturn 0.0;\n        }\n        float y = h * h / (2.0 * hprev);\n\t\tfloat d = sqrt(h * h / y * y);\n        darkness = min(darkness, k * d / max(0.0, marchDist - y));\n        hprev = h;\n        marchDist += 0.2 * h;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 450.0;\n    float threshold = 0.0001;\n    \n    int maxIterations = 1000;\n    vec3 p = ro;\n    // Fill in the iteration count\n    for (int i = 0; i < maxIterations; i++) {\n        PrimitiveDist intersect = map(p);\n        if (intersect.dist < threshold){\n            return PrimitiveDist(marchDist, intersect.primitive);\n        }\n\t\tmarchDist += 0.1 * intersect.dist;\n        if (marchDist > boundingDist){\n         \tbreak;\n        }\n        p = ro + marchDist * rd;\n    }\n    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 renderReflect(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.3;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 8.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else if (which == TERRAIN) {\n     \tmaterial = vec3(0.1, 0.85, 0.3);\n    } else if (which == HILLS) {\n     \tmaterial = texCube(iChannel2, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    \n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.3;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 8.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else if (which == TERRAIN) {\n     \tmaterial = TerrainColour(2.0 * pos, rd, nor, t);\n        return min(vec3(1.0), (diffuse + 0.3) * material);\n    } else if (which == HILLS) {\n     \tmaterial = texCube(iChannel2, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n\t\n//    if (which == TERRAIN){\n//        vec3 intersect = pos += 0.001 * nor;\n//       \tvec3 reflectRay = reflect(rd, nor);\n//        PrimitiveDist res = raymarch(intersect, reflectRay);\n//        vec3 reflectCol = renderReflect(intersect, reflectRay, res.dist, res.primitive);\n//        return mix(col, reflectCol, 0.6);\n//    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(16.0 * sin(iTime * .3), 8.0, 16.0 * cos(iTime * .3));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n  \n    // TODO [Task 1] Construct the ray direction vector\n    // set up UV coordinates in image space\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    // set up ray\n    vec3 rayDirection = vec3(uv, focalLength);\n    // transform to world space\n    rayDirection = normalize(cameraRight * rayDirection.x + cameraUp * rayDirection.y + cameraForward * rayDirection.z);\n      \n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n      col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVBR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 405, 428, 428, 466], [468, 468, 488, 488, 574], [575, 652, 678, 678, 922], [924, 924, 956, 956, 1088], [1090, 1090, 1117, 1117, 1453], [1455, 1532, 1574, 1574, 1610], [1612, 1612, 1641, 1641, 1796], [1798, 1798, 1815, 1815, 2184], [2186, 2186, 2220, 2220, 2277], [2279, 2279, 2349, 2349, 3046], [3048, 3048, 3113, 3137, 3372], [3374, 3451, 3501, 3501, 3604], [3606, 3606, 3658, 3658, 3773], [3776, 3776, 3795, 3795, 3840], [3841, 3841, 3860, 3860, 3891], [3892, 3892, 3915, 3915, 3951], [3952, 3952, 3975, 3975, 4046], [4047, 4047, 4069, 4069, 4156], [4157, 4157, 4179, 4179, 4232], [4233, 4233, 4256, 4256, 4329], [4330, 4330, 4353, 4353, 4424], [4425, 4425, 4448, 4448, 4534], [4557, 4629, 4670, 4670, 4708], [4709, 4709, 4751, 4751, 4791], [4834, 4834, 4857, 4857, 4886], [4887, 4887, 4910, 4910, 4939], [4940, 4940, 4965, 4965, 4994], [4996, 4996, 5025, 5025, 5058], [5059, 5088, 5111, 5111, 5139], [5141, 5208, 5230, 5230, 5349], [5351, 5472, 5507, 5526, 5564], [5566, 5736, 5789, 5789, 5980], [5982, 5982, 6016, 6016, 6127], [6129, 6129, 6154, 6154, 6578], [6580, 6622, 6653, 6653, 6885], [6887, 6887, 6919, 6919, 6947], [6949, 6949, 6983, 6983, 7082], [7084, 7084, 7107, 7107, 7125], [7127, 7127, 7154, 7198, 8793], [8896, 8913, 8938, 8938, 9157], [9159, 9159, 9200, 9200, 9823], [9826, 9826, 9868, 9953, 10531], [10533, 10533, 10591, 10648, 11851], [11853, 11853, 11904, 11961, 13569], [13571, 13571, 13626, 13626, 14834]], "test": "error"}
{"id": "MtVcWR", "name": "torus_thingy_18", "author": "balkhan", "description": " ", "tags": ["3d", "raymarching"], "likes": 3, "viewed": 355, "published": "Public API", "date": "1545196227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tllength(vec2 p);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tbgd_col;\t// bgd color\nvec3\th; \t\t\t// volumetric light\nvec3\trc;         // light color\n\n#define I_MAX\t\t150.\n#define E\t\t\t0.0001\n#define FAR\t\t\t150.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 60.0);\n\n    h*=0.;\n    rc = vec3(\n        abs(sin(iTime*.25+0.00) )\n   \t\t,\n        abs(sin(iTime*.25+1.04) )\n        ,\n        abs(sin(iTime*.30+2.08) )\n    );\n    vec2\tinter = (march(pos, dir));\n    bgd_col = vec3(.90, .82, .70);\n    col.xyz = bgd_col*(1.-inter.x*.005)*.5;\n    col += h*.1005*-.5;\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n\n    return length(q)-t.y;\n}\n\nvec3\tfloorify(vec3 rp) \n{\n    float var = 4000.+.0*atan((rp.x)-0., rp.y - 0.);\n    return floor(var*rp)/var;//floor(rp*mod(cos(var*1.+iTime*.1)*.0+.0+max(iTime*.0251+.5, .5), 10.))/mod(+max(iTime*.0251+.5, .5), 10.)-.0;\n}\n\nvec2\tfloorify(vec2 rp) \n{\n    float var = 10.+.0*atan((rp.x)-0., rp.y - 0.);\n    return floor(var*rp)/var;//floor(rp*mod(cos(var*1.+iTime*.1)*.0+.0+max(iTime*.0251+.5, .5), 10.))/mod(+max(iTime*.0251+.5, .5), 10.)-.0;\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tmind = 1e5;\n    float\ttoris = 1e5;\n    p.z -= -15.;\n    rotate(p.xz, 4.-1.*.35*iTime );\n\trotate(p.yz, .0*1.57-.05*iTime );\n    rotate(p.xy, iTime*.5);\n    vec2 q;\n    float ata = atan(p.x, p.z);\n    float sata = sin(ata*20.);\n    q = vec2( llength(p.xz)-40., p.y );\n    rotate(q, -iTime*3.0*.125);//+0.*cos(.0*atan(p.x, p.z)+0.*atan(q.x, q.y)-iTime*1.*.0)*3.14/12. );\n\n    float ata2 = atan(q.x, q.y);\n        rotate(q, -iTime*1.+ata*.5);\n    q.xy = modA(q.xy, 2.);q.x-=10.;\n        rotate(q, -iTime*1.5+ata*1.);\n    q.xy = abs(q.xy)-1.25;//-1.*sin(ata2*1.-iTime*2.+ata);\n    q.x = max(abs(q.x), abs(q.y) )-2.;\n    toris = mylength( q )-.50-.5*min(1.5, -.5+max(.5+-.5*sin(ata*20.+iTime*5.)*0.25, 1.+10.*sata));\n    mind = toris;\n    mind = mix(mind, abs(mind)+.005, .5 + .5*sin(-iTime+ata2+ata));\n\n    h += (1.)*1./max(.01, toris*toris*1000.+ 2.25);\n    h -= vec3(.5, .2,.15)*1./max(.01, mind*mind*1. + 2.001);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.5; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat llength(vec2 p)\n{\n    float ret;\n    \n    ret = max(\n    abs(p.x)+.5*abs(p.y)\n    ,\n    abs(p.y)+.5*abs(p.x)\n    );\n\treturn ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max(abs(p.x), abs(p.y));\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max(max(abs(p.x), abs(p.y)), abs(p.z));\n\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVcWR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[673, 673, 716, 716, 1213], [1286, 1286, 1319, 1319, 1450], [1475, 1475, 1508, 1508, 1575], [1577, 1577, 1602, 1602, 1798], [1800, 1800, 1825, 1825, 2019], [2021, 2021, 2042, 2042, 2991], [2993, 2993, 3025, 3025, 3436], [3452, 3452, 3475, 3475, 3588], [3590, 3590, 3614, 3614, 3685], [3687, 3687, 3711, 3711, 3793], [3795, 3795, 3835, 3835, 3910], [3912, 3912, 3940, 3940, 4048], [4050, 4050, 4072, 4072, 4278], [4280, 4280, 4330, 4330, 4593]], "test": "error"}
{"id": "MtVfRt", "name": "Nanoforge", "author": "mensab", "description": "Returning to raymarching stuff for a bit and trying to get creative with the mandelbox. This shader has been gathering dust in my drafts for a couple of weeks now so I figured I'd just polish it now and submit it.", "tags": ["3d", "raymarching", "fractal", "mandelbox"], "likes": 4, "viewed": 126, "published": "Public", "date": "1545593425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MIN_DIST .2\n#define MAX_DIST 20.\n#define MAX_MARCHING_STEPS 400\n#define EPS .001\n\nfloat mbox(vec3 p) {\n    //  params\n    float s = -2.2;\n    float f = 1.1;\n    float r = 3.;\n    float r_min = 0.;\n    \n    float dr = 1.;\n    vec3 off = p;\n    for (float i = 0.; i < 10.; i++) {\n        \n        //  box fold\n        p = clamp(p, -f, f) * 2. - p;\n        \n        // sphere fold\n        float p2 = dot(p, p);\n        if (p2 < r_min)\n        {\n            p *= r / r_min;\n            dr *= r / r_min;\n        }\n        else if (p2 < r)\n        {\n            p *= r / p2;\n            dr *= r / p2;\n        }\n            \n        p = s * p + off;\n        dr = dr * abs(s) + 1.;\n    }\n    return length(p) / abs(dr);\n}\n\nfloat scene(vec3 p) {\n    //  mirror\n    p.xz = abs(p.xz);\n    \n    //  repeat\n    float c = 4.4;\n    p = mod(p, c) - .5 * c;\n    \n    //  rotate\n    float theta = .051 * iTime;\n    mat4 rot = mat4(cos(theta), 0., sin(theta), 0.,\n                    0., 1., 0., 0.,\n                    -sin(theta), 0., cos(theta), 0.,\n                    0., 0., 0., 1.);\n    p = vec3(rot * vec4(p, 0.));\n\n    return mbox(p);\n}\n\nfloat raymarch(vec3 cam_pos, vec3 march_dir) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(cam_pos + depth * march_dir);\n        if (dist < EPS) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(EPS, 0.);\n    return normalize(vec3(scene(p + eps.xyy) - scene(p - eps.xyy),\n                          scene(p + eps.yxy) - scene(p - eps.yxy),\n                          scene(p + eps.yyx) - scene(p - eps.yyx)));\n}\n\nvec3 cam_dir(float fov, vec2 uv) {\n    vec2 xy = (uv * iResolution.xy) - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = cam_dir(120., uv);\n    vec3 cam_pos = vec3(0., 0., 0.);\n    float dist = raymarch(cam_pos, dir);\n    \n\tvec3 p = cam_pos + dist * dir;\n    vec3 n = normal(p);\n    float i = pow(1. - pow(dot(n, dir), 2.), 6.);\n    float v = dist / MAX_DIST;\n    \n    //  diffuse\n    vec3 col = vec3(0.);\n    \n    //  pulse\n    float pf = 4. * iTime;\n    float pd = .15;\n    float pw = 250.;\n    \n    vec3 pulse1 = vec3(0., 1., 5.) * 1. - pow(v, 4.);\n    float pc1 = pow(pow(sin((p.z - pf) * pd), 2.), 4. * pw);\n    col = mix(col, pulse1, pc1);\n    \n    vec3 pulse2 = vec3(5., .75, 0.);\n    float pc2 = pow(pow(sin((p.z - pf) * pd), 2.), pw);\n    col = mix(col, pulse2, i * pc2);\n    \n    //  fog/distance field\n    vec3 dist_col = vec3(.3 * pow(1. - v, 2.), .7 * (1. - v), 2. * (1. - v));\n    col = mix(col, dist_col, v);\n    \n    //  screen flash\n    col = mix(col, pulse2, pow(pow(sin((pf) * pd), 2.), 2. * pw));\n    col = mix(col, pulse1, pow(pow(sin((pf) * pd), 2.), 8. * pw));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVfRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 110, 125, 721], [723, 723, 744, 759, 1134], [1136, 1136, 1182, 1182, 1504], [1506, 1506, 1527, 1527, 1762], [1764, 1764, 1798, 1798, 1951], [1954, 1954, 2011, 2011, 3069]], "test": "ok"}
{"id": "tdl3z4", "name": "emissive window border experimen", "author": "mds2", "description": "just trying something out.  For full experience, turn off sound on the video in iChannel1.  I wish I could save the choice to do so in the shadertoy state when saving the shader.  But, as far as I know, I can't.", "tags": ["window", "border", "emissive"], "likes": 3, "viewed": 431, "published": "Public API", "date": "1545262270", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 50.0\n\n#define INTEGRATE_UNBOUNDED_STUFF 1\n// set to 0 to make the density of the glowy stuff 1/(distance^2)\n// by default it's 1/distance, which means the total glow contribution grows with MAX_DIST\n// I think it looks better with 1/distance\n// but, hey, neither of these functions come from \"physics\"\n// (or, if they do, it is only by coincidence)\n//\n// p.s. looks really nice when MAX_DIST is huge (thanks @CLPB for pointing this out)\n\nconst vec3 light = vec3(0.48, 0.64, -0.6);\n\nvec3 ball1;\nvec3 ball2;\nvec3 ball3;\n\nvec3 radii;\n\nconst float curve_rad = 0.1;\n\nconst mat3 color_map = 0.25 * mat3(1.0, 1.25, 1.0,\n                  \t\t\t0.7, 0.5, 1.0,\n                  \t\t\t0.0, 0.1, 1.0);\n\nmat3 tilt;\n\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat rect_sdf(in vec3 pt, in vec2 size, in float radius) {\n    vec2 xy = abs(pt.xy) - size;\n    xy = xy + curve_rad;\n    xy = max(vec2(0.0), xy);\n    float xy_dist = abs(length(xy) - curve_rad);\n    return length(vec2(pt.z, xy_dist)) - radius;\n}\n\nfloat hits(in vec2 plane_pt) {\n    vec2 rel = abs(plane_pt) + vec2(curve_rad) - vec2(1.0, 0.5625);\n    rel = max(vec2(0.0), rel);\n    return step(dot(rel, rel), curve_rad * curve_rad);\n}\n\nfloat sdf1(in vec3 pt) {\n    return rect_sdf(pt, vec2(1.0, 0.5625), 0.025 * radii.x);\n\n}\n\nfloat sdf2(in vec3 pt) {\n    return rect_sdf(pt, vec2(1.0, 0.5625) + 0.05, 0.025 * radii.y);\n}\n\nfloat sdf3(in vec3 pt) {\n    return rect_sdf(pt, vec2(1.0, 0.5625) + 0.1, 0.025 * radii.z);\n\n}\n\nvec3 sdfs(in vec3 pt) {\n    return vec3(sdf1(pt), sdf2(pt), sdf3(pt));\n}\n\nfloat sdf(in vec3 pt) {\n    return min(sdf1(pt), min(sdf2(pt), sdf3(pt)));\n}\n\nfloat min_comp(in vec3 comps) {\n    return min(comps.x, min(comps.y, comps.z));\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                sdf(pt + vec3(0.0, h, 0.0)) - f,\n                sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nfloat raymarch(in vec3 orig, in vec3 dir, out vec3 integral) {\n    integral = vec3(0.0);\n    float curr = 0.0;\n    const float step_ratio = 0.25;\n    vec3 curr_sdf = sdfs(orig);\n    float dist = step_ratio * min_comp(curr_sdf);\n    vec3 next_sdf = sdfs(orig + dir * dist);\n    // integral from 0 to d of 1/(a+bx) =\n    // screw it, just average some things.\n    integral = dist * (0.25 / curr_sdf + 1.0 / (curr_sdf + next_sdf) + 0.25 / next_sdf);\n    float total_dist = dist;\n    const vec3 thresh = vec3(0.004);\n    for (int i = 0; i < 128; ++i) {\n        curr_sdf = next_sdf;\n        dist = step_ratio * min_comp(curr_sdf);\n        total_dist += dist;\n        next_sdf = sdfs(orig + total_dist * dir);\n        vec3 mid = 0.5 * (curr_sdf + next_sdf);\n#if INTEGRATE_UNBOUNDED_STUFF        \n        integral += dist * (0.25 / max(thresh, curr_sdf) + \n                            0.5 / max(thresh, mid ) + \n                            0.25 / max(thresh, next_sdf));\n#else\n        integral += dist * (0.25 / max(thresh, curr_sdf * curr_sdf) + \n                            0.5 / max(thresh , mid * mid ) + \n                            0.25 / max(thresh, next_sdf * next_sdf));\n#endif        \n        if (min_comp(next_sdf) < 1.0e-4 || total_dist > MAX_DIST) {\n            return total_dist;\n        }\n    }\n    return total_dist;\n}\n        \n\nvec4 mainSingleRay( in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 orig = vec3(0.0, 0.0, -0.5);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    orig = tilt * orig;\n    dir = tilt * dir;\n    \n    orig.z -= 0.5;\n    \n    vec3 integral;\n    \n    \n    vec2 plane_hit = orig.xy - dir.xy * (-0.0 + orig.z) / dir.z;\n\n    float raydist = raymarch(orig, dir, integral);\n\n#if INTEGRATE_UNBOUNDED_STUFF    \n    vec3 col = smoothstep(0.15 * (1.0 *  radii), vec3(0.0), 0.45/(integral));\n#else\n    vec3 col = smoothstep(0.15 * (1.0 *  radii), vec3(0.0), 2.5/(integral));    \n#endif    \n    \n    col = color_map * col;\n    \n    // plane_hit = plane_hit * (1.0 + 0.05 * smoothstep(0.5, 1.2, length(plane_hit)));\n    \t\n    if (raydist < MAX_DIST) {\n        vec3 pt = orig + raydist * dir;\n        vec3 norm = normalize(sdf_grad(pt));\n        vec3 bounce = normalize(reflect(dir, norm));\n        vec3 dists = abs(sdfs(pt));\n        col += color_map * step(dists, vec3(1.0e-3));\n        col += 0.5 * smoothstep(0.5, 1.0, dot(bounce, light)) * vec3(0.9, 0.8, 1.0);\n    } else if (hits(plane_hit.xy) > 0.1) {\n        vec2 vid_uv = 0.5 * (plane_hit + vec2(1.0, 0.5625));\n        vid_uv.y /= 0.5625;\n        col += texture(iChannel2, vid_uv).rgb;\n    }\n    // Output to screen\n    return vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    radii = 0.1 + 0.5 * vec3(texture(iChannel0, vec2(0.0, 0.0)).r,\n                             texture(iChannel0, vec2(0.5, 0.0)).r,\n                             texture(iChannel0, vec2(1.0, 0.0)).r);\n    \n    vec2 mouse_uv = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    float theta = 0.3 * sin(iTime);\n    float ct = cos(theta);\n    float st = sin(theta);\n\n\n    tilt = mat3(ct, 0.0, st,\n                0.0, 1.0, 0.0,\n                -st, 0.0, ct);\n\n\tvec3 mouse_orig = vec3(0.0, 0.0, -0.5);\n    vec3 mouse_dir = normalize(vec3(mouse_uv, 1.0));\n    \n    mouse_orig = tilt * mouse_orig;\n    mouse_dir = tilt * mouse_dir;\n    \n    mouse_orig.z -= 0.5;\n    \n    vec2 plane_hit = mouse_orig.xy - mouse_dir.xy * (-0.0 + mouse_orig.z) / mouse_dir.z;\n    \n    if (hits(plane_hit.xy) > 0.1) {\n        radii += vec3(0.5, 0.6, 0.7);\n    }\n    \n    vec4 result = vec4(0.0);\n    const float r = 0.6;\n    result += 0.25 * mainSingleRay(fragCoord);\n    result += 0.25 * mainSingleRay(fragCoord + r * vec2(0.0, 1.0));\n    result += 0.25 * mainSingleRay(fragCoord + r * vec2(0.866, 0.5));\n    result += 0.25 * mainSingleRay(fragCoord + r * vec2(-0.866, 0.5));\n    fragColor = result;\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}, {"id": "4ll3z4", "previewfilepath": "https://soundcloud.com/dog-lick/5050-on-my-tombstone", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dog-lick/5050-on-my-tombstone", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdl3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[717, 717, 766, 766, 891], [893, 893, 942, 942, 1066], [1068, 1068, 1127, 1127, 1314], [1316, 1316, 1346, 1346, 1502], [1504, 1504, 1528, 1528, 1592], [1594, 1594, 1618, 1618, 1688], [1690, 1690, 1714, 1714, 1784], [1786, 1786, 1809, 1809, 1858], [1860, 1860, 1883, 1883, 1936], [1938, 1938, 1969, 1969, 2019], [2021, 2021, 2048, 2048, 2285], [2287, 2287, 2349, 2349, 3614], [3625, 3625, 3666, 3716, 5013], [5015, 5015, 5072, 5072, 6259]], "test": "error"}
{"id": "tdlGR4", "name": "Terrain experiment", "author": "yasuo", "description": "It's ok for right now.", "tags": ["terrain"], "likes": 7, "viewed": 389, "published": "Public API", "date": "1545237191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nmat3 matRotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nmat3 matRotateY(float rad)\n{\n    return mat3(cos(rad), 0, -sin(rad),\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\tsin(rad), 0, cos(rad));\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 map(vec3 p){\n    float speed = iTime*3.0;\n    p.z += speed;\n\tvec2 currentP = p.xz;\n    vec2 prevP = p.xz;\n    \n\t// heightmap thing\n    currentP.y += speed;\n    float n = cnoise(currentP);\n    \n    prevP.y = 0.0;\n    float l = length(prevP);\n    float lSize = 0.9;\n    vec3 c = n-(vec3(lSize, lSize, lSize)-vec3(l,l,l));\n    \n    float height = (sin(p.x*0.5)+sin(p.z*0.5))*c.y*0.2;\n    float floorD = p.y+3.0+height;\n    vec3 col = vec3(0.1,0.2,0.05)*(1.5-matRotateY(c.y*1.0)*c.y*0.15);\n    col += vec3(0.0,0.1,0.0);\n    return vec4(col,floorD);\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    //mat3 camRotY = matRotateY(-(iTime*30.0)*degToRad)*matRotateX(20.*degToRad);\n\tmat3 camRotY = matRotateX(20.0*degToRad);\n    \n\tvec3 ro=vec3(0.,-.1,-8.);\n    vec3 rd=normalize(vec3(p,1.8));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 60; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>30.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 30.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(1.35,1.35,1.35)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 151, 170, 170, 206], [207, 207, 228, 228, 265], [267, 267, 288, 288, 1365], [1367, 1367, 1395, 1395, 1512], [1514, 1514, 1542, 1542, 1627], [1629, 1629, 1665, 1665, 1724], [1726, 1726, 1743, 1743, 2277], [2279, 2279, 2302, 2302, 2552], [2554, 2554, 2588, 2588, 2838], [2840, 2840, 2896, 2896, 4142]], "test": "ok"}
{"id": "tdlGRH", "name": "try fbm noise 01", "author": "cailuming", "description": "try some fbm noise ", "tags": ["noise", "fbm"], "likes": 9, "viewed": 264, "published": "Public", "date": "1545064429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592657\n\nmat2 rot2D(float a){\n   float c =cos(a);\n   float s = sin(a);\n   \n   return mat2(c,s,-s,c); \n}\n\nvec3 getColor(float v){\n   float r = cos((v-0.78)*PI);\n   float g = cos((v-0.52)*PI);\n   float b = cos((v-0.20)*PI);\n   \n   return vec3(r,g,b);\n}\n\nvec2 hash2(vec2 uv){\n   float drive = 1.0+iTime*0.2*PI; \n   float r = fract(sin(dot(uv,vec2(3.7345236,PI))*PI*128493.0)); \n   float r1 = fract(sin(dot(uv,vec2(r,PI))*PI*14327.0)); \n   \n   return vec2(r,r1)*rot2D(drive);\n}\n\nfloat noise2D(vec2 uv){\n   vec2 p = floor(uv);\n   vec2 f = fract(uv);\n   vec2 e = vec2(1,0);\n   vec2 p00 = p;\n   vec2 p10 = p+e;\n   vec2 p11 = p+e.xx;\n   vec2 p01 = p+e.yx;\n   float v00 = dot(f-e.yy,hash2(p00));\n   float v10 = dot(f-e.xy,hash2(p10));\n   float v11 = dot(f-e.xx,hash2(p11));\n   float v01 = dot(f-e.yx,hash2(p01));\n    \n   f = f*f*f*(f*(f*6.-15.)+10.); \n   \n   return mix(mix(v00,v10,f.x),mix(v01,v11,f.x),f.y);\n}\n\nfloat fbm(vec2 uv){\n    float freq = 0.2;\n    float ampli = 3.0;\n    float ret   = 0.5;\n    for (int i=0;i<8;i++){\n       ret+= noise2D(uv*freq)*ampli;\n       //0.3425617\n       uv +=vec2(ret,ret);\n       //freq*=ret;\n       freq*=2.0;\n       ampli*=0.45;\n    }\n    return ret;\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-vec2(0.5);\n    float as =  iResolution.x/iResolution.y;\n    uv.x*=as;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    float a = atan(uv.y,uv.x);\n    uv *= 2.;\n    float v = fbm(uv*2.);\n    col = getColor(v*0.45);\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(0.8));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 44, 44, 118], [120, 120, 143, 143, 265], [267, 267, 287, 287, 488], [490, 490, 513, 513, 917], [919, 919, 938, 938, 1198], [1202, 1202, 1259, 1309, 1699]], "test": "ok"}
{"id": "tds3R7", "name": "Anothererer Mandelbrot", "author": "HyPeRbLaH", "description": "A mandelbrot which uses the average orbit position as a normal.", "tags": ["mandelbrot"], "likes": 1, "viewed": 72, "published": "Public", "date": "1545545523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float steps = 92.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 2.0/iResolution.y;\n    vec2 res = iResolution.xy * scale;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * scale * 4.0 - 2.0 * res)/(/*(sin(iTime * 0.35) * 5.0 + 7.0) * */res.y * 50.0);\n    // x = r*cos(theta)+0.25, y = r*sin(theta)\n    float theta = iTime * 0.125;\n    //float r = (1.0 - cos(theta))/2.0;\n    //uv += vec2(r*cos(theta)+0.25, r*sin(theta));\n    \n    // r = 0.25, x = r*cos(theta)-1, y = r*sin(theta)\n    float r = 0.25;\n    uv += vec2(r*cos(theta)-1.0,r*sin(theta));\n    \n    theta *= 3.14;\n    vec3 ld1 = normalize(vec3(cos(theta), sin(theta), 0.75));\n    theta += 3.14;\n    vec3 ld2 = normalize(vec3(cos(theta), sin(theta), 0.75));\n\n    vec2 z = vec2(0.0);\n    vec3 nrm = vec3(0.0);\n    \n    float i = 0.0;\n    for (; i < steps; ++i) {\n        //z += uv;\n    \tz = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n        z += uv;\n        \n        if (z.x * z.x + z.y * z.y > 4.0) {\n            break;\n        }\n        \n        nrm += vec3(z.xy, 0.0);\n    }\n    nrm /= i;//i * 2.0;\n    float mag = length(nrm.xy);\n    if (mag > 1.0) {\n        nrm = vec3(nrm.xy / mag, 0.0);\n    } else {\n        float m = 1.0 - nrm.x * nrm.x - nrm.y * nrm.y;\n        nrm.z = m;\n    }\n    //nrm = nrm * 0.5 + 0.5;\n    float l1 = dot(nrm, ld1) * 0.5 + 0.5;\n    l1 = l1*l1*l1 + 0.1;\n    float l2 = dot(nrm, ld2) * 0.5 + 0.5;\n    l2 = l2*l2*l2 + 0.1;\n    \n    //nrm = nrm * 0.5 + 0.5;\n\n    // Output to screen\n    fragColor = vec4(l1, abs(l1 - l2), l2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tds3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 1585]], "test": "ok"}
{"id": "tdsGR8", "name": "Abstract Veins", "author": "Alkama", "description": "Couldn't be simpler :D", "tags": ["2d", "abstract", "bw"], "likes": 12, "viewed": 495, "published": "Public API", "date": "1544990777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)/vec2(iResolution.y/iResolution.x, 1);\n    \n    vec2 pa = uv + .1*vec2(sin(sin(t)*2.),cos(sin(t*.8)+t));\n  \tvec2 pb = uv + .6*vec2(sin(t*.9),cos(sin(t*.2)*2.9));\n  \tfloat d = fract(length(pa)*10.) * 5.*fract(length(pb)*2.);\n  \n    d = fract(d);\n  \tfloat w = .7+.2*sin(t*2.);\n    float a = 0.1;\n    float c = (smoothstep(1.-a-w,1.-w,d) - smoothstep(w,w+a,d));\n        \n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 525]], "test": "ok"}
{"id": "tdsGRM", "name": "DVD corner thingy", "author": "Klems", "description": "Greetings to everyone who make that thing via a simulation. Completely stateless and resolution independent. Count the number of corner hits and bounce. Click on the screen to change box size.", "tags": ["2d"], "likes": 5, "viewed": 558, "published": "Public API", "date": "1545519533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 hue( in float c ) {\n    return cos(2.0*PI*c + 2.0*PI/3.0*vec3(3,2,1))*0.5+0.5;\n}\n\nint lcm( in int K, in int M ) {\n    int k = max(K, M);\n    int m = min(K, M);\n    while (m != 0) {\n        int r = k % m;\n        k = m;\n        m = r;\n    }\n    return K * M / k;\n}\n\n// Thanks P_Malin, see https://www.shadertoy.com/view/4sf3RN\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\nfloat InRect( const in vec2 vUV, const in vec4 vRect ) {\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\nfloat SampleDigit( const in float fDigit, const in vec2 vUV ) {\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\tif(fDigit < 0.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y1, x2, y4);\n\t} else if(fDigit < 1.5) {\n\t\tvRect0 = vec4(x1, y0, x2, y5); \n        vRect1 = vec4(x0, y0, x0, y0);\n\t} else if(fDigit < 2.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y3, x2, y4); \n        vRect2 = vec4(x1, y1, x3, y2);\n\t} else if(fDigit < 3.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y3, x2, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 4.5) {\n\t\tvRect0 = vec4(x0, y1, x2, y5); \n        vRect1 = vec4(x1, y2, x2, y5); \n        vRect2 = vec4(x2, y0, x3, y3);\n\t} else if(fDigit < 5.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x3, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 6.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x3, y4); \n        vRect2 = vec4(x1, y1, x2, y2);\n\t} else if(fDigit < 7.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y0, x2, y4);\n\t} else if(fDigit < 8.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y1, x2, y2); \n        vRect2 = vec4(x1, y3, x2, y4);\n\t} else if(fDigit < 9.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x2, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 10.5) {\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t} else if(fDigit < 11.5) {\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\tfloat fResult = InRect(vUV, vRect0) + \n        InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\treturn mod(fResult, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // time multiplier\n    const float mul = 100.0;\n    // size of the box and size of the world\n    ivec2 iboxWidth = max(ivec2(iMouse.xy), ivec2(45, 30));\n    ivec2 iperiod = ivec2(iResolution.xy) - iboxWidth*2;\n    \n    // figure out where the box is\n    vec2 boxWidth = vec2(iboxWidth);\n    vec2 temp = vec2(iperiod);\n    vec2 center = abs(fract(iTime/temp*mul)*2.0-1.0) * temp + boxWidth;\n    \n    // hue shift the box with each bounce\n    vec2 tt = floor(iTime/temp*mul*2.0);\n    vec3 h = hue((tt.x+tt.y)*0.2);\n    \n    // figure out when we reach a corner\n    float period = float(lcm(iperiod.x, iperiod.y)) / mul * 0.5;\n    float corner = floor(iTime/period);\n    \n    // get to the box\n    vec2 uv = fragCoord-center;\n    vec2 d = abs(uv) - boxWidth;\n    float de = max(d.x, d.y);\n    \n    // colorize\n    float digits = SampleDigit(mod(corner, 10.0),\n                               uv / boxWidth.y + vec2(0.38, 0.5));\n    h = mix(h, vec3(1), digits);\n    vec3 col = vec3(0);\n    col = mix(col, h, smoothstep(0.5, -0.5, de));\n    fragColor.rgb = col;\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 50, 50, 111], [113, 113, 144, 144, 294], [2642, 2642, 2699, 2727, 3789]], "test": "error"}
{"id": "tdsGzM", "name": "Daybreak Visualizer", "author": "alyd", "description": "My first audio visualizer! The sunrise background I made myself, and the audio part was heavily modified from https://www.shadertoy.com/view/XdcXRs\n\nIf the music doesn't load, pause and play a couple times", "tags": ["waves", "sound", "sunset", "music", "beginner", "audio", "visualizer", "sunrise"], "likes": 4, "viewed": 182, "published": "Public", "date": "1545515930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//for the sky colours:\n#define speed 0.6\n#define red_base 0.05\n#define green_base 0.1\n#define light_base 0.8\n//for the audio bars:\n#define num_bars 200.\n#define bar_spacing .2\n#define opacity .3\n#define bar_height 0.02\n#define amplitude_factor 2.\n//zooms in on the highest 1/x frequencies:\n#define hifreqfocus 2. \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    \n    //SOUND\n    //dividing my 2.0 \n    float freq_bin = floor(num_bars*st.x/hifreqfocus)/num_bars; //which frequency bin this x-coord falls into \n    float sound = texture(iChannel0,vec2(freq_bin,0)).r; //get the sound amplitude at this bin.\n    float time = iTime + sound*amplitude_factor; //jump the \"time\" forward at this bin\n    //if (st.x*num_bars-floor (st.x*num_bars)<bar_spacing)sound = 0.; //ensure gaps between bars\n    \n    //SUNRISE COLOURS\n    float dfb = 0.2+sin(time*speed); //distance of green and alpha from bottom of screen\n    float red_dft = 0.6 - sin(time*speed); //distance of red from top of screen\n        //sin(time*speed): intensity uniform across screen but varies with time\n        //cos or sin(st.y+...): area where colour is most intense moves up and down the screen\n    float red = red_base - 0.3*sin(time*speed) + cos(st.y+red_dft);\n    float green = green_base + 0.4*sin(time*speed) + 0.4*sin(st.y+dfb);\n    float blue = 0.7*sin(st.y) + 0.9*abs(sin(time*speed));\n    float alpha = light_base + 0.4*sin(st.y+dfb);\n    \n    //Adding the white bars to the screen:\n    vec4 color = vec4(red,green,blue,alpha);\n    if ((0.,st.y)< sound*sound*sound) { //&& (0.,st.y) > (sound*sound*sound-bar_height)) {\n        color = mix(color, vec4(1),opacity); \n    }\n    //add the floating squares:\n    if ((0.,st.y)< sound*sound*sound && (0.,st.y) > (sound*sound*sound-bar_height)) {\n        color = mix(color, vec4(1),0.); \n    }\n    //Final output:\n     fragColor = color;\n\n}", "image_inputs": [{"id": "Xll3RN", "previewfilepath": "https://soundcloud.com/monstercat/rogue-daybreak-free-download", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/monstercat/rogue-daybreak-free-download", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 372, 372, 1911]], "test": "error"}
{"id": "tdX3RM", "name": "the line", "author": "numa08", "description": "the line", "tags": ["line"], "likes": 0, "viewed": 40, "published": "Public", "date": "1545382110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float radius = 80.0;\n\nvec2 Center()\n{\n    float x = (sin(iTime) + 1.) / 2.;\n    return vec2(x, 0.5);\n}\n\nfloat Spiral(vec2 fragCoord, vec2 center)\n{\n    if (true)\n    {\n        \n        float angle = center.y / center.x;\n        float offset = 0.;\n        if(fragCoord.x < center.x)\n        {\n            if(fragCoord.y < center.y)\n            {\n                offset = 0.;\n            }\n            else\n            {\n                angle *= -1.;\n                offset = center.y * 2.;\n            }\n        }\n        else\n        {\n            angle = (center.y * 2. - center.y)/(center.x * 2. - center.x);\n            if(fragCoord.y < center.y)\n            {\n                angle *= -1.;\n                offset = 0.;\n            }\n            else\n            {\n                offset = 0.;\n            }\n        }\n        float diff = angle * fragCoord.x + offset - fragCoord.y;\n        if (diff > 0. && diff < 1.)\n        {\n            return 1.;\n        }\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 center = Center() * iResolution.xy;\n\n    if (distance(fragCoord, center) < radius) \n    {\n        fragColor = texture(iChannel0, uv);\n    }\n    else\n    {\n\t\tvec4 white = vec4(1, 1, 1, 1);\n\t\tvec4 col  = vec4(0, 0, 0, 0);\n        col += Spiral(fragCoord, center) * white;\n\t\tfragColor = col;\n    }\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4tsGRN", "previewfilepath": "https://soundcloud.com/djshimamura/thankyou-birthday-dj-shimamura-hardcore-rave-remix", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/djshimamura/thankyou-birthday-dj-shimamura-hardcore-rave-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdX3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 43, 43, 108], [110, 110, 153, 153, 993], [995, 995, 1052, 1052, 1400]], "test": "error"}
{"id": "tdXGRn", "name": "Bouncy Sphere", "author": "josemorval", "description": "Another experiment. A bouncy sphere.", "tags": ["raymarching", "tutorial", "shadow", "light", "sphere", "bouncy"], "likes": 2, "viewed": 347, "published": "Public API", "date": "1544698753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time;\n\n//Distance to a sphere\nfloat sphere(vec3 p,float r){\n\treturn length(p)-r;    \n}\n\nvec2 scene(vec3 p){\n    float sr = 1.;\n    vec3 bouncep = vec3(0.);\n    \n    /* Spawn many spheres for 'free'\n    float index = 5.*floor(p.z/5.+0.5);\n    sr = 1.+0.3*sin(234.12*index);\n    p.z = p.z-0.5-index;\n\t*/\n\t\n    //Bouncy ball\n    float pt = 10.*time/3.14159;\n    \n    //Here the height on the jump\n    float h = mod(pt/10.,1.);\n    h=sqrt(h);\n    h=1.-h;\n    bouncep = 5.*h*abs(sin(10.*time))*vec3(0.,-1.,0.);\n    \n    //Here the move on the x axis\n    bouncep+=vec3(10.-3.*mod(pt,10.),0.,0.);\n    bouncep-=vec3(-mix(0.,5.5,pow(mod(pt,10.)/7.,2.)),0.,0.);\n\tvec2 res = vec2(sphere(p+vec3(0.,-sr,0.)+bouncep,sr),1.);\n    \n    //Use a large sphere as a plane\n    float r =100.;\n    vec2 a = vec2(sphere(p+vec3(0.,r,0.),r),2.);\n    \n    //Check what see the camera first: the bouncy ball or the plane\n    if(a.x<res.x) res = a;\n    \n    return res;\n}\n\n//Ray to the world\nvec2 raycast(vec3 p,vec3 d){\t\n    vec2 res = vec2(0.,-1.);\n    for(int i=0;i<64;i++){\n    \tvec2 f = scene(p);\n        if(f.x<0.001*res.x){\n            res.y = f.y;\n        \tbreak;   \n        }\n        p+=f.x*d;\n        res.x += f.x;\n    }   \n    \n    return res;   \n}\n\n//Compute normal (sampling some delta points)\nvec3 normal(vec3 p) \n{\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(scene(p+h.xyy).x - scene(p-h.xyy).x,\n                           scene(p+h.yxy).x - scene(p-h.yxy).x,\n                           scene(p+h.yyx).x - scene(p-h.yyx).x));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv-0.5;\n    p.x*=iResolution.x/iResolution.y;\n\ttime = 0.7*iTime;\n    \n    vec3 col = vec3(0.);\n\t\n    //Camera\n    //---------//\n   \tvec3 po = 2.*vec3(0.,5.,-10.);\n    vec3 ta = vec3(0.,0.,0.);\n    \n    vec3 di = normalize(ta-po);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 ri = -cross(di,up);\n    up = -cross(ri,di);\n    \n    float fov = 3.;\n    di = normalize(p.x*ri+p.y*up+fov*di);\n\tpo += p.x*ri+p.y*up;\n    //---------//\n    \n    //Throw a ray to the world (direction depends on the pixel of the camera)\n    vec2 res = raycast(po,di);\n    \n    if(res.y>0.){\n        \n        //Moving light\n        vec3 lightdir = normalize(vec3(cos(time),0.5+0.05*sin(time),-0.7+0.05*sin(3.*time)));\n        \n        po+=res.x*di;\n        //Throw a ray from hit position on the world to the light\n        //if hit another surface, then we are in shadow\n        float s = raycast(po+0.01*normal(po),lightdir).y>0.?1.:0.;\n        \n        //Ambient light\n        col = 0.1*vec3(0.3,0.3,0.5);\n        \n       \tif(res.y<1.5){\n            //Color bouncy ball (diffuse)\n    \t\tcol += 1.5*vec3(0.3,0.3,0.5)*clamp(dot(normal(po),lightdir),0.,1.);  \n            //Add shadow\n            col *= (1.-0.5*s);\n        }else if(res.y<2.5){\n            //Color plane (diffuse)\n            col += 1.5*vec3(0.6,0.3,0.5)*clamp(dot(normal(po),lightdir),0.,1.);\n            //Add shadow\n            col *= (1.-0.5*s);\n        }     \n    }\n\t\n    //Playing with gamma correction\n    col.x = pow(col.x,1.5+0.2*sin(time));\n    col.y = pow(col.y,1.3+0.1*sin(1.5*time+0.3));\n    col.z = pow(col.z,1.+0.1*sin(1.5*time+0.3));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 36, 65, 65, 92], [94, 94, 113, 113, 948], [950, 969, 997, 997, 1236], [1238, 1284, 1306, 1306, 1563], [1569, 1569, 1626, 1626, 3293]], "test": "ok"}
{"id": "tsf3zH", "name": "twisting rose", "author": "morisil", "description": "Still exploring polar coordinates", "tags": ["procedural", "spiral", "illusion", "glitch", "hypnotic", "polar"], "likes": 3, "viewed": 408, "published": "Public API", "date": "1544918889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 1.0\n\n#define RAYS 30.0\n\n#define RING_PERIOD 80.0\n\n#define TWIST_FACTOR 2.0\n\nfloat getColorComponent(float dist, float angle) {\n    return\n        (\n            (\n            \tcos(\n                    (angle * RAYS)\n            \t\t+ pow(\n                        dist * 2.0,\n                \t\t(sin(iTime * SPEED) * TWIST_FACTOR)\n            \t\t) * 20.0\n        \t\t) + sin(\n            \t\tdist * RING_PERIOD\n        \t\t)\n        \t) + 2.0\n        ) / 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 delta = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(delta),\n    angle = atan(delta.x, delta.y);\n    fragColor = vec4(\n        getColorComponent(dist, angle),\n        0,\n        getColorComponent(dist * 1.02, angle),\n        1.0\n    );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsf3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 140, 140, 462], [464, 464, 519, 519, 795]], "test": "ok"}
{"id": "tsfGzH", "name": "hypnotic spiral 2", "author": "morisil", "description": "Follow up of the \"hallucinatory spiral 1\". This time ratio of light and dark is balanced and it seems to work better with higher speed.", "tags": ["procedural", "spiral", "illusion", "hypnotic", "polar"], "likes": 1, "viewed": 346, "published": "Public API", "date": "1544911745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// adjust this factor for stronger optical illusion\n#define SCALE 80.0\n// rotation speed, might be negative to spin counter-clockwise\n#define SPEED 5.0\n\nfloat getColorComponent(float dist, float angle, float scaleIncrement) {\n    return (sin(dist * (SCALE + scaleIncrement) + angle - (iTime * SPEED)) + 1.0) / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 delta = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(delta),\n    angle = atan(delta.x, delta.y);\n    fragColor = vec4(\n        getColorComponent(dist, angle, 0.0),\n        getColorComponent(dist, angle, 1.0),\n        getColorComponent(dist, angle, 2.0),\n        1.0\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 225, 225, 316], [318, 318, 373, 373, 686]], "test": "ok"}
{"id": "tsfGzM", "name": "Temporal chromab", "author": "mensab", "description": "Attempt at replicating the motion blur / chromatic abberation effect in Quite's demo Utul (https://www.youtube.com/watch?v=rP0adYqrVIU). Applied it to a simple raymarched cube that does some flying around. Probably needs some more work.", "tags": ["3d", "raymarching", "motionblur", "effect", "chromaticabberation"], "likes": 11, "viewed": 289, "published": "Public", "date": "1545406291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MIN_DIST .2\n#define MAX_DIST 20.\n#define MAX_MARCHING_STEPS 100\n#define EPS .001\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat scene(vec3 p, float t) {\n    //  rotate + bob around\n    p += vec3(cos(2. * t), sin(.5 * t), sin(t));\n    float theta = .9 * t;\n    mat4 rot = mat4(cos(theta), 0., sin(theta), 0.,\n                    0., 1., 0., 0.,\n                    -sin(theta), 0., cos(theta), 0.,\n                    0., 0., 0., 1.);\n    p = vec3(rot * vec4(p, 0.));\n    \n    return box(p, vec3(.5));\n}\n\n//  simple raymarcher\nfloat raymarch(vec3 cam_pos, vec3 march_dir, float t) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(cam_pos + depth * march_dir, t);\n        if (dist < EPS) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 cam_dir(float fov, vec2 uv) {\n    vec2 xy = (uv * iResolution.xy) - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//  image to apply effect on\nvec3 render(vec2 uv, float t) {\n    vec3 pos = vec3(0., 0., 3.);\n    vec3 dir = cam_dir(90., uv);\n    float dist = raymarch(pos, dir, t);\n    \n    float v = 1. - (dist / MAX_DIST);\n    return vec3(ceil(v));\n}\n\n//  apply effect\nvec3 render_iter(vec2 uv, float t)\n{\n    //  params\n    float iters = 10.;\n    float dt = .005;\n    \n    vec3 acc = vec3(0.);\n    for (float i = 0.; i < iters; i++) {\n        //  offset render time for each color channel\n        acc.r += render(uv, t + i * dt).r;\n        acc.g += render(uv, t + 2. * i * dt).g;\n        acc.b += render(uv, t + 3. * i * dt).b;\n    }\n\treturn acc / iters;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(render_iter(uv, iTime), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 117, 117, 206], [208, 208, 238, 266, 588], [590, 612, 667, 667, 992], [994, 994, 1028, 1028, 1181], [1183, 1212, 1243, 1243, 1420], [1422, 1439, 1475, 1490, 1827], [1829, 1829, 1883, 1883, 1977]], "test": "ok"}
{"id": "tsl3W8", "name": "HelloWorld777", "author": "yashpixster", "description": "My first shader file.", "tags": ["firstshader"], "likes": 0, "viewed": 47, "published": "Public", "date": "1546077463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsl3W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "ok"}
{"id": "tslGz8", "name": "lorn_a/d", "author": "icalvin102", "description": "inspired by lorn a/d cover art", "tags": ["polar"], "likes": 8, "viewed": 144, "published": "Public", "date": "1545013342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SCALE 20.0\n\n\nmat2 rotate2d(float angle){\n\tfloat s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nvec2 polar(vec2 uv){\n\treturn vec2(atan(uv.x, uv.y), length(uv));\n}\n\nfloat randomDither(float v, vec2 uv){\n\tfloat r = fract(sin(dot(uv, vec2(8293.8214, 5812.8372))) * 1242.10);\n\treturn step(r, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    float t = iTime * .05;\n    vec2 p = polar(uv);\n    float l = sin(p.x+t)*.5+.7;\n    \n    p.x *= 6./ ( sqrt(2.) * PI*2. );\n    if(p.y > .7){\n    \tp.y -= .7;\n        t = -t;\n    }\n\tp.y = (log2(p.y) * .1) - t;\n    p *= rotate2d(PI/4.0);\n\n    \n    vec2 fp = fract(p * SCALE) - .5;\n    \n    vec2 rp = fp * rotate2d(-PI/4.0);\n    \n    float c = fract(rp.x) * (rp.y + .3) * l;\n    c = mix(randomDither(c, fragCoord), c, .9);\n    \n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 73, 73, 159], [161, 161, 181, 181, 227], [229, 229, 266, 266, 358], [360, 360, 417, 417, 942]], "test": "ok"}
{"id": "tss3R8", "name": "spooky", "author": "Del", "description": "spooky", "tags": ["raymarch", "sdf", "wibble"], "likes": 8, "viewed": 386, "published": "Public API", "date": "1545001111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarch anything #4 (spooky)\n\n#define\tTAU 6.28318\nfloat objID = 0.0;\nfloat svobjID = 0.0;\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\nfloat line( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h )-0.3;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\t\n\n\n\nvec2 opUnionRound(const in vec2 a, const in vec2 b, const in float r)\n{\n    vec2 res = vec2(smin(a.x,b.x,r),(a.x<b.x) ? a.y : b.y);\n    return res;\n}\n\n    \n// model\nfloat K(vec2 p,float d){d=min(d,line(p,vec2(1,-8),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-5),vec2(2.5,-5)));d=min(d,line(p,vec2(5,-1.5),vec2(2.5,-5)));d=min(d,line(p,vec2(2.5,-5),vec2(5,-8)));return d;}\nfloat O(vec2 p,float d){d=min(d,line(p,vec2(5,-1.5),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(1,-8)));d=min(d,line(p,vec2(1,-8),vec2(5,-8)));d=min(d,line(p,vec2(5,-8),vec2(5,-1.5)));return d;}\nfloat P(vec2 p,float d){d=min(d,line(p,vec2(1,-8),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(5,-1.5)));d=min(d,line(p,vec2(5,-1.5),vec2(5,-5)));d=min(d,line(p,vec2(5,-5),vec2(1,-5)));return d;}\nfloat S(vec2 p,float d){d=min(d,line(p,vec2(5,-1.5),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(1,-5)));d=min(d,line(p,vec2(1,-5),vec2(5,-5)));d=min(d,line(p,vec2(5,-5),vec2(5,-8)));d=min(d,line(p,vec2(5,-8),vec2(1,-8)));return d;}\nfloat Y(vec2 p,float d){d=min(d,line(p,vec2(1,-1.5),vec2(3,-5)));d=min(d,line(p,vec2(3,-5),vec2(3,-8)));d=min(d,line(p,vec2(3,-5),vec2(5,-1.5)));return d;}\n\nfloat message(vec3 p)\n{\n\tfloat d = 200.0;\n    float cw = 5.8;\n    float gap = (cw*2.0)+40.0;\n    float width = (9.0*cw);\n    float xmod = width+gap;\n    \n\tfloat c = pMod1(p.z,28.0);\n    \n    if (p.z > 10.0 || p.z < -10.0)\n        return d;\n    \n\tp.x += fract(iTime*0.125)*xmod+c*20.0;\n    pMod1(p.x, xmod);\n\t\n\t\n\tvec2 uv = p.xy;\n\tfloat x = -((width*0.5+gap*0.5)-cw);\n\tfloat t1 = fract(iTime*0.7) * TAU;\n\n\tfloat y = sin(t1+p.x*0.25)*0.7;\n\ty-=2.0;\n\tuv-=vec2(x,y);\n\t\n\td = S(uv,d); uv.x -= cw;\n\td = P(uv,d); uv.x -= cw;\n\td = O(uv,d); uv.x -= cw;\n\td = O(uv,d); uv.x -= cw;\n\td = K(uv,d); uv.x -= cw;\n\td = Y(uv,d);\n\n\tif (d<200.0)\n\t{\n\t\t// extrude\n\t\tfloat dep = 0.3;\n\t\tvec2 e = vec2( d, abs(p.z) - dep );\n\t\td = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n\t\td -= 0.425;\t\t// rounding\n\t}\n    \n\treturn d;\n}\n\nfloat map(vec3 p)\n{\n    float time = iTime;\n    float modz = mod(time*6.75, 44.0);\n    float t2 = fract(time*1.1) * TAU;\n    float t3 = fract(time*0.7) * TAU;\n    float t4 = fract(time*0.14)* TAU;\n\n    p.xy *= rotate(p.z * 0.08 + t4);\n    \n    float m = 0.5+sin(t2+p.z*0.4)*0.5;\n    m += 0.5+cos(p.z*0.4+t3+p.x*0.4)*0.5;\n    \n\tp.z += modz;\n    pMod1(p.z,44.0);\n    \n    \n\tfloat dist = 9.0 -abs(p.y)+m;\n    \n    vec3 p2 = p;\n\tfloat cz = pMod1(p2.z,4.0);\n\tfloat cx = pMod1(p2.x,4.0);\n\n    float d4 = message(p);\n    dist = smin(dist,d4,1.1);\n    \n\n    objID = abs(p.z)/44.0;\n    return dist;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\nvec3 render(vec2 uv)\n{\n    float time = iTime;\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 80; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += .5 * d;\n\t}\n    \n    svobjID = objID;\n\tvec3 l = ro+vec3(0.0,0.0,15.0);\n\tvec3 n = normal(p);\n\tvec3 lp = normalize(l - p);\n\tfloat diff = 1.2 * max(dot(lp, n), 0.);\n    \n    vec3 c1 = vec3(2.54,2.84,2.54);\n    vec3 c2 = vec3(2.84,1.16,1.05);\n\treturn vec3(0.1)+mix(c1,c2,svobjID) * diff / (1. + t * t * .01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\t// vignette\n    col *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tss3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 135, 135, 256], [258, 258, 315, 315, 410], [412, 412, 447, 447, 473], [475, 475, 516, 516, 605], [607, 607, 629, 629, 696], [699, 699, 737, 737, 851], [853, 853, 884, 884, 975], [1136, 1145, 1169, 1169, 1345], [1346, 1346, 1370, 1370, 1544], [1545, 1545, 1569, 1569, 1743], [1744, 1744, 1768, 1768, 1979], [1980, 1980, 2004, 2004, 2135], [2137, 2137, 2160, 2160, 2929], [2931, 2931, 2950, 2950, 3522], [3525, 3597, 3623, 3738, 3934], [3935, 3935, 3957, 3957, 4510], [4512, 4512, 4569, 4569, 4809]], "test": "error"}
{"id": "tssGW8", "name": "Wind Experiment", "author": "yasuo", "description": "Try to express wind.", "tags": ["wind"], "likes": 5, "viewed": 417, "published": "Public API", "date": "1546075233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nmat3 matRotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nmat3 matRotateY(float rad)\n{\n    return mat3(cos(rad), 0, -sin(rad),\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\tsin(rad), 0, cos(rad));\n}\n\nvec4 map(vec3 p){\n    float speed = iTime*15.0;\n    p.z += speed;\n    \n    float animSpeed = iTime*5.0;\n    \n    float n = floor(p.x/10.0);\n    p.z = mod(p.z,15.0)-7.5;\n    p.y = mod(p.y,6.0)-3.0;\n    p.x = mod(p.x,6.0)-3.0;\n    p.z += fract(noise(floor(p.z/10.0)*1.3))*sin(p.z+animSpeed)*0.2;\n    p.y += fract(noise(n)*2.3)*sin(p.z+animSpeed)*0.3;\n\tp.x += fract(noise(n)*1.5-0.5)*cos(p.z+animSpeed)*0.5;\n    p.y += noise(n)*0.1;\n    p.z += noise(n)*0.2;\n    \n    // This is based on the Capsule Distance function from the IQ's, and it's modified.\n    p += vec3(0.0,0.0,1.0);\n    p.z -= clamp( p.z, 0.0, 8.0 );\n    p.y += sin(n*iTime)*1.2;\n    float pt = length( p ) - 0.05+sin(n*iTime*p.z)*0.02;\n    \n    return vec4(vec3(1.98,1.98,1.98),pt);\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    //mat3 camRotY = matRotateY(-(iTime*30.0)*degToRad)*matRotateX(20.*degToRad);\n\tmat3 camRotY = matRotateX(20.0*degToRad);\n    \n\tvec3 ro=vec3(0.,-.1,-8.);\n    vec3 rd=normalize(vec3(p,1.8));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 60; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>30.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t);\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 30.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(1.1,1.31,1.35)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssGW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 84, 84, 158], [160, 160, 188, 188, 305], [307, 307, 335, 335, 420], [422, 422, 439, 439, 1167], [1169, 1169, 1192, 1192, 1442], [1444, 1444, 1478, 1478, 1728], [1730, 1730, 1786, 1786, 3023]], "test": "timeout"}
{"id": "tssGWH", "name": "twisting color rose", "author": "morisil", "description": "variation of \"twisting rose\"", "tags": ["procedural", "spiral", "illusion", "glitch", "hypnotic", "polar", "colordistortion"], "likes": 11, "viewed": 1463, "published": "Public API", "date": "1546105902", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 1.0\n\n#define RAYS 10.0\n\n#define RING_PERIOD 80.0\n\n#define TWIST_FACTOR 2.0\n\nfloat getColorComponent(float dist, float angle) {\n    return\n        pow((\n            (\n            \tcos(\n                    (angle * RAYS)\n            \t\t+ pow(\n                        dist * 2.0,\n                \t\t(sin(iTime * SPEED) * TWIST_FACTOR)\n            \t\t) * 20.0\n        \t\t) + sin(\n            \t\tdist * RING_PERIOD\n        \t\t)\n        \t) + 2.0\n        ) / 2.0, 10.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 delta = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(delta),\n    angle = atan(delta.x, delta.y);\n    fragColor = vec4(\n        getColorComponent(dist, angle),\n        getColorComponent(dist * 1.03, angle),        \n        getColorComponent(dist * 1.06, angle),\n        1.0\n    );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 140, 140, 473], [475, 475, 530, 530, 850]], "test": "ok"}
{"id": "tsXGz4", "name": "Cheap grass", "author": "dalerank", "description": "cheap grass procedural texture", "tags": ["procedural", "texture", "grass"], "likes": 4, "viewed": 540, "published": "Public API", "date": "1545129187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLADES 6\n#define BLADE_SEED 1.0\n\nvec4 grass(vec2 p, float x)\n{\n\tfloat s = 0.8;//mix(0.7, 2.0, 0.5 + sin(x * 12.0) * 0.5);\n\tp.x += pow(1.0 + p.y, 2.0) * 0.1 * cos(x + iTime*0.1);\n\tp.x *= s;\n\tp.y = (1.0 + p.y) * s - 1.0;\n\tfloat m = 1.0 - smoothstep(0.0, clamp(1.0 - p.y * 1.5, 0.01, 0.6) * 0.2 * s, pow(abs(p.x) * 19.0, 1.5) + p.y - 0.6);\n\treturn vec4(mix(vec3(0.05, 0.1, 0.0) * 0.8, vec3(0.0, 0.3, 0.0), (p.y + 1.0) * 0.5 + abs(p.x)), m * smoothstep(-1.0, -0.9, p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ct = vec3(0.0, 1.0, 5.0);\n\tvec3 cp = vec3(0.0, 0.1, 0.0);\n\tvec3 cw = normalize(cp - ct);\n\tvec3 cu = cross(cw, vec3(0.0, 1.0, 0.0));\n\tvec3 cv = cross(cu, cw);\n\t\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - vec2(1.0);\n\tvec2 t = uv;\n\tt.x *= iResolution.x / iResolution.y;\n\n\t\n\tvec3 ro = cp, rd = vec3(t, -1.1);\n\t\n\tvec3 fcol = vec3(0.0);\n\t\n\tfor(int i = 0; i < BLADES; i++)\n\t{\n\t\tfloat z = -(float(BLADES - i) * 0.1 + 1.0);\n\t\tvec4 pln = vec4(0.0, 0.0, -1.3, z);\n\t    vec2 tc = ro.xy + rd.xy;\n\t\t\n\t\ttc.x += cos(float(i) + BLADE_SEED);\n\t\t\n\t\tfloat cell = floor(tc.x);\n\t\t\n\t\ttc.x = (tc.x - cell) - 0.9;\n\t\t\n\t\tvec4 c = grass(tc, float(i) + cell * 11.0);\n\t\t\n\t\tfcol = mix(fcol, c.rgb, c.w);\n\t}\n\t\n\tfcol = pow(fcol * 1.1, vec3(0.8));\n\n\tfragColor.rgb = fcol * 1.8;\n\tfragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 70, 70, 477]], "test": "ok"}
{"id": "tsXGzN", "name": "Canyon surveyor", "author": "mensab", "description": "Playing around with basic FBM deformation, might artifact on some machines.\n\nThe artifacting itself is neat but I can't seem to reproduce it on higher end machines, unless there's some way in GLSL to screw with floats on bit level that I don't know about.", "tags": ["2d", "noise", "terrain", "parallax"], "likes": 18, "viewed": 298, "published": "Public", "date": "1545158672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OFFSET vec2(cos(iTime * .25) + 2. * sin(.1 * iTime), sin(iTime * .25) + 2. * cos(.167 * iTime))\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(vec2(p.x, p.y), vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n//  smoothed noise\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    float c00 = rand(ip);\n    float c01 = rand(ip + vec2(1., 0.));\n    float c10 = rand(ip + vec2(0., 1.));\n    float c11 = rand(ip + vec2(1.));\n    \n    vec2 fp = fract(p);\n    vec2 uf = smoothstep(vec2(0.), vec2(1.), fp);\n    float r0 = mix(c00, c01, uf.x);\n    float r1 = mix(c10, c11, uf.x);\n    return mix(r0, r1, uf.y);\n}\n\nfloat fbm (vec2 p) {\n    int iters = 10;\n    \n    float value = 0.;\n    float freq = 1.;\n    float amp = .5;\n    \n    float gain = .5;\n    float rescale = 2.;\n    \n    for (int i = 0; i < iters; i++) {\n        value += amp * noise(p * freq);\n        freq *= rescale;\n        amp *= gain;\n    }\n    \n    return value;\n}\n\nfloat terrain(vec2 p) {\n    //  stack+deform FBMs\n    vec2 q = vec2(fbm(p), fbm(p + vec2(.1, -.1)));\n    vec2 r = vec2(fbm(p + 4. * q * vec2(2., 1.)), fbm(p + 4. * q + vec2(-5., -3.)));\n    return fbm(p + 4. * r);\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.2831853 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //  circle around\n    uv += OFFSET;\n\n    //  flatness\n    float z = .2;\n    //  estimate normals\n    vec2 e = 1. / vec2(max(iResolution.x, iResolution.y));\n    float r = terrain(uv + vec2(e.x, 0.));\n    float l = terrain(uv - vec2(e.x, 0.));\n    float b = terrain(uv + vec2(0., e.y));\n    float t = terrain(uv - vec2(0., e.y));\n    vec3 n = normalize(vec3(r - l, t - b, z));\n    \n    //  lighting\n    vec3 ld = normalize(vec3(1.));\n    float i = dot(n, ld);\n    \n    //  terrain color\n    float h = terrain(uv);\n    vec3 c = palette(h, vec3(.9, .6, 1.), vec3(1., .9, .75), vec3(.5), vec3(.57, .53, .4));\n    c = mix(vec3(h), c, h * 1.33);\n    \n    //  clouds (+parallax)\n    float clouds = fbm((uv + vec2(1.)) * 6. + .5 * OFFSET);\n    clouds = clamp(pow(clouds + .2, 10.), 0., 1.);\n    \n    fragColor = vec4(mix(i * c + clouds * .75, vec3(1.), clouds), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 126, 126, 210], [212, 231, 252, 252, 604], [606, 606, 626, 626, 924], [926, 926, 949, 975, 1141], [1143, 1143, 1198, 1198, 1249], [1251, 1251, 1306, 1306, 2260]], "test": "timeout"}
{"id": "Wdf3D8", "name": "endless chessboard", "author": "morisil", "description": "experiments with math behind the perspective, rotation, and the endless chessboard", "tags": ["endless", "loop", "checker", "rotation", "perspective", "double", "chess"], "likes": 3, "viewed": 341, "published": "Public API", "date": "1545934646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 5.0\n\n#define SCENE_ROTATION_SPEED -0.1\n\n#define PLANE_ROTATION_SPEED 0.3\n\n#define EDGE_SHARPNESS 20000.0\n\n#define AIR_PERSPECTIVE 2.0\n\n#define rotate(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat getChessboardLuminance(vec2 point) {\n    float value =\n        (1.0 - pow(sin(point.x), EDGE_SHARPNESS))\n        * sign(cos(point.x));\n    value *=\n        (1.0 - pow(sin(point.y), EDGE_SHARPNESS))\n        * sign(cos(point.y));\n    return (value + 1.0) / 2.0;    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    pixel *= rotate(iTime * SCENE_ROTATION_SPEED);\n    vec2 trans = vec2(pixel.x / pixel.y, 1.0 / pixel.y);\n    trans *= rotate(iTime * PLANE_ROTATION_SPEED);    \n    trans *= SCALE;\n    \n\tfloat luminance = getChessboardLuminance(trans);\n\n    // apply air perspective\n    luminance *= pow(abs(pixel.y * 2.0), AIR_PERSPECTIVE);\n    fragColor = vec4(vec3(luminance),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdf3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 245, 245, 474], [476, 476, 531, 531, 970]], "test": "ok"}
{"id": "wdf3WH", "name": "3d shader easy", "author": "MichalK123", "description": "Poruszajcy si shader", "tags": ["beginner"], "likes": 1, "viewed": 68, "published": "Public", "date": "1546003856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p){\n    return length(cross(p-ro, rd))/length(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n   \t\n    \n    //////////////////////////////////\n    \n    \n    vec3 ro = vec3(0., 0., -2.);\n    vec3 rd = vec3(uv.x, uv.y, 0.)-ro;\n    \n    float t = iTime;\n    vec3 p = vec3(sin(t), 0., 2.+cos(t));\n    float d = DistLine(ro, rd, p);\n    \n    d = smoothstep(.1, .09, d);\n    \n    fragColor = vec4(d);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdf3WH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 90], [92, 92, 149, 199, 644]], "test": "ok"}
{"id": "Wdf3Wn", "name": "Rainbowify", "author": "Limeth", "description": "derp", "tags": ["rainbow"], "likes": 2, "viewed": 314, "published": "Public API", "date": "1545587851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb_from_hsv(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv_from_rgb(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 get_fragment(vec2 uv) {\n    const vec2 textureSize = vec2(700, 700);\n    const float maxTextureSize = max(textureSize.x, textureSize.y);\n    const float minTextureSize = min(textureSize.x, textureSize.y);\n    const float scale = 1.0;\n    \n    // resized to fit into iResolution.xy\n    vec2 resLogoSize = textureSize * min(iResolution.x, iResolution.y) / max(textureSize.x, textureSize.y);\n    vec2 relLogoSize = resLogoSize / iResolution.xy;\n    \n    // scale\n    uv = (uv - vec2(0.5)) * 2.0;\n    uv /= scale;\n    uv = uv / 2.0 + vec2(0.5);\n    uv.x += -relLogoSize.x / 2.0;\n    \n    //\n    if(uv.x < 0.0 || uv.x >= relLogoSize.x || uv.y < 0.0 || uv.y >= relLogoSize.y) {\n        return vec3(0.0);\n    }\n    \n    vec2 texUv = uv / relLogoSize;\n    \n    vec3 rgb = texture(iChannel0, texUv).rgb;\n    vec3 hsv = hsv_from_rgb(rgb);\n    \n    hsv.x += (texUv.x - texUv.y) * 0.5 - iTime;\n    hsv.y = min(hsv.y + 0.25, 1.0);\n    hsv.z = min(hsv.z + 0.25, 1.0);\n    \n    return rgb_from_hsv(hsv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = get_fragment(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdf3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 196], [198, 198, 225, 225, 556], [558, 558, 586, 586, 1553], [1555, 1555, 1610, 1660, 1824]], "test": "error"}
{"id": "Wdf3zn", "name": "vertical flow coral", "author": "edapx", "description": "vertical flow", "tags": ["verticalflow"], "likes": 5, "viewed": 139, "published": "Public", "date": "1544650014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 vectorField(vec2 uv){\n  vec2 res = uv;\n  float n = noise(res*vec2(3.0));\n  res.y -= iTime*0.05;\n  res += sin(res.yx*40.) * 0.02;\n  res += vec2(n);\n  return res;\n}\n\nfloat plot(float val, float c, float t){\n  float l = smoothstep(c,c-t,val);\n  float r = smoothstep(c,c-t/5.,val);\n  return r-l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  float t = 0.2; // try 0.2 or 0.3\n  vec4 m = iMouse / iResolution.xxxx;\n  vec2 st = fragCoord/iResolution.xy;\n  st.y *= iResolution.y / iResolution.x;\n  st = vec2(st.y, st.y * (st.x * 0.4));\n  st = vectorField(st);\n\n  float cell = 0.2 + m.y*0.3;\n  vec2 modSt = mod(st, vec2(cell));\n\n  float x = plot(modSt.x, cell, t);\n  float y = plot(modSt.y, cell, t);\n    \n  vec3 green = vec3(0.733,1.,0.309 );\n  vec3 red = vec3(1.,0.352,0.207);\n  vec3 blue = vec3(0.086,0.290, 0.8 );\n\n    \n  vec3 col = blue * x;\n  col     += green * y;\n  col     += red*vec3(smoothstep(1.3, .01,x+y));\n\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdf3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 40, 40, 157], [159, 246, 272, 272, 788], [790, 790, 816, 816, 957], [959, 959, 999, 999, 1088], [1090, 1090, 1146, 1146, 1753]], "test": "ok"}
{"id": "wdfGD4", "name": "Spectrum Flag", "author": "vitoZ80", "description": "Flag spectrum", "tags": ["sin", "cos"], "likes": 1, "viewed": 350, "published": "Public API", "date": "1546230463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x += sin(iTime+uv.y)/3.33;\n    uv.y += cos(iTime+uv.x)/1.77;\n\n    float x = abs(sin(24.0*uv.x));\n    float y = abs(cos(24.0*uv.y));\n    vec3 color = vec3(1.0);\n\n    color *= x*y;\n    color.r *= uv.x;\n    color.g *= uv.y;\n    fragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfGD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 412]], "test": "ok"}
{"id": "WdfGWH", "name": "Puffin Pipes", "author": "nr4", "description": "Tunnel scene with some stars in the background.", "tags": ["tunnel", "acid"], "likes": 3, "viewed": 235, "published": "Public", "date": "1546173928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Puffin Pipes\n * From \"Puffin Cure\" by Team210 - 64k Demo at Under Construction 2018\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Speed optimizations\n\n// Global constants\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Global variables\nvec3 col = c.yyy;\n\n// Hash function\nfloat rand(vec2 x)\n{\n    return fract(sin(dot(x-1. ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n/* Simplex noise -\nCopyright (C) 2011 by Ashima Arts (Simplex noise)\nCopyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\nvec3 taylorInvSqrt(vec3 r) \n{     \n    return 1.79284291400159-0.85373472095314*r; \n}\n\nvec3 permute(vec3 x)\n{\n    return mod((x*34.+1.)*x, 289.);\n}\n\nfloat snoise(vec2 P) \n{     \n    const vec2 C = vec2 (0.211324865405187134, 0.366025403784438597);  \n    vec2 i = floor(P+dot(P, C.yy)) ; \n    vec2 x0 = P-i+dot(i, C.xx) ; \n    // Other  corners \n    vec2 i1 ; \n    i1.x = step ( x0.y , x0.x ) ;  //  1.0  i f  x0 . x > x0 . y ,  e l s e  0.0 \n    i1.y = 1.0 - i1.x ; \n    // x1 = x0  i1 + 1.0  C. xx ;  x2 = x0  1.0 + 2.0  C. xx ; \n    vec4 x12 = x0.xyxy + vec4 ( C.xx , C.xx * 2.0 - 1.0) ; \n    x12.xy -= i1 ; \n    //  Permutations \n    i = mod( i ,  289.0) ;  // Avoid  truncation  in  polynomial  evaluation \n    vec3 p = permute ( permute ( i.y + vec3 (0.0 , i1.y ,  1.0  ) ) + i.x + vec3 (0.0 , i1.x ,  1.0  ) ) ; \n    //  Circularly  symmetric  blending  kernel\n    vec3 m = max(0.5 - vec3 ( dot ( x0 , x0 ) ,  dot ( x12.xy , x12.xy ) , dot ( x12.zw , x12.zw ) ) ,  0.0) ; \n    m = m * m ; \n    m = m * m ; \n    //  Gradients  from 41  points  on a  line ,  mapped onto a diamond \n    vec3 x = fract ( p * (1.0  /  41.0) ) * 2.0 - 1.0  ; \n    vec3 gy = abs ( x ) - 0.5  ; \n    vec3 ox = floor ( x + 0.5) ;  // round (x)  i s  a GLSL 1.30  feature \n    vec3 gx = x - ox ; //  Normalise  gradients  i m p l i c i t l y  by  s c a l i n g m \n    m *= taylorInvSqrt ( gx * gx + gy * gy ) ; // Compute  f i n a l  noise  value  at P \n    vec3 g ; \n    g.x = gx.x * x0.x + gy.x * x0.y ; \n    g.yz = gx.yz * x12.xz + gy.yz * x12.yw ; \n    //  Scale  output  to  span  range  [  1 ,1] \n    //  ( s c a l i n g  f a c t o r  determined by  experiments ) \n    return  -1.+2.*(130.0 * dot ( m , g ) ) ; \n}\n/* End of Simplex Noise */\n\n// Multi-frequency simplex noise\nfloat mfsnoise(vec2 x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.2;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*snoise(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\n// 3D rotational matrix\nmat3 rot(vec3 p)\n{\n    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\n// add object to scene\nvec2 add(vec2 sda, vec2 sdb)\n{\n    return mix(sda, sdb, step(sdb.x, sda.x));\n}\n\n// Distance to line segment\nfloat lineseg(vec2 x, vec2 p1, vec2 p2)\n{\n    vec2 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\nfloat lineseg(vec3 x, vec3 p1, vec3 p2)\n{\n    vec3 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\n// Distance to circle\nfloat circle(vec2 x, float r)\n{\n    return length(x)-r;\n}\n\n// Distance to circle segment\nfloat circlesegment(vec2 x, float r, float p0, float p1)\n{\n    float p = atan(x.y, x.x);\n    p = clamp(p, p0, p1);\n    return length(x-r*vec2(cos(p), sin(p)));\n}\n\n// Distance to 210 logo\nfloat logo(vec2 x, float r)\n{\n    return min(\n        min(circle(x+r*c.zy, r), lineseg(x,r*c.yz, r*c.yx)),\n        circlesegment(x+r*c.xy, r, -.5*pi, .5*pi)\n    );\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\nvec2 scene(vec3 x)\n{\n    vec2 sdf = c.xy;\n    \n    x -= c.yyx*iTime;\n    \n    vec3 dv = 2.e-2*vec3(snoise(c.xx*(x.z-iTime)),\n                      snoise(c.xx*(x.z-iTime)+13.),\n                      snoise(c.xx*(x.z-iTime)-22.)\n                      );\n    x += dv;\n    x *= rot(c.yyx*iTime);\n    \n    float dz = .5;\n    vec3 z = vec3(x.xy, mod(x.z, dz)-.5*dz);\n    \n    float r = length(x.xy),\n        ddr = .1,\n        dr = mod(r, ddr)-.5*ddr,\n        p = atan(x.y,x.x),\n        ddp = pi/(8.+round(24.*rand(floor(2.*iTime)*c.xx))),\n        dp = mod(p, 2.*ddp)-ddp,\n        r0 = .3;\n    \n    vec3 y = vec3(r0*cos(p-dp), r0*sin(p-dp), 0.);\n    sdf = vec2(length(z-y)-.05, 1.+3.*round(rand(vec2(p-dp,x.z-z.z))));\n    \n    sdf = add(sdf, vec2(stroke(lineseg(z, vec3(r0*cos(p-dp-ddp), r0*sin(p-dp-ddp), 0.), vec3(r0*cos(p-dp+ddp), r0*sin(p-dp+ddp), 0.)), .03),1.));\n\tsdf = add(sdf, vec2(stroke(lineseg(vec3(z.xy,abs(z.z)), y, y+dz*c.yyx), .03), 1.+3.*round(rand(vec2(p-dp+17.)))));\n    \n    sdf.x -= length(dv)-.03;\n\n    return sdf;\n}\n\n//performs raymarching\n//scene: name of the scene function\n//xc: \t name of the coordinate variable\n//ro:\t name of the ray origin variable\n//d:\t name of the distance variable\n//dir:\t name of the direction variable\n//s:\t name of the scenestruct variable\n//N:\t number of iterations used\n//eps:\t exit criterion\n//flag:  name of the flag to set if raymarching succeeded\n#define raymarch(scene, xc, ro, d, dir, s, N, eps, flag) \\\n\tflag = false;\\\n\tfor(int i=0; i<N; ++i)\\\n    {\\\n        xc = ro + d*dir;\\\n        s = scene(xc);\\\n        if(s.x < eps)\\\n        {\\\n            flag = true;\\\n            break;\\\n        }\\\n        d += s.x;\\\n    }\n\n//computes normal with finite differences\n//scene: name of the scene function\n//n:\t name of the normal variable\n//eps:\t precision of the computation\n//xc:\t location of normal evaluation\n#define calcnormal(scene, n, eps, xc) \\\n\t{\\\n        float ss = scene(xc).x;\\\n        n = normalize(vec3(scene(xc+eps*c.xyy).xc-ss,\\\n                           scene(xc+eps*c.yxy).xc-ss,\\\n                           scene(xc+eps*c.yyx).xc-ss));\\\n    }\n\n//camera setup\n//camera: camera function with camera(out vec3 ro, out vec3 r, out vec3 u, out vec3 t)\n//ro:\t  name of the ray origin variable\n//r:\t  name of the right variable\n//u:\t  name of the up variable\n//t:\t  name of the target variable\n//uv:\t  fragment coordinate\n//dir:\t  name of the dir variable\n#define camerasetup(camera, ro, r, u, t, uv, dir) \\\n\t{\\\n        camera(ro, r, u, t);\\\n        t += uv.x*r+uv.y*u;\\\n        dir = normalize(t-ro);\\\n    }\n\n//post processing: 210 logo and trendy display lines\n//col: output color\n//uv:  fragment coordinate\n#define post(color, uv) \\\n\t{\\\n    \tcol = mix(clamp(col,c.yyy,c.xxx), c.xxx, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, stroke(logo(uv-vec2(-.45,.45),.02),.005)));\\\n    \tcol += vec3(0., 0.05, 0.1)*sin(uv.y*1050.+ 5.*iTime);\\\n\t}\n\t\n//camera for scene 1\nvoid camera1(out vec3 ro, out vec3 r, out vec3 u, out vec3 t)\n{\n    ro = c.yyx;\n    r = c.xyy;\n    u = c.yxy;\n    t = c.yyy;\n}\n\n// Standard shadertoy color\nvec3 stdcolor(vec2 x)\n{\n\treturn 0.5 + 0.5*cos(iTime+x.xyx+vec3(0,2,4));\n}\n\n// Select material color\nvec3 color(float rev, float ln, float index, vec2 uv, vec3 x)\n{\n    vec3 col = c.yyy;\n    if(index == 1.)\n    {\n        x *= 1.e-2;\n   \t\tvec3 c1 = stdcolor(1.5e2*x.z+x.xy+.5*rand(17.*c.xx)), \n        \tc2 = stdcolor(1.5e2*x.z+x.xy+x.yz+x.zx+.5*rand(12.*c.xx)+11.+uv), \n            c3 = stdcolor(1.5e2*x.z+x.xy+x.yz+x.zx+.5*rand(15.*c.xx)+23.+uv);\n\t\tcol = .1*c1*vec3(1.,1.,1.) + .2*c1*vec3(1.,1.,1.)*ln + 1.5*vec3(1.,1.,1.)*pow(rev,2.*(2.)) + 2.*c1*pow(rev, 8.)+3.*c1*pow(rev, 16.);\n        col = clamp(.23*col, 0., 1.);\n\t}\n    else if(index == 4.)\n    {\n        x *= 1.e-2;\n   \t\tvec3 c1 = 1.*stdcolor(1.5e2*x.z+x.xy+.5*rand(47.*c.xx)/*+iNBeats*/+14.), \n        \tc2 = 1.*stdcolor(1.5e2*x.z+x.xy+x.yz+x.zx+.5*rand(12.*c.xx)/*+iNBeats*/+21.+uv), \n            c3 = 1.*stdcolor(1.5e2*x.z+x.xy+x.yz+x.zx+.5*rand(15.*c.xx)/*+iNBeats*/+33.+uv);\n\t\tcol = .1*c1*vec3(1.,1.,1.) + .2*c1*vec3(1.,1.,1.)*ln + 1.5*vec3(1.,1.,1.)*pow(rev,4.) + 2.*c1*pow(rev, 8.)+3.*c1*pow(rev, 16.);\n        col = clamp(.23*col, 0., 1.);\n\t}\n    return col;\n}\n\nfloat star(vec2 x, float r0)\n{\n    return 1.-smoothstep(.5*r0, r0, length(x));\n}\n\n// Background 1 (Moon)\nvec3 background1(vec2 x)\n{\n    //Stars\n    float dr = .03, scale;\n    vec2 y = mod(x, dr)-.5*dr;\n    float rs = rand(x-y)*.005,\n        dx = -.5*(dr-rs)+(dr-2.*rs)*rand(x-y+1.),\n        dy = -.5*(dr-rs)+(dr-2.*rs)*rand(x-y+2.);\n    scale = star(y-vec2(dx,dy), rs);\n    vec3 color = scale*clamp(8.*rand(x.xy+4.)*stdcolor(rand(x-y+3.)*x.xy), 0., 1.); \n    \n    // Star nebula\n    float f = mfsnoise(x.xy-6.93, 2.e-1, 1.e2, .55);\n    color += mix(c.yyy, stdcolor(x), .5+.95*f);\n    color += mix(c.yyy, 2.*stdcolor(x+4.), .5+.33*f);\n    color += mix(c.yyy, stdcolor(x+8.), .5+.79*f);\n    \n    return clamp(color, 0., 1.);\n}\n\n// Background for the unc logo\nvec3 background2(vec2 x)\n{\n    vec3 bg = c.yyy;\n    float p = atan(x.y,x.x)/iTime,\n        n = 5.,\n        dmax = .3+.1*snoise(iTime*c.xx);\n    for(float i = 0.; i<n; i+=1.)\n    {\n        float d = i/n*dmax;\n        bg += background1((length(x)-.05+d-2.*iTime)*vec2(cos(p), sin(p))-.05*vec2(snoise(x.xy-iTime), snoise(x.xy+iTime)));\n    }\n    bg /= n;\n    return bg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    \n\t// Perform raymarching\n    vec3 ro, r, u, t, x, dir;\n    vec2 s;\n    camerasetup(camera1, ro, r, u, t, uv, dir);\n    \t\n    float d = .2/length(dir.xy);\n    {\n    \tbool hit;\n            \n        raymarch(scene, x, ro, d, dir, s, 150, 1.e-4, hit);\n        if(hit == false)\n        {\n        \t// Draw Background here.\n            col = background1(uv);\n                \n            post(col, uv);\n            fragColor = vec4(col, 1.);\n            return;\n        }\n            \n        vec3 n;\n        calcnormal(scene, n, 5.e-3, x);\n\n        vec3 l = x+2.*c.yyx, re = normalize(reflect(-l,n)), v = normalize(x-ro);\n        float rev = abs(dot(re,v)), ln = abs(dot(l,n));\n\n        col = color(rev, ln, s.y, uv, x);\n    }\n    \n    // Post-process\n    post(col, uv);\n    \n    // Set the fragment color\n    fragColor = vec4(col, 1.);    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfGWH.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[950, 967, 987, 987, 1056], [1058, 2225, 2254, 2254, 2310], [2312, 2312, 2334, 2334, 2372], [2374, 2374, 2397, 2397, 3939], [3968, 4001, 4056, 4056, 4227], [4229, 4253, 4271, 4271, 4480], [4482, 4505, 4535, 4535, 4583], [4585, 4613, 4654, 4654, 4746], [4748, 4748, 4789, 4789, 4881], [4883, 4905, 4936, 4936, 4962], [4964, 4994, 5052, 5052, 5155], [5157, 5181, 5210, 5210, 5346], [5348, 5385, 5417, 5417, 5440], [5442, 5442, 5462, 5462, 6473], [8345, 8366, 8429, 8429, 8492], [8494, 8522, 8545, 8545, 8595], [8597, 8622, 8685, 8685, 9646], [9648, 9648, 9678, 9678, 9728], [9730, 9753, 9779, 9791, 10372], [10374, 10405, 10431, 10431, 10773], [10775, 10775, 10832, 10832, 11716]], "test": "error"}
{"id": "wdfGzH", "name": "hypnotic spiral 1", "author": "morisil", "description": "Achtung! It might cause strong optical illusion, especially when the scale is adjusted. I discovered this spiral with constant increment by accident, while working on this project: https://morisil.github.io/cartesian-creatures/", "tags": ["procedural", "spiral", "illusion", "hypnotic", "polar"], "likes": 8, "viewed": 866, "published": "Public API", "date": "1544911254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// adjust this factor for stronger optical illusion\n#define SCALE 60.0\n// rotation speed, might be negative to spin counter-clockwise\n#define SPEED 1.0\n\nfloat getColorComponent(float dist, float angle, float scaleIncrement) {\n    return sin(dist * (SCALE + scaleIncrement) + angle - (iTime * SPEED));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 delta = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(delta),\n    angle = atan(delta.x, delta.y);\n    fragColor = vec4(\n        getColorComponent(dist, angle, 0.0),\n        getColorComponent(dist, angle, 1.0),\n        getColorComponent(dist, angle, 2.0),\n        1.0\n    );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 225, 225, 302], [304, 304, 359, 359, 672]], "test": "ok"}
{"id": "WdlGWr", "name": "Raymarch test 9001", "author": "Pro_Coder", "description": "raymarch test", "tags": ["raymarch"], "likes": 2, "viewed": 99, "published": "Public", "date": "1545781103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 1000\n#define MAX_DISTANCE 100.\n#define SURF_DISTANCE .001\n\n\nfloat GetDist(vec3 p){\n\tvec4 s1 = vec4(0, 1, 6, 1);\n    vec4 s2 = vec4(1, 1, 8, 1);\n    vec4 s3 = vec4(-2.3, 1, 6, 1);\n    vec4 s4 = vec4(2, 2, 6, 1);\n    \n    float sphereDist1 = length(p-s1.xyz)-s1.w;\n    float sphereDist2 = length(p-s2.xyz)-s2.w;\n    float sphereDist3 = length(p-s3.xyz)-s3.w;\n    float sphereDist4 = length(p-s4.xyz)-s4.w;\n    \n    float planeDist = p.y;\n    \n    float d = min(min(min(min(sphereDist1, planeDist), sphereDist2), sphereDist3), sphereDist4);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n \tfloat dO = 0.;\n    \n    \n    for(int i=0; i<MAX_STEPS; i++){\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DISTANCE || dS < SURF_DISTANCE) break;\n    }\n\treturn dO;\n}\n\nvec3 GetNormal(vec3 p){\n \tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p, float distanceToPoint){\n    \n    if(distanceToPoint >= MAX_DISTANCE) return 2.;\n    \n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = dot(n, l);\n    float d = RayMarch(p+n*SURF_DISTANCE*2., l);\n    if(d < length(lightPos-p)) dif = 0.;\n    return clamp(dif, .2, 1.);;\n}\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 point){\n\treturn length(cross(point - ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 point){\n\treturn smoothstep(.06, .04, DistLine(ro, rd, point));\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy - .1;\n    \n    uv -= .5;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    float t = iTime;\n    \n    \n    vec3 ro = vec3(0., 1. + mouse.y*2. , 0.);\t\t//origin (camera)\n    \n    vec3 lookat = vec3(0., 1., 6.);\n    float zoom = 1.;\n    vec3 F = normalize(lookat-ro);\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F));\n    vec3 U = normalize(cross(F, R));\n    \n    vec3 c = ro + F*zoom;\n    \n    vec3 i = c + uv.x*R + uv.y*U;\n    vec3 rd = i-ro;\n    \n    \n    \n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p, d);\n    vec3 col = vec3(dif);\n    \n    if(dif == 2.){\n    \tcol = vec3(0.3, 0.4, 0.76);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 101, 101, 572], [574, 574, 607, 607, 824], [826, 826, 849, 849, 1015], [1019, 1019, 1065, 1065, 1429], [1431, 1431, 1476, 1476, 1528], [1530, 1530, 1576, 1576, 1633], [1640, 1640, 1697, 1747, 2549]], "test": "ok"}
{"id": "wdlGz7", "name": "less slow font", "author": "Del", "description": "font rendering in cells (gives a little bit of a speed boost)", "tags": ["raymarch", "sdf", "font", "slow", "dirty"], "likes": 6, "viewed": 435, "published": "Public API", "date": "1545554901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \n//\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    vec2 mouse2 = vec2(sin(time*0.25)*0.1, 0.1+(0.5+sin(time)*0.5)*0.4);\n    if (iMouse.z>0.5)\n\t\tmouse2 = mouse;\n    float an = 7.0*mouse2.x;\n    camPos = vec3(9.5*sin(an),mouse2.y*8.0,9.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    p.y += 0.5;\n    float scale = sin(iTime*1.25)*0.15;\n    \n    float  c = cos(scale*p.y+scale);\n    float  s = sin(scale*p.y+scale);\n    mat2   m = mat2(c,-s,s,c);\n    p = vec3(m*p.zy,p.x);\n    p.y -= 0.5;\n    return p;\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n#define PI 3.14159\n#define\tTAU 6.28318\n\n#define CHS 0.2\n// 2d box for font\nfloat sdBox2(in vec2 p,in vec2 b) {vec2 d=abs(p)-b;return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);}\n// 2d line for font\nfloat line2(float d,vec2 p,vec4 l){vec2 pa=p-l.xy;vec2 ba=l.zw-l.xy;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return min(d,length(pa-ba*h));}\n// font, optimized with mirroring etc.\nfloat LR(vec2 p, float d){p.x=abs(p.x);return line2(d,p,vec4(2,-3.25,2,3.25)*CHS);}\nfloat TB(vec2 p, float d){p.y=abs(p.y);return line2(d,p,vec4(2,3.25,-2,3.25)*CHS);}\nfloat TBLR(vec2 p, float d){return min(d,abs(sdBox2(p,vec2(2,3.25)*CHS)));}\nfloat A(vec2 p,float d){d=LR(p,d);p.y=abs(p.y-1.5*CHS);return line2(d,p,vec4(2,1.75,-2,1.75)*CHS);}\nfloat B(vec2 p,float d){p.y+=1.75*CHS;d=min(d,abs(sdBox2(p,vec2(2.0,1.5)*CHS)));p+=vec2(0.5,-3.25)*CHS;return min(d,abs(sdBox2(p,vec2(1.5,1.75)*CHS)));}\nfloat C(vec2 p,float d){d=TB(p,d);return line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);}\nfloat D(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(2,-1,2,1)*CHS);p.y=abs(p.y);d=line2(d,p,vec4(2,1,1.5,2.75)*CHS);d=line2(d,p,vec4(1.5,2.75,1,3.25)*CHS);return line2(d,p,vec4(1,3.25,-2,3.25)*CHS);}\nfloat E(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);return line2(d,p,vec4(0,-0.25,-2,-0.25)*CHS);}\nfloat F(vec2 p,float d){d=line2(d,p,vec4(2,3.25,-2,3.25)*CHS);d=line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);return line2(d,p,vec4(0,-0.25,-2,-0.25)*CHS);}\nfloat G(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(2,2.25,2,3.25)*CHS);d=line2(d,p,vec4(2,-3.25,2,-0.25)*CHS);return line2(d,p,vec4(2,-0.25,0.5,-0.25)*CHS);}\nfloat H(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(-2,-0.25,2,-0.25)*CHS);}\nfloat I(vec2 p,float d){d=line2(d,p,vec4(0,-3.25,0,3.25)*CHS);p.y=abs(p.y);return line2(d,p,vec4(1.5,3.25,-1.5,3.25)*CHS);}\nfloat J(vec2 p,float d){d=line2(d,p,vec4(-1.5,-3.25,0,-3.25)*CHS);d=line2(d,p,vec4(0,-3.25,1,-2.25)*CHS);d=line2(d,p,vec4(1,-2.25,1,3.25)*CHS);return line2(d,p,vec4(1,3.25,-1.5,3.25)*CHS);}\nfloat K(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(-2,-0.25,-0.5,-0.25)*CHS);d=line2(d,p,vec4(2,3.25,-0.5,-0.25)*CHS);return line2(d,p,vec4(-0.5,-0.25,2,-3.25)*CHS);}\nfloat L(vec2 p,float d){d=line2(d,p,vec4(2,-3.25,-2,-3.25)*CHS);return line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);}\nfloat M(vec2 p,float d){p.x=abs(p.x);d=line2(d,p,vec4(2,-3.25,2,3.25)*CHS);return line2(d,p,vec4(0,0.75,2,3.25)*CHS);}\nfloat N(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(-2,3.25,2,-3.25)*CHS);}\nfloat O(vec2 p,float d){return TBLR(p,d);}\nfloat P(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,0.0)*CHS);p.y-=1.5*CHS;return min(d,abs(sdBox2(p,vec2(2.0,1.75)*CHS)));}\nfloat Q(vec2 p,float d){d=TBLR(p,d);return line2(d,p,vec4(2,-3.25,0.5,-1.75)*CHS);}\nfloat R(vec2 p,float d){d=line2(d,p,vec4(0.5,-0.25,2,-3.25)*CHS);d=line2(d,p,vec4(-2,-3.25,-2,0.0)*CHS);p.y-=1.5*CHS;return min(d, abs(sdBox2(p,vec2(2.0,1.75)*CHS)));}\nfloat S(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,3.25,-2,-0.25)*CHS);d=line2(d,p,vec4(-2,-0.25,2,-0.25)*CHS);return line2(d,p,vec4(2,-0.25,2,-3.25)*CHS);}\nfloat T(vec2 p,float d){d=line2(d,p,vec4(0,-3.25,0,3.25)*CHS);return line2(d,p,vec4(2,3.25,-2,3.25)*CHS);}\nfloat U(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(2,-3.25,-2,-3.25)*CHS);}\nfloat V(vec2 p,float d){p.x=abs(p.x);return line2(d,p,vec4(0,-3.25,2,3.25)*CHS);}\nfloat W(vec2 p,float d){p.x=abs(p.x);d=line2(d,p,vec4(2,-3.25,2,3.25)*CHS);return line2(d,p,vec4(0,-1.25,2,-3.25)*CHS);}\nfloat X(vec2 p,float d){d = line2(d,p,vec4(-2,3.25,2,-3.25)*CHS);return line2(d,p,vec4(-2,-3.25,2,3.25)*CHS);}\nfloat Y(vec2 p,float d){d=line2(d,p,vec4(0,-0.25,0,-3.25)*CHS);p.x=abs(p.x);return line2(d,p,vec4(0,-0.25,2,3.25)*CHS);}\nfloat Z(vec2 p,float d){d=TB(p,d);return line2(d,p,vec4(-2,-3.25,2,3.25)*CHS);}\n\nfloat GetChar(vec2 p, float d, float c)\n{\n    if (c<-14.0) return 0.5;\t\t// blank left\n    if (c<-13.0) return A(p,d);\n    if (c<-12.0) return B(p,d);\n    if (c<-11.0) return C(p,d);\n    if (c<-10.0) return D(p,d);\n    if (c<-9.0) return E(p,d);\n    if (c<-8.0) return F(p,d);\n    if (c<-7.0) return G(p,d);\n    if (c<-6.0) return H(p,d);\n    if (c<-5.0) return I(p,d);\n    if (c<-4.0) return J(p,d);\n    if (c<-3.0) return K(p,d);\n    if (c<-2.0) return L(p,d);\n    if (c<-1.0) return M(p,d);\n    if (c<0.0) return N(p,d);\n    if (c<1.0) return O(p,d);\n    if (c<2.0) return P(p,d);\n    if (c<3.0) return Q(p,d);\n    if (c<4.0) return R(p,d);\n    if (c<5.0) return S(p,d);\n    if (c<6.0) return T(p,d);\n    if (c<7.0) return U(p,d);\n    if (c<8.0) return V(p,d);\n    if (c<9.0) return W(p,d);\n    if (c<10.0) return X(p,d);\n    if (c<11.0) return Y(p,d);\n    if (c<12.0) return Z(p,d);\n    if (c<13.0) return 0.5;\t\t\t// blank right\n    return d;\n}\n\nfloat celltest(vec3 p,float d)\n{\n    p.x += iTime*4.1;\n    pMod1(p.x,80.0);\n    \n\tfloat t1 = fract(iTime*0.3) * TAU;\n\tp.y -= sin(t1+p.x*0.25)*0.7;\n    \n    vec3 mods = vec3(1.8,2.0,3.0);\n    vec3 cells = vec3(0.0);\n    cells.z = pMod1(p.z,mods.z);\n    p.x += cells.z*2.1;\n    cells.x = pMod1(p.x,mods.x);\n    cells.y = pMod1(p.y,mods.y);\n    \n    if (cells.y<0.0 || cells.z<-7.0 || cells.z>1.0)\n        return d;\n    \n    d = GetChar(p.xy, d, cells.x);\n    d-=0.65*CHS;\t// char thickness...\n\t//if (d<=1.0)\n\t{\n\t\t// extrude\n\t\tfloat dep = 0.1;\n\t\tvec2 e = vec2( d, abs(p.z) - dep );\n\t\td = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n\t\td -= 0.425*CHS;\t\t// rounding\n  \t\t//d-=  sin(t1+(p.x*0.15))*0.05;\n\t}\n    return d*0.5;\n}\n\nvec2 doModel( vec3 p )\n{\n    vec2 res = vec2(1.0,1.0);\n    //res = opU(res,vec2(sdBox(p,vec3(15.0,0.1,15.0)),1.0));\n    res = vec2( sdPlane(p+vec3(0.0,0.0,0.0)), 1.0);\t// floor...\n    p.y -= 1.6;\n    float d = celltest(p,1.0);\n    res = opU(res,vec2(d,3.0));\n    return res;\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in float _mat )\n{\n    vec3 mal = vec3(0.0);\n    float specval = 0.0;\n    if (_mat<=1.0)\n    {\n        float f = mod( floor(0.5*pos.z) + floor(0.5*pos.x), 2.0);\n        mal = 0.2 + 0.2*f+0.2*vec3(0.45,0.85,1.0);\n    }\n    else\n    {\n        mal = vec3(0.5,0.15,0.1);\n        specval = 1.1;\n    }\n    \n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.7,0.875,0.89));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos, lig, 0.02, 2.5 );\n    lin += dif*vec3(1.00,1.00,1.00)*sha;\n    float spec = pow(dif, 12.0) *specval;\n    \n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal.xyz*lin;\n    col+=spec;\n    \n    // fog    \n    //-----------------------------\n   \tcol *= exp(-0.0015*dis*dis);\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 70.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\t//float res = -1.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<190; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        t += h;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.0001;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n#define ZERO (min(iFrame,0))\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = doModel( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n  \tvec3 col = vec3(0.03,0.03,0.05);\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        col = doLighting( pos, nor, rd, t, res.y );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 167, 248, 248, 481], [648, 648, 673, 673, 688], [690, 719, 753, 753, 864], [866, 866, 896, 896, 929], [931, 931, 955, 955, 1179], [1181, 1181, 1212, 1212, 1318], [1319, 1319, 1350, 1350, 1457], [1458, 1458, 1489, 1489, 1595], [1596, 1596, 1631, 1631, 1657], [1659, 1834, 1874, 1874, 1995], [1997, 1997, 2019, 2019, 2086], [2144, 2163, 2198, 2198, 2269], [2270, 2290, 2325, 2325, 2434], [2435, 2474, 2500, 2500, 2557], [2558, 2558, 2584, 2584, 2641], [2642, 2642, 2670, 2670, 2717], [2718, 2718, 2742, 2742, 2817], [2818, 2818, 2842, 2842, 2970], [2971, 2971, 2995, 2995, 3051], [3052, 3052, 3076, 3076, 3280], [3281, 3281, 3305, 3305, 3401], [3402, 3402, 3426, 3426, 3550], [3551, 3551, 3575, 3575, 3748], [3749, 3749, 3773, 3773, 3829], [3830, 3830, 3854, 3854, 3953], [3954, 3954, 3978, 3978, 4143], [4144, 4144, 4168, 4168, 4340], [4341, 4341, 4365, 4365, 4451], [4452, 4452, 4476, 4476, 4570], [4571, 4571, 4595, 4595, 4650], [4651, 4651, 4675, 4675, 4693], [4694, 4694, 4718, 4718, 4819], [4820, 4820, 4844, 4844, 4903], [4904, 4904, 4928, 4928, 5071], [5072, 5072, 5096, 5096, 5231], [5232, 5232, 5256, 5256, 5338], [5339, 5339, 5363, 5363, 5419], [5420, 5420, 5444, 5444, 5501], [5502, 5502, 5526, 5526, 5622], [5623, 5623, 5647, 5647, 5733], [5734, 5734, 5758, 5758, 5854], [5855, 5855, 5879, 5879, 5934], [5936, 5936, 5977, 5977, 6882], [6884, 6884, 6916, 6916, 7602], [7604, 7604, 7628, 7628, 7880], [8123, 8123, 8209, 8209, 9159], [9161, 9161, 9210, 9210, 9774], [9776, 9776, 9808, 9808, 10229], [10260, 10260, 10338, 10338, 10607], [10610, 10610, 10674, 10674, 10852], [10854, 10854, 10911, 10911, 12075]], "test": "error"}
{"id": "WdlGzn", "name": "ShaderDojo 002", "author": "antonOTI", "description": "Made on bonzomatic to get into shape for shader showdown :)", "tags": ["raymarching", "training", "shadershowdown", "cookie"], "likes": 5, "viewed": 369, "published": "Public API", "date": "1544731564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define fGlobalTime (iTime)\n\nmat2 rot(float a)\n{\n  float ca = cos(a);float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat fbm(vec2 p)\n{\n  mat2 m = mat2(.8,-.6,.6,.8);\n  float acc = 0.;\n  p *= -m * m * .5;\n  for(float i = 1.; i < 6.; ++i)\n  {\n    p += vec2(i * 1251.675, i * 6568.457) + vec2(fGlobalTime * .3);\n    p *= m;\n    acc += (sin(p.x * i) + cos(p.y * i)) * 1./(i * .5);\n  }\n\n  return acc;\n}\n\nfloat height = 0.;\nint id = 0;\n\nfloat map(vec3 p)\n{\n\n  p.yz *= rot(sin(fGlobalTime * .1) * .2 + .1);\n  p.xz *= rot(fGlobalTime * .1);\n\n  float dist = 1000.;\n  vec3 cp = p;\n\n  p.y += fbm(p.xz * 2.) * .1;\n  float plan = p.y +.45;\n  height = p.y + .65;\n  dist = min(plan,dist);\n  \n  p = cp;\n  float sph = length(p) - 4.;\n  dist = max(dist, sph);\n  if(dist < .01) id = 1;\n\n  p = cp;\n  p.y += 5.;\n  p.xz /= 4.;\n  p.y *= 2.;\n//  p.y = max(p.y, 0.);\n  p = abs(p);\n  float cube = max(p.x, max(p.y,p.z)) - 1.;\n  dist = min(dist, cube);\n  if(cube < .01) id = 2;\n\n  return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n  vec3 ro = vec3(0.,4.,-15.);\n  vec3 rd = normalize(vec3(uv,1));\n  vec3 cp = ro;\n  rd.zy *= rot(-.3);\n\n\n  float st = 0.;\n  float cd = 0.;\n  for(;st < 1.; st += 1./128.)\n  {\n    cd = map(cp);\n    if(cd < .01) break;\n    cp += rd * cd * .45;\n  }\n\n  vec4 sky = mix(vec4(0.1,0.1,.1,0.),vec4(.6,.6,.9,1.), smoothstep(-.1,-.0, rd.y));\n\n  fragColor = sky ;\n\n  if(id == 1)\n  {\n    fragColor = mix(vec4(.2,.3,.6,0.) * 1.5, vec4(1.) * 2.5, height * .8 + .2) * pow(1. - st,2.);\n  }\n  if(id == 2)\n  {\n    fragColor = vec4(.8,.8,.6,1.) * (1. - st) * clamp(pow(length(cp.xz * .46), .8),0.,1.);\n  }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlGzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 49, 49, 119], [121, 121, 140, 140, 403], [437, 437, 456, 456, 974], [976, 976, 1033, 1033, 1685]], "test": "ok"}
{"id": "wds3DH", "name": "pattern gen BW gray and color", "author": "oO0", "description": "go full screen, move mouse, pay attention to top and bottom position \npress keyboard 1 - switch BW/color", "tags": ["texture", "animated", "background", "gray", "pattern"], "likes": 4, "viewed": 54, "published": "Public", "date": "1546132650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of https://shadertoy.com/view/Mty3Wh // 2018-12-30 00:55:16\n\nfloat start=65.; //1...\nfloat iMouseX_div=40.; //1...100\nfloat iMouseY_div=1.; //1...100\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n \n    O = vec4( \n  mod(mix(U.x,U.y, \n      iMouse.y/iResolution.y/iMouseY_div)+U.y,\n      sin(1.+iTime/(100.*(start+iMouse.x/iMouseX_div))))\n   );\n   \n    \n if(texelFetch(iChannel1, ivec2(49,2),0).x ==1.) //keyboard 1 \n    {\n O.g =\n    mod(mix(U.x,U.y, \n      iMouse.y/iResolution.y/iMouseY_div)+U.y*1.001,\n      sin(1.+iTime/(100.*(start+iMouse.x/iMouseX_div))))\n     ;\n O.b =\n       mod(mix(U.x,U.y, \n      iMouse.y/iResolution.y/iMouseY_div)+U.y,\n      sin(1.+iTime/(100.*(start+iMouse.x*1.001/iMouseX_div))))\n ;\n    }\n    \n if ( U.y/iResolution.y > .5 ) O = sqrt(O);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wds3DH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 197, 197, 770]], "test": "error"}
{"id": "WdsGR8", "name": "Xmas2018", "author": "Del", "description": "Merry Christmas everyone!", "tags": ["raymarch", "text", "line", "hsv", "snow", "slow", "extrude"], "likes": 6, "viewed": 567, "published": "Public API", "date": "1544928725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// festive (and slow) - delz 16/12/2018\n// added a couple of slight optimizations, it now actually runs on the iPhoneX ;)\n\n#define PI 3.14159\n#define\tTAU 6.28318\n\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time)\n{\n    vec2 mouse2 = vec2(sin(time*0.25)*0.1, 0.6+((0.5+sin(time) * 0.5)*0.5)*2.8);\n    float an = 7.0*mouse2.x;\n    camPos = vec3(28.5*sin(an),mouse2.y*8.0,28.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opUnionRound(const in vec2 a, const in vec2 b, const in float r)\n{\n    vec2 res = vec2(smin(a.x,b.x,r),(a.x<b.x) ? a.y : b.y);\n    return res;\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat line( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h )-0.3;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\t\n\n// model\nfloat A(vec2 p,float d){d=min(d,line(p,vec2(1,-8),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(5,-1.5)));d=min(d,line(p,vec2(1,-5),vec2(5,-5)));d=min(d,line(p,vec2(5,-8),vec2(5,-1.5)));return d;}\nfloat C(vec2 p,float d){d=min(d,line(p,vec2(5,-1.5),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(1,-8)));d=min(d,line(p,vec2(1,-8),vec2(5,-8)));return d;}\nfloat E(vec2 p,float d){d=min(d,line(p,vec2(5,-1.5),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(1,-8)));d=min(d,line(p,vec2(1,-8),vec2(5,-8)));d=min(d,line(p,vec2(3,-5),vec2(1,-5)));return d;}\nfloat H(vec2 p,float d){d=min(d,line(p,vec2(1,-8),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-5),vec2(5,-5)));d=min(d,line(p,vec2(5,-8),vec2(5,-1.5)));return d;}\nfloat I(vec2 p,float d){d=min(d,line(p,vec2(1.5,-1.5),vec2(4.5,-1.5)));d=min(d,line(p,vec2(3,-1.5),vec2(3,-8)));d=min(d,line(p,vec2(1.5,-8),vec2(4.5,-8)));return d;}\nfloat M(vec2 p,float d){d=min(d,line(p,vec2(1,-8),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(3,-4)));d=min(d,line(p,vec2(3,-4),vec2(5,-1.5)));d=min(d,line(p,vec2(5,-1.5),vec2(5,-8)));return d;}\nfloat R(vec2 p,float d){d=min(d,line(p,vec2(1,-8),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(5,-1.5)));d=min(d,line(p,vec2(5,-1.5),vec2(5,-5)));d=min(d,line(p,vec2(5,-5),vec2(1,-5)));d=min(d,line(p,vec2(3.5,-5),vec2(5,-8)));return d;}\nfloat S(vec2 p,float d){d=min(d,line(p,vec2(5,-1.5),vec2(1,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(1,-5)));d=min(d,line(p,vec2(1,-5),vec2(5,-5)));d=min(d,line(p,vec2(5,-5),vec2(5,-8)));d=min(d,line(p,vec2(5,-8),vec2(1,-8)));return d;}\nfloat T(vec2 p,float d){d=min(d,line(p,vec2(3,-8),vec2(3,-1.5)));d=min(d,line(p,vec2(1,-1.5),vec2(5,-1.5)));return d;}\nfloat Y(vec2 p,float d){d=min(d,line(p,vec2(1,-1.5),vec2(3,-5)));d=min(d,line(p,vec2(3,-5),vec2(3,-8)));d=min(d,line(p,vec2(3,-5),vec2(5,-1.5)));return d;}\n\n\nfloat message(vec3 p)\n{\n\tfloat d = 200.0;\n    float cw = 5.8;\n    float gap = (cw*2.0)+38.8;\n    float width = (15.0*cw);\n    float xmod = width+gap;\n    \n\tfloat c = pMod1(p.z,18.0);\n\tif (c>0.0 || p.z > 10.0 || p.z < -10.0)\n        return d;\n    \n\tp.x += fract(iTime*0.075)*xmod+c*25.0;\n    pMod1(p.x, xmod);\n\t\n\tfloat d2 = sdBox(p+vec3((gap*0.5)-cw,-3.0,0.0),vec3((width*0.5),5.5,0.8));\n\tif (d2>8.0)\n\t    return d;\n\t\n\tvec2 uv = p.xy;\n\tfloat x = -((width*0.5+gap*0.5)-cw);\n\tfloat t1 = fract(iTime*0.7) * TAU;\n\n\tfloat y = 7.6+sin(t1+p.x*0.25)*0.7;\n\tuv-=vec2(x,y);    \n\t\n\td = M(uv,d); uv.x -= cw;\n\td = E(uv,d); uv.x -= cw;\n\td = R(uv,d); uv.x -= cw;\n\td = R(uv,d); uv.x -= cw;\n\td = Y(uv,d); uv.x -= cw+cw;\n\td = C(uv,d); uv.x -= cw;\n\td = H(uv,d); uv.x -= cw;\n\td = R(uv,d); uv.x -= cw;\n\td = I(uv,d); uv.x -= cw;\n\td = S(uv,d); uv.x -= cw;\n\td = T(uv,d); uv.x -= cw;\n\td = M(uv,d); uv.x -= cw;\n\td = A(uv,d); uv.x -= cw;\n\td = S(uv,d);\n\n\tif (d<200.0)\n\t{\n\t\t// extrude\n\t\tfloat dep = 0.3;\n\t\tvec2 e = vec2( d, abs(p.z) - dep );\n\t\td = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n\t\td -= 0.425;\t\t// rounding\n\t}\n\treturn d;\n}\n\n\nvec2 doModel( vec3 p )\n{\n    float d2 = sdPlane(p-vec3(0.0,-1.8,0.0));\t\t// checkered floor distance...\n    float dm = message(p);\n    vec2 res = vec2(d2,0.0);\t\t\t// distance,material index\n    res = opUnionRound(res,vec2(dm,4.0),1.5);\t\n    return res;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal.\n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\n// c.a == specular val fudged in...\nvec4 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=1.0)\n    {\n        // checker floor\n\tfloat f = mod( floor(0.125*pos.z) + floor(0.125*pos.x), 2.0) + 0.35;\n        return f*vec4(0.331,0.725,0.951,0.0)*0.6;\t    \n    }\n    return vec4(hsv2rgb_smooth(vec3(-iTime*0.2+(pos.x+(pos.y*4.5))*0.0075,0.95,1.0))*0.5, 1.7);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mat )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.7,0.875,0.89));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(1.00,1.00,1.00)*sha;\n    float spec = pow(dif, 160.0) *mat.a;\n    \n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mat.xyz*lin;\n    col+=spec;\n    \n    // fog    \n    //-----------------------------\n    col *= exp(-0.0001*dis*dis);\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 180.0;           // max trace distance\n    const float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<100; i++ )          // max number of raymarching iterations is 100\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h*0.75;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.001;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n//snow original -> http://glslsandbox.com/e#36547.1\nfloat snow(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n    uv+=time/scale;\n    uv.y+=time*2./scale;\n    uv.x+=sin(uv.y+time*.5)/scale;\n    uv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n    vec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n    k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n    return k;\n}\n\n\nvec3 _Snow(vec2 uv,vec3 background)\n{\n    float c = snow(uv,30.)*.3;\n    c+=snow(uv,20.)*.5;\n    c+=snow(uv,15.)*.8;\n    c+=snow(uv,10.);\n    c+=snow(uv,8.);\n    c+=snow(uv,6.);\n    c+=snow(uv,5.);\n    c = clamp(c,0.0,1.0);\n    vec3 scol = vec3(1.0,1.0,1.0);\n    scol = mix(background,scol,c);\n    return scol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n    vec3 col = mix( vec3(0.2, 0.2, 0.2), vec3(0.0, 0.0, 0.1), fragCoord.y / iResolution.y )*0.4;\n\n    // raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mat = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mat );\n    }\n\n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------\n    // gamma\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col = _Snow(p.xy*0.5,col);\n    fragColor = vec4(col,1.);\t\n}\n// thank god, its the end of the terrible shader...\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 323, 388, 388, 591], [758, 758, 783, 783, 801], [803, 803, 844, 844, 937], [1090, 1265, 1305, 1305, 1426], [1428, 1428, 1466, 1466, 1580], [1582, 1582, 1613, 1613, 1704], [1707, 1716, 1740, 1740, 1914], [1915, 1915, 1939, 1939, 2072], [2073, 2073, 2097, 2097, 2269], [2270, 2270, 2294, 2294, 2425], [2426, 2426, 2450, 2450, 2591], [2592, 2592, 2616, 2616, 2790], [2791, 2791, 2815, 2815, 3030], [3031, 3031, 3055, 3055, 3266], [3267, 3267, 3291, 3291, 3385], [3386, 3386, 3410, 3410, 3541], [3544, 3544, 3567, 3567, 4647], [4650, 4650, 4674, 4674, 4902], [4904, 4904, 4938, 4938, 5120], [5122, 5505, 5558, 5558, 5834], [6047, 6047, 6131, 6131, 6796], [6798, 6798, 6847, 6847, 7412], [7414, 7414, 7446, 7446, 7866], [7868, 7868, 7916, 7916, 8344], [8346, 8346, 8410, 8410, 8588], [8590, 8642, 8675, 8675, 9035], [9038, 9038, 9075, 9075, 9350], [9352, 9352, 9409, 9409, 10751]], "test": "error"}
{"id": "wdsGz4", "name": "craving a slice of ", "author": "_kitzume_", "description": "This is a rainbow gradient from blue on the left to red on the right. It's basically the code from \"heatmap generation\" by uynet, deconstructed by me with once again lots and lots and lots of comments. Time element added for flash.", "tags": ["gradient", "rainbow", "gradation", "timebased"], "likes": 3, "viewed": 481, "published": "Public API", "date": "1545259958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FRAGMENT SHADER for ShaderToy\n\n////////////////////////////////////////////////////\n//                                               //\n//         Code partially based on             //\n//      \"heatmap generation\" by uynet        //\n//  https://www.shadertoy.com/view/WslGRN  //\n//                                          //\n//         Code edited by .           //\n//      Comments composed by .         //\n//                                             //\n//////////////////////////////////////////////////\n\n// #include math.h  \n// ERROR : Invalid Directive: include\n/* \"Shaders can't read files and thus, you will never find an include \n    statement in one.\"\n*/\n\n// Pi calculated out to 360 decimal places!\n// float pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360;\n// ERROR: token too long (Oddly, KodeLife seems to be okay with this super long value.)\n\n/* \"Using pi() calculated out to only 39 decimal places would allow one \n    to compute the circumference of the entire universe to the accuracy of \n    less than the diameter of a hydrogen atom. As it turns out, its totally \n    overkill to get that precise with it. Dividing 22 by 7 gives an estimate \n    that works for most everyday needs, such as carpentry and construction \n    (its roughly 99% accurate).\"\n*/\n\n   float pi = 3.141592653589793238462643383279502884197;\n\n// float   = 3.141592653589793238462643383279502884197;\n\n/* ShaderToy doesn't seem to mind if I use  as a variable name, but KodeLife \n   converts the  to a ? and complains that there is a syntax error. Since I like\n   to port, I will stay away from special characters in variable names. They are\n   too hard to type anyways.\n*/\n\n/* Definition of pi used in math.h C library:\n\n     #define M_PI 3.1415926535897932384;\n\n   \"Dividing 22 by 7 gives an estimate that works for most everyday needs.\n\n     #define M_PI 3.142857142857143;\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n /* fragCoord (or gl_fragCoord) is a special read-only input variable \n    with global scope (available to both the CPU and the GPU). fragCoord\n    can only be referenced from within a fragment shader.\n */\n\n    vec2 pixelCoord = fragCoord.xy/iResolution.xy; \n /* pixelCoord normalizes the x,y values of fragCoord to be between 0 and 1.\n\n        The x coordinate represents the horizontal value.\n        When x = 0, the pixel is on the leftmost side of the screen.\n        When x = 1, the pixel is on the rightmost side of the screen.\n        \n        The y coordinate represents the vertical value.\n        When y = 0, the pixel is at the bottom of the screen.\n        When y = 1, the pixel is at the top of the screen.\n */\n        \n    float R = 0.0;\n    float G = 0.0;\n    float B = 0.0;\n    \n    vec3 color = vec3 ( R, G, B);   // initializing color to black\n\n/* color represents the mixed RGB color, which is later passed to fragColor\n    The individual values can also be referenced as:\n\n        color.r = red\n        color.g = green\n        color.b = blue\n*/       \n    \n// This is where the fun begins.     :)\n    \n//  R = 3.143141592653589793238462643383279502884197;\n//  R = pi;\n//  R = ;\n//  R = pi/2.0;\n//  R = 1.57;\n/*  The lines above all create a completely red screen because the maximum \n    value of a color in fragColor is 1.\n*/\n    \n//  R = pixelCoord.x;\n/*  The code above produces a smooth, even gradient from black on the left \n    to red on the right.\n*/\n\n//  R = pixelCoord.x * pi;   \n/*  The code above creates a screen where the leftmost 1/3 of the screen is a black to red \n    gradient while the rightmost side is completely red. (pi * 0.318 = 1, therefore for every x\n    coordinate pixel between 0.318 and 1, when multiplied by pi, the value is greater than 1 and\n    thus a solid red.\n*/\n\n//  R = pixelCoord.x * (pi/2.0) ; \n/*  The maximum value of /2 is roughly 1.57, this makes the black to red gradient on \n    the left-hand side of the screen cover roughly 2/3. Smart! Because it approximates\n    the beautiful GOLDEN RATIO !  (Nothing shitty here. Just want to see if I can \n    use emojis in the comments of my code.) The Greek letter phi  \"varphi\" or \n     \"phi\" represents the golden ratio. The golden ration = 1.61803398875.\n*/\n\n//  R = pixelCoord.x/2.0;\n/*  Gradient is in the middle and begins with black on the left up to maroon on the right. */\n\n// R = 0.5;\n/* Entire screen is maroon. */\n\n// R = sin(pixelCoord.x*(pi));\n/* Black on the left, red in the middle, black on the right. Why?\n   The x coordinate has a range from 0 to 1.\n\n\t0 * 3.14 = 0\n\t1 * 3.14 = 3.14\n\n   Therefore the range of x * pi is 0 to 3.14.\n\n\tThe sin(0) = 0 \n\tThe sin(3.14) = 0.05\n\n   0 = black and 0.05 is close enough to 0 to be black to the human eye.\n\n   The middle of the screen, where it is bright red, has an x-coordinate of 0.5.\n\n\t0.5 * 3.14 = 1.57\n\n\tsin(1.57) = 0.03\n\n   Im lost. 0.03 is closer to black than 0.05, so why is it red in the middle?\n*/\n\n// R = sin(pixelCoord.x*pi/2.0) ;\n   R = sin(pixelCoord.x*pi/2.0) * abs(cos(iTime)) ;\n\n\n// G = pixelCoord.x*pi ;\n// G = pixelCoord.x*(pi) ;\n// G = sin(iTime); \n// G = sin(pixelCoord.x*(pi));\n\n// G = sin(pixelCoord.x*(pi)) ;\n   G = sin(pixelCoord.x*(pi)) * abs(cos(iTime)) ;\n\n    \n// B = pixelCoord.x;  // evenly distributed gradient from black (left) to blue (right)\n// B = cos(pixelCoord.x);  // nearly a completely blue screen, slightly dimmer on right edge\n/* The cosine of 0 is 1.\n   The cosine of 1 is 0.999847695156391.\n*/\n// B = cos(pixelCoord.x*(pi));  \n// B = cos(pixelCoord.x*pi);\n// B = cos(pixelCoord.x*pi/2.0);\n\n// B = cos(pixelCoord.x*pi/2.0) ;\n   B = cos(pixelCoord.x*pi/2.0) * abs(cos(iTime));\n\n    \n    color = vec3 ( R, G, B);\n\n\n// Output to screen\n\n    fragColor = vec4 (color,1.0);\n\n// This part is for testing purposes to see what each of the color values are doing standalone. \n\n//   fragColor = vec4 (color.r, 0.0, 0.0, 1.0); // red channel\n//   fragColor = vec4 (0.0, color.g, 0.0, 1.0); // green channel\n//  fragColor = vec4 (0.0, 0.0, color.b, 1.0); // blue channel\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2264, 2264, 2321, 2528, 6415]], "test": "ok"}
{"id": "WdsGzH", "name": "Projective Light Show", "author": "mla", "description": "A light show for the festive season: generate random 3D projective transformations and use to transform a glowing cube.", "tags": ["lightshow", "projective", "svd", "singularvalue", "randomrotation"], "likes": 6, "viewed": 633, "published": "Public API", "date": "1544977122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// (c) Matthew Arcus 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// A festive light show: generate random 4D linear transformations, from\n// a random scaling sandwiched between two random rotations (each generated\n// from two random quaternions). This is essentially a singular value\n// decomposition for the resulting matrix (we have the decomposition by\n// construction rather than having to compute it, for that see\n// https://www.shadertoy.com/view/XlsGRl by paniq).\n//\n// The random transformation is then used to projectively transform a cube in\n// 3D projective space using separate interpolation on the two rotations and\n// the diagonal scaling matrix.\n//\n// Mouse changes camera position.\n// 'c': toggle camera rotation\n// 'r': toggle rotation in transformation\n// 's': toggle scaling in transformation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float scale = 1.0;\nconst float A = 0.5; // Light amplitude\nconst float K = 0.4; // Concentration\nconst float R = 0.2; // Radius\nconst float PI = 3.14159265359;\n\nbool dorotation = true;\nbool doscaling = true;\nbool docamerarotation = true;\n\nbool alert = false;\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n// Quaternion left and right multiplication as matrices\n// The two forms commute (this is just associativity).\nmat4 qmat_left(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t, z,-y,-x, \n              -z, t, x,-y,\n               y,-x, t,-z,\n               x, y, z, t );\n}\n\nmat4 qmat_right(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y,-x, \n               z, t,-x,-y,\n              -y, x, t,-z,\n               x, y, z, t );\n}\n\nvec2 closest(vec4 p,vec4 q,vec4 r,vec4 s) {\n  // Find k and j such that p+kq and r+js are the closest points.\n  // Use Cramer's rule to solve linear system\n  //(p+kq-r-js).q = 0 -> p.q+kq.q-r.q-js.q = 0 => kq.q - js.q = -p.q+r.q\n  //(p+kq-r-js).s = 0 -> p.s+kq.s-r.s-js.s = 0 => kq.s - js.s = -p.s+r.s\n  vec2 c0 = vec2(dot(q,q),dot(q,s));\n  vec2 c1 = vec2(-dot(q,s),-dot(s,s));\n  vec2 a = vec2(dot(r-p,q),dot(r-p,s));\n  float d0 = determinant(mat2(a,c1)); // replace c0 with a\n  float d1 = determinant(mat2(c0,a)); // replace c1 with a\n  return vec2(d0,d1)/determinant(mat2(c0,c1));\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\n// Numerical Recipes 32-bit Linear Congruential Generator\nuint seed = 1U;\nuint lcg() {\n  seed *= 1664525U;\n  seed += 1013904223U;\n  return seed;\n}\n\n// Wang Hash, used to seed LCG\nuint ihash(uint a) {\n  a = (a ^ 61U) ^ (a >> 16);\n  a *= 9U;\n  a = a ^ (a >> 4);\n  a = a * 0x27d4eb2dU;\n  a = a ^ (a >> 15);\n  return a;\n}\n\n// Uniform random float in [0,1)\nfloat random() {\n  return float(lcg())/pow(2.0,32.0);\n}\n\n// Construct a uniformly distributed point on a sphere.\nvec3 randomspherepoint() {\n  float theta = 2.0*PI*random(); // Random azimuth\n  float z = 2.0*random()-1.0;    // z in [-1,1]\n  float r = sqrt(1.0-z*z);       // Sphere radius at z\n  return vec3(r*cos(theta),r*sin(theta),z);\n}\n\nfloat randomscalefactor(float t) {\n  //float s = -2.0*log(random());\n  //float s = 0.5/(random()-0.5);\n  //float s = inversesqrt(random());\n  float s = 1.0/random();\n  t = 2.0*min(t,1.0-t);\n  float res = mix(1.0,s,smoothstep(0.0,1.0,t));\n  return res;\n}\n\nmat4 randomscaling(float t) {\n  return mat4(randomscalefactor(t),0,0,0,\n              0,randomscalefactor(t),0,0,\n              0,0,randomscalefactor(t),0,\n              0,0,0,randomscalefactor(t));\n}\n\nvec4 randomquaternion(float t) {\n  vec3 axis = randomspherepoint();\n  float theta = PI*(random()-0.5);\n  t = min(t,1.0-t);\n  theta *= smoothstep(0.0,0.5,t);\n  return vec4(sin(theta)*axis,cos(theta));\n}\n\n// General a random R4 rotation, from two\n// random quaternions.\nmat4 randomrotation(float t) {\n  mat4 left = qmat_left(randomquaternion(t));\n  mat4 right = qmat_right(randomquaternion(t));\n  //assert(eq(left*right,right*left));\n  return left*right;\n}\n\nmat4 setmatrix(float t) {\n  t /= 10.0;\n  uint epoch = uint(floor(t));\n  seed = ihash(epoch);\n  t = fract(t);\n  if (true) {\n    // 4 seconds each out and back, with a 1 second pause between.\n    t *= 1.25;\n    if (t > 0.5) t = max(t-0.125,0.5);\n    if (t > 1.0) t = max(t-0.125,1.0);\n  }\n  mat4 m = mat4(1);\n  if (dorotation) m *= randomrotation(t);\n  if (doscaling) m *= randomscaling(t);\n  if (dorotation && doscaling) m *= randomrotation(t);\n  return m;\n}\n\n// A cube, centre of side and side direction.\nvec4 lines[] = vec4[]\n  (vec4(1,1,0,1),vec4(0,0,1,0),\n   vec4(1,-1,0,1),vec4(0,0,1,0),\n   vec4(-1,-1,0,1),vec4(0,0,1,0),\n   vec4(-1,1,0,1),vec4(0,0,1,0),\n\n   vec4(1,0,1,1),vec4(0,1,0,0),\n   vec4(1,0,-1,1),vec4(0,1,0,0),\n   vec4(-1,0,-1,1),vec4(0,1,0,0),\n   vec4(-1,0,1,1),vec4(0,1,0,0),\n   \n   vec4(0,1,1,1),vec4(1,0,0,0),\n   vec4(0,1,-1,1),vec4(1,0,0,0),\n   vec4(0,-1,-1,1),vec4(1,0,0,0),\n   vec4(0,-1,1,1),vec4(1,0,0,0));\n   \n\nvoid getline(int i, mat4 m, out vec4 r, out vec4 s) {\n  vec4 r0 = m*lines[2*i];\n  vec4 s0 = m*lines[2*i+1];\n  r  = r0/r0.w;\n  // Normalization not needed for the vector algebra, but\n  // we need to measure along the line consistently.\n  s = normalize(r0*s0.w-r0.w*s0);\n}\n\nvec4 transform(in vec4 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (docamerarotation) {\n    p.yz = rotate(p.yz, 0.123*iTime);\n    p.zx = rotate(p.zx, 0.2*iTime);\n  }\n  return p;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  docamerarotation = !keypress(CHAR_C);\n  dorotation = !keypress(CHAR_R);\n  doscaling = !keypress(CHAR_S);\n\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  float camera = 3.0;\n  vec4 p = vec4(0,0,camera,1);\n  vec4 q = vec4(xy,-1,0);\n  p = transform(p);\n  q = normalize(transform(q));\n  vec3 color = vec3(0); // Accumulate color here\n  mat4 m = setmatrix(iTime);\n  for (int i = 0; i < 12+min(int(iTime),0); i++) {\n    vec4 r,s;\n    getline(i,m,r,s);\n    vec2 k = closest(p,q,r,s);\n    vec4 p1 = p+k.x*q;\n    vec4 r1 = r+k.y*s;\n    float d = distance(p1/p1.w,r1/r1.w);\n    float h = mod(0.3*(-iTime+log(1.0+abs(k.y))),1.0);\n    vec3 basecolor = hsv2rgb(vec3(h,1.0,1.0));\n    color += A*float(k.x > 0.0)*(1.0-pow(smoothstep(0.0,R,d),K))*basecolor;\n  }\n  outColor = vec4(sqrt(color),1.0);\n  if (alert) outColor = vec4(1,0,0,1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsGzH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1297, 1297, 1318, 1318, 1344], [1346, 1346, 1373, 1373, 1401], [1403, 1403, 1428, 1428, 1497], [1499, 1499, 1524, 1524, 1601], [1603, 1714, 1738, 1738, 1895], [1897, 1897, 1922, 1922, 2079], [2081, 2081, 2124, 2382, 2665], [2667, 2667, 2697, 2697, 2747], [2823, 2823, 2835, 2835, 2895], [2897, 2928, 2948, 2948, 3066], [3068, 3101, 3117, 3117, 3156], [3158, 3214, 3240, 3240, 3440], [3442, 3442, 3476, 3581, 3695], [3697, 3697, 3726, 3726, 3897], [3899, 3899, 3931, 3931, 4100], [4102, 4167, 4197, 4197, 4353], [4355, 4355, 4380, 4380, 4812], [5289, 5289, 5342, 5342, 5559], [5561, 5561, 5588, 5588, 5923], [5925, 6020, 6047, 6047, 6223], [6295, 6295, 6320, 6320, 6380], [6382, 6382, 6433, 6433, 7304]], "test": "error"}
{"id": "WdsGzM", "name": "gears2d", "author": "oo_miguel", "description": "My Hello World of Fragment Shading", "tags": ["2d", "tiling"], "likes": 2, "viewed": 123, "published": "Public", "date": "1545436906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec2 rotate2d(vec2 uv,float _angle){return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle)) * uv;}\nvec2 scale2d(vec2 uv,float _scale){return  uv * mat2(_scale,0.0,0.0,_scale);}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(20.,100.)))*10000.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv=rotate2d(uv,1.+fract(iTime*0.02)*2.*PI);\n    uv*=5.+0.4*sin(iTime/2.);\n    \n        \n    vec2 pos = vec2(0.5)-fract(uv);\n    pos=rotate2d(pos,fract(iTime*0.4+random(floor(uv)))*2.*PI);\n    pos=scale2d(pos,0.5+sin(random(uv+fract(iTime)*2.*PI)));\n    \n    \n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n\tfloat f = smoothstep(-.0,1., cos(a*max(3.,floor(abs(uv.x))*floor(abs(uv.y)))))*0.3+0.5;\n    vec3 color = vec3( 1.-smoothstep(f,f+0.02,r) );\n    fragColor = vec4(color*vec3(0.1,0.5*random(floor(uv)),0.8+0.1*sin(2.*PI*fract(iTime*0.3))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 62, 62, 130], [131, 131, 166, 166, 208], [210, 210, 234, 234, 293], [295, 295, 352, 352, 1003]], "test": "ok"}
{"id": "WdX3WH", "name": "chess hydraulic press", "author": "morisil", "description": "Use your mouse to look around .A variation of my previous \"endless chessboard\" shader.\n\nhttps://www.shadertoy.com/view/Wdf3D8", "tags": ["mouse", "endless", "loop", "checker", "rotation", "perspective", "double", "chess", "chessboard", "hydraulic", "press"], "likes": 2, "viewed": 328, "published": "Public API", "date": "1545950795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 5.0\n\n#define EDGE_SHARPNESS 20000.0\n\n#define AIR_PERSPECTIVE 2.0\n\nvec2 toCanonicalCoordinates(vec2 pixel) {\n    return (pixel -.5 * iResolution.xy) / iResolution.y;\n}\n\nmat2 rotate2d(float angle){\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n}\n\nfloat getChessboardLuminance(vec2 point) {\n    float value =\n        (1.0 - pow(sin(point.x), EDGE_SHARPNESS))\n        * sign(cos(point.x));\n    value *=\n        (1.0 - pow(sin(point.y), EDGE_SHARPNESS))\n        * sign(cos(point.y));\n    return (value + 1.0) / 2.0;    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 point = toCanonicalCoordinates(fragCoord);\n    vec2 mouse = toCanonicalCoordinates(iMouse.xy);\n    point += vec2(0, mouse.y);\n    point *= rotate2d(sin(iTime * 0.9) * 0.2);\n    vec2 trans = vec2(point.x / point.y, 1.0 / point.y);\n    trans *= rotate2d(mouse.x);\n    // double press effect\n    trans *= SCALE + (sin(iTime) * 0.9 * SCALE);\n    \n\tfloat luminance = getChessboardLuminance(trans);\n\n    // apply air perspective\n    luminance *= pow(abs(point.y * 2.0), AIR_PERSPECTIVE);\n    fragColor = vec4(vec3(luminance),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdX3WH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 121, 121, 180], [182, 182, 209, 209, 299], [301, 301, 343, 343, 572], [575, 575, 630, 630, 1163]], "test": "ok"}
{"id": "wdXGD4", "name": "bandersnatch", "author": "bitnenfer", "description": "bandersnatch", "tags": ["logo"], "likes": 2, "viewed": 75, "published": "Public", "date": "1546223929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    vec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * aspectRatio;\n    vec2 uv2 = vec2(1.4, 1.3) * ((fragCoord.xy / iResolution.xy - 0.5) * aspectRatio) + vec2(0.0, -0.13);\n\n    if ((abs(uv2.x) < 0.15 && abs(uv2.y) < 0.25) ||\n        (uv2.x < -0.1 && uv2.x > -0.4 && uv2.y < -0.0 && uv2.y > -0.5) || \n        (uv2.x > 0.1 && uv2.x < 0.4 && uv2.y < -0.0 && uv2.y > -0.5))\n    { \n        color = vec3(1.0);\n    }\n    \n    color = mix(color * 6.0, color * pow(1.0 - length(uv / aspectRatio), 5.0), 0.999);\n    color += 0.1 * max(vec3(sin(fragCoord.y / iResolution.y * 300.0 + iTime * 20.)), 0.4);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXGD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 781]], "test": "ok"}
{"id": "wdXGDr", "name": "Cylinder - distance", "author": "iq", "description": "The SDF to an arbitrarily oriented flat-caped cylinder, with only 2 square roots and one division.", "tags": ["3d", "sdf", "distance", "cylinder"], "likes": 12, "viewed": 2050, "published": "Public API", "date": "1545715451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Cylinder intersection: https://www.shadertoy.com/view/4lcSRn\n// Cylinder bounding box: https://www.shadertoy.com/view/MtcXRf\n// Cylinder distance:     https://www.shadertoy.com/view/wdXGDr\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat map( in vec3 pos )\n{\n    return sdCylinder(pos, vec3(-0.2,-0.3,-0.1), vec3(0.3,0.3,0.4), 0.2 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n        \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 3.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXGDr.jpg", "access": "shaders20k", "license": "mit", "functions": [[1418, 1418, 1469, 1469, 1835], [1837, 1837, 1863, 1863, 1940], [1942, 2006, 2038, 2038, 2277]], "test": "ok"}
{"id": "WdXGzN", "name": "Hold This", "author": "DWishR", "description": "Found a cool pattern", "tags": ["shader"], "likes": 0, "viewed": 85, "published": "Public", "date": "1545090853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 fmod(vec2 x, vec2 y)\n{\n    return x - y * trunc(x/y);\n}\n\nfloat fmod(float x, float y)\n{\n    return x - y * trunc(x/y);\n}\n\nvec2 fmod(vec2 x, float y)\n{\n    return fmod(x, vec2(y,y));\n}\n\nvec2 uv0to1(vec2 pos)\n{\n    vec2 uvModified = mod(abs(pos),2.0);\n    vec2 invert = floor(uvModified);\n    uvModified = (invert*2.0 - uvModified) \n        * (-1.0*(1.0-invert)+1.0 *invert);\n    return uvModified;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv0to1(uv*3.0 - 1.5);\n    \n    \n    float amount = fmod(iTime * 0.25, 0.5);\n    amount = iTime * 0.25;\n    vec2 fromCenter = uv - 0.5;\n    vec2 norm = fromCenter;\n    norm = normalize(norm);\n    fromCenter += norm + amount;\n    fromCenter = fmod(fromCenter, 0.5);\n    vec2 newPos = fromCenter * 2.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+vec3(0,2,4));\n    //col = vec3(0.0,0.8,0.8);\n\tvec3 colb = 0.5 + 0.5*cos(vec3(0,2,4)+iTime+2.0);\n    //colb = vec3(0.44, 0.04, 0.30);\n    col *= max(newPos.x,0.0);\n    colb *= max(newPos.y,0.0);\n    vec3 res = col + colb;\n\n    // Output to screen\n    fragColor = vec4(newPos.x, 0.0, newPos.y, 1.0);\n    fragColor = vec4(res.x,res.y,res.z,1.0);\n    //fragColor = vec4(col.x,col.y,col.z,1.0);\n    //fragColor = vec4(colb.x,colb.y,colb.z,1.0);\n    //fragColor = vec4(0, 1.0, 1.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 60], [62, 62, 92, 92, 125], [127, 127, 155, 155, 188], [190, 190, 213, 213, 403], [405, 405, 462, 462, 1363]], "test": "ok"}
{"id": "Wsf3Dn", "name": "gloopy", "author": "Del", "description": "gloopy", "tags": ["gloopy"], "likes": 3, "viewed": 353, "published": "Public API", "date": "1545607082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// GLOOPY\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opUnionRound(const in vec2 a, const in vec2 b, const in float r)\n{\n    vec2 res = vec2(smin(a.x,b.x,r),(a.x<b.x) ? a.y : b.y);\n    return res;\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n    \n#define\tTAU 6.28318\n#define CHS 0.35\nfloat sdBox2(in vec2 p,in vec2 b) {vec2 d=abs(p)-b;return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);}\nfloat line2(float d,vec2 p,vec4 l){vec2 pa=p-l.xy;vec2 ba=l.zw-l.xy;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return min(d,length(pa-ba*h));}\nfloat LR(vec2 p, float d){p.x=abs(p.x);return line2(d,p,vec4(2,-3.25,2,3.25)*CHS);}\nfloat TB(vec2 p, float d){p.y=abs(p.y);return line2(d,p,vec4(2,3.25,-2,3.25)*CHS);}\nfloat TBLR(vec2 p, float d){return min(d,abs(sdBox2(p,vec2(2,3.25)*CHS)));}\nfloat G(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(2,2.25,2,3.25)*CHS);d=line2(d,p,vec4(2,-3.25,2,-0.25)*CHS);return line2(d,p,vec4(2,-0.25,0.5,-0.25)*CHS);}\nfloat L(vec2 p,float d){d=line2(d,p,vec4(2,-3.25,-2,-3.25)*CHS);return line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);}\nfloat O(vec2 p,float d){return TBLR(p,d);}\nfloat P(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,0.0)*CHS);p.y-=1.5*CHS;return min(d,abs(sdBox2(p,vec2(2.0,1.75)*CHS)));}\nfloat Y(vec2 p,float d){d=line2(d,p,vec4(0,-0.25,0,-3.25)*CHS);p.x=abs(p.x);return line2(d,p,vec4(0,-0.25,2,3.25)*CHS);}\n\nfloat message(vec3 p)\n{\n\tfloat d = 1.0;\n\tfloat cw = 5.8*CHS;\n\tfloat gap = (cw*2.0)+40.0;\n\tfloat width = (16.0*cw);\n\tfloat xmod = width+gap;\n    \n\tfloat c = pMod1(p.z,9.0);\n\tp.z -= 0.2+sin(p.x*1.3+fract(iTime*0.05)*TAU)*0.08;\n\tp.x += fract(iTime*0.075)*xmod+c*16.0;\n\tpMod1(p.x, xmod);\n\tvec2 uv = p.xy;\n\tfloat x = -((width*0.5+gap*0.5)-cw);\n\tfloat t1 = fract(iTime*0.5) * TAU;\n\tfloat y = -1.0+sin(t1+p.x*0.25)*0.5;\n\tuv-=vec2(x,y);\n\td = G(uv,d); uv.x -= cw;\n\td = L(uv,d); uv.x -= cw;\n\td = O(uv,d); uv.x -= cw;\n\td = O(uv,d); uv.x -= cw;\n\td = P(uv,d); uv.x -= cw;\n\td = Y(uv,d);\n\td -= 0.1;\n\tif (d<1.0)\n\t{\n\t\tfloat dep = 0.025;\n\t\tvec2 e = vec2( d, abs(p.z) - dep );\n\t\td = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n\t\td -= 0.325*CHS;\n\t}\n\treturn d;\n}\n\nmat2 rot(float a)\n{\n\tfloat c = cos(a),\n\t\ts = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p)\n{\n\tfloat t2 = fract(iTime*0.05) * TAU;\n\tp.xy *= rot(p.y*0.02+p.x*0.04-p.z * .05 + t2);\n\tfloat k = dot(sin(p.z+2. * p - cos(p.yxz)), vec3(.233));\n\tk-=sin(p.x*p.y+p.z)*0.14;\n\tk*=0.7+sin(fract(iTime*0.54)*TAU+p.z*1.4)*0.35;\n\tfloat d = 2.5 -abs(p.y) - k*k;\n\tfloat dm = message(p);\n\td = smin(d,dm,0.75);\n\treturn d;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\tvec3 n;\n\tn.x = map(p + e.xyy) - map(p - e.xyy);\n\tn.y = map(p + e.yxy) - map(p - e.yxy);\n\tn.z = map(p + e.yyx) - map(p - e.yyx);\n\treturn normalize(n);\n}\n\nvec3 render(vec2 uv) {\n\t\n\tvec3 ro = vec3(sin(iTime)*0.15, cos(iTime*0.5)*0.2, iTime*0.75);\n\tvec3 rd = normalize(vec3(uv, .8));\n\tvec3 p = vec3(0.);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 80; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += .5 * d;\n\t}\n\tvec3 l = ro;\n\tvec3 n = normal(p);\n\tvec3 lp = normalize(l - p);\n\tfloat diff = .5 * max(dot(lp, n), 0.);\n\treturn vec3(diff*0.65,diff*1.49,diff*0.65) / (1. + t * t * .01);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfragColor = vec4(render(uv), 1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3Dn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[11, 11, 52, 52, 145], [298, 473, 513, 513, 634], [677, 677, 712, 712, 783], [784, 784, 819, 819, 928], [929, 929, 955, 955, 1012], [1013, 1013, 1039, 1039, 1096], [1097, 1097, 1125, 1125, 1172], [1173, 1173, 1197, 1197, 1370], [1371, 1371, 1395, 1395, 1481], [1482, 1482, 1506, 1506, 1524], [1525, 1525, 1549, 1549, 1650], [1651, 1651, 1675, 1675, 1771], [1773, 1773, 1796, 1796, 2514], [2516, 2516, 2535, 2535, 2597], [2599, 2599, 2618, 2618, 2928], [2930, 2930, 2951, 2951, 3130], [3132, 3132, 3154, 3154, 3593], [3596, 3596, 3653, 3653, 3755]], "test": "error"}
{"id": "Wsf3zr", "name": "ufo ball", "author": "Del", "description": "ufo ball? :)", "tags": ["2d", "ball", "hsv", "ufo"], "likes": 4, "viewed": 351, "published": "Public API", "date": "1544669744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n\tvec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;    \n\tuv *= 18.0;\n\tuv.x *= sin(iTime-uv.y*.125)+1.61;\n\tuv.y *= sin(iTime-uv.y*.125)+1.61;\n\tfloat d = length(uv)*0.06;\n\td = d*d;\n\tfloat a = sin(iTime*0.61)*d;\n\tvec3 col = hsv2rgb_smooth(vec3(fract(iTime*0.4)+(uv.y+uv.x*a)*((d+0.5)*0.05),1.2-d,0.9-d));\n\tfragColor = vec4(col, 1.0);\n}\n \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 35, 35, 208], [210, 210, 267, 267, 613]], "test": "ok"}
{"id": "wsfGDr", "name": "Mandelbrot Borders", "author": "g4b0r", "description": "Yet another shader to visualize the Mandelbrot set. I wanted to see what it would look like if I rendered the borders, where the number of iterations required increases.", "tags": ["2d", "fractal", "mandelbrot", "mandel"], "likes": 7, "viewed": 390, "published": "Public API", "date": "1546068067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Gabor Nagy (gabor.nagy@me.com)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// December 28, 2018\n//\n// Yet another shader to visualize the Mandelbrot set. I wanted to see what it would \n// look like if I rendered the borders, where the number of iterations required \n// increases.\n\n#define AA 2\n#define MAX_ITERATIONS 750\n\n#define BACKGROUND_COLOR vec3(.95,.95,.95)\n#define MANDELBROT_COLOR vec3(1., .5, 0.)\n#define OUTLINE_COLOR vec3(0.,0.,1.)\n\n// Calculates the iterations needed to escape the mandelbrot set.\nint mandelbrot(vec2 uv)\n{    \n    vec2 c = uv;    \n    vec2 z = vec2(.0, .0);\n    \n    for(int i=0; i<MAX_ITERATIONS; i++)\n    {       \n    \tz = vec2( (z.x*z.x)-(z.y*z.y), 2.0*z.x*z.y) + c;\n\t\tif(dot(z,z) > 4.0)\n\t\t{\n            return i;\n\t\t}\n    }\n    return MAX_ITERATIONS;\n}\n\n// Maps from pixel coordinates to mandelbrot coordinates, and handles zooming.\nvec2 calculateUV(vec2 p) {\n\tvec2 uv = (vec2(p.x, p.y) / iResolution.xy) * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Zoom in and out as a function of iTime from -1. to 8.\n    float zoom = 8. - (cos(iTime / 3.) * 4.5 + 4.5); \n    uv *= 1. / exp(zoom);\n\n    // Zoom somewhere interesting.\n    uv.x -= 0.98990;\n    uv.y -= 0.30934;\n\n    return uv;\n}\n\n// Calculates the pixel color at point p.\nvec3 render(vec2 p) {\n\n\tvec3 color = BACKGROUND_COLOR;\n    \n    int iterations = mandelbrot(calculateUV(p));\n    \n    if (iterations == MAX_ITERATIONS) {\n        // We're inside the mandelbrot set.\n        color = MANDELBROT_COLOR;\n    } else {\n        \t    \n        // Calculate the iterations needed nearby.\n        int left = mandelbrot(calculateUV(p+vec2(-1.0,0.)));\n    \tint top = mandelbrot(calculateUV(p+vec2(0.,1.0)));\n        \n\t\t// Looks like abs() doesn't work for int on iOS.\n        float iterationJump = max(abs(float(left - iterations)), \n                                  abs(float(top - iterations)));\n\n        if (iterationJump > 0.) {\n            // If the iteration change is greater than zero, we're on a border.\n    \t\tcolor = OUTLINE_COLOR - vec3(min(.7, float(iterationJump) / 40.));\n    \t}    \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    for( int m=0; m<AA; m++ ) {\n        for( int n=0; n<AA; n++ ) {\n\t\t\tvec2 p = fragCoord + (vec2(float(m),float(n)) / float(AA) - 0.5);\n    \t\tcolor += render(p);\n        }\n    }\n    \n    color /= float(AA*AA);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfGDr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[505, 571, 596, 596, 846], [848, 927, 953, 953, 1294], [1296, 1338, 1359, 1359, 2185], [2187, 2187, 2244, 2244, 2524]], "test": "ok"}
{"id": "WsfGR8", "name": "Julia c = (0.285, 0)", "author": "virgil81188", "description": "Learning Julia sets", "tags": ["julia"], "likes": 0, "viewed": 49, "published": "Public", "date": "1544806133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 julia(vec2 z, vec2 c)\n{\n    int it = 0;\n    int maxIt = 100;\n    float x = 0.0;\n    vec2 oldZ = z;\n    while (dot(z,z) < 4.0 && it < maxIt)\n    {\n        x = z.x*z.x - z.y*z.y;\n        z.y = 2.0*z.x*z.y + c.y;\n        z.x = x + c.x;\n        it++;\n    }\n    if (it == maxIt)\n    {\n\t\treturn vec3(1,1,1);\n    }\n    else\n    {\n        float v;\n    \tv = pow(0.5 * 2.0 * 3.141592 * float(it)/float(maxIt), 0.25);\n        return vec3(pow(v, 2.0 + (0.5 + 0.5 * sin(iTime))), pow(v, 2.0 + (0.5 + 0.5 * sin(iTime * 0.7))), pow(v, 2.0 + (0.5 + 0.5 * sin(iTime * 0.5))));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / float(iResolution.y);\n\n    // Time varying pixel color\n    vec2 c = vec2(0.285 + 0.025 * sin(0.66 * iTime), 0.01 * sin(iTime * 0.5));\n    float size = 2.5;\n    vec3 col = julia((uv - vec2(0.5, 0.5)) * vec2(size * aspectRatio, size) - c*0.5, c);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 572], [574, 574, 631, 681, 1064]], "test": "ok"}
{"id": "WsfGRN", "name": "rotating tiling  (289 chars)", "author": "FabriceNeyret2", "description": "shorter & more direct algorithm -> here [url]https://www.shadertoy.com/view/wsX3zN[/url]", "tags": ["2d", "2tweets", "short", "golf"], "likes": 4, "viewed": 378, "published": "Public API", "date": "1545083399", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/WsfGz4\n// shorter & more direct algorithm: https://www.shadertoy.com/view/wsX3zN\n\n// 289 ( + rot: 33 )\n\n#define C(U) o -= smoothstep(0., 3./R.y, .3 - max(abs(U.x+ .3+min(t,.6-t)), \\\n                                                  abs(U.y+ .3-t) ) ); //\n#define D C(U) C(vec2(-U.y,U))                             \\\n          U += 2.* vec2( min(.3,.6-t), -min(t,.3) )       //\n#define E D; D; D; U = V = vec2(-V.y,V)                   //\nvoid mainImage(out vec4 O, vec2 u) {\n    float t = .3* mod(iTime,2.);\n    vec2  R = iResolution.xy,\n          U = (u+u - R) / R.y * mat2(cos(vec4(0,33,11,0) -iTime )),\n          V = U;\n    vec4 o = ++O; E; E; E; E; O = o; }                      /* \n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 515, 515, 702]], "test": "error"}
{"id": "wsfGWH", "name": "Rayleigh/Mie Day and Night Cycle", "author": "Elyxian", "description": "This is an attempt to implement the Nishita atmospheric scattering model for Rayleigh and Mie scattering as described by Scratchapixel\n\nSee https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky", "tags": ["sunset", "sky", "scattering", "night", "skybox", "rayleigh", "day", "mei", "scratchapixel"], "likes": 5, "viewed": 822, "published": "Public", "date": "1546005707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Also see https://www.shadertoy.com/view/lslXDr by gltracy for another implementation\n\n// This is an attempt to implement the Nishita atmospheric scattering model for\n// Rayleigh and Mie scattering as described by Scratchapixel\n// see https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n\n// If you are trying to understand this implementation, reading the above link will help a lot\n\n// For another atmospheric scattering model, look at the Preetham model\n\n// By changing these constants, different/alien atmospheres can be achieved\n\n// This program is written with understanding in mind (hopefully) rather than performance. In\n// particular, the getSkyColor routine can be optimised so that the transmittance function does\n// not need to calculate redundant information (see the link above for information)\n\n// Mathematical Constants\nconst float PI = 3.14159265;\n\n// Planet Constants\nconst float EARTHRADIUS = 6360e3; // 6360e3\nconst float ATMOSPHERERADIUS = 6420e3; //6420e3\nconst float SUNINTENSITY = 20.0; //20.0\n\n// Rayleigh Scattering\nconst float RAYLEIGHSCALEHEIGHT = 7994.0; // 7994.0\nconst vec3 BETAR = vec3(3.8e-6, 13.5e-6, 33.1e-6);\n\n// Mie Scattering\nconst float MIESCALEHEIGHT = 1200.0; // 1200.0\nconst vec3 BETAM = vec3(210e-5, 210e-5, 210e-5);\nconst float G = 0.76;\n\n// --------------------------------------\n// ---------- Helper Functions-----------\n// --------------------------------------\n\n// Returns the matrix that rotates a given point by 'a' radians\n\nmat2 mm2(in float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n    \n}\n\n// The tone mapping function from Uncharted 2, as implemented by Zavie\n// From https://www.shadertoy.com/view/lslGzl\n\nvec3 Uncharted2ToneMapping(vec3 color) {\n    \n    float gamma = 2.2;\n    \n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n\n}\n\n// Returns the first intersection of the ray with the sphere (or -1.0 if no intersection)\n// From https://gist.github.com/wwwtyro/beecc31d65d1004f5a9d\n\nfloat raySphereIntersect(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius) {\n    \n    float a = dot(rayDirection, rayDirection);\n    vec3 d = rayOrigin - sphereCenter;\n    float b = 2.0 * dot(rayDirection, d);\n    float c = dot(d, d) - (sphereRadius * sphereRadius);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b + sqrt((b*b) - 4.0*a*c))/(2.0*a);\n    \n}\n\n// -------------------------------\n// ------- Main Functions --------\n// -------------------------------\n\n// The rayleigh phase function\nfloat rayleighPhase(float mu) {\n    float phase = (3.0 / (16.0 * PI)) * (1.0 + mu * mu);\n    return phase;\n}\n\n// The mie phase function\nfloat miePhase(float mu) {\n    float numerator = (1.0 - G * G) * (1.0 + mu * mu);\n    float denominator = (2.0 + G * G) * pow(1.0 + G * G - 2.0 * G * mu, 3.0/2.0);\n    return (3.0 / (8.0 * PI)) * numerator / denominator;\n}\n\n// Returns the expected amount of atmospheric scattering at a given height above sea level\n// Different parameters are passed in for rayleigh and mie scattering\nvec3 scatteringAtHeight(vec3 scatteringAtSea, float height, float heightScale) {\n\treturn scatteringAtSea * exp(-height/heightScale);\n}\n\n// Returns the height of a vector above the 'earth'\nfloat height(vec3 p) {\n    return (length(p) - EARTHRADIUS);\n}\n\n// Calculates the transmittance from pb to pa, given the scale height and the scattering\n// coefficients. The samples parameter controls how accurate the result is.\n// See the scratchapixel link for details on what is happening\nvec3 transmittance(vec3 pa, vec3 pb, int samples, float scaleHeight, vec3 scatCoeffs) {\n    float opticalDepth = 0.0;\n    float segmentLength = length(pb - pa)/float(samples);\n    for (int i = 0; i < samples; i++) {\n        vec3 samplePoint = mix(pa, pb, (float(i)+0.5)/float(samples));\n        float sampleHeight = height(samplePoint);\n        opticalDepth += exp(-sampleHeight / scaleHeight) * segmentLength;\n    }\n    vec3 transmittance = exp(-1.0 * scatCoeffs * opticalDepth);\n    return transmittance;\n}\n\n// This is the main function that uses the ideas of rayleigh and mie scattering\n// This function is written with understandability in mind rather than performance, and\n// redundant calls to transmittance can be removed as per the code in the scratchapixel link\n\nvec3 getSkyColor(vec3 pa, vec3 pb, vec3 sunDir) {\n\t\n    // Get the angle between the ray direction and the sun\n    float mu = dot(normalize(pb - pa), sunDir);\n    \n    // Calculate the result from the phase functions\n    float phaseR = rayleighPhase(mu);\n    float phaseM = miePhase(mu);\n    \n    // Will be used to store the cumulative colors for rayleigh and mie\n    vec3 rayleighColor = vec3(0.0, 0.0, 0.0);\n    vec3 mieColor = vec3(0.0, 0.0, 0.0);\n\n    // Performs an integral approximation by checking a number of sample points and:\n    //\t\t- Calculating the incident light on that point from the sun\n    //\t\t- Calculating the amount of that light that gets reflected towards the origin\n    \n    int samples = 10;\n    float segmentLength = length(pb - pa) / float(samples);\n    \n    for (int i = 0; i < samples; i++) {\n        \n    \tvec3 samplePoint = mix(pa, pb, (float(i)+0.5)/float(samples));\n        float sampleHeight = height(samplePoint);\n        float distanceToAtmosphere = raySphereIntersect(samplePoint, sunDir, vec3(0.0, 0.0, 0.0), ATMOSPHERERADIUS);\n    \tvec3 atmosphereIntersect = samplePoint + sunDir * distanceToAtmosphere;\n        \n        // Rayleigh Calculations\n        vec3 trans1R = transmittance(pa, samplePoint, 10, RAYLEIGHSCALEHEIGHT, BETAR);\n        vec3 trans2R = transmittance(samplePoint, atmosphereIntersect, 10, RAYLEIGHSCALEHEIGHT, BETAR);\n        rayleighColor += trans1R * trans2R * scatteringAtHeight(BETAR, sampleHeight, RAYLEIGHSCALEHEIGHT) * segmentLength;\n        \n        // Mie Calculations\n        vec3 trans1M = transmittance(pa, samplePoint, 10, MIESCALEHEIGHT, BETAM);\n        vec3 trans2M = transmittance(samplePoint, atmosphereIntersect, 10, MIESCALEHEIGHT, BETAM);\n        mieColor += trans1M * trans2M * scatteringAtHeight(BETAM, sampleHeight, MIESCALEHEIGHT) * segmentLength;\n        \n    }\n    \n    rayleighColor = SUNINTENSITY * phaseR * rayleighColor;\n    mieColor = SUNINTENSITY * phaseM * mieColor;\n    \n    return rayleighColor + mieColor;\n    \n}\n\n// Get the sky color for the ray in direction 'p'\nvec3 skyColor(vec3 p, vec3 sunDir) {\n    \n    // Get the origin and direction of the ray\n\tvec3 origin = vec3(0.0, EARTHRADIUS + 1.0, 0.0);\n\tvec3 dir = p;\n\n\t// Get the position where the ray 'leaves' the atmopshere (see the scratchapixel link for details)\n    // Note that this implementation only works when the origin is inside the atmosphere to begin with\n    float distanceToAtmosphere = raySphereIntersect(origin, dir, vec3(0.0, 0.0, 0.0), ATMOSPHERERADIUS);\n    vec3 atmosphereIntersect = origin + dir * distanceToAtmosphere;\n    \n    // Get the color of the light from the origin to the atmosphere intersect\n    vec3 col = getSkyColor(origin, atmosphereIntersect, sunDir);\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray from the origin\n    vec3 r = normalize(vec3(p, 0.9));\n    \n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.2,0.12):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    r.yz *= mm2(mo.y);\n    r.xz *= mm2(mo.x);\n    \n    // Calculates the position of the sum (as an angle from the origin)\n    //vec3 sunDir = normalize(vec3(0.0, 0.05, 1.0));\n    float timeScale = 0.2;\n    float time = (iTime - 10.0) * timeScale;\n    vec3 sunDir = normalize(vec3(sin(time), cos(time), 1.0));\n    \n    // Gets the appropriate skycolor for the ray\n    vec3 col = skyColor(r, sunDir);\n    \n    // Runs the color through a tone mapper\n    // Found here https://www.shadertoy.com/view/lslGzl and originally from Uncharted 2\n    col = Uncharted2ToneMapping(col);\n    \n    // Render the floor \n    if (r.y < 0.0) {\n    \t//col = vec3(0.1, 0.3, 0.1);\n        col = vec3(0.5, 0.5, 0.5);\n    }\n    \n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1514, 1514, 1536, 1536, 1622], [1742, 1742, 1782, 1782, 2228], [2382, 2382, 2482, 2482, 2786], [2894, 2925, 2956, 2956, 3033], [3035, 3061, 3087, 3087, 3283], [3285, 3446, 3526, 3526, 3580], [3582, 3634, 3656, 3656, 3696], [6708, 6758, 6794, 6846, 7455], [7457, 7457, 7514, 7548, 8835]], "test": "ok"}
{"id": "WsfGz4", "name": "4 rotating squares (228 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "2tweets", "short", "golf"], "likes": 6, "viewed": 390, "published": "Public API", "date": "1545072484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C -= smoothstep(R-R, 3./R, .3 - max(abs(U.x+ .3+min(t,.6-t)), \\\n                                             abs(U+ .3-t) ) ).y, \\\n             U = vec2(-U.y,U)                             //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         t = R-R + .3*mod(iTime,2.),\n         U = (u+u - R) / R.y *mat2(cos(vec4(0,33,11,0) -iTime ));\n         O++; O C; O C; O C; O C; }                             /*\n\n\n\n\n\n\n// --- 228 chars\n\n#define C -= smoothstep(0., 3./R.y, .3 - max(abs(U.x+ .3+min(t,.6-t)), \\\n                                             abs(U.y+ .3-t) ) ), \\\n             U = vec2(-U.y,U)                             //\n#define mainImage( O, u )                                  \\\n    float t = .3* mod(iTime,2.);                           \\\n    vec2  R = iResolution.xy,                              \\\n          U = (u+u - R) / R.y *mat2(cos(vec4(0,33,11,0) -iTime )); \\\n     O++; O C; O C; O C; O C                              /*\n              \n              \n              \n              \n              \n      \n// --- 240 chars  ( rotation : +33 )\n\n#define C(U) smoothstep(2./R.y, 0.,max(abs(U.x+ .3+.3*min(t,2.-t)),\\\n                                       abs(U.y+ .3-.3*t) ) - .3 ) //\n#define mainImage( O, u )                                  \\\n    float t = mod(iTime,2.);                               \\\n    vec2  R = iResolution.xy,                              \\\n          U = (u+u - R) / R.y *mat2(cos(vec4(0,33,11,0) -iTime )), \\\n          V = vec2(-U.y,U);                                \\\n    O += 1.- C(-U) - C(U) - C(-V) - C(V)                  /*\n              \n              \n              \n              \n              \n\n// --- 234 chars\n\n#define C(U) smoothstep(2./R.y, 0.,  abs(max(U.x,U.y)) - .3 )\n#define mainImage( O, u )                                  \\\n    float t = mod(iTime,2.);                               \\\n    vec2  R = iResolution.xy,                              \\\n          U = (u+u - R)/R.y, V = vec2(-U.y,U.x),           \\\n          D = .3+.3*vec2( min( t, 2.-t ), -t );            \\\n    O += 1.- C(abs(U-D)) - C(abs(U+D)) - C(abs(V-D)) - C(abs(V+D)) /*\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 236, 236, 404]], "test": "error"}
{"id": "WsfGz8", "name": "Pulsing circle project", "author": "elijah_green14", "description": "Pulsing circle", "tags": ["1"], "likes": 0, "viewed": 61, "published": "Public", "date": "1544817658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float timer=mod(iTime, 3.0);\n    float radius=2.0/timer; // divided by time so that it changes as time progresses\n    float width=timer*3.0;\n    float ring=length(vec2(uv.x+0.2, uv.y))*radius*width-width;\n    ring=min(2.0, abs(1.0/(10.0*ring)));\n    ring=max(0.0, ring-timer); // these are used to reset the pulse effect after a certain amount of time\n    vec3 rings=vec3(0.5, .09, 0.08);\n    \n    timer=mod(iTime*1.2+2.0, 3.0);\n    radius=1.3/timer;\n    width=2.0*timer;\n    ring=length(vec2(uv.x-1.0, uv.y+0.2))*radius*width-width; \n    rings+=vec3(ring, ring*.4, ring*.5);\n    \n    \n\tfragColor = vec4(rings,4.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 740]], "test": "ok"}
{"id": "Wsl3W4", "name": "pulsating flower ", "author": "lucastakejame", "description": "the shader describes it self", "tags": ["2d", "soundvisualization"], "likes": 1, "viewed": 141, "published": "Public", "date": "1546280360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ss(a,b,c) smoothstep(a,b,c)\n#define tx(b) texture(iChannel0, b)\n#define snd(x) texture(iChannel0, vec2(x,.1)).r\n\n#define PI 3.1415\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // proportional and translated uv\n    vec2 tuv = fragCoord/iResolution.y - vec2(.5*iResolution.x/iResolution.y, .5);\n    \n    \n    // [0, 2pi]\n    float angle = atan(tuv.y,tuv.x) + PI;\n    float d = length(tuv);\n\t\n    float r = .1; \n        r += .15*tx( vec2(angle/(2.*PI),0. ) ).r;\n        r += .05*cos(angle*10. + iTime);\n\t\t//r += .01*cos(angle*2.99 + iTime);\n\t\t//r += .01*cos(angle*3.01 + iTime); //mean?\n\n    // weird distortion in x axis\n    float dist = tx(vec2(uv.x, 0.)).r;\n    //snd = snd(.1);\n    \n    float modD = mod(d, (r+.01) * (1. + dist));\n    float divDist = trunc(d/r);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(snd(.5)*divDist+uv.xyx+vec3(0,2,4));\n    \n    float flower = ss(r,r + 0.1, r + abs(modD - r) );\n    \n    col = mix(\n        \tvec3(\n                snd(.01 * fract(flower)),\n                snd(.03 * fract(flower)),\n                snd(.05 * fract(flower))\n            ),\n        \tcol,\n\t\t\t(1.- flower)\n    \t\t);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [{"id": "XtXGRM", "previewfilepath": "https://soundcloud.com/chibi-tech/moecom-lynx-norcal-stylez-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/chibi-tech/moecom-lynx-norcal-stylez-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsl3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 197, 247, 1318]], "test": "error"}
{"id": "Wsl3z8", "name": "Stealth:Study 3D modeling", "author": "yasuo", "description": "If I use \"udQuad\" function a lot, fps will be low, so I used symmetry trick to approach to create my stealth modeling. A \"polygon\" function is not what I expected. It should fill out the color. Well... Today's study is over...", "tags": ["modeling"], "likes": 8, "viewed": 357, "published": "Public API", "date": "1544954470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n\nmat3 matRotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nmat3 matRotateY(float rad)\n{\n    return mat3(cos(rad), 0, -sin(rad),\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\tsin(rad), 0, cos(rad));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// based on udquad function\nfloat polygon( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ed = e - d; vec3 pd = p - d;\n    vec3 fe = f - e; vec3 pe = p - e;\n    vec3 af = a - f; vec3 pf = p - f;\n    vec3 nor = cross( ba, ed );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ed,nor),pd)) +\n     sign(dot(cross(fe,nor),pe)) +\n     sign(dot(cross(af,nor),pf))<5.0)\n     ?\n     min( min( min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ed*clamp(dot(ed,pd)/dot2(ed),0.0,1.0)-pd) ),\n     dot2(fe*clamp(dot(fe,pe)/dot2(fe),0.0,1.0)-pe) ),\n     dot2(af*clamp(dot(af,pf)/dot2(af),0.0,1.0)-pf) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat floorDist(vec3 p)\n{\n    return p.y+3.0;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 map(vec3 p){\n    vec3 op = p;\n    float t = 100.0;\n\tfloat r = 0.05;\n    \n    // A 3D Model created by udquads\n    p.x = -abs(p.x);\n\tvec4 left = vec4(0.3,0.3,0.30,udQuad(p, vec3(-2.95924, 0.0, 2.09304), vec3(-0.498879, 0.0, -0.90205), vec3(-0.666666, 0.0, 1.33333),vec3(-2.77433, 0.0, 2.51385))-r);\n\tvec4 left2 = vec4(0.31,0.31,0.31,udQuad(p, vec3(-0.597683, 0.0, 0.496091), vec3(0.0, 0.29306, 0.130684), vec3(0.0, 0.19306, -1.59247),vec3(-0.498879, 0.0, -0.90205))-r);\n\tvec4 left3 = vec4(0.35,0.35,0.35,udQuad(p, vec3(-0.597683, 0.0, 0.496091), vec3(0.0, 0.29306, 0.130684), vec3(0.0, 0.35306, 1.65346),vec3(-0.666666, 0.0, 1.33333))-r);\n\tvec4 tailWingL = vec4(0.36,0.36,0.36,udQuad(p, vec3(-0.265, 0.3, 1.373111), vec3(-0.481232, 1.29927, 2.538658), vec3(-0.435489,1.09346, 2.138658),vec3(-0.22672, 0.3, 1.181444))-r);\n\tp = op;\n    \n    // A 3D Model created by a modified version of udquads\n    op = p;\n\tp.x = -abs(p.x);\n    p.y += 1.5;\n\n    float pol = polygon(p,vec3(0.0, 0.5, 2.0*-1.0),\n                        vec3(-0.5, 0.0, 1.4*-1.0), \n                        vec3(-3.55924, 0.0, 0.15*-1.0),\n                        vec3(-3.17433, 0.0, -0.3*-1.0), \n                        vec3(-0.6, 0.0, -0.5*-1.0),\n                        vec3(0.0, 0.5, -1.0*-1.0))-r;\n    p = op;\n    \n\tvec4 res = combine(left,left2);\n    vec4 res2 = combine(left3,tailWingL);\n    vec4 res3 = combine(vec4(0.3,0.3,0.3,pol),vec4(1.0,1.0,1.0,floorDist(p)));\n    vec4 res4 = combine(res,res2);\n    vec4 res5 = combine(res3,res4);\n    return res5;\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    mat3 camRotY = matRotateY(-(iTime*30.0)*degToRad)*matRotateX(20.*degToRad);\n\t//mat3 camRotY = matRotateX(-90.0*degToRad); // Check top view of modeling.\n\n\tvec3 ro=vec3(0.,-.1,-8.);\n    vec3 rd=normalize(vec3(p,1.8));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 60; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(1.35,1.35,1.35)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsl3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 90, 90, 207], [209, 209, 237, 237, 322], [324, 324, 349, 349, 368], [369, 369, 425, 425, 1065], [1067, 1095, 1168, 1168, 2074], [2076, 2076, 2101, 2101, 2123], [2125, 2125, 2161, 2161, 2220], [2222, 2222, 2239, 2239, 3750], [3752, 3752, 3775, 3775, 4025], [4027, 4027, 4061, 4061, 4311], [4313, 4313, 4369, 4369, 5640]], "test": "timeout"}
{"id": "wslGR7", "name": " Merry Christmas", "author": "gaz", "description": "2d", "tags": ["font", "16segment"], "likes": 5, "viewed": 198, "published": "Public", "date": "1545549807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int C[26]=int[](7325,53709,35217,53705,36241,3217,39317,7196,49601,39176,11282,35088,6202,14392,39321,3229,47513,11421,37285,16577,39192,2578,14872,8738,16418,33667);\nint N[10]=int[](39835,4106,36237,38285,5148,38293,40341,643,40349,38301);\n\nfloat de16Seg(vec2 p,int n)\n{\n\tfloat e=2.;\n\tmat2 m=mat2(0,-1,1,0);\n    for(int i=0;i<16;i++){\n\t\tint j=i&3;\n\t\tif(j==0)m*=mat2(0,1,-1,0);\n\t\tif((n>>i&1)==1){\n\t\t\tvec2 a=m*vec2(26>>j&1,19>>j&1)*vec2(0.6,1);\n\t\t\tvec2 b=m*vec2(13>>j&1,9>>j&1)*vec2(0.6,1);\n            a.x+=0.3*a.y;\n            b.x+=0.3*b.y;\n            vec2 c=p-a,d=b-a;\n\t\t\te=min(e,length(c-d* clamp(dot(c,d)/dot(d,d), 0.1, 0.9)));\n\t\t}\n\t}\n\treturn e;\n}\n\n#define A(a) idx=N[a];de=min(de,de16Seg(p,idx));p.x-=2.0;\n#define B(a) idx=C[a];de=min(de,de16Seg(p,idx));p.x-=2.0;\n#define S(a) int(mix(123456.0,float(a),min(time-=0.1,1.0)))%26\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord.xy/iResolution.y;\n\tvec3 col =vec3(0.05,0.1,0.3)- vec3(p.y*p.y)*0.3;\n    col = mix(col, texture(iChannel0, p + vec2(0,iTime * 0.08)).xyz, 0.3);\n    p *=20.0;\n    float time = mod(iTime,12.0)*0.2+1.0;\n\tint idx;\n\tfloat de=10.0;\n\tp +=vec2(-8,-14);\n\tB(S(12))\n\tB(S(4))\n\tB(S(17))\n\tB(S(17))\n\tB(S(24))\n\tp +=vec2(8,5);\n\tB(S(2))\n\tB(S(7))\n\tB(S(17))\n\tB(S(8))\n\tB(S(18))\n\tB(S(19))\n\tB(S(12))\n\tB(S(0))\n\tB(S(18))\n\tp +=vec2(6,5);\n\tA(2)\n\tA(0)\n\tA(1)\n\tA(8)\n    de /= sin(iTime*3.0)+2.0;\n\tcol = mix(col, mix(vec3(0.1,0.7,0.1),vec3(1.0,0.7,0.1),step(2.5,p.y)),exp(-6.0*de));\n\tcol = mix(col, vec3(1),exp(-25.0*de));\n\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 271, 271, 652]], "test": "error"}
{"id": "wslGRM", "name": "Fake fbm cloud", "author": "yasuo", "description": "A Cloud experiment. It's pretty volume rendering look.", "tags": ["cloud"], "likes": 2, "viewed": 396, "published": "Public API", "date": "1545500886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n\n// noise and fbm function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//-----------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nmat3 matRotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nmat3 matRotateY(float rad)\n{\n    return mat3(cos(rad), 0, -sin(rad),\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\tsin(rad), 0, cos(rad));\n}\n\nvec4 map(vec3 p){\n    float speed = iTime*1.0;\n    p.z += speed;\n    \n\tfloat n = floor(p.z/0.5);\n    p.y += noise(n)*0.1+sin(p.z)*0.5+sin(iTime*0.1)*0.2;\n    p.x += noise(n)*0.3+sin(p.z)*1.5;\n    p.y -= 1.5;\n    p.y = abs(p.y);\n\tp.y -= 1.5;\n\n    float cloudD = (p.y+1.0+fbm(p*1.1)*0.6);\n    vec3 cloudCol = vec3(1.5,1.5,1.5)+fbm(p*1.1);\n    \n    return vec4(cloudCol,cloudD);\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    //mat3 camRotY = matRotateY(-(iTime*30.0)*degToRad)*matRotateX(20.*degToRad);\n\tmat3 camRotY = matRotateX(20.0*degToRad);\n    \n\tvec3 ro=vec3(0.,-.1,-8.);\n    vec3 rd=normalize(vec3(p,1.8));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 60; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>30.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t);\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 30.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(1.1,1.31,1.35)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 346, 369, 369, 408], [410, 410, 436, 436, 841], [843, 843, 865, 865, 939], [941, 941, 962, 962, 1103], [1105, 1105, 1133, 1133, 1250], [1252, 1252, 1280, 1280, 1365], [1367, 1367, 1384, 1384, 1744], [1746, 1746, 1769, 1769, 2019], [2021, 2021, 2055, 2055, 2305], [2307, 2307, 2363, 2363, 3600]], "test": "timeout"}
{"id": "WslGz4", "name": "Box - fake soft shadow", "author": "iq", "description": "Analytic, single ray, [b]fake[/b] soft shadow for boxes. ", "tags": ["3d", "shadow", "box", "soft", "softshadow"], "likes": 35, "viewed": 2735, "published": "Public API", "date": "1545206483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytic fake soft shadow for boxes. With a single ray, we can compute a soft shadow.\n// It is \"plausible\", but not accurate. It can probably be optimized further, right now\n// I am testing the 12 edges, but generaly you only need to test between 1 and 6.\n\n\n// Other Box functions:\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n\n// Other Soft Shadow functions:\n//\n// Sphere:    https://www.shadertoy.com/view/4d2XWV\n// Ellipsoid: https://www.shadertoy.com/view/llsSzn\n// Box:       https://www.shadertoy.com/view/WslGz4\n// Capsule:   https://www.shadertoy.com/view/MlGczG\n\n\n\n#define SHADOW_TYPE 2\n\n// SHADOW_TYPE = 2 ---> great soft shadow\n// SHADOW_TYPE = 1 ---> super cheap soft shadow\n// SHADOW_TYPE = 0 ---> regular hard shadows\n\n\n#if SHADOW_TYPE==2\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz); // dm = 1.0 - rd.x*rd.x\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n#endif\n\n#if SHADOW_TYPE==1\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    // fake soft shadow\n    if( tF<0.0) return 1.0;\n    float sh = clamp(0.3*sk*(tN-tF)/tN,0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}    \n#endif\n\n#if SHADOW_TYPE==0\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 1.0;\n\treturn 0.0;\n}\n#endif\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad,\n                 out vec2 outT, out vec3 outNor, out vec2 outST, out int outFaceID ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 s = vec3((rdd.x<0.0)?1.0:-1.0,\n                  (rdd.y<0.0)?1.0:-1.0,\n                  (rdd.z<0.0)?1.0:-1.0);\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 t1 = m*(-roo + s*rad);\n    vec3 t2 = m*(-roo - s*rad);\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return false;\n\n    // compute normal (in world space), face and UV\n         if( t1.x>t1.y && t1.x>t1.z ) { outNor = txi[0].xyz*s.x; outST = roo.yz+rdd.yz*t1.x; outFaceID=(1+int(s.x))/2; /* 0, 1 */ } \n    else if( t1.y>t1.z   )            { outNor = txi[1].xyz*s.y; outST = roo.zx+rdd.zx*t1.y; outFaceID=(5+int(s.y))/2; /* 2, 3 */ }\n    else                              { outNor = txi[2].xyz*s.z; outST = roo.xy+rdd.xy*t1.z; outFaceID=(9+int(s.z))/2; /* 4, 5 */ }\n\n\toutT = vec2(tN,tF);\n    \n    return true;\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    \n    // 8 verts\n    vec3 v0 = normalize( vec3(-1.0,-1.0,-1.0)*rad - p);\n    vec3 v1 = normalize( vec3( 1.0,-1.0,-1.0)*rad - p);\n    vec3 v2 = normalize( vec3(-1.0, 1.0,-1.0)*rad - p);\n    vec3 v3 = normalize( vec3( 1.0, 1.0,-1.0)*rad - p);\n    vec3 v4 = normalize( vec3(-1.0,-1.0, 1.0)*rad - p);\n    vec3 v5 = normalize( vec3( 1.0,-1.0, 1.0)*rad - p);\n    vec3 v6 = normalize( vec3(-1.0, 1.0, 1.0)*rad - p);\n    vec3 v7 = normalize( vec3( 1.0, 1.0, 1.0)*rad - p);\n    \n    // 12 edges    \n    float k02 = dot( n, normalize( cross(v2,v0)) ) * acos( clamp(dot(v0,v2),-1.0,1.0) );\n    float k23 = dot( n, normalize( cross(v3,v2)) ) * acos( clamp(dot(v2,v3),-1.0,1.0) );\n    float k31 = dot( n, normalize( cross(v1,v3)) ) * acos( clamp(dot(v3,v1),-1.0,1.0) );\n    float k10 = dot( n, normalize( cross(v0,v1)) ) * acos( clamp(dot(v1,v0),-1.0,1.0) );\n    float k45 = dot( n, normalize( cross(v5,v4)) ) * acos( clamp(dot(v4,v5),-1.0,1.0) );\n    float k57 = dot( n, normalize( cross(v7,v5)) ) * acos( clamp(dot(v5,v7),-1.0,1.0) );\n    float k76 = dot( n, normalize( cross(v6,v7)) ) * acos( clamp(dot(v7,v6),-1.0,1.0) );\n    float k37 = dot( n, normalize( cross(v7,v3)) ) * acos( clamp(dot(v3,v7),-1.0,1.0) );\n    float k64 = dot( n, normalize( cross(v4,v6)) ) * acos( clamp(dot(v6,v4),-1.0,1.0) );\n    float k51 = dot( n, normalize( cross(v1,v5)) ) * acos( clamp(dot(v5,v1),-1.0,1.0) );\n    float k04 = dot( n, normalize( cross(v4,v0)) ) * acos( clamp(dot(v0,v4),-1.0,1.0) );\n    float k62 = dot( n, normalize( cross(v2,v6)) ) * acos( clamp(dot(v6,v2),-1.0,1.0) );\n    \n    // 6 faces    \n    float occ = 0.0;\n    occ += ( k02 + k23 + k31 + k10) * step( 0.0,  v0.z );\n    occ += ( k45 + k57 + k76 + k64) * step( 0.0, -v4.z );\n    occ += ( k51 - k31 + k37 - k57) * step( 0.0, -v5.x );\n    occ += ( k04 - k64 + k62 - k02) * step( 0.0,  v0.x );\n    occ += (-k76 - k37 - k23 - k62) * step( 0.0, -v6.y );\n    occ += (-k10 - k51 - k45 - k04) * step( 0.0,  v0.y );\n        \n    return occ / 6.2831;\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // animate box\n    mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n    mat4 tra = translate( 0.0, 1.0, 0.0 );\n    mat4 txi = tra * rot; \n    mat4 txx = inverse( txi );\n    vec3 box = vec3(0.4,0.6,0.8);\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n        float tmin = 10000.0;\n        vec3  nor = vec3(0.0);\n        vec3  pos = vec3(0.0);\n        vec2  uv = vec2(0.0);\n\n        // raytrace-plane\n        float oid = 0.0;\n        float h = (0.0-ro.y)/rd.y;\n        if( h>0.0 ) \n        { \n            tmin = h; \n            nor = vec3(0.0,1.0,0.0); \n            oid = 1.0;\n            pos = ro + rd*h;\n            uv = pos.xz;\n        }\n\n        // raytrace box\n        vec3 bnor;  vec2 buv;\n        int outFaceID;\n        vec2 tnf;\n        if( boxIntersect( ro, rd, txx, txi, box, tnf, bnor, buv, outFaceID) )\n        {\n            if( tnf.x>0.0 && tnf.x<tmin )\n            {\n                tmin = tnf.x; \n                nor = bnor;\n                uv = buv;\n                oid = 2.0;\n        \t}\n        }\n\n        // shading/lighting\t\n        vec3 col = vec3(0.9);\n        if( tmin<100.0 )\n        {\n            vec3 lig = normalize(vec3(0.3,0.5,0.8));\n            pos = ro + tmin*rd;\n\n            // material\n            float occ = 1.0;\n            vec3  mate = vec3(1.0);\n            if( oid<1.5 ) // plane\n            {\n                mate = vec3(0.6)*(0.8+0.2*checkersGradBox( 2.0*uv ));\n                // analytic ambient occlusion\n                occ = 1.0-boxOcclusion( pos, nor, txx, txi, box );\n            }\t\t\t\n            else // box\n            {\n                mate = vec3(0.5)*(0.8+0.2*checkersGradBox( 5.0*uv ));\n                // fake ambient occlusion\n                occ  = 0.5 + 0.5*nor.y;\n                occ *= 0.5 + 0.5*clamp(pos.y,0.0,1.0);\n            }\t\t\n\n\n            // lighting\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            dif *= boxSoftShadow( pos+0.01*nor, lig, txx, box, 4.0 );\n            col = vec3(0.1,0.2,0.3)*occ + 2.0*dif*vec3(1.0,0.8,0.7);\n\n            // material * lighting\t\t\n            col *= mate;\n\n            // fog\n            col = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslGz4.jpg", "access": "shaders20k", "license": "mit", "functions": [[4547, 4615, 4784, 4821, 5767], [5770, 5838, 5926, 5926, 7986], [8081, 8081, 8128, 8128, 8532], [8534, 8534, 8579, 8579, 8695], [8697, 8773, 8809, 8830, 9053]], "test": "error"}
{"id": "wslGz7", "name": "Dancy Tree Doodle", "author": "wyatt", "description": "I saw this Betty Boop cartoon from way back when and I liked how every character kind of bobs up and down in unison. \nI wanted to make a more natural looking tree, but I realized you're limited to really symetrical trees for this setup. ", "tags": ["tree", "kifs"], "likes": 54, "viewed": 1864, "published": "Public API", "date": "1545712680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 po (vec2 v) {\n\treturn vec2(length(v),atan(v.y,v.x));\n}\nvec2 ca (vec2 u) {\n\treturn u.x*vec2(cos(u.y),sin(u.y));\n}\nfloat ln (vec2 p, vec2 a, vec2 b) { \n    float r = dot(p-a,b-a)/dot(b-a,b-a);\n    r = clamp(r,0.,1.);\n    p.x+=(0.7+0.5*sin(0.1*iTime))*0.2*smoothstep(1.,0.,abs(r*2.-1.))*sin(3.14159*(r-4.*iTime));\n    return (1.+0.5*r)*length(p-a-(b-a)*r);\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{   vec2 R = iResolution.xy;\n \tfloat r = 1e9;\n \tU = 4.*(U-0.5*R)/R.y;\n \tU.y += 1.5;\n \tQ = vec4(0);\n \tfor (int i = 1; i < 20; i++) {\n        U = ca(po(U)+0.3*(sin(2.*iTime)+0.5*sin(4.53*iTime)+0.1*cos(12.2*iTime))*vec2(0,1));\n        r = min(r,ln(U,vec2(0),vec2(0,1.)));\n        U.y-=1.;\n        \n        U.x=abs(U.x);\n        U*=1.4+0.1*sin(iTime)+0.05*sin(0.2455*iTime)*(float(i));\n        U = po(U);\n        U.y += 1.+0.5*sin(0.553*iTime)*sin(sin(iTime)*float(i))+0.1*sin(0.4*iTime)+0.05*sin(0.554*iTime);\n        U = ca(U);\n        \n        \n        Q+=sin(1.5*exp(-1e2*r*r)*1.4*vec4(1,-1.8,1.9,4)+iTime);\n        \n \t\t\n \t}\n \tQ/=18.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 59], [60, 60, 78, 78, 117], [118, 118, 153, 153, 360]], "test": "ok"}
{"id": "WslGz8", "name": "Frozen Julia Set", "author": "Tony_The_Magnificent", "description": "If you have lags, you can switch member prcsn from 4096 to 512, and color computation respectively (code, which have w=15 to code, that have w=7, this important, because they have different precomputed constants for full color pallette).", "tags": ["fractal", "math", "pretty"], "likes": 1, "viewed": 67, "published": "Public", "date": "1544950184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int prcsn = 4096;\t\t// Just comment this var, and uncomment var below (don't forget switch colors)\n    //const int prcsn = 512;\n    const float scale = 3.0;\t// This variable needed for scaling fractal, \n    \t\t\t\t\t\t\t// the smaller it, the bigger set(but it's don't zoom, just stretch)\n    vec2 c = vec2(0.7885*cos(iTime/2.0), 0.7885*sin(iTime/2.0));\n    float R = (1.0 + sqrt(1.0 + 4.0 * length(c)))/2.0;\n    vec2 z = vec2((fragCoord - 0.5*iResolution.xy)/iResolution.y * scale);\n    int i = 0;\n    while(i < prcsn)\n    {\n        if(dot(z,z) > R*R)\n        \tbreak;\n        z = mat2(z, -z.y, z.x)*z + c;\n        i++;\n    }\n    vec3 C = vec3((ivec3(i)>>ivec3(0,4,8))&15)/15.0;\t// Comment this and uncomment string below respectively\n    //vec3 C = vec3((ivec3(i)>>ivec3(0,3,6))&7)/7.0;\n    fragColor = vec4(C.r, C.r+C.g, C.r+C.g+C.b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 904]], "test": "ok"}
{"id": "wslGzM", "name": "sinusland", "author": "oo_miguel", "description": "Welcome to the Land of Sinusoids.", "tags": ["procedural", "raymarching", "sinus"], "likes": 2, "viewed": 88, "published": "Public", "date": "1545523377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS  50\n#define MAX_DIST   65.\n#define SURF_DIST .05\n\nfloat sinus_plane(vec3 p, vec4 n){\n  return  dot(p,n.xyz) + n.w + \n          0.3 * sin(5.*p.x) + 0.6 * sin(p.x+iTime*3.) +\n      \t  0.1 * sin(5.*p.y) + 1.  * sin(p.z+iTime*9.);\n}\n\nfloat scene(vec3 p){\n  return min(sinus_plane(p,vec4(0.,1.,0.,3.)),sinus_plane(p,vec4(0.,-0.3,0.,3.)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = scene(p);\n        dO += dS;\n        if(dS<SURF_DIST)break;\n        if(dO>MAX_DIST)return MAX_DIST+1.;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p){\n\tfloat d = scene(p);\n    vec2  e = vec2(.01, 0);\n    vec3  n = d - vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx));\n    return normalize(n);\n}\n\nfloat light(vec3 p) {\n    vec3 pos = vec3(3, 4, 1);\n    vec3 l = normalize(pos-p);\n    vec3 n = normal(p);\n    return clamp(dot(n, l), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(sin(iTime), 1.+1.4*sin(0.3*iTime), 0);\n    vec3 rd = normalize(vec3(uv.x+0.15*sin(0.25*iTime), uv.y+0.1+0.05*sin(iTime), 1.));\n    float d = march(ro, rd);\n    vec3  p = ro + rd * d;\n    float l = light(p);\n    \n    if(d>MAX_DIST)fragColor=vec4(vec3(.8),1.);\n    else if(p.y<0.1)fragColor = vec4(vec3(d/80.,d/80.,l),1.);\n    else fragColor=vec4(vec3(l,d/80.,d/80.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 102, 102, 246], [248, 248, 268, 268, 353], [355, 355, 385, 385, 606], [608, 608, 628, 628, 774], [776, 776, 797, 797, 921], [923, 923, 977, 977, 1427]], "test": "ok"}
{"id": "Wss3D8", "name": "fractal chessboard", "author": "morisil", "description": "I learned how to use tail recursion :)", "tags": ["endless", "loop", "checker", "rotation", "perspective", "double", "chess", "tailrecursion"], "likes": 4, "viewed": 366, "published": "Public API", "date": "1546034457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RECURSION_LEVEL 10\n\n#define SCALE 1.0\n\n#define SCENE_ROTATION_SPEED -0.1\n\n#define PLANE_ROTATION_SPEED 0.3\n\n#define EDGE_SHARPNESS 20000.0\n\n#define PI 3.14159265359\n\nmat2 rotate2d(float angle){\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n}\n\nfloat getChessboardLuminance(vec2 point) {\n    float value =\n        (1.0 - pow(cos(point.x * PI), EDGE_SHARPNESS))\n        * sign(sin(point.x * PI));\n    value *=\n        (1.0 - pow(cos(point.y * PI), EDGE_SHARPNESS))\n        * sign(sin(point.y * PI));\n    return (value + 1.0) / 2.0;    \n}\n\nbool isBlack(vec2 point) {\n    vec2 checkerV = mod(floor(point), 2.0);\n    float checker = mod(checkerV.x + checkerV.y, 2.0);\n    return (checker == 1.0);\n}\n\nfloat getLuminance(vec2 pixel) {\n    float luminance = 1.0;\n    for (int i = 0; i < RECURSION_LEVEL; i++) {\n        pixel *= rotate2d(iTime * SCENE_ROTATION_SPEED);\n        vec2 trans = vec2(pixel.x / pixel.y, 1.0 / pixel.y);\n        trans *= rotate2d(iTime * PLANE_ROTATION_SPEED);    \n        trans *= SCALE;\n\n        luminance += getChessboardLuminance(trans) * luminance;\n        // apply air perspective\n        luminance *= abs(pixel.y);\n\n        if (isBlack(trans)) {\n            pixel = mod(trans, 2.0) - 1.0;\n        } else {\n            break;\n        }\n    }\n    return luminance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float luminance = getLuminance(pixel);\n    fragColor = vec4(vec3(luminance),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wss3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 201, 201, 291], [293, 293, 335, 335, 584], [586, 586, 612, 612, 742], [744, 744, 776, 776, 1337], [1339, 1339, 1394, 1394, 1549]], "test": "ok"}
{"id": "wss3zH", "name": "n00bz with b00bz", "author": "_kitzume_", "description": "Original \"Hello World!\" ShaderToy Fragment Shader with lots and lots and lots and lots of comments and explanations.", "tags": ["gradient", "gradation", "timebased"], "likes": 7, "viewed": 584, "published": "Public API", "date": "1545050834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FRAGMENT SHADER for ShaderToy\n\n///////////////////////////////////////////////\n//                                          //\n//         Code edited by .       //\n//      Comments composed by .     //\n//                                           //\n//////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n /* fragCoord (or gl_fragCoord) is a special read-only input variable \n\twith global scope (available to both the CPU and the GPU). fragCoord\n\tcan only be referenced from within a fragment shader.\n */\n\n /* pixelCoord normalizes the x,y values of fragCoord to be between 0 and 1.\n\n\tThe x coordinate represents the horizontal value.\n\tWhen x = 0, the pixel is on the leftmost side of the screen.\n\tWhen x = 1, the pixel is on the rightmost side of the screen.\n\t\n\tThe y coordinate represents the vertical value.\n\tWhen y = 0, the pixel is at the bottom of the screen.\n\tWhen y = 1, the pixel is at the top of the screen.\n */\n    vec2 pixelCoord = fragCoord.xy/iResolution.xy; \n\n    \n /* color represents the mixed RGB color, which is later passed to fragColor\n\tcolor.r = red\n\tcolor.g = green\n\tcolor.b = blue\n */       \n\n    vec3 color;\n    \n    vec3 cyan = vec3(0.0, 2.0, 4.0);        \n\n\tfloat R = pixelCoord.x;\n    float G = pixelCoord.y;\n    float B = pixelCoord.x;\n\n // color = cyan ;\n // color = vec3(R,G,B) ;\n // color = vec3(iTime) ;\n\n // color = cos(cyan) ;\n // color = cos(vec3(R,G,B)) ;\n // color = cos(vec3(iTime)) ;\n\n // color = (iTime + vec3(R,G,B) + cyan) ;    \n // color = cos(iTime + vec3(R,G,B) + cyan) ;\n // color = 0.5 * cos(iTime + vec3(R,G,B) + cyan) ;\n    \n /* cosine returns a value from -1 to 1 */\n    \n\tcolor = 0.5 + 0.5 * cos(iTime + vec3(R,G,B) + cyan) ;\n    \n // color = 0.5 + 0.5*cos(iTime+pixelCoord.xyx+vec3(0,2,4)); \n\n // Output to screen\n\n    fragColor = vec4 (color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wss3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 406, 1024, 1911]], "test": "ok"}
{"id": "Wss3zn", "name": "Ray Playground", "author": "josemorval", "description": "Visualization of raycast, with reflection, on objects surfaces. Move mouse to choose a direction (based on cursor position and center of space).", "tags": ["2d", "ray", "raycast", "physics", "point"], "likes": 5, "viewed": 399, "published": "Public API", "date": "1544739276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VEL 0.02\n\nfloat sdCircle(vec2 p, float r){\n\treturn length(p)-r;   \n}\n\n\nfloat sdSquare(vec2 p, float r){\n\treturn max(abs(p.y),abs(p.x))-0.1;   \n}\n\nfloat map(vec2 p){\n    \n    float angle = VEL*0.2*iTime;\n   \tvec2 q = p;\n    q = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*q;\n    float d = sdCircle(q-vec2(0.2+0.1*sin(VEL*iTime),-0.1+0.1*sin(VEL*iTime)),0.1);\n    d = min(d,sdSquare(q-vec2(0.2+0.2*sin(VEL*iTime),0.3),0.1));\n    d = min(d,sdSquare(q-vec2(0.5,0.05+0.3*sin(VEL*iTime)),0.1));\n    \n    p*=1.25;\n    angle = VEL*0.01*iTime;\n    q = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*p;\n    \n    q = mod(q,1.)-0.75;\n    d = min(d,sdCircle(q+vec2(0.3,0.2),0.15));\n    \n    angle -= VEL*0.05*iTime;\n    q = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*p;\n    \n    q = mod(q,1.)-0.75;\n    d = min(d,sdCircle(q,0.2));\n    \n    return d;\n    \n}\n\nvec2 calcNormal(vec2 pos )\n{\n\tvec2 eps = vec2( 0.0005, 0.0);\n\tvec2 nor = vec2(\n\t    map(pos+eps.xy) - map(pos-eps.xy),\n\t    map(pos+eps.yx) - map(pos-eps.yx));\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv-0.5;\n    p.x*=iResolution.x/iResolution.y;\n    vec2 mpos = iMouse.xy/iResolution.xy;\n    mpos -= 0.5;\n    mpos.x*=iResolution.x/iResolution.y;\n    \n    \n    vec2 dir = normalize(-mpos);\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    float mask = 0.;\n    float d = 0.;\n    \n    \n    mask = map(p);\n    mask = 1.-smoothstep(0.001,0.005,mask);\n    col = mix(vec3(1.,1.,1.),col,mask);\n    \n    col = mix(col,vec3(0.8,0.3,0.2),1.-step(0.005,abs(sdCircle(p-mpos,0.02\n                                                            +0.002*sin(10.*iTime)))));\n    col = mix(col,0.3*col,1.-step(0.,sdCircle(p,0.01)));\n    \n    \n    vec2 oldpos = mpos;\n\tvec2 newpos;\n    float totd = 0.;\n    for(int i=0;i<4;i++){\n        \n        d = 0.0;\n        for(int j=0;j<64;j++){\n            float f = map(oldpos+d*dir);\n\t\t\td+=f;\n        }\n\n\t\t\n\t\tnewpos = oldpos+dir*d;\n\n        mask = abs(dot(vec2(dir.y,-dir.x),oldpos-p)); \n        mask = 1.-smoothstep(0.003,0.005,mask);\n        mask *= step(0.,dot(dir,normalize(p-oldpos)));\n        mask *= step(0.,dot(-dir,normalize(p-newpos)));\n        mask = 1.-mask;\n        col = mix(vec3(0.8,0.5,0.9),col,mask);\n\n\n        mask = sdCircle(p-newpos,0.01);\n        mask = step(0.,mask);\n        col = mix(vec3(0.3,0.2,0.9),col,mask);\n\n\n        \n\t\tdir = reflect(dir,calcNormal(newpos));\n\t\toldpos = newpos+0.001*dir;\n        \n        totd+=d;\n\n        \n    }\n\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wss3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 50, 50, 76], [79, 79, 111, 111, 152], [154, 154, 172, 172, 870], [872, 872, 900, 900, 1057], [1059, 1059, 1116, 1116, 2588]], "test": "ok"}
{"id": "wsX3zH", "name": "hypnotic spiral 4", "author": "morisil", "description": "Follow up of the \"hallucinatory spiral 1\". This time the thickness is pulsating separately for each color composite.", "tags": ["procedural", "spiral", "illusion", "hypnotic", "polar"], "likes": 2, "viewed": 366, "published": "Public API", "date": "1544915718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// adjust this factor for stronger optical illusion\n#define SCALE 60.0\n// rotation speed, might be negative to spin counter-clockwise\n#define SPEED -25.0\n\nfloat getColorComponent(float dist, float angle, float thicknessChangeSpeed) {\n    return pow(\n        (sin(dist * (SCALE) + angle - (iTime * SPEED)) + 1.0) / 2.0,\n        (sin(iTime * thicknessChangeSpeed) + 1.0) + 0.2 // we don't want it to get too thick\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 delta = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(delta),\n    angle = atan(delta.x, delta.y);\n    fragColor = vec4(\n        getColorComponent(dist, angle, 1.0),\n        getColorComponent(dist, angle, 0.9),\n        getColorComponent(dist, angle, 0.7),\n        1.0\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsX3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 233, 233, 420], [422, 422, 477, 477, 790]], "test": "ok"}
{"id": "wsX3zN", "name": "rotating tiling 2 ( 224 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "tiling", "2tweets", "gif", "short", "golf", "loopless", "reproductions"], "likes": 9, "viewed": 466, "published": "Public API", "date": "1545173112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// shorter + alternate algo for https://www.shadertoy.com/view/WsfGRN\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O++;\n    vec2  r = iResolution.xy, U;\n    float t = iTime, c = cos(t), s = sin(t),\n          S = max( abs(c) , abs(s) );\n    for ( int i = 0; i++ < 7;\n          O -= max( r.y/6.* min( U.x, U.y ) , 0. )\n        ) U = fract( S*2.*(u+u - r) / r.y ) + vec2(i%3,i/3) -1.5,\n          U = .5 - abs( U * mat2(c,s,-s,c) ) / S; }                 /*\n\n\n\n\n\n\n// --- 244 chars, different approach for rot4 in square\n\n#define mainImage( O, u )                                      \\\n    O++;                                                       \\\n    vec2  r = iResolution.xy, U, T = iTime - vec2(0,11),       \\\n          s = abs( cos(T) ); s = max(s,s.yx);                  \\\n    for ( int i = 0; i++ < 7;                                  \\\n          O -= max( r.y/12.* min( U.x, U.y ) , 0. )            \\\n        ) U = 1.-  length( U = fract( s*2.*(u+u - r) / r.y ) + vec2(i%3,i/3) -1.5 ) \\\n              * abs( cos( mod( atan(U.y,U.x), 1.57 ) - T ))  *2./s              /*\n\n\n\n\n\n\n// --- 251 chars\n\n#define mainImage( O, u )                                          \\\n    O++;                                                           \\\n    vec2  R = iResolution.xy, U,  T = iTime - vec2(0,11),          \\\n          S = abs( cos(T) ),      s = max(S,S.yx);                 \\\n    for ( int i = 0; i++ < 7;                                      \\\n          O -= smoothstep(0., 12./R.y, 1. - max( U.x, U.y ) )      \\\n        ) U =   length( U = fract( s*2.*(u+u - R) / R.y ) + vec2(i%3,i/3) -1.5 ) \\\n              * abs( cos( mod( atan(U.y,U.x), 1.57 ) - T ) ) *2./s              /*\n\n\n\n\n\n\n// --- 276 chars\n\n#define mainImage( O, u )                                          \\\n    O++;                                                           \\\n    vec2  R = iResolution.xy, U;                                   \\\n    float t = iTime, s =  max(abs(cos(t)),abs(sin(t)));            \\\n    for ( int i=0; i++ < 9;                                        \\\n          O -= smoothstep(0., 12./R.y, 1. - max( U.x, U.y )*2./s ) \\\n        ) U =   length( U = fract( s*2.*(u+u - R)/R.y ) -1.5 + vec2(i%3,i/3) )   \\\n              * abs( cos( ( fract( atan(U.y,U.x)*.637 ) - .5 )/.637 +vec2(0,11)-t-.79) ) /*\n                                              // .637 = 2/pi\n\n\n\n\n\n// --- 284 chars\n\n#define mainImage( O, u )                                         \\\n    O++;                                                          \\\n    float t = iTime, s =  max(abs(cos(t)),abs(sin(t)));           \\\n    for (int i=0; i<9; i++) {                                     \\\n        vec2 R = iResolution.xy,                                  \\\n             U = fract(s*2.*(u+u - R)/R.y)-.5+vec2(i%3-1,i/3-1);  \\\n        U =  abs(  length( U )                                    \\\n                 * cos( ( fract( atan(U.y,U.x)*.637 ) - .5 )/.637 +vec2(0,11)-t-.79) \\\n                );                                                \\\n        O -= smoothstep(0., 12./R.y, 1. - max( U.x, U.y )*2./s ); \\\n    } /*\n/**/", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsX3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 107, 107, 431]], "test": "ok"}
{"id": "WsXGDH", "name": "endless hypnotic spirals", "author": "morisil", "description": "I replaced chessboard with the spirals.", "tags": ["spiral", "endless", "loop", "rotation", "perspective", "double"], "likes": 3, "viewed": 385, "published": "Public API", "date": "1545957985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 3.0\n\n#define SCENE_ROTATION_SPEED -0.1\n\n#define PLANE_ROTATION_SPEED 0.3\n\n#define EDGE_SHARPNESS 20000.0\n\n#define AIR_PERSPECTIVE 2.0\n\n#define SPIRAL_SPEED 5.0\n\nmat2 rotate2d(float angle){\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    pixel *= rotate2d(iTime * SCENE_ROTATION_SPEED);\n    vec2 trans = vec2(pixel.x / pixel.y, 1.0 / pixel.y);\n    trans *= rotate2d(iTime * PLANE_ROTATION_SPEED);    \n    trans *= SCALE;\n    \n    vec2 inner = mod(trans, 2.0) - vec2(1);\n    float angle = atan(inner.x, inner.y);\n    float dist = length(inner);\n    float luminance = sin(dist * 16.0 + angle - (iTime * SPIRAL_SPEED));\n\n    // apply air perspective\n    luminance *= pow(abs(pixel.y * 2.0), AIR_PERSPECTIVE);\n    fragColor = vec4(vec3(luminance),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 202, 202, 292], [295, 295, 350, 350, 934]], "test": "ok"}
{"id": "wsXGRH", "name": "tj circle draw", "author": "TownKing", "description": "tj circle draw", "tags": ["circledrw"], "likes": 0, "viewed": 337, "published": "Public API", "date": "1544891999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE1 .1031\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tfloat mWidth = min(iResolution.x,iResolution.y);\n    float pixle = 1.0/mWidth;\n    vec2 uv=fragCoord*pixle;\n    vec2 center = vec2(0.5,0.65)*iResolution.xy*pixle;\n    vec2 moveP=uv - center;\n    float len = length(moveP);\n    float ang =(atan(uv.y/uv.x)/3.1416+1.0)/2.0;\n    float circle = 0.0;\n    float vR=0.0;\n    vec3 rgb=vec3(0.0);\n    for(int i = 0; i < 1000; i+=1){\n   \t\tfloat now = float(i)/100.0;\n        float  dotAng = now*3.1415*2.0;\n        float virRad = now*(1.0+vR);\n        \n         if (i > 800){\n            vR=0.0;\n\t\tbreak;\n        }\n        \n        if (i >=450){\n        \tdotAng = 4.50*3.1415*2.0;\n            vR+=0.025;\n        }\n        float x = center.x+pow(virRad,0.9)/13.0*sin(dotAng);\n        float y = center.y+pow(virRad,0.9)/13.0*cos(dotAng);\n        float dotLen = length(vec2(x,y)-uv);\n        circle=smoothstep(0.03,0.0375,dotLen)-smoothstep(0.0375,0.04,dotLen);\n         if(i>600){\n            rgb=vec3(sin(dotLen*dotAng*iTime),cos(dotLen*dotAng*iTime),max(sin(dotLen*dotAng*iTime),cos(dotLen*dotAng*iTime)));\n\t\t\tcircle=0.0;\n            break;\n            }\n        \n        if(circle!=0.0){\n         rgb=vec3(hash12(vec2(virRad,virRad)),hash12(vec2(x,y)),hash12(vec2(uv.x,uv.y)));\n        //rgb=vec3(fract(sin(len*dotAng)),fract(cos(len*dotAng)),fract(max(sin(len*dotAng),cos(len*dotAng))));\n            if(i>600){\n            rgb=vec3(sin(dotLen*dotAng*iTime),cos(dotLen*dotAng*iTime),max(sin(dotLen*dotAng*iTime),cos(dotLen*dotAng*iTime)));\n\n            }\n\t\tbreak;\n        }\n       \n        if(float(i)>iTime*10.0){\n           \n        break;\n        }\n       \n    }\n    \n    // Time varying pixel color\n    vec3 col =  rgb*circle;\n        //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 171], [173, 173, 230, 280, 2061]], "test": "ok"}
{"id": "wsXGRN", "name": "Height map test", "author": "yasuo", "description": "Height map for terrain.", "tags": ["terrain", "heightmap"], "likes": 3, "viewed": 445, "published": "Public API", "date": "1545143359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n\tvec2 prevP = p;\n    \n    p.y += iTime*0.5;\n    float n = cnoise(p);\n    \n    prevP.y = 0.0;\n    float l = length(prevP);\n    float lSize = 0.9;\n    vec3 c = n-(vec3(lSize, lSize, lSize)-vec3(l,l,l));\n\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 108, 108, 144], [145, 145, 166, 166, 203], [205, 205, 226, 226, 1303], [1305, 1305, 1362, 1362, 1677]], "test": "ok"}
{"id": "XlGBDt", "name": "Noise2D ", "author": "felipunkerito", "description": "Thanks iq!", "tags": ["2d", "noise"], "likes": 0, "viewed": 502, "published": "Public API", "date": "1544433235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VALUENOISE\n\n\nfloat hash( vec2 a )\n{\n\n    return fract( sin(  dot( a, vec2( 3433.8, 3843.98) ) ) * 45933.8 );\n\n}\n\n/*\nfloat noise( vec2 uv )\n{\n    \n    vec2 lv = fract( uv );\n    lv = lv * lv * ( 3.0 - 2.0 * lv );\n    vec2 id = floor( uv );\n    \n    vec2 bIn = vec2( hash( id ), hash( id + vec2( 1, 0 ) ) );\n    \n    vec2 tIn = vec2( hash( id + vec2( 0, 1 ) ), hash( id + vec2( 1 ) ) );\n    \n    vec2 bT = vec2( mix( bIn.x, bIn.y, lv.x ), mix( tIn.x, tIn.y, lv.x ) );\n    \n    float c = mix( bT.x, bT.y, lv.y );\n    \n    return c;\n\n}\n*/\n\n// Succint version by Fabrice\nfloat noise( vec2 U )\n{\n    vec2 id = floor( U );\n          U = fract( U );\n    U *= U * ( 3. - 2. * U );  \n    \n    vec2 A = vec2( hash(id)            , hash(id + vec2(0,1)) ),  \n         B = vec2( hash(id + vec2(1,0)), hash(id + vec2(1,1)) ),  \n         C = mix( A, B, U.x);\n    \n    return mix( C.x, C.y, U.y );\n}\n\n\nfloat noise( in vec3 x )\n{\n\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3( 0 );\n    \n    #ifdef VALUENOISE\n    \n    col = vec3( noise( uv * 20.0 + iTime ) );\n    \n    #else\n    \n    col = vec3( noise( vec3( uv * 20.0 + iTime * 0.3, 1.0 ) ) );\n\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 43, 43, 119], [544, 574, 597, 597, 890], [893, 893, 919, 919, 1148], [1150, 1150, 1207, 1257, 1592]], "test": "error"}
{"id": "XlGBDy", "name": "Here be dragons", "author": "kosua20", "description": "This is a ray-marched GLSL implementation of the \"Here be dragons\" scene ; I'm trying to recreate/render the same 3D scene using multiple graphics techniques, frameworks and platforms. \nMore info: [url]http://simonrodriguez.fr/dragon[/url]\n", "tags": ["raymarching", "sdf", "dragon", "herebdedragons"], "likes": 5, "viewed": 420, "published": "Public API", "date": "1543870200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Here be dragons, by Simon Rodriguez, 2018.\n   More details on the overall project at http://simonrodriguez.fr/dragon\n   Code for each version of the scene available at https://github.com/kosua20/herebedragons\n*/\n\n/* Uncomment to disable the soft min/max operations and use basic \n unions/intersections instead. This will speed up the compilation\n but degrade the look. */\n//#define NO_SOFT_OPS\n\n/* Comment to remove the monkey. */\n#define SHOW_MONKEY\n\n/* Comment to remove the dragon. */\n#define SHOW_DRAGON\n\n\n/* Comment to disable any texture use. */\n#define USE_TEXTURES\n\n/* Comment to remove the cloud noise in the sky. */\n#define USE_NOISE\n\n//// PI defines\n\n#define M_PI (3.14159)\n#define M_PI_2 (2.0*M_PI)\n#define M_PI_O_2 (M_PI/2.0)\n\n\n//// Transformations\n\n// vector to transform, angle *in radians* \nvec2 rotate(vec2 v, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec2(\n        c * v.x - s * v.y,\n        s * v.x + c * v.y\n    );\n}\n\n// vector to transform, translation to apply, ZYX euler angles *in degrees*\nvec3 transform(vec3 p, vec3 t, vec3 r){\n    vec3 rP = p - t;\n    vec3 angles = M_PI/180.0 * r;\n    rP.xy = rotate(rP.xy, angles.x);\n    rP.xz = rotate(rP.xz, angles.y);\n    rP.yz = rotate(rP.yz, angles.z);\n    return rP;\n}\n\n//// Noise utilities\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 interpolation(vec3 x){\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat grad(vec3 corner, vec3 p){\n    // Position relative to current corner.\n    p = p - corner;\n    // \"Random\" number.\n  \tfloat t = floor(permute(permute( permute(corner.x) + corner.y) + corner.z));\n    // We use 16 gradients.\n    vec4 tmods = mod(vec4(t), vec4(16.0, 8.0, 4.0, 2.0));\n   \t// Compute dot(p, gradient)\n    float mul0 = 1.0-2.0*tmods.w;\n    float mul1 = tmods.z < 2.0 ? 1.0 : -1.0;\n    float num0 = tmods.x < 8.0 ? p.x : p.y;\n    float num1 = tmods.y < 4.0 ? p.y : p.z;\n    return mul0*num0+mul1*num1;\n}\n\nfloat pnoise(vec3 p){\n\t// Find the cube we are in.\n    vec3 base = floor(p);\n\tvec3 blend = interpolation(p - base);\n    vec2 bins = vec2(0.0,1.0);\n    // Mix between corner gradients, using the inteprolation weights.\n    float res = mix(\n    \tmix(\n        \tmix(grad(base+bins.xxx, p), grad(base+bins.yxx,p), blend.x),\n   \t\t\tmix(grad(base+bins.xyx, p), grad(base+bins.yyx,p), blend.x),\n        \tblend.y),\n    \tmix(\n        \tmix(grad(base+bins.xxy,p), grad(base+bins.yxy,p), blend.x),\n   \t\t\tmix(grad(base+bins.xyy,p), grad(base+bins.yyy,p), blend.x),\n        \tblend.y),\n        blend.z);\n\treturn res * 0.5 + 0.5;\n}\n\n\nfloat fbm(vec3 pos){\n\tfloat n;\n\tn = pnoise(pos*0.0625)*0.5;\n\tn += pnoise(pos*0.125)*0.25;\n\tn += pnoise(pos*0.25)*0.125;\n\treturn n/0.875;\n}\n\n\n//// Primitive signed distance functions.\n//// (source: IQ, https://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n\nfloat sdSphere(vec3 p, vec3 c, float r){\n    return length(p-c) - r*r;\n}\n\nfloat sdBox(vec3 p, vec3 r){\n    vec3 d = abs(p) - (r);\n    return length(max(d, 0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSmoothBox(vec3 p, vec3 r, float s){\n    vec3 d = abs(p) - (r - s);\n    return length(max(d, 0.0)) - s + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdPlaneH(vec3 p, float h){\n    float dist = p.y + h;\n    return max(abs(dist), 0.0);\n}\n\nfloat sdVerticalCapsule(vec3 p, float h, float r){\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCone(vec3 p, float h, float r1){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(0.0,h);\n    vec2 k2 = vec2(-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:0.0), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCylinder(vec3 p, vec2 h){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/* pos, main radius/height, cap radius,  */\nfloat sdRoundedCylinder(vec3 p,  vec2 h, float rb){\n    vec2 d = vec2( length(p.xz)-2.0*h.x+rb, abs(p.y) - h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTorus(vec3 p, vec2 t){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n//// Sharp boolean operators.\n\n// float min(float a, float b);\n// float max(float a, float b);\n\nvec2 mini(vec2 a, vec2 b){\n    return a.x < b.x ? a : b;\n}\n\nvec2 maxi(vec2 a, vec2 b){\n    return a.x < b.x ? b : a;\n}\n\n\n//// Soft boolean operators.\n//// (source: IQ, https://iquilezles.org/www/articles/smin/smin.htm)\n\nfloat minSoft(float a, float b, float k){\n#ifdef NO_SOFT_OPS\n    return min(a,b);\n#endif\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n\nfloat maxSoft(float a, float b, float k){\n#ifdef NO_SOFT_OPS\n    return max(a,b);\n#endif\n    float h = clamp( 0.5 - 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\nvec2 miniSoft(vec2 a, vec2 b, float k){\n    float s = minSoft(a.x, b.x, k);\n    return vec2(s, a.x < b.x ? a.y : b.y);\n}\n\nvec2 maxiSoft( vec2 d1, vec2 d2, float k ) {\n    float s = maxSoft( d1.x, d2.x, k);\n    return vec2(s, d1.x < d2.x ? d2.y : d1.y);\n}\n\n\n//// Helpers\n//// Generate a primitive with a custom position and orientation.\n\nfloat cylinderSmooth(vec3 p, vec3 t, vec3 r, vec2 h){\n    vec3 rP = transform(p, t, r);\n    return sdRoundedCylinder(rP, h, 0.2);\n}\n\nfloat cylinderFlat(vec3 p, vec3 t, vec3 r, vec2 h){\n    vec3 rP = transform(p, t, r);\n    return sdCylinder(rP, h);\n}\n\nfloat coneSmooth(vec3 p, vec3 t, vec3 r, vec3 h){\n    vec3 rP = transform(p, t, r);\n    return sdRoundCone(rP, h.x, h.y, h.z);\n}\n\nfloat coneFlat(vec3 p, vec3 t, vec3 r, vec2 h){\n    vec3 rP = transform(p, t, r);\n    return sdCone(rP, h.y, h.x);\n}\n\nfloat cubeFlat(vec3 p, vec3 t, vec3 r, vec3 s){\n    vec3 rP = transform(p, t, r);\n    return sdBox(rP, s);\n}\n\nfloat cubeSmooth(vec3 p, vec3 t, vec3 r, vec3 s, float m){\n    vec3 rP = transform(p, t, r);\n    return sdSmoothBox(rP, s, m);\n}\n\n\n\n//// Object signed distance functions.\n\n//// Monkey signed distance function.\n\nvec2 mapMonkey(vec3 p){\n    // The head:\n    // The main skull shape\n    float headBase = sdSphere(p, vec3(0.01, 0.2, 0.124), 0.84);\n    // Two rotated boxes for the face around the eyes\n    vec3 rP = transform(p, vec3(-0.264, 0.168, -0.574), vec3(30.6, 3.0, 14.8));\n    headBase = minSoft(headBase, sdSmoothBox(rP, vec3( 0.489, 0.368, 0.140), 0.25), 0.5);\n    rP = transform(p, vec3(0.264, 0.168, -0.574), vec3(-30.6, 177.0, -14.8));\n    headBase = minSoft(headBase, sdSmoothBox(rP, vec3( 0.489, 0.368, 0.140), 0.25), 0.5);\n    // The chin\n    headBase = minSoft(headBase, sdCylinder(p - vec3(0.0, -0.59, -0.569), vec2(0.15, 0.3)), 0.5);\n    headBase = minSoft(headBase, sdVerticalCapsule(p.yxz - vec3(-0.819, -0.1,-0.546), 0.25, 0.1), 0.5);\n    // The ears\n    vec3 earLP = transform(p, vec3(-0.844, 0.15 ,0.151), vec3(-70.7, 0.0, 0.0)); \n    vec3 earRP = transform(p, vec3(0.844, 0.15, 0.151), vec3(70.7, 180.0, 0.0));\n    float ears = min(sdRoundedCylinder(earLP , vec2(0.12, 0.25), 0.26), sdRoundedCylinder(earRP, vec2(0.12, 0.25), 0.26));\n    headBase = minSoft(headBase, ears, 0.5);\n    // Add the base material\n    vec2 monkey = vec2(headBase, 1.0);\n    \n    // The nose\n    float nose = minSoft(sdSphere(p, vec3( -0.05, -0.213, -0.748), 0.3), sdSphere(p, vec3(  0.05, -0.213, -0.748), 0.3), 0.07);\n    monkey = miniSoft(monkey, vec2(nose, 7.0), 0.07);\n    // The mouth (difference)\n    monkey = maxiSoft(monkey, vec2(-sdVerticalCapsule(p.yxz - vec3(-0.8, -0.0,-0.74), 0.1, 0.05), 5.0), 0.05);\n   \n    // The inside of the ears (difference)\n    float innerEars = min(sdRoundedCylinder(earLP + vec3(0.02, -0.15, 0.1) , vec2(0.1,0.04), 0.2), sdRoundedCylinder(earRP + vec3(0.02, -0.15, -0.1) , vec2(0.1, 0.04), 0.2));\n    monkey = maxiSoft(monkey, vec2(-innerEars, 6.0), 0.2);\n     \n    // The eyes, with their pupils and irises\n    vec2 leftEye = vec2(sdSphere(p,  vec3( -0.338, 0.228, -0.67), 0.42), 2.0);\n    vec2 rightEye = vec2(sdSphere(p,  vec3( 0.338, 0.228, -0.67), 0.42), 2.0);\n    vec2 leftEyeI = vec2(sdSphere(p, vec3( -0.338, 0.228, -0.75), 0.34), 3.0);\n    vec2 leftEyeP = vec2(sdSphere(p, vec3( -0.338, 0.228, -0.805), 0.26), 4.0);\n    vec2 rightEyeI = vec2(sdSphere(p,vec3(  0.338, 0.228, -0.75), 0.34), 3.0);\n    vec2 rightEyeP = vec2(sdSphere(p,vec3(  0.338, 0.228, -0.805), 0.26), 4.0);\n    \n    // Merge everything.\n    leftEye = mini(mini(leftEye, leftEyeI), leftEyeP);\n    rightEye = mini(mini(rightEye, rightEyeI), rightEyeP);\n    monkey = mini(mini(monkey, leftEye), rightEye);\n    return monkey;\n}\n\n//// Dragon signed distance function.\n\nvec2 mapFoot(vec3 p){\n    // The fingers.\n    float footFingers = coneSmooth(p, vec3(0.0), vec3(-0.0, 0.0, -90.0), vec3(0.12, 0.08, 0.3));\n    footFingers = min(footFingers, coneSmooth(p, vec3(0.0), vec3(-0.0, 30.0, -90.0), vec3(0.12, 0.08, 0.3)));\n    footFingers = min(footFingers, coneSmooth(p, vec3(0.0), vec3(-0.0, -30.0, -90.0), vec3(0.12, 0.08, 0.3)));\n    // The nails.\n    float footNails = coneSmooth(p, vec3(0.15, 0.0, 0.3), vec3(-0.0, 15.0, -90.0), vec3(0.07, 0.01, 0.15));\n    footNails = min(footNails, coneSmooth(p, vec3(0.0, 0.0, 0.35), vec3(-0.0, 0.0, -90.0), vec3(0.07, 0.01, 0.15)));\n    footNails = min(footNails, coneSmooth(p, vec3(-0.15, 0.0, 0.28), vec3(-0.0, -15.0, -90.0), vec3(0.07, 0.01, 0.15)));\n    // Merge and assign the proper material.\n    return mini(vec2(footFingers, 8.0), vec2(footNails, 9.0));\n}\n\nvec2 mapJaw(vec3 p){\n    // Two cylinders for the jaw itself.\n    float jawbase = cylinderFlat(p, vec3(-0.012, -0.128, -0.043), vec3(95.2, -188.0, 7.3 ), vec2(0.048, 0.323));\n    jawbase = minSoft(jawbase, cylinderFlat(p, vec3(-0.012, -0.128, 0.178), vec3(-86.0, -173.0, 172.0), vec2(0.048, 0.323)), 0.2);\n    // Add a half torus at the front.\n    vec3 rP = p - vec3(-0.32, -0.12, 0.02);\n    float jawFrontBottom = sdTorus(rP, vec2(0.12, 0.04));\n    // Cut it in half by intersecting with a box.\n    jawFrontBottom = maxSoft(jawFrontBottom, sdBox(rP + vec3(0.5, 0.0, 0.0), vec3(0.5, 1.0, 1.0)), 0.1);\n    // Merge, assign material.\n    vec2 jawBottom = vec2(minSoft(jawbase, jawFrontBottom, 0.1), 8.0);\n    // The tongue.\n    float tongue = cubeFlat(p, vec3(-0.029, -0.105, 0.067), vec3(0.0, -98.6, 0.0), vec3(0.02, 0.001,0.3));\n    // Merge with the jaw.\n    jawBottom = miniSoft(jawBottom, vec2(tongue, 5.0), 0.14) ;\n    // The teeth.\n    // Two fangs, using cones.\n    float toothBottom = coneFlat(p, vec3(-0.32, -0.058, 0.1), vec3(0.0, -25.2, 0.0), vec2(0.04, 0.08));\n    toothBottom = min(toothBottom, coneFlat(p, vec3(-0.3, -0.058, -0.05), vec3(0.0, -25.2, 0.0), vec2(0.04, 0.08)));\n    return mini(vec2(toothBottom, 6.0), jawBottom);\n}\n\nvec2 mapDragonHead(vec3 p){\n    // Bottom jaw.\n    vec2 jawBottom = mapJaw(p);\n    // Add the pointy tongue.\n    vec2 spikingTongue = vec2(coneSmooth(p, vec3(-0.30, -0.12, 0.02), vec3(-54.2, -22.9, 6.23), vec3(0.025, 0.005, 0.2)), 5.0);\n    jawBottom = miniSoft(jawBottom, spikingTongue, 0.1);\n    // Top jaw.\n    vec3 rP = p ;\n    // Flip the jaw and orient it.\n    rP.y = -rP.y;\n    rP.xy = rotate(rP.xy, -0.3);\n    vec2 jawtop = mapJaw(rP);\n    // Add the nose and chin bumps.\n    jawtop = miniSoft(jawtop, vec2(sdSphere(p, vec3(-0.3, 0.25, 0.025), 0.22), 8.0), 0.1);\n    jawBottom = miniSoft(jawBottom, vec2(sdSphere(p, vec3(-0.4, -0.2, 0.025), 0.15), 8.0), 0.15);\n    vec2 combinedHead = mini(jawBottom, jawtop);\n    // Merge both jaws with the base head.\n    float baseHead = cubeSmooth(p, vec3(0.163, 0.25, 0.1), vec3(9.41, -7.33, 0.0), vec3(0.2, 0.04, 0.15), 0.07);\n    combinedHead = miniSoft(combinedHead, vec2(baseHead, 8.0), 0.3);\n\n    // Spikes on both sides and the neck.\n    // Left spikes: a series of rounded cones.\n    float leftSpikes = coneSmooth(p, vec3(0.286, 0.236,-0.04), vec3(60.0, -29.1, -4.2), vec3(0.05, 0.01, 0.32));\n    leftSpikes = min(leftSpikes, coneSmooth(p, vec3(0.35,0.16,-0.05), vec3(82.6, -26.9, -5.0), vec3(0.056, 0.01, 0.34)));\n    leftSpikes = min(leftSpikes, coneSmooth(p, vec3(0.40,0.064,-0.09), vec3(84.1,-30.5,14.1), vec3(0.056,0.01,0.28)));\n    leftSpikes = min(leftSpikes, coneSmooth(p, vec3(0.42,-0.037,-0.12), vec3(105.0,-0.0,15.0), vec3(0.056,0.01,0.28)));\n    // Same for the right spikes.\n    float rightSpikes = coneSmooth(p, vec3(0.286, 0.236,0.22), vec3(60.0, -29.1, 0.0), vec3(0.05, 0.01, 0.32));\n    rightSpikes = min(rightSpikes, coneSmooth(p, vec3(0.35,0.16,0.23), vec3(82.6, -26.9, -15.0), vec3(0.056, 0.01, 0.34)));\n    rightSpikes = min(rightSpikes, coneSmooth(p, vec3(0.43,0.064,0.27), vec3(84.1,-20.5,-28.0), vec3(0.056,0.01,0.28)));\n    rightSpikes = min(rightSpikes, coneSmooth(p, vec3(0.44,-0.037,0.3), vec3(105.0,-10.0,-35.0), vec3(0.056,0.01,0.28)));\n    // And the center spikes.\n    float centerSpikes = coneSmooth(p, vec3(0.45,0.2,0.1), vec3(70.0,0.0,-0.0), vec3(0.06,0.02,0.5));\n    centerSpikes = min(centerSpikes, coneSmooth(p, vec3(0.58,0.3,0.1), vec3(20.0,0.0,-0.0), vec3(0.04,0.01,0.2)));\n    // Merge all spikes.\n    vec2 spikes = vec2(min(min(leftSpikes, rightSpikes), centerSpikes), 8.0);\n    // Add them to the head.\n    combinedHead = miniSoft(combinedHead, spikes, 0.1);\n    \n    // Finally the eyes.\n    float eyes = sdSphere(p, vec3(-0.07, 0.25, 0.12), 0.18);\n    eyes = min(eyes, sdSphere(p, vec3(-0.05, 0.25, -0.0), 0.18));\n    // Pupils.\n    float eyeDots = sdSphere(p, vec3(-0.09, 0.26, 0.115), 0.12);\n    eyeDots = min(eyeDots, sdSphere(p, vec3(-0.07, 0.26, -0.0), 0.12));\n    // Combine everything.\n    vec2 mergedEyes = mini(vec2(eyes, 11.0), vec2(eyeDots, 4.0));\n    return mini(combinedHead, mergedEyes);;\n}\n\nvec2 mapDragon(vec3 p){\n\t// Body: combine tori and cylinders.\n\t// Four tori, each intersected with one (or two) boxes to only keep half of it..\n    vec3 rP = p - vec3(-0.35, 0.8, -0.9);\n    float topbody = sdTorus(rP.yxz, vec2(0.35, 0.2));\n    topbody = maxSoft(topbody, sdBox(rP - vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    rP = p - vec3(-0.35, 0.25, -0.1);\n    float topbody1 = sdTorus(rP.yxz, vec2(0.35, 0.2));\n    topbody1 = maxSoft(topbody1, sdBox(rP + vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    rP = p - vec3(-0.55, 0.25, -1.45);\n    rP.xz = rotate(rP.xz, 0.6);\n    float topbody2 = sdTorus(rP.yxz, vec2(0.34, 0.2));\n    topbody2 = maxSoft(topbody2, sdBox(rP + vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    rP = p - vec3(-0.35, 0.8, 0.5);\n    float topbody3 = sdTorus(rP.yxz, vec2(0.34, 0.2));\n    topbody3 = maxSoft(topbody3, sdBox(rP - vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    topbody3 = maxSoft(topbody3, sdBox(rP - vec3(0.0, 0.5, -1.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    // Merge the tori.\n    float dragonBody = topbody3;\n    dragonBody = min(topbody1, dragonBody);\n    dragonBody = min(topbody, dragonBody);\n    dragonBody = min(topbody2, dragonBody);\n    // Add junction cylinders.\n    dragonBody = minSoft(cylinderSmooth(p, vec3(-0.35,0.51,0.2), vec3(0.0, -0, 10.0), vec2(0.105, 0.25)), dragonBody, 0.1);\n    dragonBody = minSoft(cylinderSmooth(p, vec3(-0.35,0.55,-0.51), vec3(0.0, -0, 10.0), vec2(0.105, 0.25)), dragonBody, 0.1);\n    dragonBody = minSoft(cylinderSmooth(p, vec3(-0.35,0.51,-1.2), vec3(0.0, -0, 10.0), vec2(0.105, 0.25)), dragonBody, 0.1);\n    // Smooth a bit the whole body.\n    dragonBody -= 0.025;\n    // Add the tail.\n    dragonBody = minSoft(coneSmooth(p, vec3(-0.75,0.32,-1.74), vec3(30.0, -50.0, -20.0), vec3(0.18, 0.01, 0.8)), dragonBody, 0.1);\n    \n    // The end of the tail: two flat boxes rotated by 45 and merged.\n    vec3 tP = p - vec3(-0.7, 1.2, -1.6);\n    tP.xy = rotate(tP.xy, -0.7);\n    tP.yz = rotate(tP.yz, 0.4);\n    tP.xz = rotate(tP.xz, 0.4);\n    float dragonTail = sdSmoothBox(tP, vec3(0.02,0.18, 0.18), 0.04);\n    tP.yz = rotate(tP.yz, 0.6);\n    dragonTail = min(dragonTail, sdSmoothBox(tP, vec3(0.02,0.18, 0.18), 0.04));\n    // Add the end of the tail to the body.\n    float dragonMain = minSoft(dragonBody, dragonTail, 0.25);\n    \n    // Legs.\n    // The left back leg has three components because of the weird knee-spike.\n    float leftBackLeg = cylinderSmooth(p, vec3(-0.7, 0.298, -1.15), vec3(15.2, 80.0, 46.9), vec2(0.071, 0.296));\n    leftBackLeg = min(leftBackLeg, cylinderSmooth(p, vec3(-0.85, 0.2, -1.2), vec3(-5.0, 15.2, -1.0), vec2(0.071, 0.296)));\n    leftBackLeg = minSoft(leftBackLeg, coneSmooth(p, vec3(-0.85, 0.7, -1.2), vec3(20.0, 25.0, -1.0), vec3(0.09, 0.03, 0.3)), 0.1);\n    // Merge with the foot.\n    vec2 leftBackFoot = mini(mapFoot(p - vec3(-0.85, -0.2, -1.2)), vec2(leftBackLeg, 8.0));\n    \n    // Right back leg, only one cylinder needed.\n    float rightBackLeg = cylinderSmooth(p, vec3(-0.2, -0.13, -1.4), vec3(20.0, 20.0, 80.0), vec2(0.071, 0.2));\n    vec2 rightBackFoot = mini(mapFoot(p - vec3(-0.1, -0.2, -1.2)), vec2(rightBackLeg, 8.0));\n    \n    // Right front leg, two cylinders.\n    float rightFrontLeg = cylinderSmooth(p, vec3(-0.05, -0.15, -0.1), vec3(20.0, 20.0, 90.0), vec2(0.071, 0.1));\n    rightFrontLeg = min(rightFrontLeg, cylinderSmooth(p, vec3(-0.05, 0.05, -0.05), vec3(-90.0, 40.0, 90.0), vec2(0.071, 0.18)));\n    vec2 rightFrontFoot = mini(mapFoot(p - vec3(-0.0, -0.2, 0.1)), vec2(rightFrontLeg, 8.0));\n    \n    // Left front leg: two cylinders.\n    float leftFrontLeg = cylinderSmooth(p, vec3(-0.7, -0.0, -0.1), vec3(10.0, -20.0, 110.0), vec2(0.071, 0.1));\n    leftFrontLeg = min(leftFrontLeg, cylinderSmooth(p, vec3(-0.65, 0.05, -0.05), vec3(-90.0, 40.0, 90.0), vec2(0.071, 0.18)));\n    // For the left front leg, the foot is custom, to wrap it around the blue stone.\n    vec3 lP = p - vec3( -0.8, 0.05, 0.1);\n    // Fingers.\n    float leftFrontFootBase = coneSmooth(lP, vec3(0.0), vec3(-0.0, 0.0, -90.0), vec3(0.12, 0.08, 0.3));\n    leftFrontFootBase = min(leftFrontFootBase, coneSmooth(lP, vec3(0.0), vec3(-0.0, 30.0, -90.0), vec3(0.12, 0.08, 0.3)));\n    leftFrontFootBase = min(leftFrontFootBase, coneSmooth(lP, vec3(0.0), vec3(-0.0, -30.0, -100.0), vec3(0.12, 0.08, 0.3)));\n    // Nails.\n    float leftFrontFootNails = coneSmooth(lP, vec3(0.15, 0.0, 0.3), vec3(-0.0, 15.0, -150.0), vec3(0.07, 0.02, 0.15));\n    leftFrontFootNails = min(leftFrontFootNails, coneSmooth(lP, vec3(0.0, 0.0, 0.35), vec3(-0.0, 0.0, -150.0), vec3(0.07, 0.02, 0.15)));\n    leftFrontFootNails = min(leftFrontFootNails, coneSmooth(lP, vec3(-0.15, -0.08, 0.28), vec3(-0.0, -15.0, -150.0), vec3(0.07, 0.02, 0.15)));\n    // Merge the fingers and nails.\n    vec2 leftFrontFoot = vec2(min(leftFrontFootBase, leftFrontFootNails), leftFrontFootBase < leftFrontFootNails ? 8.0 : 9.0);\n    // Add the leg.\n    leftFrontFoot = miniSoft(leftFrontFoot, vec2(leftFrontLeg, 8.0), 0.1);\n    // And add a blue sphere under the foot.\n    leftFrontFoot = mini(leftFrontFoot, vec2(sdSphere(p, vec3(-0.75, -0.1, 0.3), 0.45), 10.0)); \n    // Merge all feet.\n    vec2 feetMerged = mini(mini(mini(leftBackFoot, rightBackFoot),rightFrontFoot), leftFrontFoot);\n    \n    // Finally the head.\n    vec3 headPos = p - vec3(-0.45, 1.2, 0.7);\n    headPos.xz = rotate(headPos.xz, M_PI_O_2);\n    vec2 dragonHead = mapDragonHead(headPos);\n\n    // Merge everything.\n    return miniSoft(miniSoft(vec2(dragonMain, 8.0), feetMerged, 0.2), dragonHead, 0.2);\n}\n\n//// Scene signed distance function.\n\nvec2 map(vec3 p){\n    \n    // Ground.\n    float ground = sdPlaneH(p, 1.01);\n    vec2 res = vec2(ground, 0.0);\n   \n    // Monkey.\n#ifdef SHOW_MONKEY\n    // Compute position.\n    const float monkeyScale = 0.35;\n    const vec3 monkeyShift = vec3(-1.25, -0.2, 0.25);\n    vec3 monkeyP = p - monkeyShift;\n    monkeyP /= monkeyScale;\n    // Animate the monkey.\n    monkeyP.xz = rotate(monkeyP.xz, mod(iTime, M_PI_2));\n    // Basic culling: approximate as a sphere, and use its SDF if far enough.\n    float monkeyCull = monkeyScale*(sdSphere(p, monkeyShift, 1.0) );\n    if(monkeyCull < 1.0){\n        // Get our distance to the monkey.\n        vec2 monkey = mapMonkey(monkeyP);\n        // Compensate the scaling.\n        monkey.x *= monkeyScale;\n        // Store the result if closer.\n        res = mini(res, monkey);\n    } else {\n        // Use the sphere SDF instead, adjusted so that isolines align with the full SDF isolines.\n        res = mini(res, vec2(2.0*monkeyCull + 0.57));\n    }\n#endif\n    \n    // Dragon.\n#ifdef SHOW_DRAGON\n    // Compute position.\n    const vec3 dragonShift = vec3(0.5, -0.75, 0.5);\n    vec3 dragonP = p - dragonShift;\n    // Basic culling: approximate as a sphere, and use its SDF if far enough.\n    float dragonCull = (sdSphere(dragonP, vec3(-0.3,0.5,-0.7), 1.3) );\n    if(dragonCull<1.0){\n        // Get our distance to the dragon.\n        vec2 dragon = mapDragon(dragonP);\n         // Store the result if closer.\n        res = mini(res, dragon);\n    } else {\n         // Use the sphere SDF instead, adjusted so that isolines align with the full SDF isolines.\n        res = mini(res, vec2(dragonCull));\n    }\n #endif\n    \n    return res;\n}\n\n\n\n///// Geometry helpers.\n\n// Compute the normal to the surface of the scene at a given world point.\n/*vec3 normal(vec3 p){\n    const vec2 epsilon = vec2(0.02, 0.0); //...bit agressive.\n    // Use centered finite differences scheme.\n    return normalize(vec3(\n        map(p + epsilon.xyy).x - map(p - epsilon.xyy).x,\n        map(p + epsilon.yxy).x - map(p - epsilon.yxy).x,\n        map(p + epsilon.yyx).x - map(p - epsilon.yyx).x\n    ));\n    \n}*/\n\n// Compute the normal to the surface of the scene at a given world point.\nvec3 normalCheap(vec3 p){\n    const vec2 epsilon = vec2(0.02, 0.0); //...bit agressive.\n    float dP = map(p).x;\n    // Forward differences scheme, cheaper.\n    return normalize(vec3(\n        map(p + epsilon.xyy).x - dP,\n        map(p + epsilon.yxy).x - dP,\n        map(p + epsilon.yyx).x - dP \n    ));\n}\n\n// Origin and direction of the ray, distance to the hit, last step distance and material id.\nbool raymarch(vec3 orig, vec3 dir, out float t, out vec2 res){\n    // Reset.\n    t = 0.0;\n    res = vec2(0.0);\n    // Step through the scene.\n    for(int i = 0; i < 96; ++i){\n        // Current position.\n        vec3 pos = orig + t * dir;\n        // Query the distance to the closest surface in the scene.\n        res = map(pos);\n        // Move by this distance.\n        t += res.x;\n        // If the distance to the scene is small, we have reached the surface.\n        if(res.x < 0.01){\n            return true;\n        }\n    }\n    return false;\n}\n\nconst vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\nconst vec3 groundTint = vec3(0.9, 0.9, 1.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Compute ray in view space.\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy-1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 dir = normalize(vec3(uv, 1.0));\n    vec3 eye = vec3(0.0, 0.0, -2.25);\n    // Move camera around center based on cursor position.\n    \n    float horizAngle = -iMouse.x/iResolution.x * M_PI_2 + M_PI * 1.25 + M_PI;\n    float vertAngle = M_PI_O_2 - iMouse.y/iResolution.y * (M_PI_O_2);\n\t// Hack for when the page is just loaded, so that the default viewpoint is interesting.\n\tif(iMouse.x == 0.0 && iMouse.y == 0.0){\n        horizAngle = M_PI * 1.25;\n        vertAngle = 0.0;\n    }\n    // Move eye and dir to world space.\n    eye.yz = rotate(eye.yz, vertAngle);\n    dir.yz = rotate(dir.yz, vertAngle);\n    eye.xz = rotate(eye.xz, horizAngle);\n    dir.xz = rotate(dir.xz, horizAngle);\n    \n    // Check if we intersect something along the ray.\n    float t; vec2 res;\n    bool didHit = raymarch(eye, dir, t, res);\n    \n    // Compute the color of the pixel.\n    vec3 outColor = vec3(0.0);\n    // If we hit a surface, compute it's appearance.\n    if(didHit){\n        // Compute position and normal.\n        vec3 hit = eye + t * dir;\n        vec3 n = normalCheap(hit);\n        \n        // See if the light is occluded by another surface, by marching in the light direction.\n        float tDummy; vec2 resDummy;\n        float shadowingFactor = float(raymarch(hit + 0.02*n, lightDir, tDummy, resDummy));\n\n        // Diffuse lighting.\n        float diffuse = max(dot(n, lightDir), 0.0);\n        diffuse *= (1.0-shadowingFactor);\n        // Specular lighting.\n\t\tfloat specular = max(dot(reflect(-lightDir, n), -dir), 0.0);\n        \n        vec3 baseColor = vec3(1.0,0.0,0.0);\n        if(res.y < 0.5){\n            // Plane texture.\n#ifdef USE_TEXTURES\n            float stones = texture(iChannel0, fract(hit.xz * 0.4)).r;\n#else\n            float stones = clamp(pow(2.0*pnoise(4.0*hit), 2.0), 0.0, 1.0);\n#endif\n            // When reaching the horizon, fade the texture into a unique flat color.\n            float fadingHorizon = 0.5 * clamp(length(hit) / 10.0, 0.0, 1.0) + 0.5;\n            baseColor = mix(stones, 0.2, fadingHorizon) * groundTint;\n            specular = pow(specular, 50.0);\n            \n        } else if(res.y < 1.5){\n            // Monkey skin.\n            baseColor = vec3(122.0, 86.0, 65.0)/255.0;\n\t\t\tspecular = 0.0;\n            \n        } else if(res.y < 2.5){ \n            // Monkey eye. \n            baseColor = vec3(1.0);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 3.5){ \n            // Monkey eye iris.\n            baseColor = vec3(0.1, 0.4, 1.0);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 4.5){ \n            // Monkey eye pupil.\n            baseColor = vec3(0.0);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 5.5){ \n            // Monkey mouth.\n            baseColor = vec3(0.29, 0.12, 0.13);\n\t\t\tspecular = pow(specular, 80.0);\n\n        } else if(res.y < 6.5){ \n            // Monkey ears.\n            baseColor = vec3(227.0, 180.0, 100.0)/255.0;\n\t\t\tspecular = 0.0;\n\n        } else if(res.y < 7.5){ \n            // Monkey nose.\n            baseColor = 0.9*vec3(0.84, 0.7, 0.69);\n\t\t\tspecular = 0.0;\n            \n        } else if(res.y < 8.5){ \n            // Dragon skin.\n            // Apply some high frequency details.\n#ifdef USE_TEXTURES\n            float scales = 0.25 * texture(iChannel1, 2.0 * hit.yz).r + 0.25;\n#else\n            float scales = 0.25*pnoise(40.0*hit.yxz)+0.25;\n#endif\n            baseColor = scales * vec3(0.2, 0.9, 0.1);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 9.5){ \n            // Dragon nails.\n            baseColor = vec3(0.8, 0.9, 0.5);\n\t\t\tspecular = 0.0;\n\n        } else if(res.y < 10.5){ \n            // Dragon blue stone.\n            // Apply some high frequency details.\n#ifdef USE_TEXTURES\n            float scales = texture(iChannel1, n.xy).r;\n#else\n            float scales = pnoise(30.0*hit.yxz);\n#endif\n            baseColor = scales * vec3(0.0, 0.7, 1.0);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 11.5){ \n            // Dragon eye.\n            baseColor = vec3(1.0, 0.15, 0.0);\n\t\t\tspecular = pow(specular, 100.0);\n        }\n\n        //Apply diffuse and ambient shading to the base color.\n        outColor = (diffuse + 0.1) * baseColor + specular;\n  \n    } else {\n        // We haven't hit anything, it's the sky.\n        // Mix between two colors picked from the \"miramar\" cubemap.\n        // Use FBM noise based on Perlin noise.\n#ifdef USE_NOISE\n        float scale = fbm(dir*45.0);\n#else\n        float scale = clamp(dir.y+0.2, 0.0, 1.0);\n#endif\n        outColor = mix(vec3(0.24, 0.27, 0.33), 1.5*vec3(0.53, 0.67, 0.72), scale*scale);\n    }\n\n    // Output to screen, apply gamma correction.\n    fragColor = vec4(pow(outColor, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGBDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[766, 810, 843, 843, 974], [976, 1052, 1091, 1091, 1274], [1298, 1298, 1321, 1321, 1370], [1372, 1372, 1396, 1396, 1436], [1438, 1438, 1465, 1465, 1521], [1523, 1523, 1555, 1599, 2042], [2044, 2044, 2065, 2094, 2656], [2659, 2659, 2679, 2679, 2797], [2930, 2930, 2970, 2970, 3002], [3004, 3004, 3032, 3032, 3126], [3128, 3128, 3171, 3171, 3273], [3275, 3275, 3307, 3307, 3367], [3369, 3369, 3419, 3419, 3482], [3484, 3484, 3524, 3524, 3868], [3870, 3870, 3925, 3925, 4203], [4205, 4205, 4238, 4238, 4337], [4339, 4383, 4434, 4434, 4558], [4560, 4560, 4590, 4590, 4655], [4755, 4755, 4781, 4781, 4813], [4815, 4815, 4841, 4841, 4873], [4975, 4975, 5016, 5016, 5145], [5147, 5147, 5188, 5188, 5330], [5332, 5332, 5371, 5371, 5452], [5454, 5454, 5498, 5498, 5586], [5669, 5669, 5722, 5722, 5800], [5802, 5802, 5853, 5853, 5919], [5921, 5921, 5970, 5970, 6049], [6051, 6051, 6098, 6098, 6167], [6169, 6169, 6216, 6216, 6277], [6279, 6279, 6337, 6337, 6407], [6490, 6490, 6513, 6558, 9017], [9058, 9058, 9079, 9099, 9891], [9893, 9893, 9913, 9954, 11135], [11137, 11137, 11164, 11183, 14039], [14041, 14041, 14064, 14184, 19585], [19625, 19625, 19642, 19662, 21288], [21738, 21812, 21837, 21837, 22116], [22118, 22211, 22273, 22287, 22760], [22863, 22863, 22918, 22952, 27763]], "test": "error"}
{"id": "XlGfRm", "name": "torus_thingy_20", "author": "balkhan", "description": " ", "tags": ["3d", "raymarching"], "likes": 5, "viewed": 401, "published": "Public API", "date": "1545196875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t110.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 60.0);\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y >= FAR)\n        ret_col = vec3(.90, .82, .70);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n   return dot(p - origin,normal);   \n}\n\nfloat\tscene(vec3 p)\n{  \n    p.z += -36.;\n    float\tvar;\n    float\tmind = 1e5;\n    float\tcage = 1e5;\n    rotate(p.xz, 1.57-.35*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    vec3 op = p;\n    var  = atan(op.x,op.y);\n    \n    p = op;\n    vec3 pp = p;\n    p.xy = modA(p.xy, 100.);\n    p.x -= 10.+.0*abs(5.*sin(iTime*.25));\n    p.zx = modA(p.zx, 100.);\n    p.z -= 4.+2.*sin(atan(pp.x,pp.y)*2.+atan(p.z)*8.-iTime*0.);\n    \n    mind = length(p.zx)-.0506125;\n    mind = min(mind,\n        length(p.zy)-.0506125\n        );\n    mind = min(mind,\n               length(p)-.10010506125\n               );\n    mind = min(mind,\n               length(p.z+.5*sin(iTime*.5)+.45)-.01001\n               );\n\n    ret_col = vec3(.90, .82, .70);\n    float ball = 1e5;\n    h += vec3(.5, .5, .9)*1./(ball*ball*1.+.25);\n    h -= vec3(-.50,.1250,1.)*vec3(1.)*.0125/(.01+mind*mind);\n    h -= vec3(.05,.05,1.)*vec3(1.)*.0125/(.01+mind*mind);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    ret = max(abs(p.z)+.5*abs(p.x), ret);\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGfRm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[616, 616, 659, 659, 1035], [1108, 1108, 1141, 1141, 1272], [1297, 1297, 1344, 1344, 1384], [1386, 1386, 1407, 1407, 2316], [2318, 2318, 2350, 2350, 2761], [2777, 2777, 2801, 2801, 2898], [2900, 2900, 2924, 2924, 3058], [3060, 3060, 3100, 3100, 3175], [3177, 3177, 3205, 3205, 3313], [3315, 3315, 3337, 3337, 3543], [3545, 3545, 3595, 3595, 3858]], "test": "error"}
{"id": "XlKfW3", "name": "flow field", "author": "kruzifix", "description": "distorted and thresholded voronoi", "tags": ["voronoi"], "likes": 5, "viewed": 198, "published": "Public", "date": "1544295611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 N23(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(a);\n}\n\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat voro(vec2 uv, float t, float dmix)\n{\n    vec2 guv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    float md = 100.;\n    for (float x = -1.; x <= 1.; x++)\n    {\n        for (float y = -1.; y <= 1.; y++)   \n        {\n            vec2 offs = vec2(x, y);\n            vec2 n = N22(id + offs);\n            \n            vec2 p = offs + sin(n * t) * .3;\n            p -= guv;\n            float d1 = length(p);\n            float d2 = abs(p.x) + abs(p.y);\n            \n            float d = mix(d1, d2, dmix);\n            \n            md = min(md, d);\n        }\n    }\n    return md;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.x;\n    \n    float t = iTime*0.5;\n    float mode = step(0.5, fract(t*0.1));\n    \n    float dis = 0.5 * sin(t*0.8);\n    \n    vec2 duv = uv;\n    duv.y += sin(duv.x*3.0+t*0.2)*dis;\n    duv.x += cos(duv.y*2.0-t*0.1)*dis;\n    \n    float m = 0.0;\n    vec3 col = vec3(0);\n    for (float i = 0.0; i <= 10.0; i++) {\n        float dir = sin(i * 0.4 + sin(t * 0.01));\n        dir = mix(dir, -dir, mode);\n        \n        vec2 co = mix(uv, duv, i * 0.1);\n        \n        vec2 p = co * (1.0 + i*0.6)-t*vec2(sin(dir), cos(dir));\n        float tt = 23.0+i*12.0 + t;\n        float md = sin(i * 0.2);\n        \n    \tfloat v = voro(p, tt, md);\n        \n        float th = 0.65 + i * 0.01;\n        float blur = (0.1+i)*0.005;\n        m += smoothstep(th - blur, th + blur, v) * 0.1;\n        \n        float cs = 0.02 + 0.02 * cos(i*0.1);\n        col += m * N23(vec2(i * cs)) * vec3(0.7, 0.7, 1.0);\n    }\n    \n    float k1 = smoothstep(0.1, 0.4, m);\n    float k2 = smoothstep(0.2, 0.3, m);\n    float k3 = smoothstep(0.4, 0.5, m);\n    \n    vec3 col2 = vec3(10, 2, 0) * k1 +\n        vec3(0, 2, 1) * k2 +\n        vec3(0, 10, 1) * k3;\n    \n    vec3 res = mix(col, col2, mode);\n    res = res / (res + 1.0);\n    \n    fragColor = vec4(res, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 127], [129, 129, 147, 147, 281], [283, 283, 325, 325, 867], [869, 869, 924, 924, 2202]], "test": "ok"}
{"id": "XlKfWy", "name": "Myro's first raymarching shader", "author": "Myro", "description": "My first raymarching shader\nhelped by this tutorial\nhttps://www.youtube.com/watch?v=yxNnRSefK94\n\nand these raymarching primitives distance functions \nhttps://www.shadertoy.com/view/Xds3zN", "tags": ["raymarching"], "likes": 2, "viewed": 75, "published": "Public", "date": "1543943534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// first raymarching thing\n// https://www.youtube.com/watch?v=yxNnRSefK94\n\n// raymarching primitives distance functions\n// https://www.shadertoy.com/view/Xds3zN\n    \n\n// distance function for a box\n// input p : - the current path being traced\n// input b : - box vector (width/2, heigth/2, depth/2)\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// distance function for a sphere\n// input p : - the current path being traced\n// input s : - sphere radius\nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n// MAPPING FUNCTION ... raymarching stuff having to do with path tracing\nfloat map (vec3 path) {\n    \n    // makes an infinite repeating pattern\n    path = fract(path) *2.0 -1.0; \n    path.xy *= mat2(cos(0.5*path.z), -sin(.5*path.z), sin(.5*path.z), cos(.5*path.z));\n\t\t\n    // boolean operation : taking a box and extruding a sphere \n\treturn max(box(path,vec3(0.6)),-sphere(path,0.8));\n}\n\n\n// TRACING A PATH : measuring the distance to the nearest object\nfloat trace  (vec3 origin, vec3 ray) {\n\t\n    //t is the point at which we are in the measuring of the distance\n    float t =0.0;\n    \n    for (int i=0; i<32; i++) {\n    \tvec3 path = origin + ray * t;\t\n    \tfloat dist = map(path);\n    \t// we want t to be as large as possible at each step but not too big to induce artifacts\n        t += 0.5 * dist;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t// Pixel coordinates from -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //ray direction (the view plane is at z=1)\n    vec3 ray = normalize(vec3 (uv,1.0));\n\n    //ROTATING THE CAMERA (rotating the ray)\n    float rotTime = iTime/3.0;\n    //rotation matrix around the y axis\n    ray.xz *= mat2(cos(rotTime), -sin(rotTime), sin(rotTime), cos(rotTime));\n    \n    //camera position (rays origin)\n    vec3 origin = vec3 (0.0,0.0,-3); \n    origin = vec3 (0.0,iTime,iTime);           \n    \n    //tracing the ray (getting the distance of the closest object in the ray direction)\n\tfloat depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth * depth * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    // rainbow colors fun\n\tfc.x *= 1.0+sin(1.5*iTime);\n    fc.y *= 1.0-sin(1.5*iTime+5.0);\n    \n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKfWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 298, 327, 327, 418], [420, 528, 561, 561, 587], [590, 663, 686, 734, 977], [980, 1045, 1083, 1155, 1420], [1422, 1422, 1479, 1529, 2553]], "test": "ok"}
{"id": "XlVBRd", "name": "Particles exercise", "author": "Vermifuge", "description": "particles", "tags": ["particles"], "likes": 2, "viewed": 103, "published": "Public", "date": "1543624925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 one = vec2(1., 0.);\nconst float cells = 5.;\n\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(17.2512372,259.12379)))*7326.26723);\n}\n\nfloat noise(vec2 uv) {\n    vec2 ix = floor(uv);\n    vec2 fx = fract(uv);\n    fx = fx*fx*(3.-2.*fx);\n    \n    float bl = hash(ix);\n    float br = hash(ix + one.xy);\n    float tl = hash(ix + one.yx);\n    float tr = hash(ix + one.xx);\n   \n    return mix(\n        mix(bl, br, fx.x),\n        mix(tl, tr, fx.x),\n        fx.y);\n}\n\nfloat fbm(vec2 uv) {\n    float c = .5;\n    float po = 1.;\n    float res = 0.;\n    for (int i = 0; i < 4; ++i) {\n        res += c * noise(uv*po);\n        c /= 2.;\n        po *= 2. + .03 * hash(vec2(po));\n    }\n    return res;\n}\n\nfloat snow(vec2 uv, float cells) {\n    vec2 ruv = uv;\n    uv = uv * cells;\n    float px = noise(floor(uv) + 3.*one.yx * iTime) - .0;\n    float py = noise(floor(uv) + 3.*one.xy * iTime + 23.246*one);\n    float r = .02 + .06*noise(floor(uv) + one.xy * iTime + 235.246);\n    \n    vec2 pt = vec2(px, py);\n    return 1.-smoothstep(0.001, 2.*r, length(fract(uv) - pt));\n}\n\nvec2 wind(float cells) {\n    return 1./cells*iTime * one.yx - 4./cells*iTime * one.xy;\n}\n\nfloat ground(vec3 p) {\n    vec2 hills = p.xz / 5. + iTime;\n    return p.y - 3.*(fbm(hills)-.5) - noise(hills);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.001, 0.);\n    return normalize(vec3(\n        ground(p + e.xyy) - ground(p - e.xyy),\n        ground(p + e.yxy) - ground(p - e.yxy),\n        ground(p + e.yyx) - ground(p - e.yyx)));\n}\n\nvec4 raymarch(vec2 uv) {\n    vec3 camera = vec3(0., 2. + iMouse.y / iResolution.y * 10., -1.);\n    vec3 dir = normalize(vec3(uv - .2 * one.yx, 1.));\n    \n    float t = 0.;\n    vec3 p = camera;\n    for (int i = 0; i < 70; ++i) {\n        vec3 r = camera + t * dir;\n        float d = ground(r);\n        if (d < .001) {\n            p = r;\n        }\n        t += d;\n    }\n    if (t > 100.) {\n        return vec4(p, 0.);\n    }\n    return vec4(vec3(dot(normal(p), one.yxy)), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 screenpos = uv;\n    \n    \n    vec3 col = mix(vec3(.1, .1, .2), vec3(.3, .3, .7), 1.-screenpos.y);\n    vec4 obj = raymarch(uv);\n    col = mix(col, obj.xyz, obj.w);\n    \n    float snowflake = snow(uv + wind(10.), 12.) + snow(uv + wind(15.), 12.)\n        + snow(uv + wind(20.), 20.)\n        + snow(uv + wind(3.), 3.)\n        + snow(uv + wind(6.), 6.);\n    \n    col = mix(col, vec3(1.), snowflake);\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVBRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 71, 71, 144], [146, 146, 168, 168, 468], [470, 470, 490, 490, 696], [698, 698, 732, 732, 1063], [1065, 1065, 1089, 1089, 1153], [1155, 1155, 1177, 1177, 1267], [1269, 1269, 1290, 1290, 1491], [1493, 1493, 1517, 1517, 1967], [1969, 1969, 2026, 2081, 2640]], "test": "timeout"}
{"id": "XlVfWV", "name": "simple smoooth line", "author": "dilip019", "description": "smoooth line", "tags": ["line", "smoooth"], "likes": 6, "viewed": 122, "published": "Public", "date": "1544111195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/4ssSRl\n\n#define Pi 3.14159\n#define smooth true\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.yy;\n\tvec2 uv= fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y; \n  //  vec2 center = \n    vec2 q = p;\n\t\n \tfloat var = 0.9 +0.45* cos(0.5*iTime);\n \tfloat var2 = 0.5+ 0.45*sin(0.5*iTime);\n    // background\t\n\tvec3 col = vec3(0.5,0.85,0.9);\n\t\n\t// compute distance to a set of lines\n    float d   = 0.3;\t \n    \n\tvec2 pA = vec2(0.9,0.50); \t\n    vec2 pB = vec2( var, var2 );\t\n      \n   \tfloat h = line( pA, pB, uv );\n\td = min( d, h );\n\n \tif( smooth )\n\t{\n\t\tfloat w = 0.5*fwidth(d); \n\t\tw *= 1.5; // extra blur\n\t\tcol = mix( vec3(0.0,0.0,0.0), col, smoothstep(-w,w,d-0.04) ); // black\n\t\tcol = mix( vec3(1.0,0.6,0.0), col, smoothstep(-w,w,d-0.02) ); // orange\n\t\t\n\t}\n \telse\n\t{\n \t\tif( d<0.04) col = vec3(0.0,0.0,0.0); // black \n\t\tif( d<0.02 ) col = vec3(1.0,0.6,0.0); // orange\n\t}\n\t \t\n \t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 127, 127, 247], [249, 249, 306, 306, 1196]], "test": "ok"}
{"id": "XlVfzd", "name": "Cloud Fog of War", "author": "esrever2357", "description": "Quick n dirty procedurally generated cloud texture, layered to use as  fog of war for a 2D game. Click and drag to \"reveal\" area. The number of layers is variable based on time, to demonstrate how from a single cloud per cell we can create a dense layer.", "tags": ["2d", "tile"], "likes": 1, "viewed": 227, "published": "Public", "date": "1543652596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TILE_RES_POT 6\n#define TILE_RES (1 << TILE_RES_POT)\n#define NUM_CLOUD_CIRCLES 16\n#define VISIBLE_RADIUS 1.0\n\nfloat randomf(float p)\n{\n    return fract(52.043*sin(p*205.429));\n}\n\nfloat random(int p)\n{\n    return randomf(float(p));\n}\n\nfloat circle(vec2 uv, vec2 c, float r)\n{\n    vec2 d = uv-c;\n    //d.y *= 1.0 + 0.5*abs(c.x-0.5); // pancake them the further from c.x==0.5 they are\n    float val = 1.0 - step(r*r, dot(d,d));\n    float rimdistance = 1.0 - 0.5*smoothstep(r*r*0.01, r*r, dot(d,d));\n    val = val * rimdistance;\n    //vec2 dir = vec2(random(int(uv.x*100.0)), random(int(uv.y*100.0)))*vec2(2.0) - vec2(1.0);\n    vec2 dir = vec2(0.0,1.0);\n    //return max( val * smoothstep( -1.0, 0.0, dot(normalize(vec2(c.x,uv.y)-c), dir)), 0.0);\n    return val * (r*0.85 + uv.y-c.y)/r;\n}\n\n// return cloud intensity in [0,1]^2 space\nfloat cloud( vec2 uv, int seed )\n{\n    float vmax = 0.0;\n    for(int i=0; i < NUM_CLOUD_CIRCLES; ++i)\n    {\n        vec2 coff = 0.25 + 0.5*vec2( random(seed*123 + i), random(seed*234 + i));\n        coff.y = (coff.y-0.5)*(1.0 - coff.x) + 0.5; // allow greater y expansion at the center\n        coff.y += 0.025*sin(0.975*iTime + 10.0*random(seed + 1));\n        float radius = 0.1 + 0.05*random(seed*345 + i);\n        float val = circle(uv, coff,radius) * ( 0.9 + 0.1*random(seed*113+i));\n        vmax= max(vmax,val);\n    }\n    return vmax;\n}\n\nfloat cloud_layer(vec2 uv, ivec2 tileId, int layer_index)\n{\n    return cloud(uv, tileId.x + 1 + tileId.y * 1024 + layer_index);\n}\n\nfloat tile_cloud_opacity( vec2 c0, vec2 c1)\n{\n    float nd = length(c1-c0)/(float(TILE_RES)*sqrt(2.0));\n    nd /= VISIBLE_RADIUS;\n    \n    nd = smoothstep(0.5,1.0,nd);\n    return min(nd,1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cloudsum = 0.0;\n    \n    ivec2 mouseTile = ivec2(iMouse.xy) >> TILE_RES_POT;\n    ivec2 tileIdBase = ivec2(gl_FragCoord.xy) >> TILE_RES_POT;\n    \n    int NUM_CLOUD_LAYERS = 1 + int(iTime)%12;\n    \n    for(int layer_index=0;layer_index<NUM_CLOUD_LAYERS;++layer_index)\n    {\n        vec2 coord = gl_FragCoord.xy + vec2(TILE_RES)*vec2( random(layer_index*123+1), random(layer_index*234+1));\n        ivec2 tileId = ivec2(coord.xy) >> TILE_RES_POT;\n\t\tvec2 uv = fract(coord.xy / vec2(TILE_RES));\n        \n        float intensity = cloud_layer(uv, tileId, layer_index);\n        intensity *= tile_cloud_opacity(gl_FragCoord.xy, iMouse.xy);\n        \n        // blend\n        cloudsum = mix( cloudsum, intensity, intensity);\n    }\n    \n    vec2 borderDiff = abs((gl_FragCoord.xy / float(TILE_RES)) - vec2(tileIdBase));\n    vec2 onBorder2 = vec2(1.0) - smoothstep(vec2(0.0),vec2(0.1), borderDiff);\n    float onBorder = max(onBorder2.x,onBorder2.y);\n    \n    \n    fragColor = vec4(onBorder,0.3,1.0,0.0);\n    fragColor.xyz = mix(fragColor.xyz, vec3(cloudsum), cloudsum );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVfzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 141, 141, 184], [186, 186, 207, 207, 239], [241, 241, 281, 281, 791], [793, 836, 870, 870, 1375], [1377, 1377, 1436, 1436, 1506], [1708, 1708, 1765, 1765, 2835]], "test": "ok"}
{"id": "XlyBWc", "name": "Are you ready for Smash?", "author": "Polytope", "description": "Just fun and smash!!", "tags": ["2d", "noise", "nintendo", "smash"], "likes": 5, "viewed": 191, "published": "Public", "date": "1544189590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 translate(vec2 p, vec2 o)\n{\n    return p - o;\n}\n\nfloat SDbox(vec2 uv, vec2 r)\n{\n    return length(max(abs(uv)-r,vec2(.07)));\n}\n\nfloat SDcircle(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\n\nfloat SDunion(float a, float b)\n{\n    return min(a,b);\n}\n\nfloat R2D(vec2 uv)\n{\n    return fract(sin(dot(uv,vec2(120.,670.)))*4563.);\n}\n\nfloat noise(vec2 uv, float zoom)\n{\n    vec2 i_uv = floor(uv*zoom);\n    vec2 f_uv = fract(uv*zoom);\n    \n    float a = R2D(i_uv);\n    float b = R2D(i_uv+vec2(1.0,0.0));\n    float c = R2D(i_uv+vec2(0.0,1.0));\n    float d = R2D(i_uv+vec2(1.0,1.0));\n    \n    vec2 u = smoothstep(.0,1.,f_uv);\n    \n    float ab = mix(a,b,f_uv.x);\n    float cd = mix(c,d,f_uv.x);\n    \n    return mix(ab,cd,f_uv.y);\n    \n}\n\nfloat noise2(vec2 st)\n{\n    float n = noise(st,8.)*.5;\n    n += noise(st,16.)*.25;\n    n += noise(st,32.)*.125;\n    n += noise(st,64.)*.0625;\n    \n    return n;\n}\n\nvec3 c1 = vec3(.85,.12,.0);\nvec3 c2 = vec3(.98,.54,.01);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 st = vec2(uv);\n    st.y -= iTime*.05;\n    \n    float n = noise2(st);\n    float v = abs(sin(iTime*.5))*n;\n\n    vec2 p1 = translate(uv,vec2(.0,-.3));\n    float b1 = SDbox(p1,vec2(6.,.001));\n    b1 = smoothstep(.1,.16,b1);\n    b1 += smoothstep(.1,.2,b1*n);\n    \n    vec2 p2 = translate(uv,vec2(-.5,.0));\n    float b2 = SDbox(p2,vec2(.05,6.));\n    b2 = smoothstep(.1,.16,b2);\n    b2 += smoothstep(.1,.9,b2*n);\n    \n    float b = SDunion(b1,b2);\n    \n    float c = SDcircle(uv,.6);\n    c = smoothstep(.1,.5,c);\n    c += smoothstep(.1,.2,c*n);\n    \n    float t = b-c;\n    \n    vec3 col = vec3(0.);\n    col = (mix(c1,c2,(abs(sin(iTime*.5))+.5)*(n*2.))+n)*t;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyBWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 52], [54, 54, 84, 84, 131], [133, 133, 167, 167, 194], [196, 196, 229, 229, 252], [254, 254, 274, 274, 330], [332, 332, 366, 366, 730], [732, 732, 755, 755, 894], [954, 954, 1011, 1011, 1821]], "test": "ok"}
{"id": "XlyfD3", "name": "yuebing", "author": "greenkuruma", "description": "yuebing(mooncake) zoom in / out", "tags": ["study"], "likes": 2, "viewed": 62, "published": "Public", "date": "1544180668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float Time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = ( fragCoord.xy / iResolution.xy ) / 2.0;\n\n\tfloat duration = sin(iTime/2.)*20.;\n\n\tvec3 color;\n\tcolor.g += sin(position.x*position.y*10000. * duration);\n\t\n\tcolor.r += sin(position.x*position.y*10011. * duration*0.5);\n\t\n\tcolor.b += sin(position.x*position.y*10022. * duration*0.25);\n        \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 123, 123, 488]], "test": "error"}
{"id": "XlyfDG", "name": "[TDF18]Kanye West & Lil Pump", "author": "yasuo", "description": "\"I love it\" Make america great again!", "tags": ["raytracing", "tdf", "kanye"], "likes": 3, "viewed": 175, "published": "Public", "date": "1543757748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 0.5\n#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n#define fmod(x,y)  x-y*floor(x/y)\n\n\nstruct Params {\n\tmat3 krot;\n\tmat3 lrot;\n\tmat3 staturot;\n\tfloat headSc;\n\tvec3 bodySc;\n\tfloat armSc;\n\tfloat legSc;\n\tfloat shoesSc;\n\tfloat floorSc;\n\tfloat statueSc;\n\n\tvec3 head;\n\tfloat bodyZ;\n\tfloat wallX;\n\tvec3 arm;\n\tvec3 leg;\n\tfloat shoesX;\n\tfloat shoesZ;\n};\n\nfloat random(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat randomRange (in vec2 seed, in float min, in float max) {\n\treturn min + random(seed) * (max - min);\n}\t\n\t\nfloat noise(vec2 p){\n\tconst int res = 16;\n\t\n\tp *= float(res);\n\tvec2 n = floor(p);\n\tvec2 f = fract(p);\n\t\n\tf = f * f * (3.0 - 2.0 * f);\n\t\n\tfloat n0 = random(n);\n\tfloat n1 = random(n + vec2(1.0, 0.0));\n\tfloat n2 = random(n + vec2(0.0, 1.0));\n\tfloat n3 = random(n + vec2(1.0, 1.0));\n\t\n\tfloat m0 = mix(n0, n1, f.x);\n\tfloat m1 = mix(n2, n3, f.x);\n\t\n\treturn mix(m0, m1, f.y);\n}\n\nmat3 matRotateY(float rad)\n{\n    return mat3(cos(rad), 0, -sin(rad),\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\tsin(rad), 0, cos(rad));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n    float a = sin(t*.2 + 1.5), b = sin(t*.2);\n    return vec2(a*2., a*b);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat statue( vec3 p, vec2 h )\n{\n\tconst float a = 0.566025;\n\tp.y = abs(p.y);\n    vec3 q = abs( p );\n    float dx = max( q.x - h.y, max( q.z * a + p.y * 0.5, -p.y ) - h.x * 0.5 );\n    float dz = max( q.z - h.y, max( q.x * a + p.y * 0.5, -p.y ) - h.x * 0.5 );\n    return max( dx, dz );\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nfloat cubicInOut(float t) {\n\tfloat p = 2.0 * t * t;\n\treturn t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec3 bodyTex(vec3 cl,vec3 lcl,vec2 uv) {\n\tvec2 wave = vec2(uv.x,sin(uv.x*6.0*PI)/10.0-0.5 );\n\tfloat diff = distance(uv,wave)*noise(uv);\n\treturn max(cl,smoothstep(0.1,0.01,diff))*lcl;\n}\n\nvec4 lilpumpDist(vec3 p, Params param){\n\tvec3 op=p;\n    float d=100.0;\n    \n    p.x = abs(p.x);\n    p -= vec3(0.35, 0.0, 0.0);\n    p.y-=0.4;\n    \n    d=100.0;\n    d = min(d,sdBox(p-vec3(0.0+param.leg.x,-0.65,0.9+param.leg.z),vec3(0.3+param.legSc,0.5,0.2)));\n\tvec4 leg = vec4(0.4,0.3,0.3,d);\n    p=op;\n    \n    op=p;\n    p.x = abs(p.x);\n    p -= vec3(0.15, -1.15, 1.5);\n    \n    d=100.0;\n\t\n\tfloat shoes =sdBox(p+vec3(-0.2+param.shoesX,-0.4,0.6+param.shoesZ),vec3(0.32+param.shoesSc,0.08,0.3));\n\td=min(d,shoes);\n    vec4 shoesdist = vec4(0.75,0.75,0.75,d);\n    p=op;\n    \n    op=p;\n\tp.y-=1.1;\n    \n    d=100.0;\n    d=min(d,sdBox(p-vec3(0.0,-0.55+sin(iTime*5.1)*0.03,0.9+param.bodyZ),vec3(0.7+param.bodySc.x,0.6+param.bodySc.y,0.3+param.bodySc.z)));\n\t\n\tvec4 body = vec4(bodyTex(vec3(0.6,0.3,0.3),vec3(0.9,0.9,0.9),p.xy), d);\n    p=op;\n    \n\top=p;\n    p.x = abs(p.x);\n    p -= vec3(0.86, 0.0, 0.0);\n    p.y-=1.05;\n    \n    d=100.0;\n    d=min(d, sdBox(p-vec3(0.0+param.arm.x,(-0.55+param.arm.y)+sin(iTime*5.0)*0.05,0.9+param.arm.z),vec3(0.15,0.65,0.3)));\n\tvec4 arm = vec4(0.55,0.3,0.3,d-0.0001);\n    p=op;\n    \n\top=p;\n\tp.y-=1.65;\n    \n    d=100.0;\n    d=min(d,sdBox((p-vec3(0.0,(-0.39+param.head.y)+sin(iTime*5.0)*0.05,0.9+param.head.z)),vec3(0.15+param.headSc,0.15+param.headSc,0.15+param.headSc)));\n\tvec4 head = vec4(0.95,0.75,0.6,d-0.0001);\n    \n    vec4 res1 = combine(leg,shoesdist);\n    vec4 res2 = combine(body,arm);\n    vec4 res3 = combine(head,res1);\n    vec4 res4 = combine(res2,res3);\n\n    return res4;\n}\n\nvec4 kanyeDist(vec3 p, Params param){\n\tvec3 op=p;\n    float d=100.0;\n    \n    p.x = abs(p.x);\n    p -= vec3(0.37, 0.0, 0.0);\n    p.y-=0.4;\n    \n    d=100.0;\n    d = min(d,sdBox(p-vec3(0.0+param.leg.x,-0.65,0.9+param.leg.z),vec3(0.3+param.legSc,0.5,0.2)));\n\tvec4 leg = vec4(0.3,0.3,0.3,d);\n    p=op;\n    \n    op=p;\n    p.x = abs(p.x);\n    p -= vec3(0.15, -1.15, 1.9);\n    \n    d=100.0;\n\tfloat shoes =sdBox(p+vec3(-0.2+param.shoesX,-0.4,0.8+param.shoesZ),vec3(0.32+param.shoesSc,0.08,0.2));\n\td=min(d,shoes);\n    vec4 shoesdist = vec4(0.7,0.7,0.7,d);\n    p=op;\n    \n    op=p;\n\tp.y-=1.1;\n    \n    d=100.0;\n    d=min(d,sdBox(p-vec3(0.0,-0.55+sin(iTime*5.1)*0.03,0.9),vec3(0.7+param.bodySc.x,0.6+param.bodySc.y,0.3+param.bodySc.z)));\n\tvec4 body = vec4(bodyTex(vec3(0.2,0.07,0.05),vec3(0.5,0.37,0.0),p.xy), d);\n    p=op;\n    \n\top=p;\n    p.x = abs(p.x);\n    p -= vec3(0.86, 0.0, 0.0);\n    p.y-=1.05;\n    \n    d=100.0;\n    d=min(d, sdBox((p-vec3(0.0+param.arm.x,(-0.55+param.arm.y)+sin(iTime*5.0)*0.05,0.9+param.arm.z)),vec3(0.15,0.65,0.3)));\n\tvec4 arm = vec4(0.12,0.05,0.05,d-0.0001);\n    p=op;\n    \n\top=p;\n\tp.y-=1.65;\n    \n    d=100.0;\n    d=min(d,sdBox(p-vec3(0.0,(-0.39+param.head.y)+sin(iTime*5.0)*0.05,0.9+param.head.z),vec3(0.15+param.headSc,0.15+param.headSc,0.15+param.headSc)));\n\tvec4 head = vec4(0.45,0.15,0.1,d-0.0001);\n\n    vec4 res1 = combine(leg,shoesdist);\n    vec4 res2 = combine(body,arm);\n    vec4 res3 = combine(head,res1);\n    vec4 res4 = combine(res2,res3);\n\n    return res4;\n}\n\nvec3 noiseTex(vec3 p){\n\tvec3 color = vec3(0.0);\n\tcolor += noise(p.xz) * 0.125;\n\tcolor += noise(p.xz * 2.0) * 0.125;\n\tcolor += noise(p.xz * 4.0) * 0.125;\n\tcolor += noise(p.xz * 8.0) * 0.125;\n\tcolor += noise(p.xz * 16.0) * 0.125;\n\tcolor += noise(p.xz * 32.0) * 0.125;\n\treturn color;\n}\n\nvec4 map(vec3 p,Params param){    \n    float t = 100.0;\n    \n\tvec3 oldp = p;\n\tp.z = mod(p.z+(iTime*SPEED), 0.5)-0.25;\n\n    vec3 floorp = (p-vec3(0.0,0.5,0.0));\n    float w = sdBox(floorp,vec3(3.6+param.floorSc, 0.01, 0.3));\n\n\tvec3 floorColor = noiseTex(floorp)*vec3(1.23);\n\n    vec4 floorDist = vec4(floorColor, w);\n    \n    p = oldp;\n    p.z = mod(p.z+(iTime*SPEED), 0.7)-0.35;\n\tp.x = abs(p.x);\n    p -= vec3(6.0+param.wallX, 2.0, 0.0);\n    \n    \n\tfloat box = sdBox(p,vec3(0.3,3.5,0.5));\n    float box2 = sdBox(p,vec3(0.5,1.5,0.2));\n    float wall = opS(box2,box);\n    \n    t = min(t, wall);\n\n\tvec3 wallColor = noiseTex(p.zxy)*vec3(2.63,2.6,2.65);\n    vec4 wallDist = vec4(wallColor, t);\n    \t\n    t = 100.0;\n    float sta = statue((p+vec3(0.2, 0.0, 0.0))*param.staturot,vec2(0.4+param.statueSc,0.1));\n    t = min(t, sta);\n    vec4 statueDist = vec4(0.85,0.82,0.85, t);\n    \n    t = 100.0;\n    t = min(t, sdBox(p+vec3(0.3, 0.0, 0.35),vec3(0.02,3.5,0.02)));\n    vec4 wallLine = vec4(0.9,0.9,0.9, t);\n\t\n\tvec4 lilpump = lilpumpDist((oldp+vec3(-1.5, -1.35, -7.0))*param.lrot,param);\n\tvec4 kanye = kanyeDist((oldp+vec3(1.5, -1.35, -6.0))*param.krot,param);\n\n\tvec4 res1 = combine(floorDist,wallDist);\n    vec4 res2 = combine(statueDist,wallLine);\n\tvec4 res3 = combine(lilpump,kanye);\n\tvec4 res4 = combine(res1,res2);\n\tvec4 res5 = combine(res3,res4);\n\n\treturn res5;\n}\n\nvec3 normalMap(vec3 p,Params param){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0),param).w - map(p + vec3( -d, 0.0, 0.0),param).w,\n\t\tmap(p + vec3(0.0,   d, 0.0),param).w - map(p + vec3(0.0,  -d, 0.0),param).w,\n\t\tmap(p + vec3(0.0, 0.0,   d),param).w - map(p + vec3(0.0, 0.0,  -d),param).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd, Params param){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c,param).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid rainbow(vec2 p, float size, vec3 color, inout vec3 dst){\n    float l = smoothstep(0.0,1.1,length(p - vec2( 0.0,  0.0)));\n    if(l < size)dst = color;\n}\n\nfloat slopeSaw(vec2 position){\n\tfloat y = position.x;\n\tfloat animVal = sin(iTime);\n\tfloat animVal2 = sin(iTime*0.1);\n\tfloat animVal3 = sin(iTime*0.2);\n\tfloat animVal4 = sin(iTime*0.3);\n\tfloat animVal5 = sin(iTime*0.4);\n\tfloat animVal6 = sin(iTime*0.5);\n\tfloat animVal7 = sin(iTime*0.6);\n\tfloat animVal8 = sin(iTime*0.7);\n\tfloat animVal9 = sin(iTime*0.8);\n\tfloat slope = smoothstep( y-0.8+animVal, y-0.8+animVal, position.y);\n\tslope += smoothstep( y-0.6+animVal2, y-0.6+animVal2, position.y);\n\tslope += smoothstep( y-0.4+animVal4, y-0.4+animVal4, position.y);\n\tslope += smoothstep( y-0.2+animVal, y-0.2+animVal, position.y);\n\tslope += smoothstep( y+animVal5, y+animVal5, position.y);\n\tslope += smoothstep( y+0.2+animVal6, y+0.2+animVal6, position.y);\n\tslope += smoothstep( y+0.4+animVal7, y+0.4+animVal7, position.y);\n\tslope += smoothstep( y+0.6+animVal8, y+0.6+animVal8, position.y);\n\tslope += smoothstep( y+0.8+animVal9, y+0.8+animVal9, position.y);\n\treturn slope;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n\tfloat uvy = mod(iTime*0.5,2.5)-1.0;\n\tif (p.y+uvy > 0.2 && p.y+uvy < 0.7) {\n\t\tp.x += sin(p.y*5.0)*0.1;\n\t}\n\n\t// glitch effects\n\tfloat sceneLength = 10.0;\n\tfloat scene = fmod(iTime,sceneLength);\n\tif(scene>7.0 && scene<8.0){\n\t\tfloat threshold = 0.3;\n\n\t\tfloat etime = sin(iTime)*70.0; \n\t\tfloat f = fract(etime * 0.01* 10.0);\n\t\tetime += cubicInOut(2.0 - exp(-f*0.2));\n\t\tetime *= 0.2;\n\t\tfloat maxOffset = threshold/2.0;\n\t\t\n\t\tfor(float i = 0.0; i < 10.0 * 0.3; i += 2.0){\n\t\t\tfloat sliceY = random(vec2(etime , float(i)));\n\t\t\tfloat sliceH = random(vec2(etime , float(i))) * 0.55;\n\t\t\tfloat hOffset = randomRange(vec2(etime , float(i)), -maxOffset, maxOffset);\n\t\t\tvec2 uvOff = p;\n\t\t\tuvOff.x += hOffset*etime*0.05;\n\t\t\tif ((step(-sliceY, p.y) - step(fract(-sliceY+sliceH), p.y)) == 1.0 ){\n\t\t\t\tp = uvOff;\n\t\t\t}\n\t\t}\n\t\tp.x += sin(p.y*etime)*0.2*cos(p.y*etime)*0.1;\n\t}\t\n\t\n\tvec3 camPos = vec3(0.0, 2.0, 10.0);\n\tvec3 Fwd = vec3(0.0, 0.0, -1.0);\n\tvec3 Up  = vec3(0.0,  1., 0.0);\n\t\n\tvec3 left = cross(Fwd, Up);\n\tfloat depth = 0.7;\n\tvec3 ray = normalize(left * p.x + Up * p.y + Fwd * depth);\n\n\tfloat amplitude = 3.;\n\tfloat frequency = 2.;\n\tfloat noiseVal = 0.0;\n\tnoiseVal = sin(frequency);\n\tfloat nt = 0.01*(-iTime*130.0);\n\tnoiseVal += sin(p.x*frequency*2.1 + nt)*4.5;\n\tnoiseVal += sin(p.x*frequency*1.72 + nt*1.121)*4.0;\n\tnoiseVal += sin(p.x*frequency*2.221 + nt*0.437)*5.0;\n\tnoiseVal += sin(p.x*frequency*3.1122+ nt*4.269)*2.5;\n\tnoiseVal *= amplitude*0.06;\n\n\tp.xy -= path(noiseVal)*0.1;\n\n\t// animation\n\tmat3 camRotY = matRotateY(((sin(iTime*2.0)*noiseVal))*degToRad)*matRotateY(((sin(iTime*2.0)*3.0))*degToRad);\n\tmat3 rotY = matRotateY((22.0-(sin(iTime*2.0)*10.0))*degToRad);\n\tmat3 rotY2 = matRotateY((-20.0+(sin(iTime*2.2)*10.0))*degToRad);\n\t\n\tParams param;\n\tfloat animTime = fmod(iTime,16.0);\n\tfloat hsc = 0.0;\n\thsc += cubicInOut(animscene(animTime, 1.0, 0.6))*0.2;\n\thsc -= cubicInOut(animscene(animTime, 5.8, 0.6))*0.2;\n\n\thsc += cubicInOut(animscene(animTime, 9.2, 0.6))*0.2;\n\thsc -= cubicInOut(animscene(animTime, 12.9, 0.6))*0.2;\n\n\tfloat headY = 0.0;\n\theadY -= cubicInOut(animscene(animTime, 9.2, 0.6))*0.35;\n\theadY += cubicInOut(animscene(animTime, 12.9, 0.6))*0.35;\n\t\n\tfloat headZ = 0.0;\n\theadZ += cubicInOut(animscene(animTime, 9.2, 0.6))*0.5;\n\theadZ -= cubicInOut(animscene(animTime, 12.9, 0.6))*0.5;\n\n\tfloat bsc = 0.0;\n\tbsc -= cubicInOut(animscene(animTime, 1.4, 0.6))*0.35;\n\tbsc += cubicInOut(animscene(animTime, 5.4, 0.6))*0.35;\n\n\tbsc -= cubicInOut(animscene(animTime, 9.0, 0.6))*0.3;\n\tbsc += cubicInOut(animscene(animTime, 13.0, 0.6))*0.3;\n\t\n\tfloat bscY = 0.0;\n\tbscY -= cubicInOut(animscene(animTime, 9.1, 0.6))*0.2;\n\tbscY += cubicInOut(animscene(animTime, 13.1, 0.6))*0.2;\n\n\tfloat bscZ = 0.0;\n\tbscZ += cubicInOut(animscene(animTime, 9.2, 0.6))*0.35;\n\tbscZ -= cubicInOut(animscene(animTime, 13.2, 0.6))*0.35;\n\n\tfloat lsc = 0.0;\n\tlsc -= cubicInOut(animscene(animTime, 1.2, 0.6))*0.15;\n\tlsc += cubicInOut(animscene(animTime, 5.6, 0.6))*0.15;\n\n\tlsc -= cubicInOut(animscene(animTime, 8.9, 0.6))*0.15;\n\tlsc += cubicInOut(animscene(animTime, 12.9, 0.6))*0.15;\n\n\tfloat lx = 0.0;\n\tlx -= cubicInOut(animscene(animTime, 1.2, 0.6))*0.16;\n\tlx += cubicInOut(animscene(animTime, 5.6, 0.6))*0.16;\n\n\tlx -= cubicInOut(animscene(animTime, 8.9, 0.6))*0.16;\n\tlx += cubicInOut(animscene(animTime, 12.9, 0.6))*0.16;\n\n\tfloat lz = 0.0;\n\tlz -= cubicInOut(animscene(animTime, 8.9, 0.6))*0.4;\n\tlz += cubicInOut(animscene(animTime, 12.9, 0.6))*0.4;\n\n\tfloat shoessc = 0.0;\n\tshoessc -= cubicInOut(animscene(animTime, 1.3, 0.6))*0.16;\n\tshoessc += cubicInOut(animscene(animTime, 5.6, 0.6))*0.16;\n\t\n\tshoessc -= cubicInOut(animscene(animTime, 8.9, 0.6))*0.16;\n\tshoessc += cubicInOut(animscene(animTime, 12.9, 0.6))*0.16;\n\n\tfloat shoesx = 0.0;\n\tshoesx += cubicInOut(animscene(animTime, 1.3, 0.6))*0.16;\n\tshoesx -= cubicInOut(animscene(animTime, 5.6, 0.6))*0.16;\n\n\tshoesx += cubicInOut(animscene(animTime, 8.9, 0.6))*0.16;\n\tshoesx -= cubicInOut(animscene(animTime, 12.9, 0.6))*0.16;\n\n\tfloat shoesz = 0.0;\n\tshoesz += cubicInOut(animscene(animTime, 8.9, 0.6))*0.4;\n\tshoesz -= cubicInOut(animscene(animTime, 12.9, 0.6))*0.43;\n\n\tfloat armx = 0.0;\n\tarmx -= cubicInOut(animscene(animTime, 1.7, 0.6))*0.35;\n\tarmx += cubicInOut(animscene(animTime, 5.2, 0.6))*0.35;\n\n\tarmx -= cubicInOut(animscene(animTime, 8.8, 0.6))*0.6;\n\tarmx += cubicInOut(animscene(animTime, 12.8, 0.6))*0.6;\n\n\tfloat army = 0.0;\n\tarmy -= cubicInOut(animscene(animTime, 8.8, 0.6))*0.7;\n\tarmy += cubicInOut(animscene(animTime, 12.8, 0.6))*0.7;\n\n\tfloat armz = 0.0;\n\tarmz += cubicInOut(animscene(animTime, 8.8, 0.6))*0.3;\n\tarmz -= cubicInOut(animscene(animTime, 12.8, 0.6))*0.3;\n\n\tfloat fsc = 0.0;\n\tfsc -= cubicInOut(animscene(animTime, 2.0, 0.6))*0.6;\n\tfsc += cubicInOut(animscene(animTime, 6.2, 0.6))*0.6;\n\n\tfsc -= cubicInOut(animscene(animTime, 9.0, 0.6))*0.6;\n\tfsc += cubicInOut(animscene(animTime, 13.2, 0.6))*0.6;\n\n\tfloat wx = 0.0;\n\twx -= cubicInOut(animscene(animTime, 2.3, 0.6))*0.6;\n\twx += cubicInOut(animscene(animTime, 6.0, 0.6))*0.6;\n\n\twx -= cubicInOut(animscene(animTime, 9.3, 0.6))*0.6;\n\twx += cubicInOut(animscene(animTime, 13.0, 0.6))*0.6;\n\n\tfloat bgsc = 0.0;\n\tbgsc += cubicInOut(animscene(animTime, 1.9, 0.6))*0.3;\n\tbgsc -= cubicInOut(animscene(animTime, 5.8, 0.6))*0.3;\n\n\tbgsc += cubicInOut(animscene(animTime, 8.9, 0.6))*0.3;\n\tbgsc -= cubicInOut(animscene(animTime, 12.8, 0.6))*0.3;\n\n\tfloat staturot = 0.0;\n\tstaturot += cubicInOut(animscene(animTime, 2.3, 1.0))*180.0;\n\tstaturot += cubicInOut(animscene(animTime, 6.0, 1.0))*180.0;\n\t\n\tstaturot += cubicInOut(animscene(animTime, 9.3, 1.0))*180.0;\n\tstaturot += cubicInOut(animscene(animTime, 13.0, 1.0))*180.0;\n\n\tfloat statueSc = 0.4;\n\tstatueSc -= cubicInOut(animscene(animTime, 2.3, 1.0))*0.4;\n\tstatueSc += cubicInOut(animscene(animTime, 6.0, 1.0))*0.4;\n\n\tstatueSc -= cubicInOut(animscene(animTime, 9.3, 1.0))*0.4;\n\tstatueSc += cubicInOut(animscene(animTime, 13.0, 1.0))*0.4;\n\n\tparam.krot = rotY;\n\tparam.lrot = rotY2;\n\tparam.staturot = matRotateY(staturot*degToRad);\n\tparam.headSc = hsc;\n\tparam.head = vec3(0,headY,headZ);\n\tparam.bodySc = vec3(bsc,bscY,bscZ);\n\tparam.legSc = lsc;\n\tparam.leg = vec3(lx,0,lz);\n\tparam.shoesSc = shoessc;\n\tparam.shoesX = shoesx;\n\tparam.shoesZ = shoesz;\n\tparam.arm = vec3(armx,army,armz);\n\tparam.floorSc = fsc;\n\tparam.wallX = wx;\n\tparam.statueSc = statueSc;\n\n\tfloat t, dist;\n\tt = 0.0;\n\tvec3 distPos = camPos;\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 60; i++){\n\t\tdistCl = map(distPos,param);\n\t\tdist = distCl.w;\n\t\tif(dist < 0.001){break;}\n\t\tt += dist;\n\t\tdistPos = (camPos + t * ray)*camRotY;\n\t}\n\n\tvec2 rainbowp = p;\n\tvec3 color;\n\tfloat shadow = 1.0;\n\tif(dist < 0.001){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(0.0, 1.0, 0.0);\n\t\tvec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n\t\tvec3 normal = normalMap(distPos,param);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 0.1, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light,param);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n\t\t// rainbow bg\n\t\tif(scene>7.0 && scene<8.0){\n\t\t\trainbowp.y+=slopeSaw((fragCoord.xy) / min(iResolution.x, iResolution.y))-5.0;\n\t\t}\n\t\t\n\t\trainbowp.x*=(0.55+bgsc);\n\t\t\n\t\trainbowp.y += sin(rainbowp.x*30.0+iTime*2.0)*0.3*cos(rainbowp.x*10.0+iTime*2.0)*0.2;\n\t\trainbowp.y += 0.05+(bgsc*0.2);\n\t\t\n\n\t\tvec3 rainbowbg = vec3(0.8)+(.1-length(p.xy)/3.);\n\t\tvec3 rcolor = rainbowbg;\n\t\trainbow (rainbowp, 0.95, vec3(1.0,0.0,0.0), rcolor);\n\t\trainbow (rainbowp, 0.9, vec3(1.0,0.6,0.0), rcolor);\n\t\trainbow (rainbowp, 0.85, vec3(1.0,1.0,0.0), rcolor);\n\t\trainbow (rainbowp, 0.8, vec3(0.0,1.0,0.0), rcolor);\n\t\trainbow (rainbowp, 0.75, vec3(0.3,0.3,0.8), rcolor);\n\t\trainbow (rainbowp, 0.7, vec3(0.7,0.7,1.0), rcolor);\n\t\trainbow (rainbowp, 0.65, vec3(0.8,0.0,1.0), rcolor);\n\t\trainbow (rainbowp, 0.6, rainbowbg, rcolor);\n\n\t\tcolor = rcolor*(rainbowbg*noiseTex(vec3(rainbowp.xy,rainbowp.y))*vec3(2.0));\n\t}\n\n\t// rendering result\n\tfloat brightness = 3.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n\t// cross hatch\n\tvec3 hacthcolor = vec3(dst.x*0.9,0.2,0.2);\n\tfloat hatchsize = 5.0;\n\tif (color.g < 0.3) {\n        if (mod(fragCoord.x + fragCoord.y, hatchsize) == 0.0) {\n            fragColor = vec4(hacthcolor, 1.0);\n        }\n    }\n     \n    if (color.g < 0.1) {\n        if (mod(fragCoord.x - fragCoord.y, hatchsize) == 0.0) {\n            fragColor = vec4(hacthcolor, 1.0);\n        }\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 374, 396, 396, 466], [468, 468, 530, 530, 574], [578, 578, 598, 598, 948], [950, 950, 978, 978, 1063], [1065, 1065, 1098, 1098, 1124], [1126, 1216, 1236, 1236, 1312], [1314, 1314, 1345, 1345, 1432], [1434, 1434, 1466, 1466, 1719], [1721, 1721, 1757, 1757, 1816], [1818, 1818, 1845, 1845, 1915], [1917, 2029, 2076, 2076, 2117], [2119, 2119, 2159, 2159, 2303], [2305, 2305, 2344, 2344, 3815], [3817, 3817, 3854, 3854, 5307], [5309, 5309, 5331, 5331, 5591], [5593, 5593, 5623, 5623, 6954], [6956, 6956, 6992, 6992, 7278], [7280, 7280, 7328, 7328, 7584], [7586, 7586, 7647, 7647, 7742], [7744, 7744, 7774, 7774, 8711], [8713, 8713, 8769, 8769, 17308]], "test": "timeout"}
{"id": "XlyfWd", "name": "Shannon-Nyquist limit on energy", "author": "FabriceNeyret2", "description": "windowed contrast computed on [url] https://www.shadertoy.com/view/MtKfD3 [/url]\n( see there for explanations )", "tags": ["nyquist", "signal", "shannon"], "likes": 3, "viewed": 343, "published": "Public API", "date": "1544455541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// windowed contrast of  https://shadertoy.com/view/MtKfD3\n\n#define N          2.            // window size (pixels)\n#define filter(x)  gauss(x)      // filter type\n\n#define sinc(x)  ( x==0. ? 1. : sin(PI*x)/(PI*x) )\n#define gauss(x)   exp(-.5*(x)*(x)*4.)\n#define PI         3.14159265359\n\nfloat f(float x, float y) {\n    y = (x+iTime)*  (1.+y);\n    y =  sin( 3.1419/2.*y );\n  //return .5+.5*y;    // signal\n    return y*y;        // energy, i.e. variance, i.e. contrast^2\n}\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float x = U.x < iResolution.x/2. ? U.x : U.x - .5,\n          y = ceil(U.y/iResolution.y*20.)/20., s = 0.;\n    O -= O;\n    for (float i = -100.; i <= 100.; i++)\n        s += filter(i/N),\n        O += f(x-i,y) * filter(i/N);\n    O /= s;\n    O = sqrt(O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyfWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 290, 317, 317, 474], [475, 475, 513, 513, 771]], "test": "ok"}
{"id": "XtGBDG", "name": "Construction", "author": "shutosg", "description": "TDF2018", "tags": ["tdf2018"], "likes": 2, "viewed": 159, "published": "Public", "date": "1543743725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//// ray\n#define RAY_FOVY\n\n//// \n// #define SCALE_ANIMATION\n#define GO_ANIMATION\n#define DIR_ANIMATION\n\n//// rotate\n#define USE_ROTATE\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//// \n#define resolution iResolution\n#define duration 30.\n#define gTime iTime * .75\n#define PI 3.14159265\n#define INFINITY 1. / 0.\n#define RAY_HIT_THRESHOLD 0.001\n#define MAX_MARCHING_ITTRATION 128\n#define EDGE_THRESHOLD 0.0005\n#define FAR_CLIP 1E30\n#define FRACTAL_STEP 5\n\n//// enum\n#define OR  0\n#define AND 1\n#define SUB 2\n// material\n#define M_BASE 0.\n#define M_CROSS 1.\n#define M_EDGE 2.\n#define M_SPHEREE 3.\n#define M_TORUS 4.\n// color\n#define C_YELLOW vec3(.9, 1., .4)\n#define C_BLACK vec3(.0)\n#define C_WHITE vec3(1.)\n#define C_GRAY vec3(.05)\n#define C_PINK vec3(.8, .05, .35)\n#define C_RED vec3(.99, .0, .0)\n\n#define C_BASE C_BLACK\n#define C_CROSS C_RED\n#define C_EDGE C_RED\n#define C_TORUS C_BLACK\n#define C_AO C_WHITE\n\n/// Easing\nfloat easeOutExpo(float t, float from, float to, float dur)\n{\n    return from + (to - from) * (1. - pow(2., -10. * t / dur));\n}\n\n/// math\nfloat sin2(float x, float min, float max)\n{\n    float len = max - min;\n    return min + (len * sin(x) + len) * .5;\n}\n\nfloat max2(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\n/// Noise Functions ==============================\nvec2 dotedRandom(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n                    dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat perlinNoise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    vec2 v00 = dotedRandom(p+vec2(0,0));\n    vec2 v10 = dotedRandom(p+vec2(1,0));\n    vec2 v01 = dotedRandom(p+vec2(0,1));\n    vec2 v11 = dotedRandom(p+vec2(1,1));\n\n    return mix( mix( dot( v00, f - vec2(0,0) ), dot( v10, f - vec2(1,0) ), u.x ),\n                    mix( dot( v01, f - vec2(0,1) ), dot( v11, f - vec2(1,1) ), u.x ), \n                    u.y) + 0.5;\n}\n\nfloat fBm (vec2 st) \n{\n    float f = 0.;\n    vec2 q = st;\n\n    f += 0.5000 * perlinNoise( q );\n    q *= 2.01;\n    f += 0.2500 * perlinNoise( q );\n    q *= 2.02;\n    f += 0.1250 * perlinNoise( q );\n    q *= 2.03;\n    f += 0.0625 * perlinNoise( q );\n    q *= 2.01;\n\n    return f;\n}\n\nfloat animNoise(float speed, float offset, float scale)\n{\n    return scale * (fBm(vec2(cos(gTime * speed + offset / PI), sin(gTime * speed + offset / PI))) - .5);\n}\n\nvec3 getRayDirection(vec3 cDir, vec3 cUp, vec2 fPosition)\n{\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n#ifdef RAY_FOVY\n    float angle = 135. + 45. * easeOutExpo(gTime, 1., 0., 2.); \n    vec2 aspect = resolution.xy / min(resolution.x, resolution.y);\n    float fov = angle * 0.5 * PI / 180.;\n    float aspectm = max2(aspect);\n    return normalize(\n        cDir + \n        cSide * targetDepth * tan(fov * aspect.x / aspectm) * fPosition.x / aspect.x +\n        cUp * targetDepth * tan(fov * aspect.y / aspectm) * fPosition.y / aspect.y);\n#else\n    return normalize(cSide * fPosition.x + cUp * fPosition.y + cDir * targetDepth);\n#endif\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec2 rotate2d(vec2 xy, float thete)\n{\n    return mat2(cos(thete), -sin(thete), sin(thete), cos(thete)) * xy;\n}\n\n/// Filter effect ==============================\n\n// horizontal displacement map\nfloat displacementAmount(float gTimeOffset)\n{\n    // \n    float gTimeInterval = 2.;\n    // sincx(0. ~ xRange)\n    float xRange = 20.;\n    float x = mod((iTime + gTimeOffset) * xRange / gTimeInterval, xRange);\n    return sin(x) / pow(x, 3.);\n}\nvec2 flHorizontalDisplacement(vec2 fPosition, float timeOffset)\n{\n    float noiseValue = (perlinNoise(floor(vec2(fPosition.y * 100., iTime + timeOffset)) / 1.01) - .5) * displacementAmount(0.) * 2.;\n    fPosition.x = fPosition.x + noiseValue * 3.0;\n    return fPosition;\n}\n\n/// Operations for Ray Marching ==============================\n// Union\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\nvec2 opU(vec2 d1, vec2 d2)\n{\n    if(d1.x < d2.x) return d1;\n    return d2;\n}\n\n// Substraction\nfloat opS(float d1, float d2)\n{\n    return max(d1, -d2);\n}\nvec2 opS(vec2 d1, vec2 d2)\n{\n    if(d1.x > -d2.x + EDGE_THRESHOLD) return d1;\n    if(d1.x < -d2.x - EDGE_THRESHOLD) return vec2(-d2.x, d2.y);\n    return vec2(d1.x, M_EDGE);\n}\nvec2 opS(vec2 d1, vec2 d2, vec3 p)\n{\n    if(d1.x > -d2.x + EDGE_THRESHOLD) return d1;\n    if(d1.x < -d2.x - EDGE_THRESHOLD) return vec2(-d2.x, d2.y);\n    // edge\n    float radius = mod(iTime / 2., 2.);\n    float margin = .1 * perlinNoise(p.xy * 10.);\n    float l = length(p);\n    if(l < radius + margin && l > radius - margin) return vec2(d1.x, M_EDGE);\n    return d1;\n}\n\n// Intersection\nfloat opI(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\n// Repetition\nvec3 opRep(vec3 p, vec3 interval)\n{\n    return mod(p, interval * 2.) - interval;\n}\nvec3 opRep(vec3 p, float interval) { return opRep(p, vec3(interval)); }\n\n/// Distance Functions ==============================\n// 2d Rectangle\nfloat dfRect(vec2 p, vec2 size)\n{\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// 3d Box\nvec2 dfBox(vec3 p, vec3 size)\n{\n    vec3 d = abs(p) - size;\n    return vec2(min(max(d.x, max(d.y, d.z)), .0) + length(max(d, .0)), M_BASE);\n}\n\nvec2 dfInfCross(vec3 p, float side)\n{\n    // optimized\n    float pillarX = dfRect(p.xy, vec2(side));\n    float pillarY = dfRect(p.yz, vec2(side));\n    float pillarZ = dfRect(p.zx, vec2(side));\n    /*\n    vec2 pillarX = dfBox(p, vec3(INFINITY, side, side));\n    vec2 pillarY = dfBox(p, vec3(side, INFINITY, side));\n    vec2 pillarZ = dfBox(p, vec3(side, side, INFINITY));\n    */\n    return vec2(opU(pillarX, opU(pillarY, pillarZ)), M_CROSS);\n}\n\nvec2 dfSphere(vec3 p, vec3 position, float scale)\n{\n    float radius = 1. * scale;\n    return vec2(length(p - position) - radius, M_SPHEREE);\n}\n\nvec2 dfTorus(vec3 p, vec3 position, float size, float thickness){\n    vec2 r = vec2(length(p.xy) - size, p.z);\n    return vec2(length(r) - thickness, M_TORUS);\n}\n\nvec2 dfMenger(vec3 p)\n{\n    float cubeSize = 1.;\n    float count = 1.;\n    vec2 baseCube = dfBox(p, vec3(cubeSize));\n    vec2 dist = baseCube;\n    for(int i=1; i<=FRACTAL_STEP; i++)\n    {\n        // if(i > int(floor(mod(gTime * 3., 5.)))) break;\n        // float repeatInterval = 1.25 - abs(pow(1. * cos(gTime / PI), 2.) * 1.0);\n        float repeatInterval = 0.6 - abs(.2 * cos(gTime / PI *.5));\n        // float repeatInterval = 1. / 3.;\n        vec3 a = opRep(p * count, repeatInterval);\n        vec3 r = 1. - 3. * abs(a);\n\n        count *= 3.;\n        vec2 c = vec2(dfInfCross(r, cubeSize / 3.).x / count, M_CROSS);\n        dist = opS(dist, c, p);\n    }\n    return dist;\n}\n\nvec2 dfSphere2(vec3 p)\n{\n    float z = 1.;\n    return opS(opS(opS(\n        dfSphere(p, vec3(0., 0., z), .065), \n        dfSphere(p, vec3(cos(gTime * 3.) * 0.05, sin(gTime * 2.) * 0.05, 0.04 * sin(gTime * 3.) + z), .025)),\n        dfSphere(p, vec3(cos(gTime * 2.) * 0.05, sin(gTime * 2.5) * 0.065, 0.04 * sin(gTime * 2.) + z), .045)),\n        dfSphere(p, vec3(cos(gTime * 1.) * 0.05, sin(gTime * 3.5) * 0.065, 0.05 * sin(gTime * 1.) + z), .03));\n}\n\nvec2 distanceFunc(vec3 p)\n{\n    // vec2 dist = dfMenger(rotate(opRep(p, 1.5), radians(gTime / PI * 100.), vec3(1., 1., 0.)));\n    vec2 dist = opU(\n        dfMenger(opRep(vec3(p.xy, p.z -1.125 * gTime), vec3(vec2(1.25 + .25 * displacementAmount(-1.)), 1.001))),\n        dfSphere2(p));\n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;  // ray\n    return normalize(vec3(\n        distanceFunc(p + vec3(  d, 0.0, 0.0)).x - distanceFunc(p + vec3( -d, 0.0, 0.0)).x,\n        distanceFunc(p + vec3(0.0,   d, 0.0)).x - distanceFunc(p + vec3(0.0,  -d, 0.0)).x,\n        distanceFunc(p + vec3(0.0, 0.0,   d)).x - distanceFunc(p + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nfloat getSimpleLightingDiffuse(vec3 rPosition, vec3 lightPos)\n{\n    vec3 normal = getNormal(rPosition);\n    return clamp(dot(lightPos, normal), 0.05, 1.0);\n}\n\nfloat getSoftShadow(vec3 rPosition, vec3 lDirection){\n    lDirection = normalize(lDirection);\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for(float t = 0.0; t < 50.0; t++){\n        h = distanceFunc(rPosition + lDirection * c).x;\n        if(h < 0.001){\n            return shadowCoef;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvec4 getColor(vec2 fPosition)\n{\n    // camera\n#ifdef SCALE_ANIMATION\n    float k = 9.;\n    float animTime = mod(gTime, 3.);\n    if(mod(floor(gTime / 3.), 2.) == 1.) animTime = 3. - animTime; \n    vec3 cPosition = vec3(0.0,  0.0,  2.) + vec3(fBm(vec2(cos(gTime / PI), sin(gTime / PI))) - .5, fBm(vec2(sin(gTime / PI), cos(gTime / PI))) - .5, mix(200., .0, 1.0 - exp( -animTime * k )));\n#elif defined GO_ANIMATION\n    float camSpeed = 1.;\n    vec3 cPosition = vec3(0.0,  0.0,  2.25) + \n    vec3(animNoise(1., 0., .1),\n         animNoise(1., 10., .2),\n         -1.125);\n#else\n    vec3 cPosition = vec3(0.0,  0.0,  2.25);\n#endif\n\n#ifdef DIR_ANIMATION\n    vec3 cDirection = vec3(\n        animNoise(0.1, 1., 7.5),\n        animNoise(0.1, 0., 7.5),\n        -1.);\n#else\n    vec3 cDirection = vec3(0.0,  0.0, -1.0);\n#endif\n\n    // light\n    vec3 lPosition = vec3(0.577, 2., 1.577);\n    \n    // ray\n    vec3 rDirection = getRayDirection(cDirection, vec3(0., 1., 0.), fPosition);\n    \n    // marching loop\n    vec2 distance = vec2(0.); // ray\n    float rLength = 0.0;     // ray\n    vec3  rPosition = cPosition;    // ray\n    float ittrCount = 0.;\n    for(int i = 0; i < MAX_MARCHING_ITTRATION; i++) {\n        distance = distanceFunc(rPosition);\n        float absDist = abs(distance.x);\n        if(distance.y == M_SPHEREE && (absDist < RAY_HIT_THRESHOLD || absDist > FAR_CLIP)) {\n            rLength += distance.x;\n            vec3 newDir = getNormal(rPosition);\n            rPosition = cPosition + rDirection * rLength;\n            rDirection = newDir;\n            ittrCount++;\n            continue;\n        }\n        if(absDist < RAY_HIT_THRESHOLD || absDist > FAR_CLIP) { break; }\n        rLength += distance.x;\n        rPosition = cPosition + rDirection * rLength;\n        ittrCount++;\n    }\n    \n    // \n    float diffuse = getSimpleLightingDiffuse(rPosition, lPosition);\n    float shadow = getSoftShadow(rPosition + getNormal(rPosition) * 0.001, lPosition);\n    vec3 color = C_BASE; \n    if (distance.y == M_BASE)  color = C_BASE;\n    if (distance.y == M_CROSS) color = C_CROSS;\n    if (distance.y == M_EDGE)  color = C_EDGE;\n    \n    float aoCoeff = smoothstep(0., 1., ittrCount / float(MAX_MARCHING_ITTRATION));  // AO()\n    return vec4(color * diffuse * max(.5, shadow) * (1. - aoCoeff) + C_AO * aoCoeff, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // fragment position\n    vec2 fPosition = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    \n    fragColor = getColor(flHorizontalDisplacement(fPosition, 0.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1011, 1022, 1083, 1083, 1149], [1151, 1160, 1203, 1203, 1276], [1278, 1278, 1298, 1298, 1326], [1328, 1379, 1406, 1406, 1551], [1553, 1553, 1582, 1582, 2029], [2031, 2031, 2053, 2053, 2310], [2312, 2312, 2369, 2369, 2476], [2478, 2478, 2537, 2537, 3132], [3134, 3134, 3179, 3179, 3608], [3610, 3610, 3647, 3647, 3720], [3772, 3803, 3848, 3880, 4087], [4088, 4088, 4153, 4153, 4360], [4362, 4434, 4465, 4465, 4491], [4492, 4492, 4520, 4520, 4568], [4570, 4586, 4617, 4617, 4644], [4645, 4645, 4673, 4673, 4819], [4820, 4820, 4856, 4856, 5190], [5192, 5208, 5239, 5239, 5265], [5267, 5281, 5316, 5316, 5363], [5364, 5364, 5400, 5400, 5435], [5437, 5507, 5540, 5540, 5626], [5628, 5638, 5669, 5669, 5779], [5781, 5781, 5818, 5835, 6223], [6225, 6225, 6276, 6276, 6368], [6370, 6370, 6435, 6435, 6531], [6533, 6533, 6556, 6556, 7209], [7211, 7211, 7235, 7235, 7657], [7659, 7659, 7686, 7784, 7961], [7963, 7963, 7986, 7986, 8373], [8375, 8375, 8438, 8438, 8532], [8534, 8534, 8587, 8587, 8977], [8979, 8979, 9010, 9024, 11399], [11401, 11401, 11456, 11481, 11648]], "test": "timeout"}
{"id": "XtGBWG", "name": "GLSL Practice With Shadertoy ", "author": "RaduBT", "description": "http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/", "tags": ["practice"], "likes": 9, "viewed": 413, "published": "Public API", "date": "1543728782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float speed = .041;\n    float scale = 0.002;\n    vec2 p = fragCoord * scale;   \n    for(int i=1; i<10; i++){\n        p.x+=0.5/float(i)*sin(float(i)*3.*p.y+iTime*speed)+iMouse.x/1000.;\n        p.y+=0.3/float(i)*cos(float(i)*3.*p.x+iTime*speed)+iMouse.y/1000.;\n    }\n    float r=cos(p.x+p.y+1.)*.5+.5;\n    float g=sin(p.x+p.y+1.)*.5+.5;\n    float b=(sin(p.x+p.y)+cos(p.x+p.y))*.85+.5;\n    vec3 color = vec3(r,g,b);\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 510]], "test": "ok"}
{"id": "XtKfWc", "name": "Physically-based SDF [copy]", "author": "battlebottle", "description": "just https://www.shadertoy.com/view/XlKSDR but just with some toying around on my side. Tried a different ACES tonemapper.\nClick and drag to see to see no-tonemapper vs tonemapper.\n\nThe ball changes hue over time \\_()_/", "tags": ["sdf", "tonemapper", "pbr", "aces"], "likes": 7, "viewed": 463, "published": "Public API", "date": "1544318191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = (sin(iTime) + 1.5) * 1.0;\n        float indirectIntensity = 0.64 * (sin(iTime) + 1.5) * .5;\n\n        if (material < 4.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            // Metallic objects\n            baseColor = hueShift(vec3(0.1, 0.6, 0.05),iTime);\n            roughness = 0.2;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 0.8, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin.x += 1.7 * cos(iTime * 0.2);\n    origin.z += 1.7 * sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    // Tone mapping\n    if (iMouse.z > 0.0) {\n        if (iMouse.x < fragCoord.x) {\n        \tcolor = ACESFitted(color);\n        }\n    } else {\n        color = ACESFitted(color);\n    }\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n    \n    //add some noise\n    fragColor -= vec4( texture(iChannel0, fragCoord.xy / 256.0).rgb / 64.0, 0.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKfWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 110, 110, 885], [1078, 1078, 1104, 1104, 1122], [1124, 1124, 1160, 1160, 1188], [1190, 1190, 1227, 1227, 1285], [1287, 1287, 1319, 1319, 1355], [1357, 1357, 1387, 1387, 1548], [1728, 1728, 1777, 1777, 2071], [2073, 2073, 2123, 2123, 2446], [2448, 2448, 2479, 2479, 2799], [2972, 2972, 2993, 2993, 3041], [3043, 3043, 3104, 3189, 3386], [3388, 3388, 3461, 3553, 3753], [3755, 3755, 3797, 3877, 3931], [3933, 3933, 3982, 3982, 4030], [4032, 4032, 4105, 4162, 4375], [4377, 4377, 4397, 4397, 4420], [4606, 4606, 4656, 4740, 5098], [5100, 5100, 5155, 5212, 5472], [5676, 5676, 5709, 5765, 5951], [6354, 6354, 6381, 6381, 6505], [6507, 6507, 6536, 6536, 6746], [6750, 6750, 6789, 6789, 6832], [7010, 7010, 7078, 7098, 10075], [10263, 10263, 10327, 10327, 10579], [10581, 10581, 10636, 10666, 11694]], "test": "error"}
{"id": "XttBWX", "name": "[TDF2018]Time_machine", "author": "EvilRyu", "description": "glsl compo for tokyo demo fest 2018, 3rd place\n\nNice to be there, thanks tdf!", "tags": ["raymarching", "fractal", "tdf", "doraemon"], "likes": 26, "viewed": 874, "published": "Public API", "date": "1543756590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define PI 3.1415926535\n#define FAR 30.0\n\nvec2 hash22(vec2 p)\n{\n    float f=p.x+p.y*37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nfloat hash13(vec3 p)\n{\n    p=fract(p * vec3(5.3983, 5.4472, 6.9371));\n    p += dot(p.yzx, p.xyz + vec3(21.5351, 14.3137, 15.3219));\n    return fract(p.x * p.y * p.z * 95.4337);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n\nvec2 line(vec3 pos, vec3 a, vec3 b)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return vec2(length(pa-h*ba), h);\n}\n\nfloat line(vec3 pos, vec3 a, vec3 b, float r)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return length(pa-h*ba)-r;\n}\n\nfloat line(vec2 pos, vec2 a, vec2 b, float r)\n{\n    vec2 pa=pos-a;\n    vec2 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return length(pa-h*ba)-r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q=vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere(vec3 p)\n{\n    return length(p)-0.5;\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n  vec2 d=abs(vec2(length(p.xz),p.y))-h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat prism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat ellipsoid(vec3 p, vec3 r)\n{\n    float k0=length(p/r);\n    float k1=length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n  vec3 d=abs(p)-b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 swing(vec3 p)\n{\n    p.xy*=rot(0.15*sin(1.5*iTime));\n\n    p+=vec3(0.5*sin(1.5*iTime),0.,-0.3+2.*iTime);\n    return p;\n}\n\n// for bounding sphere\nvec3 inverse_swing(vec3 p)\n{\n    p.xy*=rot(-0.15*sin(1.5*iTime));\n\n    p-=vec3(0.5*sin(1.5*iTime),0.,-0.3+2.*iTime);\n    return p;\n}\n\n#define HEAD 1\n#define BODY 2\n#define NOSE 3\n#define HAND 4\n#define BELL 5\n// machine\n#define BASE 6\n#define CONTROL 7\n#define CONTROL_FRONT 8\n#define FUEL 9\n#define HANDLE1 10\n#define HANDLE2 11\n#define SOFA 12\n#define LIGHT 13\n\nint obj_id, machine_id;\n\nvoid body(vec3 p, inout float d0)\n{\n    float d1=line(p+vec3(0.,.6,0.),vec3(0),vec3(0.,0.2,0.),0.32);\n    if(d1<d0) obj_id=BODY;\n    d0=smin(d0,d1,0.03);\n}\n\nvoid brace(vec3 p, inout float d0)\n{\n    float d2=torus(p+vec3(0.,.4,0.),vec2(0.31,0.03));\n    if(d2<d0) {obj_id=NOSE;d0=d2;}\n}\n\nvoid legs(vec3 p, inout float d0)\n{\n    vec3 q=vec3(abs(p.x)-.18,p.y,p.z);\n    float d3=line(q+vec3(0,.95,0.),vec3(0),vec3(0.,0.2,0.),0.15);\n    d0=smin(d0,d3,0.13);\n    \n    // feet\n    q.x=abs(p.x)-0.2;\n    float d4=torus(q+vec3(0.,1.05,0.),vec2(0.08,0.09));\n    if(d4<d0) {obj_id=HAND;d0=d4;}\n}\n\nvoid arms(vec3 p, inout float d0)\n{\n    vec2 d5=line(p+vec3(-.28,0.5,0.),vec3(0),vec3(0.27,0.25,0.));\n    d5.x=d5.x-0.1*(1.-.6*d5.y);\n    if(d5.x<d0) obj_id=BODY;\n    d0=smin(d0,d5.x,.02);\n    d5.x=length(p+vec3(-.6,0.2,0.))-0.09;\n    if(d5.x<d0) {obj_id=HAND;d0=d5.x;}\n    \n    d5=line(p+vec3(.28,0.5,0.),vec3(0),.9*vec3(-0.27,-0.25,0.));\n    d5.x=d5.x-0.1*(1.-.6*d5.y);\n    if(d5.x<d0){obj_id=BODY;d0=d5.x;}\n    d5.x=length(p+vec3(.55,0.75,0.))-0.08;\n    if(d5.x<d0) {obj_id=HAND;d0=d5.x;}\n}\n\nvoid nose_tail(vec3 p, inout float d0)\n{\n    float d6=length(p+vec3(0.,-0.15,0.5))-0.05;\n    if(d6<d0) {obj_id=NOSE;d0=d6;}\n    \n    // tail\n    float d7=line(p+vec3(0.,0.77,-0.1),vec3(0),vec3(0.,-0.1,0.25),0.01);\n    float dt=length(p+vec3(0.,0.87,-0.35))-0.04;\n    if(dt<d0) {obj_id=NOSE;d0=dt;}\n    if(d7<d0) {obj_id=BODY;d0=d7;}\n\n}\n\nvoid bag(vec3 p, inout float d0)\n{\n    vec3 q=p;\n    q.yz*=rot(0.14);\n    float d8=cylinder(vec3(q.x,q.z+.16,abs(q.y+0.55)), vec2(0.1,.19))-0.05;\n    float d9=box(q+vec3(0.,.1,.0),vec3(1.,.44,1.));\n    d8=smax(-d9,d8,.02);\n    d0=smin(d0,d8,0.01);\n    \n    // bell\n    float d10=length(p+vec3(0.,0.46,0.36))-0.06;\n    float d11=torus(p+vec3(0.,0.46,0.36),vec2(0.06,0.009));\n    d10=min(d10,d11);\n    if(d10<d0) {obj_id=BELL;d0=d10;}\n}\n\nvoid mouth(vec3 p, inout float d0)\n{\n    vec3 q=p;\n    \n    p.yz*=rot(0.2);\n    float d12=cylinder(vec3(p.x,p.z+.6,abs(p.y-0.11)), vec2(0.25,.19))-0.05;\n    float d13=box(p+vec3(0.,-1.11,.0),vec3(1.,1.,1.));\n    d12=smax(-d13,d12,.06);\n    if(-d12>d0) obj_id=NOSE;\n    d0=smax(-d12,d0,.03); \n    float dt=length(vec3(abs(p.x)-.05,p.y+.18,p.z+.2))-0.2;\n    if(dt<d0) {obj_id=NOSE;d0=dt;}\n    \n    \n    q.x=abs(q.x);\n    \n    vec2 d5=line(q+vec3(0.,-0.03,0.41),vec3(0),vec3(0.27,-0.01,-0.02));\n    //if(d14<d0) obj_id=NOSE;\n    d5.x-=0.07+0.01*(1.-d5.y);\n    d0=smin(d0,d5.x,0.01);\n}\n\nfloat doraemon(vec3 p)\n{\n    p=swing(p);\n    \n    obj_id=HEAD;\n    float d0=length(p)-0.5;\n    \n    body(p,d0);\n    brace(p,d0);\n    legs(p,d0);\n    arms(p,d0);\n    nose_tail(p,d0);\n    bag(p,d0);\n    mouth(p,d0);\n    return d0;\n}\n\nvoid main_control(vec3 p, inout float d0)\n{\n    float d2=box(p+vec3(0.,-0.4,.9), vec3(.87,.4, .2));    \n    if(d2<d0){machine_id=CONTROL;d0=d2;}\n    float d3=prism(vec3(p.z+1.,p.y-0.24,p.x), vec2(0.4,0.87));\n    if(d3<d0){machine_id=CONTROL_FRONT;d0=d3;}\n    \n    float d4=box(p+vec3(0.,-0.8,.85),vec3(0.8,0.2,0.2));\n    d0=max(-d4,d0);\n    \n    float d5=cylinder(p+vec3(-0.5,-0.7,.8),vec2(0.015,0.2));\n    if(d5<d0){machine_id=CONTROL;d0=d5;}\n    \n    float d6=length(p+vec3(-0.5,-0.88,.8))-0.05;\n    if(d6<d0) {machine_id=HANDLE1; d0=d6;}\n}\n\nvoid lamp(vec3 p, inout float d0)\n{\n    float d7=cylinder(p+vec3(-1.17,-1.,.8),vec2(0.025,1.));\n    float d8=line(p+vec3(-1.17,-2.,.8),vec3(0.),vec3(-0.35,0.35,0.),0.025);\n    d8=min(d7,d8);\n    if(d8<d0){machine_id=CONTROL;d0=d8;}\n    \n    vec3 q=p;\n    q.xy*=rot(0.8);\n    float d9=ellipsoid(q+vec3(1.32,-2.22,.8),vec3(0.25,0.07,0.2));\n    if(d9<d0){machine_id=LIGHT;d0=d9;}\n}\n\nvoid handles(vec3 p, inout float d0)\n{\n    float d=cylinder(vec3(p.x+1.35,p.z-1.2, p.y-.1),vec2(0.3,.25));\n    d=max(d,-box(p+vec3(1.65,-.2,-1.2),vec3(0.3,0.4,0.3)));\n    d=max(d,-box(p+vec3(1.25,.4,-1.2),vec3(0.3,0.4,0.3)));\n    if(d<d0){machine_id=CONTROL;d0=d;}\n    \n    p=p+vec3(1.15,-.3,-1.1);\n    \n    for(int i=0;i<3;++i)\n    {\n        d=line(p,vec3(0),vec3(0.1,0.2,0.),0.01);\n        d0=min(d0,d);\n        d=length(p+vec3(-0.1,-0.2,0.))-0.04;\n        if(d<d0){machine_id=HANDLE2;d0=d;}\n        p.z-=0.11;\n    }\n}\n\nvoid sofa(vec3 p, inout float d0)\n{\n    float d12=rbox(p+vec3(0.,-.5,-.8),vec3(0.6,0.5,0.04), 0.05);\n    float d13=rbox(p+vec3(0.,-.15,-.4),vec3(0.6,0.15,0.3), 0.05);\n    d13=smin(d12,d13,0.2);  \n    if(d13<d0){machine_id=SOFA;d0=d13;}\n}\n\nfloat timemachine(vec3 p)\n{\n    p=swing(p+vec3(0,0,0));p.y+=1.15;\n    \n    machine_id=BASE;\n    \n    float d0=box(p+vec3(0.,0.02,0.), vec3(1.5,0.06,1.8));\n    \n    main_control(p,d0);\n    lamp(p,d0);\n    handles(p,d0);\n    sofa(p,d0);\n    \n    p.x=abs(p.x)-1.17;\n    float d1=line(p+vec3(0.,-0.1,1.45),vec3(0),vec3(0.,0.,1.5),0.2);\n    if(d1<d0) {machine_id=FUEL; d0=d1;}\n    return d0;\n}\n\n\nvec2 fold(vec2 p, float a)\n{\n    p.x=abs(p.x);\n    vec2 n = vec2(cos(a),sin(a));\n    for(int i = 0; i < 3; ++i)\n    {\n        p -= 2.*min(0.,dot(p,n))*n;\n        n = normalize(n-vec2(1.,0.));\n    }\n    return p;\n}\n\nvec3 path(float p)\n{\n    return vec3(sin(p*0.05)*cos(p*0.025)*18., 0.,0.);\n}\n\n/// from Klem's Olympian: https://www.shadertoy.com/view/XltyRf\nvec3 tunnel(vec3 rd, float pos, float speed) \n{\n    const float max_r = 5.;\n    vec3 col;//=vec3(1.);\n    for (float r=1.0;r<max_r+float(min(0,iFrame));r+=1.0) \n    {\n        // calculate where the ray intersects several fixed radius cylinders\n        // using cylindrical coordinates\n        // (phi, r, z)\n        // phi=arctan(rd.y/rd.x)\n        // r=r\n        // length(rd.xy) / r = rd.z / z ==> z=rd.z*r/length(rd.xy)\n        float phi=atan(rd.x, rd.y);\n        float z=rd.z*r/length(rd.xy);\n        if(r<1.5)col=vec3(abs(z)*.005);\n        // adjust the uv acoording to cylinder size and position\n        vec2 uv=vec2(phi*r, pos+z);\n        uv.x+=1.717*hash13(vec3(floor(uv),r))*r;\n        \n        vec2 cell_center=floor(uv)+0.5;\n        cell_center+=hash22(cell_center+vec2(0.,r))-.5;\n\n        vec2 size=vec2(.01);\n        size.y+=speed/r;\n        size.y/=sin(atan(r/abs(z)));\n        \n        //float d=(length((uv-cell_center)/size)-1.)*size.y;\n        //col+=vec3(1,.9,.6)*smoothstep(0.105,-0.105,d)/(.5*r*r+.3*z*z);\n\n        \n        float redshift=0.01+speed/r;\n        cell_center.y-=redshift;\n        for (int i=0; i<3+min(0,iFrame); i++) \n        {\n            cell_center.y+=redshift;\n            \n            // draw stars\n            vec2 p=uv-cell_center;\n            float d=(length(p/size)-1.0)*size.y;\n            float dist=(r*r+z*z);\n            col[i]+=smoothstep(0.02, -0.02, d)/dist;\n        }\n        \n    }\n    return 3.*col;\n}\n\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1+float(min(0,iFrame)); i++)\n    {\n        d=i/5.0;\n        r+=w*(d-min(doraemon(p+n*d),timemachine(p+n*d)));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\n\nvec3 material_doraemon(vec3 rd, vec3 pos, vec3 nor)\n{\n    vec3 col=vec3(0);\n    float d; \n    pos=swing(pos);\n    \n    if(obj_id==HEAD)\n    {\n        col=vec3(0.,0.5,1.0); \n        if(pos.z<0.&&length(vec2(pos.x*0.9,pos.y+0.05))<0.38)col=vec3(0.9);\n        \n        // eyes\n        if(pos.z<0.)\n        {\n            vec2 p=vec2(abs(pos.x)-0.1,pos.y*.7-0.2);\n            float r=length(p.xy);\n            col*=pow(1.-smoothstep(0.08,0.09,r)*smoothstep(0.1,0.09,r),1.);\n            if(r<0.085) col=vec3(1.);\n            p=vec2(abs(pos.x)-0.06, pos.y-0.26);\n            r=length(p);\n            p=vec2(abs(pos.x)-0.06, pos.y-0.26);\n            float r1=length(p);\n            col*=pow(1.-smoothstep(0.0,0.025,r)*smoothstep(0.03,0.025,r),7.0);\n            \n            // beards\n            if(pos.y>0.&&pos.y<0.11)\n            col*=smoothstep(0.,0.01,abs(pos.x));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y), vec2(0.,0.14),vec2(0.14,0.18),0.001));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y+0.04), vec2(0.,0.14),vec2(0.15,0.15),0.001));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y+0.08), vec2(0.,0.14),vec2(0.15,0.13),0.001));\n        }\n    }\n    else if(obj_id==BODY)\n    {\n        col=vec3(0.,0.5,1.0); \n        if(pos.z<0.&&length(vec2(pos.x,pos.y+.6))<.22)col=vec3(0.9);\n    }\n    else if(obj_id==NOSE)\n        col=vec3(.4,0.,0.);\n    else if(obj_id==BELL)\n        col=vec3(1.2,0.7,0.);\n    else if(obj_id==HAND)\n        col=vec3(.9);\n    else if(obj_id==BASE)\n        col=vec3(0.05,0.1,0.2);\n    else if(obj_id==CONTROL)\n        col=vec3(.9,.7,.5);\n    else if(obj_id==CONTROL_FRONT)\n    {\n        col=vec3(.9,.7,.5);\n        // pos.y -1.x -> -0.7\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-0.8),vec2(0.5,-0.8),0.001)),40.));\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-0.9),vec2(0.5,-0.9),0.001)),40.));\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-1.),vec2(0.5,-1.),0.001)),40.));\n        \n    }\n    else if(obj_id==HANDLE1)\n        col=vec3(0.,0.1,0.3);\n    else if(obj_id==FUEL)\n        col=vec3(0.01,0.04,0.1);\n    else if(obj_id==HANDLE2||obj_id==SOFA)\n        col=vec3(0.1,0.,0.04);\n    else if(obj_id==LIGHT)\n    {\n        // pixel light\n        vec2 frp=abs(fract(pos.xz*10.));\n        frp=pow(frp, vec2(4.));\n        float edge=max(0.,1.-(frp.x+frp.y));\n        vec2 flp=floor(pos.xz*10.);\n        float k=dot(sin(flp+cos(flp.yx*2.+iTime*2.)),vec2(.5));\n        col=nor.y<0.? 10.*edge*vec3(pow(k,.7)*2., 4.*pow(k, 1.5), pow(k,2.)) : vec3(.9,.7,.5);\n    }\n    return col;\n}\n\nvec3 get_doraemon_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*doraemon(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 get_timemachine_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*timemachine(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 lighting_doraemon(vec3 rd, vec3 pos, float ps,float hitinfo, float t)\n{\n    vec3 l1dir=normalize(vec3(1.0,2.,-1.));\n    vec3 l1col=vec3(1.,0.8,0.8);\n    \n    vec3 e=vec3(0.5*ps,0.0,0.0); \n    vec3 nor;\n\n    if(hitinfo<.9)\n        nor=get_doraemon_normal(pos);\n    else\n        nor=get_timemachine_normal(pos);\n    \n    if(timemachine(pos)<doraemon(pos))obj_id=machine_id;\n    if(t>FAR&&obj_id==LIGHT)obj_id=CONTROL; // avoid weird artifacts, should find a bettwe way\n    \n    vec3 mate=material_doraemon(rd,pos,nor);\n    float ao=get_ao(pos,nor);\n    float dif=max(0.0,dot(nor,l1dir));\n    float bac=max(0.0,dot(nor,-l1dir));\n    float spe=max(0.0, pow(clamp(dot(l1dir, reflect(rd, nor)), 0.0, 1.0), 32.0));\n\n    vec3 lin=6.0*dif*l1col*ao;\n    lin+=1.*bac*l1col;\n    lin+=3.*spe*vec3(1.);\n    return lin*0.2*mate;\n}\n\nfloat pixel_size;\n\nvec4 intersect_doraemon(vec3 ro, vec3 rd, out vec3 hitinfo)\n{\n    hitinfo=vec3(0.,0.,1.);\n    float d_first=100.0, t_first=0.0;\n    float old_d=1000.0;\n    float d_max=1000.0, t_max=0.0;\n    float t=1.0;\n    float d=100.0;\n    float hitwho=0.,old_hitwho=0.;\n    \n    for(int i=0; i<64+min(0,iFrame); ++i) \n    {\n        hitwho=0.;\n        // splitting them is just for not crashing my windows laptop....\n        d=doraemon(ro+rd*t);\n        float d1=timemachine(ro+rd*t);\n        if(d1<d){hitwho=1.;d=d1;}\n\n        \n        if(d_first == 100.0)  // the first edge\n        {\n            hitinfo.x=hitwho;\n            if(d>old_d) \n            {\n                if(old_d<pixel_size * (t-old_d))\n                {\n                    d_first=old_d;\n                    t_first=t-old_d;\n                    hitinfo.x=old_hitwho;\n                }\n            }\n            old_d=d;\n            old_hitwho=hitwho;\n        }\n        if(d<d_max) // save the max occluder\n        { \n            t_max=t; \n            d_max=d;\n            hitinfo.y=hitwho;\n        }  \n        \n        if(d<0.00001 || t>FAR)\n            break;\n        t += d;\n        hitinfo.z=t;\n    }\n    return vec4(t_max, d_max, t_first, d_first);\n}\n\nfloat bounding_sphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 p=sph.xyz;\n    p=inverse_swing(p);\n    float t=-1.0;\n    vec3  ce=ro-p;\n    float b=dot(rd, ce);\n    float c=dot(ce, ce)-sph.w*sph.w;\n    float h=b*b - c;\n    if(h>0.0)\n    {\n        t=-b-sqrt(h);\n    }\n    \n    return t;\n}\n\nvec3 render_doraemon(vec3 ro, vec3 rd, vec3 bg)\n{\n    float t=bounding_sphere(ro,rd,vec4(0.,-0.35,0.,2.5));\n    if(t<=0. || t>1000.)\n        return bg;\n    \n    // first hit, max hit, t\n    vec3 hitinfo;\n    vec4 res=intersect_doraemon(ro,rd,hitinfo);\n    \n    float d_max, t_max, d_first, t_first;\n    t_max=res.x;\n    d_max=res.y;\n    t_first=res.z;\n    d_first=res.w;\n    vec3 nor,pos;\n    \n    vec3 col=bg;\n    \n    if(d_max < pixel_size*t_max) \n    {\n        pos=ro+rd*t_max;\n        col=mix(lighting_doraemon(rd, pos, pixel_size*t_max,hitinfo.y, hitinfo.z), col, \n                  clamp(d_max/(pixel_size * t_max), 0.0, 1.0));\n    }\n    float ratio=0.0;\n\n    if(d_first==100.0 || t_max==t_first)\n    {\n        t_first=t_max;\n        d_first=d_max;\n        ratio=0.5;\n    }\n    \n    pos=ro+rd*t_first;\n    col=mix(lighting_doraemon(rd, pos, pixel_size*t_first,hitinfo.x, hitinfo.z),\n              col, clamp(ratio+d_first/(pixel_size*t_first), 0.0, 1.0));\n    \n    return col;\n}\n\n\n#define CITY_MENGER 1\n#define CITY_ROAD 2\n\n#define VOXEL_GAP 0.1\n\nconst mat3 ma=mat3(0.6,0.,0.8,\n                   0.,1.,0.,\n                   -0.8,0.,0.6);\n\nvec4 city(vec3 p)\n{\n    p.y-=0.3;\n    obj_id=CITY_MENGER;\n    vec2 flp=floor(p.xz);\n    vec2 frp=fract(p.xz);\n    \n    frp-=0.5;\n    \n    vec2 rand;\n    rand=hash22(flp);\n    float height=0.4+rand.x*rand.x*1.7;\n    float d0=box(vec3(frp.x,p.y,frp.y),vec3(0.1,height,.4));   \n    \n    vec4 res=vec4(d0, 1.0, 0.0, 0.0);\n    \n    // menger spone from iq\n    // larger value gives higher density of rooms\n    // I like 1.1, 1.2, 1.7\n    float s=1.+.2*rand.y*(1.-step(1.6,height)); \n    vec3 q=p;\n    for(int m=0; m<4+min(0,iFrame); m++)\n    {      \n        p.y+=rand.y;\n        vec3 a=mod(p*s, 2.0)-1.0;\n        s*=3.;\n        vec3 r=abs(1. - 3.0*abs(a));\n        float da=max(r.x,r.y);\n        float db=r.y;//max(r.y,r.z);\n        float dc=max(r.z,r.x);\n        float c=(min(da,min(db,dc))-1.)/s;\n\n        if(c>d0)\n        {\n          d0=c;\n          res=vec4(d0, min(res.y,.2*da*db*dc), (1.0+float(m))/4.0, 0. );\n        }\n    }\n   \n    if(q.y<res.x){obj_id=CITY_ROAD;res.x=q.y;}\n    return res;\n}\n\n\nvec3 get_city_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*city(p+0.001*e).x;\n    }\n    return normalize(n);\n}\n\n#define CITY_ITER 250\n#define CITY_FAR 50.\n\nvec4 intersect_city_voxel(vec3 ro, vec3 rd)\n{\n    vec4 h=vec4(100.),res=vec4(-1);\n    float t = 0.05;\n    vec3 p=vec3(0.0);\n\n    for (int i=0; i<CITY_ITER+min(0,iFrame); i++)\n    {\n        if(h.x<0.0001+0.000125*t||t>CITY_FAR)\n        {\n            continue;\n        }\n        p=ro+rd*t;\n\n        h=city(p);\n\n        // 2d voxel marching the city blocks, as the boundaries are not continues\n        \n        float dx=-fract(p.x);\n        if (rd.x>0.) \n            dx=fract(-p.x);\n        \n        float dz=-fract(p.z);\n        if (rd.z>0.)\n            dz=fract(-p.z);\n        \n        float nearest=min(fract(dx/rd.x), fract(dz/rd.z))+VOXEL_GAP;\n        nearest=max(VOXEL_GAP, nearest);\n        \n        t+= min(h.x, nearest); \n        res=vec4(t,h.yzw);\n        \n    }\n    return res;\n}\n\nvec3 material_city(vec3 p, float night)\n{\n    vec3 col=vec3(0.4,0.6,1.0)*0.15;\n    vec4 res=city(p);\n    if(obj_id==CITY_MENGER)\n    {\n        res.z=1.-res.z;\n        col=(1.2*(1.-night)+0.8)* vec3(.5+res.z*res.z,.3+pow(res.z, 3.), res.z*res.z*0.9);\n        //col=vec3(res.z);  \n\n        if(night>0.5)\n        {\n            if(res.z<.25)\n                col=50.*vec3(1.2,0.3,0.);\n            else if(res.z<0.75)\n                col*=6.;\n        }\n        \n    }\n    else\n    {\n        p.z-=iTime*2.;\n        col+=(1.-smoothstep(0.01,0.025,abs(abs(p.x)-.25)))*vec3(1);\n        col=mix(col,vec3(1.2,0.7,0.),floor(fract(p.z)+.5)*(1.-smoothstep(0.01,0.02,abs(p.x)-0.001)));//*vec3(1);\n        // fake shadow\n        col*=(0.06+smoothstep(0.4,0.6,abs(abs(p.x+0.13)-0.7))); \n        col*=(0.06+smoothstep(0.4,0.6,-p.x+1.47))*vec3(1); \n    }\n    return col;\n}\n\nvec3 city_bg(vec3 ro, vec3 rd, float night)\n{\n    const vec3 moon_col=vec3(0.8,1.,1.);\n    const vec3 moon_dir=vec3(0,0,-1.);    \n    vec3 col;\n    \n    col=vec3(1.)-moon_col*smoothstep(-.1,0.,rd.y)*smoothstep(0.33,0.37,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n\n    if(night>0.)\n        col=vec3(0.)+vec3(0.3,0.,0.)*smoothstep(-.1,0.,rd.y)*smoothstep(0.33,0.37,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n    \n    return col;\n}\n\n\nfloat curve(in vec3 p, in float w)\n{\n    vec2 e=vec2(-1., 1.)*w;\n    \n    float t1=city(p+e.yxx).x, t2=city(p+e.xxy).x;\n    float t3=city(p+e.xyx).x, t4=city(p+e.yyy).x;\n    \n    return 0.0125/(w*w)*(t1+t2+t3+t4-4.*city(p).x);\n}\n\nvec4 render_city(vec3 ro, vec3 rd, float night)\n{\n    vec4 res=intersect_city_voxel(ro,rd);\n    vec3 col=city_bg(ro,rd,night);\n\n    if(res.x<CITY_FAR)\n    {\n       // if(city(ro+res.x*rd).x>0.005/res.x)\n         //   res.x=res.w;\n        vec3 pos=ro+res.x*rd;\n        vec3 nor=get_city_normal(pos);\n        vec3 l1dir=normalize(vec3(1.0,2.,-1.));\n        vec3 l1col=vec3(1.2,0.8,0.5);\n        \n        float ao=res.y*res.y;\n        if(obj_id==CITY_ROAD)\n            ao=1.;\n\n        vec3 mate=material_city(pos,night);\n        float dif=max(0.0,dot(nor,l1dir));\n        float bac=max(0.0,dot(nor,-l1dir));\n        float sky=0.5+0.5*nor.y;\n        float spe=pow(max(dot(reflect(-l1dir, nor), -rd), 0.0), 16.0);\n        float crv=clamp(1.-abs(curve(pos,0.0015)),0.,1.);\n\n        vec3 lin=4.0*(1.-night)*dif*l1col*ao;\n        lin+=3.*sky*vec3(0.1,0.2,0.5)*ao;\n        lin+=1.*bac*l1col*ao;\n        lin+=1.*spe*vec3(1.);\n        col=lin*crv*0.2*mate;\n        \n        vec3 skycol=vec3(1.-night);\n        if(rd.z<0.)\n            col=mix(col,vec3(.15,0,0),1.-exp(-0.005*res.x*res.x));\n        else col=mix(col,skycol,1.-exp(-0.001*res.x*res.x));\n       //col=vec3(lin);\n    }\n    return vec4(col,res.x);\n}\n\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    pixel_size=1.0/(iResolution.y);\n   \n     // debugging camera\n    //float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    //float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    //vec3 ro=vec3(0.,0.9,-2.*iTime)+vec3(cos(y_rot)*cos(x_rot),0.,cos(y_rot)*sin(x_rot))*10.;\n    //vec3 ta=vec3(0.,0.,-2.*iTime);\n   \n    float time=mod(iTime,40.);\n    vec3 ro,ro2;\n    if(time < 20.)\n    {\n        ro=vec3(0.,.9,-9.);\n        ro2=ro;\n        \n        if(time>10.)\n        {\n            ro.xz*=rot(-(time-10.)*0.07);\n        }\n    }\n    else\n    {\n        ro=vec3(0.,.9,9.);\n        ro2=ro;\n    }\n\n    ro.z-=2.*iTime;\n    ro2.z-=2.*iTime;\n    vec3 ta=vec3(0.,0.,-2.*iTime);\n    \n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(r*p.x + u*p.y + f*2.3);\n    \n    vec3 timetunnel=tunnel(rd,-iTime*8.,.05);\n    vec3 menger=render_city(ro2,rd, 1.0-step(0.0,sin(0.05*(iTime+40.-14.)))).xyz;\n    \n    vec3 bg=mix(timetunnel,menger,1.-smoothstep(0.,1.,sin(0.1*(iTime+40.))));\n    vec3 col=render_doraemon(ro,rd,bg);\n    \n    // post processing\n    col=tonemap(col);\n    col=pow(clamp(col,0.,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttBWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[153, 153, 174, 174, 253], [255, 255, 277, 277, 433], [435, 435, 454, 454, 523], [525, 525, 564, 564, 653], [656, 656, 695, 695, 724], [727, 727, 764, 764, 900], [902, 902, 949, 949, 1078], [1080, 1080, 1127, 1127, 1256], [1258, 1258, 1287, 1287, 1350], [1352, 1352, 1374, 1374, 1402], [1404, 1404, 1436, 1436, 1531], [1533, 1533, 1560, 1560, 1653], [1655, 1655, 1684, 1684, 1771], [1773, 1773, 1806, 1806, 1891], [1893, 1893, 1930, 1930, 2026], [2028, 2028, 2048, 2048, 2151], [2153, 2176, 2204, 2204, 2308], [2565, 2565, 2600, 2600, 2720], [2722, 2722, 2758, 2758, 2849], [2851, 2851, 2886, 2886, 3148], [3150, 3150, 3185, 3185, 3643], [3645, 3645, 3685, 3685, 3980], [3982, 3982, 4016, 4016, 4416], [4418, 4418, 4454, 4454, 4999], [5001, 5001, 5025, 5025, 5231], [5233, 5233, 5276, 5276, 5775], [5777, 5777, 5812, 5812, 6155], [6157, 6157, 6195, 6195, 6677], [6679, 6679, 6714, 6714, 6916], [6918, 6918, 6945, 6945, 7306], [7309, 7309, 7337, 7337, 7522], [7524, 7524, 7544, 7544, 7600], [7602, 7666, 7713, 7713, 9122], [9125, 9125, 9155, 9155, 9377], [9381, 9381, 9434, 9434, 12096], [12098, 12098, 12132, 12230, 12431], [12433, 12433, 12470, 12568, 12772], [12774, 12774, 12850, 12850, 13594], [13615, 13615, 13676, 13676, 14826], [14828, 14828, 14888, 14888, 15121], [15123, 15123, 15172, 15172, 16107], [16270, 16270, 16289, 16289, 17265], [17268, 17268, 17298, 17396, 17595], [17641, 17641, 17686, 17686, 18428], [18430, 18430, 18471, 18471, 19282], [19284, 19284, 19329, 19329, 19708], [19711, 19711, 19747, 19747, 19939], [19941, 19941, 19990, 19990, 21139], [21142, 21142, 21165, 21165, 21341], [21344, 21344, 21401, 21401, 22773]], "test": "timeout"}
{"id": "XtVBDc", "name": "sin(floor(x))", "author": "Orpheus", "description": "visualization of the sin(floor(x)) function over time", "tags": ["learning"], "likes": 3, "viewed": 66, "published": "Public", "date": "1544330461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // sin(floor(x))\n    //float sf = abs(sin(floor((iTime*10.0)+(uv.x*1000.0))));\n    float sf = abs(sin(floor((iTime*TWO_PI*2.0)+(uv.x*1000.0))));\n    \n    // step function\n    vec3 col = vec3(step(sf,uv.y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 137, 447]], "test": "ok"}
{"id": "XtVBDV", "name": "Are smoother() lines better() ?", "author": "elenzil", "description": "smoothstep() on the left, smootherstep() on the right.\ngamma(2.2) top, 1.0 bottom.\n\nfork of \"Simple Smooth Line\" by dilip019. https://www.shadertoy.com/view/XlVfWV\ncomparing smoothstep() to smootherstep() from v_coda: https://www.shadertoy.com/view/MlyBWK", "tags": ["smoothstep", "smootherstep"], "likes": 2, "viewed": 450, "published": "Public API", "date": "1544118337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// smoothstep() on the left, smootherstep() on the right.\n// fork of \"Simple Smooth Line\" by dilip019. https://www.shadertoy.com/view/XlVfWV\n// comparing smoothstep() to smootherstep() from v_coda: https://www.shadertoy.com/view/MlyBWK\n\n#define Pi 3.14159\n#define smooth true\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// Ken Perlin suggests an improved version of the smoothstep() function, \n// which has zero 1st- and 2nd-order derivatives at x = 0 and x = 1.\nfloat smootherstep(float edge0, float edge1, float x) \n{\n  x = clamp((x - edge0)/(edge1 - edge0), 0., 1.);\n  return x * x * x * (x * (x * 6. - 15.) + 10.);\n}\n\nfloat smoothit(float a, float b, float c, bool useSmoother) {\n    if (useSmoother) {\n        return smootherstep(a, b, c);\n    }\n    else {\n        return smoothstep(a, b, c);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.yy;\n\tvec2 uv2= fragCoord.xy / iResolution.xy;\n    uv2.x *= iResolution.x/iResolution.y; \n  //  vec2 center = \n    vec2 q = p;\n\t\n \tfloat var = 0.9 +0.45* cos(0.5*iTime);\n \tfloat var2 = 0.5+ 0.45*sin(0.5*iTime);\n    // background\t\n\tvec3 col = vec3(0.5,0.85,0.9);\n\t\n    \n\tvec2 pA = vec2(0.9,0.50); \t\n    vec2 pB = vec2( var, var2 );\t\n    \n    for (int n = 0; n < 2; ++n) {\n        // compute distance to a set of lines\n        float d   = 0.3;\t \n        \n        vec2 uv = uv2;\n        uv.x += (n == 0 ? 0.3 : -0.3);\n      \n        float h = line( pA, pB, uv );\n        d = min( d, h );\n\n        if( smooth )\n        {\n            const float minW = 0.001;\n            const float maxW = 0.05;\n            float w = mix(minW, maxW, sin(iTime * 0.2) * 0.5 + 0.5);\n            col = mix( vec3(0.0,0.0,0.0), col, smoothit(-w,w,d-0.04,n == 1) ); // black\n            col = mix( vec3(1.0,0.6,0.0), col, smoothit(-w,w,d-0.02,n == 1) ); // orange\n\n        }\n        else\n        {\n            if( d<0.04) col = vec3(0.0,0.0,0.0); // black \n            if( d<0.02 ) col = vec3(1.0,0.6,0.0); // orange\n        }\n    }\n    \n    if (p.y > sin(iTime * 0.8) * 0.2) {\n        col = pow(col, vec3(1.0/2.2));\n    }\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 323, 323, 443], [445, 588, 644, 644, 745], [747, 747, 808, 808, 930], [932, 932, 989, 989, 2281]], "test": "ok"}
{"id": "XtVfWG", "name": "fast easy heightmap tracing", "author": "public_int_i", "description": "fast easy heightmap tracing", "tags": ["fast", "heightmap", "tracing", "easy"], "likes": 4, "viewed": 561, "published": "Public API", "date": "1543876465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2018 - https://xaloez.com/\n\nfloat hmap(vec2 p) {\n    return sin(p.x*.2)*1.6+cos(p.y*.5)+sin(p.y*.08)*2.3;\n}\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    vec3 rd = normalize(vec3((u*2.-iResolution.xy)/iResolution.x,1.)),\n        rp = vec3(0,6.,0.);\n    \n    float ang = iTime*.1;\n    rd.xz *= mat2(cos(ang),-sin(ang),sin(ang),cos(ang));\n    \n    if (rd.y > 0.) {\n    \to = vec4(0.);\n        return;\n    }\n    \n    float s = 4.;\n    int i;\n    for (i = 0; i < 64; i++) {\n        if (rp.y < hmap(rp.xz)) {\n            if (s > .01) {\n                rp -= rd*s;\n                s *= .5;\n            } else break;\n        }\n        rp += rd*s;\n    }\n    if (i < 64) {\n        vec3 p1 = vec3(rp.x,0.,rp.z), p2 = vec3(rp.x+.1,0.,rp.z), p3 = vec3(rp.x,0.,rp.z+.1);\n        p1.y = hmap(p1.xz);\n        p2.y = hmap(p2.xz);\n        p3.y = hmap(p3.xz);\n        vec3 nrm = cross(normalize(p2-p1),normalize(p3-p1));\n        o = vec4(abs(nrm)*(.5+sin(iTime*vec3(.2,.14,.27))*.5),1);\n    } else o = vec4(0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 74, 74, 133], [135, 135, 175, 175, 1020]], "test": "ok"}
{"id": "XtVfzd", "name": "[TDF18] Sake shader", "author": "Pheema", "description": "The shader for GLSL Graphics Compo in Tokyo Demo Fest 2018!!!\nInspired from a sake set, \"Janome Ochoko()\" [url]https://www.google.co.jp/search?q=Janome+Ochoko[/url]\nYou can change where you pour sake by dragging the mouse.", "tags": ["reflection", "wave", "refraction", "water", "sake"], "likes": 26, "viewed": 733, "published": "Public", "date": "1543747947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float eps = 1e-3;\nconst float pi = 3.1415926535;\nconst vec3 z_up = vec3(0.0, 0.0, 1.0);\n\n// Ref: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 p) { \n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat mod2(float p, float a) {\n    return p - a * floor(p / a);\n}\n\nvec2 mod2(vec2 p, vec2 a) {\n    return vec2(mod2(p.x, a.x), mod2(p.y, a.y));\n}\n\nfloat sdf_circle(vec2 p, vec2 o, float r) {\n    return length(p - o) - r;\n}\n\nfloat sdf_ring(vec2 p, float r, float lineWidth) {\n    float outer = sdf_circle(p, vec2(0, 0), r + 0.5 * lineWidth);\n    float inner = sdf_circle(p, vec2(0, 0), r - 0.5 * lineWidth);\n    \n    return max(-inner, outer);\n}\n\nfloat sdf(vec2 p) {\n    return min(sdf_ring(p, 0.75, 0.175), sdf_ring(p, 0.35, 0.175));\n}\n\nfloat sake_displacement(vec2 p, vec2 p0) {\n    float dist = length(p - p0);\n    vec2 dir = normalize(p - p0);\n     \n    float k = 5.0;\n    float omega = 20.0;\n    float basewave = 0.5 * sin(k * dist - mod2(omega * iTime, 2.0 * pi)) + 0.5;\n    float k2 = 22.0;\n    float omega2 = 44.0;\n    float subwave = 0.5 * sin(k2 * dist - mod2(omega2 * iTime, 2.0 * pi)) + 0.5;\n    float k3 = 45.0;\n    float omega3 = 90.0;\n    float subwave2 = 0.5 * sin(k3 * dist - mod2(omega3 * iTime, 2.0 * pi)) + 0.5;\n    \n    basewave = 2.0 * pow(basewave, 4.0) + 0.3 * pow(subwave, 2.0) + 0.09 * subwave2;\n        \n    float amp = min(1.0 / sqrt(eps + dist), 1.0);\n    amp *= basewave;\n    \n    float outer_r = 0.82;\n    amp += 100.0 * step(outer_r, length(p)) * (length(p) - outer_r) * (length(p) - outer_r);\n    \n    amp = 1.0 - exp(-amp);\n    \n    amp *= step(length(p0), 0.85);\n    \n    return -0.1 * amp;\n}\n\nvec3 sake_normal(vec2 p, vec2 p0) {\n    float dfx = sake_displacement(p + vec2(1.0, 0.0) * eps, p0) - sake_displacement(p - vec2(1.0, 0.0) * eps, p0);\n    float dfy = sake_displacement(p + vec2(0.0, 1.0) * eps, p0) - sake_displacement(p - vec2(0.0, 1.0) * eps, p0);\n    return normalize(vec3(dfx, dfy, 2.0 * eps));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.xy;\n    vec2 pos = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mouse_pos = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    if (iMouse.x == 0.0 && iMouse.y == 0.0) {\n        mouse_pos = vec2(-0.5, -0.5) + 0.1 * vec2(2.0 * noise(iTime) - 1.0, 2.0 * noise(iTime + 11.52) - 1.0);\n    }\n    \n    vec3 light_dir = normalize(vec3(3.0, 2.0, 1.0));\n    const float max_sake_depth = 0.4;\n    float sake_depth = mod2(0.05 * iTime, max_sake_depth) * step(length(mouse_pos), 0.85);\n    \n    vec3 normal = sake_normal(pos, mouse_pos);   \n    vec3 refract_dir = refract(-z_up, normal, 1.4);\n        \n    vec2 displacement = refract_dir.xy / refract_dir.z * sake_depth;\n    \n    vec2 displaced_pos = pos + displacement;\n    \n    // rings\n    vec3 ring_color = vec3(0.1, 0.1, 0.6);\n    vec3 ring_edge_color = vec3(0.3, 0.6, 0.9);\n    ring_color = mix(ring_edge_color, ring_color, smoothstep(-0.02, 0.02, -sdf(displaced_pos)));\n    \n    vec3 cup_color = vec3(0.98, 0.98, 0.98);  \n    vec3 color = mix(ring_color, cup_color, smoothstep(0.0, 0.02, sdf(displaced_pos)));\n    \n    color *= 1.0 - 1.0 * max(0.0, dot(displaced_pos, light_dir.xy));\n    color *= mix(0.8, 1.0, sake_depth / max_sake_depth);\n    color *= mix(vec3(1.0), vec3(1.0, 1.0, 0.0), 1.0 - exp(-0.1 * sake_depth));   \n    \n    // reflection\n    vec3 ref_dir = reflect(-z_up, normal);\n    vec3 ref_color = 3.0 * vec3(1.0, 1.0, 1.0) * smoothstep(0.8, 0.9, dot(ref_dir, light_dir));\n    ref_color += 0.5 * noise(2.0 * ref_dir.xy);\n    ref_color *= 1.0 - exp(-2.0 * sake_depth);\n    \n    color += 1.0 * ref_color;\n   \n    // edge\n    color = mix(color, cup_color * 0.6, smoothstep(0.86, 0.87, length(pos)));\n    \n    \n    color = mix(color, vec3(0.1), smoothstep(0.91, 0.92, length(pos)));\n    color *= 1.0 - 0.5 * length(uv) * length(uv);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVfzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 169, 189, 189, 259], [261, 261, 281, 281, 319], [321, 321, 342, 342, 433], [435, 435, 456, 456, 655], [657, 657, 687, 687, 722], [724, 724, 751, 751, 802], [804, 804, 847, 847, 879], [881, 881, 931, 931, 1101], [1103, 1103, 1122, 1122, 1192], [1194, 1194, 1236, 1236, 2083], [2085, 2085, 2120, 2120, 2401], [2403, 2403, 2460, 2460, 4417]], "test": "ok"}
{"id": "XtyfDc", "name": "impossible triangle (224 ch)", "author": "FabriceNeyret2", "description": ".", "tags": ["illusion", "escher", "fake3d", "2tweets", "short", "golf"], "likes": 23, "viewed": 583, "published": "Public API", "date": "1544203923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/4lGfDc\n\n#define S(r)  smoothstep(  9./R.y, 0., abs( U.x -r ) -.1 )   //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = u+u - R;\n    U =  length(U+U)/R.y   /* .955 = 3/pi  1.05 = pi/3  33 ~ pi/2 */\n         *cos( ( mod( .955*atan(U.y,U.x) - iTime ,2.) - .92 ) *1.05 -vec2(0,33));\n    U.x+U.y < 1.85 ? O += mix( .5* S(.5), S(.7), .5+.5*U.y ) : O; }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 149, 149, 419]], "test": "ok"}
{"id": "XtyfDG", "name": "[TDF2018] Life", "author": "setchi", "description": "TokyoDemoFest 2018 GLSL Graphics Compo 2nd place.", "tags": ["3d", "raymarching", "tdf"], "likes": 53, "viewed": 2268, "published": "Public API", "date": "1543753848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Title: Life (TokyoDemoFest 2018 GLSL Graphics Compo 2nd place)\n// Copyright (c) 2018 setchi\n// License: Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n\nprecision highp float;\n\n#define SHADERTOY 1\n#define PI 3.141592654\n#define saturate(a) clamp(a, 0., 1.)\n#define range(a, b) (step(a, floor(time2)) * step(floor(time2), b))\n\nconst int maxIteration = 128;\nconst float fmaxIteration = float(maxIteration);\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat time0, time1, time2, zoom, a;\nint iter;\n\nfloat box(vec3 p, float b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 hue(float hue) {\n    vec3 rgb = fract(hue + vec3(0., 2. / 3., 1. / 3.));\n    rgb = abs(rgb * 2. - 1.);\n    return clamp(rgb * 3. - 1., 0., 1.);\n}\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot1, rot2, rot3, rot4;\n\nvec2 ifs(vec3 p) {\n    float d1 = 999., d2 = 999.;\n    float range = .8, radius = .5 * (1. + zoom);\n\n    const float maxIter = 8.;\n    for (int i = int(maxIter); i > 0; i--) {\n        if (i <= iter) {\n            break;\n        }\n\n        float ratio = float(i) / maxIter;\n        float bx = box(p, radius * ratio);\n        d1 = mix(d1, min(d1, bx), float(i > iter + 1));\n        d2 = min(d2, bx);\n\n        ratio *= ratio;\n\n        p.xz = abs(p.xz) - range * ratio * .7;\n        p.xz *= rot1;\n        p.yz *= rot3;\n        p.yx *= rot2;\n\n        p.yz = abs(p.yz) - range * ratio * .7;\n        p.xz *= rot1;\n        p.yz *= rot4;\n        p.yx *= rot2;\n    }\n\n    return vec2(d1, d2);\n}\n\nfloat map(vec3 p) {\n    vec2 d = ifs(p);\n    return mix(d.y, d.x, mix(a, 1. - a, step(time0, 5.5)));\n}\n\nfloat calcAo(vec3 p, vec3 n) {\n    float sca = 1.0, occ = 0.0;\n\n    for (float i = 0.; i < 5.; i++) {\n        float hr = 0.05 + i * 0.08;\n        float dd = map(n * hr + p);\n        occ += (hr - dd) * sca;\n        sca *= 0.5;\n    }\n\n    return saturate(1.0 - occ);\n}\n\nvec3 intersect(vec3 ro, vec3 ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i < maxIteration; i++) {\n        float res = abs(map(ro + ray * t));\n        if (res < 0.005) return vec3(t, res, i);\n        t += res;\n    }\n\n    return vec3(-1.0);\n}\n\nvec3 normal(vec3 pos, float e) {\n    vec2 eps = vec2(1.0, -1.0) * 0.5773 * e;\n\n    return normalize(eps.xyy * map(pos + eps.xyy) +\n                     eps.yyx * map(pos + eps.yyx) +\n                     eps.yxy * map(pos + eps.yxy) +\n                     eps.xxx * map(pos + eps.xxx));\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    \n    return mat3(cu, cv, cw);\n}\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n\n\tp.xy += 0.1 * time1;\n\n\tfloat f = 0.5000 * noise(p); p = m2 * p * 2.02;\n\tf += 0.2500 * noise(p); p = m2 * p * 2.03;\n\tf += 0.1250 * noise(p); p = m2 * p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\nvec3 sky(vec3 ro, vec3 ray) {\n    vec3 col = vec3(0.);\n\n    float rd = ray.y + 0.3;\n    col = mix(col, vec3(2.0, 0.25, 2.0), 0.5 * smoothstep(0.5, 0.8, fbm((ro.xz + ray.xz * (250000.0 - ro.y) / rd) * 0.000008)));\n    col = mix(col, vec3(0.), pow(1.0 - max(rd, 0.0), 4.0));\n    \n    col = mix(vec3(0.), col, saturate(time1 * 3. - 4.));\n    col = mix(col, vec3(0.), saturate(time1 - 5.25));\n    return col * 1.3;\n}\n\n#define edge(start, end, sStart, sEnd, ecol) if (range(start, end) > 0.) { showEdge = 1.; float offs = pos.y - mix(sStart, sEnd, 0.025 + saturate(time2 - start)); edgeColor = ecol; edgeIntensity = mix(0., edgeIntensity, saturate(1. - abs(offs))); col = mix(col, objectColor, saturate(1. - (offs + 1.5))); }\n\nvec3 render(vec2 p) {\n    float t = time0 * 0.7 - 1.;\n    float offs = mix(1., hash11(max(1., floor(t * 4.))), smoothstep(0., .5, time0));\n    vec3 ro = vec3(cos(t * 3.5) * 11., sin(t * 3.9) * 4.5, sin(t * 1.5) * 10.) * 0.7;\n\n    t = time1 * 0.7;\n    offs = mix(mix(1., hash11(max(1., floor(t * 4.))), step(0., time1)), 1., step(4.6, time1));\n    ro = mix(ro, vec3(cos(t * 1.5) * 11. * offs, sin(t * 2.) * 4. * offs * 2., sin(t * 1.5) * 20. * offs) * 0.9, smoothstep(0.7, 1., time1));\n    ro = mix(ro, vec3(cos(t * 1.5) * 11., sin(t * 3.9) * 4., sin(t * 1.5) * 10.), smoothstep(4.6, 5.5, time1));\n    ro = mix(ro, vec3(5., 3., 5.), saturate(time1 - 6.7));\n\n    vec3 ta = vec3(0.0, 0.0, (sin(t * 0.55) * 0.5 + 0.5) * 2.0);\n    ta = mix(ta, vec3(0.), saturate(time1 - 6.7));\n\n    mat3 cm = createCamera(ro, ta, 0.);\n    vec3 ray = cm * normalize(vec3(p, 4.0));\n\n    vec3 res = intersect(ro, ray);\n    if (res.y < -0.5) {\n        return sky(ro, ray);\n    }\n\n    vec3 pos = ro + ray * res.x;\n    vec3 nor = normal(pos, 0.008);\n\n    float glowIntensity = saturate(pow(abs(1. - abs(dot(nor, ray))), 1.));\n    vec3 objectColor = (vec3(.003, .001, .0095)\n            * pow(1. / res.z * 1.5, -1.8) + glowIntensity * vec3(.1, .25, .3)) * res.x * 0.3\n            * calcAo(pos, nor)\n            + sky(ro, normalize(reflect(ray, nor))) * .4 * (1. - zoom);\n\n    float a = smoothstep(0.3, 0.7, pow(fract(time0 * 3.), 0.4));\n    float edgeThreshold = mix(0.02, 0.03, (1. - a) * (1. - zoom));\n    float edgeIntensity = smoothstep(edgeThreshold - 0.01, edgeThreshold, length(nor - normal(pos, .015)));\n\n    float noShade = range(-10., 3.);\n    vec3 col = mix(objectColor, vec3(0.), noShade);\n\n    float showEdge = 0.;\n    vec3 edgeColor = vec3(1.);\n    vec3 rainbow = hue(pos.z / 2.);\n    edge(3., 3.5, -2., 2.2, hue(abs(offs) / 5. + .5) * 2.)\n    edge(6., 6.5, -3.5, 2., rainbow)\n    edge(5., 5.5, -3.5, 2., rainbow)\n    edge(10., 10.5, -3.5, 2., rainbow)\n    edge(11.5, 12., -3.5, 2.4, rainbow)\n\n    if (time2 > 16.5) {\n        showEdge = 1.;\n        offs = pos.y - mix(-3.5, 4., saturate(time2 - 16.5));\n        col = mix(objectColor, vec3(0.), saturate(1. - offs));\n        edgeIntensity = mix(0., edgeIntensity, saturate(1. - (offs + .6)));\n    }\n\n    col += edgeColor * edgeIntensity * step(1., zoom + noShade + showEdge);\n    col = mix(col, 1. - col, zoom);\n    return col;\n}\n\nvec2 shake(float t) {\n    float s = t * 50.0;\n    return (vec2(hash11(s), hash11(s + 11.0)) * 2.0 - 1.0) * exp(-5.0 * t) * 0.2;\n}\n\nvec3 vignette(vec2 p) {\n    p *= 1.0 - p.yx;\n    return vec3(1.2, 1.1, .85) * pow(16. * p.x * p.y * (1. - p.x) * (1. - p.y), 0.125);\n}\n\nvoid entryPoint(in vec2 coord, in vec2 resolution, in float time, out vec4 color) {\n    vec2 p = (coord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n\n    time0 = mod(time * 0.4, 11.);\n    time1 = time0 - 11. / 4.;\n    time2 = time1 * 0.7 * 4.;\n\n    float t = time0 * 3.;\n    iter = int(mix(clamp(14. - floor(t), 0., 7.), min(8., floor(t) - 24.), step(24., floor(t))));\n    a = mix(1., smoothstep(0.3, 0.7, pow(fract(t), 0.4)), step(7.5, t));\n\n    t = time1 * 3.;\n    float angle = step(1.2, time1) * (floor(t + 0.5) + smoothstep(0.3, 0.7, pow(fract(t + 0.5), 0.4)));\n\n    rot1 = rot(0.785397);\n    rot2 = rot(1.7079);\n    rot3 = rot(angle * 1.2 + 424. + step(7.035716, time0) * 3.);\n    rot4 = rot(angle * 1.2 + 226.);\n\n    zoom = range(8., 9.) + range(11., 11.5);\n\n    p = mix(p, vec2(1. + hash11(p.y) * 10., p.y), saturate(time0 - 10.33) * 5.);\n    p += shake(fract(time1 * 2.)) * 0.10;\n    p *= 1.0 + 5. * pow(length(p), 1.5) * zoom;\n\n    vec3 col = render(p);\n    col *= vignette(coord.xy / resolution.xy);\n    col = mix(col, vec3(0.), saturate(time0 - 10.33) * 10. + step(time, 0.));\n\n    color = vec4(col, 0.);\n}\n\nvoid\n#if SHADERTOY == 1\nmainImage(out vec4 fragColor, in vec2 fragCoord) { entryPoint(fragCoord.xy, iResolution.xy, iTime, fragColor); }\n#else\nmain(void) { entryPoint(gl_FragCoord.xy, resolution.xy, time, gl_FragColor); }\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyfDG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[553, 553, 581, 581, 676], [678, 678, 697, 697, 763], [765, 765, 786, 786, 915], [917, 917, 940, 940, 1055], [1087, 1087, 1105, 1105, 1771], [1773, 1773, 1792, 1792, 1875], [1877, 1877, 1907, 1907, 2143], [2145, 2145, 2180, 2180, 2392], [2394, 2394, 2426, 2426, 2682], [2684, 2684, 2731, 2731, 2924], [2926, 2926, 2946, 2946, 3034], [3036, 3036, 3057, 3057, 3337], [3339, 3339, 3358, 3358, 3610], [3612, 3612, 3641, 3641, 4024], [6700, 6700, 6721, 6721, 6829], [6831, 6831, 6854, 6854, 6965], [6967, 6967, 7050, 7050, 8101]], "test": "error"}
{"id": "XtyfRc", "name": "thing_14", "author": "balkhan", "description": " ", "tags": ["3d", "raymarching"], "likes": 16, "viewed": 595, "published": "Public API", "date": "1545015904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define E 0.0001\n\nvoid rotate(inout vec2 p, float a)\n{\n\tp = vec2(cos(a)*p.x+sin(a)*p.y, -sin(a)*p.x+cos(a)*p.y);\n}\n\nvec3 h;\n\nfloat mylength(vec3 p) {return max(abs(p.z), max(abs(p.x), abs(p.y)));}\n\nvec2 modA(vec2 p, float c)\n{\n    float an = 6.28/c;\n    float a = atan(p.x, p.y)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p)\n{\n\tfloat m = 1e5;\n    p.x -= 1.5*cos(iTime*.25);\n    p.y += 1.5*sin(iTime*.5);\n\trotate(p.xz, .25*sin(iTime));   \n    vec3 op = p;\n    \n    float a = p.z*1.+ iTime*.0;\n    \n    p.xy += vec2(cos(a), sin(a))*.125;\n    m = max(length(p.xy)-.7, -(length(p.xy)-.5));\n    \n    m = abs(m)+.001;\n    \n    h += vec3(.7, .42, .3)/max(.25, m*m*.0001 + 1.81);\n    \n    p = op;\n    p.xy += .5*vec2(cos(a), sin(a))*.6;\n    p.xy = modA(p.xy, 5.);p.x-=.75;\n    p.z -= 2.-iTime;\n    float id = floor(p.z);\n    p.z = fract(p.z)-.5;\n    float e = mix(length(p), mylength(p), ceil(mod(id, 2.)) )-.125;\n    e = abs(e)-.001;\n\n    e = abs(e)+0.001;\n    m = min(m, e*.25);\n    h += vec3(.51, .5, .3)/max(.25, e*e*100. + .181);\n\n    p = op;\n//    p.xy += vec2(cos(a), sin(a))*.6;\n    rotate(p.xy, a*.1-iTime*.5);\n\n    \n    p.xy = fract(p.xy*.25)-.5;\n    rotate(p.xy, p.z*1.5+iTime*10.*.25+sin(p.z+iTime)*3.14);\n    p.xy = abs(p.xy)-.1051;\n    rotate(p.xy, -p.z*1.5+iTime*-5.*.25+sin(-p.z+iTime*.5)*3.14);\n    p.xy = abs(p.xy)-.051;\n    \n    \n    float s = length(p.xy)-.0151+(.0071+1.0*.027*cos(p.z*1.*.5-(2.+iTime)));\n    \n    m = min(s, m);\n    \n    h += vec3(.1, .418, .93)/max(.25, s*s*10. + .81);\n    return m;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    h -= h ;\n    vec2 R = iResolution.xy,u = (f-R*.5)/R.y;\n\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(.0,.0,-1.);\n    vec3 rd = vec3(u.xy, 1.);\n    \n    vec2 md = vec2(0.);\n    vec3 p;\n    for (int i = 0; i < 250; i++)\n    {\n        p = ro + rd*md.y;\n    \tmd.x = map(p);\n        md.y += md.x;\n        if (md.y > 10. || md.x <= E)\n            break;\n        \n    }\n\tcol = h*.01;\n    col /= max(1., md.y*.5);\n    \n    col+= md.y * vec3(.01, .13, .01)*0.051;\n    col*= 1.-(length(u)*.75);\n    o = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyfRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[133, 133, 169, 169, 229], [240, 240, 264, 264, 311], [313, 313, 341, 341, 471], [473, 473, 492, 492, 1682], [1684, 1684, 1725, 1725, 2238]], "test": "ok"}
{"id": "XtyfWc", "name": "Funky Circles", "author": "XRNZ", "description": "funky circles !", "tags": ["funkycircles"], "likes": 2, "viewed": 64, "published": "Public", "date": "1544193215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    vec2 px = vec2(uv.x*iResolution.x/iResolution.y,uv.y);\n\n    float x1 = cos(1.44*iTime);\n    float x2 = cos(1.66*iTime);\n    float x3 = cos(1.77*iTime);\n    \n    float d = distance(px,vec2(x1,0)) * distance(px,vec2(-x2,0)) / distance(px,vec2(0.5*x3,0));\n    \n    float freq = d * exp(3.*(.55+.45*cos(1.0*iTime)));\n    \n    float r = step(0.9,sin(freq));\n    float g = step(0.9,sin(1.5*freq));\n    float b = step(0.9,sin(2.2*freq));\n    \n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyfWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 630]], "test": "ok"}
